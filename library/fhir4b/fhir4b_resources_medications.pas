unit fhir4b_resources_medications;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir4b.inc}

interface

// Generated on Mon, Dec 27, 2021 21:46+1100 for FHIR v4.3.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities,  
  fhir4b_base, fhir4b_enums, fhir4b_types, fhir4b_resources_base, fhir4b_resources_canonical;



type
{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  TFhirAdministrableProductDefinitionProperty = class;
  TFhirAdministrableProductDefinitionPropertyList = class;
  TFhirAdministrableProductDefinitionRouteOfAdministration = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationList = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod = class;
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList = class;
  TFhirAdministrableProductDefinition = class;
  TFhirAdministrableProductDefinitionList = class;
{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_INGREDIENT}
  TFhirIngredientManufacturer = class;
  TFhirIngredientManufacturerList = class;
  TFhirIngredientSubstance = class;
  TFhirIngredientSubstanceList = class;
  TFhirIngredientSubstanceStrength = class;
  TFhirIngredientSubstanceStrengthList = class;
  TFhirIngredientSubstanceStrengthReferenceStrength = class;
  TFhirIngredientSubstanceStrengthReferenceStrengthList = class;
  TFhirIngredient = class;
  TFhirIngredientList = class;
{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  TFhirManufacturedItemDefinitionProperty = class;
  TFhirManufacturedItemDefinitionPropertyList = class;
  TFhirManufacturedItemDefinition = class;
  TFhirManufacturedItemDefinitionList = class;
{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEDICATION}
  TFhirMedicationIngredient = class;
  TFhirMedicationIngredientList = class;
  TFhirMedicationBatch = class;
  TFhirMedicationBatchList = class;
  TFhirMedication = class;
  TFhirMedicationList = class;
{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  TFhirMedicationKnowledgeRelatedMedicationKnowledge = class;
  TFhirMedicationKnowledgeRelatedMedicationKnowledgeList = class;
  TFhirMedicationKnowledgeMonograph = class;
  TFhirMedicationKnowledgeMonographList = class;
  TFhirMedicationKnowledgeIngredient = class;
  TFhirMedicationKnowledgeIngredientList = class;
  TFhirMedicationKnowledgeCost = class;
  TFhirMedicationKnowledgeCostList = class;
  TFhirMedicationKnowledgeMonitoringProgram = class;
  TFhirMedicationKnowledgeMonitoringProgramList = class;
  TFhirMedicationKnowledgeAdministrationGuidelines = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesList = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesDosage = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesDosageList = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics = class;
  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList = class;
  TFhirMedicationKnowledgeMedicineClassification = class;
  TFhirMedicationKnowledgeMedicineClassificationList = class;
  TFhirMedicationKnowledgePackaging = class;
  TFhirMedicationKnowledgePackagingList = class;
  TFhirMedicationKnowledgeDrugCharacteristic = class;
  TFhirMedicationKnowledgeDrugCharacteristicList = class;
  TFhirMedicationKnowledgeRegulatory = class;
  TFhirMedicationKnowledgeRegulatoryList = class;
  TFhirMedicationKnowledgeRegulatorySubstitution = class;
  TFhirMedicationKnowledgeRegulatorySubstitutionList = class;
  TFhirMedicationKnowledgeRegulatorySchedule = class;
  TFhirMedicationKnowledgeRegulatoryScheduleList = class;
  TFhirMedicationKnowledgeRegulatoryMaxDispense = class;
  TFhirMedicationKnowledgeRegulatoryMaxDispenseList = class;
  TFhirMedicationKnowledgeKinetics = class;
  TFhirMedicationKnowledgeKineticsList = class;
  TFhirMedicationKnowledge = class;
  TFhirMedicationKnowledgeList = class;
{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  TFhirMedicinalProductDefinitionContact = class;
  TFhirMedicinalProductDefinitionContactList = class;
  TFhirMedicinalProductDefinitionName = class;
  TFhirMedicinalProductDefinitionNameList = class;
  TFhirMedicinalProductDefinitionNameNamePart = class;
  TFhirMedicinalProductDefinitionNameNamePartList = class;
  TFhirMedicinalProductDefinitionNameCountryLanguage = class;
  TFhirMedicinalProductDefinitionNameCountryLanguageList = class;
  TFhirMedicinalProductDefinitionCrossReference = class;
  TFhirMedicinalProductDefinitionCrossReferenceList = class;
  TFhirMedicinalProductDefinitionOperation = class;
  TFhirMedicinalProductDefinitionOperationList = class;
  TFhirMedicinalProductDefinitionCharacteristic = class;
  TFhirMedicinalProductDefinitionCharacteristicList = class;
  TFhirMedicinalProductDefinition = class;
  TFhirMedicinalProductDefinitionList = class;
{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  TFhirNutritionProductNutrient = class;
  TFhirNutritionProductNutrientList = class;
  TFhirNutritionProductIngredient = class;
  TFhirNutritionProductIngredientList = class;
  TFhirNutritionProductProductCharacteristic = class;
  TFhirNutritionProductProductCharacteristicList = class;
  TFhirNutritionProductInstance = class;
  TFhirNutritionProductInstanceList = class;
  TFhirNutritionProduct = class;
  TFhirNutritionProductList = class;
{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  TFhirPackagedProductDefinitionLegalStatusOfSupply = class;
  TFhirPackagedProductDefinitionLegalStatusOfSupplyList = class;
  TFhirPackagedProductDefinitionPackage = class;
  TFhirPackagedProductDefinitionPackageList = class;
  TFhirPackagedProductDefinitionPackageProperty = class;
  TFhirPackagedProductDefinitionPackagePropertyList = class;
  TFhirPackagedProductDefinitionPackageContainedItem = class;
  TFhirPackagedProductDefinitionPackageContainedItemList = class;
  TFhirPackagedProductDefinition = class;
  TFhirPackagedProductDefinitionList = class;
{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  TFhirRegulatedAuthorizationCase = class;
  TFhirRegulatedAuthorizationCaseList = class;
  TFhirRegulatedAuthorization = class;
  TFhirRegulatedAuthorizationList = class;
{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_SUBSTANCE}
  TFhirSubstanceInstance = class;
  TFhirSubstanceInstanceList = class;
  TFhirSubstanceIngredient = class;
  TFhirSubstanceIngredientList = class;
  TFhirSubstance = class;
  TFhirSubstanceList = class;
{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  TFhirSubstanceDefinitionMoiety = class;
  TFhirSubstanceDefinitionMoietyList = class;
  TFhirSubstanceDefinitionProperty = class;
  TFhirSubstanceDefinitionPropertyList = class;
  TFhirSubstanceDefinitionMolecularWeight = class;
  TFhirSubstanceDefinitionMolecularWeightList = class;
  TFhirSubstanceDefinitionStructure = class;
  TFhirSubstanceDefinitionStructureList = class;
  TFhirSubstanceDefinitionStructureRepresentation = class;
  TFhirSubstanceDefinitionStructureRepresentationList = class;
  TFhirSubstanceDefinitionCode = class;
  TFhirSubstanceDefinitionCodeList = class;
  TFhirSubstanceDefinitionName = class;
  TFhirSubstanceDefinitionNameList = class;
  TFhirSubstanceDefinitionNameOfficial = class;
  TFhirSubstanceDefinitionNameOfficialList = class;
  TFhirSubstanceDefinitionRelationship = class;
  TFhirSubstanceDefinitionRelationshipList = class;
  TFhirSubstanceDefinitionSourceMaterial = class;
  TFhirSubstanceDefinitionSourceMaterialList = class;
  TFhirSubstanceDefinition = class;
  TFhirSubstanceDefinitionList = class;
{$ENDIF FHIR_SUBSTANCEDEFINITION}




{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
  // Characteristics e.g. a products onset of action.
  TFhirAdministrableProductDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FStatus : TFhirCodeableConcept;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetStatus(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionProperty; overload;
    function Clone : TFhirAdministrableProductDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to The status of characteristic e.g. assigned or pending. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of characteristic e.g. assigned or pending.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

  end;

  TFhirAdministrableProductDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionPropertyList;
    function GetCurrent : TFhirAdministrableProductDefinitionProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionProperty read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionPropertyList; overload;
    function Clone : TFhirAdministrableProductDefinitionPropertyList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionPropertyListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionProperty to the end of the list.
    function Append : TFhirAdministrableProductDefinitionProperty;
    
    // Add an already existing FhirAdministrableProductDefinitionProperty to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinitionProperty) : TFhirAdministrableProductDefinitionProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionProperty) : Integer;
    
    // Insert FhirAdministrableProductDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionProperty;
    
    // Insert an existing FhirAdministrableProductDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionProperty);
    
    // Get the iIndexth FhirAdministrableProductDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionProperties[index : Integer] : TFhirAdministrableProductDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route.
  TFhirAdministrableProductDefinitionRouteOfAdministration = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FFirstDose : TFhirQuantity;
    FMaxSingleDose : TFhirQuantity;
    FMaxDosePerDay : TFhirQuantity;
    FMaxDosePerTreatmentPeriod : TFhirRatio;
    FMaxTreatmentPeriod : TFhirDuration;
    FtargetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetFirstDose(value : TFhirQuantity);
    procedure SetMaxSingleDose(value : TFhirQuantity);
    procedure SetMaxDosePerDay(value : TFhirQuantity);
    procedure SetMaxDosePerTreatmentPeriod(value : TFhirRatio);
    procedure SetMaxTreatmentPeriod(value : TFhirDuration);
    function GetTargetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
    function GetHasTargetSpeciesList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministration; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded expression for the route. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded expression for the route.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement. (defined for API consistency)
    property firstDose : TFhirQuantity read FFirstDose write SetFirstDose;
    // The first dose (dose quantity) administered can be specified for the product, using a numerical value and its unit of measurement.
    property firstDoseElement : TFhirQuantity read FFirstDose write SetFirstDose;

    // Typed access to The maximum single dose that can be administered, can be specified using a numerical value and its unit of measurement. (defined for API consistency)
    property maxSingleDose : TFhirQuantity read FMaxSingleDose write SetMaxSingleDose;
    // The maximum single dose that can be administered, can be specified using a numerical value and its unit of measurement.
    property maxSingleDoseElement : TFhirQuantity read FMaxSingleDose write SetMaxSingleDose;

    // Typed access to The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered. (defined for API consistency)
    property maxDosePerDay : TFhirQuantity read FMaxDosePerDay write SetMaxDosePerDay;
    // The maximum dose per day (maximum dose quantity to be administered in any one 24-h period) that can be administered.
    property maxDosePerDayElement : TFhirQuantity read FMaxDosePerDay write SetMaxDosePerDay;

    // Typed access to The maximum dose per treatment period that can be administered. (defined for API consistency)
    property maxDosePerTreatmentPeriod : TFhirRatio read FMaxDosePerTreatmentPeriod write SetMaxDosePerTreatmentPeriod;
    // The maximum dose per treatment period that can be administered.
    property maxDosePerTreatmentPeriodElement : TFhirRatio read FMaxDosePerTreatmentPeriod write SetMaxDosePerTreatmentPeriod;

    // Typed access to The maximum treatment period during which an Investigational Medicinal Product can be administered. (defined for API consistency)
    property maxTreatmentPeriod : TFhirDuration read FMaxTreatmentPeriod write SetMaxTreatmentPeriod;
    // The maximum treatment period during which an Investigational Medicinal Product can be administered.
    property maxTreatmentPeriodElement : TFhirDuration read FMaxTreatmentPeriod write SetMaxTreatmentPeriod;

    // A species for which this route applies.
    property targetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList read GetTargetSpeciesList;
    property hasTargetSpeciesList : boolean read GetHasTargetSpeciesList;

  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
    function GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministration;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionRouteOfAdministration read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationList; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionRouteOfAdministration to the end of the list.
    function Append : TFhirAdministrableProductDefinitionRouteOfAdministration;
    
    // Add an already existing FhirAdministrableProductDefinitionRouteOfAdministration to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinitionRouteOfAdministration) : TFhirAdministrableProductDefinitionRouteOfAdministration; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionRouteOfAdministration) : Integer;
    
    // Insert FhirAdministrableProductDefinitionRouteOfAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    
    // Insert an existing FhirAdministrableProductDefinitionRouteOfAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
    
    // Get the iIndexth FhirAdministrableProductDefinitionRouteOfAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionRouteOfAdministrations[index : Integer] : TFhirAdministrableProductDefinitionRouteOfAdministration read GetItemN write SetItemN; default;
  End;

  // A species for which this route applies.
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FwithdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetWithdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    function GetHasWithdrawalPeriodList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded expression for the species. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded expression for the species.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A species specific time during which consumption of animal product is not appropriate.
    property withdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList read GetWithdrawalPeriodList;
    property hasWithdrawalPeriodList : boolean read GetHasWithdrawalPeriodList;

  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
    function GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies to the end of the list.
    function Append : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    
    // Add an already existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies) : Integer;
    
    // Insert FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    
    // Insert an existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    
    // Get the iIndexth FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies[index : Integer] : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies read GetItemN write SetItemN; default;
  End;

  // A species specific time during which consumption of animal product is not appropriate.
  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod = class (TFhirBackboneElement)
  protected
    FTissue : TFhirCodeableConcept;
    FValue : TFhirQuantity;
    FSupportingInformation : TFhirString;
    procedure SetTissue(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirQuantity);
    procedure SetSupportingInformation(value : TFhirString);
    function GetSupportingInformationST : String;
    procedure SetSupportingInformationST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded expression for the type of tissue for which the withdrawal period applues, e.g. meat, milk. (defined for API consistency)
    property tissue : TFhirCodeableConcept read FTissue write SetTissue;
    // Coded expression for the type of tissue for which the withdrawal period applues, e.g. meat, milk.
    property tissueElement : TFhirCodeableConcept read FTissue write SetTissue;

    // Typed access to A value for the time. (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // A value for the time.
    property valueElement : TFhirQuantity read FValue write SetValue;

    // Typed access to Extra information about the withdrawal period.
    property supportingInformation : String read GetSupportingInformationST write SetSupportingInformationST;
    // Extra information about the withdrawal period.
    property supportingInformationElement : TFhirString read FSupportingInformation write SetSupportingInformation;

  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
    function GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList; overload;
    function Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator;
    
    //  Add a FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod to the end of the list.
    function Append : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // Add an already existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod) : Integer;
    
    // Insert FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // Insert an existing FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    
    // Get the iIndexth FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriods[index : Integer] : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod read GetItemN write SetItemN; default;
  End;

  // A medicinal product in the final form which is suitable for administering to a patient (after any mixing of multiple components, dissolution etc. has been performed).
  TFhirAdministrableProductDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FformOfList : TFhirReferenceList;
    FAdministrableDoseForm : TFhirCodeableConcept;
    FUnitOfPresentation : TFhirCodeableConcept;
    FproducedFromList : TFhirReferenceList;
    FingredientList : TFhirCodeableConceptList;
    FDevice : TFhirReference;
    Fproperty_List : TFhirAdministrableProductDefinitionPropertyList;
    FrouteOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetFormOfList : TFhirReferenceList;
    function GetHasFormOfList : Boolean;
    procedure SetAdministrableDoseForm(value : TFhirCodeableConcept);
    procedure SetUnitOfPresentation(value : TFhirCodeableConcept);
    function GetProducedFromList : TFhirReferenceList;
    function GetHasProducedFromList : Boolean;
    function GetIngredientList : TFhirCodeableConceptList;
    function GetHasIngredientList : Boolean;
    procedure SetDevice(value : TFhirReference);
    function GetProperty_List : TFhirAdministrableProductDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    function GetRouteOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
    function GetHasRouteOfAdministrationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdministrableProductDefinition; overload;
    function Clone : TFhirAdministrableProductDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier for the administrable product.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of this administrable product. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The medicinal product that this is a prepared administrable form of. This element is not a reference to the item(s) that make up this administrable form (for which see AdministrableProductDefinition.producedFrom). It is medicinal product as a whole, which may have several components (as well as packaging, devices etc.), that are given to the patient in this final administrable form. A single medicinal product may have several different administrable products (e.g. a tablet and a cream), and these could have different administrable forms (e.g. tablet as oral solid, or tablet crushed).
    property formOfList : TFhirReferenceList read GetFormOfList;
    property hasFormOfList : boolean read GetHasFormOfList;

    // Typed access to The dose form of the final product after necessary reconstitution or processing. Contrasts to the manufactured dose form (see ManufacturedItemDefinition). If the manufactured form was 'powder for solution for injection', the administrable dose form could be 'solution for injection' (once mixed with another item having manufactured form 'solvent for solution for injection'). (defined for API consistency)
    property administrableDoseForm : TFhirCodeableConcept read FAdministrableDoseForm write SetAdministrableDoseForm;
    // The dose form of the final product after necessary reconstitution or processing. Contrasts to the manufactured dose form (see ManufacturedItemDefinition). If the manufactured form was 'powder for solution for injection', the administrable dose form could be 'solution for injection' (once mixed with another item having manufactured form 'solvent for solution for injection').
    property administrableDoseFormElement : TFhirCodeableConcept read FAdministrableDoseForm write SetAdministrableDoseForm;

    // Typed access to The presentation type in which this item is given to a patient. e.g. for a spray - 'puff' (as in 'contains 100 mcg per puff'), or for a liquid - 'vial' (as in 'contains 5 ml per vial'). (defined for API consistency)
    property unitOfPresentation : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;
    // The presentation type in which this item is given to a patient. e.g. for a spray - 'puff' (as in 'contains 100 mcg per puff'), or for a liquid - 'vial' (as in 'contains 5 ml per vial').
    property unitOfPresentationElement : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;

    // The constituent manufactured item(s) that this administrable product is produced from. Either a single item, or several that are mixed before administration (e.g. a power item and a solvent item, to make a consumable solution). Note the items this is produced from are not raw ingredients (see AdministrableProductDefinition.ingredient), but manufactured medication items (ManufacturedItemDefinitions), which may be combined or prepared and transformed for patient use. The constituent items that this administrable form is produced from are all part of the product (for which see AdministrableProductDefinition.formOf).
    property producedFromList : TFhirReferenceList read GetProducedFromList;
    property hasProducedFromList : boolean read GetHasProducedFromList;

    // The ingredients of this administrable medicinal product. This is only needed if the ingredients are not specified either using ManufacturedItemDefiniton (via AdministrableProductDefinition.producedFrom) to state which component items are used to make this, or using by incoming references from the Ingredient resource, to state in detail which substances exist within this. This element allows a basic coded ingredient to be used.
    property ingredientList : TFhirCodeableConceptList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to A device that is integral to the medicinal product, in effect being considered as an "ingredient" of the medicinal product. This is not intended for devices that are just co-packaged. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // A device that is integral to the medicinal product, in effect being considered as an "ingredient" of the medicinal product. This is not intended for devices that are just co-packaged.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Characteristics e.g. a products onset of action.
    property property_List : TFhirAdministrableProductDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route.
    property routeOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList read GetRouteOfAdministrationList;
    property hasRouteOfAdministrationList : boolean read GetHasRouteOfAdministrationList;

  end;

  TFhirAdministrableProductDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdministrableProductDefinitionList;
    function GetCurrent : TFhirAdministrableProductDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdministrableProductDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdministrableProductDefinition read GetCurrent;
  end;

  TFhirAdministrableProductDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdministrableProductDefinition;
    procedure SetItemN(index : Integer; value : TFhirAdministrableProductDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdministrableProductDefinitionList; overload;
    function Clone : TFhirAdministrableProductDefinitionList; overload;
    function GetEnumerator : TFhirAdministrableProductDefinitionListEnumerator;
    
    //  Add a FhirAdministrableProductDefinition to the end of the list.
    function Append : TFhirAdministrableProductDefinition;
    
    // Add an already existing FhirAdministrableProductDefinition to the end of the list.
    function AddItem(value : TFhirAdministrableProductDefinition) : TFhirAdministrableProductDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdministrableProductDefinition) : Integer;
    
    // Insert FhirAdministrableProductDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdministrableProductDefinition;
    
    // Insert an existing FhirAdministrableProductDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdministrableProductDefinition);
    
    // Get the iIndexth FhirAdministrableProductDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdministrableProductDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdministrableProductDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdministrableProductDefinitions[index : Integer] : TFhirAdministrableProductDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_INGREDIENT}
  // An organization that manufactures this ingredient.
  TFhirIngredientManufacturer = class (TFhirBackboneElement)
  protected
    FRole : TFhirCoding;
    FManufacturer : TFhirReference;
    procedure SetRole(value : TFhirCoding);
    procedure SetManufacturer(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientManufacturer; overload;
    function Clone : TFhirIngredientManufacturer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role. (defined for API consistency)
    property role : TFhirCoding read FRole write SetRole;
    // The way in which this manufacturer is associated with the ingredient. For example whether it is a possible one (others allowed), or an exclusive authorized one for this ingredient. Note that this is not the manufacturing process role.
    property roleElement : TFhirCoding read FRole write SetRole;

    // Typed access to An organization that manufactures this ingredient. (defined for API consistency)
    property manufacturer : TFhirReference read FManufacturer write SetManufacturer;
    // An organization that manufactures this ingredient.
    property manufacturerElement : TFhirReference read FManufacturer write SetManufacturer;

  end;

  TFhirIngredientManufacturerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientManufacturerList;
    function GetCurrent : TFhirIngredientManufacturer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientManufacturerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientManufacturer read GetCurrent;
  end;

  TFhirIngredientManufacturerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientManufacturer;
    procedure SetItemN(index : Integer; value : TFhirIngredientManufacturer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientManufacturerList; overload;
    function Clone : TFhirIngredientManufacturerList; overload;
    function GetEnumerator : TFhirIngredientManufacturerListEnumerator;
    
    //  Add a FhirIngredientManufacturer to the end of the list.
    function Append : TFhirIngredientManufacturer;
    
    // Add an already existing FhirIngredientManufacturer to the end of the list.
    function AddItem(value : TFhirIngredientManufacturer) : TFhirIngredientManufacturer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientManufacturer) : Integer;
    
    // Insert FhirIngredientManufacturer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientManufacturer;
    
    // Insert an existing FhirIngredientManufacturer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientManufacturer);
    
    // Get the iIndexth FhirIngredientManufacturer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientManufacturer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientManufacturer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientManufacturers[index : Integer] : TFhirIngredientManufacturer read GetItemN write SetItemN; default;
  End;

  // The substance that comprises this ingredient.
  TFhirIngredientSubstance = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableReference;
    FstrengthList : TFhirIngredientSubstanceStrengthList;
    procedure SetCode(value : TFhirCodeableReference);
    function GetStrengthList : TFhirIngredientSubstanceStrengthList;
    function GetHasStrengthList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSubstance; overload;
    function Clone : TFhirIngredientSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code or full resource that represents the ingredient substance. (defined for API consistency)
    property code : TFhirCodeableReference read FCode write SetCode;
    // A code or full resource that represents the ingredient substance.
    property codeElement : TFhirCodeableReference read FCode write SetCode;

    // The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item.
    property strengthList : TFhirIngredientSubstanceStrengthList read GetStrengthList;
    property hasStrengthList : boolean read GetHasStrengthList;

  end;

  TFhirIngredientSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSubstanceList;
    function GetCurrent : TFhirIngredientSubstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSubstance read GetCurrent;
  end;

  TFhirIngredientSubstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSubstance;
    procedure SetItemN(index : Integer; value : TFhirIngredientSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSubstanceList; overload;
    function Clone : TFhirIngredientSubstanceList; overload;
    function GetEnumerator : TFhirIngredientSubstanceListEnumerator;
    
    //  Add a FhirIngredientSubstance to the end of the list.
    function Append : TFhirIngredientSubstance;
    
    // Add an already existing FhirIngredientSubstance to the end of the list.
    function AddItem(value : TFhirIngredientSubstance) : TFhirIngredientSubstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSubstance) : Integer;
    
    // Insert FhirIngredientSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSubstance;
    
    // Insert an existing FhirIngredientSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSubstance);
    
    // Get the iIndexth FhirIngredientSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSubstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSubstances[index : Integer] : TFhirIngredientSubstance read GetItemN write SetItemN; default;
  End;

  // The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item.
  TFhirIngredientSubstanceStrength = class (TFhirBackboneElement)
  protected
    FPresentation : TFhirDataType;
    FPresentationText : TFhirString;
    FConcentration : TFhirDataType;
    FConcentrationText : TFhirString;
    FMeasurementPoint : TFhirString;
    FcountryList : TFhirCodeableConceptList;
    FreferenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
    procedure SetPresentation(value : TFhirDataType);
    procedure SetPresentationText(value : TFhirString);
    function GetPresentationTextST : String;
    procedure SetPresentationTextST(value : String);
    procedure SetConcentration(value : TFhirDataType);
    procedure SetConcentrationText(value : TFhirString);
    function GetConcentrationTextST : String;
    procedure SetConcentrationTextST(value : String);
    procedure SetMeasurementPoint(value : TFhirString);
    function GetMeasurementPointST : String;
    procedure SetMeasurementPointST(value : String);
    function GetCountryList : TFhirCodeableConceptList;
    function GetHasCountryList : Boolean;
    function GetReferenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
    function GetHasReferenceStrengthList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSubstanceStrength; overload;
    function Clone : TFhirIngredientSubstanceStrength; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item. (defined for API consistency)
    property presentation : TFhirDataType read FPresentation write SetPresentation;
    // The quantity of substance in the unit of presentation, or in the volume (or mass) of the single pharmaceutical product or manufactured item.
    property presentationElement : TFhirDataType read FPresentation write SetPresentation;

    // Typed access to A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.
    property presentationText : String read GetPresentationTextST write SetPresentationTextST;
    // A textual represention of either the whole of the presentation strength or a part of it - with the rest being in Strength.presentation as a ratio.
    property presentationTextElement : TFhirString read FPresentationText write SetPresentationText;

    // Typed access to The strength per unitary volume (or mass). (defined for API consistency)
    property concentration : TFhirDataType read FConcentration write SetConcentration;
    // The strength per unitary volume (or mass).
    property concentrationElement : TFhirDataType read FConcentration write SetConcentration;

    // Typed access to A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.
    property concentrationText : String read GetConcentrationTextST write SetConcentrationTextST;
    // A textual represention of either the whole of the concentration strength or a part of it - with the rest being in Strength.concentration as a ratio.
    property concentrationTextElement : TFhirString read FConcentrationText write SetConcentrationText;

    // Typed access to For when strength is measured at a particular point or distance.
    property measurementPoint : String read GetMeasurementPointST write SetMeasurementPointST;
    // For when strength is measured at a particular point or distance.
    property measurementPointElement : TFhirString read FMeasurementPoint write SetMeasurementPoint;

    // The country or countries for which the strength range applies.
    property countryList : TFhirCodeableConceptList read GetCountryList;
    property hasCountryList : boolean read GetHasCountryList;

    // Strength expressed in terms of a reference substance.
    property referenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList read GetReferenceStrengthList;
    property hasReferenceStrengthList : boolean read GetHasReferenceStrengthList;

  end;

  TFhirIngredientSubstanceStrengthListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSubstanceStrengthList;
    function GetCurrent : TFhirIngredientSubstanceStrength;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSubstanceStrengthList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSubstanceStrength read GetCurrent;
  end;

  TFhirIngredientSubstanceStrengthList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSubstanceStrength;
    procedure SetItemN(index : Integer; value : TFhirIngredientSubstanceStrength);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSubstanceStrengthList; overload;
    function Clone : TFhirIngredientSubstanceStrengthList; overload;
    function GetEnumerator : TFhirIngredientSubstanceStrengthListEnumerator;
    
    //  Add a FhirIngredientSubstanceStrength to the end of the list.
    function Append : TFhirIngredientSubstanceStrength;
    
    // Add an already existing FhirIngredientSubstanceStrength to the end of the list.
    function AddItem(value : TFhirIngredientSubstanceStrength) : TFhirIngredientSubstanceStrength; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSubstanceStrength) : Integer;
    
    // Insert FhirIngredientSubstanceStrength before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSubstanceStrength;
    
    // Insert an existing FhirIngredientSubstanceStrength before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSubstanceStrength);
    
    // Get the iIndexth FhirIngredientSubstanceStrength. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSubstanceStrength);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSubstanceStrength;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSubstanceStrengths[index : Integer] : TFhirIngredientSubstanceStrength read GetItemN write SetItemN; default;
  End;

  // Strength expressed in terms of a reference substance.
  TFhirIngredientSubstanceStrengthReferenceStrength = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableReference;
    FStrength : TFhirDataType;
    FMeasurementPoint : TFhirString;
    FcountryList : TFhirCodeableConceptList;
    procedure SetSubstance(value : TFhirCodeableReference);
    procedure SetStrength(value : TFhirDataType);
    procedure SetMeasurementPoint(value : TFhirString);
    function GetMeasurementPointST : String;
    procedure SetMeasurementPointST(value : String);
    function GetCountryList : TFhirCodeableConceptList;
    function GetHasCountryList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredientSubstanceStrengthReferenceStrength; overload;
    function Clone : TFhirIngredientSubstanceStrengthReferenceStrength; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Relevant reference substance. (defined for API consistency)
    property substance : TFhirCodeableReference read FSubstance write SetSubstance;
    // Relevant reference substance.
    property substanceElement : TFhirCodeableReference read FSubstance write SetSubstance;

    // Typed access to Strength expressed in terms of a reference substance. (defined for API consistency)
    property strength : TFhirDataType read FStrength write SetStrength;
    // Strength expressed in terms of a reference substance.
    property strengthElement : TFhirDataType read FStrength write SetStrength;

    // Typed access to For when strength is measured at a particular point or distance.
    property measurementPoint : String read GetMeasurementPointST write SetMeasurementPointST;
    // For when strength is measured at a particular point or distance.
    property measurementPointElement : TFhirString read FMeasurementPoint write SetMeasurementPoint;

    // The country or countries for which the strength range applies.
    property countryList : TFhirCodeableConceptList read GetCountryList;
    property hasCountryList : boolean read GetHasCountryList;

  end;

  TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
    function GetCurrent : TFhirIngredientSubstanceStrengthReferenceStrength;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientSubstanceStrengthReferenceStrengthList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredientSubstanceStrengthReferenceStrength read GetCurrent;
  end;

  TFhirIngredientSubstanceStrengthReferenceStrengthList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredientSubstanceStrengthReferenceStrength;
    procedure SetItemN(index : Integer; value : TFhirIngredientSubstanceStrengthReferenceStrength);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientSubstanceStrengthReferenceStrengthList; overload;
    function Clone : TFhirIngredientSubstanceStrengthReferenceStrengthList; overload;
    function GetEnumerator : TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator;
    
    //  Add a FhirIngredientSubstanceStrengthReferenceStrength to the end of the list.
    function Append : TFhirIngredientSubstanceStrengthReferenceStrength;
    
    // Add an already existing FhirIngredientSubstanceStrengthReferenceStrength to the end of the list.
    function AddItem(value : TFhirIngredientSubstanceStrengthReferenceStrength) : TFhirIngredientSubstanceStrengthReferenceStrength; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredientSubstanceStrengthReferenceStrength) : Integer;
    
    // Insert FhirIngredientSubstanceStrengthReferenceStrength before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredientSubstanceStrengthReferenceStrength;
    
    // Insert an existing FhirIngredientSubstanceStrengthReferenceStrength before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredientSubstanceStrengthReferenceStrength);
    
    // Get the iIndexth FhirIngredientSubstanceStrengthReferenceStrength. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredientSubstanceStrengthReferenceStrength);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredientSubstanceStrengthReferenceStrength;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredientSubstanceStrengthReferenceStrengths[index : Integer] : TFhirIngredientSubstanceStrengthReferenceStrength read GetItemN write SetItemN; default;
  End;

  // An ingredient of a manufactured item or pharmaceutical product.
  TFhirIngredient = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    Ffor_List : TFhirReferenceList;
    FRole : TFhirCodeableConcept;
    Ffunction_List : TFhirCodeableConceptList;
    FAllergenicIndicator : TFhirBoolean;
    FmanufacturerList : TFhirIngredientManufacturerList;
    FSubstance : TFhirIngredientSubstance;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetFor_List : TFhirReferenceList;
    function GetHasFor_List : Boolean;
    procedure SetRole(value : TFhirCodeableConcept);
    function GetFunction_List : TFhirCodeableConceptList;
    function GetHasFunction_List : Boolean;
    procedure SetAllergenicIndicator(value : TFhirBoolean);
    function GetAllergenicIndicatorST : Boolean;
    procedure SetAllergenicIndicatorST(value : Boolean);
    function GetManufacturerList : TFhirIngredientManufacturerList;
    function GetHasManufacturerList : Boolean;
    procedure SetSubstance(value : TFhirIngredientSubstance);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirIngredient; overload;
    function Clone : TFhirIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // The identifier(s) of this Ingredient that are assigned by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The status of this ingredient. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The product which this ingredient is a constituent part of.
    property for_List : TFhirReferenceList read GetFor_List;
    property hasFor_List : boolean read GetHasFor_List;

    // Typed access to A classification of the ingredient identifying its purpose within the product, e.g. active, inactive. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // A classification of the ingredient identifying its purpose within the product, e.g. active, inactive.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // A classification of the ingredient identifying its precise purpose(s) in the drug product. This extends the Ingredient.role to add more detail. Example: Antioxidant, Alkalizing Agent.
    property function_List : TFhirCodeableConceptList read GetFunction_List;
    property hasFunction_List : boolean read GetHasFunction_List;

    // Typed access to If the ingredient is a known or suspected allergen.
    property allergenicIndicator : Boolean read GetAllergenicIndicatorST write SetAllergenicIndicatorST;
    // If the ingredient is a known or suspected allergen.
    property allergenicIndicatorElement : TFhirBoolean read FAllergenicIndicator write SetAllergenicIndicator;

    // An organization that manufactures this ingredient.
    property manufacturerList : TFhirIngredientManufacturerList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Typed access to The substance that comprises this ingredient. (defined for API consistency)
    property substance : TFhirIngredientSubstance read FSubstance write SetSubstance;
    // The substance that comprises this ingredient.
    property substanceElement : TFhirIngredientSubstance read FSubstance write SetSubstance;

  end;

  TFhirIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirIngredientList;
    function GetCurrent : TFhirIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirIngredient read GetCurrent;
  end;

  TFhirIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirIngredient;
    procedure SetItemN(index : Integer; value : TFhirIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirIngredientList; overload;
    function Clone : TFhirIngredientList; overload;
    function GetEnumerator : TFhirIngredientListEnumerator;
    
    //  Add a FhirIngredient to the end of the list.
    function Append : TFhirIngredient;
    
    // Add an already existing FhirIngredient to the end of the list.
    function AddItem(value : TFhirIngredient) : TFhirIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirIngredient) : Integer;
    
    // Insert FhirIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirIngredient;
    
    // Insert an existing FhirIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirIngredient);
    
    // Get the iIndexth FhirIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirIngredients[index : Integer] : TFhirIngredient read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
  // General characteristics of this item.
  TFhirManufacturedItemDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirManufacturedItemDefinitionProperty; overload;
    function Clone : TFhirManufacturedItemDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirManufacturedItemDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirManufacturedItemDefinitionPropertyList;
    function GetCurrent : TFhirManufacturedItemDefinitionProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirManufacturedItemDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirManufacturedItemDefinitionProperty read GetCurrent;
  end;

  TFhirManufacturedItemDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirManufacturedItemDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirManufacturedItemDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirManufacturedItemDefinitionPropertyList; overload;
    function Clone : TFhirManufacturedItemDefinitionPropertyList; overload;
    function GetEnumerator : TFhirManufacturedItemDefinitionPropertyListEnumerator;
    
    //  Add a FhirManufacturedItemDefinitionProperty to the end of the list.
    function Append : TFhirManufacturedItemDefinitionProperty;
    
    // Add an already existing FhirManufacturedItemDefinitionProperty to the end of the list.
    function AddItem(value : TFhirManufacturedItemDefinitionProperty) : TFhirManufacturedItemDefinitionProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirManufacturedItemDefinitionProperty) : Integer;
    
    // Insert FhirManufacturedItemDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirManufacturedItemDefinitionProperty;
    
    // Insert an existing FhirManufacturedItemDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirManufacturedItemDefinitionProperty);
    
    // Get the iIndexth FhirManufacturedItemDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirManufacturedItemDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirManufacturedItemDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirManufacturedItemDefinitionProperties[index : Integer] : TFhirManufacturedItemDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // The definition and characteristics of a medicinal manufactured item, such as a tablet or capsule, as contained in a packaged medicinal product.
  TFhirManufacturedItemDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FManufacturedDoseForm : TFhirCodeableConcept;
    FUnitOfPresentation : TFhirCodeableConcept;
    FmanufacturerList : TFhirReferenceList;
    FingredientList : TFhirCodeableConceptList;
    Fproperty_List : TFhirManufacturedItemDefinitionPropertyList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetManufacturedDoseForm(value : TFhirCodeableConcept);
    procedure SetUnitOfPresentation(value : TFhirCodeableConcept);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetIngredientList : TFhirCodeableConceptList;
    function GetHasIngredientList : Boolean;
    function GetProperty_List : TFhirManufacturedItemDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirManufacturedItemDefinition; overload;
    function Clone : TFhirManufacturedItemDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of this item. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Dose form as manufactured and before any transformation into the pharmaceutical product. (defined for API consistency)
    property manufacturedDoseForm : TFhirCodeableConcept read FManufacturedDoseForm write SetManufacturedDoseForm;
    // Dose form as manufactured and before any transformation into the pharmaceutical product.
    property manufacturedDoseFormElement : TFhirCodeableConcept read FManufacturedDoseForm write SetManufacturedDoseForm;

    // Typed access to The real world units in which the quantity of the manufactured item is described. (defined for API consistency)
    property unitOfPresentation : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;
    // The real world units in which the quantity of the manufactured item is described.
    property unitOfPresentationElement : TFhirCodeableConcept read FUnitOfPresentation write SetUnitOfPresentation;

    // Manufacturer of the item (Note that this should be named "manufacturer" but it currently causes technical issues).
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // The ingredients of this manufactured item. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource.
    property ingredientList : TFhirCodeableConceptList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // General characteristics of this item.
    property property_List : TFhirManufacturedItemDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

  end;

  TFhirManufacturedItemDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirManufacturedItemDefinitionList;
    function GetCurrent : TFhirManufacturedItemDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirManufacturedItemDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirManufacturedItemDefinition read GetCurrent;
  end;

  TFhirManufacturedItemDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirManufacturedItemDefinition;
    procedure SetItemN(index : Integer; value : TFhirManufacturedItemDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirManufacturedItemDefinitionList; overload;
    function Clone : TFhirManufacturedItemDefinitionList; overload;
    function GetEnumerator : TFhirManufacturedItemDefinitionListEnumerator;
    
    //  Add a FhirManufacturedItemDefinition to the end of the list.
    function Append : TFhirManufacturedItemDefinition;
    
    // Add an already existing FhirManufacturedItemDefinition to the end of the list.
    function AddItem(value : TFhirManufacturedItemDefinition) : TFhirManufacturedItemDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirManufacturedItemDefinition) : Integer;
    
    // Insert FhirManufacturedItemDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirManufacturedItemDefinition;
    
    // Insert an existing FhirManufacturedItemDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirManufacturedItemDefinition);
    
    // Get the iIndexth FhirManufacturedItemDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirManufacturedItemDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirManufacturedItemDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirManufacturedItemDefinitions[index : Integer] : TFhirManufacturedItemDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEDICATION}
  // Identifies a particular constituent of interest in the product.
  TFhirMedicationIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirDataType;
    FIsActive : TFhirBoolean;
    FStrength : TFhirRatio;
    procedure SetItem(value : TFhirDataType);
    procedure SetIsActive(value : TFhirBoolean);
    function GetIsActiveST : Boolean;
    procedure SetIsActiveST(value : Boolean);
    procedure SetStrength(value : TFhirRatio);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationIngredient; overload;
    function Clone : TFhirMedicationIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual ingredient - either a substance (simple ingredient) or another medication of a medication. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // The actual ingredient - either a substance (simple ingredient) or another medication of a medication.
    property itemElement : TFhirDataType read FItem write SetItem;

    // Typed access to Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActive : Boolean read GetIsActiveST write SetIsActiveST;
    // Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActiveElement : TFhirBoolean read FIsActive write SetIsActive;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet. (defined for API consistency)
    property strength : TFhirRatio read FStrength write SetStrength;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet.
    property strengthElement : TFhirRatio read FStrength write SetStrength;

  end;

  TFhirMedicationIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationIngredientList;
    function GetCurrent : TFhirMedicationIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationIngredient read GetCurrent;
  end;

  TFhirMedicationIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationIngredientList; overload;
    function Clone : TFhirMedicationIngredientList; overload;
    function GetEnumerator : TFhirMedicationIngredientListEnumerator;
    
    //  Add a FhirMedicationIngredient to the end of the list.
    function Append : TFhirMedicationIngredient;
    
    // Add an already existing FhirMedicationIngredient to the end of the list.
    function AddItem(value : TFhirMedicationIngredient) : TFhirMedicationIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationIngredient) : Integer;
    
    // Insert FhirMedicationIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationIngredient;
    
    // Insert an existing FhirMedicationIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationIngredient);
    
    // Get the iIndexth FhirMedicationIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationIngredients[index : Integer] : TFhirMedicationIngredient read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationBatch = class (TFhirBackboneElement)
  protected
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDateTime;
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetExpirationDate(value : TFhirDateTime);
    function GetExpirationDateST : TFslDateTime;
    procedure SetExpirationDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationBatch; overload;
    function Clone : TFhirMedicationBatch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The assigned lot number of a batch of the specified product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // The assigned lot number of a batch of the specified product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to When this specific batch of product will expire.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // When this specific batch of product will expire.
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

  end;

  TFhirMedicationBatchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationBatchList;
    function GetCurrent : TFhirMedicationBatch;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationBatchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationBatch read GetCurrent;
  end;

  TFhirMedicationBatchList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationBatch;
    procedure SetItemN(index : Integer; value : TFhirMedicationBatch);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationBatchList; overload;
    function Clone : TFhirMedicationBatchList; overload;
    function GetEnumerator : TFhirMedicationBatchListEnumerator;
    
    //  Add a FhirMedicationBatch to the end of the list.
    function Append : TFhirMedicationBatch;
    
    // Add an already existing FhirMedicationBatch to the end of the list.
    function AddItem(value : TFhirMedicationBatch) : TFhirMedicationBatch; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationBatch) : Integer;
    
    // Insert FhirMedicationBatch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationBatch;
    
    // Insert an existing FhirMedicationBatch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationBatch);
    
    // Get the iIndexth FhirMedicationBatch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationBatch);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationBatch;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationBatches[index : Integer] : TFhirMedicationBatch read GetItemN write SetItemN; default;
  End;

  // This resource is primarily used for the identification and definition of a medication for the purposes of prescribing, dispensing, and administering a medication as well as for making statements about medication use.
  TFhirMedication = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FManufacturer : TFhirReference;
    FForm : TFhirCodeableConcept;
    FAmount : TFhirRatio;
    FingredientList : TFhirMedicationIngredientList;
    FBatch : TFhirMedicationBatch;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationStatusCodesEnum);
    procedure SetManufacturer(value : TFhirReference);
    procedure SetForm(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirRatio);
    function GetIngredientList : TFhirMedicationIngredientList;
    function GetHasIngredientList : Boolean;
    procedure SetBatch(value : TFhirMedicationBatch);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedication; overload;
    function Clone : TFhirMedication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this medication.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that specify this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A code to indicate if the medication is in active use.
    property status : TFhirMedicationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product. (defined for API consistency)
    property manufacturer : TFhirReference read FManufacturer write SetManufacturer;
    // Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product.
    property manufacturerElement : TFhirReference read FManufacturer write SetManufacturer;

    // Typed access to Describes the form of the item.  Powder; tablets; capsule. (defined for API consistency)
    property form : TFhirCodeableConcept read FForm write SetForm;
    // Describes the form of the item.  Powder; tablets; capsule.
    property formElement : TFhirCodeableConcept read FForm write SetForm;

    // Typed access to Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.). (defined for API consistency)
    property amount : TFhirRatio read FAmount write SetAmount;
    // Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.).
    property amountElement : TFhirRatio read FAmount write SetAmount;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to Information that only applies to packages (not products). (defined for API consistency)
    property batch : TFhirMedicationBatch read FBatch write SetBatch;
    // Information that only applies to packages (not products).
    property batchElement : TFhirMedicationBatch read FBatch write SetBatch;

  end;

  TFhirMedicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationList;
    function GetCurrent : TFhirMedication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedication read GetCurrent;
  end;

  TFhirMedicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedication;
    procedure SetItemN(index : Integer; value : TFhirMedication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationList; overload;
    function Clone : TFhirMedicationList; overload;
    function GetEnumerator : TFhirMedicationListEnumerator;
    
    //  Add a FhirMedication to the end of the list.
    function Append : TFhirMedication;
    
    // Add an already existing FhirMedication to the end of the list.
    function AddItem(value : TFhirMedication) : TFhirMedication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedication) : Integer;
    
    // Insert FhirMedication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedication;
    
    // Insert an existing FhirMedication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedication);
    
    // Get the iIndexth FhirMedication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedications[index : Integer] : TFhirMedication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
  // Associated or related knowledge about a medication.
  TFhirMedicationKnowledgeRelatedMedicationKnowledge = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FreferenceList : TFhirReferenceList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetReferenceList : TFhirReferenceList;
    function GetHasReferenceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    function Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of the associated medication knowledge reference. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of the associated medication knowledge reference.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Associated documentation about the associated medication knowledge.
    property referenceList : TFhirReferenceList read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

  end;

  TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    function GetCurrent : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRelatedMedicationKnowledge read GetCurrent;
  end;

  TFhirMedicationKnowledgeRelatedMedicationKnowledgeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList; overload;
    function Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRelatedMedicationKnowledge to the end of the list.
    function Append : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // Add an already existing FhirMedicationKnowledgeRelatedMedicationKnowledge to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge) : TFhirMedicationKnowledgeRelatedMedicationKnowledge; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRelatedMedicationKnowledge) : Integer;
    
    // Insert FhirMedicationKnowledgeRelatedMedicationKnowledge before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // Insert an existing FhirMedicationKnowledgeRelatedMedicationKnowledge before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    
    // Get the iIndexth FhirMedicationKnowledgeRelatedMedicationKnowledge. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRelatedMedicationKnowledges[index : Integer] : TFhirMedicationKnowledgeRelatedMedicationKnowledge read GetItemN write SetItemN; default;
  End;

  // Associated documentation about the medication.
  TFhirMedicationKnowledgeMonograph = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSource : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMonograph; overload;
    function Clone : TFhirMedicationKnowledgeMonograph; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of documentation about the medication. (e.g. professional monograph, patient education monograph). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of documentation about the medication. (e.g. professional monograph, patient education monograph).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Associated documentation about the medication. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // Associated documentation about the medication.
    property sourceElement : TFhirReference read FSource write SetSource;

  end;

  TFhirMedicationKnowledgeMonographListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMonographList;
    function GetCurrent : TFhirMedicationKnowledgeMonograph;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMonographList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMonograph read GetCurrent;
  end;

  TFhirMedicationKnowledgeMonographList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMonograph;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMonograph);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeMonographList; overload;
    function Clone : TFhirMedicationKnowledgeMonographList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeMonographListEnumerator;
    
    //  Add a FhirMedicationKnowledgeMonograph to the end of the list.
    function Append : TFhirMedicationKnowledgeMonograph;
    
    // Add an already existing FhirMedicationKnowledgeMonograph to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeMonograph) : TFhirMedicationKnowledgeMonograph; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMonograph) : Integer;
    
    // Insert FhirMedicationKnowledgeMonograph before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMonograph;
    
    // Insert an existing FhirMedicationKnowledgeMonograph before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMonograph);
    
    // Get the iIndexth FhirMedicationKnowledgeMonograph. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMonograph);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMonograph;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeMonographs[index : Integer] : TFhirMedicationKnowledgeMonograph read GetItemN write SetItemN; default;
  End;

  // Identifies a particular constituent of interest in the product.
  TFhirMedicationKnowledgeIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirDataType;
    FIsActive : TFhirBoolean;
    FStrength : TFhirRatio;
    procedure SetItem(value : TFhirDataType);
    procedure SetIsActive(value : TFhirBoolean);
    function GetIsActiveST : Boolean;
    procedure SetIsActiveST(value : Boolean);
    procedure SetStrength(value : TFhirRatio);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeIngredient; overload;
    function Clone : TFhirMedicationKnowledgeIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual ingredient - either a substance (simple ingredient) or another medication. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // The actual ingredient - either a substance (simple ingredient) or another medication.
    property itemElement : TFhirDataType read FItem write SetItem;

    // Typed access to Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActive : Boolean read GetIsActiveST write SetIsActiveST;
    // Indication of whether this ingredient affects the therapeutic action of the drug.
    property isActiveElement : TFhirBoolean read FIsActive write SetIsActive;

    // Typed access to Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet. (defined for API consistency)
    property strength : TFhirRatio read FStrength write SetStrength;
    // Specifies how many (or how much) of the items there are in this Medication.  For example, 250 mg per tablet.  This is expressed as a ratio where the numerator is 250mg and the denominator is 1 tablet.
    property strengthElement : TFhirRatio read FStrength write SetStrength;

  end;

  TFhirMedicationKnowledgeIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeIngredientList;
    function GetCurrent : TFhirMedicationKnowledgeIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeIngredient read GetCurrent;
  end;

  TFhirMedicationKnowledgeIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeIngredient;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeIngredientList; overload;
    function Clone : TFhirMedicationKnowledgeIngredientList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeIngredientListEnumerator;
    
    //  Add a FhirMedicationKnowledgeIngredient to the end of the list.
    function Append : TFhirMedicationKnowledgeIngredient;
    
    // Add an already existing FhirMedicationKnowledgeIngredient to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeIngredient) : TFhirMedicationKnowledgeIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeIngredient) : Integer;
    
    // Insert FhirMedicationKnowledgeIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeIngredient;
    
    // Insert an existing FhirMedicationKnowledgeIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeIngredient);
    
    // Get the iIndexth FhirMedicationKnowledgeIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeIngredients[index : Integer] : TFhirMedicationKnowledgeIngredient read GetItemN write SetItemN; default;
  End;

  // The price of the medication.
  TFhirMedicationKnowledgeCost = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSource : TFhirString;
    FCost : TFhirMoney;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirString);
    function GetSourceST : String;
    procedure SetSourceST(value : String);
    procedure SetCost(value : TFhirMoney);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeCost; overload;
    function Clone : TFhirMedicationKnowledgeCost; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The category of the cost information.  For example, manufacturers' cost, patient cost, claim reimbursement cost, actual acquisition cost. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The category of the cost information.  For example, manufacturers' cost, patient cost, claim reimbursement cost, actual acquisition cost.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The source or owner that assigns the price to the medication.
    property source : String read GetSourceST write SetSourceST;
    // The source or owner that assigns the price to the medication.
    property sourceElement : TFhirString read FSource write SetSource;

    // Typed access to The price of the medication. (defined for API consistency)
    property cost : TFhirMoney read FCost write SetCost;
    // The price of the medication.
    property costElement : TFhirMoney read FCost write SetCost;

  end;

  TFhirMedicationKnowledgeCostListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeCostList;
    function GetCurrent : TFhirMedicationKnowledgeCost;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeCostList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeCost read GetCurrent;
  end;

  TFhirMedicationKnowledgeCostList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeCost;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeCost);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeCostList; overload;
    function Clone : TFhirMedicationKnowledgeCostList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeCostListEnumerator;
    
    //  Add a FhirMedicationKnowledgeCost to the end of the list.
    function Append : TFhirMedicationKnowledgeCost;
    
    // Add an already existing FhirMedicationKnowledgeCost to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeCost) : TFhirMedicationKnowledgeCost; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeCost) : Integer;
    
    // Insert FhirMedicationKnowledgeCost before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeCost;
    
    // Insert an existing FhirMedicationKnowledgeCost before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeCost);
    
    // Get the iIndexth FhirMedicationKnowledgeCost. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeCost);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeCost;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeCosts[index : Integer] : TFhirMedicationKnowledgeCost read GetItemN write SetItemN; default;
  End;

  // The program under which the medication is reviewed.
  TFhirMedicationKnowledgeMonitoringProgram = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FName : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMonitoringProgram; overload;
    function Clone : TFhirMedicationKnowledgeMonitoringProgram; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of program under which the medication is monitored. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of program under which the medication is monitored.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Name of the reviewing program.
    property name : String read GetNameST write SetNameST;
    // Name of the reviewing program.
    property nameElement : TFhirString read FName write SetName;

  end;

  TFhirMedicationKnowledgeMonitoringProgramListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMonitoringProgramList;
    function GetCurrent : TFhirMedicationKnowledgeMonitoringProgram;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMonitoringProgramList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMonitoringProgram read GetCurrent;
  end;

  TFhirMedicationKnowledgeMonitoringProgramList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeMonitoringProgramList; overload;
    function Clone : TFhirMedicationKnowledgeMonitoringProgramList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeMonitoringProgramListEnumerator;
    
    //  Add a FhirMedicationKnowledgeMonitoringProgram to the end of the list.
    function Append : TFhirMedicationKnowledgeMonitoringProgram;
    
    // Add an already existing FhirMedicationKnowledgeMonitoringProgram to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeMonitoringProgram) : TFhirMedicationKnowledgeMonitoringProgram; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMonitoringProgram) : Integer;
    
    // Insert FhirMedicationKnowledgeMonitoringProgram before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    
    // Insert an existing FhirMedicationKnowledgeMonitoringProgram before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
    
    // Get the iIndexth FhirMedicationKnowledgeMonitoringProgram. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMonitoringProgram);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMonitoringProgram;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeMonitoringPrograms[index : Integer] : TFhirMedicationKnowledgeMonitoringProgram read GetItemN write SetItemN; default;
  End;

  // Guidelines for the administration of the medication.
  TFhirMedicationKnowledgeAdministrationGuidelines = class (TFhirBackboneElement)
  protected
    FdosageList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
    FIndication : TFhirDataType;
    FpatientCharacteristicsList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
    function GetDosageList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
    function GetHasDosageList : Boolean;
    procedure SetIndication(value : TFhirDataType);
    function GetPatientCharacteristicsList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
    function GetHasPatientCharacteristicsList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeAdministrationGuidelines; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelines; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Dosage for the medication for the specific guidelines.
    property dosageList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

    // Typed access to Indication for use that apply to the specific administration guidelines. (defined for API consistency)
    property indication : TFhirDataType read FIndication write SetIndication;
    // Indication for use that apply to the specific administration guidelines.
    property indicationElement : TFhirDataType read FIndication write SetIndication;

    // Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
    property patientCharacteristicsList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList read GetPatientCharacteristicsList;
    property hasPatientCharacteristicsList : boolean read GetHasPatientCharacteristicsList;

  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeAdministrationGuidelinesList;
    function GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelines;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeAdministrationGuidelines read GetCurrent;
  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelines;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelines);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesList; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator;
    
    //  Add a FhirMedicationKnowledgeAdministrationGuidelines to the end of the list.
    function Append : TFhirMedicationKnowledgeAdministrationGuidelines;
    
    // Add an already existing FhirMedicationKnowledgeAdministrationGuidelines to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeAdministrationGuidelines) : TFhirMedicationKnowledgeAdministrationGuidelines; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeAdministrationGuidelines) : Integer;
    
    // Insert FhirMedicationKnowledgeAdministrationGuidelines before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelines;
    
    // Insert an existing FhirMedicationKnowledgeAdministrationGuidelines before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelines);
    
    // Get the iIndexth FhirMedicationKnowledgeAdministrationGuidelines. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelines);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelines;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeAdministrationGuidelines[index : Integer] : TFhirMedicationKnowledgeAdministrationGuidelines read GetItemN write SetItemN; default;
  End;

  // Dosage for the medication for the specific guidelines.
  TFhirMedicationKnowledgeAdministrationGuidelinesDosage = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FdosageList : TFhirDosageList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of dosage (for example, prophylaxis, maintenance, therapeutic, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of dosage (for example, prophylaxis, maintenance, therapeutic, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Dosage for the medication for the specific guidelines.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
    function GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeAdministrationGuidelinesDosage read GetCurrent;
  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator;
    
    //  Add a FhirMedicationKnowledgeAdministrationGuidelinesDosage to the end of the list.
    function Append : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
    
    // Add an already existing FhirMedicationKnowledgeAdministrationGuidelinesDosage to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage) : Integer;
    
    // Insert FhirMedicationKnowledgeAdministrationGuidelinesDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
    
    // Insert an existing FhirMedicationKnowledgeAdministrationGuidelinesDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
    
    // Get the iIndexth FhirMedicationKnowledgeAdministrationGuidelinesDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeAdministrationGuidelinesDosages[index : Integer] : TFhirMedicationKnowledgeAdministrationGuidelinesDosage read GetItemN write SetItemN; default;
  End;

  // Characteristics of the patient that are relevant to the administration guidelines (for example, height, weight, gender, etc.).
  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics = class (TFhirBackboneElement)
  protected
    FCharacteristic : TFhirDataType;
    FvalueList : TFhirStringList;
    procedure SetCharacteristic(value : TFhirDataType);
    function GetValueList : TFhirStringList;
    function GetHasValueList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender). (defined for API consistency)
    property characteristic : TFhirDataType read FCharacteristic write SetCharacteristic;
    // Specific characteristic that is relevant to the administration guideline (e.g. height, weight, gender).
    property characteristicElement : TFhirDataType read FCharacteristic write SetCharacteristic;

    // The specific characteristic (e.g. height, weight, gender, etc.).
    property valueList : TFhirStringList read GetValueList;
    property hasValueList : boolean read GetHasValueList;

  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
    function GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics read GetCurrent;
  end;

  TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList; overload;
    function Clone : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator;
    
    //  Add a FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics to the end of the list.
    function Append : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
    
    // Add an already existing FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics) : Integer;
    
    // Insert FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
    
    // Insert an existing FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
    
    // Get the iIndexth FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics[index : Integer] : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics read GetItemN write SetItemN; default;
  End;

  // Categorization of the medication within a formulary or classification system.
  TFhirMedicationKnowledgeMedicineClassification = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FclassificationList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeMedicineClassification; overload;
    function Clone : TFhirMedicationKnowledgeMedicineClassification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of category for the medication (for example, therapeutic classification, therapeutic sub-classification).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Specific category assigned to the medication (e.g. anti-infective, anti-hypertensive, antibiotic, etc.).
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

  end;

  TFhirMedicationKnowledgeMedicineClassificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeMedicineClassificationList;
    function GetCurrent : TFhirMedicationKnowledgeMedicineClassification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeMedicineClassificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeMedicineClassification read GetCurrent;
  end;

  TFhirMedicationKnowledgeMedicineClassificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeMedicineClassificationList; overload;
    function Clone : TFhirMedicationKnowledgeMedicineClassificationList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeMedicineClassificationListEnumerator;
    
    //  Add a FhirMedicationKnowledgeMedicineClassification to the end of the list.
    function Append : TFhirMedicationKnowledgeMedicineClassification;
    
    // Add an already existing FhirMedicationKnowledgeMedicineClassification to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeMedicineClassification) : TFhirMedicationKnowledgeMedicineClassification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeMedicineClassification) : Integer;
    
    // Insert FhirMedicationKnowledgeMedicineClassification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    
    // Insert an existing FhirMedicationKnowledgeMedicineClassification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
    
    // Get the iIndexth FhirMedicationKnowledgeMedicineClassification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeMedicineClassification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeMedicineClassification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeMedicineClassifications[index : Integer] : TFhirMedicationKnowledgeMedicineClassification read GetItemN write SetItemN; default;
  End;

  // Information that only applies to packages (not products).
  TFhirMedicationKnowledgePackaging = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgePackaging; overload;
    function Clone : TFhirMedicationKnowledgePackaging; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that defines the specific type of packaging that the medication can be found in (e.g. blister sleeve, tube, bottle). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code that defines the specific type of packaging that the medication can be found in (e.g. blister sleeve, tube, bottle).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The number of product units the package would contain if fully loaded. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of product units the package would contain if fully loaded.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

  end;

  TFhirMedicationKnowledgePackagingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgePackagingList;
    function GetCurrent : TFhirMedicationKnowledgePackaging;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgePackagingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgePackaging read GetCurrent;
  end;

  TFhirMedicationKnowledgePackagingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgePackaging;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgePackaging);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgePackagingList; overload;
    function Clone : TFhirMedicationKnowledgePackagingList; overload;
    function GetEnumerator : TFhirMedicationKnowledgePackagingListEnumerator;
    
    //  Add a FhirMedicationKnowledgePackaging to the end of the list.
    function Append : TFhirMedicationKnowledgePackaging;
    
    // Add an already existing FhirMedicationKnowledgePackaging to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgePackaging) : TFhirMedicationKnowledgePackaging; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgePackaging) : Integer;
    
    // Insert FhirMedicationKnowledgePackaging before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgePackaging;
    
    // Insert an existing FhirMedicationKnowledgePackaging before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgePackaging);
    
    // Get the iIndexth FhirMedicationKnowledgePackaging. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgePackaging);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgePackaging;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgePackagings[index : Integer] : TFhirMedicationKnowledgePackaging read GetItemN write SetItemN; default;
  End;

  // Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
  TFhirMedicationKnowledgeDrugCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeDrugCharacteristic; overload;
    function Clone : TFhirMedicationKnowledgeDrugCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code specifying which characteristic of the medicine is being described (for example, colour, shape, imprint). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code specifying which characteristic of the medicine is being described (for example, colour, shape, imprint).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Description of the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Description of the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMedicationKnowledgeDrugCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeDrugCharacteristicList;
    function GetCurrent : TFhirMedicationKnowledgeDrugCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeDrugCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeDrugCharacteristic read GetCurrent;
  end;

  TFhirMedicationKnowledgeDrugCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeDrugCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeDrugCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeDrugCharacteristicList; overload;
    function Clone : TFhirMedicationKnowledgeDrugCharacteristicList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeDrugCharacteristicListEnumerator;
    
    //  Add a FhirMedicationKnowledgeDrugCharacteristic to the end of the list.
    function Append : TFhirMedicationKnowledgeDrugCharacteristic;
    
    // Add an already existing FhirMedicationKnowledgeDrugCharacteristic to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeDrugCharacteristic) : TFhirMedicationKnowledgeDrugCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeDrugCharacteristic) : Integer;
    
    // Insert FhirMedicationKnowledgeDrugCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeDrugCharacteristic;
    
    // Insert an existing FhirMedicationKnowledgeDrugCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeDrugCharacteristic);
    
    // Get the iIndexth FhirMedicationKnowledgeDrugCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeDrugCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeDrugCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeDrugCharacteristics[index : Integer] : TFhirMedicationKnowledgeDrugCharacteristic read GetItemN write SetItemN; default;
  End;

  // Regulatory information about a medication.
  TFhirMedicationKnowledgeRegulatory = class (TFhirBackboneElement)
  protected
    FRegulatoryAuthority : TFhirReference;
    FsubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    FscheduleList : TFhirMedicationKnowledgeRegulatoryScheduleList;
    FMaxDispense : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    procedure SetRegulatoryAuthority(value : TFhirReference);
    function GetSubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    function GetHasSubstitutionList : Boolean;
    function GetScheduleList : TFhirMedicationKnowledgeRegulatoryScheduleList;
    function GetHasScheduleList : Boolean;
    procedure SetMaxDispense(value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatory; overload;
    function Clone : TFhirMedicationKnowledgeRegulatory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The authority that is specifying the regulations. (defined for API consistency)
    property regulatoryAuthority : TFhirReference read FRegulatoryAuthority write SetRegulatoryAuthority;
    // The authority that is specifying the regulations.
    property regulatoryAuthorityElement : TFhirReference read FRegulatoryAuthority write SetRegulatoryAuthority;

    // Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
    property substitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList read GetSubstitutionList;
    property hasSubstitutionList : boolean read GetHasSubstitutionList;

    // Specifies the schedule of a medication in jurisdiction.
    property scheduleList : TFhirMedicationKnowledgeRegulatoryScheduleList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Typed access to The maximum number of units of the medication that can be dispensed in a period. (defined for API consistency)
    property maxDispense : TFhirMedicationKnowledgeRegulatoryMaxDispense read FMaxDispense write SetMaxDispense;
    // The maximum number of units of the medication that can be dispensed in a period.
    property maxDispenseElement : TFhirMedicationKnowledgeRegulatoryMaxDispense read FMaxDispense write SetMaxDispense;

  end;

  TFhirMedicationKnowledgeRegulatoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatory read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatoryList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatory to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatory;
    
    // Add an already existing FhirMedicationKnowledgeRegulatory to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeRegulatory) : TFhirMedicationKnowledgeRegulatory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatory) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    
    // Insert an existing FhirMedicationKnowledgeRegulatory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatories[index : Integer] : TFhirMedicationKnowledgeRegulatory read GetItemN write SetItemN; default;
  End;

  // Specifies if changes are allowed when dispensing a medication from a regulatory perspective.
  TFhirMedicationKnowledgeRegulatorySubstitution = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FAllowed : TFhirBoolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAllowed(value : TFhirBoolean);
    function GetAllowedST : Boolean;
    procedure SetAllowedST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specifies the type of substitution allowed. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the type of substitution allowed.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Specifies if regulation allows for changes in the medication when dispensing.
    property allowed : Boolean read GetAllowedST write SetAllowedST;
    // Specifies if regulation allows for changes in the medication when dispensing.
    property allowedElement : TFhirBoolean read FAllowed write SetAllowed;

  end;

  TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatorySubstitution;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatorySubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatorySubstitution read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatorySubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatorySubstitutionList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySubstitutionList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatorySubstitution to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // Add an already existing FhirMedicationKnowledgeRegulatorySubstitution to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeRegulatorySubstitution) : TFhirMedicationKnowledgeRegulatorySubstitution; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatorySubstitution) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatorySubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // Insert an existing FhirMedicationKnowledgeRegulatorySubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatorySubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatorySubstitution);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatorySubstitution;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatorySubstitutions[index : Integer] : TFhirMedicationKnowledgeRegulatorySubstitution read GetItemN write SetItemN; default;
  End;

  // Specifies the schedule of a medication in jurisdiction.
  TFhirMedicationKnowledgeRegulatorySchedule = class (TFhirBackboneElement)
  protected
    FSchedule : TFhirCodeableConcept;
    procedure SetSchedule(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatorySchedule; overload;
    function Clone : TFhirMedicationKnowledgeRegulatorySchedule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specifies the specific drug schedule. (defined for API consistency)
    property schedule : TFhirCodeableConcept read FSchedule write SetSchedule;
    // Specifies the specific drug schedule.
    property scheduleElement : TFhirCodeableConcept read FSchedule write SetSchedule;

  end;

  TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryScheduleList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatorySchedule;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryScheduleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatorySchedule read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryScheduleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatorySchedule;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatorySchedule);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatoryScheduleList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryScheduleList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatorySchedule to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatorySchedule;
    
    // Add an already existing FhirMedicationKnowledgeRegulatorySchedule to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeRegulatorySchedule) : TFhirMedicationKnowledgeRegulatorySchedule; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatorySchedule) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatorySchedule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatorySchedule;
    
    // Insert an existing FhirMedicationKnowledgeRegulatorySchedule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatorySchedule);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatorySchedule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatorySchedule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatorySchedule;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatorySchedules[index : Integer] : TFhirMedicationKnowledgeRegulatorySchedule read GetItemN write SetItemN; default;
  End;

  // The maximum number of units of the medication that can be dispensed in a period.
  TFhirMedicationKnowledgeRegulatoryMaxDispense = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FPeriod : TFhirDuration;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetPeriod(value : TFhirDuration);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The maximum number of units of the medication that can be dispensed. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The maximum number of units of the medication that can be dispensed.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The period that applies to the maximum number of units. (defined for API consistency)
    property period : TFhirDuration read FPeriod write SetPeriod;
    // The period that applies to the maximum number of units.
    property periodElement : TFhirDuration read FPeriod write SetPeriod;

  end;

  TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
    function GetCurrent : TFhirMedicationKnowledgeRegulatoryMaxDispense;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeRegulatoryMaxDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeRegulatoryMaxDispense read GetCurrent;
  end;

  TFhirMedicationKnowledgeRegulatoryMaxDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeRegulatoryMaxDispenseList; overload;
    function Clone : TFhirMedicationKnowledgeRegulatoryMaxDispenseList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator;
    
    //  Add a FhirMedicationKnowledgeRegulatoryMaxDispense to the end of the list.
    function Append : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // Add an already existing FhirMedicationKnowledgeRegulatoryMaxDispense to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeRegulatoryMaxDispense) : TFhirMedicationKnowledgeRegulatoryMaxDispense; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeRegulatoryMaxDispense) : Integer;
    
    // Insert FhirMedicationKnowledgeRegulatoryMaxDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // Insert an existing FhirMedicationKnowledgeRegulatoryMaxDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    
    // Get the iIndexth FhirMedicationKnowledgeRegulatoryMaxDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeRegulatoryMaxDispense;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeRegulatoryMaxDispenses[index : Integer] : TFhirMedicationKnowledgeRegulatoryMaxDispense read GetItemN write SetItemN; default;
  End;

  // The time course of drug absorption, distribution, metabolism and excretion of a medication from the body.
  TFhirMedicationKnowledgeKinetics = class (TFhirBackboneElement)
  protected
    FareaUnderCurveList : TFhirQuantityList;
    FlethalDose50List : TFhirQuantityList;
    FHalfLifePeriod : TFhirDuration;
    function GetAreaUnderCurveList : TFhirQuantityList;
    function GetHasAreaUnderCurveList : Boolean;
    function GetLethalDose50List : TFhirQuantityList;
    function GetHasLethalDose50List : Boolean;
    procedure SetHalfLifePeriod(value : TFhirDuration);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledgeKinetics; overload;
    function Clone : TFhirMedicationKnowledgeKinetics; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The drug concentration measured at certain discrete points in time.
    property areaUnderCurveList : TFhirQuantityList read GetAreaUnderCurveList;
    property hasAreaUnderCurveList : boolean read GetHasAreaUnderCurveList;

    // The median lethal dose of a drug.
    property lethalDose50List : TFhirQuantityList read GetLethalDose50List;
    property hasLethalDose50List : boolean read GetHasLethalDose50List;

    // Typed access to The time required for any specified property (e.g., the concentration of a substance in the body) to decrease by half. (defined for API consistency)
    property halfLifePeriod : TFhirDuration read FHalfLifePeriod write SetHalfLifePeriod;
    // The time required for any specified property (e.g., the concentration of a substance in the body) to decrease by half.
    property halfLifePeriodElement : TFhirDuration read FHalfLifePeriod write SetHalfLifePeriod;

  end;

  TFhirMedicationKnowledgeKineticsListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeKineticsList;
    function GetCurrent : TFhirMedicationKnowledgeKinetics;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeKineticsList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledgeKinetics read GetCurrent;
  end;

  TFhirMedicationKnowledgeKineticsList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledgeKinetics;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledgeKinetics);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeKineticsList; overload;
    function Clone : TFhirMedicationKnowledgeKineticsList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeKineticsListEnumerator;
    
    //  Add a FhirMedicationKnowledgeKinetics to the end of the list.
    function Append : TFhirMedicationKnowledgeKinetics;
    
    // Add an already existing FhirMedicationKnowledgeKinetics to the end of the list.
    function AddItem(value : TFhirMedicationKnowledgeKinetics) : TFhirMedicationKnowledgeKinetics; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledgeKinetics) : Integer;
    
    // Insert FhirMedicationKnowledgeKinetics before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledgeKinetics;
    
    // Insert an existing FhirMedicationKnowledgeKinetics before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledgeKinetics);
    
    // Get the iIndexth FhirMedicationKnowledgeKinetics. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledgeKinetics);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledgeKinetics;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledgeKinetics[index : Integer] : TFhirMedicationKnowledgeKinetics read GetItemN write SetItemN; default;
  End;

  // Information about a medication that is used to support knowledge.
  TFhirMedicationKnowledge = class (TFhirDomainResource)
  protected
    FCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FManufacturer : TFhirReference;
    FDoseForm : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    FsynonymList : TFhirStringList;
    FrelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    FassociatedMedicationList : TFhirReferenceList;
    FproductTypeList : TFhirCodeableConceptList;
    FmonographList : TFhirMedicationKnowledgeMonographList;
    FingredientList : TFhirMedicationKnowledgeIngredientList;
    FPreparationInstruction : TFhirMarkdown;
    FintendedRouteList : TFhirCodeableConceptList;
    FcostList : TFhirMedicationKnowledgeCostList;
    FmonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
    FadministrationGuidelinesList : TFhirMedicationKnowledgeAdministrationGuidelinesList;
    FmedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
    FPackaging : TFhirMedicationKnowledgePackaging;
    FdrugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList;
    FcontraindicationList : TFhirReferenceList;
    FregulatoryList : TFhirMedicationKnowledgeRegulatoryList;
    FkineticsList : TFhirMedicationKnowledgeKineticsList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationKnowledgeStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationKnowledgeStatusCodesEnum);
    procedure SetManufacturer(value : TFhirReference);
    procedure SetDoseForm(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirQuantity);
    function GetSynonymList : TFhirStringList;
    function GetHasSynonymList : Boolean;
    function GetRelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
    function GetHasRelatedMedicationKnowledgeList : Boolean;
    function GetAssociatedMedicationList : TFhirReferenceList;
    function GetHasAssociatedMedicationList : Boolean;
    function GetProductTypeList : TFhirCodeableConceptList;
    function GetHasProductTypeList : Boolean;
    function GetMonographList : TFhirMedicationKnowledgeMonographList;
    function GetHasMonographList : Boolean;
    function GetIngredientList : TFhirMedicationKnowledgeIngredientList;
    function GetHasIngredientList : Boolean;
    procedure SetPreparationInstruction(value : TFhirMarkdown);
    function GetPreparationInstructionST : String;
    procedure SetPreparationInstructionST(value : String);
    function GetIntendedRouteList : TFhirCodeableConceptList;
    function GetHasIntendedRouteList : Boolean;
    function GetCostList : TFhirMedicationKnowledgeCostList;
    function GetHasCostList : Boolean;
    function GetMonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
    function GetHasMonitoringProgramList : Boolean;
    function GetAdministrationGuidelinesList : TFhirMedicationKnowledgeAdministrationGuidelinesList;
    function GetHasAdministrationGuidelinesList : Boolean;
    function GetMedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
    function GetHasMedicineClassificationList : Boolean;
    procedure SetPackaging(value : TFhirMedicationKnowledgePackaging);
    function GetDrugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList;
    function GetHasDrugCharacteristicList : Boolean;
    function GetContraindicationList : TFhirReferenceList;
    function GetHasContraindicationList : Boolean;
    function GetRegulatoryList : TFhirMedicationKnowledgeRegulatoryList;
    function GetHasRegulatoryList : Boolean;
    function GetKineticsList : TFhirMedicationKnowledgeKineticsList;
    function GetHasKineticsList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationKnowledge; overload;
    function Clone : TFhirMedicationKnowledge; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that specifies this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that specifies this medication, or a textual description if no code is available. Usage note: This could be a standard medication code such as a code from RxNorm, SNOMED CT, IDMP etc. It could also be a national or local formulary code, optionally with translations to other code systems.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A code to indicate if the medication is in active use.  The status refers to the validity about the information of the medication and not to its medicinal properties.
    property status : TFhirMedicationKnowledgeStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product. (defined for API consistency)
    property manufacturer : TFhirReference read FManufacturer write SetManufacturer;
    // Describes the details of the manufacturer of the medication product.  This is not intended to represent the distributor of a medication product.
    property manufacturerElement : TFhirReference read FManufacturer write SetManufacturer;

    // Typed access to Describes the form of the item.  Powder; tablets; capsule. (defined for API consistency)
    property doseForm : TFhirCodeableConcept read FDoseForm write SetDoseForm;
    // Describes the form of the item.  Powder; tablets; capsule.
    property doseFormElement : TFhirCodeableConcept read FDoseForm write SetDoseForm;

    // Typed access to Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.). (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Specific amount of the drug in the packaged product.  For example, when specifying a product that has the same strength (For example, Insulin glargine 100 unit per mL solution for injection), this attribute provides additional clarification of the package amount (For example, 3 mL, 10mL, etc.).
    property amountElement : TFhirQuantity read FAmount write SetAmount;

    // Additional names for a medication, for example, the name(s) given to a medication in different countries.  For example, acetaminophen and paracetamol or salbutamol and albuterol.
    property synonymList : TFhirStringList read GetSynonymList;
    property hasSynonymList : boolean read GetHasSynonymList;

    // Associated or related knowledge about a medication.
    property relatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList read GetRelatedMedicationKnowledgeList;
    property hasRelatedMedicationKnowledgeList : boolean read GetHasRelatedMedicationKnowledgeList;

    // Associated or related medications.  For example, if the medication is a branded product (e.g. Crestor), this is the Therapeutic Moeity (e.g. Rosuvastatin) or if this is a generic medication (e.g. Rosuvastatin), this would link to a branded product (e.g. Crestor).
    property associatedMedicationList : TFhirReferenceList read GetAssociatedMedicationList;
    property hasAssociatedMedicationList : boolean read GetHasAssociatedMedicationList;

    // Category of the medication or product (e.g. branded product, therapeutic moeity, generic product, innovator product, etc.).
    property productTypeList : TFhirCodeableConceptList read GetProductTypeList;
    property hasProductTypeList : boolean read GetHasProductTypeList;

    // Associated documentation about the medication.
    property monographList : TFhirMedicationKnowledgeMonographList read GetMonographList;
    property hasMonographList : boolean read GetHasMonographList;

    // Identifies a particular constituent of interest in the product.
    property ingredientList : TFhirMedicationKnowledgeIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Typed access to The instructions for preparing the medication.
    property preparationInstruction : String read GetPreparationInstructionST write SetPreparationInstructionST;
    // The instructions for preparing the medication.
    property preparationInstructionElement : TFhirMarkdown read FPreparationInstruction write SetPreparationInstruction;

    // The intended or approved route of administration.
    property intendedRouteList : TFhirCodeableConceptList read GetIntendedRouteList;
    property hasIntendedRouteList : boolean read GetHasIntendedRouteList;

    // The price of the medication.
    property costList : TFhirMedicationKnowledgeCostList read GetCostList;
    property hasCostList : boolean read GetHasCostList;

    // The program under which the medication is reviewed.
    property monitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList read GetMonitoringProgramList;
    property hasMonitoringProgramList : boolean read GetHasMonitoringProgramList;

    // Guidelines for the administration of the medication.
    property administrationGuidelinesList : TFhirMedicationKnowledgeAdministrationGuidelinesList read GetAdministrationGuidelinesList;
    property hasAdministrationGuidelinesList : boolean read GetHasAdministrationGuidelinesList;

    // Categorization of the medication within a formulary or classification system.
    property medicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList read GetMedicineClassificationList;
    property hasMedicineClassificationList : boolean read GetHasMedicineClassificationList;

    // Typed access to Information that only applies to packages (not products). (defined for API consistency)
    property packaging : TFhirMedicationKnowledgePackaging read FPackaging write SetPackaging;
    // Information that only applies to packages (not products).
    property packagingElement : TFhirMedicationKnowledgePackaging read FPackaging write SetPackaging;

    // Specifies descriptive properties of the medicine, such as color, shape, imprints, etc.
    property drugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList read GetDrugCharacteristicList;
    property hasDrugCharacteristicList : boolean read GetHasDrugCharacteristicList;

    // Potential clinical issue with or between medication(s) (for example, drug-drug interaction, drug-disease contraindication, drug-allergy interaction, etc.).
    property contraindicationList : TFhirReferenceList read GetContraindicationList;
    property hasContraindicationList : boolean read GetHasContraindicationList;

    // Regulatory information about a medication.
    property regulatoryList : TFhirMedicationKnowledgeRegulatoryList read GetRegulatoryList;
    property hasRegulatoryList : boolean read GetHasRegulatoryList;

    // The time course of drug absorption, distribution, metabolism and excretion of a medication from the body.
    property kineticsList : TFhirMedicationKnowledgeKineticsList read GetKineticsList;
    property hasKineticsList : boolean read GetHasKineticsList;

  end;

  TFhirMedicationKnowledgeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationKnowledgeList;
    function GetCurrent : TFhirMedicationKnowledge;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationKnowledgeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationKnowledge read GetCurrent;
  end;

  TFhirMedicationKnowledgeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationKnowledge;
    procedure SetItemN(index : Integer; value : TFhirMedicationKnowledge);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationKnowledgeList; overload;
    function Clone : TFhirMedicationKnowledgeList; overload;
    function GetEnumerator : TFhirMedicationKnowledgeListEnumerator;
    
    //  Add a FhirMedicationKnowledge to the end of the list.
    function Append : TFhirMedicationKnowledge;
    
    // Add an already existing FhirMedicationKnowledge to the end of the list.
    function AddItem(value : TFhirMedicationKnowledge) : TFhirMedicationKnowledge; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationKnowledge) : Integer;
    
    // Insert FhirMedicationKnowledge before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationKnowledge;
    
    // Insert an existing FhirMedicationKnowledge before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationKnowledge);
    
    // Get the iIndexth FhirMedicationKnowledge. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationKnowledge);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationKnowledge;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationKnowledges[index : Integer] : TFhirMedicationKnowledge read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
  // A product specific contact, person (in a role), or an organization.
  TFhirMedicinalProductDefinitionContact = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FContact : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetContact(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionContact; overload;
    function Clone : TFhirMedicinalProductDefinitionContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Allows the contact to be classified, for example QPPV, Pharmacovigilance Enquiry Information.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A product specific contact, person (in a role), or an organization. (defined for API consistency)
    property contact : TFhirReference read FContact write SetContact;
    // A product specific contact, person (in a role), or an organization.
    property contactElement : TFhirReference read FContact write SetContact;

  end;

  TFhirMedicinalProductDefinitionContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionContactList;
    function GetCurrent : TFhirMedicinalProductDefinitionContact;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionContact read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionContact;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionContactList; overload;
    function Clone : TFhirMedicinalProductDefinitionContactList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionContactListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionContact to the end of the list.
    function Append : TFhirMedicinalProductDefinitionContact;
    
    // Add an already existing FhirMedicinalProductDefinitionContact to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionContact) : TFhirMedicinalProductDefinitionContact; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionContact) : Integer;
    
    // Insert FhirMedicinalProductDefinitionContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionContact;
    
    // Insert an existing FhirMedicinalProductDefinitionContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionContact);
    
    // Get the iIndexth FhirMedicinalProductDefinitionContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionContacts[index : Integer] : TFhirMedicinalProductDefinitionContact read GetItemN write SetItemN; default;
  End;

  // The product's name, including full name and possibly coded parts.
  TFhirMedicinalProductDefinitionName = class (TFhirBackboneElement)
  protected
    FProductName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FnamePartList : TFhirMedicinalProductDefinitionNameNamePartList;
    FcountryLanguageList : TFhirMedicinalProductDefinitionNameCountryLanguageList;
    procedure SetProductName(value : TFhirString);
    function GetProductNameST : String;
    procedure SetProductNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetNamePartList : TFhirMedicinalProductDefinitionNameNamePartList;
    function GetHasNamePartList : Boolean;
    function GetCountryLanguageList : TFhirMedicinalProductDefinitionNameCountryLanguageList;
    function GetHasCountryLanguageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionName; overload;
    function Clone : TFhirMedicinalProductDefinitionName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The full product name.
    property productName : String read GetProductNameST write SetProductNameST;
    // The full product name.
    property productNameElement : TFhirString read FProductName write SetProductName;

    // Typed access to Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of product name, such as rINN, BAN, Proprietary, Non-Proprietary.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Coding words or phrases of the name.
    property namePartList : TFhirMedicinalProductDefinitionNameNamePartList read GetNamePartList;
    property hasNamePartList : boolean read GetHasNamePartList;

    // Country where the name applies.
    property countryLanguageList : TFhirMedicinalProductDefinitionNameCountryLanguageList read GetCountryLanguageList;
    property hasCountryLanguageList : boolean read GetHasCountryLanguageList;

  end;

  TFhirMedicinalProductDefinitionNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionNameList;
    function GetCurrent : TFhirMedicinalProductDefinitionName;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionName read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionName;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionNameList; overload;
    function Clone : TFhirMedicinalProductDefinitionNameList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionNameListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionName to the end of the list.
    function Append : TFhirMedicinalProductDefinitionName;
    
    // Add an already existing FhirMedicinalProductDefinitionName to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionName) : TFhirMedicinalProductDefinitionName; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionName) : Integer;
    
    // Insert FhirMedicinalProductDefinitionName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionName;
    
    // Insert an existing FhirMedicinalProductDefinitionName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionName);
    
    // Get the iIndexth FhirMedicinalProductDefinitionName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionNames[index : Integer] : TFhirMedicinalProductDefinitionName read GetItemN write SetItemN; default;
  End;

  // Coding words or phrases of the name.
  TFhirMedicinalProductDefinitionNameNamePart = class (TFhirBackboneElement)
  protected
    FPart : TFhirString;
    FType_ : TFhirCodeableConcept;
    procedure SetPart(value : TFhirString);
    function GetPartST : String;
    procedure SetPartST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionNameNamePart; overload;
    function Clone : TFhirMedicinalProductDefinitionNameNamePart; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A fragment of a product name.
    property part : String read GetPartST write SetPartST;
    // A fragment of a product name.
    property partElement : TFhirString read FPart write SetPart;

    // Typed access to Identifying type for this part of the name (e.g. strength part). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Identifying type for this part of the name (e.g. strength part).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirMedicinalProductDefinitionNameNamePartListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionNameNamePartList;
    function GetCurrent : TFhirMedicinalProductDefinitionNameNamePart;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionNameNamePartList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionNameNamePart read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionNameNamePartList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionNameNamePart;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionNameNamePart);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionNameNamePartList; overload;
    function Clone : TFhirMedicinalProductDefinitionNameNamePartList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionNameNamePartListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionNameNamePart to the end of the list.
    function Append : TFhirMedicinalProductDefinitionNameNamePart;
    
    // Add an already existing FhirMedicinalProductDefinitionNameNamePart to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionNameNamePart) : TFhirMedicinalProductDefinitionNameNamePart; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionNameNamePart) : Integer;
    
    // Insert FhirMedicinalProductDefinitionNameNamePart before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionNameNamePart;
    
    // Insert an existing FhirMedicinalProductDefinitionNameNamePart before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionNameNamePart);
    
    // Get the iIndexth FhirMedicinalProductDefinitionNameNamePart. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionNameNamePart);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionNameNamePart;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionNameNameParts[index : Integer] : TFhirMedicinalProductDefinitionNameNamePart read GetItemN write SetItemN; default;
  End;

  // Country where the name applies.
  TFhirMedicinalProductDefinitionNameCountryLanguage = class (TFhirBackboneElement)
  protected
    FCountry : TFhirCodeableConcept;
    FJurisdiction : TFhirCodeableConcept;
    FLanguage : TFhirCodeableConcept;
    procedure SetCountry(value : TFhirCodeableConcept);
    procedure SetJurisdiction(value : TFhirCodeableConcept);
    procedure SetLanguage(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionNameCountryLanguage; overload;
    function Clone : TFhirMedicinalProductDefinitionNameCountryLanguage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Country code for where this name applies. (defined for API consistency)
    property country : TFhirCodeableConcept read FCountry write SetCountry;
    // Country code for where this name applies.
    property countryElement : TFhirCodeableConcept read FCountry write SetCountry;

    // Typed access to Jurisdiction code for where this name applies. (defined for API consistency)
    property jurisdiction : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;
    // Jurisdiction code for where this name applies.
    property jurisdictionElement : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;

    // Typed access to Language code for this name. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // Language code for this name.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

  end;

  TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionNameCountryLanguageList;
    function GetCurrent : TFhirMedicinalProductDefinitionNameCountryLanguage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionNameCountryLanguageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionNameCountryLanguage read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionNameCountryLanguageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionNameCountryLanguage;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionNameCountryLanguage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionNameCountryLanguageList; overload;
    function Clone : TFhirMedicinalProductDefinitionNameCountryLanguageList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionNameCountryLanguage to the end of the list.
    function Append : TFhirMedicinalProductDefinitionNameCountryLanguage;
    
    // Add an already existing FhirMedicinalProductDefinitionNameCountryLanguage to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionNameCountryLanguage) : TFhirMedicinalProductDefinitionNameCountryLanguage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionNameCountryLanguage) : Integer;
    
    // Insert FhirMedicinalProductDefinitionNameCountryLanguage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionNameCountryLanguage;
    
    // Insert an existing FhirMedicinalProductDefinitionNameCountryLanguage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionNameCountryLanguage);
    
    // Get the iIndexth FhirMedicinalProductDefinitionNameCountryLanguage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionNameCountryLanguage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionNameCountryLanguage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionNameCountryLanguages[index : Integer] : TFhirMedicinalProductDefinitionNameCountryLanguage read GetItemN write SetItemN; default;
  End;

  // Reference to another product, e.g. for linking authorised to investigational product.
  TFhirMedicinalProductDefinitionCrossReference = class (TFhirBackboneElement)
  protected
    FProduct : TFhirCodeableReference;
    FType_ : TFhirCodeableConcept;
    procedure SetProduct(value : TFhirCodeableReference);
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionCrossReference; overload;
    function Clone : TFhirMedicinalProductDefinitionCrossReference; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to another product, e.g. for linking authorised to investigational product. (defined for API consistency)
    property product : TFhirCodeableReference read FProduct write SetProduct;
    // Reference to another product, e.g. for linking authorised to investigational product.
    property productElement : TFhirCodeableReference read FProduct write SetProduct;

    // Typed access to The type of relationship, for instance branded to generic, product to development product (investigational), parallel import version. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of relationship, for instance branded to generic, product to development product (investigational), parallel import version.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirMedicinalProductDefinitionCrossReferenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionCrossReferenceList;
    function GetCurrent : TFhirMedicinalProductDefinitionCrossReference;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionCrossReferenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionCrossReference read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionCrossReferenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionCrossReference;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionCrossReference);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionCrossReferenceList; overload;
    function Clone : TFhirMedicinalProductDefinitionCrossReferenceList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionCrossReferenceListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionCrossReference to the end of the list.
    function Append : TFhirMedicinalProductDefinitionCrossReference;
    
    // Add an already existing FhirMedicinalProductDefinitionCrossReference to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionCrossReference) : TFhirMedicinalProductDefinitionCrossReference; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionCrossReference) : Integer;
    
    // Insert FhirMedicinalProductDefinitionCrossReference before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionCrossReference;
    
    // Insert an existing FhirMedicinalProductDefinitionCrossReference before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionCrossReference);
    
    // Get the iIndexth FhirMedicinalProductDefinitionCrossReference. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionCrossReference);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionCrossReference;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionCrossReferences[index : Integer] : TFhirMedicinalProductDefinitionCrossReference read GetItemN write SetItemN; default;
  End;

  // A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
  TFhirMedicinalProductDefinitionOperation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableReference;
    FEffectiveDate : TFhirPeriod;
    ForganizationList : TFhirReferenceList;
    FConfidentialityIndicator : TFhirCodeableConcept;
    procedure SetType_(value : TFhirCodeableReference);
    procedure SetEffectiveDate(value : TFhirPeriod);
    function GetOrganizationList : TFhirReferenceList;
    function GetHasOrganizationList : Boolean;
    procedure SetConfidentialityIndicator(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionOperation; overload;
    function Clone : TFhirMedicinalProductDefinitionOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here. (defined for API consistency)
    property type_ : TFhirCodeableReference read FType_ write SetType_;
    // The type of manufacturing operation e.g. manufacturing itself, re-packaging. For the authorization of this, a RegulatedAuthorization would point to the same plan or activity referenced here.
    property type_Element : TFhirCodeableReference read FType_ write SetType_;

    // Typed access to Date range of applicability. (defined for API consistency)
    property effectiveDate : TFhirPeriod read FEffectiveDate write SetEffectiveDate;
    // Date range of applicability.
    property effectiveDateElement : TFhirPeriod read FEffectiveDate write SetEffectiveDate;

    // The organization or establishment responsible for (or associated with) the particular process or step, examples include the manufacturer, importer, agent.
    property organizationList : TFhirReferenceList read GetOrganizationList;
    property hasOrganizationList : boolean read GetHasOrganizationList;

    // Typed access to Specifies whether this particular business or manufacturing process is considered proprietary or confidential. (defined for API consistency)
    property confidentialityIndicator : TFhirCodeableConcept read FConfidentialityIndicator write SetConfidentialityIndicator;
    // Specifies whether this particular business or manufacturing process is considered proprietary or confidential.
    property confidentialityIndicatorElement : TFhirCodeableConcept read FConfidentialityIndicator write SetConfidentialityIndicator;

  end;

  TFhirMedicinalProductDefinitionOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionOperationList;
    function GetCurrent : TFhirMedicinalProductDefinitionOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionOperation read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionOperation;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionOperationList; overload;
    function Clone : TFhirMedicinalProductDefinitionOperationList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionOperationListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionOperation to the end of the list.
    function Append : TFhirMedicinalProductDefinitionOperation;
    
    // Add an already existing FhirMedicinalProductDefinitionOperation to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionOperation) : TFhirMedicinalProductDefinitionOperation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionOperation) : Integer;
    
    // Insert FhirMedicinalProductDefinitionOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionOperation;
    
    // Insert an existing FhirMedicinalProductDefinitionOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionOperation);
    
    // Get the iIndexth FhirMedicinalProductDefinitionOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionOperations[index : Integer] : TFhirMedicinalProductDefinitionOperation read GetItemN write SetItemN; default;
  End;

  // Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
  TFhirMedicinalProductDefinitionCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinitionCharacteristic; overload;
    function Clone : TFhirMedicinalProductDefinitionCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirMedicinalProductDefinitionCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionCharacteristicList;
    function GetCurrent : TFhirMedicinalProductDefinitionCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinitionCharacteristic read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinitionCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinitionCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionCharacteristicList; overload;
    function Clone : TFhirMedicinalProductDefinitionCharacteristicList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionCharacteristicListEnumerator;
    
    //  Add a FhirMedicinalProductDefinitionCharacteristic to the end of the list.
    function Append : TFhirMedicinalProductDefinitionCharacteristic;
    
    // Add an already existing FhirMedicinalProductDefinitionCharacteristic to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinitionCharacteristic) : TFhirMedicinalProductDefinitionCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinitionCharacteristic) : Integer;
    
    // Insert FhirMedicinalProductDefinitionCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinitionCharacteristic;
    
    // Insert an existing FhirMedicinalProductDefinitionCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinitionCharacteristic);
    
    // Get the iIndexth FhirMedicinalProductDefinitionCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinitionCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinitionCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitionCharacteristics[index : Integer] : TFhirMedicinalProductDefinitionCharacteristic read GetItemN write SetItemN; default;
  End;

  // Detailed definition of a medicinal product, typically for uses other than direct patient care (e.g. regulatory use, drug catalogs).
  TFhirMedicinalProductDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FDomain : TFhirCodeableConcept;
    FVersion : TFhirString;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FDescription : TFhirMarkdown;
    FCombinedPharmaceuticalDoseForm : TFhirCodeableConcept;
    FrouteList : TFhirCodeableConceptList;
    FIndication : TFhirMarkdown;
    FLegalStatusOfSupply : TFhirCodeableConcept;
    FAdditionalMonitoringIndicator : TFhirCodeableConcept;
    FspecialMeasuresList : TFhirCodeableConceptList;
    FPediatricUseIndicator : TFhirCodeableConcept;
    FclassificationList : TFhirCodeableConceptList;
    FmarketingStatusList : TFhirMarketingStatusList;
    FpackagedMedicinalProductList : TFhirCodeableConceptList;
    FingredientList : TFhirCodeableConceptList;
    FimpurityList : TFhirCodeableReferenceList;
    FattachedDocumentList : TFhirReferenceList;
    FmasterFileList : TFhirReferenceList;
    FcontactList : TFhirMedicinalProductDefinitionContactList;
    FclinicalTrialList : TFhirReferenceList;
    FcodeList : TFhirCodingList;
    FnameList : TFhirMedicinalProductDefinitionNameList;
    FcrossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList;
    FoperationList : TFhirMedicinalProductDefinitionOperationList;
    FcharacteristicList : TFhirMedicinalProductDefinitionCharacteristicList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDomain(value : TFhirCodeableConcept);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetCombinedPharmaceuticalDoseForm(value : TFhirCodeableConcept);
    function GetRouteList : TFhirCodeableConceptList;
    function GetHasRouteList : Boolean;
    procedure SetIndication(value : TFhirMarkdown);
    function GetIndicationST : String;
    procedure SetIndicationST(value : String);
    procedure SetLegalStatusOfSupply(value : TFhirCodeableConcept);
    procedure SetAdditionalMonitoringIndicator(value : TFhirCodeableConcept);
    function GetSpecialMeasuresList : TFhirCodeableConceptList;
    function GetHasSpecialMeasuresList : Boolean;
    procedure SetPediatricUseIndicator(value : TFhirCodeableConcept);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
    function GetMarketingStatusList : TFhirMarketingStatusList;
    function GetHasMarketingStatusList : Boolean;
    function GetPackagedMedicinalProductList : TFhirCodeableConceptList;
    function GetHasPackagedMedicinalProductList : Boolean;
    function GetIngredientList : TFhirCodeableConceptList;
    function GetHasIngredientList : Boolean;
    function GetImpurityList : TFhirCodeableReferenceList;
    function GetHasImpurityList : Boolean;
    function GetAttachedDocumentList : TFhirReferenceList;
    function GetHasAttachedDocumentList : Boolean;
    function GetMasterFileList : TFhirReferenceList;
    function GetHasMasterFileList : Boolean;
    function GetContactList : TFhirMedicinalProductDefinitionContactList;
    function GetHasContactList : Boolean;
    function GetClinicalTrialList : TFhirReferenceList;
    function GetHasClinicalTrialList : Boolean;
    function GetCodeList : TFhirCodingList;
    function GetHasCodeList : Boolean;
    function GetNameList : TFhirMedicinalProductDefinitionNameList;
    function GetHasNameList : Boolean;
    function GetCrossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList;
    function GetHasCrossReferenceList : Boolean;
    function GetOperationList : TFhirMedicinalProductDefinitionOperationList;
    function GetHasOperationList : Boolean;
    function GetCharacteristicList : TFhirMedicinalProductDefinitionCharacteristicList;
    function GetHasCharacteristicList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicinalProductDefinition; overload;
    function Clone : TFhirMedicinalProductDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this product. Could be an MPID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Regulatory type, e.g. Investigational or Authorized. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Regulatory type, e.g. Investigational or Authorized.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to If this medicine applies to human or veterinary uses. (defined for API consistency)
    property domain : TFhirCodeableConcept read FDomain write SetDomain;
    // If this medicine applies to human or veterinary uses.
    property domainElement : TFhirCodeableConcept read FDomain write SetDomain;

    // Typed access to A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.
    property version : String read GetVersionST write SetVersionST;
    // A business identifier relating to a specific version of the product, this is commonly used to support revisions to an existing product.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status within the lifecycle of this product record. A high-level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization status.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the given status became applicable.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the given status became applicable.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to General description of this product.
    property description : String read GetDescriptionST write SetDescriptionST;
    // General description of this product.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to The dose form for a single part product, or combined form of a multiple part product. (defined for API consistency)
    property combinedPharmaceuticalDoseForm : TFhirCodeableConcept read FCombinedPharmaceuticalDoseForm write SetCombinedPharmaceuticalDoseForm;
    // The dose form for a single part product, or combined form of a multiple part product.
    property combinedPharmaceuticalDoseFormElement : TFhirCodeableConcept read FCombinedPharmaceuticalDoseForm write SetCombinedPharmaceuticalDoseForm;

    // The path by which the product is taken into or makes contact with the body. In some regions this is referred to as the licenced or approved route. See also AdministrableProductDefinition resource.
    property routeList : TFhirCodeableConceptList read GetRouteList;
    property hasRouteList : boolean read GetHasRouteList;

    // Typed access to Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.
    property indication : String read GetIndicationST write SetIndicationST;
    // Description of indication(s) for this product, used when structured indications are not required. In cases where structured indications are required, they are captured using the ClinicalUseDefinition resource. An indication is a medical situation for which using the product is appropriate.
    property indicationElement : TFhirMarkdown read FIndication write SetIndication;

    // Typed access to The legal status of supply of the medicinal product as classified by the regulator. (defined for API consistency)
    property legalStatusOfSupply : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;
    // The legal status of supply of the medicinal product as classified by the regulator.
    property legalStatusOfSupplyElement : TFhirCodeableConcept read FLegalStatusOfSupply write SetLegalStatusOfSupply;

    // Typed access to Whether the Medicinal Product is subject to additional monitoring for regulatory reasons. (defined for API consistency)
    property additionalMonitoringIndicator : TFhirCodeableConcept read FAdditionalMonitoringIndicator write SetAdditionalMonitoringIndicator;
    // Whether the Medicinal Product is subject to additional monitoring for regulatory reasons.
    property additionalMonitoringIndicatorElement : TFhirCodeableConcept read FAdditionalMonitoringIndicator write SetAdditionalMonitoringIndicator;

    // Whether the Medicinal Product is subject to special measures for regulatory reasons.
    property specialMeasuresList : TFhirCodeableConceptList read GetSpecialMeasuresList;
    property hasSpecialMeasuresList : boolean read GetHasSpecialMeasuresList;

    // Typed access to If authorised for use in children. (defined for API consistency)
    property pediatricUseIndicator : TFhirCodeableConcept read FPediatricUseIndicator write SetPediatricUseIndicator;
    // If authorised for use in children.
    property pediatricUseIndicatorElement : TFhirCodeableConcept read FPediatricUseIndicator write SetPediatricUseIndicator;

    // Allows the product to be classified by various systems.
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Marketing status of the medicinal product, in contrast to marketing authorization.
    property marketingStatusList : TFhirMarketingStatusList read GetMarketingStatusList;
    property hasMarketingStatusList : boolean read GetHasMarketingStatusList;

    // Package representation for the product. See also the PackagedProductDefinition resource.
    property packagedMedicinalProductList : TFhirCodeableConceptList read GetPackagedMedicinalProductList;
    property hasPackagedMedicinalProductList : boolean read GetHasPackagedMedicinalProductList;

    // The ingredients of this medicinal product - when not detailed in other resources. This is only needed if the ingredients are not specified by incoming references from the Ingredient resource, or indirectly via incoming AdministrableProductDefinition, PackagedProductDefinition or ManufacturedItemDefinition references. In cases where those levels of detail are not used, the ingredients may be specified directly here as codes.
    property ingredientList : TFhirCodeableConceptList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Any component of the drug product which is not the chemical entity defined as the drug substance or an excipient in the drug product. This includes process-related impurities and contaminants, product-related impurities including degradation products.
    property impurityList : TFhirCodeableReferenceList read GetImpurityList;
    property hasImpurityList : boolean read GetHasImpurityList;

    // Additional information or supporting documentation about the medicinal product.
    property attachedDocumentList : TFhirReferenceList read GetAttachedDocumentList;
    property hasAttachedDocumentList : boolean read GetHasAttachedDocumentList;

    // A master file for the medicinal product (e.g. Pharmacovigilance System Master File). Drug master files (DMFs) are documents submitted to regulatory agencies to provide confidential detailed information about facilities, processes or articles used in the manufacturing, processing, packaging and storing of drug products.
    property masterFileList : TFhirReferenceList read GetMasterFileList;
    property hasMasterFileList : boolean read GetHasMasterFileList;

    // A product specific contact, person (in a role), or an organization.
    property contactList : TFhirMedicinalProductDefinitionContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Clinical trials or studies that this product is involved in.
    property clinicalTrialList : TFhirReferenceList read GetClinicalTrialList;
    property hasClinicalTrialList : boolean read GetHasClinicalTrialList;

    // A code that this product is known by, usually within some formal terminology. Products (types of medications) tend to be known by identifiers during development and within regulatory process. However when they are prescribed they tend to be identified by codes. The same product may be have multiple codes, applied to it by multiple organizations.
    property codeList : TFhirCodingList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // The product's name, including full name and possibly coded parts.
    property nameList : TFhirMedicinalProductDefinitionNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // Reference to another product, e.g. for linking authorised to investigational product.
    property crossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList read GetCrossReferenceList;
    property hasCrossReferenceList : boolean read GetHasCrossReferenceList;

    // A manufacturing or administrative process or step associated with (or performed on) the medicinal product.
    property operationList : TFhirMedicinalProductDefinitionOperationList read GetOperationList;
    property hasOperationList : boolean read GetHasOperationList;

    // Allows the key product features to be recorded, such as "sugar free", "modified release", "parallel import".
    property characteristicList : TFhirMedicinalProductDefinitionCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

  end;

  TFhirMedicinalProductDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicinalProductDefinitionList;
    function GetCurrent : TFhirMedicinalProductDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicinalProductDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicinalProductDefinition read GetCurrent;
  end;

  TFhirMedicinalProductDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicinalProductDefinition;
    procedure SetItemN(index : Integer; value : TFhirMedicinalProductDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicinalProductDefinitionList; overload;
    function Clone : TFhirMedicinalProductDefinitionList; overload;
    function GetEnumerator : TFhirMedicinalProductDefinitionListEnumerator;
    
    //  Add a FhirMedicinalProductDefinition to the end of the list.
    function Append : TFhirMedicinalProductDefinition;
    
    // Add an already existing FhirMedicinalProductDefinition to the end of the list.
    function AddItem(value : TFhirMedicinalProductDefinition) : TFhirMedicinalProductDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicinalProductDefinition) : Integer;
    
    // Insert FhirMedicinalProductDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicinalProductDefinition;
    
    // Insert an existing FhirMedicinalProductDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicinalProductDefinition);
    
    // Get the iIndexth FhirMedicinalProductDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicinalProductDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicinalProductDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicinalProductDefinitions[index : Integer] : TFhirMedicinalProductDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_NUTRITIONPRODUCT}
  // The product's nutritional information expressed by the nutrients.
  TFhirNutritionProductNutrient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FamountList : TFhirRatioList;
    procedure SetItem(value : TFhirCodeableReference);
    function GetAmountList : TFhirRatioList;
    function GetHasAmountList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductNutrient; overload;
    function Clone : TFhirNutritionProductNutrient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The (relevant) nutrients in the product. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The (relevant) nutrients in the product.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // The amount of nutrient expressed in one or more units: X per pack / per serving / per dose.
    property amountList : TFhirRatioList read GetAmountList;
    property hasAmountList : boolean read GetHasAmountList;

  end;

  TFhirNutritionProductNutrientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductNutrientList;
    function GetCurrent : TFhirNutritionProductNutrient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductNutrientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductNutrient read GetCurrent;
  end;

  TFhirNutritionProductNutrientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductNutrient;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductNutrient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductNutrientList; overload;
    function Clone : TFhirNutritionProductNutrientList; overload;
    function GetEnumerator : TFhirNutritionProductNutrientListEnumerator;
    
    //  Add a FhirNutritionProductNutrient to the end of the list.
    function Append : TFhirNutritionProductNutrient;
    
    // Add an already existing FhirNutritionProductNutrient to the end of the list.
    function AddItem(value : TFhirNutritionProductNutrient) : TFhirNutritionProductNutrient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductNutrient) : Integer;
    
    // Insert FhirNutritionProductNutrient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductNutrient;
    
    // Insert an existing FhirNutritionProductNutrient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductNutrient);
    
    // Get the iIndexth FhirNutritionProductNutrient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductNutrient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductNutrient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductNutrients[index : Integer] : TFhirNutritionProductNutrient read GetItemN write SetItemN; default;
  End;

  // Ingredients contained in this product.
  TFhirNutritionProductIngredient = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FamountList : TFhirRatioList;
    procedure SetItem(value : TFhirCodeableReference);
    function GetAmountList : TFhirRatioList;
    function GetHasAmountList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductIngredient; overload;
    function Clone : TFhirNutritionProductIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ingredient contained in the product. (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The ingredient contained in the product.
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // The amount of ingredient that is in the product.
    property amountList : TFhirRatioList read GetAmountList;
    property hasAmountList : boolean read GetHasAmountList;

  end;

  TFhirNutritionProductIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductIngredientList;
    function GetCurrent : TFhirNutritionProductIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductIngredient read GetCurrent;
  end;

  TFhirNutritionProductIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductIngredient;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductIngredientList; overload;
    function Clone : TFhirNutritionProductIngredientList; overload;
    function GetEnumerator : TFhirNutritionProductIngredientListEnumerator;
    
    //  Add a FhirNutritionProductIngredient to the end of the list.
    function Append : TFhirNutritionProductIngredient;
    
    // Add an already existing FhirNutritionProductIngredient to the end of the list.
    function AddItem(value : TFhirNutritionProductIngredient) : TFhirNutritionProductIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductIngredient) : Integer;
    
    // Insert FhirNutritionProductIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductIngredient;
    
    // Insert an existing FhirNutritionProductIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductIngredient);
    
    // Get the iIndexth FhirNutritionProductIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductIngredients[index : Integer] : TFhirNutritionProductIngredient read GetItemN write SetItemN; default;
  End;

  // Specifies descriptive properties of the nutrition product.
  TFhirNutritionProductProductCharacteristic = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductProductCharacteristic; overload;
    function Clone : TFhirNutritionProductProductCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code specifying which characteristic of the product is being described (for example, colour, shape). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code specifying which characteristic of the product is being described (for example, colour, shape).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The actual characteristic value corresponding to the type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The actual characteristic value corresponding to the type.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirNutritionProductProductCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductProductCharacteristicList;
    function GetCurrent : TFhirNutritionProductProductCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductProductCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductProductCharacteristic read GetCurrent;
  end;

  TFhirNutritionProductProductCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductProductCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductProductCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductProductCharacteristicList; overload;
    function Clone : TFhirNutritionProductProductCharacteristicList; overload;
    function GetEnumerator : TFhirNutritionProductProductCharacteristicListEnumerator;
    
    //  Add a FhirNutritionProductProductCharacteristic to the end of the list.
    function Append : TFhirNutritionProductProductCharacteristic;
    
    // Add an already existing FhirNutritionProductProductCharacteristic to the end of the list.
    function AddItem(value : TFhirNutritionProductProductCharacteristic) : TFhirNutritionProductProductCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductProductCharacteristic) : Integer;
    
    // Insert FhirNutritionProductProductCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductProductCharacteristic;
    
    // Insert an existing FhirNutritionProductProductCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductProductCharacteristic);
    
    // Get the iIndexth FhirNutritionProductProductCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductProductCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductProductCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductProductCharacteristics[index : Integer] : TFhirNutritionProductProductCharacteristic read GetItemN write SetItemN; default;
  End;

  // Conveys instance-level information about this product item. One or several physical, countable instances or occurrences of the product.
  TFhirNutritionProductInstance = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FidentifierList : TFhirIdentifierList;
    FLotNumber : TFhirString;
    FExpiry : TFhirDateTime;
    FUseBy : TFhirDateTime;
    procedure SetQuantity(value : TFhirQuantity);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetExpiry(value : TFhirDateTime);
    function GetExpiryST : TFslDateTime;
    procedure SetExpiryST(value : TFslDateTime);
    procedure SetUseBy(value : TFhirDateTime);
    function GetUseByST : TFslDateTime;
    procedure SetUseByST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProductInstance; overload;
    function Clone : TFhirNutritionProductInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount of items or instances that the resource considers, for instance when referring to 2 identical units together. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of items or instances that the resource considers, for instance when referring to 2 identical units together.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // The identifier for the physical instance, typically a serial number.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identification of the batch or lot of the product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // The identification of the batch or lot of the product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property expiry : TFslDateTime read GetExpiryST write SetExpiryST;
    // The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property expiryElement : TFhirDateTime read FExpiry write SetExpiry;

    // Typed access to The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property useBy : TFslDateTime read GetUseByST write SetUseByST;
    // The time after which the product is no longer expected to be in proper condition, or its use is not advised or not allowed.
    property useByElement : TFhirDateTime read FUseBy write SetUseBy;

  end;

  TFhirNutritionProductInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductInstanceList;
    function GetCurrent : TFhirNutritionProductInstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProductInstance read GetCurrent;
  end;

  TFhirNutritionProductInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProductInstance;
    procedure SetItemN(index : Integer; value : TFhirNutritionProductInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductInstanceList; overload;
    function Clone : TFhirNutritionProductInstanceList; overload;
    function GetEnumerator : TFhirNutritionProductInstanceListEnumerator;
    
    //  Add a FhirNutritionProductInstance to the end of the list.
    function Append : TFhirNutritionProductInstance;
    
    // Add an already existing FhirNutritionProductInstance to the end of the list.
    function AddItem(value : TFhirNutritionProductInstance) : TFhirNutritionProductInstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProductInstance) : Integer;
    
    // Insert FhirNutritionProductInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProductInstance;
    
    // Insert an existing FhirNutritionProductInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProductInstance);
    
    // Get the iIndexth FhirNutritionProductInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProductInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProductInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProductInstances[index : Integer] : TFhirNutritionProductInstance read GetItemN write SetItemN; default;
  End;

  // A food or fluid product that is consumed by patients.
  TFhirNutritionProduct = class (TFhirDomainResource)
  protected
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FmanufacturerList : TFhirReferenceList;
    FnutrientList : TFhirNutritionProductNutrientList;
    FingredientList : TFhirNutritionProductIngredientList;
    FknownAllergenList : TFhirCodeableReferenceList;
    FproductCharacteristicList : TFhirNutritionProductProductCharacteristicList;
    FInstance : TFhirNutritionProductInstance;
    FnoteList : TFhirAnnotationList;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirNutritionProductStatusEnum;
    procedure SetStatusST(value : TFhirNutritionProductStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetNutrientList : TFhirNutritionProductNutrientList;
    function GetHasNutrientList : Boolean;
    function GetIngredientList : TFhirNutritionProductIngredientList;
    function GetHasIngredientList : Boolean;
    function GetKnownAllergenList : TFhirCodeableReferenceList;
    function GetHasKnownAllergenList : Boolean;
    function GetProductCharacteristicList : TFhirNutritionProductProductCharacteristicList;
    function GetHasProductCharacteristicList : Boolean;
    procedure SetInstance(value : TFhirNutritionProductInstance);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionProduct; overload;
    function Clone : TFhirNutritionProduct; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The current state of the product.
    property status : TFhirNutritionProductStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Nutrition products can have different classifications - according to its nutritional properties, preparation methods, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The code assigned to the product, for example a manufacturer number or other terminology. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The code assigned to the product, for example a manufacturer number or other terminology.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The organisation (manufacturer, representative or legal authorisation holder) that is responsible for the device.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // The product's nutritional information expressed by the nutrients.
    property nutrientList : TFhirNutritionProductNutrientList read GetNutrientList;
    property hasNutrientList : boolean read GetHasNutrientList;

    // Ingredients contained in this product.
    property ingredientList : TFhirNutritionProductIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

    // Allergens that are known or suspected to be a part of this nutrition product.
    property knownAllergenList : TFhirCodeableReferenceList read GetKnownAllergenList;
    property hasKnownAllergenList : boolean read GetHasKnownAllergenList;

    // Specifies descriptive properties of the nutrition product.
    property productCharacteristicList : TFhirNutritionProductProductCharacteristicList read GetProductCharacteristicList;
    property hasProductCharacteristicList : boolean read GetHasProductCharacteristicList;

    // Typed access to Conveys instance-level information about this product item. One or several physical, countable instances or occurrences of the product. (defined for API consistency)
    property instance : TFhirNutritionProductInstance read FInstance write SetInstance;
    // Conveys instance-level information about this product item. One or several physical, countable instances or occurrences of the product.
    property instanceElement : TFhirNutritionProductInstance read FInstance write SetInstance;

    // Comments made about the product.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirNutritionProductListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionProductList;
    function GetCurrent : TFhirNutritionProduct;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionProductList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionProduct read GetCurrent;
  end;

  TFhirNutritionProductList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionProduct;
    procedure SetItemN(index : Integer; value : TFhirNutritionProduct);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionProductList; overload;
    function Clone : TFhirNutritionProductList; overload;
    function GetEnumerator : TFhirNutritionProductListEnumerator;
    
    //  Add a FhirNutritionProduct to the end of the list.
    function Append : TFhirNutritionProduct;
    
    // Add an already existing FhirNutritionProduct to the end of the list.
    function AddItem(value : TFhirNutritionProduct) : TFhirNutritionProduct; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionProduct) : Integer;
    
    // Insert FhirNutritionProduct before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionProduct;
    
    // Insert an existing FhirNutritionProduct before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionProduct);
    
    // Get the iIndexth FhirNutritionProduct. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionProduct);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionProduct;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionProducts[index : Integer] : TFhirNutritionProduct read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
  // The legal status of supply of the packaged item as classified by the regulator.
  TFhirPackagedProductDefinitionLegalStatusOfSupply = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FJurisdiction : TFhirCodeableConcept;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetJurisdiction(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionLegalStatusOfSupply; overload;
    function Clone : TFhirPackagedProductDefinitionLegalStatusOfSupply; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual status of supply. In what situation this package type may be supplied for use. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The actual status of supply. In what situation this package type may be supplied for use.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context. (defined for API consistency)
    property jurisdiction : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;
    // The place where the legal status of supply applies. When not specified, this indicates it is unknown in this context.
    property jurisdictionElement : TFhirCodeableConcept read FJurisdiction write SetJurisdiction;

  end;

  TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
    function GetCurrent : TFhirPackagedProductDefinitionLegalStatusOfSupply;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionLegalStatusOfSupplyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionLegalStatusOfSupply read GetCurrent;
  end;

  TFhirPackagedProductDefinitionLegalStatusOfSupplyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionLegalStatusOfSupply;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionLegalStatusOfSupplyList; overload;
    function Clone : TFhirPackagedProductDefinitionLegalStatusOfSupplyList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionLegalStatusOfSupply to the end of the list.
    function Append : TFhirPackagedProductDefinitionLegalStatusOfSupply;
    
    // Add an already existing FhirPackagedProductDefinitionLegalStatusOfSupply to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinitionLegalStatusOfSupply) : TFhirPackagedProductDefinitionLegalStatusOfSupply; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionLegalStatusOfSupply) : Integer;
    
    // Insert FhirPackagedProductDefinitionLegalStatusOfSupply before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionLegalStatusOfSupply;
    
    // Insert an existing FhirPackagedProductDefinitionLegalStatusOfSupply before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
    
    // Get the iIndexth FhirPackagedProductDefinitionLegalStatusOfSupply. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionLegalStatusOfSupply);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionLegalStatusOfSupply;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionLegalStatusOfSupplies[index : Integer] : TFhirPackagedProductDefinitionLegalStatusOfSupply read GetItemN write SetItemN; default;
  End;

  // A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).
  TFhirPackagedProductDefinitionPackage = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirInteger;
    FmaterialList : TFhirCodeableConceptList;
    FalternateMaterialList : TFhirCodeableConceptList;
    FshelfLifeStorageList : TFhirProductShelfLifeList;
    FmanufacturerList : TFhirReferenceList;
    Fproperty_List : TFhirPackagedProductDefinitionPackagePropertyList;
    FcontainedItemList : TFhirPackagedProductDefinitionPackageContainedItemList;
    FpackageList : TFhirPackagedProductDefinitionPackageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirInteger);
    function GetQuantityST : String;
    procedure SetQuantityST(value : String);
    function GetMaterialList : TFhirCodeableConceptList;
    function GetHasMaterialList : Boolean;
    function GetAlternateMaterialList : TFhirCodeableConceptList;
    function GetHasAlternateMaterialList : Boolean;
    function GetShelfLifeStorageList : TFhirProductShelfLifeList;
    function GetHasShelfLifeStorageList : Boolean;
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetProperty_List : TFhirPackagedProductDefinitionPackagePropertyList;
    function GetHasProperty_List : Boolean;
    function GetContainedItemList : TFhirPackagedProductDefinitionPackageContainedItemList;
    function GetHasContainedItemList : Boolean;
    function GetPackageList : TFhirPackagedProductDefinitionPackageList;
    function GetHasPackageList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionPackage; overload;
    function Clone : TFhirPackagedProductDefinitionPackage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Including possibly Data Carrier Identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The physical type of the container of the items. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The physical type of the container of the items.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The quantity of this level of packaging in the package that contains it. If specified, the outermost level is always 1.
    property quantity : String read GetQuantityST write SetQuantityST;
    // The quantity of this level of packaging in the package that contains it. If specified, the outermost level is always 1.
    property quantityElement : TFhirInteger read FQuantity write SetQuantity;

    // Material type of the package item.
    property materialList : TFhirCodeableConceptList read GetMaterialList;
    property hasMaterialList : boolean read GetHasMaterialList;

    // A possible alternate material for the packaging.
    property alternateMaterialList : TFhirCodeableConceptList read GetAlternateMaterialList;
    property hasAlternateMaterialList : boolean read GetHasAlternateMaterialList;

    // Shelf Life and storage information.
    property shelfLifeStorageList : TFhirProductShelfLifeList read GetShelfLifeStorageList;
    property hasShelfLifeStorageList : boolean read GetHasShelfLifeStorageList;

    // Manufacturer of this package Item. When there are multiple it means these are all possible manufacturers.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // General characteristics of this item.
    property property_List : TFhirPackagedProductDefinitionPackagePropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // The item(s) within the packaging.
    property containedItemList : TFhirPackagedProductDefinitionPackageContainedItemList read GetContainedItemList;
    property hasContainedItemList : boolean read GetHasContainedItemList;

    // Allows containers (and parts of containers) parwithin containers, still a single packaged product.  See also PackagedProductDefinition.package.containedItem.item(PackagedProductDefinition).
    property packageList : TFhirPackagedProductDefinitionPackageList read GetPackageList;
    property hasPackageList : boolean read GetHasPackageList;

  end;

  TFhirPackagedProductDefinitionPackageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionPackageList;
    function GetCurrent : TFhirPackagedProductDefinitionPackage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionPackageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionPackage read GetCurrent;
  end;

  TFhirPackagedProductDefinitionPackageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionPackage;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionPackage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionPackageList; overload;
    function Clone : TFhirPackagedProductDefinitionPackageList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionPackageListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionPackage to the end of the list.
    function Append : TFhirPackagedProductDefinitionPackage;
    
    // Add an already existing FhirPackagedProductDefinitionPackage to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinitionPackage) : TFhirPackagedProductDefinitionPackage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionPackage) : Integer;
    
    // Insert FhirPackagedProductDefinitionPackage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionPackage;
    
    // Insert an existing FhirPackagedProductDefinitionPackage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionPackage);
    
    // Get the iIndexth FhirPackagedProductDefinitionPackage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionPackage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionPackage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionPackages[index : Integer] : TFhirPackagedProductDefinitionPackage read GetItemN write SetItemN; default;
  End;

  // General characteristics of this item.
  TFhirPackagedProductDefinitionPackageProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionPackageProperty; overload;
    function Clone : TFhirPackagedProductDefinitionPackageProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirPackagedProductDefinitionPackagePropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionPackagePropertyList;
    function GetCurrent : TFhirPackagedProductDefinitionPackageProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionPackagePropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionPackageProperty read GetCurrent;
  end;

  TFhirPackagedProductDefinitionPackagePropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionPackageProperty;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionPackageProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionPackagePropertyList; overload;
    function Clone : TFhirPackagedProductDefinitionPackagePropertyList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionPackagePropertyListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionPackageProperty to the end of the list.
    function Append : TFhirPackagedProductDefinitionPackageProperty;
    
    // Add an already existing FhirPackagedProductDefinitionPackageProperty to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinitionPackageProperty) : TFhirPackagedProductDefinitionPackageProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionPackageProperty) : Integer;
    
    // Insert FhirPackagedProductDefinitionPackageProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionPackageProperty;
    
    // Insert an existing FhirPackagedProductDefinitionPackageProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionPackageProperty);
    
    // Get the iIndexth FhirPackagedProductDefinitionPackageProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionPackageProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionPackageProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionPackageProperties[index : Integer] : TFhirPackagedProductDefinitionPackageProperty read GetItemN write SetItemN; default;
  End;

  // The item(s) within the packaging.
  TFhirPackagedProductDefinitionPackageContainedItem = class (TFhirBackboneElement)
  protected
    FItem : TFhirCodeableReference;
    FAmount : TFhirQuantity;
    procedure SetItem(value : TFhirCodeableReference);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinitionPackageContainedItem; overload;
    function Clone : TFhirPackagedProductDefinitionPackageContainedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.package.package). (defined for API consistency)
    property item : TFhirCodeableReference read FItem write SetItem;
    // The actual item(s) of medication, as manufactured, or a device (typically, but not necessarily, a co-packaged one), or other medically related item (such as food, biologicals, raw materials, medical fluids, gases etc.), as contained in the package. This also allows another whole packaged product to be included, which is solely for the case where a package of other entire packages is wanted - such as a wholesale or distribution pack (for layers within one package, use PackagedProductDefinition.package.package).
    property itemElement : TFhirCodeableReference read FItem write SetItem;

    // Typed access to The number of this type of item within this packaging. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // The number of this type of item within this packaging.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirPackagedProductDefinitionPackageContainedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionPackageContainedItemList;
    function GetCurrent : TFhirPackagedProductDefinitionPackageContainedItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionPackageContainedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinitionPackageContainedItem read GetCurrent;
  end;

  TFhirPackagedProductDefinitionPackageContainedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinitionPackageContainedItem;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinitionPackageContainedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionPackageContainedItemList; overload;
    function Clone : TFhirPackagedProductDefinitionPackageContainedItemList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionPackageContainedItemListEnumerator;
    
    //  Add a FhirPackagedProductDefinitionPackageContainedItem to the end of the list.
    function Append : TFhirPackagedProductDefinitionPackageContainedItem;
    
    // Add an already existing FhirPackagedProductDefinitionPackageContainedItem to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinitionPackageContainedItem) : TFhirPackagedProductDefinitionPackageContainedItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinitionPackageContainedItem) : Integer;
    
    // Insert FhirPackagedProductDefinitionPackageContainedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinitionPackageContainedItem;
    
    // Insert an existing FhirPackagedProductDefinitionPackageContainedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinitionPackageContainedItem);
    
    // Get the iIndexth FhirPackagedProductDefinitionPackageContainedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinitionPackageContainedItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinitionPackageContainedItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitionPackageContainedItems[index : Integer] : TFhirPackagedProductDefinitionPackageContainedItem read GetItemN write SetItemN; default;
  End;

  // A medically related item or items, in a container or package.
  TFhirPackagedProductDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FpackageForList : TFhirReferenceList;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FcontainedItemQuantityList : TFhirQuantityList;
    FDescription : TFhirMarkdown;
    FlegalStatusOfSupplyList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
    FmarketingStatusList : TFhirMarketingStatusList;
    FcharacteristicList : TFhirCodeableConceptList;
    FCopackagedIndicator : TFhirBoolean;
    FmanufacturerList : TFhirReferenceList;
    FPackage : TFhirPackagedProductDefinitionPackage;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetPackageForList : TFhirReferenceList;
    function GetHasPackageForList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    function GetContainedItemQuantityList : TFhirQuantityList;
    function GetHasContainedItemQuantityList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetLegalStatusOfSupplyList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
    function GetHasLegalStatusOfSupplyList : Boolean;
    function GetMarketingStatusList : TFhirMarketingStatusList;
    function GetHasMarketingStatusList : Boolean;
    function GetCharacteristicList : TFhirCodeableConceptList;
    function GetHasCharacteristicList : Boolean;
    procedure SetCopackagedIndicator(value : TFhirBoolean);
    function GetCopackagedIndicatorST : Boolean;
    procedure SetCopackagedIndicatorST(value : Boolean);
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    procedure SetPackage(value : TFhirPackagedProductDefinitionPackage);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPackagedProductDefinition; overload;
    function Clone : TFhirPackagedProductDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.
    property name : String read GetNameST write SetNameST;
    // A name for this package. Typically what it would be listed as in a drug formulary or catalogue, inventory etc.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A high level category e.g. medicinal product, raw material, shipping/transport container, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A high level category e.g. medicinal product, raw material, shipping/transport container, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The product that this is a pack for.
    property packageForList : TFhirReferenceList read GetPackageForList;
    property hasPackageForList : boolean read GetHasPackageForList;

    // Typed access to The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status within the lifecycle of this item. A high level status, this is not intended to duplicate details carried elsewhere such as legal status, or authorization or marketing status.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the given status became applicable.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the given status became applicable.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // A total of the amount of items in the package, per item type. This can be considered as the pack size. This attribute differs from containedItem.amount in that it can give a single aggregated count of all tablet types in a pack, even when these are different manufactured items. For example a pill pack of 21 tablets plus 7 sugar tablets, can be denoted here as '28 tablets'. This attribute is repeatable so that the different item types in one pack type can be counted (e.g. a count of vials and count of syringes). Each repeat must have different units, so that it is clear what the different sets of counted items are, and it is not intended to allow different counts of similar items (e.g. not '2 tubes and 3 tubes'). Repeats are not to be used to represent different pack sizes (e.g. 20 pack vs. 50 pack) - which would be different instances of this resource.
    property containedItemQuantityList : TFhirQuantityList read GetContainedItemQuantityList;
    property hasContainedItemQuantityList : boolean read GetHasContainedItemQuantityList;

    // Typed access to Textual description. Note that this is not the name of the package or product.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description. Note that this is not the name of the package or product.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The legal status of supply of the packaged item as classified by the regulator.
    property legalStatusOfSupplyList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList read GetLegalStatusOfSupplyList;
    property hasLegalStatusOfSupplyList : boolean read GetHasLegalStatusOfSupplyList;

    // Marketing information.
    property marketingStatusList : TFhirMarketingStatusList read GetMarketingStatusList;
    property hasMarketingStatusList : boolean read GetHasMarketingStatusList;

    // Allows the key features to be recorded, such as "hospital pack", "nurse prescribable", "calendar pack".
    property characteristicList : TFhirCodeableConceptList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Typed access to States whether a drug product is supplied with another item such as a diluent or adjuvant.
    property copackagedIndicator : Boolean read GetCopackagedIndicatorST write SetCopackagedIndicatorST;
    // States whether a drug product is supplied with another item such as a diluent or adjuvant.
    property copackagedIndicatorElement : TFhirBoolean read FCopackagedIndicator write SetCopackagedIndicator;

    // Manufacturer of this package type. When there are multiple it means these are all possible manufacturers.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // Typed access to A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item). (defined for API consistency)
    property package : TFhirPackagedProductDefinitionPackage read FPackage write SetPackage;
    // A packaging item, as a container for medically related items, possibly with other packaging items within, or a packaging component, such as bottle cap (which is not a device or a medication manufactured item).
    property packageElement : TFhirPackagedProductDefinitionPackage read FPackage write SetPackage;

  end;

  TFhirPackagedProductDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPackagedProductDefinitionList;
    function GetCurrent : TFhirPackagedProductDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPackagedProductDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPackagedProductDefinition read GetCurrent;
  end;

  TFhirPackagedProductDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPackagedProductDefinition;
    procedure SetItemN(index : Integer; value : TFhirPackagedProductDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPackagedProductDefinitionList; overload;
    function Clone : TFhirPackagedProductDefinitionList; overload;
    function GetEnumerator : TFhirPackagedProductDefinitionListEnumerator;
    
    //  Add a FhirPackagedProductDefinition to the end of the list.
    function Append : TFhirPackagedProductDefinition;
    
    // Add an already existing FhirPackagedProductDefinition to the end of the list.
    function AddItem(value : TFhirPackagedProductDefinition) : TFhirPackagedProductDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPackagedProductDefinition) : Integer;
    
    // Insert FhirPackagedProductDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPackagedProductDefinition;
    
    // Insert an existing FhirPackagedProductDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPackagedProductDefinition);
    
    // Get the iIndexth FhirPackagedProductDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPackagedProductDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPackagedProductDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPackagedProductDefinitions[index : Integer] : TFhirPackagedProductDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
  // The case or regulatory procedure for granting or amending a marketing authorization. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).
  TFhirRegulatedAuthorizationCase = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FDate : TFhirDataType;
    FapplicationList : TFhirRegulatedAuthorizationCaseList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDataType);
    function GetApplicationList : TFhirRegulatedAuthorizationCaseList;
    function GetHasApplicationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRegulatedAuthorizationCase; overload;
    function Clone : TFhirRegulatedAuthorizationCase; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier by which this case can be referenced. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier by which this case can be referenced.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to The defining type of case. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The defining type of case.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The status associated with the case. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status associated with the case.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Relevant date for this of case. (defined for API consistency)
    property date : TFhirDataType read FDate write SetDate;
    // Relevant date for this of case.
    property dateElement : TFhirDataType read FDate write SetDate;

    // Applications submitted to obtain a marketing authorization. Steps within the longer running case or procedure.
    property applicationList : TFhirRegulatedAuthorizationCaseList read GetApplicationList;
    property hasApplicationList : boolean read GetHasApplicationList;

  end;

  TFhirRegulatedAuthorizationCaseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRegulatedAuthorizationCaseList;
    function GetCurrent : TFhirRegulatedAuthorizationCase;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRegulatedAuthorizationCaseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRegulatedAuthorizationCase read GetCurrent;
  end;

  TFhirRegulatedAuthorizationCaseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRegulatedAuthorizationCase;
    procedure SetItemN(index : Integer; value : TFhirRegulatedAuthorizationCase);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRegulatedAuthorizationCaseList; overload;
    function Clone : TFhirRegulatedAuthorizationCaseList; overload;
    function GetEnumerator : TFhirRegulatedAuthorizationCaseListEnumerator;
    
    //  Add a FhirRegulatedAuthorizationCase to the end of the list.
    function Append : TFhirRegulatedAuthorizationCase;
    
    // Add an already existing FhirRegulatedAuthorizationCase to the end of the list.
    function AddItem(value : TFhirRegulatedAuthorizationCase) : TFhirRegulatedAuthorizationCase; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRegulatedAuthorizationCase) : Integer;
    
    // Insert FhirRegulatedAuthorizationCase before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRegulatedAuthorizationCase;
    
    // Insert an existing FhirRegulatedAuthorizationCase before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRegulatedAuthorizationCase);
    
    // Get the iIndexth FhirRegulatedAuthorizationCase. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRegulatedAuthorizationCase);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRegulatedAuthorizationCase;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRegulatedAuthorizationCases[index : Integer] : TFhirRegulatedAuthorizationCase read GetItemN write SetItemN; default;
  End;

  // Regulatory approval, clearance or licencing related to a regulated product, treatment, facility or activity that is cited in a guidance, regulation, rule or legislative act. An example is Market Authorization relating to a Medicinal Product.
  TFhirRegulatedAuthorization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FsubjectList : TFhirReferenceList;
    FType_ : TFhirCodeableConcept;
    FDescription : TFhirMarkdown;
    FregionList : TFhirCodeableConceptList;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FValidityPeriod : TFhirPeriod;
    FIndication : TFhirCodeableReference;
    FIntendedUse : TFhirCodeableConcept;
    FbasisList : TFhirCodeableConceptList;
    FHolder : TFhirReference;
    FRegulator : TFhirReference;
    FCase_ : TFhirRegulatedAuthorizationCase;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetRegionList : TFhirCodeableConceptList;
    function GetHasRegionList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetValidityPeriod(value : TFhirPeriod);
    procedure SetIndication(value : TFhirCodeableReference);
    procedure SetIntendedUse(value : TFhirCodeableConcept);
    function GetBasisList : TFhirCodeableConceptList;
    function GetHasBasisList : Boolean;
    procedure SetHolder(value : TFhirReference);
    procedure SetRegulator(value : TFhirReference);
    procedure SetCase_(value : TFhirRegulatedAuthorizationCase);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRegulatedAuthorization; overload;
    function Clone : TFhirRegulatedAuthorization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for the authorization, typically assigned by the authorizing body.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The product type, treatment, facility or activity that is being authorized.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to Overall type of this authorization, for example drug marketing approval, orphan drug designation. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Overall type of this authorization, for example drug marketing approval, orphan drug designation.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to General textual supporting information.
    property description : String read GetDescriptionST write SetDescriptionST;
    // General textual supporting information.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The territory (e.g., country, jurisdiction etc.) in which the authorization has been granted.
    property regionList : TFhirCodeableConceptList read GetRegionList;
    property hasRegionList : boolean read GetHasRegionList;

    // Typed access to The status that is authorised e.g. approved. Intermediate states can be tracked with cases and applications. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status that is authorised e.g. approved. Intermediate states can be tracked with cases and applications.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the current status was assigned.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the current status was assigned.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date. (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // The time period in which the regulatory approval, clearance or licencing is in effect. As an example, a Marketing Authorization includes the date of authorization and/or an expiration date.
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Typed access to Condition for which the use of the regulated product applies. (defined for API consistency)
    property indication : TFhirCodeableReference read FIndication write SetIndication;
    // Condition for which the use of the regulated product applies.
    property indicationElement : TFhirCodeableReference read FIndication write SetIndication;

    // Typed access to The intended use of the product, e.g. prevention, treatment. (defined for API consistency)
    property intendedUse : TFhirCodeableConcept read FIntendedUse write SetIntendedUse;
    // The intended use of the product, e.g. prevention, treatment.
    property intendedUseElement : TFhirCodeableConcept read FIntendedUse write SetIntendedUse;

    // The legal or regulatory framework against which this authorization is granted, or other reasons for it.
    property basisList : TFhirCodeableConceptList read GetBasisList;
    property hasBasisList : boolean read GetHasBasisList;

    // Typed access to The organization that holds the granted authorization. (defined for API consistency)
    property holder : TFhirReference read FHolder write SetHolder;
    // The organization that holds the granted authorization.
    property holderElement : TFhirReference read FHolder write SetHolder;

    // Typed access to The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc. (defined for API consistency)
    property regulator : TFhirReference read FRegulator write SetRegulator;
    // The regulatory authority or authorizing body granting the authorization. For example, European Medicines Agency (EMA), Food and Drug Administration (FDA), Health Canada (HC), etc.
    property regulatorElement : TFhirReference read FRegulator write SetRegulator;

    // Typed access to The case or regulatory procedure for granting or amending a marketing authorization. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page). (defined for API consistency)
    property case_ : TFhirRegulatedAuthorizationCase read FCase_ write SetCase_;
    // The case or regulatory procedure for granting or amending a marketing authorization. Note: This area is subject to ongoing review and the workgroup is seeking implementer feedback on its use (see link at bottom of page).
    property case_Element : TFhirRegulatedAuthorizationCase read FCase_ write SetCase_;

  end;

  TFhirRegulatedAuthorizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRegulatedAuthorizationList;
    function GetCurrent : TFhirRegulatedAuthorization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRegulatedAuthorizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRegulatedAuthorization read GetCurrent;
  end;

  TFhirRegulatedAuthorizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRegulatedAuthorization;
    procedure SetItemN(index : Integer; value : TFhirRegulatedAuthorization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRegulatedAuthorizationList; overload;
    function Clone : TFhirRegulatedAuthorizationList; overload;
    function GetEnumerator : TFhirRegulatedAuthorizationListEnumerator;
    
    //  Add a FhirRegulatedAuthorization to the end of the list.
    function Append : TFhirRegulatedAuthorization;
    
    // Add an already existing FhirRegulatedAuthorization to the end of the list.
    function AddItem(value : TFhirRegulatedAuthorization) : TFhirRegulatedAuthorization; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRegulatedAuthorization) : Integer;
    
    // Insert FhirRegulatedAuthorization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRegulatedAuthorization;
    
    // Insert an existing FhirRegulatedAuthorization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRegulatedAuthorization);
    
    // Get the iIndexth FhirRegulatedAuthorization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRegulatedAuthorization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRegulatedAuthorization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRegulatedAuthorizations[index : Integer] : TFhirRegulatedAuthorization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_SUBSTANCE}
  // Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
  TFhirSubstanceInstance = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FExpiry : TFhirDateTime;
    FQuantity : TFhirQuantity;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetExpiry(value : TFhirDateTime);
    function GetExpiryST : TFslDateTime;
    procedure SetExpiryST(value : TFslDateTime);
    procedure SetQuantity(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceInstance; overload;
    function Clone : TFhirSubstanceInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier associated with the package/container (usually a label affixed directly). (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier associated with the package/container (usually a label affixed directly).
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    property expiry : TFslDateTime read GetExpiryST write SetExpiryST;
    // When the substance is no longer valid to use. For some substances, a single arbitrary date is used for expiry.
    property expiryElement : TFhirDateTime read FExpiry write SetExpiry;

    // Typed access to The amount of the substance. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of the substance.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

  end;

  TFhirSubstanceInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceInstanceList;
    function GetCurrent : TFhirSubstanceInstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceInstance read GetCurrent;
  end;

  TFhirSubstanceInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceInstance;
    procedure SetItemN(index : Integer; value : TFhirSubstanceInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceInstanceList; overload;
    function Clone : TFhirSubstanceInstanceList; overload;
    function GetEnumerator : TFhirSubstanceInstanceListEnumerator;
    
    //  Add a FhirSubstanceInstance to the end of the list.
    function Append : TFhirSubstanceInstance;
    
    // Add an already existing FhirSubstanceInstance to the end of the list.
    function AddItem(value : TFhirSubstanceInstance) : TFhirSubstanceInstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceInstance) : Integer;
    
    // Insert FhirSubstanceInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceInstance;
    
    // Insert an existing FhirSubstanceInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceInstance);
    
    // Get the iIndexth FhirSubstanceInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceInstances[index : Integer] : TFhirSubstanceInstance read GetItemN write SetItemN; default;
  End;

  // A substance can be composed of other substances.
  TFhirSubstanceIngredient = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirRatio;
    FSubstance : TFhirDataType;
    procedure SetQuantity(value : TFhirRatio);
    procedure SetSubstance(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceIngredient; overload;
    function Clone : TFhirSubstanceIngredient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount of the ingredient in the substance - a concentration ratio. (defined for API consistency)
    property quantity : TFhirRatio read FQuantity write SetQuantity;
    // The amount of the ingredient in the substance - a concentration ratio.
    property quantityElement : TFhirRatio read FQuantity write SetQuantity;

    // Typed access to Another substance that is a component of this substance. (defined for API consistency)
    property substance : TFhirDataType read FSubstance write SetSubstance;
    // Another substance that is a component of this substance.
    property substanceElement : TFhirDataType read FSubstance write SetSubstance;

  end;

  TFhirSubstanceIngredientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceIngredientList;
    function GetCurrent : TFhirSubstanceIngredient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceIngredientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceIngredient read GetCurrent;
  end;

  TFhirSubstanceIngredientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceIngredient;
    procedure SetItemN(index : Integer; value : TFhirSubstanceIngredient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceIngredientList; overload;
    function Clone : TFhirSubstanceIngredientList; overload;
    function GetEnumerator : TFhirSubstanceIngredientListEnumerator;
    
    //  Add a FhirSubstanceIngredient to the end of the list.
    function Append : TFhirSubstanceIngredient;
    
    // Add an already existing FhirSubstanceIngredient to the end of the list.
    function AddItem(value : TFhirSubstanceIngredient) : TFhirSubstanceIngredient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceIngredient) : Integer;
    
    // Insert FhirSubstanceIngredient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceIngredient;
    
    // Insert an existing FhirSubstanceIngredient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceIngredient);
    
    // Get the iIndexth FhirSubstanceIngredient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceIngredient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceIngredient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceIngredients[index : Integer] : TFhirSubstanceIngredient read GetItemN write SetItemN; default;
  End;

  // A homogeneous material with a definite composition.
  TFhirSubstance = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FinstanceList : TFhirSubstanceInstanceList;
    FingredientList : TFhirSubstanceIngredientList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFHIRSubstanceStatusEnum;
    procedure SetStatusST(value : TFhirFHIRSubstanceStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetInstanceList : TFhirSubstanceInstanceList;
    function GetHasInstanceList : Boolean;
    function GetIngredientList : TFhirSubstanceIngredientList;
    function GetHasIngredientList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstance; overload;
    function Clone : TFhirSubstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier for the substance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A code to indicate if the substance is actively used.
    property status : TFhirFHIRSubstanceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code that classifies the general type of substance.  This is used  for searching, sorting and display purposes.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A code (or set of codes) that identify this substance. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code (or set of codes) that identify this substance.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A description of the substance - its appearance, handling requirements, and other usage notes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the substance - its appearance, handling requirements, and other usage notes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Substance may be used to describe a kind of substance, or a specific package/container of the substance: an instance.
    property instanceList : TFhirSubstanceInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

    // A substance can be composed of other substances.
    property ingredientList : TFhirSubstanceIngredientList read GetIngredientList;
    property hasIngredientList : boolean read GetHasIngredientList;

  end;

  TFhirSubstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceList;
    function GetCurrent : TFhirSubstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstance read GetCurrent;
  end;

  TFhirSubstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstance;
    procedure SetItemN(index : Integer; value : TFhirSubstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceList; overload;
    function Clone : TFhirSubstanceList; overload;
    function GetEnumerator : TFhirSubstanceListEnumerator;
    
    //  Add a FhirSubstance to the end of the list.
    function Append : TFhirSubstance;
    
    // Add an already existing FhirSubstance to the end of the list.
    function AddItem(value : TFhirSubstance) : TFhirSubstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstance) : Integer;
    
    // Insert FhirSubstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstance;
    
    // Insert an existing FhirSubstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstance);
    
    // Get the iIndexth FhirSubstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstances[index : Integer] : TFhirSubstance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
  // Moiety, for structural modifications.
  TFhirSubstanceDefinitionMoiety = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FStereochemistry : TFhirCodeableConcept;
    FOpticalActivity : TFhirCodeableConcept;
    FMolecularFormula : TFhirString;
    FAmount : TFhirDataType;
    FAmountType : TFhirCodeableConcept;
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStereochemistry(value : TFhirCodeableConcept);
    procedure SetOpticalActivity(value : TFhirCodeableConcept);
    procedure SetMolecularFormula(value : TFhirString);
    function GetMolecularFormulaST : String;
    procedure SetMolecularFormulaST(value : String);
    procedure SetAmount(value : TFhirDataType);
    procedure SetAmountType(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionMoiety; overload;
    function Clone : TFhirSubstanceDefinitionMoiety; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Role that the moiety is playing. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role that the moiety is playing.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Identifier by which this moiety substance is known. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier by which this moiety substance is known.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Textual name for this moiety substance.
    property name : String read GetNameST write SetNameST;
    // Textual name for this moiety substance.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Stereochemistry type. (defined for API consistency)
    property stereochemistry : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;
    // Stereochemistry type.
    property stereochemistryElement : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;

    // Typed access to Optical activity type. (defined for API consistency)
    property opticalActivity : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;
    // Optical activity type.
    property opticalActivityElement : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;

    // Typed access to Molecular formula for this moiety of this substance, typically using the Hill system.
    property molecularFormula : String read GetMolecularFormulaST write SetMolecularFormulaST;
    // Molecular formula for this moiety of this substance, typically using the Hill system.
    property molecularFormulaElement : TFhirString read FMolecularFormula write SetMolecularFormula;

    // Typed access to Quantitative value for this moiety. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // Quantitative value for this moiety.
    property amountElement : TFhirDataType read FAmount write SetAmount;

    // Typed access to The measurement type of the quantitative value. (defined for API consistency)
    property amountType : TFhirCodeableConcept read FAmountType write SetAmountType;
    // The measurement type of the quantitative value.
    property amountTypeElement : TFhirCodeableConcept read FAmountType write SetAmountType;

  end;

  TFhirSubstanceDefinitionMoietyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionMoietyList;
    function GetCurrent : TFhirSubstanceDefinitionMoiety;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionMoietyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionMoiety read GetCurrent;
  end;

  TFhirSubstanceDefinitionMoietyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionMoiety;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionMoiety);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionMoietyList; overload;
    function Clone : TFhirSubstanceDefinitionMoietyList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionMoietyListEnumerator;
    
    //  Add a FhirSubstanceDefinitionMoiety to the end of the list.
    function Append : TFhirSubstanceDefinitionMoiety;
    
    // Add an already existing FhirSubstanceDefinitionMoiety to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionMoiety) : TFhirSubstanceDefinitionMoiety; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionMoiety) : Integer;
    
    // Insert FhirSubstanceDefinitionMoiety before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionMoiety;
    
    // Insert an existing FhirSubstanceDefinitionMoiety before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionMoiety);
    
    // Get the iIndexth FhirSubstanceDefinitionMoiety. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionMoiety);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionMoiety;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionMoieties[index : Integer] : TFhirSubstanceDefinitionMoiety read GetItemN write SetItemN; default;
  End;

  // General specifications for this substance.
  TFhirSubstanceDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionProperty; overload;
    function Clone : TFhirSubstanceDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code expressing the type of characteristic. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code expressing the type of characteristic.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A value for the characteristic. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // A value for the characteristic.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirSubstanceDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionPropertyList;
    function GetCurrent : TFhirSubstanceDefinitionProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionProperty read GetCurrent;
  end;

  TFhirSubstanceDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionPropertyList; overload;
    function Clone : TFhirSubstanceDefinitionPropertyList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionPropertyListEnumerator;
    
    //  Add a FhirSubstanceDefinitionProperty to the end of the list.
    function Append : TFhirSubstanceDefinitionProperty;
    
    // Add an already existing FhirSubstanceDefinitionProperty to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionProperty) : TFhirSubstanceDefinitionProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionProperty) : Integer;
    
    // Insert FhirSubstanceDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionProperty;
    
    // Insert an existing FhirSubstanceDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionProperty);
    
    // Get the iIndexth FhirSubstanceDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionProperties[index : Integer] : TFhirSubstanceDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // The molecular weight or weight range (for proteins, polymers or nucleic acids).
  TFhirSubstanceDefinitionMolecularWeight = class (TFhirBackboneElement)
  protected
    FMethod : TFhirCodeableConcept;
    FType_ : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionMolecularWeight; overload;
    function Clone : TFhirSubstanceDefinitionMolecularWeight; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The method by which the molecular weight was determined. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // The method by which the molecular weight was determined.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to Type of molecular weight such as exact, average (also known as. number average), weight average. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of molecular weight such as exact, average (also known as. number average), weight average.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirSubstanceDefinitionMolecularWeightListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionMolecularWeightList;
    function GetCurrent : TFhirSubstanceDefinitionMolecularWeight;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionMolecularWeightList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionMolecularWeight read GetCurrent;
  end;

  TFhirSubstanceDefinitionMolecularWeightList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionMolecularWeight;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionMolecularWeight);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionMolecularWeightList; overload;
    function Clone : TFhirSubstanceDefinitionMolecularWeightList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionMolecularWeightListEnumerator;
    
    //  Add a FhirSubstanceDefinitionMolecularWeight to the end of the list.
    function Append : TFhirSubstanceDefinitionMolecularWeight;
    
    // Add an already existing FhirSubstanceDefinitionMolecularWeight to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionMolecularWeight) : TFhirSubstanceDefinitionMolecularWeight; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionMolecularWeight) : Integer;
    
    // Insert FhirSubstanceDefinitionMolecularWeight before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionMolecularWeight;
    
    // Insert an existing FhirSubstanceDefinitionMolecularWeight before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionMolecularWeight);
    
    // Get the iIndexth FhirSubstanceDefinitionMolecularWeight. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionMolecularWeight);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionMolecularWeight;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionMolecularWeights[index : Integer] : TFhirSubstanceDefinitionMolecularWeight read GetItemN write SetItemN; default;
  End;

  // Structural information.
  TFhirSubstanceDefinitionStructure = class (TFhirBackboneElement)
  protected
    FStereochemistry : TFhirCodeableConcept;
    FOpticalActivity : TFhirCodeableConcept;
    FMolecularFormula : TFhirString;
    FMolecularFormulaByMoiety : TFhirString;
    FMolecularWeight : TFhirSubstanceDefinitionMolecularWeight;
    FtechniqueList : TFhirCodeableConceptList;
    FsourceDocumentList : TFhirReferenceList;
    FrepresentationList : TFhirSubstanceDefinitionStructureRepresentationList;
    procedure SetStereochemistry(value : TFhirCodeableConcept);
    procedure SetOpticalActivity(value : TFhirCodeableConcept);
    procedure SetMolecularFormula(value : TFhirString);
    function GetMolecularFormulaST : String;
    procedure SetMolecularFormulaST(value : String);
    procedure SetMolecularFormulaByMoiety(value : TFhirString);
    function GetMolecularFormulaByMoietyST : String;
    procedure SetMolecularFormulaByMoietyST(value : String);
    procedure SetMolecularWeight(value : TFhirSubstanceDefinitionMolecularWeight);
    function GetTechniqueList : TFhirCodeableConceptList;
    function GetHasTechniqueList : Boolean;
    function GetSourceDocumentList : TFhirReferenceList;
    function GetHasSourceDocumentList : Boolean;
    function GetRepresentationList : TFhirSubstanceDefinitionStructureRepresentationList;
    function GetHasRepresentationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionStructure; overload;
    function Clone : TFhirSubstanceDefinitionStructure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Stereochemistry type. (defined for API consistency)
    property stereochemistry : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;
    // Stereochemistry type.
    property stereochemistryElement : TFhirCodeableConcept read FStereochemistry write SetStereochemistry;

    // Typed access to Optical activity type. (defined for API consistency)
    property opticalActivity : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;
    // Optical activity type.
    property opticalActivityElement : TFhirCodeableConcept read FOpticalActivity write SetOpticalActivity;

    // Typed access to Molecular formula of this substance, typically using the Hill system.
    property molecularFormula : String read GetMolecularFormulaST write SetMolecularFormulaST;
    // Molecular formula of this substance, typically using the Hill system.
    property molecularFormulaElement : TFhirString read FMolecularFormula write SetMolecularFormula;

    // Typed access to Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
    property molecularFormulaByMoiety : String read GetMolecularFormulaByMoietyST write SetMolecularFormulaByMoietyST;
    // Specified per moiety according to the Hill system, i.e. first C, then H, then alphabetical, each moiety separated by a dot.
    property molecularFormulaByMoietyElement : TFhirString read FMolecularFormulaByMoiety write SetMolecularFormulaByMoiety;

    // Typed access to The molecular weight or weight range (for proteins, polymers or nucleic acids). (defined for API consistency)
    property molecularWeight : TFhirSubstanceDefinitionMolecularWeight read FMolecularWeight write SetMolecularWeight;
    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightElement : TFhirSubstanceDefinitionMolecularWeight read FMolecularWeight write SetMolecularWeight;

    // The method used to elucidate the structure or characterization of the drug substance. Examples: X-ray, HPLC, NMR, Peptide mapping, Ligand binding assay.
    property techniqueList : TFhirCodeableConceptList read GetTechniqueList;
    property hasTechniqueList : boolean read GetHasTechniqueList;

    // Supporting literature about the source of information.
    property sourceDocumentList : TFhirReferenceList read GetSourceDocumentList;
    property hasSourceDocumentList : boolean read GetHasSourceDocumentList;

    // A depiction of the structure or characterization of the substance.
    property representationList : TFhirSubstanceDefinitionStructureRepresentationList read GetRepresentationList;
    property hasRepresentationList : boolean read GetHasRepresentationList;

  end;

  TFhirSubstanceDefinitionStructureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionStructureList;
    function GetCurrent : TFhirSubstanceDefinitionStructure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionStructureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionStructure read GetCurrent;
  end;

  TFhirSubstanceDefinitionStructureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionStructure;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionStructure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionStructureList; overload;
    function Clone : TFhirSubstanceDefinitionStructureList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionStructureListEnumerator;
    
    //  Add a FhirSubstanceDefinitionStructure to the end of the list.
    function Append : TFhirSubstanceDefinitionStructure;
    
    // Add an already existing FhirSubstanceDefinitionStructure to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionStructure) : TFhirSubstanceDefinitionStructure; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionStructure) : Integer;
    
    // Insert FhirSubstanceDefinitionStructure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionStructure;
    
    // Insert an existing FhirSubstanceDefinitionStructure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionStructure);
    
    // Get the iIndexth FhirSubstanceDefinitionStructure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionStructure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionStructure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionStructures[index : Integer] : TFhirSubstanceDefinitionStructure read GetItemN write SetItemN; default;
  End;

  // A depiction of the structure or characterization of the substance.
  TFhirSubstanceDefinitionStructureRepresentation = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FRepresentation : TFhirString;
    FFormat : TFhirCodeableConcept;
    FDocument : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRepresentation(value : TFhirString);
    function GetRepresentationST : String;
    procedure SetRepresentationST(value : String);
    procedure SetFormat(value : TFhirCodeableConcept);
    procedure SetDocument(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionStructureRepresentation; overload;
    function Clone : TFhirSubstanceDefinitionStructureRepresentation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of structural representation (e.g. full, partial) or the technique used to derive the analytical characterization of the substance (e.g. x-ray, HPLC, NMR, peptide mapping, ligand binding assay, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of structural representation (e.g. full, partial) or the technique used to derive the analytical characterization of the substance (e.g. x-ray, HPLC, NMR, peptide mapping, ligand binding assay, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The structural representation or characterization as a text string in a standard format.
    property representation : String read GetRepresentationST write SetRepresentationST;
    // The structural representation or characterization as a text string in a standard format.
    property representationElement : TFhirString read FRepresentation write SetRepresentation;

    // Typed access to The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document. (defined for API consistency)
    property format : TFhirCodeableConcept read FFormat write SetFormat;
    // The format of the representation e.g. InChI, SMILES, MOLFILE, CDX, SDF, PDB, mmCIF. The logical content type rather than the physical file format of a document.
    property formatElement : TFhirCodeableConcept read FFormat write SetFormat;

    // Typed access to An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file. (defined for API consistency)
    property document : TFhirReference read FDocument write SetDocument;
    // An attached file with the structural representation or characterization e.g. a molecular structure graphic of the substance, a JCAMP or AnIML file.
    property documentElement : TFhirReference read FDocument write SetDocument;

  end;

  TFhirSubstanceDefinitionStructureRepresentationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionStructureRepresentationList;
    function GetCurrent : TFhirSubstanceDefinitionStructureRepresentation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionStructureRepresentationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionStructureRepresentation read GetCurrent;
  end;

  TFhirSubstanceDefinitionStructureRepresentationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionStructureRepresentation;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionStructureRepresentation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionStructureRepresentationList; overload;
    function Clone : TFhirSubstanceDefinitionStructureRepresentationList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionStructureRepresentationListEnumerator;
    
    //  Add a FhirSubstanceDefinitionStructureRepresentation to the end of the list.
    function Append : TFhirSubstanceDefinitionStructureRepresentation;
    
    // Add an already existing FhirSubstanceDefinitionStructureRepresentation to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionStructureRepresentation) : TFhirSubstanceDefinitionStructureRepresentation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionStructureRepresentation) : Integer;
    
    // Insert FhirSubstanceDefinitionStructureRepresentation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionStructureRepresentation;
    
    // Insert an existing FhirSubstanceDefinitionStructureRepresentation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionStructureRepresentation);
    
    // Get the iIndexth FhirSubstanceDefinitionStructureRepresentation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionStructureRepresentation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionStructureRepresentation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionStructureRepresentations[index : Integer] : TFhirSubstanceDefinitionStructureRepresentation read GetItemN write SetItemN; default;
  End;

  // Codes associated with the substance.
  TFhirSubstanceDefinitionCode = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FStatusDate : TFhirDateTime;
    FnoteList : TFhirAnnotationList;
    FsourceList : TFhirReferenceList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionCode; overload;
    function Clone : TFhirSubstanceDefinitionCode; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The specific code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Status of the code assignment, for example 'provisional', 'approved'. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Status of the code assignment, for example 'provisional', 'approved'.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to The date at which the code status is changed as part of the terminology maintenance.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // The date at which the code status is changed as part of the terminology maintenance.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Any comment can be provided in this field, if necessary.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionCodeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionCodeList;
    function GetCurrent : TFhirSubstanceDefinitionCode;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionCodeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionCode read GetCurrent;
  end;

  TFhirSubstanceDefinitionCodeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionCode;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionCode);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionCodeList; overload;
    function Clone : TFhirSubstanceDefinitionCodeList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionCodeListEnumerator;
    
    //  Add a FhirSubstanceDefinitionCode to the end of the list.
    function Append : TFhirSubstanceDefinitionCode;
    
    // Add an already existing FhirSubstanceDefinitionCode to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionCode) : TFhirSubstanceDefinitionCode; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionCode) : Integer;
    
    // Insert FhirSubstanceDefinitionCode before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionCode;
    
    // Insert an existing FhirSubstanceDefinitionCode before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionCode);
    
    // Get the iIndexth FhirSubstanceDefinitionCode. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionCode);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionCode;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionCodes[index : Integer] : TFhirSubstanceDefinitionCode read GetItemN write SetItemN; default;
  End;

  // Names applicable to this substance.
  TFhirSubstanceDefinitionName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    FlanguageList : TFhirCodeableConceptList;
    FdomainList : TFhirCodeableConceptList;
    FjurisdictionList : TFhirCodeableConceptList;
    FsynonymList : TFhirSubstanceDefinitionNameList;
    FtranslationList : TFhirSubstanceDefinitionNameList;
    FofficialList : TFhirSubstanceDefinitionNameOfficialList;
    FsourceList : TFhirReferenceList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
    function GetLanguageList : TFhirCodeableConceptList;
    function GetHasLanguageList : Boolean;
    function GetDomainList : TFhirCodeableConceptList;
    function GetHasDomainList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    function GetSynonymList : TFhirSubstanceDefinitionNameList;
    function GetHasSynonymList : Boolean;
    function GetTranslationList : TFhirSubstanceDefinitionNameList;
    function GetHasTranslationList : Boolean;
    function GetOfficialList : TFhirSubstanceDefinitionNameOfficialList;
    function GetHasOfficialList : Boolean;
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionName; overload;
    function Clone : TFhirSubstanceDefinitionName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual name.
    property name : String read GetNameST write SetNameST;
    // The actual name.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Name type, for example 'systematic',  'scientific, 'brand'. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Name type, for example 'systematic',  'scientific, 'brand'.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The status of the name, for example 'current', 'proposed'. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of the name, for example 'current', 'proposed'.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to If this is the preferred name for this substance.
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // If this is the preferred name for this substance.
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

    // Human language that the name is written in.
    property languageList : TFhirCodeableConceptList read GetLanguageList;
    property hasLanguageList : boolean read GetHasLanguageList;

    // The use context of this name for example if there is a different name a drug active ingredient as opposed to a food colour additive.
    property domainList : TFhirCodeableConceptList read GetDomainList;
    property hasDomainList : boolean read GetHasDomainList;

    // The jurisdiction where this name applies.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // A synonym of this particular name, by which the substance is also known.
    property synonymList : TFhirSubstanceDefinitionNameList read GetSynonymList;
    property hasSynonymList : boolean read GetHasSynonymList;

    // A translation for this name into another human language.
    property translationList : TFhirSubstanceDefinitionNameList read GetTranslationList;
    property hasTranslationList : boolean read GetHasTranslationList;

    // Details of the official nature of this name.
    property officialList : TFhirSubstanceDefinitionNameOfficialList read GetOfficialList;
    property hasOfficialList : boolean read GetHasOfficialList;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionNameList;
    function GetCurrent : TFhirSubstanceDefinitionName;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionName read GetCurrent;
  end;

  TFhirSubstanceDefinitionNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionName;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionNameList; overload;
    function Clone : TFhirSubstanceDefinitionNameList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionNameListEnumerator;
    
    //  Add a FhirSubstanceDefinitionName to the end of the list.
    function Append : TFhirSubstanceDefinitionName;
    
    // Add an already existing FhirSubstanceDefinitionName to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionName) : TFhirSubstanceDefinitionName; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionName) : Integer;
    
    // Insert FhirSubstanceDefinitionName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionName;
    
    // Insert an existing FhirSubstanceDefinitionName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionName);
    
    // Get the iIndexth FhirSubstanceDefinitionName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionNames[index : Integer] : TFhirSubstanceDefinitionName read GetItemN write SetItemN; default;
  End;

  // Details of the official nature of this name.
  TFhirSubstanceDefinitionNameOfficial = class (TFhirBackboneElement)
  protected
    FAuthority : TFhirCodeableConcept;
    FStatus : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    procedure SetAuthority(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionNameOfficial; overload;
    function Clone : TFhirSubstanceDefinitionNameOfficial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Which authority uses this official name. (defined for API consistency)
    property authority : TFhirCodeableConcept read FAuthority write SetAuthority;
    // Which authority uses this official name.
    property authorityElement : TFhirCodeableConcept read FAuthority write SetAuthority;

    // Typed access to The status of the official name, for example 'provisional', 'approved'. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // The status of the official name, for example 'provisional', 'approved'.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Date of official name change.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of official name change.
    property dateElement : TFhirDateTime read FDate write SetDate;

  end;

  TFhirSubstanceDefinitionNameOfficialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionNameOfficialList;
    function GetCurrent : TFhirSubstanceDefinitionNameOfficial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionNameOfficialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionNameOfficial read GetCurrent;
  end;

  TFhirSubstanceDefinitionNameOfficialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionNameOfficial;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionNameOfficial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionNameOfficialList; overload;
    function Clone : TFhirSubstanceDefinitionNameOfficialList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionNameOfficialListEnumerator;
    
    //  Add a FhirSubstanceDefinitionNameOfficial to the end of the list.
    function Append : TFhirSubstanceDefinitionNameOfficial;
    
    // Add an already existing FhirSubstanceDefinitionNameOfficial to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionNameOfficial) : TFhirSubstanceDefinitionNameOfficial; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionNameOfficial) : Integer;
    
    // Insert FhirSubstanceDefinitionNameOfficial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionNameOfficial;
    
    // Insert an existing FhirSubstanceDefinitionNameOfficial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionNameOfficial);
    
    // Get the iIndexth FhirSubstanceDefinitionNameOfficial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionNameOfficial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionNameOfficial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionNameOfficials[index : Integer] : TFhirSubstanceDefinitionNameOfficial read GetItemN write SetItemN; default;
  End;

  // A link between this substance and another, with details of the relationship.
  TFhirSubstanceDefinitionRelationship = class (TFhirBackboneElement)
  protected
    FSubstanceDefinition : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    FIsDefining : TFhirBoolean;
    FAmount : TFhirDataType;
    FAmountRatioHighLimit : TFhirRatio;
    FAmountType : TFhirCodeableConcept;
    FsourceList : TFhirReferenceList;
    procedure SetSubstanceDefinition(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetIsDefining(value : TFhirBoolean);
    function GetIsDefiningST : Boolean;
    procedure SetIsDefiningST(value : Boolean);
    procedure SetAmount(value : TFhirDataType);
    procedure SetAmountRatioHighLimit(value : TFhirRatio);
    procedure SetAmountType(value : TFhirCodeableConcept);
    function GetSourceList : TFhirReferenceList;
    function GetHasSourceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionRelationship; overload;
    function Clone : TFhirSubstanceDefinitionRelationship; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A pointer to another substance, as a resource or just a representational code. (defined for API consistency)
    property substanceDefinition : TFhirDataType read FSubstanceDefinition write SetSubstanceDefinition;
    // A pointer to another substance, as a resource or just a representational code.
    property substanceDefinitionElement : TFhirDataType read FSubstanceDefinition write SetSubstanceDefinition;

    // Typed access to For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of". (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // For example "salt to parent", "active moiety", "starting material", "polymorph", "impurity of".
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
    property isDefining : Boolean read GetIsDefiningST write SetIsDefiningST;
    // For example where an enzyme strongly bonds with a particular substance, this is a defining relationship for that enzyme, out of several possible substance relationships.
    property isDefiningElement : TFhirBoolean read FIsDefining write SetIsDefining;

    // Typed access to A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other. (defined for API consistency)
    property amount : TFhirDataType read FAmount write SetAmount;
    // A numeric factor for the relationship, for instance to express that the salt of a substance has some percentage of the active substance in relation to some other.
    property amountElement : TFhirDataType read FAmount write SetAmount;

    // Typed access to For use when the numeric has an uncertain range. (defined for API consistency)
    property amountRatioHighLimit : TFhirRatio read FAmountRatioHighLimit write SetAmountRatioHighLimit;
    // For use when the numeric has an uncertain range.
    property amountRatioHighLimitElement : TFhirRatio read FAmountRatioHighLimit write SetAmountRatioHighLimit;

    // Typed access to An operator for the amount, for example "average", "approximately", "less than". (defined for API consistency)
    property amountType : TFhirCodeableConcept read FAmountType write SetAmountType;
    // An operator for the amount, for example "average", "approximately", "less than".
    property amountTypeElement : TFhirCodeableConcept read FAmountType write SetAmountType;

    // Supporting literature.
    property sourceList : TFhirReferenceList read GetSourceList;
    property hasSourceList : boolean read GetHasSourceList;

  end;

  TFhirSubstanceDefinitionRelationshipListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionRelationshipList;
    function GetCurrent : TFhirSubstanceDefinitionRelationship;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionRelationshipList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionRelationship read GetCurrent;
  end;

  TFhirSubstanceDefinitionRelationshipList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionRelationship;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionRelationship);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionRelationshipList; overload;
    function Clone : TFhirSubstanceDefinitionRelationshipList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionRelationshipListEnumerator;
    
    //  Add a FhirSubstanceDefinitionRelationship to the end of the list.
    function Append : TFhirSubstanceDefinitionRelationship;
    
    // Add an already existing FhirSubstanceDefinitionRelationship to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionRelationship) : TFhirSubstanceDefinitionRelationship; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionRelationship) : Integer;
    
    // Insert FhirSubstanceDefinitionRelationship before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionRelationship;
    
    // Insert an existing FhirSubstanceDefinitionRelationship before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionRelationship);
    
    // Get the iIndexth FhirSubstanceDefinitionRelationship. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionRelationship);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionRelationship;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionRelationships[index : Integer] : TFhirSubstanceDefinitionRelationship read GetItemN write SetItemN; default;
  End;

  // Material or taxonomic/anatomical source for the substance.
  TFhirSubstanceDefinitionSourceMaterial = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FGenus : TFhirCodeableConcept;
    FSpecies : TFhirCodeableConcept;
    FPart : TFhirCodeableConcept;
    FcountryOfOriginList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetGenus(value : TFhirCodeableConcept);
    procedure SetSpecies(value : TFhirCodeableConcept);
    procedure SetPart(value : TFhirCodeableConcept);
    function GetCountryOfOriginList : TFhirCodeableConceptList;
    function GetHasCountryOfOriginList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinitionSourceMaterial; overload;
    function Clone : TFhirSubstanceDefinitionSourceMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A classification that provides the origin of the raw material. Example: cat hair would be an Animal source type.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name. (defined for API consistency)
    property genus : TFhirCodeableConcept read FGenus write SetGenus;
    // The genus of an organism, typically referring to the Latin epithet of the genus element of the plant/animal scientific name.
    property genusElement : TFhirCodeableConcept read FGenus write SetGenus;

    // Typed access to The species of an organism, typically referring to the Latin epithet of the species of the plant/animal. (defined for API consistency)
    property species : TFhirCodeableConcept read FSpecies write SetSpecies;
    // The species of an organism, typically referring to the Latin epithet of the species of the plant/animal.
    property speciesElement : TFhirCodeableConcept read FSpecies write SetSpecies;

    // Typed access to An anatomical origin of the source material within an organism. (defined for API consistency)
    property part : TFhirCodeableConcept read FPart write SetPart;
    // An anatomical origin of the source material within an organism.
    property partElement : TFhirCodeableConcept read FPart write SetPart;

    // The country or countries where the material is harvested.
    property countryOfOriginList : TFhirCodeableConceptList read GetCountryOfOriginList;
    property hasCountryOfOriginList : boolean read GetHasCountryOfOriginList;

  end;

  TFhirSubstanceDefinitionSourceMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionSourceMaterialList;
    function GetCurrent : TFhirSubstanceDefinitionSourceMaterial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionSourceMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinitionSourceMaterial read GetCurrent;
  end;

  TFhirSubstanceDefinitionSourceMaterialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinitionSourceMaterial;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinitionSourceMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionSourceMaterialList; overload;
    function Clone : TFhirSubstanceDefinitionSourceMaterialList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionSourceMaterialListEnumerator;
    
    //  Add a FhirSubstanceDefinitionSourceMaterial to the end of the list.
    function Append : TFhirSubstanceDefinitionSourceMaterial;
    
    // Add an already existing FhirSubstanceDefinitionSourceMaterial to the end of the list.
    function AddItem(value : TFhirSubstanceDefinitionSourceMaterial) : TFhirSubstanceDefinitionSourceMaterial; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinitionSourceMaterial) : Integer;
    
    // Insert FhirSubstanceDefinitionSourceMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinitionSourceMaterial;
    
    // Insert an existing FhirSubstanceDefinitionSourceMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinitionSourceMaterial);
    
    // Get the iIndexth FhirSubstanceDefinitionSourceMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinitionSourceMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinitionSourceMaterial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitionSourceMaterials[index : Integer] : TFhirSubstanceDefinitionSourceMaterial read GetItemN write SetItemN; default;
  End;

  // The detailed description of a substance, typically at a level beyond what is used for prescribing.
  TFhirSubstanceDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FStatus : TFhirCodeableConcept;
    FclassificationList : TFhirCodeableConceptList;
    FDomain : TFhirCodeableConcept;
    FgradeList : TFhirCodeableConceptList;
    FDescription : TFhirMarkdown;
    FinformationSourceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FmanufacturerList : TFhirReferenceList;
    FsupplierList : TFhirReferenceList;
    FmoietyList : TFhirSubstanceDefinitionMoietyList;
    Fproperty_List : TFhirSubstanceDefinitionPropertyList;
    FmolecularWeightList : TFhirSubstanceDefinitionMolecularWeightList;
    FStructure : TFhirSubstanceDefinitionStructure;
    FcodeList : TFhirSubstanceDefinitionCodeList;
    FnameList : TFhirSubstanceDefinitionNameList;
    FrelationshipList : TFhirSubstanceDefinitionRelationshipList;
    FSourceMaterial : TFhirSubstanceDefinitionSourceMaterial;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetStatus(value : TFhirCodeableConcept);
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
    procedure SetDomain(value : TFhirCodeableConcept);
    function GetGradeList : TFhirCodeableConceptList;
    function GetHasGradeList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetInformationSourceList : TFhirReferenceList;
    function GetHasInformationSourceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetManufacturerList : TFhirReferenceList;
    function GetHasManufacturerList : Boolean;
    function GetSupplierList : TFhirReferenceList;
    function GetHasSupplierList : Boolean;
    function GetMoietyList : TFhirSubstanceDefinitionMoietyList;
    function GetHasMoietyList : Boolean;
    function GetProperty_List : TFhirSubstanceDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    function GetMolecularWeightList : TFhirSubstanceDefinitionMolecularWeightList;
    function GetHasMolecularWeightList : Boolean;
    procedure SetStructure(value : TFhirSubstanceDefinitionStructure);
    function GetCodeList : TFhirSubstanceDefinitionCodeList;
    function GetHasCodeList : Boolean;
    function GetNameList : TFhirSubstanceDefinitionNameList;
    function GetHasNameList : Boolean;
    function GetRelationshipList : TFhirSubstanceDefinitionRelationshipList;
    function GetHasRelationshipList : Boolean;
    procedure SetSourceMaterial(value : TFhirSubstanceDefinitionSourceMaterial);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubstanceDefinition; overload;
    function Clone : TFhirSubstanceDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier by which this substance is known.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A business level identifier of the substance.
    property version : String read GetVersionST write SetVersionST;
    // A business level identifier of the substance.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to Status of substance within the catalogue e.g. approved. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Status of substance within the catalogue e.g. approved.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // A high level categorization, e.g. polymer or nucleic acid, or food, chemical, biological, or a lower level such as the general types of polymer (linear or branch chain) or type of impurity (process related or contaminant).
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Typed access to If the substance applies to only human or veterinary use. (defined for API consistency)
    property domain : TFhirCodeableConcept read FDomain write SetDomain;
    // If the substance applies to only human or veterinary use.
    property domainElement : TFhirCodeableConcept read FDomain write SetDomain;

    // The quality standard, established benchmark, to which substance complies (e.g. USP/NF, Ph. Eur, JP, BP, Company Standard).
    property gradeList : TFhirCodeableConceptList read GetGradeList;
    property hasGradeList : boolean read GetHasGradeList;

    // Typed access to Textual description of the substance.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of the substance.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Supporting literature.
    property informationSourceList : TFhirReferenceList read GetInformationSourceList;
    property hasInformationSourceList : boolean read GetHasInformationSourceList;

    // Textual comment about the substance's catalogue or registry record.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // A company that makes this substance.
    property manufacturerList : TFhirReferenceList read GetManufacturerList;
    property hasManufacturerList : boolean read GetHasManufacturerList;

    // A company that supplies this substance.
    property supplierList : TFhirReferenceList read GetSupplierList;
    property hasSupplierList : boolean read GetHasSupplierList;

    // Moiety, for structural modifications.
    property moietyList : TFhirSubstanceDefinitionMoietyList read GetMoietyList;
    property hasMoietyList : boolean read GetHasMoietyList;

    // General specifications for this substance.
    property property_List : TFhirSubstanceDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // The molecular weight or weight range (for proteins, polymers or nucleic acids).
    property molecularWeightList : TFhirSubstanceDefinitionMolecularWeightList read GetMolecularWeightList;
    property hasMolecularWeightList : boolean read GetHasMolecularWeightList;

    // Typed access to Structural information. (defined for API consistency)
    property structure : TFhirSubstanceDefinitionStructure read FStructure write SetStructure;
    // Structural information.
    property structureElement : TFhirSubstanceDefinitionStructure read FStructure write SetStructure;

    // Codes associated with the substance.
    property codeList : TFhirSubstanceDefinitionCodeList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Names applicable to this substance.
    property nameList : TFhirSubstanceDefinitionNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A link between this substance and another, with details of the relationship.
    property relationshipList : TFhirSubstanceDefinitionRelationshipList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // Typed access to Material or taxonomic/anatomical source for the substance. (defined for API consistency)
    property sourceMaterial : TFhirSubstanceDefinitionSourceMaterial read FSourceMaterial write SetSourceMaterial;
    // Material or taxonomic/anatomical source for the substance.
    property sourceMaterialElement : TFhirSubstanceDefinitionSourceMaterial read FSourceMaterial write SetSourceMaterial;

  end;

  TFhirSubstanceDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubstanceDefinitionList;
    function GetCurrent : TFhirSubstanceDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubstanceDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubstanceDefinition read GetCurrent;
  end;

  TFhirSubstanceDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubstanceDefinition;
    procedure SetItemN(index : Integer; value : TFhirSubstanceDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubstanceDefinitionList; overload;
    function Clone : TFhirSubstanceDefinitionList; overload;
    function GetEnumerator : TFhirSubstanceDefinitionListEnumerator;
    
    //  Add a FhirSubstanceDefinition to the end of the list.
    function Append : TFhirSubstanceDefinition;
    
    // Add an already existing FhirSubstanceDefinition to the end of the list.
    function AddItem(value : TFhirSubstanceDefinition) : TFhirSubstanceDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubstanceDefinition) : Integer;
    
    // Insert FhirSubstanceDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubstanceDefinition;
    
    // Insert an existing FhirSubstanceDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubstanceDefinition);
    
    // Get the iIndexth FhirSubstanceDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubstanceDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubstanceDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubstanceDefinitions[index : Integer] : TFhirSubstanceDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSTANCEDEFINITION}



implementation

uses
  fhir4b_utilities;



{$IFDEF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{ TFhirAdministrableProductDefinitionProperty }

constructor TFhirAdministrableProductDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  FStatus.free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAdministrableProductDefinitionProperty(oSource).type_.Clone;
  value := TFhirAdministrableProductDefinitionProperty(oSource).value.Clone;
  status := TFhirAdministrableProductDefinitionProperty(oSource).status.Clone;
end;

procedure TFhirAdministrableProductDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
end;

procedure TFhirAdministrableProductDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
end;

function TFhirAdministrableProductDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdministrableProductDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else if (propName = 'status') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else if (propName = 'status') then StatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionProperty.fhirType : string;
begin
  result := 'AdministrableProductDefinition.property';
end;

function TFhirAdministrableProductDefinitionProperty.Link : TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(inherited Link);
end;

function TFhirAdministrableProductDefinitionProperty.Clone : TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(inherited Clone);
end;

function TFhirAdministrableProductDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(statusElement, o.statusElement, true);
  end;
end;

function TFhirAdministrableProductDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue) and isEmptyProp(FStatus);
end;

procedure TFhirAdministrableProductDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
  fields.add('status');
end;

function TFhirAdministrableProductDefinitionProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAdministrableProductDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirAdministrableProductDefinitionProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirAdministrableProductDefinitionProperty.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

{ TFhirAdministrableProductDefinitionPropertyListEnumerator }

constructor TFhirAdministrableProductDefinitionPropertyListEnumerator.Create(list : TFhirAdministrableProductDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionPropertyListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionPropertyList }

function TFhirAdministrableProductDefinitionPropertyList.AddItem(value: TFhirAdministrableProductDefinitionProperty): TFhirAdministrableProductDefinitionProperty;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionProperty');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionPropertyList.Append: TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionPropertyList.GetEnumerator : TFhirAdministrableProductDefinitionPropertyListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionPropertyList.Clone: TFhirAdministrableProductDefinitionPropertyList;
begin
  result := TFhirAdministrableProductDefinitionPropertyList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionPropertyList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionProperty;
end;
function TFhirAdministrableProductDefinitionPropertyList.IndexOf(value: TFhirAdministrableProductDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionPropertyList.Insert(index: Integer): TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionPropertyList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value is TFhirAdministrableProductDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionPropertyList.Item(index: Integer): TFhirAdministrableProductDefinitionProperty;
begin
  result := TFhirAdministrableProductDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionPropertyList.Link: TFhirAdministrableProductDefinitionPropertyList;
begin
  result := TFhirAdministrableProductDefinitionPropertyList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value is TFhirAdministrableProductDefinitionProperty);
  FhirAdministrableProductDefinitionProperties[index] := value;
end;

procedure TFhirAdministrableProductDefinitionPropertyList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionProperty);
begin
  assert(value is TFhirAdministrableProductDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministration }

constructor TFhirAdministrableProductDefinitionRouteOfAdministration.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministration.Destroy;
begin
  FCode.free;
  FFirstDose.free;
  FMaxSingleDose.free;
  FMaxDosePerDay.free;
  FMaxDosePerTreatmentPeriod.free;
  FMaxTreatmentPeriod.free;
  FTargetSpeciesList.Free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).code.Clone;
  firstDose := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).firstDose.Clone;
  maxSingleDose := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxSingleDose.Clone;
  maxDosePerDay := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxDosePerDay.Clone;
  maxDosePerTreatmentPeriod := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxDosePerTreatmentPeriod.Clone;
  maxTreatmentPeriod := TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).maxTreatmentPeriod.Clone;
  if (TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).FTargetSpeciesList = nil) then
  begin
    FTargetSpeciesList.free;
    FTargetSpeciesList := nil;
  end
  else
  begin
    if FTargetSpeciesList = nil then
      FTargetSpeciesList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Create;
    FTargetSpeciesList.Assign(TFhirAdministrableProductDefinitionRouteOfAdministration(oSource).FTargetSpeciesList);
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'firstDose') Then
     list.add(self.link, 'firstDose', FFirstDose.Link);
  if (child_name = 'maxSingleDose') Then
     list.add(self.link, 'maxSingleDose', FMaxSingleDose.Link);
  if (child_name = 'maxDosePerDay') Then
     list.add(self.link, 'maxDosePerDay', FMaxDosePerDay.Link);
  if (child_name = 'maxDosePerTreatmentPeriod') Then
     list.add(self.link, 'maxDosePerTreatmentPeriod', FMaxDosePerTreatmentPeriod.Link);
  if (child_name = 'maxTreatmentPeriod') Then
     list.add(self.link, 'maxTreatmentPeriod', FMaxTreatmentPeriod.Link);
  if (child_name = 'targetSpecies') Then
    list.addAll(self, 'targetSpecies', FTargetSpeciesList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'firstDose', 'Quantity', false, TFhirQuantity, FFirstDose.Link));
  oList.add(TFHIRProperty.create(self, 'maxSingleDose', 'Quantity', false, TFhirQuantity, FMaxSingleDose.Link));
  oList.add(TFHIRProperty.create(self, 'maxDosePerDay', 'Quantity', false, TFhirQuantity, FMaxDosePerDay.Link));
  oList.add(TFHIRProperty.create(self, 'maxDosePerTreatmentPeriod', 'Ratio', false, TFhirRatio, FMaxDosePerTreatmentPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'maxTreatmentPeriod', 'Duration', false, TFhirDuration, FMaxTreatmentPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'targetSpecies', 'BackboneElement', true, TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies, FTargetSpeciesList.Link));
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'firstDose') then
  begin
    FirstDose := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'maxSingleDose') then
  begin
    MaxSingleDose := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'maxDosePerDay') then
  begin
    MaxDosePerDay := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'maxDosePerTreatmentPeriod') then
  begin
    MaxDosePerTreatmentPeriod := propValue as TFhirRatio;
    result := propValue;
  end
  else if (propName = 'maxTreatmentPeriod') then
  begin
    MaxTreatmentPeriod := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'targetSpecies') then
  begin
    TargetSpeciesList.add(propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetSpecies') then TargetSpeciesList.insertItem(index, propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies)
  else inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'firstDose') then result := TFhirQuantity.create()
  else if (propName = 'maxSingleDose') then result := TFhirQuantity.create()
  else if (propName = 'maxDosePerDay') then result := TFhirQuantity.create()
  else if (propName = 'maxDosePerTreatmentPeriod') then result := TFhirRatio.create()
  else if (propName = 'maxTreatmentPeriod') then result := TFhirDuration.create()
  else if (propName = 'targetSpecies') then result := TargetSpeciesList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'firstDose') then result := 'Quantity'
  else if (propName = 'maxSingleDose') then result := 'Quantity'
  else if (propName = 'maxDosePerDay') then result := 'Quantity'
  else if (propName = 'maxDosePerTreatmentPeriod') then result := 'Ratio'
  else if (propName = 'maxTreatmentPeriod') then result := 'Duration'
  else if (propName = 'targetSpecies') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'firstDose') then FirstDoseElement := nil
  else if (propName = 'maxSingleDose') then MaxSingleDoseElement := nil
  else if (propName = 'maxDosePerDay') then MaxDosePerDayElement := nil
  else if (propName = 'maxDosePerTreatmentPeriod') then MaxDosePerTreatmentPeriodElement := nil
  else if (propName = 'maxTreatmentPeriod') then MaxTreatmentPeriodElement := nil
  else if (propName = 'targetSpecies') then deletePropertyValue('targetSpecies', TargetSpeciesList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'firstDose') then FirstDoseElement := new as TFhirQuantity
  else if (propName = 'maxSingleDose') then MaxSingleDoseElement := new as TFhirQuantity
  else if (propName = 'maxDosePerDay') then MaxDosePerDayElement := new as TFhirQuantity
  else if (propName = 'maxDosePerTreatmentPeriod') then MaxDosePerTreatmentPeriodElement := new as TFhirRatio
  else if (propName = 'maxTreatmentPeriod') then MaxTreatmentPeriodElement := new as TFhirDuration
  else if (propName = 'targetSpecies') then replacePropertyValue('targetSpecies', TargetSpeciesList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetSpecies') then TargetSpeciesList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.fhirType : string;
begin
  result := 'AdministrableProductDefinition.routeOfAdministration';
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.Link : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(inherited Link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.Clone : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionRouteOfAdministration)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionRouteOfAdministration(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(firstDoseElement, o.firstDoseElement, true) and 
      compareDeep(maxSingleDoseElement, o.maxSingleDoseElement, true) and compareDeep(maxDosePerDayElement, o.maxDosePerDayElement, true) and 
      compareDeep(maxDosePerTreatmentPeriodElement, o.maxDosePerTreatmentPeriodElement, true) and 
      compareDeep(maxTreatmentPeriodElement, o.maxTreatmentPeriodElement, true) and 
      compareDeep(targetSpeciesList, o.targetSpeciesList, true);
  end;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FFirstDose) and isEmptyProp(FMaxSingleDose) and isEmptyProp(FMaxDosePerDay) and isEmptyProp(FMaxDosePerTreatmentPeriod) and isEmptyProp(FMaxTreatmentPeriod) and isEmptyProp(FtargetSpeciesList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('firstDose');
  fields.add('maxSingleDose');
  fields.add('maxDosePerDay');
  fields.add('maxDosePerTreatmentPeriod');
  fields.add('maxTreatmentPeriod');
  fields.add('targetSpecies');
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetSpeciesList.sizeInBytes(magic));
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetFirstDose(value : TFhirQuantity);
begin
  FFirstDose.free;
  FFirstDose := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxSingleDose(value : TFhirQuantity);
begin
  FMaxSingleDose.free;
  FMaxSingleDose := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxDosePerDay(value : TFhirQuantity);
begin
  FMaxDosePerDay.free;
  FMaxDosePerDay := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxDosePerTreatmentPeriod(value : TFhirRatio);
begin
  FMaxDosePerTreatmentPeriod.free;
  FMaxDosePerTreatmentPeriod := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministration.SetMaxTreatmentPeriod(value : TFhirDuration);
begin
  FMaxTreatmentPeriod.free;
  FMaxTreatmentPeriod := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.GetTargetSpeciesList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
begin
  if FTargetSpeciesList = nil then
    FTargetSpeciesList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Create;
  result := FTargetSpeciesList;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministration.GetHasTargetSpeciesList : boolean;
begin
  result := (FTargetSpeciesList <> nil) and (FTargetSpeciesList.count > 0);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationList }

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.AddItem(value: TFhirAdministrableProductDefinitionRouteOfAdministration): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionRouteOfAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionRouteOfAdministration');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Append: TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Clone: TFhirAdministrableProductDefinitionRouteOfAdministrationList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration;
end;
function TFhirAdministrableProductDefinitionRouteOfAdministrationList.IndexOf(value: TFhirAdministrableProductDefinitionRouteOfAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Insert(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministration);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Item(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministration;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministration(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationList.Link: TFhirAdministrableProductDefinitionRouteOfAdministrationList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministration);
  FhirAdministrableProductDefinitionRouteOfAdministrations[index] := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministration);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministration);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Destroy;
begin
  FCode.free;
  FWithdrawalPeriodList.Free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(oSource).code.Clone;
  if (TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(oSource).FWithdrawalPeriodList = nil) then
  begin
    FWithdrawalPeriodList.free;
    FWithdrawalPeriodList := nil;
  end
  else
  begin
    if FWithdrawalPeriodList = nil then
      FWithdrawalPeriodList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Create;
    FWithdrawalPeriodList.Assign(TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(oSource).FWithdrawalPeriodList);
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'withdrawalPeriod') Then
    list.addAll(self, 'withdrawalPeriod', FWithdrawalPeriodList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'withdrawalPeriod', 'BackboneElement', true, TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod, FWithdrawalPeriodList.Link));
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'withdrawalPeriod') then
  begin
    WithdrawalPeriodList.add(propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'withdrawalPeriod') then WithdrawalPeriodList.insertItem(index, propValue as TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod)
  else inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'withdrawalPeriod') then result := WithdrawalPeriodList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'withdrawalPeriod') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'withdrawalPeriod') then deletePropertyValue('withdrawalPeriod', WithdrawalPeriodList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'withdrawalPeriod') then replacePropertyValue('withdrawalPeriod', WithdrawalPeriodList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'withdrawalPeriod') then WithdrawalPeriodList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.fhirType : string;
begin
  result := 'AdministrableProductDefinition.routeOfAdministration.targetSpecies';
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(inherited Link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(withdrawalPeriodList, o.withdrawalPeriodList, true);
  end;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FwithdrawalPeriodList);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('withdrawalPeriod');
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FWithdrawalPeriodList.sizeInBytes(magic));
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.GetWithdrawalPeriodList : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  if FWithdrawalPeriodList = nil then
    FWithdrawalPeriodList := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Create;
  result := FWithdrawalPeriodList;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.GetHasWithdrawalPeriodList : boolean;
begin
  result := (FWithdrawalPeriodList <> nil) and (FWithdrawalPeriodList.count > 0);
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList }

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.AddItem(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Append: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Clone: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
end;
function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.IndexOf(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Insert(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Item(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Link: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies[index] := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpecies);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Destroy;
begin
  FTissue.free;
  FValue.free;
  FSupportingInformation.free;
  inherited;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Assign(oSource : TFslObject);
begin
  inherited;
  tissue := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).tissue.Clone;
  value := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).value.Clone;
  supportingInformationElement := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(oSource).supportingInformationElement.Clone;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'tissue') Then
     list.add(self.link, 'tissue', FTissue.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'supportingInformation') Then
     list.add(self.link, 'supportingInformation', FSupportingInformation.Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'tissue', 'CodeableConcept', false, TFhirCodeableConcept, FTissue.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'string', false, TFhirString, FSupportingInformation.Link));
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'tissue') then
  begin
    Tissue := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'tissue') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirQuantity.create()
  else if (propName = 'supportingInformation') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'tissue') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'Quantity'
  else if (propName = 'supportingInformation') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'tissue') then TissueElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'supportingInformation') then SupportingInformationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'tissue') then TissueElement := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := new as TFhirQuantity
  else if (propName = 'supportingInformation') then SupportingInformationElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.fhirType : string;
begin
  result := 'AdministrableProductDefinition.routeOfAdministration.targetSpecies.withdrawalPeriod';
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Link : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(inherited Link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.Clone : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(other);
    result := compareDeep(tissueElement, o.tissueElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(supportingInformationElement, o.supportingInformationElement, true);
  end;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTissue) and isEmptyProp(FValue) and isEmptyProp(FSupportingInformation);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('tissue');
  fields.add('value');
  fields.add('supportingInformation');
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetTissue(value : TFhirCodeableConcept);
begin
  FTissue.free;
  FTissue := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetSupportingInformation(value : TFhirString);
begin
  FSupportingInformation.free;
  FSupportingInformation := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.GetSupportingInformationST : String;
begin
  if FSupportingInformation = nil then
    result := ''
  else
    result := FSupportingInformation.value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.SetSupportingInformationST(value : String);
begin
  if value <> '' then
  begin
    if FSupportingInformation = nil then
      FSupportingInformation := TFhirString.create;
    FSupportingInformation.value := value
  end
  else if FSupportingInformation <> nil then
    FSupportingInformation.value := '';
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator }

constructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Create(list : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.GetCurrent : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList }

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.AddItem(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Append: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.GetEnumerator : TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Clone: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.GetItemN(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
end;
function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.IndexOf(value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Insert(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Item(index: Integer): TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Link: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList;
begin
  result := TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  FhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriods[index] := value;
end;

procedure TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriodList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
begin
  assert(value is TFhirAdministrableProductDefinitionRouteOfAdministrationTargetSpeciesWithdrawalPeriod);
  ObjectByIndex[index] := value;
end;

{ TFhirAdministrableProductDefinition }

constructor TFhirAdministrableProductDefinition.Create;
begin
  inherited;
end;

destructor TFhirAdministrableProductDefinition.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FFormOfList.Free;
  FAdministrableDoseForm.free;
  FUnitOfPresentation.free;
  FProducedFromList.Free;
  FIngredientList.Free;
  FDevice.free;
  FProperty_List.Free;
  FRouteOfAdministrationList.Free;
  inherited;
end;

procedure TFhirAdministrableProductDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAdministrableProductDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAdministrableProductDefinition(oSource).FIdentifierList);
  end;
  statusElement := TFhirAdministrableProductDefinition(oSource).statusElement.Clone;
  if (TFhirAdministrableProductDefinition(oSource).FFormOfList = nil) then
  begin
    FFormOfList.free;
    FFormOfList := nil;
  end
  else
  begin
    if FFormOfList = nil then
      FFormOfList := TFhirReferenceList.Create;
    FFormOfList.Assign(TFhirAdministrableProductDefinition(oSource).FFormOfList);
  end;
  administrableDoseForm := TFhirAdministrableProductDefinition(oSource).administrableDoseForm.Clone;
  unitOfPresentation := TFhirAdministrableProductDefinition(oSource).unitOfPresentation.Clone;
  if (TFhirAdministrableProductDefinition(oSource).FProducedFromList = nil) then
  begin
    FProducedFromList.free;
    FProducedFromList := nil;
  end
  else
  begin
    if FProducedFromList = nil then
      FProducedFromList := TFhirReferenceList.Create;
    FProducedFromList.Assign(TFhirAdministrableProductDefinition(oSource).FProducedFromList);
  end;
  if (TFhirAdministrableProductDefinition(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirCodeableConceptList.Create;
    FIngredientList.Assign(TFhirAdministrableProductDefinition(oSource).FIngredientList);
  end;
  device := TFhirAdministrableProductDefinition(oSource).device.Clone;
  if (TFhirAdministrableProductDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirAdministrableProductDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirAdministrableProductDefinition(oSource).FProperty_List);
  end;
  if (TFhirAdministrableProductDefinition(oSource).FRouteOfAdministrationList = nil) then
  begin
    FRouteOfAdministrationList.free;
    FRouteOfAdministrationList := nil;
  end
  else
  begin
    if FRouteOfAdministrationList = nil then
      FRouteOfAdministrationList := TFhirAdministrableProductDefinitionRouteOfAdministrationList.Create;
    FRouteOfAdministrationList.Assign(TFhirAdministrableProductDefinition(oSource).FRouteOfAdministrationList);
  end;
end;

function TFhirAdministrableProductDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtAdministrableProductDefinition;
end;

procedure TFhirAdministrableProductDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'formOf') Then
    list.addAll(self, 'formOf', FFormOfList);
  if (child_name = 'administrableDoseForm') Then
     list.add(self.link, 'administrableDoseForm', FAdministrableDoseForm.Link);
  if (child_name = 'unitOfPresentation') Then
     list.add(self.link, 'unitOfPresentation', FUnitOfPresentation.Link);
  if (child_name = 'producedFrom') Then
    list.addAll(self, 'producedFrom', FProducedFromList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'routeOfAdministration') Then
    list.addAll(self, 'routeOfAdministration', FRouteOfAdministrationList);
end;

procedure TFhirAdministrableProductDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'formOf', 'Reference', true, TFhirReference, FFormOfList.Link));
  oList.add(TFHIRProperty.create(self, 'administrableDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FAdministrableDoseForm.Link));
  oList.add(TFHIRProperty.create(self, 'unitOfPresentation', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfPresentation.Link));
  oList.add(TFHIRProperty.create(self, 'producedFrom', 'Reference', true, TFhirReference, FProducedFromList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'CodeableConcept', true, TFhirCodeableConcept, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirAdministrableProductDefinitionProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'routeOfAdministration', 'BackboneElement', true, TFhirAdministrableProductDefinitionRouteOfAdministration, FRouteOfAdministrationList.Link));
end;

function TFhirAdministrableProductDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'formOf') then
  begin
    FormOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'administrableDoseForm') then
  begin
    AdministrableDoseForm := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'unitOfPresentation') then
  begin
    UnitOfPresentation := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'producedFrom') then
  begin
    ProducedFromList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirAdministrableProductDefinitionProperty);
    result := propValue;
  end
  else if (propName = 'routeOfAdministration') then
  begin
    RouteOfAdministrationList.add(propValue as TFhirAdministrableProductDefinitionRouteOfAdministration);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdministrableProductDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'formOf') then FormOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'producedFrom') then ProducedFromList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirAdministrableProductDefinitionProperty)
  else if (propName = 'routeOfAdministration') then RouteOfAdministrationList.insertItem(index, propValue as TFhirAdministrableProductDefinitionRouteOfAdministration)
  else inherited;
end;

function TFhirAdministrableProductDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'formOf') then result := FormOfList.new()
  else if (propName = 'administrableDoseForm') then result := TFhirCodeableConcept.create()
  else if (propName = 'unitOfPresentation') then result := TFhirCodeableConcept.create()
  else if (propName = 'producedFrom') then result := ProducedFromList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'device') then result := TFhirReference.create()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'routeOfAdministration') then result := RouteOfAdministrationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdministrableProductDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'formOf') then result := 'Reference'
  else if (propName = 'administrableDoseForm') then result := 'CodeableConcept'
  else if (propName = 'unitOfPresentation') then result := 'CodeableConcept'
  else if (propName = 'producedFrom') then result := 'Reference'
  else if (propName = 'ingredient') then result := 'CodeableConcept'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'routeOfAdministration') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdministrableProductDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'formOf') then deletePropertyValue('formOf', FormOfList, value)
  else if (propName = 'administrableDoseForm') then AdministrableDoseFormElement := nil
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := nil
  else if (propName = 'producedFrom') then deletePropertyValue('producedFrom', ProducedFromList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'routeOfAdministration') then deletePropertyValue('routeOfAdministration', RouteOfAdministrationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdministrableProductDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'formOf') then replacePropertyValue('formOf', FormOfList, existing, new)
  else if (propName = 'administrableDoseForm') then AdministrableDoseFormElement := new as TFhirCodeableConcept
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := new as TFhirCodeableConcept
  else if (propName = 'producedFrom') then replacePropertyValue('producedFrom', ProducedFromList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'device') then DeviceElement := new as TFhirReference
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'routeOfAdministration') then replacePropertyValue('routeOfAdministration', RouteOfAdministrationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdministrableProductDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'formOf') then FormOfList.move(source, destination)
  else if (propName = 'producedFrom') then ProducedFromList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'routeOfAdministration') then RouteOfAdministrationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdministrableProductDefinition.fhirType : string;
begin
  result := 'AdministrableProductDefinition';
end;

function TFhirAdministrableProductDefinition.Link : TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(inherited Link);
end;

function TFhirAdministrableProductDefinition.Clone : TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(inherited Clone);
end;

function TFhirAdministrableProductDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirAdministrableProductDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdministrableProductDefinition)) then
    result := false
  else
  begin
    o := TFhirAdministrableProductDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(formOfList, o.formOfList, true) and compareDeep(administrableDoseFormElement, o.administrableDoseFormElement, true) and 
      compareDeep(unitOfPresentationElement, o.unitOfPresentationElement, true) and 
      compareDeep(producedFromList, o.producedFromList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(deviceElement, o.deviceElement, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(routeOfAdministrationList, o.routeOfAdministrationList, true);
  end;
end;

function TFhirAdministrableProductDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FformOfList) and isEmptyProp(FAdministrableDoseForm) and isEmptyProp(FUnitOfPresentation) and isEmptyProp(FproducedFromList) and isEmptyProp(FingredientList) and isEmptyProp(FDevice) and isEmptyProp(Fproperty_List) and isEmptyProp(FrouteOfAdministrationList);
end;

procedure TFhirAdministrableProductDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('formOf');
  fields.add('administrableDoseForm');
  fields.add('unitOfPresentation');
  fields.add('producedFrom');
  fields.add('ingredient');
  fields.add('device');
  fields.add('property');
  fields.add('routeOfAdministration');
end;

function TFhirAdministrableProductDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FFormOfList.sizeInBytes(magic));
  inc(result, FProducedFromList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FRouteOfAdministrationList.sizeInBytes(magic));
end;

function TFhirAdministrableProductDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAdministrableProductDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAdministrableProductDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirAdministrableProductDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirAdministrableProductDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirAdministrableProductDefinition.GetFormOfList : TFhirReferenceList;
begin
  if FFormOfList = nil then
    FFormOfList := TFhirReferenceList.Create;
  result := FFormOfList;
end;

function TFhirAdministrableProductDefinition.GetHasFormOfList : boolean;
begin
  result := (FFormOfList <> nil) and (FFormOfList.count > 0);
end;

procedure TFhirAdministrableProductDefinition.SetAdministrableDoseForm(value : TFhirCodeableConcept);
begin
  FAdministrableDoseForm.free;
  FAdministrableDoseForm := value;
end;

procedure TFhirAdministrableProductDefinition.SetUnitOfPresentation(value : TFhirCodeableConcept);
begin
  FUnitOfPresentation.free;
  FUnitOfPresentation := value;
end;

function TFhirAdministrableProductDefinition.GetProducedFromList : TFhirReferenceList;
begin
  if FProducedFromList = nil then
    FProducedFromList := TFhirReferenceList.Create;
  result := FProducedFromList;
end;

function TFhirAdministrableProductDefinition.GetHasProducedFromList : boolean;
begin
  result := (FProducedFromList <> nil) and (FProducedFromList.count > 0);
end;

function TFhirAdministrableProductDefinition.GetIngredientList : TFhirCodeableConceptList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirCodeableConceptList.Create;
  result := FIngredientList;
end;

function TFhirAdministrableProductDefinition.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

procedure TFhirAdministrableProductDefinition.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value;
end;

function TFhirAdministrableProductDefinition.GetProperty_List : TFhirAdministrableProductDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirAdministrableProductDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirAdministrableProductDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirAdministrableProductDefinition.GetRouteOfAdministrationList : TFhirAdministrableProductDefinitionRouteOfAdministrationList;
begin
  if FRouteOfAdministrationList = nil then
    FRouteOfAdministrationList := TFhirAdministrableProductDefinitionRouteOfAdministrationList.Create;
  result := FRouteOfAdministrationList;
end;

function TFhirAdministrableProductDefinition.GetHasRouteOfAdministrationList : boolean;
begin
  result := (FRouteOfAdministrationList <> nil) and (FRouteOfAdministrationList.count > 0);
end;

{ TFhirAdministrableProductDefinitionListEnumerator }

constructor TFhirAdministrableProductDefinitionListEnumerator.Create(list : TFhirAdministrableProductDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdministrableProductDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdministrableProductDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdministrableProductDefinitionListEnumerator.GetCurrent : TFhirAdministrableProductDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirAdministrableProductDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdministrableProductDefinitionList }

function TFhirAdministrableProductDefinitionList.AddItem(value: TFhirAdministrableProductDefinition): TFhirAdministrableProductDefinition;
begin
  assert(value.ClassName = 'TFhirAdministrableProductDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdministrableProductDefinition');
  add(value);
  result := value;
end;

function TFhirAdministrableProductDefinitionList.Append: TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirAdministrableProductDefinitionList.GetEnumerator : TFhirAdministrableProductDefinitionListEnumerator;
begin
  result := TFhirAdministrableProductDefinitionListEnumerator.Create(self.link);
end;

function TFhirAdministrableProductDefinitionList.Clone: TFhirAdministrableProductDefinitionList;
begin
  result := TFhirAdministrableProductDefinitionList(inherited Clone);
end;

function TFhirAdministrableProductDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdministrableProductDefinitionList.GetItemN(index: Integer): TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdministrableProductDefinition;
end;
function TFhirAdministrableProductDefinitionList.IndexOf(value: TFhirAdministrableProductDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdministrableProductDefinitionList.Insert(index: Integer): TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdministrableProductDefinitionList.InsertItem(index: Integer; value: TFhirAdministrableProductDefinition);
begin
  assert(value is TFhirAdministrableProductDefinition);
  Inherited Insert(index, value);
end;

function TFhirAdministrableProductDefinitionList.Item(index: Integer): TFhirAdministrableProductDefinition;
begin
  result := TFhirAdministrableProductDefinition(ObjectByIndex[index]);
end;

function TFhirAdministrableProductDefinitionList.Link: TFhirAdministrableProductDefinitionList;
begin
  result := TFhirAdministrableProductDefinitionList(inherited Link);
end;

procedure TFhirAdministrableProductDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdministrableProductDefinitionList.SetItemByIndex(index: Integer; value: TFhirAdministrableProductDefinition);
begin
  assert(value is TFhirAdministrableProductDefinition);
  FhirAdministrableProductDefinitions[index] := value;
end;

procedure TFhirAdministrableProductDefinitionList.SetItemN(index: Integer; value: TFhirAdministrableProductDefinition);
begin
  assert(value is TFhirAdministrableProductDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ADMINISTRABLEPRODUCTDEFINITION}
{$IFDEF FHIR_INGREDIENT}
{ TFhirIngredientManufacturer }

constructor TFhirIngredientManufacturer.Create;
begin
  inherited;
end;

destructor TFhirIngredientManufacturer.Destroy;
begin
  FRole.free;
  FManufacturer.free;
  inherited;
end;

procedure TFhirIngredientManufacturer.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirIngredientManufacturer(oSource).role.Clone;
  manufacturer := TFhirIngredientManufacturer(oSource).manufacturer.Clone;
end;

procedure TFhirIngredientManufacturer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
end;

procedure TFhirIngredientManufacturer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'Coding', false, TFhirCoding, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', false, TFhirReference, FManufacturer.Link));
end;

function TFhirIngredientManufacturer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientManufacturer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirIngredientManufacturer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCoding.create()
  else if (propName = 'manufacturer') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientManufacturer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'Coding'
  else if (propName = 'manufacturer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientManufacturer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientManufacturer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCoding
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientManufacturer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientManufacturer.fhirType : string;
begin
  result := 'Ingredient.manufacturer';
end;

function TFhirIngredientManufacturer.Link : TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer(inherited Link);
end;

function TFhirIngredientManufacturer.Clone : TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer(inherited Clone);
end;

function TFhirIngredientManufacturer.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientManufacturer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientManufacturer)) then
    result := false
  else
  begin
    o := TFhirIngredientManufacturer(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(manufacturerElement, o.manufacturerElement, true);
  end;
end;

function TFhirIngredientManufacturer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FManufacturer);
end;

procedure TFhirIngredientManufacturer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('manufacturer');
end;

function TFhirIngredientManufacturer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirIngredientManufacturer.SetRole(value : TFhirCoding);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirIngredientManufacturer.SetManufacturer(value : TFhirReference);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

{ TFhirIngredientManufacturerListEnumerator }

constructor TFhirIngredientManufacturerListEnumerator.Create(list : TFhirIngredientManufacturerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientManufacturerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientManufacturerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientManufacturerListEnumerator.GetCurrent : TFhirIngredientManufacturer;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientManufacturerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientManufacturerList }

function TFhirIngredientManufacturerList.AddItem(value: TFhirIngredientManufacturer): TFhirIngredientManufacturer;
begin
  assert(value.ClassName = 'TFhirIngredientManufacturer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientManufacturer');
  add(value);
  result := value;
end;

function TFhirIngredientManufacturerList.Append: TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientManufacturerList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientManufacturerList.GetEnumerator : TFhirIngredientManufacturerListEnumerator;
begin
  result := TFhirIngredientManufacturerListEnumerator.Create(self.link);
end;

function TFhirIngredientManufacturerList.Clone: TFhirIngredientManufacturerList;
begin
  result := TFhirIngredientManufacturerList(inherited Clone);
end;

function TFhirIngredientManufacturerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientManufacturerList.GetItemN(index: Integer): TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer(ObjectByIndex[index]);
end;

function TFhirIngredientManufacturerList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientManufacturer;
end;
function TFhirIngredientManufacturerList.IndexOf(value: TFhirIngredientManufacturer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientManufacturerList.Insert(index: Integer): TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientManufacturerList.InsertItem(index: Integer; value: TFhirIngredientManufacturer);
begin
  assert(value is TFhirIngredientManufacturer);
  Inherited Insert(index, value);
end;

function TFhirIngredientManufacturerList.Item(index: Integer): TFhirIngredientManufacturer;
begin
  result := TFhirIngredientManufacturer(ObjectByIndex[index]);
end;

function TFhirIngredientManufacturerList.Link: TFhirIngredientManufacturerList;
begin
  result := TFhirIngredientManufacturerList(inherited Link);
end;

procedure TFhirIngredientManufacturerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientManufacturerList.SetItemByIndex(index: Integer; value: TFhirIngredientManufacturer);
begin
  assert(value is TFhirIngredientManufacturer);
  FhirIngredientManufacturers[index] := value;
end;

procedure TFhirIngredientManufacturerList.SetItemN(index: Integer; value: TFhirIngredientManufacturer);
begin
  assert(value is TFhirIngredientManufacturer);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredientSubstance }

constructor TFhirIngredientSubstance.Create;
begin
  inherited;
end;

destructor TFhirIngredientSubstance.Destroy;
begin
  FCode.free;
  FStrengthList.Free;
  inherited;
end;

procedure TFhirIngredientSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirIngredientSubstance(oSource).code.Clone;
  if (TFhirIngredientSubstance(oSource).FStrengthList = nil) then
  begin
    FStrengthList.free;
    FStrengthList := nil;
  end
  else
  begin
    if FStrengthList = nil then
      FStrengthList := TFhirIngredientSubstanceStrengthList.Create;
    FStrengthList.Assign(TFhirIngredientSubstance(oSource).FStrengthList);
  end;
end;

procedure TFhirIngredientSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'strength') Then
    list.addAll(self, 'strength', FStrengthList);
end;

procedure TFhirIngredientSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableReference', false, TFhirCodeableReference, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'strength', 'BackboneElement', true, TFhirIngredientSubstanceStrength, FStrengthList.Link));
end;

function TFhirIngredientSubstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    StrengthList.add(propValue as TFhirIngredientSubstanceStrength);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'strength') then StrengthList.insertItem(index, propValue as TFhirIngredientSubstanceStrength)
  else inherited;
end;

function TFhirIngredientSubstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableReference.create()
  else if (propName = 'strength') then result := StrengthList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableReference'
  else if (propName = 'strength') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSubstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'strength') then deletePropertyValue('strength', StrengthList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableReference
  else if (propName = 'strength') then replacePropertyValue('strength', StrengthList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'strength') then StrengthList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSubstance.fhirType : string;
begin
  result := 'Ingredient.substance';
end;

function TFhirIngredientSubstance.Link : TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(inherited Link);
end;

function TFhirIngredientSubstance.Clone : TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(inherited Clone);
end;

function TFhirIngredientSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSubstance)) then
    result := false
  else
  begin
    o := TFhirIngredientSubstance(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(strengthList, o.strengthList, true);
  end;
end;

function TFhirIngredientSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FstrengthList);
end;

procedure TFhirIngredientSubstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('strength');
end;

function TFhirIngredientSubstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FStrengthList.sizeInBytes(magic));
end;

procedure TFhirIngredientSubstance.SetCode(value : TFhirCodeableReference);
begin
  FCode.free;
  FCode := value;
end;

function TFhirIngredientSubstance.GetStrengthList : TFhirIngredientSubstanceStrengthList;
begin
  if FStrengthList = nil then
    FStrengthList := TFhirIngredientSubstanceStrengthList.Create;
  result := FStrengthList;
end;

function TFhirIngredientSubstance.GetHasStrengthList : boolean;
begin
  result := (FStrengthList <> nil) and (FStrengthList.count > 0);
end;

{ TFhirIngredientSubstanceListEnumerator }

constructor TFhirIngredientSubstanceListEnumerator.Create(list : TFhirIngredientSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSubstanceListEnumerator.GetCurrent : TFhirIngredientSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSubstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientSubstanceList }

function TFhirIngredientSubstanceList.AddItem(value: TFhirIngredientSubstance): TFhirIngredientSubstance;
begin
  assert(value.ClassName = 'TFhirIngredientSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSubstance');
  add(value);
  result := value;
end;

function TFhirIngredientSubstanceList.Append: TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSubstanceList.GetEnumerator : TFhirIngredientSubstanceListEnumerator;
begin
  result := TFhirIngredientSubstanceListEnumerator.Create(self.link);
end;

function TFhirIngredientSubstanceList.Clone: TFhirIngredientSubstanceList;
begin
  result := TFhirIngredientSubstanceList(inherited Clone);
end;

function TFhirIngredientSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSubstanceList.GetItemN(index: Integer): TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSubstance;
end;
function TFhirIngredientSubstanceList.IndexOf(value: TFhirIngredientSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSubstanceList.Insert(index: Integer): TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceList.InsertItem(index: Integer; value: TFhirIngredientSubstance);
begin
  assert(value is TFhirIngredientSubstance);
  Inherited Insert(index, value);
end;

function TFhirIngredientSubstanceList.Item(index: Integer): TFhirIngredientSubstance;
begin
  result := TFhirIngredientSubstance(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceList.Link: TFhirIngredientSubstanceList;
begin
  result := TFhirIngredientSubstanceList(inherited Link);
end;

procedure TFhirIngredientSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSubstanceList.SetItemByIndex(index: Integer; value: TFhirIngredientSubstance);
begin
  assert(value is TFhirIngredientSubstance);
  FhirIngredientSubstances[index] := value;
end;

procedure TFhirIngredientSubstanceList.SetItemN(index: Integer; value: TFhirIngredientSubstance);
begin
  assert(value is TFhirIngredientSubstance);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredientSubstanceStrength }

constructor TFhirIngredientSubstanceStrength.Create;
begin
  inherited;
end;

destructor TFhirIngredientSubstanceStrength.Destroy;
begin
  FPresentation.free;
  FPresentationText.free;
  FConcentration.free;
  FConcentrationText.free;
  FMeasurementPoint.free;
  FCountryList.Free;
  FReferenceStrengthList.Free;
  inherited;
end;

procedure TFhirIngredientSubstanceStrength.Assign(oSource : TFslObject);
begin
  inherited;
  presentation := TFhirIngredientSubstanceStrength(oSource).presentation.Clone;
  presentationTextElement := TFhirIngredientSubstanceStrength(oSource).presentationTextElement.Clone;
  concentration := TFhirIngredientSubstanceStrength(oSource).concentration.Clone;
  concentrationTextElement := TFhirIngredientSubstanceStrength(oSource).concentrationTextElement.Clone;
  measurementPointElement := TFhirIngredientSubstanceStrength(oSource).measurementPointElement.Clone;
  if (TFhirIngredientSubstanceStrength(oSource).FCountryList = nil) then
  begin
    FCountryList.free;
    FCountryList := nil;
  end
  else
  begin
    if FCountryList = nil then
      FCountryList := TFhirCodeableConceptList.Create;
    FCountryList.Assign(TFhirIngredientSubstanceStrength(oSource).FCountryList);
  end;
  if (TFhirIngredientSubstanceStrength(oSource).FReferenceStrengthList = nil) then
  begin
    FReferenceStrengthList.free;
    FReferenceStrengthList := nil;
  end
  else
  begin
    if FReferenceStrengthList = nil then
      FReferenceStrengthList := TFhirIngredientSubstanceStrengthReferenceStrengthList.Create;
    FReferenceStrengthList.Assign(TFhirIngredientSubstanceStrength(oSource).FReferenceStrengthList);
  end;
end;

procedure TFhirIngredientSubstanceStrength.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'presentation[x]') or (child_name = 'presentation') Then
     list.add(self.link, 'presentation[x]', FPresentation.Link);
  if (child_name = 'presentationText') Then
     list.add(self.link, 'presentationText', FPresentationText.Link);
  if (child_name = 'concentration[x]') or (child_name = 'concentration') Then
     list.add(self.link, 'concentration[x]', FConcentration.Link);
  if (child_name = 'concentrationText') Then
     list.add(self.link, 'concentrationText', FConcentrationText.Link);
  if (child_name = 'measurementPoint') Then
     list.add(self.link, 'measurementPoint', FMeasurementPoint.Link);
  if (child_name = 'country') Then
    list.addAll(self, 'country', FCountryList);
  if (child_name = 'referenceStrength') Then
    list.addAll(self, 'referenceStrength', FReferenceStrengthList);
end;

procedure TFhirIngredientSubstanceStrength.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'presentation[x]', 'Ratio|RatioRange', false, TFhirDataType, FPresentation.Link));
  oList.add(TFHIRProperty.create(self, 'presentationText', 'string', false, TFhirString, FPresentationText.Link));
  oList.add(TFHIRProperty.create(self, 'concentration[x]', 'Ratio|RatioRange', false, TFhirDataType, FConcentration.Link));
  oList.add(TFHIRProperty.create(self, 'concentrationText', 'string', false, TFhirString, FConcentrationText.Link));
  oList.add(TFHIRProperty.create(self, 'measurementPoint', 'string', false, TFhirString, FMeasurementPoint.Link));
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', true, TFhirCodeableConcept, FCountryList.Link));
  oList.add(TFHIRProperty.create(self, 'referenceStrength', 'BackboneElement', true, TFhirIngredientSubstanceStrengthReferenceStrength, FReferenceStrengthList.Link));
end;

function TFhirIngredientSubstanceStrength.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'presentation', ['Ratio', 'RatioRange'])) then
  begin
    Presentation := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'presentationText') then
  begin
    PresentationTextElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'concentration', ['Ratio', 'RatioRange'])) then
  begin
    Concentration := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'concentrationText') then
  begin
    ConcentrationTextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'measurementPoint') then
  begin
    MeasurementPointElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'referenceStrength') then
  begin
    ReferenceStrengthList.add(propValue as TFhirIngredientSubstanceStrengthReferenceStrength);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSubstanceStrength.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'country') then CountryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'referenceStrength') then ReferenceStrengthList.insertItem(index, propValue as TFhirIngredientSubstanceStrengthReferenceStrength)
  else inherited;
end;

function TFhirIngredientSubstanceStrength.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'presentation', ['Ratio', 'RatioRange'])) then raise EFHIRException.create('Cannot make property Presentation')
  else if (propName = 'presentationText') then result := TFhirString.create()
  else if (isMatchingName(propName, 'concentration', ['Ratio', 'RatioRange'])) then raise EFHIRException.create('Cannot make property Concentration')
  else if (propName = 'concentrationText') then result := TFhirString.create()
  else if (propName = 'measurementPoint') then result := TFhirString.create()
  else if (propName = 'country') then result := CountryList.new()
  else if (propName = 'referenceStrength') then result := ReferenceStrengthList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSubstanceStrength.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'presentation[x]') then result := 'Ratio|RatioRange'
  else if (propName = 'presentationText') then result := 'string'
  else if (propName = 'concentration[x]') then result := 'Ratio|RatioRange'
  else if (propName = 'concentrationText') then result := 'string'
  else if (propName = 'measurementPoint') then result := 'string'
  else if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'referenceStrength') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSubstanceStrength.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'presentation', ['Ratio', 'RatioRange'])) then PresentationElement := nil
  else if (propName = 'presentationText') then PresentationTextElement := nil
  else if (isMatchingName(propName, 'concentration', ['Ratio', 'RatioRange'])) then ConcentrationElement := nil
  else if (propName = 'concentrationText') then ConcentrationTextElement := nil
  else if (propName = 'measurementPoint') then MeasurementPointElement := nil
  else if (propName = 'country') then deletePropertyValue('country', CountryList, value)
  else if (propName = 'referenceStrength') then deletePropertyValue('referenceStrength', ReferenceStrengthList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSubstanceStrength.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'presentation', ['Ratio', 'RatioRange'])) then PresentationElement := new as TFhirDataType
  else if (propName = 'presentationText') then PresentationTextElement := asString(new)
  else if (isMatchingName(propName, 'concentration', ['Ratio', 'RatioRange'])) then ConcentrationElement := new as TFhirDataType
  else if (propName = 'concentrationText') then ConcentrationTextElement := asString(new)
  else if (propName = 'measurementPoint') then MeasurementPointElement := asString(new)
  else if (propName = 'country') then replacePropertyValue('country', CountryList, existing, new)
  else if (propName = 'referenceStrength') then replacePropertyValue('referenceStrength', ReferenceStrengthList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSubstanceStrength.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'country') then CountryList.move(source, destination)
  else if (propName = 'referenceStrength') then ReferenceStrengthList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSubstanceStrength.fhirType : string;
begin
  result := 'Ingredient.substance.strength';
end;

function TFhirIngredientSubstanceStrength.Link : TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(inherited Link);
end;

function TFhirIngredientSubstanceStrength.Clone : TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(inherited Clone);
end;

function TFhirIngredientSubstanceStrength.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSubstanceStrength;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSubstanceStrength)) then
    result := false
  else
  begin
    o := TFhirIngredientSubstanceStrength(other);
    result := compareDeep(presentationElement, o.presentationElement, true) and 
      compareDeep(presentationTextElement, o.presentationTextElement, true) and compareDeep(concentrationElement, o.concentrationElement, true) and 
      compareDeep(concentrationTextElement, o.concentrationTextElement, true) and compareDeep(measurementPointElement, o.measurementPointElement, true) and 
      compareDeep(countryList, o.countryList, true) and compareDeep(referenceStrengthList, o.referenceStrengthList, true);
  end;
end;

function TFhirIngredientSubstanceStrength.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPresentation) and isEmptyProp(FPresentationText) and isEmptyProp(FConcentration) and isEmptyProp(FConcentrationText) and isEmptyProp(FMeasurementPoint) and isEmptyProp(FcountryList) and isEmptyProp(FreferenceStrengthList);
end;

procedure TFhirIngredientSubstanceStrength.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('presentation[x]');
  fields.add('presentationText');
  fields.add('concentration[x]');
  fields.add('concentrationText');
  fields.add('measurementPoint');
  fields.add('country');
  fields.add('referenceStrength');
end;

function TFhirIngredientSubstanceStrength.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCountryList.sizeInBytes(magic));
  inc(result, FReferenceStrengthList.sizeInBytes(magic));
end;

procedure TFhirIngredientSubstanceStrength.SetPresentation(value : TFhirDataType);
begin
  FPresentation.free;
  FPresentation := value;
end;

procedure TFhirIngredientSubstanceStrength.SetPresentationText(value : TFhirString);
begin
  FPresentationText.free;
  FPresentationText := value;
end;

function TFhirIngredientSubstanceStrength.GetPresentationTextST : String;
begin
  if FPresentationText = nil then
    result := ''
  else
    result := FPresentationText.value;
end;

procedure TFhirIngredientSubstanceStrength.SetPresentationTextST(value : String);
begin
  if value <> '' then
  begin
    if FPresentationText = nil then
      FPresentationText := TFhirString.create;
    FPresentationText.value := value
  end
  else if FPresentationText <> nil then
    FPresentationText.value := '';
end;

procedure TFhirIngredientSubstanceStrength.SetConcentration(value : TFhirDataType);
begin
  FConcentration.free;
  FConcentration := value;
end;

procedure TFhirIngredientSubstanceStrength.SetConcentrationText(value : TFhirString);
begin
  FConcentrationText.free;
  FConcentrationText := value;
end;

function TFhirIngredientSubstanceStrength.GetConcentrationTextST : String;
begin
  if FConcentrationText = nil then
    result := ''
  else
    result := FConcentrationText.value;
end;

procedure TFhirIngredientSubstanceStrength.SetConcentrationTextST(value : String);
begin
  if value <> '' then
  begin
    if FConcentrationText = nil then
      FConcentrationText := TFhirString.create;
    FConcentrationText.value := value
  end
  else if FConcentrationText <> nil then
    FConcentrationText.value := '';
end;

procedure TFhirIngredientSubstanceStrength.SetMeasurementPoint(value : TFhirString);
begin
  FMeasurementPoint.free;
  FMeasurementPoint := value;
end;

function TFhirIngredientSubstanceStrength.GetMeasurementPointST : String;
begin
  if FMeasurementPoint = nil then
    result := ''
  else
    result := FMeasurementPoint.value;
end;

procedure TFhirIngredientSubstanceStrength.SetMeasurementPointST(value : String);
begin
  if value <> '' then
  begin
    if FMeasurementPoint = nil then
      FMeasurementPoint := TFhirString.create;
    FMeasurementPoint.value := value
  end
  else if FMeasurementPoint <> nil then
    FMeasurementPoint.value := '';
end;

function TFhirIngredientSubstanceStrength.GetCountryList : TFhirCodeableConceptList;
begin
  if FCountryList = nil then
    FCountryList := TFhirCodeableConceptList.Create;
  result := FCountryList;
end;

function TFhirIngredientSubstanceStrength.GetHasCountryList : boolean;
begin
  result := (FCountryList <> nil) and (FCountryList.count > 0);
end;

function TFhirIngredientSubstanceStrength.GetReferenceStrengthList : TFhirIngredientSubstanceStrengthReferenceStrengthList;
begin
  if FReferenceStrengthList = nil then
    FReferenceStrengthList := TFhirIngredientSubstanceStrengthReferenceStrengthList.Create;
  result := FReferenceStrengthList;
end;

function TFhirIngredientSubstanceStrength.GetHasReferenceStrengthList : boolean;
begin
  result := (FReferenceStrengthList <> nil) and (FReferenceStrengthList.count > 0);
end;

{ TFhirIngredientSubstanceStrengthListEnumerator }

constructor TFhirIngredientSubstanceStrengthListEnumerator.Create(list : TFhirIngredientSubstanceStrengthList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSubstanceStrengthListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSubstanceStrengthListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSubstanceStrengthListEnumerator.GetCurrent : TFhirIngredientSubstanceStrength;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSubstanceStrengthListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientSubstanceStrengthList }

function TFhirIngredientSubstanceStrengthList.AddItem(value: TFhirIngredientSubstanceStrength): TFhirIngredientSubstanceStrength;
begin
  assert(value.ClassName = 'TFhirIngredientSubstanceStrength', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSubstanceStrength');
  add(value);
  result := value;
end;

function TFhirIngredientSubstanceStrengthList.Append: TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSubstanceStrengthList.GetEnumerator : TFhirIngredientSubstanceStrengthListEnumerator;
begin
  result := TFhirIngredientSubstanceStrengthListEnumerator.Create(self.link);
end;

function TFhirIngredientSubstanceStrengthList.Clone: TFhirIngredientSubstanceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthList(inherited Clone);
end;

function TFhirIngredientSubstanceStrengthList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSubstanceStrengthList.GetItemN(index: Integer): TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSubstanceStrength;
end;
function TFhirIngredientSubstanceStrengthList.IndexOf(value: TFhirIngredientSubstanceStrength): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSubstanceStrengthList.Insert(index: Integer): TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthList.InsertItem(index: Integer; value: TFhirIngredientSubstanceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrength);
  Inherited Insert(index, value);
end;

function TFhirIngredientSubstanceStrengthList.Item(index: Integer): TFhirIngredientSubstanceStrength;
begin
  result := TFhirIngredientSubstanceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthList.Link: TFhirIngredientSubstanceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthList(inherited Link);
end;

procedure TFhirIngredientSubstanceStrengthList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSubstanceStrengthList.SetItemByIndex(index: Integer; value: TFhirIngredientSubstanceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrength);
  FhirIngredientSubstanceStrengths[index] := value;
end;

procedure TFhirIngredientSubstanceStrengthList.SetItemN(index: Integer; value: TFhirIngredientSubstanceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrength);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredientSubstanceStrengthReferenceStrength }

constructor TFhirIngredientSubstanceStrengthReferenceStrength.Create;
begin
  inherited;
end;

destructor TFhirIngredientSubstanceStrengthReferenceStrength.Destroy;
begin
  FSubstance.free;
  FStrength.free;
  FMeasurementPoint.free;
  FCountryList.Free;
  inherited;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).substance.Clone;
  strength := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).strength.Clone;
  measurementPointElement := TFhirIngredientSubstanceStrengthReferenceStrength(oSource).measurementPointElement.Clone;
  if (TFhirIngredientSubstanceStrengthReferenceStrength(oSource).FCountryList = nil) then
  begin
    FCountryList.free;
    FCountryList := nil;
  end
  else
  begin
    if FCountryList = nil then
      FCountryList := TFhirCodeableConceptList.Create;
    FCountryList.Assign(TFhirIngredientSubstanceStrengthReferenceStrength(oSource).FCountryList);
  end;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'strength[x]') or (child_name = 'strength') Then
     list.add(self.link, 'strength[x]', FStrength.Link);
  if (child_name = 'measurementPoint') Then
     list.add(self.link, 'measurementPoint', FMeasurementPoint.Link);
  if (child_name = 'country') Then
    list.addAll(self, 'country', FCountryList);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableReference', false, TFhirCodeableReference, FSubstance.Link));
  oList.add(TFHIRProperty.create(self, 'strength[x]', 'Ratio|RatioRange', false, TFhirDataType, FStrength.Link));
  oList.add(TFHIRProperty.create(self, 'measurementPoint', 'string', false, TFhirString, FMeasurementPoint.Link));
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', true, TFhirCodeableConcept, FCountryList.Link));
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'strength', ['Ratio', 'RatioRange'])) then
  begin
    Strength := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'measurementPoint') then
  begin
    MeasurementPointElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'country') then
  begin
    CountryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'country') then CountryList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableReference.create()
  else if (isMatchingName(propName, 'strength', ['Ratio', 'RatioRange'])) then raise EFHIRException.create('Cannot make property Strength')
  else if (propName = 'measurementPoint') then result := TFhirString.create()
  else if (propName = 'country') then result := CountryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableReference'
  else if (propName = 'strength[x]') then result := 'Ratio|RatioRange'
  else if (propName = 'measurementPoint') then result := 'string'
  else if (propName = 'country') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (isMatchingName(propName, 'strength', ['Ratio', 'RatioRange'])) then StrengthElement := nil
  else if (propName = 'measurementPoint') then MeasurementPointElement := nil
  else if (propName = 'country') then deletePropertyValue('country', CountryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableReference
  else if (isMatchingName(propName, 'strength', ['Ratio', 'RatioRange'])) then StrengthElement := new as TFhirDataType
  else if (propName = 'measurementPoint') then MeasurementPointElement := asString(new)
  else if (propName = 'country') then replacePropertyValue('country', CountryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'country') then CountryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.fhirType : string;
begin
  result := 'Ingredient.substance.strength.referenceStrength';
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.Link : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(inherited Link);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.Clone : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(inherited Clone);
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.equals(other : TObject) : boolean; 
var
  o : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredientSubstanceStrengthReferenceStrength)) then
    result := false
  else
  begin
    o := TFhirIngredientSubstanceStrengthReferenceStrength(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(strengthElement, o.strengthElement, true) and 
      compareDeep(measurementPointElement, o.measurementPointElement, true) and compareDeep(countryList, o.countryList, true);
  end;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FStrength) and isEmptyProp(FMeasurementPoint) and isEmptyProp(FcountryList);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('substance');
  fields.add('strength[x]');
  fields.add('measurementPoint');
  fields.add('country');
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCountryList.sizeInBytes(magic));
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetSubstance(value : TFhirCodeableReference);
begin
  FSubstance.free;
  FSubstance := value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetStrength(value : TFhirDataType);
begin
  FStrength.free;
  FStrength := value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetMeasurementPoint(value : TFhirString);
begin
  FMeasurementPoint.free;
  FMeasurementPoint := value;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.GetMeasurementPointST : String;
begin
  if FMeasurementPoint = nil then
    result := ''
  else
    result := FMeasurementPoint.value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrength.SetMeasurementPointST(value : String);
begin
  if value <> '' then
  begin
    if FMeasurementPoint = nil then
      FMeasurementPoint := TFhirString.create;
    FMeasurementPoint.value := value
  end
  else if FMeasurementPoint <> nil then
    FMeasurementPoint.value := '';
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.GetCountryList : TFhirCodeableConceptList;
begin
  if FCountryList = nil then
    FCountryList := TFhirCodeableConceptList.Create;
  result := FCountryList;
end;

function TFhirIngredientSubstanceStrengthReferenceStrength.GetHasCountryList : boolean;
begin
  result := (FCountryList <> nil) and (FCountryList.count > 0);
end;

{ TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator }

constructor TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.Create(list : TFhirIngredientSubstanceStrengthReferenceStrengthList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.GetCurrent : TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientSubstanceStrengthReferenceStrengthList }

function TFhirIngredientSubstanceStrengthReferenceStrengthList.AddItem(value: TFhirIngredientSubstanceStrengthReferenceStrength): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  assert(value.ClassName = 'TFhirIngredientSubstanceStrengthReferenceStrength', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredientSubstanceStrengthReferenceStrength');
  add(value);
  result := value;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Append: TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.GetEnumerator : TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrengthListEnumerator.Create(self.link);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Clone: TFhirIngredientSubstanceStrengthReferenceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrengthList(inherited Clone);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.GetItemN(index: Integer): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength;
end;
function TFhirIngredientSubstanceStrengthReferenceStrengthList.IndexOf(value: TFhirIngredientSubstanceStrengthReferenceStrength): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Insert(index: Integer): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.InsertItem(index: Integer; value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrengthReferenceStrength);
  Inherited Insert(index, value);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Item(index: Integer): TFhirIngredientSubstanceStrengthReferenceStrength;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrength(ObjectByIndex[index]);
end;

function TFhirIngredientSubstanceStrengthReferenceStrengthList.Link: TFhirIngredientSubstanceStrengthReferenceStrengthList;
begin
  result := TFhirIngredientSubstanceStrengthReferenceStrengthList(inherited Link);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.SetItemByIndex(index: Integer; value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrengthReferenceStrength);
  FhirIngredientSubstanceStrengthReferenceStrengths[index] := value;
end;

procedure TFhirIngredientSubstanceStrengthReferenceStrengthList.SetItemN(index: Integer; value: TFhirIngredientSubstanceStrengthReferenceStrength);
begin
  assert(value is TFhirIngredientSubstanceStrengthReferenceStrength);
  ObjectByIndex[index] := value;
end;

{ TFhirIngredient }

constructor TFhirIngredient.Create;
begin
  inherited;
end;

destructor TFhirIngredient.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FFor_List.Free;
  FRole.free;
  FFunction_List.Free;
  FAllergenicIndicator.free;
  FManufacturerList.Free;
  FSubstance.free;
  inherited;
end;

procedure TFhirIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirIngredient(oSource).identifier.Clone;
  statusElement := TFhirIngredient(oSource).statusElement.Clone;
  if (TFhirIngredient(oSource).FFor_List = nil) then
  begin
    FFor_List.free;
    FFor_List := nil;
  end
  else
  begin
    if FFor_List = nil then
      FFor_List := TFhirReferenceList.Create;
    FFor_List.Assign(TFhirIngredient(oSource).FFor_List);
  end;
  role := TFhirIngredient(oSource).role.Clone;
  if (TFhirIngredient(oSource).FFunction_List = nil) then
  begin
    FFunction_List.free;
    FFunction_List := nil;
  end
  else
  begin
    if FFunction_List = nil then
      FFunction_List := TFhirCodeableConceptList.Create;
    FFunction_List.Assign(TFhirIngredient(oSource).FFunction_List);
  end;
  allergenicIndicatorElement := TFhirIngredient(oSource).allergenicIndicatorElement.Clone;
  if (TFhirIngredient(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirIngredientManufacturerList.Create;
    FManufacturerList.Assign(TFhirIngredient(oSource).FManufacturerList);
  end;
  substance := TFhirIngredient(oSource).substance.Clone;
end;

function TFhirIngredient.GetResourceType : TFhirResourceType;
begin
  result := frtIngredient;
end;

procedure TFhirIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'for') Then
    list.addAll(self, 'for', FFor_List);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'function') Then
    list.addAll(self, 'function', FFunction_List);
  if (child_name = 'allergenicIndicator') Then
     list.add(self.link, 'allergenicIndicator', FAllergenicIndicator.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
end;

procedure TFhirIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'for', 'Reference', true, TFhirReference, FFor_List.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', true, TFhirCodeableConcept, FFunction_List.Link));
  oList.add(TFHIRProperty.create(self, 'allergenicIndicator', 'boolean', false, TFhirBoolean, FAllergenicIndicator.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'BackboneElement', true, TFhirIngredientManufacturer, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'substance', 'BackboneElement', false, TFhirIngredientSubstance, FSubstance.Link));
end;

function TFhirIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'for') then
  begin
    For_List.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'function') then
  begin
    Function_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'allergenicIndicator') then
  begin
    AllergenicIndicatorElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirIngredientManufacturer);
    result := propValue;
  end
  else if (propName = 'substance') then
  begin
    Substance := propValue as TFhirIngredientSubstance;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'for') then For_List.insertItem(index, propValue as TFhirReference)
  else if (propName = 'function') then Function_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirIngredientManufacturer)
  else inherited;
end;

function TFhirIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'for') then result := For_List.new()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'function') then result := Function_List.new()
  else if (propName = 'allergenicIndicator') then result := TFhirBoolean.create()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'substance') then result := TFhirIngredientSubstance.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'for') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'allergenicIndicator') then result := 'boolean'
  else if (propName = 'manufacturer') then result := 'BackboneElement'
  else if (propName = 'substance') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'for') then deletePropertyValue('for', For_List, value)
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'function') then deletePropertyValue('function', Function_List, value)
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'substance') then SubstanceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'for') then replacePropertyValue('for', For_List, existing, new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'function') then replacePropertyValue('function', Function_List, existing, new)
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := asBoolean(new)
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'substance') then SubstanceElement := new as TFhirIngredientSubstance
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'for') then For_List.move(source, destination)
  else if (propName = 'function') then Function_List.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirIngredient.fhirType : string;
begin
  result := 'Ingredient';
end;

function TFhirIngredient.Link : TFhirIngredient;
begin
  result := TFhirIngredient(inherited Link);
end;

function TFhirIngredient.Clone : TFhirIngredient;
begin
  result := TFhirIngredient(inherited Clone);
end;

function TFhirIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirIngredient)) then
    result := false
  else
  begin
    o := TFhirIngredient(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(for_List, o.for_List, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(function_List, o.function_List, true) and compareDeep(allergenicIndicatorElement, o.allergenicIndicatorElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(substanceElement, o.substanceElement, true);
  end;
end;

function TFhirIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(Ffor_List) and isEmptyProp(FRole) and isEmptyProp(Ffunction_List) and isEmptyProp(FAllergenicIndicator) and isEmptyProp(FmanufacturerList) and isEmptyProp(FSubstance);
end;

procedure TFhirIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('for');
  fields.add('role');
  fields.add('function');
  fields.add('allergenicIndicator');
  fields.add('manufacturer');
  fields.add('substance');
end;

function TFhirIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FFor_List.sizeInBytes(magic));
  inc(result, FFunction_List.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
end;

procedure TFhirIngredient.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirIngredient.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirIngredient.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirIngredient.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirIngredient.GetFor_List : TFhirReferenceList;
begin
  if FFor_List = nil then
    FFor_List := TFhirReferenceList.Create;
  result := FFor_List;
end;

function TFhirIngredient.GetHasFor_List : boolean;
begin
  result := (FFor_List <> nil) and (FFor_List.count > 0);
end;

procedure TFhirIngredient.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

function TFhirIngredient.GetFunction_List : TFhirCodeableConceptList;
begin
  if FFunction_List = nil then
    FFunction_List := TFhirCodeableConceptList.Create;
  result := FFunction_List;
end;

function TFhirIngredient.GetHasFunction_List : boolean;
begin
  result := (FFunction_List <> nil) and (FFunction_List.count > 0);
end;

procedure TFhirIngredient.SetAllergenicIndicator(value : TFhirBoolean);
begin
  FAllergenicIndicator.free;
  FAllergenicIndicator := value;
end;

function TFhirIngredient.GetAllergenicIndicatorST : Boolean;
begin
  if FAllergenicIndicator = nil then
    result := false
  else
    result := FAllergenicIndicator.value;
end;

procedure TFhirIngredient.SetAllergenicIndicatorST(value : Boolean);
begin
  if FAllergenicIndicator = nil then
    FAllergenicIndicator := TFhirBoolean.create;
  FAllergenicIndicator.value := value
end;

function TFhirIngredient.GetManufacturerList : TFhirIngredientManufacturerList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirIngredientManufacturerList.Create;
  result := FManufacturerList;
end;

function TFhirIngredient.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

procedure TFhirIngredient.SetSubstance(value : TFhirIngredientSubstance);
begin
  FSubstance.free;
  FSubstance := value;
end;

{ TFhirIngredientListEnumerator }

constructor TFhirIngredientListEnumerator.Create(list : TFhirIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirIngredientListEnumerator.GetCurrent : TFhirIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirIngredientList }

function TFhirIngredientList.AddItem(value: TFhirIngredient): TFhirIngredient;
begin
  assert(value.ClassName = 'TFhirIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirIngredient');
  add(value);
  result := value;
end;

function TFhirIngredientList.Append: TFhirIngredient;
begin
  result := TFhirIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirIngredientList.GetEnumerator : TFhirIngredientListEnumerator;
begin
  result := TFhirIngredientListEnumerator.Create(self.link);
end;

function TFhirIngredientList.Clone: TFhirIngredientList;
begin
  result := TFhirIngredientList(inherited Clone);
end;

function TFhirIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirIngredientList.GetItemN(index: Integer): TFhirIngredient;
begin
  result := TFhirIngredient(ObjectByIndex[index]);
end;

function TFhirIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirIngredient;
end;
function TFhirIngredientList.IndexOf(value: TFhirIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirIngredientList.Insert(index: Integer): TFhirIngredient;
begin
  result := TFhirIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirIngredientList.InsertItem(index: Integer; value: TFhirIngredient);
begin
  assert(value is TFhirIngredient);
  Inherited Insert(index, value);
end;

function TFhirIngredientList.Item(index: Integer): TFhirIngredient;
begin
  result := TFhirIngredient(ObjectByIndex[index]);
end;

function TFhirIngredientList.Link: TFhirIngredientList;
begin
  result := TFhirIngredientList(inherited Link);
end;

procedure TFhirIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirIngredientList.SetItemByIndex(index: Integer; value: TFhirIngredient);
begin
  assert(value is TFhirIngredient);
  FhirIngredients[index] := value;
end;

procedure TFhirIngredientList.SetItemN(index: Integer; value: TFhirIngredient);
begin
  assert(value is TFhirIngredient);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_INGREDIENT}
{$IFDEF FHIR_MANUFACTUREDITEMDEFINITION}
{ TFhirManufacturedItemDefinitionProperty }

constructor TFhirManufacturedItemDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirManufacturedItemDefinitionProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirManufacturedItemDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirManufacturedItemDefinitionProperty(oSource).type_.Clone;
  value := TFhirManufacturedItemDefinitionProperty(oSource).value.Clone;
end;

procedure TFhirManufacturedItemDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirManufacturedItemDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirManufacturedItemDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirManufacturedItemDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirManufacturedItemDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirManufacturedItemDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirManufacturedItemDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirManufacturedItemDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirManufacturedItemDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirManufacturedItemDefinitionProperty.fhirType : string;
begin
  result := 'ManufacturedItemDefinition.property';
end;

function TFhirManufacturedItemDefinitionProperty.Link : TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(inherited Link);
end;

function TFhirManufacturedItemDefinitionProperty.Clone : TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(inherited Clone);
end;

function TFhirManufacturedItemDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirManufacturedItemDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirManufacturedItemDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirManufacturedItemDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirManufacturedItemDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirManufacturedItemDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirManufacturedItemDefinitionProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirManufacturedItemDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirManufacturedItemDefinitionProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirManufacturedItemDefinitionPropertyListEnumerator }

constructor TFhirManufacturedItemDefinitionPropertyListEnumerator.Create(list : TFhirManufacturedItemDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirManufacturedItemDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirManufacturedItemDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirManufacturedItemDefinitionPropertyListEnumerator.GetCurrent : TFhirManufacturedItemDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirManufacturedItemDefinitionPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirManufacturedItemDefinitionPropertyList }

function TFhirManufacturedItemDefinitionPropertyList.AddItem(value: TFhirManufacturedItemDefinitionProperty): TFhirManufacturedItemDefinitionProperty;
begin
  assert(value.ClassName = 'TFhirManufacturedItemDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirManufacturedItemDefinitionProperty');
  add(value);
  result := value;
end;

function TFhirManufacturedItemDefinitionPropertyList.Append: TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirManufacturedItemDefinitionPropertyList.GetEnumerator : TFhirManufacturedItemDefinitionPropertyListEnumerator;
begin
  result := TFhirManufacturedItemDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirManufacturedItemDefinitionPropertyList.Clone: TFhirManufacturedItemDefinitionPropertyList;
begin
  result := TFhirManufacturedItemDefinitionPropertyList(inherited Clone);
end;

function TFhirManufacturedItemDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirManufacturedItemDefinitionPropertyList.GetItemN(index: Integer): TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirManufacturedItemDefinitionProperty;
end;
function TFhirManufacturedItemDefinitionPropertyList.IndexOf(value: TFhirManufacturedItemDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirManufacturedItemDefinitionPropertyList.Insert(index: Integer): TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionPropertyList.InsertItem(index: Integer; value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value is TFhirManufacturedItemDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirManufacturedItemDefinitionPropertyList.Item(index: Integer): TFhirManufacturedItemDefinitionProperty;
begin
  result := TFhirManufacturedItemDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionPropertyList.Link: TFhirManufacturedItemDefinitionPropertyList;
begin
  result := TFhirManufacturedItemDefinitionPropertyList(inherited Link);
end;

procedure TFhirManufacturedItemDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirManufacturedItemDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value is TFhirManufacturedItemDefinitionProperty);
  FhirManufacturedItemDefinitionProperties[index] := value;
end;

procedure TFhirManufacturedItemDefinitionPropertyList.SetItemN(index: Integer; value: TFhirManufacturedItemDefinitionProperty);
begin
  assert(value is TFhirManufacturedItemDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirManufacturedItemDefinition }

constructor TFhirManufacturedItemDefinition.Create;
begin
  inherited;
end;

destructor TFhirManufacturedItemDefinition.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FManufacturedDoseForm.free;
  FUnitOfPresentation.free;
  FManufacturerList.Free;
  FIngredientList.Free;
  FProperty_List.Free;
  inherited;
end;

procedure TFhirManufacturedItemDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirManufacturedItemDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirManufacturedItemDefinition(oSource).FIdentifierList);
  end;
  statusElement := TFhirManufacturedItemDefinition(oSource).statusElement.Clone;
  manufacturedDoseForm := TFhirManufacturedItemDefinition(oSource).manufacturedDoseForm.Clone;
  unitOfPresentation := TFhirManufacturedItemDefinition(oSource).unitOfPresentation.Clone;
  if (TFhirManufacturedItemDefinition(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirManufacturedItemDefinition(oSource).FManufacturerList);
  end;
  if (TFhirManufacturedItemDefinition(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirCodeableConceptList.Create;
    FIngredientList.Assign(TFhirManufacturedItemDefinition(oSource).FIngredientList);
  end;
  if (TFhirManufacturedItemDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirManufacturedItemDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirManufacturedItemDefinition(oSource).FProperty_List);
  end;
end;

function TFhirManufacturedItemDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtManufacturedItemDefinition;
end;

procedure TFhirManufacturedItemDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'manufacturedDoseForm') Then
     list.add(self.link, 'manufacturedDoseForm', FManufacturedDoseForm.Link);
  if (child_name = 'unitOfPresentation') Then
     list.add(self.link, 'unitOfPresentation', FUnitOfPresentation.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
end;

procedure TFhirManufacturedItemDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturedDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FManufacturedDoseForm.Link));
  oList.add(TFHIRProperty.create(self, 'unitOfPresentation', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfPresentation.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'CodeableConcept', true, TFhirCodeableConcept, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirManufacturedItemDefinitionProperty, FProperty_List.Link));
end;

function TFhirManufacturedItemDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'manufacturedDoseForm') then
  begin
    ManufacturedDoseForm := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'unitOfPresentation') then
  begin
    UnitOfPresentation := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirManufacturedItemDefinitionProperty);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirManufacturedItemDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirManufacturedItemDefinitionProperty)
  else inherited;
end;

function TFhirManufacturedItemDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'manufacturedDoseForm') then result := TFhirCodeableConcept.create()
  else if (propName = 'unitOfPresentation') then result := TFhirCodeableConcept.create()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'property') then result := Property_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirManufacturedItemDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'manufacturedDoseForm') then result := 'CodeableConcept'
  else if (propName = 'unitOfPresentation') then result := 'CodeableConcept'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'ingredient') then result := 'CodeableConcept'
  else if (propName = 'property') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirManufacturedItemDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'manufacturedDoseForm') then ManufacturedDoseFormElement := nil
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirManufacturedItemDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'manufacturedDoseForm') then ManufacturedDoseFormElement := new as TFhirCodeableConcept
  else if (propName = 'unitOfPresentation') then UnitOfPresentationElement := new as TFhirCodeableConcept
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirManufacturedItemDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirManufacturedItemDefinition.fhirType : string;
begin
  result := 'ManufacturedItemDefinition';
end;

function TFhirManufacturedItemDefinition.Link : TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(inherited Link);
end;

function TFhirManufacturedItemDefinition.Clone : TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(inherited Clone);
end;

function TFhirManufacturedItemDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirManufacturedItemDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirManufacturedItemDefinition)) then
    result := false
  else
  begin
    o := TFhirManufacturedItemDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(manufacturedDoseFormElement, o.manufacturedDoseFormElement, true) and 
      compareDeep(unitOfPresentationElement, o.unitOfPresentationElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(property_List, o.property_List, true);
  end;
end;

function TFhirManufacturedItemDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FManufacturedDoseForm) and isEmptyProp(FUnitOfPresentation) and isEmptyProp(FmanufacturerList) and isEmptyProp(FingredientList) and isEmptyProp(Fproperty_List);
end;

procedure TFhirManufacturedItemDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('manufacturedDoseForm');
  fields.add('unitOfPresentation');
  fields.add('manufacturer');
  fields.add('ingredient');
  fields.add('property');
end;

function TFhirManufacturedItemDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
end;

function TFhirManufacturedItemDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirManufacturedItemDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirManufacturedItemDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirManufacturedItemDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirManufacturedItemDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirManufacturedItemDefinition.SetManufacturedDoseForm(value : TFhirCodeableConcept);
begin
  FManufacturedDoseForm.free;
  FManufacturedDoseForm := value;
end;

procedure TFhirManufacturedItemDefinition.SetUnitOfPresentation(value : TFhirCodeableConcept);
begin
  FUnitOfPresentation.free;
  FUnitOfPresentation := value;
end;

function TFhirManufacturedItemDefinition.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirManufacturedItemDefinition.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirManufacturedItemDefinition.GetIngredientList : TFhirCodeableConceptList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirCodeableConceptList.Create;
  result := FIngredientList;
end;

function TFhirManufacturedItemDefinition.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirManufacturedItemDefinition.GetProperty_List : TFhirManufacturedItemDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirManufacturedItemDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirManufacturedItemDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

{ TFhirManufacturedItemDefinitionListEnumerator }

constructor TFhirManufacturedItemDefinitionListEnumerator.Create(list : TFhirManufacturedItemDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirManufacturedItemDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirManufacturedItemDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirManufacturedItemDefinitionListEnumerator.GetCurrent : TFhirManufacturedItemDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirManufacturedItemDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirManufacturedItemDefinitionList }

function TFhirManufacturedItemDefinitionList.AddItem(value: TFhirManufacturedItemDefinition): TFhirManufacturedItemDefinition;
begin
  assert(value.ClassName = 'TFhirManufacturedItemDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirManufacturedItemDefinition');
  add(value);
  result := value;
end;

function TFhirManufacturedItemDefinitionList.Append: TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirManufacturedItemDefinitionList.GetEnumerator : TFhirManufacturedItemDefinitionListEnumerator;
begin
  result := TFhirManufacturedItemDefinitionListEnumerator.Create(self.link);
end;

function TFhirManufacturedItemDefinitionList.Clone: TFhirManufacturedItemDefinitionList;
begin
  result := TFhirManufacturedItemDefinitionList(inherited Clone);
end;

function TFhirManufacturedItemDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirManufacturedItemDefinitionList.GetItemN(index: Integer): TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirManufacturedItemDefinition;
end;
function TFhirManufacturedItemDefinitionList.IndexOf(value: TFhirManufacturedItemDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirManufacturedItemDefinitionList.Insert(index: Integer): TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirManufacturedItemDefinitionList.InsertItem(index: Integer; value: TFhirManufacturedItemDefinition);
begin
  assert(value is TFhirManufacturedItemDefinition);
  Inherited Insert(index, value);
end;

function TFhirManufacturedItemDefinitionList.Item(index: Integer): TFhirManufacturedItemDefinition;
begin
  result := TFhirManufacturedItemDefinition(ObjectByIndex[index]);
end;

function TFhirManufacturedItemDefinitionList.Link: TFhirManufacturedItemDefinitionList;
begin
  result := TFhirManufacturedItemDefinitionList(inherited Link);
end;

procedure TFhirManufacturedItemDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirManufacturedItemDefinitionList.SetItemByIndex(index: Integer; value: TFhirManufacturedItemDefinition);
begin
  assert(value is TFhirManufacturedItemDefinition);
  FhirManufacturedItemDefinitions[index] := value;
end;

procedure TFhirManufacturedItemDefinitionList.SetItemN(index: Integer; value: TFhirManufacturedItemDefinition);
begin
  assert(value is TFhirManufacturedItemDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MANUFACTUREDITEMDEFINITION}
{$IFDEF FHIR_MEDICATION}
{ TFhirMedicationIngredient }

constructor TFhirMedicationIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationIngredient.Destroy;
begin
  FItem.free;
  FIsActive.free;
  FStrength.free;
  inherited;
end;

procedure TFhirMedicationIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationIngredient(oSource).item.Clone;
  isActiveElement := TFhirMedicationIngredient(oSource).isActiveElement.Clone;
  strength := TFhirMedicationIngredient(oSource).strength.Clone;
end;

procedure TFhirMedicationIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
  if (child_name = 'isActive') Then
     list.add(self.link, 'isActive', FIsActive.Link);
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
end;

procedure TFhirMedicationIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference', false, TFhirDataType, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'isActive', 'boolean', false, TFhirBoolean, FIsActive.Link));
  oList.add(TFHIRProperty.create(self, 'strength', 'Ratio', false, TFhirRatio, FStrength.Link));
end;

function TFhirMedicationIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'isActive') then
  begin
    IsActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    Strength := propValue as TFhirRatio;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item')
  else if (propName = 'isActive') then result := TFhirBoolean.create()
  else if (propName = 'strength') then result := TFhirRatio.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'isActive') then result := 'boolean'
  else if (propName = 'strength') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil
  else if (propName = 'isActive') then IsActiveElement := nil
  else if (propName = 'strength') then StrengthElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirDataType
  else if (propName = 'isActive') then IsActiveElement := asBoolean(new)
  else if (propName = 'strength') then StrengthElement := new as TFhirRatio
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationIngredient.fhirType : string;
begin
  result := 'Medication.ingredient';
end;

function TFhirMedicationIngredient.Link : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Link);
end;

function TFhirMedicationIngredient.Clone : TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(inherited Clone);
end;

function TFhirMedicationIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(isActiveElement, o.isActiveElement, true) and 
      compareDeep(strengthElement, o.strengthElement, true);
  end;
end;

function TFhirMedicationIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FIsActive) and isEmptyProp(FStrength);
end;

procedure TFhirMedicationIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item[x]');
  fields.add('isActive');
  fields.add('strength');
end;

function TFhirMedicationIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationIngredient.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value;
end;

procedure TFhirMedicationIngredient.SetIsActive(value : TFhirBoolean);
begin
  FIsActive.free;
  FIsActive := value;
end;

function TFhirMedicationIngredient.GetIsActiveST : Boolean;
begin
  if FIsActive = nil then
    result := false
  else
    result := FIsActive.value;
end;

procedure TFhirMedicationIngredient.SetIsActiveST(value : Boolean);
begin
  if FIsActive = nil then
    FIsActive := TFhirBoolean.create;
  FIsActive.value := value
end;

procedure TFhirMedicationIngredient.SetStrength(value : TFhirRatio);
begin
  FStrength.free;
  FStrength := value;
end;

{ TFhirMedicationIngredientListEnumerator }

constructor TFhirMedicationIngredientListEnumerator.Create(list : TFhirMedicationIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationIngredientListEnumerator.GetCurrent : TFhirMedicationIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationIngredientList }

function TFhirMedicationIngredientList.AddItem(value: TFhirMedicationIngredient): TFhirMedicationIngredient;
begin
  assert(value.ClassName = 'TFhirMedicationIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationIngredient');
  add(value);
  result := value;
end;

function TFhirMedicationIngredientList.Append: TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationIngredientList.GetEnumerator : TFhirMedicationIngredientListEnumerator;
begin
  result := TFhirMedicationIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationIngredientList.Clone: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Clone);
end;

function TFhirMedicationIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationIngredientList.GetItemN(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationIngredient;
end;
function TFhirMedicationIngredientList.IndexOf(value: TFhirMedicationIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationIngredientList.Insert(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationIngredientList.InsertItem(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationIngredientList.Item(index: Integer): TFhirMedicationIngredient;
begin
  result := TFhirMedicationIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationIngredientList.Link: TFhirMedicationIngredientList;
begin
  result := TFhirMedicationIngredientList(inherited Link);
end;

procedure TFhirMedicationIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  FhirMedicationIngredients[index] := value;
end;

procedure TFhirMedicationIngredientList.SetItemN(index: Integer; value: TFhirMedicationIngredient);
begin
  assert(value is TFhirMedicationIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationBatch }

constructor TFhirMedicationBatch.Create;
begin
  inherited;
end;

destructor TFhirMedicationBatch.Destroy;
begin
  FLotNumber.free;
  FExpirationDate.free;
  inherited;
end;

procedure TFhirMedicationBatch.Assign(oSource : TFslObject);
begin
  inherited;
  lotNumberElement := TFhirMedicationBatch(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirMedicationBatch(oSource).expirationDateElement.Clone;
end;

procedure TFhirMedicationBatch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
end;

procedure TFhirMedicationBatch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link));
end;

function TFhirMedicationBatch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationBatch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationBatch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'lotNumber') then result := TFhirString.create()
  else if (propName = 'expirationDate') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationBatch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationBatch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationBatch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'lotNumber') then LotNumberElement := asString(new)
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationBatch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationBatch.fhirType : string;
begin
  result := 'Medication.batch';
end;

function TFhirMedicationBatch.Link : TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(inherited Link);
end;

function TFhirMedicationBatch.Clone : TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(inherited Clone);
end;

function TFhirMedicationBatch.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationBatch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationBatch)) then
    result := false
  else
  begin
    o := TFhirMedicationBatch(other);
    result := compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expirationDateElement, o.expirationDateElement, true);
  end;
end;

function TFhirMedicationBatch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate);
end;

procedure TFhirMedicationBatch.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('lotNumber');
  fields.add('expirationDate');
end;

function TFhirMedicationBatch.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationBatch.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

function TFhirMedicationBatch.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirMedicationBatch.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirMedicationBatch.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

function TFhirMedicationBatch.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

procedure TFhirMedicationBatch.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.create;
  FExpirationDate.value := value
end;

{ TFhirMedicationBatchListEnumerator }

constructor TFhirMedicationBatchListEnumerator.Create(list : TFhirMedicationBatchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationBatchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationBatchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationBatchListEnumerator.GetCurrent : TFhirMedicationBatch;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationBatchListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationBatchList }

function TFhirMedicationBatchList.AddItem(value: TFhirMedicationBatch): TFhirMedicationBatch;
begin
  assert(value.ClassName = 'TFhirMedicationBatch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationBatch');
  add(value);
  result := value;
end;

function TFhirMedicationBatchList.Append: TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationBatchList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationBatchList.GetEnumerator : TFhirMedicationBatchListEnumerator;
begin
  result := TFhirMedicationBatchListEnumerator.Create(self.link);
end;

function TFhirMedicationBatchList.Clone: TFhirMedicationBatchList;
begin
  result := TFhirMedicationBatchList(inherited Clone);
end;

function TFhirMedicationBatchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationBatchList.GetItemN(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(ObjectByIndex[index]);
end;

function TFhirMedicationBatchList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationBatch;
end;
function TFhirMedicationBatchList.IndexOf(value: TFhirMedicationBatch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationBatchList.Insert(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationBatchList.InsertItem(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  Inherited Insert(index, value);
end;

function TFhirMedicationBatchList.Item(index: Integer): TFhirMedicationBatch;
begin
  result := TFhirMedicationBatch(ObjectByIndex[index]);
end;

function TFhirMedicationBatchList.Link: TFhirMedicationBatchList;
begin
  result := TFhirMedicationBatchList(inherited Link);
end;

procedure TFhirMedicationBatchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationBatchList.SetItemByIndex(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  FhirMedicationBatches[index] := value;
end;

procedure TFhirMedicationBatchList.SetItemN(index: Integer; value: TFhirMedicationBatch);
begin
  assert(value is TFhirMedicationBatch);
  ObjectByIndex[index] := value;
end;

{ TFhirMedication }

constructor TFhirMedication.Create;
begin
  inherited;
end;

destructor TFhirMedication.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FStatus.free;
  FManufacturer.free;
  FForm.free;
  FAmount.free;
  FIngredientList.Free;
  FBatch.free;
  inherited;
end;

procedure TFhirMedication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedication(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedication(oSource).FIdentifierList);
  end;
  code := TFhirMedication(oSource).code.Clone;
  statusElement := TFhirMedication(oSource).statusElement.Clone;
  manufacturer := TFhirMedication(oSource).manufacturer.Clone;
  form := TFhirMedication(oSource).form.Clone;
  amount := TFhirMedication(oSource).amount.Clone;
  if (TFhirMedication(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationIngredientList.Create;
    FIngredientList.Assign(TFhirMedication(oSource).FIngredientList);
  end;
  batch := TFhirMedication(oSource).batch.Clone;
end;

function TFhirMedication.GetResourceType : TFhirResourceType;
begin
  result := frtMedication;
end;

procedure TFhirMedication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'form') Then
     list.add(self.link, 'form', FForm.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'batch') Then
     list.add(self.link, 'batch', FBatch.Link);
end;

procedure TFhirMedication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', false, TFhirReference, FManufacturer.Link));
  oList.add(TFHIRProperty.create(self, 'form', 'CodeableConcept', false, TFhirCodeableConcept, FForm.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', false, TFhirRatio, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirMedicationIngredient, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'batch', 'BackboneElement', false, TFhirMedicationBatch, FBatch.Link));
end;

function TFhirMedication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusCodesEnum, CODES_TFhirMedicationStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'form') then
  begin
    Form := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirRatio;
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationIngredient);
    result := propValue;
  end
  else if (propName = 'batch') then
  begin
    Batch := propValue as TFhirMedicationBatch;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationIngredient)
  else inherited;
end;

function TFhirMedication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusCodesEnum[MedicationStatusCodesNull], CODES_TFhirMedicationStatusCodesEnum[MedicationStatusCodesNull]) 
  else if (propName = 'manufacturer') then result := TFhirReference.create()
  else if (propName = 'form') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirRatio.create()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'batch') then result := TFhirMedicationBatch.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'form') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Ratio'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else if (propName = 'batch') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'form') then FormElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'batch') then BatchElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusCodesEnum, CODES_TFhirMedicationStatusCodesEnum, new)
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference
  else if (propName = 'form') then FormElement := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := new as TFhirRatio
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'batch') then BatchElement := new as TFhirMedicationBatch
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedication.fhirType : string;
begin
  result := 'Medication';
end;

function TFhirMedication.Link : TFhirMedication;
begin
  result := TFhirMedication(inherited Link);
end;

function TFhirMedication.Clone : TFhirMedication;
begin
  result := TFhirMedication(inherited Clone);
end;

function TFhirMedication.equals(other : TObject) : boolean; 
var
  o : TFhirMedication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedication)) then
    result := false
  else
  begin
    o := TFhirMedication(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(manufacturerElement, o.manufacturerElement, true) and 
      compareDeep(formElement, o.formElement, true) and compareDeep(amountElement, o.amountElement, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(batchElement, o.batchElement, true);
  end;
end;

function TFhirMedication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FManufacturer) and isEmptyProp(FForm) and isEmptyProp(FAmount) and isEmptyProp(FingredientList) and isEmptyProp(FBatch);
end;

procedure TFhirMedication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('status');
  fields.add('manufacturer');
  fields.add('form');
  fields.add('amount');
  fields.add('ingredient');
  fields.add('batch');
end;

function TFhirMedication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
end;

function TFhirMedication.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedication.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedication.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMedication.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedication.GetStatusST : TFhirMedicationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationStatusCodesEnum(0)
  else
    result := TFhirMedicationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedication.SetStatusST(value : TFhirMedicationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusCodesEnum[value], CODES_TFhirMedicationStatusCodesEnum[value]);
end;

procedure TFhirMedication.SetManufacturer(value : TFhirReference);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

procedure TFhirMedication.SetForm(value : TFhirCodeableConcept);
begin
  FForm.free;
  FForm := value;
end;

procedure TFhirMedication.SetAmount(value : TFhirRatio);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirMedication.GetIngredientList : TFhirMedicationIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationIngredientList.Create;
  result := FIngredientList;
end;

function TFhirMedication.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

procedure TFhirMedication.SetBatch(value : TFhirMedicationBatch);
begin
  FBatch.free;
  FBatch := value;
end;

{ TFhirMedicationListEnumerator }

constructor TFhirMedicationListEnumerator.Create(list : TFhirMedicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationListEnumerator.GetCurrent : TFhirMedication;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationList }

function TFhirMedicationList.AddItem(value: TFhirMedication): TFhirMedication;
begin
  assert(value.ClassName = 'TFhirMedication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedication');
  add(value);
  result := value;
end;

function TFhirMedicationList.Append: TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationList.GetEnumerator : TFhirMedicationListEnumerator;
begin
  result := TFhirMedicationListEnumerator.Create(self.link);
end;

function TFhirMedicationList.Clone: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Clone);
end;

function TFhirMedicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationList.GetItemN(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedication;
end;
function TFhirMedicationList.IndexOf(value: TFhirMedication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationList.Insert(index: Integer): TFhirMedication;
begin
  result := TFhirMedication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationList.InsertItem(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  Inherited Insert(index, value);
end;

function TFhirMedicationList.Item(index: Integer): TFhirMedication;
begin
  result := TFhirMedication(ObjectByIndex[index]);
end;

function TFhirMedicationList.Link: TFhirMedicationList;
begin
  result := TFhirMedicationList(inherited Link);
end;

procedure TFhirMedicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationList.SetItemByIndex(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  FhirMedications[index] := value;
end;

procedure TFhirMedicationList.SetItemN(index: Integer; value: TFhirMedication);
begin
  assert(value is TFhirMedication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATION}
{$IFDEF FHIR_MEDICATIONKNOWLEDGE}
{ TFhirMedicationKnowledgeRelatedMedicationKnowledge }

constructor TFhirMedicationKnowledgeRelatedMedicationKnowledge.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRelatedMedicationKnowledge.Destroy;
begin
  FType_.free;
  FReferenceList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList.Create;
    FReferenceList.Assign(TFhirMedicationKnowledgeRelatedMedicationKnowledge(oSource).FReferenceList);
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', true, TFhirReference, FReferenceList.Link));
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'reference') then result := ReferenceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.fhirType : string;
begin
  result := 'MedicationKnowledge.relatedMedicationKnowledge';
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.Link : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(inherited Link);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.Clone : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(inherited Clone);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRelatedMedicationKnowledge)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRelatedMedicationKnowledge(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(referenceList, o.referenceList, true);
  end;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FreferenceList);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('reference');
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FReferenceList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledge.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetReferenceList : TFhirReferenceList;
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList.Create;
  result := FReferenceList;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledge.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

{ TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator }

constructor TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Create(list : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.GetCurrent : TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeRelatedMedicationKnowledgeList }

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.AddItem(value: TFhirMedicationKnowledgeRelatedMedicationKnowledge): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRelatedMedicationKnowledge', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRelatedMedicationKnowledge');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Append: TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.GetEnumerator : TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Clone: TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList(inherited Clone);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.GetItemN(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge;
end;
function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.IndexOf(value: TFhirMedicationKnowledgeRelatedMedicationKnowledge): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Insert(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Item(index: Integer): TFhirMedicationKnowledgeRelatedMedicationKnowledge;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Link: TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  FhirMedicationKnowledgeRelatedMedicationKnowledges[index] := value;
end;

procedure TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRelatedMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledgeRelatedMedicationKnowledge);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMonograph }

constructor TFhirMedicationKnowledgeMonograph.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMonograph.Destroy;
begin
  FType_.free;
  FSource.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMonograph.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMonograph(oSource).type_.Clone;
  source := TFhirMedicationKnowledgeMonograph(oSource).source.Clone;
end;

procedure TFhirMedicationKnowledgeMonograph.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
end;

procedure TFhirMedicationKnowledgeMonograph.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
end;

function TFhirMedicationKnowledgeMonograph.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMonograph.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeMonograph.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMonograph.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMonograph.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMonograph.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMonograph.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMonograph.fhirType : string;
begin
  result := 'MedicationKnowledge.monograph';
end;

function TFhirMedicationKnowledgeMonograph.Link : TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(inherited Link);
end;

function TFhirMedicationKnowledgeMonograph.Clone : TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(inherited Clone);
end;

function TFhirMedicationKnowledgeMonograph.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMonograph;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMonograph)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMonograph(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(sourceElement, o.sourceElement, true);
  end;
end;

function TFhirMedicationKnowledgeMonograph.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSource);
end;

procedure TFhirMedicationKnowledgeMonograph.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('source');
end;

function TFhirMedicationKnowledgeMonograph.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeMonograph.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeMonograph.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

{ TFhirMedicationKnowledgeMonographListEnumerator }

constructor TFhirMedicationKnowledgeMonographListEnumerator.Create(list : TFhirMedicationKnowledgeMonographList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMonographListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMonographListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMonographListEnumerator.GetCurrent : TFhirMedicationKnowledgeMonograph;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMonographListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeMonographList }

function TFhirMedicationKnowledgeMonographList.AddItem(value: TFhirMedicationKnowledgeMonograph): TFhirMedicationKnowledgeMonograph;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMonograph', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMonograph');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeMonographList.Append: TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonographList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMonographList.GetEnumerator : TFhirMedicationKnowledgeMonographListEnumerator;
begin
  result := TFhirMedicationKnowledgeMonographListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMonographList.Clone: TFhirMedicationKnowledgeMonographList;
begin
  result := TFhirMedicationKnowledgeMonographList(inherited Clone);
end;

function TFhirMedicationKnowledgeMonographList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMonographList.GetItemN(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonographList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMonograph;
end;
function TFhirMedicationKnowledgeMonographList.IndexOf(value: TFhirMedicationKnowledgeMonograph): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMonographList.Insert(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonographList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMonographList.Item(index: Integer): TFhirMedicationKnowledgeMonograph;
begin
  result := TFhirMedicationKnowledgeMonograph(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonographList.Link: TFhirMedicationKnowledgeMonographList;
begin
  result := TFhirMedicationKnowledgeMonographList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMonographList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMonographList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  FhirMedicationKnowledgeMonographs[index] := value;
end;

procedure TFhirMedicationKnowledgeMonographList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMonograph);
begin
  assert(value is TFhirMedicationKnowledgeMonograph);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeIngredient }

constructor TFhirMedicationKnowledgeIngredient.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeIngredient.Destroy;
begin
  FItem.free;
  FIsActive.free;
  FStrength.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirMedicationKnowledgeIngredient(oSource).item.Clone;
  isActiveElement := TFhirMedicationKnowledgeIngredient(oSource).isActiveElement.Clone;
  strength := TFhirMedicationKnowledgeIngredient(oSource).strength.Clone;
end;

procedure TFhirMedicationKnowledgeIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
  if (child_name = 'isActive') Then
     list.add(self.link, 'isActive', FIsActive.Link);
  if (child_name = 'strength') Then
     list.add(self.link, 'strength', FStrength.Link);
end;

procedure TFhirMedicationKnowledgeIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference', false, TFhirDataType, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'isActive', 'boolean', false, TFhirBoolean, FIsActive.Link));
  oList.add(TFHIRProperty.create(self, 'strength', 'Ratio', false, TFhirRatio, FStrength.Link));
end;

function TFhirMedicationKnowledgeIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'isActive') then
  begin
    IsActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'strength') then
  begin
    Strength := propValue as TFhirRatio;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item')
  else if (propName = 'isActive') then result := TFhirBoolean.create()
  else if (propName = 'strength') then result := TFhirRatio.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'isActive') then result := 'boolean'
  else if (propName = 'strength') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil
  else if (propName = 'isActive') then IsActiveElement := nil
  else if (propName = 'strength') then StrengthElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirDataType
  else if (propName = 'isActive') then IsActiveElement := asBoolean(new)
  else if (propName = 'strength') then StrengthElement := new as TFhirRatio
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeIngredient.fhirType : string;
begin
  result := 'MedicationKnowledge.ingredient';
end;

function TFhirMedicationKnowledgeIngredient.Link : TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(inherited Link);
end;

function TFhirMedicationKnowledgeIngredient.Clone : TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(inherited Clone);
end;

function TFhirMedicationKnowledgeIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeIngredient)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(isActiveElement, o.isActiveElement, true) and 
      compareDeep(strengthElement, o.strengthElement, true);
  end;
end;

function TFhirMedicationKnowledgeIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FIsActive) and isEmptyProp(FStrength);
end;

procedure TFhirMedicationKnowledgeIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item[x]');
  fields.add('isActive');
  fields.add('strength');
end;

function TFhirMedicationKnowledgeIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeIngredient.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value;
end;

procedure TFhirMedicationKnowledgeIngredient.SetIsActive(value : TFhirBoolean);
begin
  FIsActive.free;
  FIsActive := value;
end;

function TFhirMedicationKnowledgeIngredient.GetIsActiveST : Boolean;
begin
  if FIsActive = nil then
    result := false
  else
    result := FIsActive.value;
end;

procedure TFhirMedicationKnowledgeIngredient.SetIsActiveST(value : Boolean);
begin
  if FIsActive = nil then
    FIsActive := TFhirBoolean.create;
  FIsActive.value := value
end;

procedure TFhirMedicationKnowledgeIngredient.SetStrength(value : TFhirRatio);
begin
  FStrength.free;
  FStrength := value;
end;

{ TFhirMedicationKnowledgeIngredientListEnumerator }

constructor TFhirMedicationKnowledgeIngredientListEnumerator.Create(list : TFhirMedicationKnowledgeIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeIngredientListEnumerator.GetCurrent : TFhirMedicationKnowledgeIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeIngredientList }

function TFhirMedicationKnowledgeIngredientList.AddItem(value: TFhirMedicationKnowledgeIngredient): TFhirMedicationKnowledgeIngredient;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeIngredient');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeIngredientList.Append: TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeIngredientList.GetEnumerator : TFhirMedicationKnowledgeIngredientListEnumerator;
begin
  result := TFhirMedicationKnowledgeIngredientListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeIngredientList.Clone: TFhirMedicationKnowledgeIngredientList;
begin
  result := TFhirMedicationKnowledgeIngredientList(inherited Clone);
end;

function TFhirMedicationKnowledgeIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeIngredientList.GetItemN(index: Integer): TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeIngredient;
end;
function TFhirMedicationKnowledgeIngredientList.IndexOf(value: TFhirMedicationKnowledgeIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeIngredientList.Insert(index: Integer): TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeIngredientList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value is TFhirMedicationKnowledgeIngredient);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeIngredientList.Item(index: Integer): TFhirMedicationKnowledgeIngredient;
begin
  result := TFhirMedicationKnowledgeIngredient(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeIngredientList.Link: TFhirMedicationKnowledgeIngredientList;
begin
  result := TFhirMedicationKnowledgeIngredientList(inherited Link);
end;

procedure TFhirMedicationKnowledgeIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeIngredientList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value is TFhirMedicationKnowledgeIngredient);
  FhirMedicationKnowledgeIngredients[index] := value;
end;

procedure TFhirMedicationKnowledgeIngredientList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeIngredient);
begin
  assert(value is TFhirMedicationKnowledgeIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeCost }

constructor TFhirMedicationKnowledgeCost.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeCost.Destroy;
begin
  FType_.free;
  FSource.free;
  FCost.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeCost.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeCost(oSource).type_.Clone;
  sourceElement := TFhirMedicationKnowledgeCost(oSource).sourceElement.Clone;
  cost := TFhirMedicationKnowledgeCost(oSource).cost.Clone;
end;

procedure TFhirMedicationKnowledgeCost.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'cost') Then
     list.add(self.link, 'cost', FCost.Link);
end;

procedure TFhirMedicationKnowledgeCost.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'string', false, TFhirString, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'cost', 'Money', false, TFhirMoney, FCost.Link));
end;

function TFhirMedicationKnowledgeCost.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    Cost := propValue as TFhirMoney;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeCost.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeCost.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := TFhirString.create()
  else if (propName = 'cost') then result := TFhirMoney.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeCost.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'string'
  else if (propName = 'cost') then result := 'Money'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeCost.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'cost') then CostElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeCost.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'source') then SourceElement := asString(new)
  else if (propName = 'cost') then CostElement := new as TFhirMoney
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeCost.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeCost.fhirType : string;
begin
  result := 'MedicationKnowledge.cost';
end;

function TFhirMedicationKnowledgeCost.Link : TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(inherited Link);
end;

function TFhirMedicationKnowledgeCost.Clone : TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(inherited Clone);
end;

function TFhirMedicationKnowledgeCost.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeCost;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeCost)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeCost(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(costElement, o.costElement, true);
  end;
end;

function TFhirMedicationKnowledgeCost.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSource) and isEmptyProp(FCost);
end;

procedure TFhirMedicationKnowledgeCost.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('source');
  fields.add('cost');
end;

function TFhirMedicationKnowledgeCost.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeCost.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeCost.SetSource(value : TFhirString);
begin
  FSource.free;
  FSource := value;
end;

function TFhirMedicationKnowledgeCost.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

procedure TFhirMedicationKnowledgeCost.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirString.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

procedure TFhirMedicationKnowledgeCost.SetCost(value : TFhirMoney);
begin
  FCost.free;
  FCost := value;
end;

{ TFhirMedicationKnowledgeCostListEnumerator }

constructor TFhirMedicationKnowledgeCostListEnumerator.Create(list : TFhirMedicationKnowledgeCostList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeCostListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeCostListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeCostListEnumerator.GetCurrent : TFhirMedicationKnowledgeCost;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeCostListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeCostList }

function TFhirMedicationKnowledgeCostList.AddItem(value: TFhirMedicationKnowledgeCost): TFhirMedicationKnowledgeCost;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeCost', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeCost');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeCostList.Append: TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeCostList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeCostList.GetEnumerator : TFhirMedicationKnowledgeCostListEnumerator;
begin
  result := TFhirMedicationKnowledgeCostListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeCostList.Clone: TFhirMedicationKnowledgeCostList;
begin
  result := TFhirMedicationKnowledgeCostList(inherited Clone);
end;

function TFhirMedicationKnowledgeCostList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeCostList.GetItemN(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeCostList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeCost;
end;
function TFhirMedicationKnowledgeCostList.IndexOf(value: TFhirMedicationKnowledgeCost): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeCostList.Insert(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeCostList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeCostList.Item(index: Integer): TFhirMedicationKnowledgeCost;
begin
  result := TFhirMedicationKnowledgeCost(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeCostList.Link: TFhirMedicationKnowledgeCostList;
begin
  result := TFhirMedicationKnowledgeCostList(inherited Link);
end;

procedure TFhirMedicationKnowledgeCostList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeCostList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  FhirMedicationKnowledgeCosts[index] := value;
end;

procedure TFhirMedicationKnowledgeCostList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeCost);
begin
  assert(value is TFhirMedicationKnowledgeCost);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMonitoringProgram }

constructor TFhirMedicationKnowledgeMonitoringProgram.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMonitoringProgram.Destroy;
begin
  FType_.free;
  FName.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMonitoringProgram(oSource).type_.Clone;
  nameElement := TFhirMedicationKnowledgeMonitoringProgram(oSource).nameElement.Clone;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
end;

function TFhirMedicationKnowledgeMonitoringProgram.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeMonitoringProgram.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'name') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMonitoringProgram.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'name') then NameElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'name') then NameElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMonitoringProgram.fhirType : string;
begin
  result := 'MedicationKnowledge.monitoringProgram';
end;

function TFhirMedicationKnowledgeMonitoringProgram.Link : TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(inherited Link);
end;

function TFhirMedicationKnowledgeMonitoringProgram.Clone : TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(inherited Clone);
end;

function TFhirMedicationKnowledgeMonitoringProgram.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMonitoringProgram;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMonitoringProgram)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMonitoringProgram(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(nameElement, o.nameElement, true);
  end;
end;

function TFhirMedicationKnowledgeMonitoringProgram.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FName);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('name');
end;

function TFhirMedicationKnowledgeMonitoringProgram.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirMedicationKnowledgeMonitoringProgram.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMedicationKnowledgeMonitoringProgram.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

{ TFhirMedicationKnowledgeMonitoringProgramListEnumerator }

constructor TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Create(list : TFhirMedicationKnowledgeMonitoringProgramList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.GetCurrent : TFhirMedicationKnowledgeMonitoringProgram;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMonitoringProgramListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeMonitoringProgramList }

function TFhirMedicationKnowledgeMonitoringProgramList.AddItem(value: TFhirMedicationKnowledgeMonitoringProgram): TFhirMedicationKnowledgeMonitoringProgram;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMonitoringProgram', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMonitoringProgram');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Append: TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.GetEnumerator : TFhirMedicationKnowledgeMonitoringProgramListEnumerator;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Clone: TFhirMedicationKnowledgeMonitoringProgramList;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramList(inherited Clone);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMonitoringProgramList.GetItemN(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram;
end;
function TFhirMedicationKnowledgeMonitoringProgramList.IndexOf(value: TFhirMedicationKnowledgeMonitoringProgram): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Insert(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Item(index: Integer): TFhirMedicationKnowledgeMonitoringProgram;
begin
  result := TFhirMedicationKnowledgeMonitoringProgram(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMonitoringProgramList.Link: TFhirMedicationKnowledgeMonitoringProgramList;
begin
  result := TFhirMedicationKnowledgeMonitoringProgramList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  FhirMedicationKnowledgeMonitoringPrograms[index] := value;
end;

procedure TFhirMedicationKnowledgeMonitoringProgramList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMonitoringProgram);
begin
  assert(value is TFhirMedicationKnowledgeMonitoringProgram);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeAdministrationGuidelines }

constructor TFhirMedicationKnowledgeAdministrationGuidelines.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelines.Destroy;
begin
  FDosageList.Free;
  FIndication.free;
  FPatientCharacteristicsList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgeAdministrationGuidelines(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Create;
    FDosageList.Assign(TFhirMedicationKnowledgeAdministrationGuidelines(oSource).FDosageList);
  end;
  indication := TFhirMedicationKnowledgeAdministrationGuidelines(oSource).indication.Clone;
  if (TFhirMedicationKnowledgeAdministrationGuidelines(oSource).FPatientCharacteristicsList = nil) then
  begin
    FPatientCharacteristicsList.free;
    FPatientCharacteristicsList := nil;
  end
  else
  begin
    if FPatientCharacteristicsList = nil then
      FPatientCharacteristicsList := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Create;
    FPatientCharacteristicsList.Assign(TFhirMedicationKnowledgeAdministrationGuidelines(oSource).FPatientCharacteristicsList);
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
  if (child_name = 'indication[x]') or (child_name = 'indication') Then
     list.add(self.link, 'indication[x]', FIndication.Link);
  if (child_name = 'patientCharacteristics') Then
    list.addAll(self, 'patientCharacteristics', FPatientCharacteristicsList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'dosage', 'BackboneElement', true, TFhirMedicationKnowledgeAdministrationGuidelinesDosage, FDosageList.Link));
  oList.add(TFHIRProperty.create(self, 'indication[x]', 'CodeableConcept|Reference', false, TFhirDataType, FIndication.Link));
  oList.add(TFHIRProperty.create(self, 'patientCharacteristics', 'BackboneElement', true, TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics, FPatientCharacteristicsList.Link));
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
    result := propValue;
  end
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then
  begin
    Indication := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'patientCharacteristics') then
  begin
    PatientCharacteristicsList.add(propValue as TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirMedicationKnowledgeAdministrationGuidelinesDosage)
  else if (propName = 'patientCharacteristics') then PatientCharacteristicsList.insertItem(index, propValue as TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics)
  else inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'dosage') then result := DosageList.new()
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Indication')
  else if (propName = 'patientCharacteristics') then result := PatientCharacteristicsList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'dosage') then result := 'BackboneElement'
  else if (propName = 'indication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'patientCharacteristics') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value)
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then IndicationElement := nil
  else if (propName = 'patientCharacteristics') then deletePropertyValue('patientCharacteristics', PatientCharacteristicsList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new)
  else if (isMatchingName(propName, 'indication', ['CodeableConcept', 'Reference'])) then IndicationElement := new as TFhirDataType
  else if (propName = 'patientCharacteristics') then replacePropertyValue('patientCharacteristics', PatientCharacteristicsList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dosage') then DosageList.move(source, destination)
  else if (propName = 'patientCharacteristics') then PatientCharacteristicsList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.fhirType : string;
begin
  result := 'MedicationKnowledge.administrationGuidelines';
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.Link : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines(inherited Link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.Clone : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeAdministrationGuidelines)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeAdministrationGuidelines(other);
    result := compareDeep(dosageList, o.dosageList, true) and compareDeep(indicationElement, o.indicationElement, true) and 
      compareDeep(patientCharacteristicsList, o.patientCharacteristicsList, true);
  end;
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FdosageList) and isEmptyProp(FIndication) and isEmptyProp(FpatientCharacteristicsList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('dosage');
  fields.add('indication[x]');
  fields.add('patientCharacteristics');
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDosageList.sizeInBytes(magic));
  inc(result, FPatientCharacteristicsList.sizeInBytes(magic));
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.GetDosageList : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Create;
  result := FDosageList;
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelines.SetIndication(value : TFhirDataType);
begin
  FIndication.free;
  FIndication := value;
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.GetPatientCharacteristicsList : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
begin
  if FPatientCharacteristicsList = nil then
    FPatientCharacteristicsList := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Create;
  result := FPatientCharacteristicsList;
end;

function TFhirMedicationKnowledgeAdministrationGuidelines.GetHasPatientCharacteristicsList : boolean;
begin
  result := (FPatientCharacteristicsList <> nil) and (FPatientCharacteristicsList.count > 0);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator }

constructor TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesList }

function TFhirMedicationKnowledgeAdministrationGuidelinesList.AddItem(value: TFhirMedicationKnowledgeAdministrationGuidelines): TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeAdministrationGuidelines', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeAdministrationGuidelines');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Append: TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Clone: TFhirMedicationKnowledgeAdministrationGuidelinesList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesList(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.GetItemN(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines;
end;
function TFhirMedicationKnowledgeAdministrationGuidelinesList.IndexOf(value: TFhirMedicationKnowledgeAdministrationGuidelines): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Insert(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelines);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelines);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Item(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelines;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelines(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesList.Link: TFhirMedicationKnowledgeAdministrationGuidelinesList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesList(inherited Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelines);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelines);
  FhirMedicationKnowledgeAdministrationGuidelines[index] := value;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelines);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelines);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesDosage }

constructor TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Destroy;
begin
  FType_.free;
  FDosageList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeAdministrationGuidelinesDosage(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirMedicationKnowledgeAdministrationGuidelinesDosage(oSource).FDosageList);
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link));
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage)
  else inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'dosage') then result := DosageList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'dosage') then result := 'Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dosage') then DosageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.fhirType : string;
begin
  result := 'MedicationKnowledge.administrationGuidelines.dosage';
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Link : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(inherited Link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.Clone : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeAdministrationGuidelinesDosage)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(dosageList, o.dosageList, true);
  end;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FdosageList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('dosage');
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDosageList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosage.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator }

constructor TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesDosageList }

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.AddItem(value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage): TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeAdministrationGuidelinesDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeAdministrationGuidelinesDosage');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Append: TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Clone: TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosageList(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.GetItemN(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
end;
function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.IndexOf(value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Insert(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Item(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesDosage;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosage(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Link: TFhirMedicationKnowledgeAdministrationGuidelinesDosageList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesDosageList(inherited Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
  FhirMedicationKnowledgeAdministrationGuidelinesDosages[index] := value;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesDosageList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics }

constructor TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Destroy;
begin
  FCharacteristic.free;
  FValueList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Assign(oSource : TFslObject);
begin
  inherited;
  characteristic := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(oSource).characteristic.Clone;
  if (TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(oSource).FValueList = nil) then
  begin
    FValueList.free;
    FValueList := nil;
  end
  else
  begin
    if FValueList = nil then
      FValueList := TFhirStringList.Create;
    FValueList.Assign(TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(oSource).FValueList);
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'characteristic[x]') or (child_name = 'characteristic') Then
     list.add(self.link, 'characteristic[x]', FCharacteristic.Link);
  if (child_name = 'value') Then
    list.addAll(self, 'value', FValueList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'characteristic[x]', 'CodeableConcept|Quantity', false, TFhirDataType, FCharacteristic.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'string', true, TFhirString, FValueList.Link));
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'characteristic', ['CodeableConcept', 'Quantity'])) then
  begin
    Characteristic := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'value') then ValueList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'characteristic', ['CodeableConcept', 'Quantity'])) then raise EFHIRException.create('Cannot make property Characteristic')
  else if (propName = 'value') then result := ValueList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'characteristic[x]') then result := 'CodeableConcept|Quantity'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'characteristic', ['CodeableConcept', 'Quantity'])) then CharacteristicElement := nil
  else if (propName = 'value') then deletePropertyValue('value', ValueList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'characteristic', ['CodeableConcept', 'Quantity'])) then CharacteristicElement := new as TFhirDataType
  else if (propName = 'value') then replacePropertyValue('value', ValueList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'value') then ValueList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.fhirType : string;
begin
  result := 'MedicationKnowledge.administrationGuidelines.patientCharacteristics';
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Link : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(inherited Link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.Clone : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(other);
    result := compareDeep(characteristicElement, o.characteristicElement, true) and 
      compareDeep(valueList, o.valueList, true);
  end;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCharacteristic) and isEmptyProp(FvalueList);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('characteristic[x]');
  fields.add('value');
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FValueList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.SetCharacteristic(value : TFhirDataType);
begin
  FCharacteristic.free;
  FCharacteristic := value;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.GetValueList : TFhirStringList;
begin
  if FValueList = nil then
    FValueList := TFhirStringList.Create;
  result := FValueList;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.GetHasValueList : boolean;
begin
  result := (FValueList <> nil) and (FValueList.count > 0);
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator }

constructor TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.Create(list : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.GetCurrent : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList }

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.AddItem(value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics): TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Append: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.GetEnumerator : TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Clone: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList(inherited Clone);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.GetItemN(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
end;
function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.IndexOf(value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Insert(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Item(index: Integer): TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Link: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList;
begin
  result := TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList(inherited Link);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
  FhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics[index] := value;
end;

procedure TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristicsList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
begin
  assert(value is TFhirMedicationKnowledgeAdministrationGuidelinesPatientCharacteristics);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeMedicineClassification }

constructor TFhirMedicationKnowledgeMedicineClassification.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeMedicineClassification.Destroy;
begin
  FType_.free;
  FClassificationList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledgeMedicineClassification.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeMedicineClassification(oSource).type_.Clone;
  if (TFhirMedicationKnowledgeMedicineClassification(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirMedicationKnowledgeMedicineClassification(oSource).FClassificationList);
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link));
end;

function TFhirMedicationKnowledgeMedicineClassification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirMedicationKnowledgeMedicineClassification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'classification') then result := ClassificationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeMedicineClassification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'classification') then ClassificationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeMedicineClassification.fhirType : string;
begin
  result := 'MedicationKnowledge.medicineClassification';
end;

function TFhirMedicationKnowledgeMedicineClassification.Link : TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(inherited Link);
end;

function TFhirMedicationKnowledgeMedicineClassification.Clone : TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(inherited Clone);
end;

function TFhirMedicationKnowledgeMedicineClassification.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeMedicineClassification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeMedicineClassification)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeMedicineClassification(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(classificationList, o.classificationList, true);
  end;
end;

function TFhirMedicationKnowledgeMedicineClassification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FclassificationList);
end;

procedure TFhirMedicationKnowledgeMedicineClassification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('classification');
end;

function TFhirMedicationKnowledgeMedicineClassification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FClassificationList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeMedicineClassification.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMedicationKnowledgeMedicineClassification.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirMedicationKnowledgeMedicineClassification.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

{ TFhirMedicationKnowledgeMedicineClassificationListEnumerator }

constructor TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Create(list : TFhirMedicationKnowledgeMedicineClassificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.GetCurrent : TFhirMedicationKnowledgeMedicineClassification;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeMedicineClassificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeMedicineClassificationList }

function TFhirMedicationKnowledgeMedicineClassificationList.AddItem(value: TFhirMedicationKnowledgeMedicineClassification): TFhirMedicationKnowledgeMedicineClassification;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeMedicineClassification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeMedicineClassification');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Append: TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.GetEnumerator : TFhirMedicationKnowledgeMedicineClassificationListEnumerator;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Clone: TFhirMedicationKnowledgeMedicineClassificationList;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationList(inherited Clone);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeMedicineClassificationList.GetItemN(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeMedicineClassification;
end;
function TFhirMedicationKnowledgeMedicineClassificationList.IndexOf(value: TFhirMedicationKnowledgeMedicineClassification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Insert(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Item(index: Integer): TFhirMedicationKnowledgeMedicineClassification;
begin
  result := TFhirMedicationKnowledgeMedicineClassification(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeMedicineClassificationList.Link: TFhirMedicationKnowledgeMedicineClassificationList;
begin
  result := TFhirMedicationKnowledgeMedicineClassificationList(inherited Link);
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  FhirMedicationKnowledgeMedicineClassifications[index] := value;
end;

procedure TFhirMedicationKnowledgeMedicineClassificationList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeMedicineClassification);
begin
  assert(value is TFhirMedicationKnowledgeMedicineClassification);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgePackaging }

constructor TFhirMedicationKnowledgePackaging.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgePackaging.Destroy;
begin
  FType_.free;
  FQuantity.free;
  inherited;
end;

procedure TFhirMedicationKnowledgePackaging.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgePackaging(oSource).type_.Clone;
  quantity := TFhirMedicationKnowledgePackaging(oSource).quantity.Clone;
end;

procedure TFhirMedicationKnowledgePackaging.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
end;

procedure TFhirMedicationKnowledgePackaging.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
end;

function TFhirMedicationKnowledgePackaging.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgePackaging.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgePackaging.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgePackaging.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgePackaging.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgePackaging.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgePackaging.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgePackaging.fhirType : string;
begin
  result := 'MedicationKnowledge.packaging';
end;

function TFhirMedicationKnowledgePackaging.Link : TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(inherited Link);
end;

function TFhirMedicationKnowledgePackaging.Clone : TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(inherited Clone);
end;

function TFhirMedicationKnowledgePackaging.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgePackaging;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgePackaging)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgePackaging(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(quantityElement, o.quantityElement, true);
  end;
end;

function TFhirMedicationKnowledgePackaging.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FQuantity);
end;

procedure TFhirMedicationKnowledgePackaging.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('quantity');
end;

function TFhirMedicationKnowledgePackaging.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgePackaging.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgePackaging.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

{ TFhirMedicationKnowledgePackagingListEnumerator }

constructor TFhirMedicationKnowledgePackagingListEnumerator.Create(list : TFhirMedicationKnowledgePackagingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgePackagingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgePackagingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgePackagingListEnumerator.GetCurrent : TFhirMedicationKnowledgePackaging;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgePackagingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgePackagingList }

function TFhirMedicationKnowledgePackagingList.AddItem(value: TFhirMedicationKnowledgePackaging): TFhirMedicationKnowledgePackaging;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgePackaging', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgePackaging');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgePackagingList.Append: TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgePackagingList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgePackagingList.GetEnumerator : TFhirMedicationKnowledgePackagingListEnumerator;
begin
  result := TFhirMedicationKnowledgePackagingListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgePackagingList.Clone: TFhirMedicationKnowledgePackagingList;
begin
  result := TFhirMedicationKnowledgePackagingList(inherited Clone);
end;

function TFhirMedicationKnowledgePackagingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgePackagingList.GetItemN(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgePackagingList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgePackaging;
end;
function TFhirMedicationKnowledgePackagingList.IndexOf(value: TFhirMedicationKnowledgePackaging): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgePackagingList.Insert(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgePackagingList.InsertItem(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgePackagingList.Item(index: Integer): TFhirMedicationKnowledgePackaging;
begin
  result := TFhirMedicationKnowledgePackaging(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgePackagingList.Link: TFhirMedicationKnowledgePackagingList;
begin
  result := TFhirMedicationKnowledgePackagingList(inherited Link);
end;

procedure TFhirMedicationKnowledgePackagingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgePackagingList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  FhirMedicationKnowledgePackagings[index] := value;
end;

procedure TFhirMedicationKnowledgePackagingList.SetItemN(index: Integer; value: TFhirMedicationKnowledgePackaging);
begin
  assert(value is TFhirMedicationKnowledgePackaging);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeDrugCharacteristic }

constructor TFhirMedicationKnowledgeDrugCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeDrugCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeDrugCharacteristic(oSource).type_.Clone;
  value := TFhirMedicationKnowledgeDrugCharacteristic(oSource).value.Clone;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|string|Quantity|base64Binary', false, TFhirDataType, FValue.Link));
end;

function TFhirMedicationKnowledgeDrugCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeDrugCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|string|Quantity|base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.fhirType : string;
begin
  result := 'MedicationKnowledge.drugCharacteristic';
end;

function TFhirMedicationKnowledgeDrugCharacteristic.Link : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(inherited Link);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.Clone : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(inherited Clone);
end;

function TFhirMedicationKnowledgeDrugCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeDrugCharacteristic)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeDrugCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicationKnowledgeDrugCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirMedicationKnowledgeDrugCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirMedicationKnowledgeDrugCharacteristicListEnumerator }

constructor TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.Create(list : TFhirMedicationKnowledgeDrugCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.GetCurrent : TFhirMedicationKnowledgeDrugCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeDrugCharacteristicList }

function TFhirMedicationKnowledgeDrugCharacteristicList.AddItem(value: TFhirMedicationKnowledgeDrugCharacteristic): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeDrugCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeDrugCharacteristic');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Append: TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.GetEnumerator : TFhirMedicationKnowledgeDrugCharacteristicListEnumerator;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristicListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Clone: TFhirMedicationKnowledgeDrugCharacteristicList;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristicList(inherited Clone);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.GetItemN(index: Integer): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic;
end;
function TFhirMedicationKnowledgeDrugCharacteristicList.IndexOf(value: TFhirMedicationKnowledgeDrugCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Insert(index: Integer): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDrugCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Item(index: Integer): TFhirMedicationKnowledgeDrugCharacteristic;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeDrugCharacteristicList.Link: TFhirMedicationKnowledgeDrugCharacteristicList;
begin
  result := TFhirMedicationKnowledgeDrugCharacteristicList(inherited Link);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDrugCharacteristic);
  FhirMedicationKnowledgeDrugCharacteristics[index] := value;
end;

procedure TFhirMedicationKnowledgeDrugCharacteristicList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeDrugCharacteristic);
begin
  assert(value is TFhirMedicationKnowledgeDrugCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatory }

constructor TFhirMedicationKnowledgeRegulatory.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatory.Destroy;
begin
  FRegulatoryAuthority.free;
  FSubstitutionList.Free;
  FScheduleList.Free;
  FMaxDispense.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatory.Assign(oSource : TFslObject);
begin
  inherited;
  regulatoryAuthority := TFhirMedicationKnowledgeRegulatory(oSource).regulatoryAuthority.Clone;
  if (TFhirMedicationKnowledgeRegulatory(oSource).FSubstitutionList = nil) then
  begin
    FSubstitutionList.free;
    FSubstitutionList := nil;
  end
  else
  begin
    if FSubstitutionList = nil then
      FSubstitutionList := TFhirMedicationKnowledgeRegulatorySubstitutionList.Create;
    FSubstitutionList.Assign(TFhirMedicationKnowledgeRegulatory(oSource).FSubstitutionList);
  end;
  if (TFhirMedicationKnowledgeRegulatory(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirMedicationKnowledgeRegulatoryScheduleList.Create;
    FScheduleList.Assign(TFhirMedicationKnowledgeRegulatory(oSource).FScheduleList);
  end;
  maxDispense := TFhirMedicationKnowledgeRegulatory(oSource).maxDispense.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'regulatoryAuthority') Then
     list.add(self.link, 'regulatoryAuthority', FRegulatoryAuthority.Link);
  if (child_name = 'substitution') Then
    list.addAll(self, 'substitution', FSubstitutionList);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'maxDispense') Then
     list.add(self.link, 'maxDispense', FMaxDispense.Link);
end;

procedure TFhirMedicationKnowledgeRegulatory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'regulatoryAuthority', 'Reference', false, TFhirReference, FRegulatoryAuthority.Link));
  oList.add(TFHIRProperty.create(self, 'substitution', 'BackboneElement', true, TFhirMedicationKnowledgeRegulatorySubstitution, FSubstitutionList.Link));
  oList.add(TFHIRProperty.create(self, 'schedule', 'BackboneElement', true, TFhirMedicationKnowledgeRegulatorySchedule, FScheduleList.Link));
  oList.add(TFHIRProperty.create(self, 'maxDispense', 'BackboneElement', false, TFhirMedicationKnowledgeRegulatoryMaxDispense, FMaxDispense.Link));
end;

function TFhirMedicationKnowledgeRegulatory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'regulatoryAuthority') then
  begin
    RegulatoryAuthority := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    SubstitutionList.add(propValue as TFhirMedicationKnowledgeRegulatorySubstitution);
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirMedicationKnowledgeRegulatorySchedule);
    result := propValue;
  end
  else if (propName = 'maxDispense') then
  begin
    MaxDispense := propValue as TFhirMedicationKnowledgeRegulatoryMaxDispense;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'substitution') then SubstitutionList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatorySubstitution)
  else if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatorySchedule)
  else inherited;
end;

function TFhirMedicationKnowledgeRegulatory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'regulatoryAuthority') then result := TFhirReference.create()
  else if (propName = 'substitution') then result := SubstitutionList.new()
  else if (propName = 'schedule') then result := ScheduleList.new()
  else if (propName = 'maxDispense') then result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'regulatoryAuthority') then result := 'Reference'
  else if (propName = 'substitution') then result := 'BackboneElement'
  else if (propName = 'schedule') then result := 'BackboneElement'
  else if (propName = 'maxDispense') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'regulatoryAuthority') then RegulatoryAuthorityElement := nil
  else if (propName = 'substitution') then deletePropertyValue('substitution', SubstitutionList, value)
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value)
  else if (propName = 'maxDispense') then MaxDispenseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'regulatoryAuthority') then RegulatoryAuthorityElement := new as TFhirReference
  else if (propName = 'substitution') then replacePropertyValue('substitution', SubstitutionList, existing, new)
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new)
  else if (propName = 'maxDispense') then MaxDispenseElement := new as TFhirMedicationKnowledgeRegulatoryMaxDispense
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatory.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'substitution') then SubstitutionList.move(source, destination)
  else if (propName = 'schedule') then ScheduleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatory.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory';
end;

function TFhirMedicationKnowledgeRegulatory.Link : TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatory.Clone : TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatory.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatory)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatory(other);
    result := compareDeep(regulatoryAuthorityElement, o.regulatoryAuthorityElement, true) and 
      compareDeep(substitutionList, o.substitutionList, true) and compareDeep(scheduleList, o.scheduleList, true) and 
      compareDeep(maxDispenseElement, o.maxDispenseElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRegulatoryAuthority) and isEmptyProp(FsubstitutionList) and isEmptyProp(FscheduleList) and isEmptyProp(FMaxDispense);
end;

procedure TFhirMedicationKnowledgeRegulatory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('regulatoryAuthority');
  fields.add('substitution');
  fields.add('schedule');
  fields.add('maxDispense');
end;

function TFhirMedicationKnowledgeRegulatory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSubstitutionList.sizeInBytes(magic));
  inc(result, FScheduleList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledgeRegulatory.SetRegulatoryAuthority(value : TFhirReference);
begin
  FRegulatoryAuthority.free;
  FRegulatoryAuthority := value;
end;

function TFhirMedicationKnowledgeRegulatory.GetSubstitutionList : TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  if FSubstitutionList = nil then
    FSubstitutionList := TFhirMedicationKnowledgeRegulatorySubstitutionList.Create;
  result := FSubstitutionList;
end;

function TFhirMedicationKnowledgeRegulatory.GetHasSubstitutionList : boolean;
begin
  result := (FSubstitutionList <> nil) and (FSubstitutionList.count > 0);
end;

function TFhirMedicationKnowledgeRegulatory.GetScheduleList : TFhirMedicationKnowledgeRegulatoryScheduleList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirMedicationKnowledgeRegulatoryScheduleList.Create;
  result := FScheduleList;
end;

function TFhirMedicationKnowledgeRegulatory.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

procedure TFhirMedicationKnowledgeRegulatory.SetMaxDispense(value : TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  FMaxDispense.free;
  FMaxDispense := value;
end;

{ TFhirMedicationKnowledgeRegulatoryListEnumerator }

constructor TFhirMedicationKnowledgeRegulatoryListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatory;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeRegulatoryList }

function TFhirMedicationKnowledgeRegulatoryList.AddItem(value: TFhirMedicationKnowledgeRegulatory): TFhirMedicationKnowledgeRegulatory;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatory');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeRegulatoryList.Append: TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryList.Clone: TFhirMedicationKnowledgeRegulatoryList;
begin
  result := TFhirMedicationKnowledgeRegulatoryList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatory;
end;
function TFhirMedicationKnowledgeRegulatoryList.IndexOf(value: TFhirMedicationKnowledgeRegulatory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryList.Item(index: Integer): TFhirMedicationKnowledgeRegulatory;
begin
  result := TFhirMedicationKnowledgeRegulatory(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryList.Link: TFhirMedicationKnowledgeRegulatoryList;
begin
  result := TFhirMedicationKnowledgeRegulatoryList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  FhirMedicationKnowledgeRegulatories[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatory);
begin
  assert(value is TFhirMedicationKnowledgeRegulatory);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatorySubstitution }

constructor TFhirMedicationKnowledgeRegulatorySubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatorySubstitution.Destroy;
begin
  FType_.free;
  FAllowed.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicationKnowledgeRegulatorySubstitution(oSource).type_.Clone;
  allowedElement := TFhirMedicationKnowledgeRegulatorySubstitution(oSource).allowedElement.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'allowed') Then
     list.add(self.link, 'allowed', FAllowed.Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'allowed', 'boolean', false, TFhirBoolean, FAllowed.Link));
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'allowed') then
  begin
    AllowedElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'allowed') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'allowed') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'allowed') then AllowedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'allowed') then AllowedElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory.substitution';
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.Link : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.Clone : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatorySubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatorySubstitution(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(allowedElement, o.allowedElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FAllowed);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('allowed');
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetAllowed(value : TFhirBoolean);
begin
  FAllowed.free;
  FAllowed := value;
end;

function TFhirMedicationKnowledgeRegulatorySubstitution.GetAllowedST : Boolean;
begin
  if FAllowed = nil then
    result := false
  else
    result := FAllowed.value;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitution.SetAllowedST(value : Boolean);
begin
  if FAllowed = nil then
    FAllowed := TFhirBoolean.create;
  FAllowed.value := value
end;

{ TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator }

constructor TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatorySubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeRegulatorySubstitutionList }

function TFhirMedicationKnowledgeRegulatorySubstitutionList.AddItem(value: TFhirMedicationKnowledgeRegulatorySubstitution): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatorySubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatorySubstitution');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Append: TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.GetEnumerator : TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Clone: TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution;
end;
function TFhirMedicationKnowledgeRegulatorySubstitutionList.IndexOf(value: TFhirMedicationKnowledgeRegulatorySubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Item(index: Integer): TFhirMedicationKnowledgeRegulatorySubstitution;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatorySubstitutionList.Link: TFhirMedicationKnowledgeRegulatorySubstitutionList;
begin
  result := TFhirMedicationKnowledgeRegulatorySubstitutionList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  FhirMedicationKnowledgeRegulatorySubstitutions[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatorySubstitutionList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatorySubstitution);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatorySchedule }

constructor TFhirMedicationKnowledgeRegulatorySchedule.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatorySchedule.Destroy;
begin
  FSchedule.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.Assign(oSource : TFslObject);
begin
  inherited;
  schedule := TFhirMedicationKnowledgeRegulatorySchedule(oSource).schedule.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'schedule', 'CodeableConcept', false, TFhirCodeableConcept, FSchedule.Link));
end;

function TFhirMedicationKnowledgeRegulatorySchedule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatorySchedule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'schedule') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatorySchedule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'schedule') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatorySchedule.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory.schedule';
end;

function TFhirMedicationKnowledgeRegulatorySchedule.Link : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatorySchedule.Clone : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatorySchedule.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatorySchedule)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatorySchedule(other);
    result := compareDeep(scheduleElement, o.scheduleElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatorySchedule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSchedule);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('schedule');
end;

function TFhirMedicationKnowledgeRegulatorySchedule.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeRegulatorySchedule.SetSchedule(value : TFhirCodeableConcept);
begin
  FSchedule.free;
  FSchedule := value;
end;

{ TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator }

constructor TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryScheduleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatorySchedule;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeRegulatoryScheduleList }

function TFhirMedicationKnowledgeRegulatoryScheduleList.AddItem(value: TFhirMedicationKnowledgeRegulatorySchedule): TFhirMedicationKnowledgeRegulatorySchedule;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatorySchedule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatorySchedule');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Append: TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryScheduleListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Clone: TFhirMedicationKnowledgeRegulatoryScheduleList;
begin
  result := TFhirMedicationKnowledgeRegulatoryScheduleList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule;
end;
function TFhirMedicationKnowledgeRegulatoryScheduleList.IndexOf(value: TFhirMedicationKnowledgeRegulatorySchedule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatorySchedule);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySchedule);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Item(index: Integer): TFhirMedicationKnowledgeRegulatorySchedule;
begin
  result := TFhirMedicationKnowledgeRegulatorySchedule(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryScheduleList.Link: TFhirMedicationKnowledgeRegulatoryScheduleList;
begin
  result := TFhirMedicationKnowledgeRegulatoryScheduleList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatorySchedule);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySchedule);
  FhirMedicationKnowledgeRegulatorySchedules[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryScheduleList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatorySchedule);
begin
  assert(value is TFhirMedicationKnowledgeRegulatorySchedule);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispense }

constructor TFhirMedicationKnowledgeRegulatoryMaxDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeRegulatoryMaxDispense.Destroy;
begin
  FQuantity.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirMedicationKnowledgeRegulatoryMaxDispense(oSource).quantity.Clone;
  period := TFhirMedicationKnowledgeRegulatoryMaxDispense(oSource).period.Clone;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Duration', false, TFhirDuration, FPeriod.Link));
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirDuration;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'period') then result := TFhirDuration.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'period') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'period') then PeriodElement := new as TFhirDuration
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.fhirType : string;
begin
  result := 'MedicationKnowledge.regulatory.maxDispense';
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.Link : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(inherited Link);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.Clone : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeRegulatoryMaxDispense)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeRegulatoryMaxDispense(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FPeriod);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('period');
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispense.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispense.SetPeriod(value : TFhirDuration);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator }

constructor TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Create(list : TFhirMedicationKnowledgeRegulatoryMaxDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.GetCurrent : TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeRegulatoryMaxDispenseList }

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.AddItem(value: TFhirMedicationKnowledgeRegulatoryMaxDispense): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeRegulatoryMaxDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeRegulatoryMaxDispense');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Append: TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.GetEnumerator : TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Clone: TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseList(inherited Clone);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.GetItemN(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense;
end;
function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.IndexOf(value: TFhirMedicationKnowledgeRegulatoryMaxDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Insert(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Item(index: Integer): TFhirMedicationKnowledgeRegulatoryMaxDispense;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispense(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Link: TFhirMedicationKnowledgeRegulatoryMaxDispenseList;
begin
  result := TFhirMedicationKnowledgeRegulatoryMaxDispenseList(inherited Link);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  FhirMedicationKnowledgeRegulatoryMaxDispenses[index] := value;
end;

procedure TFhirMedicationKnowledgeRegulatoryMaxDispenseList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeRegulatoryMaxDispense);
begin
  assert(value is TFhirMedicationKnowledgeRegulatoryMaxDispense);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledgeKinetics }

constructor TFhirMedicationKnowledgeKinetics.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledgeKinetics.Destroy;
begin
  FAreaUnderCurveList.Free;
  FLethalDose50List.Free;
  FHalfLifePeriod.free;
  inherited;
end;

procedure TFhirMedicationKnowledgeKinetics.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationKnowledgeKinetics(oSource).FAreaUnderCurveList = nil) then
  begin
    FAreaUnderCurveList.free;
    FAreaUnderCurveList := nil;
  end
  else
  begin
    if FAreaUnderCurveList = nil then
      FAreaUnderCurveList := TFhirQuantityList.Create;
    FAreaUnderCurveList.Assign(TFhirMedicationKnowledgeKinetics(oSource).FAreaUnderCurveList);
  end;
  if (TFhirMedicationKnowledgeKinetics(oSource).FLethalDose50List = nil) then
  begin
    FLethalDose50List.free;
    FLethalDose50List := nil;
  end
  else
  begin
    if FLethalDose50List = nil then
      FLethalDose50List := TFhirQuantityList.Create;
    FLethalDose50List.Assign(TFhirMedicationKnowledgeKinetics(oSource).FLethalDose50List);
  end;
  halfLifePeriod := TFhirMedicationKnowledgeKinetics(oSource).halfLifePeriod.Clone;
end;

procedure TFhirMedicationKnowledgeKinetics.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'areaUnderCurve') Then
    list.addAll(self, 'areaUnderCurve', FAreaUnderCurveList);
  if (child_name = 'lethalDose50') Then
    list.addAll(self, 'lethalDose50', FLethalDose50List);
  if (child_name = 'halfLifePeriod') Then
     list.add(self.link, 'halfLifePeriod', FHalfLifePeriod.Link);
end;

procedure TFhirMedicationKnowledgeKinetics.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'areaUnderCurve', 'Quantity', true, TFhirQuantity, FAreaUnderCurveList.Link));
  oList.add(TFHIRProperty.create(self, 'lethalDose50', 'Quantity', true, TFhirQuantity, FLethalDose50List.Link));
  oList.add(TFHIRProperty.create(self, 'halfLifePeriod', 'Duration', false, TFhirDuration, FHalfLifePeriod.Link));
end;

function TFhirMedicationKnowledgeKinetics.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'areaUnderCurve') then
  begin
    AreaUnderCurveList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'lethalDose50') then
  begin
    LethalDose50List.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'halfLifePeriod') then
  begin
    HalfLifePeriod := propValue as TFhirDuration;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledgeKinetics.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'areaUnderCurve') then AreaUnderCurveList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'lethalDose50') then LethalDose50List.insertItem(index, propValue as TFhirQuantity)
  else inherited;
end;

function TFhirMedicationKnowledgeKinetics.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'areaUnderCurve') then result := AreaUnderCurveList.new()
  else if (propName = 'lethalDose50') then result := LethalDose50List.new()
  else if (propName = 'halfLifePeriod') then result := TFhirDuration.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledgeKinetics.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'areaUnderCurve') then result := 'Quantity'
  else if (propName = 'lethalDose50') then result := 'Quantity'
  else if (propName = 'halfLifePeriod') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledgeKinetics.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'areaUnderCurve') then deletePropertyValue('areaUnderCurve', AreaUnderCurveList, value)
  else if (propName = 'lethalDose50') then deletePropertyValue('lethalDose50', LethalDose50List, value)
  else if (propName = 'halfLifePeriod') then HalfLifePeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledgeKinetics.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'areaUnderCurve') then replacePropertyValue('areaUnderCurve', AreaUnderCurveList, existing, new)
  else if (propName = 'lethalDose50') then replacePropertyValue('lethalDose50', LethalDose50List, existing, new)
  else if (propName = 'halfLifePeriod') then HalfLifePeriodElement := new as TFhirDuration
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledgeKinetics.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'areaUnderCurve') then AreaUnderCurveList.move(source, destination)
  else if (propName = 'lethalDose50') then LethalDose50List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledgeKinetics.fhirType : string;
begin
  result := 'MedicationKnowledge.kinetics';
end;

function TFhirMedicationKnowledgeKinetics.Link : TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics(inherited Link);
end;

function TFhirMedicationKnowledgeKinetics.Clone : TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics(inherited Clone);
end;

function TFhirMedicationKnowledgeKinetics.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledgeKinetics;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledgeKinetics)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledgeKinetics(other);
    result := compareDeep(areaUnderCurveList, o.areaUnderCurveList, true) and compareDeep(lethalDose50List, o.lethalDose50List, true) and 
      compareDeep(halfLifePeriodElement, o.halfLifePeriodElement, true);
  end;
end;

function TFhirMedicationKnowledgeKinetics.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FareaUnderCurveList) and isEmptyProp(FlethalDose50List) and isEmptyProp(FHalfLifePeriod);
end;

procedure TFhirMedicationKnowledgeKinetics.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('areaUnderCurve');
  fields.add('lethalDose50');
  fields.add('halfLifePeriod');
end;

function TFhirMedicationKnowledgeKinetics.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAreaUnderCurveList.sizeInBytes(magic));
  inc(result, FLethalDose50List.sizeInBytes(magic));
end;

function TFhirMedicationKnowledgeKinetics.GetAreaUnderCurveList : TFhirQuantityList;
begin
  if FAreaUnderCurveList = nil then
    FAreaUnderCurveList := TFhirQuantityList.Create;
  result := FAreaUnderCurveList;
end;

function TFhirMedicationKnowledgeKinetics.GetHasAreaUnderCurveList : boolean;
begin
  result := (FAreaUnderCurveList <> nil) and (FAreaUnderCurveList.count > 0);
end;

function TFhirMedicationKnowledgeKinetics.GetLethalDose50List : TFhirQuantityList;
begin
  if FLethalDose50List = nil then
    FLethalDose50List := TFhirQuantityList.Create;
  result := FLethalDose50List;
end;

function TFhirMedicationKnowledgeKinetics.GetHasLethalDose50List : boolean;
begin
  result := (FLethalDose50List <> nil) and (FLethalDose50List.count > 0);
end;

procedure TFhirMedicationKnowledgeKinetics.SetHalfLifePeriod(value : TFhirDuration);
begin
  FHalfLifePeriod.free;
  FHalfLifePeriod := value;
end;

{ TFhirMedicationKnowledgeKineticsListEnumerator }

constructor TFhirMedicationKnowledgeKineticsListEnumerator.Create(list : TFhirMedicationKnowledgeKineticsList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeKineticsListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeKineticsListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeKineticsListEnumerator.GetCurrent : TFhirMedicationKnowledgeKinetics;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeKineticsListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeKineticsList }

function TFhirMedicationKnowledgeKineticsList.AddItem(value: TFhirMedicationKnowledgeKinetics): TFhirMedicationKnowledgeKinetics;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledgeKinetics', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledgeKinetics');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeKineticsList.Append: TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeKineticsList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeKineticsList.GetEnumerator : TFhirMedicationKnowledgeKineticsListEnumerator;
begin
  result := TFhirMedicationKnowledgeKineticsListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeKineticsList.Clone: TFhirMedicationKnowledgeKineticsList;
begin
  result := TFhirMedicationKnowledgeKineticsList(inherited Clone);
end;

function TFhirMedicationKnowledgeKineticsList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeKineticsList.GetItemN(index: Integer): TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeKineticsList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledgeKinetics;
end;
function TFhirMedicationKnowledgeKineticsList.IndexOf(value: TFhirMedicationKnowledgeKinetics): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeKineticsList.Insert(index: Integer): TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeKineticsList.InsertItem(index: Integer; value: TFhirMedicationKnowledgeKinetics);
begin
  assert(value is TFhirMedicationKnowledgeKinetics);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeKineticsList.Item(index: Integer): TFhirMedicationKnowledgeKinetics;
begin
  result := TFhirMedicationKnowledgeKinetics(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeKineticsList.Link: TFhirMedicationKnowledgeKineticsList;
begin
  result := TFhirMedicationKnowledgeKineticsList(inherited Link);
end;

procedure TFhirMedicationKnowledgeKineticsList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeKineticsList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledgeKinetics);
begin
  assert(value is TFhirMedicationKnowledgeKinetics);
  FhirMedicationKnowledgeKinetics[index] := value;
end;

procedure TFhirMedicationKnowledgeKineticsList.SetItemN(index: Integer; value: TFhirMedicationKnowledgeKinetics);
begin
  assert(value is TFhirMedicationKnowledgeKinetics);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationKnowledge }

constructor TFhirMedicationKnowledge.Create;
begin
  inherited;
end;

destructor TFhirMedicationKnowledge.Destroy;
begin
  FCode.free;
  FStatus.free;
  FManufacturer.free;
  FDoseForm.free;
  FAmount.free;
  FSynonymList.Free;
  FRelatedMedicationKnowledgeList.Free;
  FAssociatedMedicationList.Free;
  FProductTypeList.Free;
  FMonographList.Free;
  FIngredientList.Free;
  FPreparationInstruction.free;
  FIntendedRouteList.Free;
  FCostList.Free;
  FMonitoringProgramList.Free;
  FAdministrationGuidelinesList.Free;
  FMedicineClassificationList.Free;
  FPackaging.free;
  FDrugCharacteristicList.Free;
  FContraindicationList.Free;
  FRegulatoryList.Free;
  FKineticsList.Free;
  inherited;
end;

procedure TFhirMedicationKnowledge.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMedicationKnowledge(oSource).code.Clone;
  statusElement := TFhirMedicationKnowledge(oSource).statusElement.Clone;
  manufacturer := TFhirMedicationKnowledge(oSource).manufacturer.Clone;
  doseForm := TFhirMedicationKnowledge(oSource).doseForm.Clone;
  amount := TFhirMedicationKnowledge(oSource).amount.Clone;
  if (TFhirMedicationKnowledge(oSource).FSynonymList = nil) then
  begin
    FSynonymList.free;
    FSynonymList := nil;
  end
  else
  begin
    if FSynonymList = nil then
      FSynonymList := TFhirStringList.Create;
    FSynonymList.Assign(TFhirMedicationKnowledge(oSource).FSynonymList);
  end;
  if (TFhirMedicationKnowledge(oSource).FRelatedMedicationKnowledgeList = nil) then
  begin
    FRelatedMedicationKnowledgeList.free;
    FRelatedMedicationKnowledgeList := nil;
  end
  else
  begin
    if FRelatedMedicationKnowledgeList = nil then
      FRelatedMedicationKnowledgeList := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Create;
    FRelatedMedicationKnowledgeList.Assign(TFhirMedicationKnowledge(oSource).FRelatedMedicationKnowledgeList);
  end;
  if (TFhirMedicationKnowledge(oSource).FAssociatedMedicationList = nil) then
  begin
    FAssociatedMedicationList.free;
    FAssociatedMedicationList := nil;
  end
  else
  begin
    if FAssociatedMedicationList = nil then
      FAssociatedMedicationList := TFhirReferenceList.Create;
    FAssociatedMedicationList.Assign(TFhirMedicationKnowledge(oSource).FAssociatedMedicationList);
  end;
  if (TFhirMedicationKnowledge(oSource).FProductTypeList = nil) then
  begin
    FProductTypeList.free;
    FProductTypeList := nil;
  end
  else
  begin
    if FProductTypeList = nil then
      FProductTypeList := TFhirCodeableConceptList.Create;
    FProductTypeList.Assign(TFhirMedicationKnowledge(oSource).FProductTypeList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMonographList = nil) then
  begin
    FMonographList.free;
    FMonographList := nil;
  end
  else
  begin
    if FMonographList = nil then
      FMonographList := TFhirMedicationKnowledgeMonographList.Create;
    FMonographList.Assign(TFhirMedicationKnowledge(oSource).FMonographList);
  end;
  if (TFhirMedicationKnowledge(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirMedicationKnowledgeIngredientList.Create;
    FIngredientList.Assign(TFhirMedicationKnowledge(oSource).FIngredientList);
  end;
  preparationInstructionElement := TFhirMedicationKnowledge(oSource).preparationInstructionElement.Clone;
  if (TFhirMedicationKnowledge(oSource).FIntendedRouteList = nil) then
  begin
    FIntendedRouteList.free;
    FIntendedRouteList := nil;
  end
  else
  begin
    if FIntendedRouteList = nil then
      FIntendedRouteList := TFhirCodeableConceptList.Create;
    FIntendedRouteList.Assign(TFhirMedicationKnowledge(oSource).FIntendedRouteList);
  end;
  if (TFhirMedicationKnowledge(oSource).FCostList = nil) then
  begin
    FCostList.free;
    FCostList := nil;
  end
  else
  begin
    if FCostList = nil then
      FCostList := TFhirMedicationKnowledgeCostList.Create;
    FCostList.Assign(TFhirMedicationKnowledge(oSource).FCostList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMonitoringProgramList = nil) then
  begin
    FMonitoringProgramList.free;
    FMonitoringProgramList := nil;
  end
  else
  begin
    if FMonitoringProgramList = nil then
      FMonitoringProgramList := TFhirMedicationKnowledgeMonitoringProgramList.Create;
    FMonitoringProgramList.Assign(TFhirMedicationKnowledge(oSource).FMonitoringProgramList);
  end;
  if (TFhirMedicationKnowledge(oSource).FAdministrationGuidelinesList = nil) then
  begin
    FAdministrationGuidelinesList.free;
    FAdministrationGuidelinesList := nil;
  end
  else
  begin
    if FAdministrationGuidelinesList = nil then
      FAdministrationGuidelinesList := TFhirMedicationKnowledgeAdministrationGuidelinesList.Create;
    FAdministrationGuidelinesList.Assign(TFhirMedicationKnowledge(oSource).FAdministrationGuidelinesList);
  end;
  if (TFhirMedicationKnowledge(oSource).FMedicineClassificationList = nil) then
  begin
    FMedicineClassificationList.free;
    FMedicineClassificationList := nil;
  end
  else
  begin
    if FMedicineClassificationList = nil then
      FMedicineClassificationList := TFhirMedicationKnowledgeMedicineClassificationList.Create;
    FMedicineClassificationList.Assign(TFhirMedicationKnowledge(oSource).FMedicineClassificationList);
  end;
  packaging := TFhirMedicationKnowledge(oSource).packaging.Clone;
  if (TFhirMedicationKnowledge(oSource).FDrugCharacteristicList = nil) then
  begin
    FDrugCharacteristicList.free;
    FDrugCharacteristicList := nil;
  end
  else
  begin
    if FDrugCharacteristicList = nil then
      FDrugCharacteristicList := TFhirMedicationKnowledgeDrugCharacteristicList.Create;
    FDrugCharacteristicList.Assign(TFhirMedicationKnowledge(oSource).FDrugCharacteristicList);
  end;
  if (TFhirMedicationKnowledge(oSource).FContraindicationList = nil) then
  begin
    FContraindicationList.free;
    FContraindicationList := nil;
  end
  else
  begin
    if FContraindicationList = nil then
      FContraindicationList := TFhirReferenceList.Create;
    FContraindicationList.Assign(TFhirMedicationKnowledge(oSource).FContraindicationList);
  end;
  if (TFhirMedicationKnowledge(oSource).FRegulatoryList = nil) then
  begin
    FRegulatoryList.free;
    FRegulatoryList := nil;
  end
  else
  begin
    if FRegulatoryList = nil then
      FRegulatoryList := TFhirMedicationKnowledgeRegulatoryList.Create;
    FRegulatoryList.Assign(TFhirMedicationKnowledge(oSource).FRegulatoryList);
  end;
  if (TFhirMedicationKnowledge(oSource).FKineticsList = nil) then
  begin
    FKineticsList.free;
    FKineticsList := nil;
  end
  else
  begin
    if FKineticsList = nil then
      FKineticsList := TFhirMedicationKnowledgeKineticsList.Create;
    FKineticsList.Assign(TFhirMedicationKnowledge(oSource).FKineticsList);
  end;
end;

function TFhirMedicationKnowledge.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationKnowledge;
end;

procedure TFhirMedicationKnowledge.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'doseForm') Then
     list.add(self.link, 'doseForm', FDoseForm.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'synonym') Then
    list.addAll(self, 'synonym', FSynonymList);
  if (child_name = 'relatedMedicationKnowledge') Then
    list.addAll(self, 'relatedMedicationKnowledge', FRelatedMedicationKnowledgeList);
  if (child_name = 'associatedMedication') Then
    list.addAll(self, 'associatedMedication', FAssociatedMedicationList);
  if (child_name = 'productType') Then
    list.addAll(self, 'productType', FProductTypeList);
  if (child_name = 'monograph') Then
    list.addAll(self, 'monograph', FMonographList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'preparationInstruction') Then
     list.add(self.link, 'preparationInstruction', FPreparationInstruction.Link);
  if (child_name = 'intendedRoute') Then
    list.addAll(self, 'intendedRoute', FIntendedRouteList);
  if (child_name = 'cost') Then
    list.addAll(self, 'cost', FCostList);
  if (child_name = 'monitoringProgram') Then
    list.addAll(self, 'monitoringProgram', FMonitoringProgramList);
  if (child_name = 'administrationGuidelines') Then
    list.addAll(self, 'administrationGuidelines', FAdministrationGuidelinesList);
  if (child_name = 'medicineClassification') Then
    list.addAll(self, 'medicineClassification', FMedicineClassificationList);
  if (child_name = 'packaging') Then
     list.add(self.link, 'packaging', FPackaging.Link);
  if (child_name = 'drugCharacteristic') Then
    list.addAll(self, 'drugCharacteristic', FDrugCharacteristicList);
  if (child_name = 'contraindication') Then
    list.addAll(self, 'contraindication', FContraindicationList);
  if (child_name = 'regulatory') Then
    list.addAll(self, 'regulatory', FRegulatoryList);
  if (child_name = 'kinetics') Then
    list.addAll(self, 'kinetics', FKineticsList);
end;

procedure TFhirMedicationKnowledge.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', false, TFhirReference, FManufacturer.Link));
  oList.add(TFHIRProperty.create(self, 'doseForm', 'CodeableConcept', false, TFhirCodeableConcept, FDoseForm.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'synonym', 'string', true, TFhirString, FSynonymList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedMedicationKnowledge', 'BackboneElement', true, TFhirMedicationKnowledgeRelatedMedicationKnowledge, FRelatedMedicationKnowledgeList.Link));
  oList.add(TFHIRProperty.create(self, 'associatedMedication', 'Reference', true, TFhirReference, FAssociatedMedicationList.Link));
  oList.add(TFHIRProperty.create(self, 'productType', 'CodeableConcept', true, TFhirCodeableConcept, FProductTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'monograph', 'BackboneElement', true, TFhirMedicationKnowledgeMonograph, FMonographList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirMedicationKnowledgeIngredient, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'preparationInstruction', 'markdown', false, TFhirMarkdown, FPreparationInstruction.Link));
  oList.add(TFHIRProperty.create(self, 'intendedRoute', 'CodeableConcept', true, TFhirCodeableConcept, FIntendedRouteList.Link));
  oList.add(TFHIRProperty.create(self, 'cost', 'BackboneElement', true, TFhirMedicationKnowledgeCost, FCostList.Link));
  oList.add(TFHIRProperty.create(self, 'monitoringProgram', 'BackboneElement', true, TFhirMedicationKnowledgeMonitoringProgram, FMonitoringProgramList.Link));
  oList.add(TFHIRProperty.create(self, 'administrationGuidelines', 'BackboneElement', true, TFhirMedicationKnowledgeAdministrationGuidelines, FAdministrationGuidelinesList.Link));
  oList.add(TFHIRProperty.create(self, 'medicineClassification', 'BackboneElement', true, TFhirMedicationKnowledgeMedicineClassification, FMedicineClassificationList.Link));
  oList.add(TFHIRProperty.create(self, 'packaging', 'BackboneElement', false, TFhirMedicationKnowledgePackaging, FPackaging.Link));
  oList.add(TFHIRProperty.create(self, 'drugCharacteristic', 'BackboneElement', true, TFhirMedicationKnowledgeDrugCharacteristic, FDrugCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'contraindication', 'Reference', true, TFhirReference, FContraindicationList.Link));
  oList.add(TFHIRProperty.create(self, 'regulatory', 'BackboneElement', true, TFhirMedicationKnowledgeRegulatory, FRegulatoryList.Link));
  oList.add(TFHIRProperty.create(self, 'kinetics', 'BackboneElement', true, TFhirMedicationKnowledgeKinetics, FKineticsList.Link));
end;

function TFhirMedicationKnowledge.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum, CODES_TFhirMedicationKnowledgeStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'doseForm') then
  begin
    DoseForm := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'synonym') then
  begin
    SynonymList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'relatedMedicationKnowledge') then
  begin
    RelatedMedicationKnowledgeList.add(propValue as TFhirMedicationKnowledgeRelatedMedicationKnowledge);
    result := propValue;
  end
  else if (propName = 'associatedMedication') then
  begin
    AssociatedMedicationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'productType') then
  begin
    ProductTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'monograph') then
  begin
    MonographList.add(propValue as TFhirMedicationKnowledgeMonograph);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirMedicationKnowledgeIngredient);
    result := propValue;
  end
  else if (propName = 'preparationInstruction') then
  begin
    PreparationInstructionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'intendedRoute') then
  begin
    IntendedRouteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'cost') then
  begin
    CostList.add(propValue as TFhirMedicationKnowledgeCost);
    result := propValue;
  end
  else if (propName = 'monitoringProgram') then
  begin
    MonitoringProgramList.add(propValue as TFhirMedicationKnowledgeMonitoringProgram);
    result := propValue;
  end
  else if (propName = 'administrationGuidelines') then
  begin
    AdministrationGuidelinesList.add(propValue as TFhirMedicationKnowledgeAdministrationGuidelines);
    result := propValue;
  end
  else if (propName = 'medicineClassification') then
  begin
    MedicineClassificationList.add(propValue as TFhirMedicationKnowledgeMedicineClassification);
    result := propValue;
  end
  else if (propName = 'packaging') then
  begin
    Packaging := propValue as TFhirMedicationKnowledgePackaging;
    result := propValue;
  end
  else if (propName = 'drugCharacteristic') then
  begin
    DrugCharacteristicList.add(propValue as TFhirMedicationKnowledgeDrugCharacteristic);
    result := propValue;
  end
  else if (propName = 'contraindication') then
  begin
    ContraindicationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'regulatory') then
  begin
    RegulatoryList.add(propValue as TFhirMedicationKnowledgeRegulatory);
    result := propValue;
  end
  else if (propName = 'kinetics') then
  begin
    KineticsList.add(propValue as TFhirMedicationKnowledgeKinetics);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationKnowledge.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'synonym') then SynonymList.insertItem(index, asString(propValue))
  else if (propName = 'relatedMedicationKnowledge') then RelatedMedicationKnowledgeList.insertItem(index, propValue as TFhirMedicationKnowledgeRelatedMedicationKnowledge)
  else if (propName = 'associatedMedication') then AssociatedMedicationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'productType') then ProductTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'monograph') then MonographList.insertItem(index, propValue as TFhirMedicationKnowledgeMonograph)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirMedicationKnowledgeIngredient)
  else if (propName = 'intendedRoute') then IntendedRouteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'cost') then CostList.insertItem(index, propValue as TFhirMedicationKnowledgeCost)
  else if (propName = 'monitoringProgram') then MonitoringProgramList.insertItem(index, propValue as TFhirMedicationKnowledgeMonitoringProgram)
  else if (propName = 'administrationGuidelines') then AdministrationGuidelinesList.insertItem(index, propValue as TFhirMedicationKnowledgeAdministrationGuidelines)
  else if (propName = 'medicineClassification') then MedicineClassificationList.insertItem(index, propValue as TFhirMedicationKnowledgeMedicineClassification)
  else if (propName = 'drugCharacteristic') then DrugCharacteristicList.insertItem(index, propValue as TFhirMedicationKnowledgeDrugCharacteristic)
  else if (propName = 'contraindication') then ContraindicationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'regulatory') then RegulatoryList.insertItem(index, propValue as TFhirMedicationKnowledgeRegulatory)
  else if (propName = 'kinetics') then KineticsList.insertItem(index, propValue as TFhirMedicationKnowledgeKinetics)
  else inherited;
end;

function TFhirMedicationKnowledge.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum[MedicationKnowledgeStatusCodesNull], CODES_TFhirMedicationKnowledgeStatusCodesEnum[MedicationKnowledgeStatusCodesNull]) 
  else if (propName = 'manufacturer') then result := TFhirReference.create()
  else if (propName = 'doseForm') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirQuantity.create()
  else if (propName = 'synonym') then result := SynonymList.new()
  else if (propName = 'relatedMedicationKnowledge') then result := RelatedMedicationKnowledgeList.new()
  else if (propName = 'associatedMedication') then result := AssociatedMedicationList.new()
  else if (propName = 'productType') then result := ProductTypeList.new()
  else if (propName = 'monograph') then result := MonographList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'preparationInstruction') then result := TFhirMarkdown.create()
  else if (propName = 'intendedRoute') then result := IntendedRouteList.new()
  else if (propName = 'cost') then result := CostList.new()
  else if (propName = 'monitoringProgram') then result := MonitoringProgramList.new()
  else if (propName = 'administrationGuidelines') then result := AdministrationGuidelinesList.new()
  else if (propName = 'medicineClassification') then result := MedicineClassificationList.new()
  else if (propName = 'packaging') then result := TFhirMedicationKnowledgePackaging.create()
  else if (propName = 'drugCharacteristic') then result := DrugCharacteristicList.new()
  else if (propName = 'contraindication') then result := ContraindicationList.new()
  else if (propName = 'regulatory') then result := RegulatoryList.new()
  else if (propName = 'kinetics') then result := KineticsList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationKnowledge.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'doseForm') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else if (propName = 'synonym') then result := 'string'
  else if (propName = 'relatedMedicationKnowledge') then result := 'BackboneElement'
  else if (propName = 'associatedMedication') then result := 'Reference'
  else if (propName = 'productType') then result := 'CodeableConcept'
  else if (propName = 'monograph') then result := 'BackboneElement'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else if (propName = 'preparationInstruction') then result := 'markdown'
  else if (propName = 'intendedRoute') then result := 'CodeableConcept'
  else if (propName = 'cost') then result := 'BackboneElement'
  else if (propName = 'monitoringProgram') then result := 'BackboneElement'
  else if (propName = 'administrationGuidelines') then result := 'BackboneElement'
  else if (propName = 'medicineClassification') then result := 'BackboneElement'
  else if (propName = 'packaging') then result := 'BackboneElement'
  else if (propName = 'drugCharacteristic') then result := 'BackboneElement'
  else if (propName = 'contraindication') then result := 'Reference'
  else if (propName = 'regulatory') then result := 'BackboneElement'
  else if (propName = 'kinetics') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationKnowledge.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'doseForm') then DoseFormElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else if (propName = 'synonym') then deletePropertyValue('synonym', SynonymList, value)
  else if (propName = 'relatedMedicationKnowledge') then deletePropertyValue('relatedMedicationKnowledge', RelatedMedicationKnowledgeList, value)
  else if (propName = 'associatedMedication') then deletePropertyValue('associatedMedication', AssociatedMedicationList, value)
  else if (propName = 'productType') then deletePropertyValue('productType', ProductTypeList, value)
  else if (propName = 'monograph') then deletePropertyValue('monograph', MonographList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'preparationInstruction') then PreparationInstructionElement := nil
  else if (propName = 'intendedRoute') then deletePropertyValue('intendedRoute', IntendedRouteList, value)
  else if (propName = 'cost') then deletePropertyValue('cost', CostList, value)
  else if (propName = 'monitoringProgram') then deletePropertyValue('monitoringProgram', MonitoringProgramList, value)
  else if (propName = 'administrationGuidelines') then deletePropertyValue('administrationGuidelines', AdministrationGuidelinesList, value)
  else if (propName = 'medicineClassification') then deletePropertyValue('medicineClassification', MedicineClassificationList, value)
  else if (propName = 'packaging') then PackagingElement := nil
  else if (propName = 'drugCharacteristic') then deletePropertyValue('drugCharacteristic', DrugCharacteristicList, value)
  else if (propName = 'contraindication') then deletePropertyValue('contraindication', ContraindicationList, value)
  else if (propName = 'regulatory') then deletePropertyValue('regulatory', RegulatoryList, value)
  else if (propName = 'kinetics') then deletePropertyValue('kinetics', KineticsList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationKnowledge.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum, CODES_TFhirMedicationKnowledgeStatusCodesEnum, new)
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference
  else if (propName = 'doseForm') then DoseFormElement := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity
  else if (propName = 'synonym') then replacePropertyValue('synonym', SynonymList, existing, new)
  else if (propName = 'relatedMedicationKnowledge') then replacePropertyValue('relatedMedicationKnowledge', RelatedMedicationKnowledgeList, existing, new)
  else if (propName = 'associatedMedication') then replacePropertyValue('associatedMedication', AssociatedMedicationList, existing, new)
  else if (propName = 'productType') then replacePropertyValue('productType', ProductTypeList, existing, new)
  else if (propName = 'monograph') then replacePropertyValue('monograph', MonographList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'preparationInstruction') then PreparationInstructionElement := asMarkdown(new)
  else if (propName = 'intendedRoute') then replacePropertyValue('intendedRoute', IntendedRouteList, existing, new)
  else if (propName = 'cost') then replacePropertyValue('cost', CostList, existing, new)
  else if (propName = 'monitoringProgram') then replacePropertyValue('monitoringProgram', MonitoringProgramList, existing, new)
  else if (propName = 'administrationGuidelines') then replacePropertyValue('administrationGuidelines', AdministrationGuidelinesList, existing, new)
  else if (propName = 'medicineClassification') then replacePropertyValue('medicineClassification', MedicineClassificationList, existing, new)
  else if (propName = 'packaging') then PackagingElement := new as TFhirMedicationKnowledgePackaging
  else if (propName = 'drugCharacteristic') then replacePropertyValue('drugCharacteristic', DrugCharacteristicList, existing, new)
  else if (propName = 'contraindication') then replacePropertyValue('contraindication', ContraindicationList, existing, new)
  else if (propName = 'regulatory') then replacePropertyValue('regulatory', RegulatoryList, existing, new)
  else if (propName = 'kinetics') then replacePropertyValue('kinetics', KineticsList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationKnowledge.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'synonym') then SynonymList.move(source, destination)
  else if (propName = 'relatedMedicationKnowledge') then RelatedMedicationKnowledgeList.move(source, destination)
  else if (propName = 'associatedMedication') then AssociatedMedicationList.move(source, destination)
  else if (propName = 'productType') then ProductTypeList.move(source, destination)
  else if (propName = 'monograph') then MonographList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'intendedRoute') then IntendedRouteList.move(source, destination)
  else if (propName = 'cost') then CostList.move(source, destination)
  else if (propName = 'monitoringProgram') then MonitoringProgramList.move(source, destination)
  else if (propName = 'administrationGuidelines') then AdministrationGuidelinesList.move(source, destination)
  else if (propName = 'medicineClassification') then MedicineClassificationList.move(source, destination)
  else if (propName = 'drugCharacteristic') then DrugCharacteristicList.move(source, destination)
  else if (propName = 'contraindication') then ContraindicationList.move(source, destination)
  else if (propName = 'regulatory') then RegulatoryList.move(source, destination)
  else if (propName = 'kinetics') then KineticsList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationKnowledge.fhirType : string;
begin
  result := 'MedicationKnowledge';
end;

function TFhirMedicationKnowledge.Link : TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(inherited Link);
end;

function TFhirMedicationKnowledge.Clone : TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(inherited Clone);
end;

function TFhirMedicationKnowledge.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationKnowledge;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationKnowledge)) then
    result := false
  else
  begin
    o := TFhirMedicationKnowledge(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(doseFormElement, o.doseFormElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(synonymList, o.synonymList, true) and 
      compareDeep(relatedMedicationKnowledgeList, o.relatedMedicationKnowledgeList, true) and 
      compareDeep(associatedMedicationList, o.associatedMedicationList, true) and compareDeep(productTypeList, o.productTypeList, true) and 
      compareDeep(monographList, o.monographList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(preparationInstructionElement, o.preparationInstructionElement, true) and 
      compareDeep(intendedRouteList, o.intendedRouteList, true) and compareDeep(costList, o.costList, true) and 
      compareDeep(monitoringProgramList, o.monitoringProgramList, true) and compareDeep(administrationGuidelinesList, o.administrationGuidelinesList, true) and 
      compareDeep(medicineClassificationList, o.medicineClassificationList, true) and 
      compareDeep(packagingElement, o.packagingElement, true) and compareDeep(drugCharacteristicList, o.drugCharacteristicList, true) and 
      compareDeep(contraindicationList, o.contraindicationList, true) and compareDeep(regulatoryList, o.regulatoryList, true) and 
      compareDeep(kineticsList, o.kineticsList, true);
  end;
end;

function TFhirMedicationKnowledge.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FManufacturer) and isEmptyProp(FDoseForm) and isEmptyProp(FAmount) and isEmptyProp(FsynonymList) and isEmptyProp(FrelatedMedicationKnowledgeList) and isEmptyProp(FassociatedMedicationList) and isEmptyProp(FproductTypeList) and isEmptyProp(FmonographList) and isEmptyProp(FingredientList) and isEmptyProp(FPreparationInstruction) and isEmptyProp(FintendedRouteList) and isEmptyProp(FcostList) and isEmptyProp(FmonitoringProgramList) and isEmptyProp(FadministrationGuidelinesList) and isEmptyProp(FmedicineClassificationList) and isEmptyProp(FPackaging) and isEmptyProp(FdrugCharacteristicList) and isEmptyProp(FcontraindicationList) and isEmptyProp(FregulatoryList) and isEmptyProp(FkineticsList);
end;

procedure TFhirMedicationKnowledge.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('status');
  fields.add('manufacturer');
  fields.add('doseForm');
  fields.add('amount');
  fields.add('synonym');
  fields.add('relatedMedicationKnowledge');
  fields.add('associatedMedication');
  fields.add('productType');
  fields.add('monograph');
  fields.add('ingredient');
  fields.add('preparationInstruction');
  fields.add('intendedRoute');
  fields.add('cost');
  fields.add('monitoringProgram');
  fields.add('administrationGuidelines');
  fields.add('medicineClassification');
  fields.add('packaging');
  fields.add('drugCharacteristic');
  fields.add('contraindication');
  fields.add('regulatory');
  fields.add('kinetics');
end;

function TFhirMedicationKnowledge.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSynonymList.sizeInBytes(magic));
  inc(result, FRelatedMedicationKnowledgeList.sizeInBytes(magic));
  inc(result, FAssociatedMedicationList.sizeInBytes(magic));
  inc(result, FProductTypeList.sizeInBytes(magic));
  inc(result, FMonographList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FIntendedRouteList.sizeInBytes(magic));
  inc(result, FCostList.sizeInBytes(magic));
  inc(result, FMonitoringProgramList.sizeInBytes(magic));
  inc(result, FAdministrationGuidelinesList.sizeInBytes(magic));
  inc(result, FMedicineClassificationList.sizeInBytes(magic));
  inc(result, FDrugCharacteristicList.sizeInBytes(magic));
  inc(result, FContraindicationList.sizeInBytes(magic));
  inc(result, FRegulatoryList.sizeInBytes(magic));
  inc(result, FKineticsList.sizeInBytes(magic));
end;

procedure TFhirMedicationKnowledge.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMedicationKnowledge.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationKnowledge.GetStatusST : TFhirMedicationKnowledgeStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationKnowledgeStatusCodesEnum(0)
  else
    result := TFhirMedicationKnowledgeStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationKnowledgeStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedicationKnowledge.SetStatusST(value : TFhirMedicationKnowledgeStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationKnowledgeStatusCodesEnum[value], CODES_TFhirMedicationKnowledgeStatusCodesEnum[value]);
end;

procedure TFhirMedicationKnowledge.SetManufacturer(value : TFhirReference);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

procedure TFhirMedicationKnowledge.SetDoseForm(value : TFhirCodeableConcept);
begin
  FDoseForm.free;
  FDoseForm := value;
end;

procedure TFhirMedicationKnowledge.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirMedicationKnowledge.GetSynonymList : TFhirStringList;
begin
  if FSynonymList = nil then
    FSynonymList := TFhirStringList.Create;
  result := FSynonymList;
end;

function TFhirMedicationKnowledge.GetHasSynonymList : boolean;
begin
  result := (FSynonymList <> nil) and (FSynonymList.count > 0);
end;

function TFhirMedicationKnowledge.GetRelatedMedicationKnowledgeList : TFhirMedicationKnowledgeRelatedMedicationKnowledgeList;
begin
  if FRelatedMedicationKnowledgeList = nil then
    FRelatedMedicationKnowledgeList := TFhirMedicationKnowledgeRelatedMedicationKnowledgeList.Create;
  result := FRelatedMedicationKnowledgeList;
end;

function TFhirMedicationKnowledge.GetHasRelatedMedicationKnowledgeList : boolean;
begin
  result := (FRelatedMedicationKnowledgeList <> nil) and (FRelatedMedicationKnowledgeList.count > 0);
end;

function TFhirMedicationKnowledge.GetAssociatedMedicationList : TFhirReferenceList;
begin
  if FAssociatedMedicationList = nil then
    FAssociatedMedicationList := TFhirReferenceList.Create;
  result := FAssociatedMedicationList;
end;

function TFhirMedicationKnowledge.GetHasAssociatedMedicationList : boolean;
begin
  result := (FAssociatedMedicationList <> nil) and (FAssociatedMedicationList.count > 0);
end;

function TFhirMedicationKnowledge.GetProductTypeList : TFhirCodeableConceptList;
begin
  if FProductTypeList = nil then
    FProductTypeList := TFhirCodeableConceptList.Create;
  result := FProductTypeList;
end;

function TFhirMedicationKnowledge.GetHasProductTypeList : boolean;
begin
  result := (FProductTypeList <> nil) and (FProductTypeList.count > 0);
end;

function TFhirMedicationKnowledge.GetMonographList : TFhirMedicationKnowledgeMonographList;
begin
  if FMonographList = nil then
    FMonographList := TFhirMedicationKnowledgeMonographList.Create;
  result := FMonographList;
end;

function TFhirMedicationKnowledge.GetHasMonographList : boolean;
begin
  result := (FMonographList <> nil) and (FMonographList.count > 0);
end;

function TFhirMedicationKnowledge.GetIngredientList : TFhirMedicationKnowledgeIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirMedicationKnowledgeIngredientList.Create;
  result := FIngredientList;
end;

function TFhirMedicationKnowledge.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

procedure TFhirMedicationKnowledge.SetPreparationInstruction(value : TFhirMarkdown);
begin
  FPreparationInstruction.free;
  FPreparationInstruction := value;
end;

function TFhirMedicationKnowledge.GetPreparationInstructionST : String;
begin
  if FPreparationInstruction = nil then
    result := ''
  else
    result := FPreparationInstruction.value;
end;

procedure TFhirMedicationKnowledge.SetPreparationInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FPreparationInstruction = nil then
      FPreparationInstruction := TFhirMarkdown.create;
    FPreparationInstruction.value := value
  end
  else if FPreparationInstruction <> nil then
    FPreparationInstruction.value := '';
end;

function TFhirMedicationKnowledge.GetIntendedRouteList : TFhirCodeableConceptList;
begin
  if FIntendedRouteList = nil then
    FIntendedRouteList := TFhirCodeableConceptList.Create;
  result := FIntendedRouteList;
end;

function TFhirMedicationKnowledge.GetHasIntendedRouteList : boolean;
begin
  result := (FIntendedRouteList <> nil) and (FIntendedRouteList.count > 0);
end;

function TFhirMedicationKnowledge.GetCostList : TFhirMedicationKnowledgeCostList;
begin
  if FCostList = nil then
    FCostList := TFhirMedicationKnowledgeCostList.Create;
  result := FCostList;
end;

function TFhirMedicationKnowledge.GetHasCostList : boolean;
begin
  result := (FCostList <> nil) and (FCostList.count > 0);
end;

function TFhirMedicationKnowledge.GetMonitoringProgramList : TFhirMedicationKnowledgeMonitoringProgramList;
begin
  if FMonitoringProgramList = nil then
    FMonitoringProgramList := TFhirMedicationKnowledgeMonitoringProgramList.Create;
  result := FMonitoringProgramList;
end;

function TFhirMedicationKnowledge.GetHasMonitoringProgramList : boolean;
begin
  result := (FMonitoringProgramList <> nil) and (FMonitoringProgramList.count > 0);
end;

function TFhirMedicationKnowledge.GetAdministrationGuidelinesList : TFhirMedicationKnowledgeAdministrationGuidelinesList;
begin
  if FAdministrationGuidelinesList = nil then
    FAdministrationGuidelinesList := TFhirMedicationKnowledgeAdministrationGuidelinesList.Create;
  result := FAdministrationGuidelinesList;
end;

function TFhirMedicationKnowledge.GetHasAdministrationGuidelinesList : boolean;
begin
  result := (FAdministrationGuidelinesList <> nil) and (FAdministrationGuidelinesList.count > 0);
end;

function TFhirMedicationKnowledge.GetMedicineClassificationList : TFhirMedicationKnowledgeMedicineClassificationList;
begin
  if FMedicineClassificationList = nil then
    FMedicineClassificationList := TFhirMedicationKnowledgeMedicineClassificationList.Create;
  result := FMedicineClassificationList;
end;

function TFhirMedicationKnowledge.GetHasMedicineClassificationList : boolean;
begin
  result := (FMedicineClassificationList <> nil) and (FMedicineClassificationList.count > 0);
end;

procedure TFhirMedicationKnowledge.SetPackaging(value : TFhirMedicationKnowledgePackaging);
begin
  FPackaging.free;
  FPackaging := value;
end;

function TFhirMedicationKnowledge.GetDrugCharacteristicList : TFhirMedicationKnowledgeDrugCharacteristicList;
begin
  if FDrugCharacteristicList = nil then
    FDrugCharacteristicList := TFhirMedicationKnowledgeDrugCharacteristicList.Create;
  result := FDrugCharacteristicList;
end;

function TFhirMedicationKnowledge.GetHasDrugCharacteristicList : boolean;
begin
  result := (FDrugCharacteristicList <> nil) and (FDrugCharacteristicList.count > 0);
end;

function TFhirMedicationKnowledge.GetContraindicationList : TFhirReferenceList;
begin
  if FContraindicationList = nil then
    FContraindicationList := TFhirReferenceList.Create;
  result := FContraindicationList;
end;

function TFhirMedicationKnowledge.GetHasContraindicationList : boolean;
begin
  result := (FContraindicationList <> nil) and (FContraindicationList.count > 0);
end;

function TFhirMedicationKnowledge.GetRegulatoryList : TFhirMedicationKnowledgeRegulatoryList;
begin
  if FRegulatoryList = nil then
    FRegulatoryList := TFhirMedicationKnowledgeRegulatoryList.Create;
  result := FRegulatoryList;
end;

function TFhirMedicationKnowledge.GetHasRegulatoryList : boolean;
begin
  result := (FRegulatoryList <> nil) and (FRegulatoryList.count > 0);
end;

function TFhirMedicationKnowledge.GetKineticsList : TFhirMedicationKnowledgeKineticsList;
begin
  if FKineticsList = nil then
    FKineticsList := TFhirMedicationKnowledgeKineticsList.Create;
  result := FKineticsList;
end;

function TFhirMedicationKnowledge.GetHasKineticsList : boolean;
begin
  result := (FKineticsList <> nil) and (FKineticsList.count > 0);
end;

{ TFhirMedicationKnowledgeListEnumerator }

constructor TFhirMedicationKnowledgeListEnumerator.Create(list : TFhirMedicationKnowledgeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationKnowledgeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationKnowledgeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationKnowledgeListEnumerator.GetCurrent : TFhirMedicationKnowledge;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationKnowledgeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationKnowledgeList }

function TFhirMedicationKnowledgeList.AddItem(value: TFhirMedicationKnowledge): TFhirMedicationKnowledge;
begin
  assert(value.ClassName = 'TFhirMedicationKnowledge', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationKnowledge');
  add(value);
  result := value;
end;

function TFhirMedicationKnowledgeList.Append: TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationKnowledgeList.GetEnumerator : TFhirMedicationKnowledgeListEnumerator;
begin
  result := TFhirMedicationKnowledgeListEnumerator.Create(self.link);
end;

function TFhirMedicationKnowledgeList.Clone: TFhirMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeList(inherited Clone);
end;

function TFhirMedicationKnowledgeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationKnowledgeList.GetItemN(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationKnowledge;
end;
function TFhirMedicationKnowledgeList.IndexOf(value: TFhirMedicationKnowledge): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationKnowledgeList.Insert(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationKnowledgeList.InsertItem(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  Inherited Insert(index, value);
end;

function TFhirMedicationKnowledgeList.Item(index: Integer): TFhirMedicationKnowledge;
begin
  result := TFhirMedicationKnowledge(ObjectByIndex[index]);
end;

function TFhirMedicationKnowledgeList.Link: TFhirMedicationKnowledgeList;
begin
  result := TFhirMedicationKnowledgeList(inherited Link);
end;

procedure TFhirMedicationKnowledgeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationKnowledgeList.SetItemByIndex(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  FhirMedicationKnowledges[index] := value;
end;

procedure TFhirMedicationKnowledgeList.SetItemN(index: Integer; value: TFhirMedicationKnowledge);
begin
  assert(value is TFhirMedicationKnowledge);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONKNOWLEDGE}
{$IFDEF FHIR_MEDICINALPRODUCTDEFINITION}
{ TFhirMedicinalProductDefinitionContact }

constructor TFhirMedicinalProductDefinitionContact.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionContact.Destroy;
begin
  FType_.free;
  FContact.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionContact.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicinalProductDefinitionContact(oSource).type_.Clone;
  contact := TFhirMedicinalProductDefinitionContact(oSource).contact.Clone;
end;

procedure TFhirMedicinalProductDefinitionContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'contact') Then
     list.add(self.link, 'contact', FContact.Link);
end;

procedure TFhirMedicinalProductDefinitionContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'Reference', false, TFhirReference, FContact.Link));
end;

function TFhirMedicinalProductDefinitionContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    Contact := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'contact') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'contact') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'contact') then ContactElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'contact') then ContactElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionContact.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionContact.fhirType : string;
begin
  result := 'MedicinalProductDefinition.contact';
end;

function TFhirMedicinalProductDefinitionContact.Link : TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(inherited Link);
end;

function TFhirMedicinalProductDefinitionContact.Clone : TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(inherited Clone);
end;

function TFhirMedicinalProductDefinitionContact.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionContact)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionContact(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(contactElement, o.contactElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FContact);
end;

procedure TFhirMedicinalProductDefinitionContact.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('contact');
end;

function TFhirMedicinalProductDefinitionContact.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionContact.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicinalProductDefinitionContact.SetContact(value : TFhirReference);
begin
  FContact.free;
  FContact := value;
end;

{ TFhirMedicinalProductDefinitionContactListEnumerator }

constructor TFhirMedicinalProductDefinitionContactListEnumerator.Create(list : TFhirMedicinalProductDefinitionContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionContactListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionContactListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionContact;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionContactListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionContactList }

function TFhirMedicinalProductDefinitionContactList.AddItem(value: TFhirMedicinalProductDefinitionContact): TFhirMedicinalProductDefinitionContact;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionContact');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionContactList.Append: TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionContactList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionContactList.GetEnumerator : TFhirMedicinalProductDefinitionContactListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionContactListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionContactList.Clone: TFhirMedicinalProductDefinitionContactList;
begin
  result := TFhirMedicinalProductDefinitionContactList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionContactList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionContact;
end;
function TFhirMedicinalProductDefinitionContactList.IndexOf(value: TFhirMedicinalProductDefinitionContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionContactList.Insert(index: Integer): TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionContactList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value is TFhirMedicinalProductDefinitionContact);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionContactList.Item(index: Integer): TFhirMedicinalProductDefinitionContact;
begin
  result := TFhirMedicinalProductDefinitionContact(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionContactList.Link: TFhirMedicinalProductDefinitionContactList;
begin
  result := TFhirMedicinalProductDefinitionContactList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionContactList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value is TFhirMedicinalProductDefinitionContact);
  FhirMedicinalProductDefinitionContacts[index] := value;
end;

procedure TFhirMedicinalProductDefinitionContactList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionContact);
begin
  assert(value is TFhirMedicinalProductDefinitionContact);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionName }

constructor TFhirMedicinalProductDefinitionName.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionName.Destroy;
begin
  FProductName.free;
  FType_.free;
  FNamePartList.Free;
  FCountryLanguageList.Free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionName.Assign(oSource : TFslObject);
begin
  inherited;
  productNameElement := TFhirMedicinalProductDefinitionName(oSource).productNameElement.Clone;
  type_ := TFhirMedicinalProductDefinitionName(oSource).type_.Clone;
  if (TFhirMedicinalProductDefinitionName(oSource).FNamePartList = nil) then
  begin
    FNamePartList.free;
    FNamePartList := nil;
  end
  else
  begin
    if FNamePartList = nil then
      FNamePartList := TFhirMedicinalProductDefinitionNameNamePartList.Create;
    FNamePartList.Assign(TFhirMedicinalProductDefinitionName(oSource).FNamePartList);
  end;
  if (TFhirMedicinalProductDefinitionName(oSource).FCountryLanguageList = nil) then
  begin
    FCountryLanguageList.free;
    FCountryLanguageList := nil;
  end
  else
  begin
    if FCountryLanguageList = nil then
      FCountryLanguageList := TFhirMedicinalProductDefinitionNameCountryLanguageList.Create;
    FCountryLanguageList.Assign(TFhirMedicinalProductDefinitionName(oSource).FCountryLanguageList);
  end;
end;

procedure TFhirMedicinalProductDefinitionName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'productName') Then
     list.add(self.link, 'productName', FProductName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'namePart') Then
    list.addAll(self, 'namePart', FNamePartList);
  if (child_name = 'countryLanguage') Then
    list.addAll(self, 'countryLanguage', FCountryLanguageList);
end;

procedure TFhirMedicinalProductDefinitionName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'productName', 'string', false, TFhirString, FProductName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'namePart', 'BackboneElement', true, TFhirMedicinalProductDefinitionNameNamePart, FNamePartList.Link));
  oList.add(TFHIRProperty.create(self, 'countryLanguage', 'BackboneElement', true, TFhirMedicinalProductDefinitionNameCountryLanguage, FCountryLanguageList.Link));
end;

function TFhirMedicinalProductDefinitionName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'productName') then
  begin
    ProductNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'namePart') then
  begin
    NamePartList.add(propValue as TFhirMedicinalProductDefinitionNameNamePart);
    result := propValue;
  end
  else if (propName = 'countryLanguage') then
  begin
    CountryLanguageList.add(propValue as TFhirMedicinalProductDefinitionNameCountryLanguage);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'namePart') then NamePartList.insertItem(index, propValue as TFhirMedicinalProductDefinitionNameNamePart)
  else if (propName = 'countryLanguage') then CountryLanguageList.insertItem(index, propValue as TFhirMedicinalProductDefinitionNameCountryLanguage)
  else inherited;
end;

function TFhirMedicinalProductDefinitionName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'productName') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'namePart') then result := NamePartList.new()
  else if (propName = 'countryLanguage') then result := CountryLanguageList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'productName') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'namePart') then result := 'BackboneElement'
  else if (propName = 'countryLanguage') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'productName') then ProductNameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'namePart') then deletePropertyValue('namePart', NamePartList, value)
  else if (propName = 'countryLanguage') then deletePropertyValue('countryLanguage', CountryLanguageList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'productName') then ProductNameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'namePart') then replacePropertyValue('namePart', NamePartList, existing, new)
  else if (propName = 'countryLanguage') then replacePropertyValue('countryLanguage', CountryLanguageList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionName.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'namePart') then NamePartList.move(source, destination)
  else if (propName = 'countryLanguage') then CountryLanguageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionName.fhirType : string;
begin
  result := 'MedicinalProductDefinition.name';
end;

function TFhirMedicinalProductDefinitionName.Link : TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(inherited Link);
end;

function TFhirMedicinalProductDefinitionName.Clone : TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(inherited Clone);
end;

function TFhirMedicinalProductDefinitionName.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionName)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionName(other);
    result := compareDeep(productNameElement, o.productNameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(namePartList, o.namePartList, true) and compareDeep(countryLanguageList, o.countryLanguageList, true);
  end;
end;

function TFhirMedicinalProductDefinitionName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProductName) and isEmptyProp(FType_) and isEmptyProp(FnamePartList) and isEmptyProp(FcountryLanguageList);
end;

procedure TFhirMedicinalProductDefinitionName.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('productName');
  fields.add('type');
  fields.add('namePart');
  fields.add('countryLanguage');
end;

function TFhirMedicinalProductDefinitionName.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNamePartList.sizeInBytes(magic));
  inc(result, FCountryLanguageList.sizeInBytes(magic));
end;

procedure TFhirMedicinalProductDefinitionName.SetProductName(value : TFhirString);
begin
  FProductName.free;
  FProductName := value;
end;

function TFhirMedicinalProductDefinitionName.GetProductNameST : String;
begin
  if FProductName = nil then
    result := ''
  else
    result := FProductName.value;
end;

procedure TFhirMedicinalProductDefinitionName.SetProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FProductName = nil then
      FProductName := TFhirString.create;
    FProductName.value := value
  end
  else if FProductName <> nil then
    FProductName.value := '';
end;

procedure TFhirMedicinalProductDefinitionName.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMedicinalProductDefinitionName.GetNamePartList : TFhirMedicinalProductDefinitionNameNamePartList;
begin
  if FNamePartList = nil then
    FNamePartList := TFhirMedicinalProductDefinitionNameNamePartList.Create;
  result := FNamePartList;
end;

function TFhirMedicinalProductDefinitionName.GetHasNamePartList : boolean;
begin
  result := (FNamePartList <> nil) and (FNamePartList.count > 0);
end;

function TFhirMedicinalProductDefinitionName.GetCountryLanguageList : TFhirMedicinalProductDefinitionNameCountryLanguageList;
begin
  if FCountryLanguageList = nil then
    FCountryLanguageList := TFhirMedicinalProductDefinitionNameCountryLanguageList.Create;
  result := FCountryLanguageList;
end;

function TFhirMedicinalProductDefinitionName.GetHasCountryLanguageList : boolean;
begin
  result := (FCountryLanguageList <> nil) and (FCountryLanguageList.count > 0);
end;

{ TFhirMedicinalProductDefinitionNameListEnumerator }

constructor TFhirMedicinalProductDefinitionNameListEnumerator.Create(list : TFhirMedicinalProductDefinitionNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionNameListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionName;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionNameListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionNameList }

function TFhirMedicinalProductDefinitionNameList.AddItem(value: TFhirMedicinalProductDefinitionName): TFhirMedicinalProductDefinitionName;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionName');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionNameList.Append: TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionNameList.GetEnumerator : TFhirMedicinalProductDefinitionNameListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionNameListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionNameList.Clone: TFhirMedicinalProductDefinitionNameList;
begin
  result := TFhirMedicinalProductDefinitionNameList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionNameList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionName;
end;
function TFhirMedicinalProductDefinitionNameList.IndexOf(value: TFhirMedicinalProductDefinitionName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionNameList.Insert(index: Integer): TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionName);
begin
  assert(value is TFhirMedicinalProductDefinitionName);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionNameList.Item(index: Integer): TFhirMedicinalProductDefinitionName;
begin
  result := TFhirMedicinalProductDefinitionName(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameList.Link: TFhirMedicinalProductDefinitionNameList;
begin
  result := TFhirMedicinalProductDefinitionNameList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionNameList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionName);
begin
  assert(value is TFhirMedicinalProductDefinitionName);
  FhirMedicinalProductDefinitionNames[index] := value;
end;

procedure TFhirMedicinalProductDefinitionNameList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionName);
begin
  assert(value is TFhirMedicinalProductDefinitionName);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionNameNamePart }

constructor TFhirMedicinalProductDefinitionNameNamePart.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionNameNamePart.Destroy;
begin
  FPart.free;
  FType_.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.Assign(oSource : TFslObject);
begin
  inherited;
  partElement := TFhirMedicinalProductDefinitionNameNamePart(oSource).partElement.Clone;
  type_ := TFhirMedicinalProductDefinitionNameNamePart(oSource).type_.Clone;
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'part', 'string', false, TFhirString, FPart.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
end;

function TFhirMedicinalProductDefinitionNameNamePart.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'part') then
  begin
    PartElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionNameNamePart.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'part') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionNameNamePart.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'part') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'part') then PartElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'part') then PartElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionNameNamePart.fhirType : string;
begin
  result := 'MedicinalProductDefinition.name.namePart';
end;

function TFhirMedicinalProductDefinitionNameNamePart.Link : TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart(inherited Link);
end;

function TFhirMedicinalProductDefinitionNameNamePart.Clone : TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameNamePart.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionNameNamePart;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionNameNamePart)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionNameNamePart(other);
    result := compareDeep(partElement, o.partElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirMedicinalProductDefinitionNameNamePart.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPart) and isEmptyProp(FType_);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('part');
  fields.add('type');
end;

function TFhirMedicinalProductDefinitionNameNamePart.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.SetPart(value : TFhirString);
begin
  FPart.free;
  FPart := value;
end;

function TFhirMedicinalProductDefinitionNameNamePart.GetPartST : String;
begin
  if FPart = nil then
    result := ''
  else
    result := FPart.value;
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.SetPartST(value : String);
begin
  if value <> '' then
  begin
    if FPart = nil then
      FPart := TFhirString.create;
    FPart.value := value
  end
  else if FPart <> nil then
    FPart.value := '';
end;

procedure TFhirMedicinalProductDefinitionNameNamePart.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

{ TFhirMedicinalProductDefinitionNameNamePartListEnumerator }

constructor TFhirMedicinalProductDefinitionNameNamePartListEnumerator.Create(list : TFhirMedicinalProductDefinitionNameNamePartList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionNameNamePartListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionNameNamePartListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionNameNamePartListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionNameNamePart;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionNameNamePartListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionNameNamePartList }

function TFhirMedicinalProductDefinitionNameNamePartList.AddItem(value: TFhirMedicinalProductDefinitionNameNamePart): TFhirMedicinalProductDefinitionNameNamePart;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionNameNamePart', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionNameNamePart');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Append: TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionNameNamePartList.GetEnumerator : TFhirMedicinalProductDefinitionNameNamePartListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionNameNamePartListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Clone: TFhirMedicinalProductDefinitionNameNamePartList;
begin
  result := TFhirMedicinalProductDefinitionNameNamePartList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionNameNamePartList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart;
end;
function TFhirMedicinalProductDefinitionNameNamePartList.IndexOf(value: TFhirMedicinalProductDefinitionNameNamePart): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Insert(index: Integer): TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionNameNamePart);
begin
  assert(value is TFhirMedicinalProductDefinitionNameNamePart);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Item(index: Integer): TFhirMedicinalProductDefinitionNameNamePart;
begin
  result := TFhirMedicinalProductDefinitionNameNamePart(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameNamePartList.Link: TFhirMedicinalProductDefinitionNameNamePartList;
begin
  result := TFhirMedicinalProductDefinitionNameNamePartList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionNameNamePart);
begin
  assert(value is TFhirMedicinalProductDefinitionNameNamePart);
  FhirMedicinalProductDefinitionNameNameParts[index] := value;
end;

procedure TFhirMedicinalProductDefinitionNameNamePartList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionNameNamePart);
begin
  assert(value is TFhirMedicinalProductDefinitionNameNamePart);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionNameCountryLanguage }

constructor TFhirMedicinalProductDefinitionNameCountryLanguage.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionNameCountryLanguage.Destroy;
begin
  FCountry.free;
  FJurisdiction.free;
  FLanguage.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.Assign(oSource : TFslObject);
begin
  inherited;
  country := TFhirMedicinalProductDefinitionNameCountryLanguage(oSource).country.Clone;
  jurisdiction := TFhirMedicinalProductDefinitionNameCountryLanguage(oSource).jurisdiction.Clone;
  language := TFhirMedicinalProductDefinitionNameCountryLanguage(oSource).language.Clone;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'country') Then
     list.add(self.link, 'country', FCountry.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'country', 'CodeableConcept', false, TFhirCodeableConcept, FCountry.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', false, TFhirCodeableConcept, FJurisdiction.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'country') then
  begin
    Country := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    Jurisdiction := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'country') then result := TFhirCodeableConcept.create()
  else if (propName = 'jurisdiction') then result := TFhirCodeableConcept.create()
  else if (propName = 'language') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'country') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'language') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'language') then LanguageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'country') then CountryElement := new as TFhirCodeableConcept
  else if (propName = 'jurisdiction') then JurisdictionElement := new as TFhirCodeableConcept
  else if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.fhirType : string;
begin
  result := 'MedicinalProductDefinition.name.countryLanguage';
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.Link : TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage(inherited Link);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.Clone : TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionNameCountryLanguage)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionNameCountryLanguage(other);
    result := compareDeep(countryElement, o.countryElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(languageElement, o.languageElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCountry) and isEmptyProp(FJurisdiction) and isEmptyProp(FLanguage);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('country');
  fields.add('jurisdiction');
  fields.add('language');
end;

function TFhirMedicinalProductDefinitionNameCountryLanguage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.SetCountry(value : TFhirCodeableConcept);
begin
  FCountry.free;
  FCountry := value;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.SetJurisdiction(value : TFhirCodeableConcept);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguage.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

{ TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator }

constructor TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.Create(list : TFhirMedicinalProductDefinitionNameCountryLanguageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionNameCountryLanguageList }

function TFhirMedicinalProductDefinitionNameCountryLanguageList.AddItem(value: TFhirMedicinalProductDefinitionNameCountryLanguage): TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionNameCountryLanguage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionNameCountryLanguage');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Append: TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.GetEnumerator : TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguageListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Clone: TFhirMedicinalProductDefinitionNameCountryLanguageList;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguageList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage;
end;
function TFhirMedicinalProductDefinitionNameCountryLanguageList.IndexOf(value: TFhirMedicinalProductDefinitionNameCountryLanguage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Insert(index: Integer): TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionNameCountryLanguage);
begin
  assert(value is TFhirMedicinalProductDefinitionNameCountryLanguage);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Item(index: Integer): TFhirMedicinalProductDefinitionNameCountryLanguage;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguage(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionNameCountryLanguageList.Link: TFhirMedicinalProductDefinitionNameCountryLanguageList;
begin
  result := TFhirMedicinalProductDefinitionNameCountryLanguageList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionNameCountryLanguage);
begin
  assert(value is TFhirMedicinalProductDefinitionNameCountryLanguage);
  FhirMedicinalProductDefinitionNameCountryLanguages[index] := value;
end;

procedure TFhirMedicinalProductDefinitionNameCountryLanguageList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionNameCountryLanguage);
begin
  assert(value is TFhirMedicinalProductDefinitionNameCountryLanguage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionCrossReference }

constructor TFhirMedicinalProductDefinitionCrossReference.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionCrossReference.Destroy;
begin
  FProduct.free;
  FType_.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionCrossReference.Assign(oSource : TFslObject);
begin
  inherited;
  product := TFhirMedicinalProductDefinitionCrossReference(oSource).product.Clone;
  type_ := TFhirMedicinalProductDefinitionCrossReference(oSource).type_.Clone;
end;

procedure TFhirMedicinalProductDefinitionCrossReference.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'product') Then
     list.add(self.link, 'product', FProduct.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'product', 'CodeableReference', false, TFhirCodeableReference, FProduct.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
end;

function TFhirMedicinalProductDefinitionCrossReference.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'product') then
  begin
    Product := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionCrossReference.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'product') then result := TFhirCodeableReference.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionCrossReference.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'product') then result := 'CodeableReference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := new as TFhirCodeableReference
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionCrossReference.fhirType : string;
begin
  result := 'MedicinalProductDefinition.crossReference';
end;

function TFhirMedicinalProductDefinitionCrossReference.Link : TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(inherited Link);
end;

function TFhirMedicinalProductDefinitionCrossReference.Clone : TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCrossReference.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionCrossReference;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionCrossReference)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionCrossReference(other);
    result := compareDeep(productElement, o.productElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirMedicinalProductDefinitionCrossReference.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProduct) and isEmptyProp(FType_);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('product');
  fields.add('type');
end;

function TFhirMedicinalProductDefinitionCrossReference.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionCrossReference.SetProduct(value : TFhirCodeableReference);
begin
  FProduct.free;
  FProduct := value;
end;

procedure TFhirMedicinalProductDefinitionCrossReference.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

{ TFhirMedicinalProductDefinitionCrossReferenceListEnumerator }

constructor TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.Create(list : TFhirMedicinalProductDefinitionCrossReferenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionCrossReference;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionCrossReferenceList }

function TFhirMedicinalProductDefinitionCrossReferenceList.AddItem(value: TFhirMedicinalProductDefinitionCrossReference): TFhirMedicinalProductDefinitionCrossReference;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionCrossReference', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionCrossReference');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Append: TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.GetEnumerator : TFhirMedicinalProductDefinitionCrossReferenceListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionCrossReferenceListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Clone: TFhirMedicinalProductDefinitionCrossReferenceList;
begin
  result := TFhirMedicinalProductDefinitionCrossReferenceList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionCrossReference;
end;
function TFhirMedicinalProductDefinitionCrossReferenceList.IndexOf(value: TFhirMedicinalProductDefinitionCrossReference): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Insert(index: Integer): TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value is TFhirMedicinalProductDefinitionCrossReference);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Item(index: Integer): TFhirMedicinalProductDefinitionCrossReference;
begin
  result := TFhirMedicinalProductDefinitionCrossReference(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCrossReferenceList.Link: TFhirMedicinalProductDefinitionCrossReferenceList;
begin
  result := TFhirMedicinalProductDefinitionCrossReferenceList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value is TFhirMedicinalProductDefinitionCrossReference);
  FhirMedicinalProductDefinitionCrossReferences[index] := value;
end;

procedure TFhirMedicinalProductDefinitionCrossReferenceList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionCrossReference);
begin
  assert(value is TFhirMedicinalProductDefinitionCrossReference);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionOperation }

constructor TFhirMedicinalProductDefinitionOperation.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionOperation.Destroy;
begin
  FType_.free;
  FEffectiveDate.free;
  FOrganizationList.Free;
  FConfidentialityIndicator.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionOperation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicinalProductDefinitionOperation(oSource).type_.Clone;
  effectiveDate := TFhirMedicinalProductDefinitionOperation(oSource).effectiveDate.Clone;
  if (TFhirMedicinalProductDefinitionOperation(oSource).FOrganizationList = nil) then
  begin
    FOrganizationList.free;
    FOrganizationList := nil;
  end
  else
  begin
    if FOrganizationList = nil then
      FOrganizationList := TFhirReferenceList.Create;
    FOrganizationList.Assign(TFhirMedicinalProductDefinitionOperation(oSource).FOrganizationList);
  end;
  confidentialityIndicator := TFhirMedicinalProductDefinitionOperation(oSource).confidentialityIndicator.Clone;
end;

procedure TFhirMedicinalProductDefinitionOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'effectiveDate') Then
     list.add(self.link, 'effectiveDate', FEffectiveDate.Link);
  if (child_name = 'organization') Then
    list.addAll(self, 'organization', FOrganizationList);
  if (child_name = 'confidentialityIndicator') Then
     list.add(self.link, 'confidentialityIndicator', FConfidentialityIndicator.Link);
end;

procedure TFhirMedicinalProductDefinitionOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableReference', false, TFhirCodeableReference, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'effectiveDate', 'Period', false, TFhirPeriod, FEffectiveDate.Link));
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', true, TFhirReference, FOrganizationList.Link));
  oList.add(TFHIRProperty.create(self, 'confidentialityIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FConfidentialityIndicator.Link));
end;

function TFhirMedicinalProductDefinitionOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'effectiveDate') then
  begin
    EffectiveDate := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    OrganizationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'confidentialityIndicator') then
  begin
    ConfidentialityIndicator := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'organization') then OrganizationList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMedicinalProductDefinitionOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableReference.create()
  else if (propName = 'effectiveDate') then result := TFhirPeriod.create()
  else if (propName = 'organization') then result := OrganizationList.new()
  else if (propName = 'confidentialityIndicator') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableReference'
  else if (propName = 'effectiveDate') then result := 'Period'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'confidentialityIndicator') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'effectiveDate') then EffectiveDateElement := nil
  else if (propName = 'organization') then deletePropertyValue('organization', OrganizationList, value)
  else if (propName = 'confidentialityIndicator') then ConfidentialityIndicatorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableReference
  else if (propName = 'effectiveDate') then EffectiveDateElement := new as TFhirPeriod
  else if (propName = 'organization') then replacePropertyValue('organization', OrganizationList, existing, new)
  else if (propName = 'confidentialityIndicator') then ConfidentialityIndicatorElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'organization') then OrganizationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionOperation.fhirType : string;
begin
  result := 'MedicinalProductDefinition.operation';
end;

function TFhirMedicinalProductDefinitionOperation.Link : TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation(inherited Link);
end;

function TFhirMedicinalProductDefinitionOperation.Clone : TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation(inherited Clone);
end;

function TFhirMedicinalProductDefinitionOperation.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionOperation)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionOperation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(effectiveDateElement, o.effectiveDateElement, true) and 
      compareDeep(organizationList, o.organizationList, true) and compareDeep(confidentialityIndicatorElement, o.confidentialityIndicatorElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FEffectiveDate) and isEmptyProp(ForganizationList) and isEmptyProp(FConfidentialityIndicator);
end;

procedure TFhirMedicinalProductDefinitionOperation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('effectiveDate');
  fields.add('organization');
  fields.add('confidentialityIndicator');
end;

function TFhirMedicinalProductDefinitionOperation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FOrganizationList.sizeInBytes(magic));
end;

procedure TFhirMedicinalProductDefinitionOperation.SetType_(value : TFhirCodeableReference);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicinalProductDefinitionOperation.SetEffectiveDate(value : TFhirPeriod);
begin
  FEffectiveDate.free;
  FEffectiveDate := value;
end;

function TFhirMedicinalProductDefinitionOperation.GetOrganizationList : TFhirReferenceList;
begin
  if FOrganizationList = nil then
    FOrganizationList := TFhirReferenceList.Create;
  result := FOrganizationList;
end;

function TFhirMedicinalProductDefinitionOperation.GetHasOrganizationList : boolean;
begin
  result := (FOrganizationList <> nil) and (FOrganizationList.count > 0);
end;

procedure TFhirMedicinalProductDefinitionOperation.SetConfidentialityIndicator(value : TFhirCodeableConcept);
begin
  FConfidentialityIndicator.free;
  FConfidentialityIndicator := value;
end;

{ TFhirMedicinalProductDefinitionOperationListEnumerator }

constructor TFhirMedicinalProductDefinitionOperationListEnumerator.Create(list : TFhirMedicinalProductDefinitionOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionOperationListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionOperation;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionOperationList }

function TFhirMedicinalProductDefinitionOperationList.AddItem(value: TFhirMedicinalProductDefinitionOperation): TFhirMedicinalProductDefinitionOperation;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionOperation');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionOperationList.Append: TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionOperationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionOperationList.GetEnumerator : TFhirMedicinalProductDefinitionOperationListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionOperationListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionOperationList.Clone: TFhirMedicinalProductDefinitionOperationList;
begin
  result := TFhirMedicinalProductDefinitionOperationList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionOperationList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionOperation;
end;
function TFhirMedicinalProductDefinitionOperationList.IndexOf(value: TFhirMedicinalProductDefinitionOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionOperationList.Insert(index: Integer): TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionOperationList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionOperation);
begin
  assert(value is TFhirMedicinalProductDefinitionOperation);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionOperationList.Item(index: Integer): TFhirMedicinalProductDefinitionOperation;
begin
  result := TFhirMedicinalProductDefinitionOperation(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionOperationList.Link: TFhirMedicinalProductDefinitionOperationList;
begin
  result := TFhirMedicinalProductDefinitionOperationList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionOperationList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionOperation);
begin
  assert(value is TFhirMedicinalProductDefinitionOperation);
  FhirMedicinalProductDefinitionOperations[index] := value;
end;

procedure TFhirMedicinalProductDefinitionOperationList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionOperation);
begin
  assert(value is TFhirMedicinalProductDefinitionOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinitionCharacteristic }

constructor TFhirMedicinalProductDefinitionCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinitionCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirMedicinalProductDefinitionCharacteristic(oSource).type_.Clone;
  value := TFhirMedicinalProductDefinitionCharacteristic(oSource).value.Clone;
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirMedicinalProductDefinitionCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicinalProductDefinitionCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinitionCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinitionCharacteristic.fhirType : string;
begin
  result := 'MedicinalProductDefinition.characteristic';
end;

function TFhirMedicinalProductDefinitionCharacteristic.Link : TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic(inherited Link);
end;

function TFhirMedicinalProductDefinitionCharacteristic.Clone : TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinitionCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinitionCharacteristic)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinitionCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMedicinalProductDefinitionCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirMedicinalProductDefinitionCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicinalProductDefinitionCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirMedicinalProductDefinitionCharacteristicListEnumerator }

constructor TFhirMedicinalProductDefinitionCharacteristicListEnumerator.Create(list : TFhirMedicinalProductDefinitionCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionCharacteristicListEnumerator.GetCurrent : TFhirMedicinalProductDefinitionCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionCharacteristicList }

function TFhirMedicinalProductDefinitionCharacteristicList.AddItem(value: TFhirMedicinalProductDefinitionCharacteristic): TFhirMedicinalProductDefinitionCharacteristic;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinitionCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinitionCharacteristic');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Append: TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionCharacteristicList.GetEnumerator : TFhirMedicinalProductDefinitionCharacteristicListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionCharacteristicListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Clone: TFhirMedicinalProductDefinitionCharacteristicList;
begin
  result := TFhirMedicinalProductDefinitionCharacteristicList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionCharacteristicList.GetItemN(index: Integer): TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic;
end;
function TFhirMedicinalProductDefinitionCharacteristicList.IndexOf(value: TFhirMedicinalProductDefinitionCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Insert(index: Integer): TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinitionCharacteristic);
begin
  assert(value is TFhirMedicinalProductDefinitionCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Item(index: Integer): TFhirMedicinalProductDefinitionCharacteristic;
begin
  result := TFhirMedicinalProductDefinitionCharacteristic(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionCharacteristicList.Link: TFhirMedicinalProductDefinitionCharacteristicList;
begin
  result := TFhirMedicinalProductDefinitionCharacteristicList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinitionCharacteristic);
begin
  assert(value is TFhirMedicinalProductDefinitionCharacteristic);
  FhirMedicinalProductDefinitionCharacteristics[index] := value;
end;

procedure TFhirMedicinalProductDefinitionCharacteristicList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinitionCharacteristic);
begin
  assert(value is TFhirMedicinalProductDefinitionCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicinalProductDefinition }

constructor TFhirMedicinalProductDefinition.Create;
begin
  inherited;
end;

destructor TFhirMedicinalProductDefinition.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FDomain.free;
  FVersion.free;
  FStatus.free;
  FStatusDate.free;
  FDescription.free;
  FCombinedPharmaceuticalDoseForm.free;
  FRouteList.Free;
  FIndication.free;
  FLegalStatusOfSupply.free;
  FAdditionalMonitoringIndicator.free;
  FSpecialMeasuresList.Free;
  FPediatricUseIndicator.free;
  FClassificationList.Free;
  FMarketingStatusList.Free;
  FPackagedMedicinalProductList.Free;
  FIngredientList.Free;
  FImpurityList.Free;
  FAttachedDocumentList.Free;
  FMasterFileList.Free;
  FContactList.Free;
  FClinicalTrialList.Free;
  FCodeList.Free;
  FNameList.Free;
  FCrossReferenceList.Free;
  FOperationList.Free;
  FCharacteristicList.Free;
  inherited;
end;

procedure TFhirMedicinalProductDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicinalProductDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicinalProductDefinition(oSource).FIdentifierList);
  end;
  type_ := TFhirMedicinalProductDefinition(oSource).type_.Clone;
  domain := TFhirMedicinalProductDefinition(oSource).domain.Clone;
  versionElement := TFhirMedicinalProductDefinition(oSource).versionElement.Clone;
  status := TFhirMedicinalProductDefinition(oSource).status.Clone;
  statusDateElement := TFhirMedicinalProductDefinition(oSource).statusDateElement.Clone;
  descriptionElement := TFhirMedicinalProductDefinition(oSource).descriptionElement.Clone;
  combinedPharmaceuticalDoseForm := TFhirMedicinalProductDefinition(oSource).combinedPharmaceuticalDoseForm.Clone;
  if (TFhirMedicinalProductDefinition(oSource).FRouteList = nil) then
  begin
    FRouteList.free;
    FRouteList := nil;
  end
  else
  begin
    if FRouteList = nil then
      FRouteList := TFhirCodeableConceptList.Create;
    FRouteList.Assign(TFhirMedicinalProductDefinition(oSource).FRouteList);
  end;
  indicationElement := TFhirMedicinalProductDefinition(oSource).indicationElement.Clone;
  legalStatusOfSupply := TFhirMedicinalProductDefinition(oSource).legalStatusOfSupply.Clone;
  additionalMonitoringIndicator := TFhirMedicinalProductDefinition(oSource).additionalMonitoringIndicator.Clone;
  if (TFhirMedicinalProductDefinition(oSource).FSpecialMeasuresList = nil) then
  begin
    FSpecialMeasuresList.free;
    FSpecialMeasuresList := nil;
  end
  else
  begin
    if FSpecialMeasuresList = nil then
      FSpecialMeasuresList := TFhirCodeableConceptList.Create;
    FSpecialMeasuresList.Assign(TFhirMedicinalProductDefinition(oSource).FSpecialMeasuresList);
  end;
  pediatricUseIndicator := TFhirMedicinalProductDefinition(oSource).pediatricUseIndicator.Clone;
  if (TFhirMedicinalProductDefinition(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirMedicinalProductDefinition(oSource).FClassificationList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FMarketingStatusList = nil) then
  begin
    FMarketingStatusList.free;
    FMarketingStatusList := nil;
  end
  else
  begin
    if FMarketingStatusList = nil then
      FMarketingStatusList := TFhirMarketingStatusList.Create;
    FMarketingStatusList.Assign(TFhirMedicinalProductDefinition(oSource).FMarketingStatusList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FPackagedMedicinalProductList = nil) then
  begin
    FPackagedMedicinalProductList.free;
    FPackagedMedicinalProductList := nil;
  end
  else
  begin
    if FPackagedMedicinalProductList = nil then
      FPackagedMedicinalProductList := TFhirCodeableConceptList.Create;
    FPackagedMedicinalProductList.Assign(TFhirMedicinalProductDefinition(oSource).FPackagedMedicinalProductList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirCodeableConceptList.Create;
    FIngredientList.Assign(TFhirMedicinalProductDefinition(oSource).FIngredientList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FImpurityList = nil) then
  begin
    FImpurityList.free;
    FImpurityList := nil;
  end
  else
  begin
    if FImpurityList = nil then
      FImpurityList := TFhirCodeableReferenceList.Create;
    FImpurityList.Assign(TFhirMedicinalProductDefinition(oSource).FImpurityList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FAttachedDocumentList = nil) then
  begin
    FAttachedDocumentList.free;
    FAttachedDocumentList := nil;
  end
  else
  begin
    if FAttachedDocumentList = nil then
      FAttachedDocumentList := TFhirReferenceList.Create;
    FAttachedDocumentList.Assign(TFhirMedicinalProductDefinition(oSource).FAttachedDocumentList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FMasterFileList = nil) then
  begin
    FMasterFileList.free;
    FMasterFileList := nil;
  end
  else
  begin
    if FMasterFileList = nil then
      FMasterFileList := TFhirReferenceList.Create;
    FMasterFileList.Assign(TFhirMedicinalProductDefinition(oSource).FMasterFileList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirMedicinalProductDefinitionContactList.Create;
    FContactList.Assign(TFhirMedicinalProductDefinition(oSource).FContactList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FClinicalTrialList = nil) then
  begin
    FClinicalTrialList.free;
    FClinicalTrialList := nil;
  end
  else
  begin
    if FClinicalTrialList = nil then
      FClinicalTrialList := TFhirReferenceList.Create;
    FClinicalTrialList.Assign(TFhirMedicinalProductDefinition(oSource).FClinicalTrialList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodingList.Create;
    FCodeList.Assign(TFhirMedicinalProductDefinition(oSource).FCodeList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirMedicinalProductDefinitionNameList.Create;
    FNameList.Assign(TFhirMedicinalProductDefinition(oSource).FNameList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FCrossReferenceList = nil) then
  begin
    FCrossReferenceList.free;
    FCrossReferenceList := nil;
  end
  else
  begin
    if FCrossReferenceList = nil then
      FCrossReferenceList := TFhirMedicinalProductDefinitionCrossReferenceList.Create;
    FCrossReferenceList.Assign(TFhirMedicinalProductDefinition(oSource).FCrossReferenceList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FOperationList = nil) then
  begin
    FOperationList.free;
    FOperationList := nil;
  end
  else
  begin
    if FOperationList = nil then
      FOperationList := TFhirMedicinalProductDefinitionOperationList.Create;
    FOperationList.Assign(TFhirMedicinalProductDefinition(oSource).FOperationList);
  end;
  if (TFhirMedicinalProductDefinition(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirMedicinalProductDefinitionCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirMedicinalProductDefinition(oSource).FCharacteristicList);
  end;
end;

function TFhirMedicinalProductDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtMedicinalProductDefinition;
end;

procedure TFhirMedicinalProductDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'domain') Then
     list.add(self.link, 'domain', FDomain.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'combinedPharmaceuticalDoseForm') Then
     list.add(self.link, 'combinedPharmaceuticalDoseForm', FCombinedPharmaceuticalDoseForm.Link);
  if (child_name = 'route') Then
    list.addAll(self, 'route', FRouteList);
  if (child_name = 'indication') Then
     list.add(self.link, 'indication', FIndication.Link);
  if (child_name = 'legalStatusOfSupply') Then
     list.add(self.link, 'legalStatusOfSupply', FLegalStatusOfSupply.Link);
  if (child_name = 'additionalMonitoringIndicator') Then
     list.add(self.link, 'additionalMonitoringIndicator', FAdditionalMonitoringIndicator.Link);
  if (child_name = 'specialMeasures') Then
    list.addAll(self, 'specialMeasures', FSpecialMeasuresList);
  if (child_name = 'pediatricUseIndicator') Then
     list.add(self.link, 'pediatricUseIndicator', FPediatricUseIndicator.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'marketingStatus') Then
    list.addAll(self, 'marketingStatus', FMarketingStatusList);
  if (child_name = 'packagedMedicinalProduct') Then
    list.addAll(self, 'packagedMedicinalProduct', FPackagedMedicinalProductList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'impurity') Then
    list.addAll(self, 'impurity', FImpurityList);
  if (child_name = 'attachedDocument') Then
    list.addAll(self, 'attachedDocument', FAttachedDocumentList);
  if (child_name = 'masterFile') Then
    list.addAll(self, 'masterFile', FMasterFileList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'clinicalTrial') Then
    list.addAll(self, 'clinicalTrial', FClinicalTrialList);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'crossReference') Then
    list.addAll(self, 'crossReference', FCrossReferenceList);
  if (child_name = 'operation') Then
    list.addAll(self, 'operation', FOperationList);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
end;

procedure TFhirMedicinalProductDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', false, TFhirCodeableConcept, FDomain.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'combinedPharmaceuticalDoseForm', 'CodeableConcept', false, TFhirCodeableConcept, FCombinedPharmaceuticalDoseForm.Link));
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', true, TFhirCodeableConcept, FRouteList.Link));
  oList.add(TFHIRProperty.create(self, 'indication', 'markdown', false, TFhirMarkdown, FIndication.Link));
  oList.add(TFHIRProperty.create(self, 'legalStatusOfSupply', 'CodeableConcept', false, TFhirCodeableConcept, FLegalStatusOfSupply.Link));
  oList.add(TFHIRProperty.create(self, 'additionalMonitoringIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FAdditionalMonitoringIndicator.Link));
  oList.add(TFHIRProperty.create(self, 'specialMeasures', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialMeasuresList.Link));
  oList.add(TFHIRProperty.create(self, 'pediatricUseIndicator', 'CodeableConcept', false, TFhirCodeableConcept, FPediatricUseIndicator.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link));
  oList.add(TFHIRProperty.create(self, 'marketingStatus', 'MarketingStatus', true, TFhirMarketingStatus, FMarketingStatusList.Link));
  oList.add(TFHIRProperty.create(self, 'packagedMedicinalProduct', 'CodeableConcept', true, TFhirCodeableConcept, FPackagedMedicinalProductList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'CodeableConcept', true, TFhirCodeableConcept, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'impurity', 'CodeableReference', true, TFhirCodeableReference, FImpurityList.Link));
  oList.add(TFHIRProperty.create(self, 'attachedDocument', 'Reference', true, TFhirReference, FAttachedDocumentList.Link));
  oList.add(TFHIRProperty.create(self, 'masterFile', 'Reference', true, TFhirReference, FMasterFileList.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'BackboneElement', true, TFhirMedicinalProductDefinitionContact, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'clinicalTrial', 'Reference', true, TFhirReference, FClinicalTrialList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'Coding', true, TFhirCoding, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'BackboneElement', true, TFhirMedicinalProductDefinitionName, FNameList.Link));
  oList.add(TFHIRProperty.create(self, 'crossReference', 'BackboneElement', true, TFhirMedicinalProductDefinitionCrossReference, FCrossReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'operation', 'BackboneElement', true, TFhirMedicinalProductDefinitionOperation, FOperationList.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirMedicinalProductDefinitionCharacteristic, FCharacteristicList.Link));
end;

function TFhirMedicinalProductDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    Domain := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'combinedPharmaceuticalDoseForm') then
  begin
    CombinedPharmaceuticalDoseForm := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    RouteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'legalStatusOfSupply') then
  begin
    LegalStatusOfSupply := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'additionalMonitoringIndicator') then
  begin
    AdditionalMonitoringIndicator := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'specialMeasures') then
  begin
    SpecialMeasuresList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'pediatricUseIndicator') then
  begin
    PediatricUseIndicator := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'marketingStatus') then
  begin
    MarketingStatusList.add(propValue as TFhirMarketingStatus);
    result := propValue;
  end
  else if (propName = 'packagedMedicinalProduct') then
  begin
    PackagedMedicinalProductList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'impurity') then
  begin
    ImpurityList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'attachedDocument') then
  begin
    AttachedDocumentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'masterFile') then
  begin
    MasterFileList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirMedicinalProductDefinitionContact);
    result := propValue;
  end
  else if (propName = 'clinicalTrial') then
  begin
    ClinicalTrialList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirMedicinalProductDefinitionName);
    result := propValue;
  end
  else if (propName = 'crossReference') then
  begin
    CrossReferenceList.add(propValue as TFhirMedicinalProductDefinitionCrossReference);
    result := propValue;
  end
  else if (propName = 'operation') then
  begin
    OperationList.add(propValue as TFhirMedicinalProductDefinitionOperation);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirMedicinalProductDefinitionCharacteristic);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicinalProductDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'route') then RouteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialMeasures') then SpecialMeasuresList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'marketingStatus') then MarketingStatusList.insertItem(index, propValue as TFhirMarketingStatus)
  else if (propName = 'packagedMedicinalProduct') then PackagedMedicinalProductList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'impurity') then ImpurityList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'attachedDocument') then AttachedDocumentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'masterFile') then MasterFileList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirMedicinalProductDefinitionContact)
  else if (propName = 'clinicalTrial') then ClinicalTrialList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirMedicinalProductDefinitionName)
  else if (propName = 'crossReference') then CrossReferenceList.insertItem(index, propValue as TFhirMedicinalProductDefinitionCrossReference)
  else if (propName = 'operation') then OperationList.insertItem(index, propValue as TFhirMedicinalProductDefinitionOperation)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirMedicinalProductDefinitionCharacteristic)
  else inherited;
end;

function TFhirMedicinalProductDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'domain') then result := TFhirCodeableConcept.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'combinedPharmaceuticalDoseForm') then result := TFhirCodeableConcept.create()
  else if (propName = 'route') then result := RouteList.new()
  else if (propName = 'indication') then result := TFhirMarkdown.create()
  else if (propName = 'legalStatusOfSupply') then result := TFhirCodeableConcept.create()
  else if (propName = 'additionalMonitoringIndicator') then result := TFhirCodeableConcept.create()
  else if (propName = 'specialMeasures') then result := SpecialMeasuresList.new()
  else if (propName = 'pediatricUseIndicator') then result := TFhirCodeableConcept.create()
  else if (propName = 'classification') then result := ClassificationList.new()
  else if (propName = 'marketingStatus') then result := MarketingStatusList.new()
  else if (propName = 'packagedMedicinalProduct') then result := PackagedMedicinalProductList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'impurity') then result := ImpurityList.new()
  else if (propName = 'attachedDocument') then result := AttachedDocumentList.new()
  else if (propName = 'masterFile') then result := MasterFileList.new()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'clinicalTrial') then result := ClinicalTrialList.new()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'crossReference') then result := CrossReferenceList.new()
  else if (propName = 'operation') then result := OperationList.new()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicinalProductDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'combinedPharmaceuticalDoseForm') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'indication') then result := 'markdown'
  else if (propName = 'legalStatusOfSupply') then result := 'CodeableConcept'
  else if (propName = 'additionalMonitoringIndicator') then result := 'CodeableConcept'
  else if (propName = 'specialMeasures') then result := 'CodeableConcept'
  else if (propName = 'pediatricUseIndicator') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'marketingStatus') then result := 'MarketingStatus'
  else if (propName = 'packagedMedicinalProduct') then result := 'CodeableConcept'
  else if (propName = 'ingredient') then result := 'CodeableConcept'
  else if (propName = 'impurity') then result := 'CodeableReference'
  else if (propName = 'attachedDocument') then result := 'Reference'
  else if (propName = 'masterFile') then result := 'Reference'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'clinicalTrial') then result := 'Reference'
  else if (propName = 'code') then result := 'Coding'
  else if (propName = 'name') then result := 'BackboneElement'
  else if (propName = 'crossReference') then result := 'BackboneElement'
  else if (propName = 'operation') then result := 'BackboneElement'
  else if (propName = 'characteristic') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicinalProductDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'domain') then DomainElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'combinedPharmaceuticalDoseForm') then CombinedPharmaceuticalDoseFormElement := nil
  else if (propName = 'route') then deletePropertyValue('route', RouteList, value)
  else if (propName = 'indication') then IndicationElement := nil
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := nil
  else if (propName = 'additionalMonitoringIndicator') then AdditionalMonitoringIndicatorElement := nil
  else if (propName = 'specialMeasures') then deletePropertyValue('specialMeasures', SpecialMeasuresList, value)
  else if (propName = 'pediatricUseIndicator') then PediatricUseIndicatorElement := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else if (propName = 'marketingStatus') then deletePropertyValue('marketingStatus', MarketingStatusList, value)
  else if (propName = 'packagedMedicinalProduct') then deletePropertyValue('packagedMedicinalProduct', PackagedMedicinalProductList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'impurity') then deletePropertyValue('impurity', ImpurityList, value)
  else if (propName = 'attachedDocument') then deletePropertyValue('attachedDocument', AttachedDocumentList, value)
  else if (propName = 'masterFile') then deletePropertyValue('masterFile', MasterFileList, value)
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'clinicalTrial') then deletePropertyValue('clinicalTrial', ClinicalTrialList, value)
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'crossReference') then deletePropertyValue('crossReference', CrossReferenceList, value)
  else if (propName = 'operation') then deletePropertyValue('operation', OperationList, value)
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicinalProductDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'domain') then DomainElement := new as TFhirCodeableConcept
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'combinedPharmaceuticalDoseForm') then CombinedPharmaceuticalDoseFormElement := new as TFhirCodeableConcept
  else if (propName = 'route') then replacePropertyValue('route', RouteList, existing, new)
  else if (propName = 'indication') then IndicationElement := asMarkdown(new)
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyElement := new as TFhirCodeableConcept
  else if (propName = 'additionalMonitoringIndicator') then AdditionalMonitoringIndicatorElement := new as TFhirCodeableConcept
  else if (propName = 'specialMeasures') then replacePropertyValue('specialMeasures', SpecialMeasuresList, existing, new)
  else if (propName = 'pediatricUseIndicator') then PediatricUseIndicatorElement := new as TFhirCodeableConcept
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else if (propName = 'marketingStatus') then replacePropertyValue('marketingStatus', MarketingStatusList, existing, new)
  else if (propName = 'packagedMedicinalProduct') then replacePropertyValue('packagedMedicinalProduct', PackagedMedicinalProductList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'impurity') then replacePropertyValue('impurity', ImpurityList, existing, new)
  else if (propName = 'attachedDocument') then replacePropertyValue('attachedDocument', AttachedDocumentList, existing, new)
  else if (propName = 'masterFile') then replacePropertyValue('masterFile', MasterFileList, existing, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'clinicalTrial') then replacePropertyValue('clinicalTrial', ClinicalTrialList, existing, new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'crossReference') then replacePropertyValue('crossReference', CrossReferenceList, existing, new)
  else if (propName = 'operation') then replacePropertyValue('operation', OperationList, existing, new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicinalProductDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'route') then RouteList.move(source, destination)
  else if (propName = 'specialMeasures') then SpecialMeasuresList.move(source, destination)
  else if (propName = 'classification') then ClassificationList.move(source, destination)
  else if (propName = 'marketingStatus') then MarketingStatusList.move(source, destination)
  else if (propName = 'packagedMedicinalProduct') then PackagedMedicinalProductList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'impurity') then ImpurityList.move(source, destination)
  else if (propName = 'attachedDocument') then AttachedDocumentList.move(source, destination)
  else if (propName = 'masterFile') then MasterFileList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'clinicalTrial') then ClinicalTrialList.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'crossReference') then CrossReferenceList.move(source, destination)
  else if (propName = 'operation') then OperationList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicinalProductDefinition.fhirType : string;
begin
  result := 'MedicinalProductDefinition';
end;

function TFhirMedicinalProductDefinition.Link : TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(inherited Link);
end;

function TFhirMedicinalProductDefinition.Clone : TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(inherited Clone);
end;

function TFhirMedicinalProductDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirMedicinalProductDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicinalProductDefinition)) then
    result := false
  else
  begin
    o := TFhirMedicinalProductDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(domainElement, o.domainElement, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusDateElement, o.statusDateElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(combinedPharmaceuticalDoseFormElement, o.combinedPharmaceuticalDoseFormElement, true) and 
      compareDeep(routeList, o.routeList, true) and compareDeep(indicationElement, o.indicationElement, true) and 
      compareDeep(legalStatusOfSupplyElement, o.legalStatusOfSupplyElement, true) and 
      compareDeep(additionalMonitoringIndicatorElement, o.additionalMonitoringIndicatorElement, true) and 
      compareDeep(specialMeasuresList, o.specialMeasuresList, true) and compareDeep(pediatricUseIndicatorElement, o.pediatricUseIndicatorElement, true) and 
      compareDeep(classificationList, o.classificationList, true) and compareDeep(marketingStatusList, o.marketingStatusList, true) and 
      compareDeep(packagedMedicinalProductList, o.packagedMedicinalProductList, true) and 
      compareDeep(ingredientList, o.ingredientList, true) and compareDeep(impurityList, o.impurityList, true) and 
      compareDeep(attachedDocumentList, o.attachedDocumentList, true) and compareDeep(masterFileList, o.masterFileList, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(clinicalTrialList, o.clinicalTrialList, true) and 
      compareDeep(codeList, o.codeList, true) and compareDeep(nameList, o.nameList, true) and 
      compareDeep(crossReferenceList, o.crossReferenceList, true) and compareDeep(operationList, o.operationList, true) and 
      compareDeep(characteristicList, o.characteristicList, true);
  end;
end;

function TFhirMedicinalProductDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FDomain) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FDescription) and isEmptyProp(FCombinedPharmaceuticalDoseForm) and isEmptyProp(FrouteList) and isEmptyProp(FIndication) and isEmptyProp(FLegalStatusOfSupply) and isEmptyProp(FAdditionalMonitoringIndicator) and isEmptyProp(FspecialMeasuresList) and isEmptyProp(FPediatricUseIndicator) and isEmptyProp(FclassificationList) and isEmptyProp(FmarketingStatusList) and isEmptyProp(FpackagedMedicinalProductList) and isEmptyProp(FingredientList) and isEmptyProp(FimpurityList) and isEmptyProp(FattachedDocumentList) and isEmptyProp(FmasterFileList) and isEmptyProp(FcontactList) and isEmptyProp(FclinicalTrialList) and isEmptyProp(FcodeList) and isEmptyProp(FnameList) and isEmptyProp(FcrossReferenceList) and isEmptyProp(FoperationList) and isEmptyProp(FcharacteristicList);
end;

procedure TFhirMedicinalProductDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('domain');
  fields.add('version');
  fields.add('status');
  fields.add('statusDate');
  fields.add('description');
  fields.add('combinedPharmaceuticalDoseForm');
  fields.add('route');
  fields.add('indication');
  fields.add('legalStatusOfSupply');
  fields.add('additionalMonitoringIndicator');
  fields.add('specialMeasures');
  fields.add('pediatricUseIndicator');
  fields.add('classification');
  fields.add('marketingStatus');
  fields.add('packagedMedicinalProduct');
  fields.add('ingredient');
  fields.add('impurity');
  fields.add('attachedDocument');
  fields.add('masterFile');
  fields.add('contact');
  fields.add('clinicalTrial');
  fields.add('code');
  fields.add('name');
  fields.add('crossReference');
  fields.add('operation');
  fields.add('characteristic');
end;

function TFhirMedicinalProductDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRouteList.sizeInBytes(magic));
  inc(result, FSpecialMeasuresList.sizeInBytes(magic));
  inc(result, FClassificationList.sizeInBytes(magic));
  inc(result, FMarketingStatusList.sizeInBytes(magic));
  inc(result, FPackagedMedicinalProductList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FImpurityList.sizeInBytes(magic));
  inc(result, FAttachedDocumentList.sizeInBytes(magic));
  inc(result, FMasterFileList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FClinicalTrialList.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FCrossReferenceList.sizeInBytes(magic));
  inc(result, FOperationList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
end;

function TFhirMedicinalProductDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicinalProductDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedicinalProductDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicinalProductDefinition.SetDomain(value : TFhirCodeableConcept);
begin
  FDomain.free;
  FDomain := value;
end;

procedure TFhirMedicinalProductDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirMedicinalProductDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirMedicinalProductDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirMedicinalProductDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirMedicinalProductDefinition.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirMedicinalProductDefinition.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirMedicinalProductDefinition.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

procedure TFhirMedicinalProductDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirMedicinalProductDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirMedicinalProductDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirMedicinalProductDefinition.SetCombinedPharmaceuticalDoseForm(value : TFhirCodeableConcept);
begin
  FCombinedPharmaceuticalDoseForm.free;
  FCombinedPharmaceuticalDoseForm := value;
end;

function TFhirMedicinalProductDefinition.GetRouteList : TFhirCodeableConceptList;
begin
  if FRouteList = nil then
    FRouteList := TFhirCodeableConceptList.Create;
  result := FRouteList;
end;

function TFhirMedicinalProductDefinition.GetHasRouteList : boolean;
begin
  result := (FRouteList <> nil) and (FRouteList.count > 0);
end;

procedure TFhirMedicinalProductDefinition.SetIndication(value : TFhirMarkdown);
begin
  FIndication.free;
  FIndication := value;
end;

function TFhirMedicinalProductDefinition.GetIndicationST : String;
begin
  if FIndication = nil then
    result := ''
  else
    result := FIndication.value;
end;

procedure TFhirMedicinalProductDefinition.SetIndicationST(value : String);
begin
  if value <> '' then
  begin
    if FIndication = nil then
      FIndication := TFhirMarkdown.create;
    FIndication.value := value
  end
  else if FIndication <> nil then
    FIndication.value := '';
end;

procedure TFhirMedicinalProductDefinition.SetLegalStatusOfSupply(value : TFhirCodeableConcept);
begin
  FLegalStatusOfSupply.free;
  FLegalStatusOfSupply := value;
end;

procedure TFhirMedicinalProductDefinition.SetAdditionalMonitoringIndicator(value : TFhirCodeableConcept);
begin
  FAdditionalMonitoringIndicator.free;
  FAdditionalMonitoringIndicator := value;
end;

function TFhirMedicinalProductDefinition.GetSpecialMeasuresList : TFhirCodeableConceptList;
begin
  if FSpecialMeasuresList = nil then
    FSpecialMeasuresList := TFhirCodeableConceptList.Create;
  result := FSpecialMeasuresList;
end;

function TFhirMedicinalProductDefinition.GetHasSpecialMeasuresList : boolean;
begin
  result := (FSpecialMeasuresList <> nil) and (FSpecialMeasuresList.count > 0);
end;

procedure TFhirMedicinalProductDefinition.SetPediatricUseIndicator(value : TFhirCodeableConcept);
begin
  FPediatricUseIndicator.free;
  FPediatricUseIndicator := value;
end;

function TFhirMedicinalProductDefinition.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirMedicinalProductDefinition.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetMarketingStatusList : TFhirMarketingStatusList;
begin
  if FMarketingStatusList = nil then
    FMarketingStatusList := TFhirMarketingStatusList.Create;
  result := FMarketingStatusList;
end;

function TFhirMedicinalProductDefinition.GetHasMarketingStatusList : boolean;
begin
  result := (FMarketingStatusList <> nil) and (FMarketingStatusList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetPackagedMedicinalProductList : TFhirCodeableConceptList;
begin
  if FPackagedMedicinalProductList = nil then
    FPackagedMedicinalProductList := TFhirCodeableConceptList.Create;
  result := FPackagedMedicinalProductList;
end;

function TFhirMedicinalProductDefinition.GetHasPackagedMedicinalProductList : boolean;
begin
  result := (FPackagedMedicinalProductList <> nil) and (FPackagedMedicinalProductList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetIngredientList : TFhirCodeableConceptList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirCodeableConceptList.Create;
  result := FIngredientList;
end;

function TFhirMedicinalProductDefinition.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetImpurityList : TFhirCodeableReferenceList;
begin
  if FImpurityList = nil then
    FImpurityList := TFhirCodeableReferenceList.Create;
  result := FImpurityList;
end;

function TFhirMedicinalProductDefinition.GetHasImpurityList : boolean;
begin
  result := (FImpurityList <> nil) and (FImpurityList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetAttachedDocumentList : TFhirReferenceList;
begin
  if FAttachedDocumentList = nil then
    FAttachedDocumentList := TFhirReferenceList.Create;
  result := FAttachedDocumentList;
end;

function TFhirMedicinalProductDefinition.GetHasAttachedDocumentList : boolean;
begin
  result := (FAttachedDocumentList <> nil) and (FAttachedDocumentList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetMasterFileList : TFhirReferenceList;
begin
  if FMasterFileList = nil then
    FMasterFileList := TFhirReferenceList.Create;
  result := FMasterFileList;
end;

function TFhirMedicinalProductDefinition.GetHasMasterFileList : boolean;
begin
  result := (FMasterFileList <> nil) and (FMasterFileList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetContactList : TFhirMedicinalProductDefinitionContactList;
begin
  if FContactList = nil then
    FContactList := TFhirMedicinalProductDefinitionContactList.Create;
  result := FContactList;
end;

function TFhirMedicinalProductDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetClinicalTrialList : TFhirReferenceList;
begin
  if FClinicalTrialList = nil then
    FClinicalTrialList := TFhirReferenceList.Create;
  result := FClinicalTrialList;
end;

function TFhirMedicinalProductDefinition.GetHasClinicalTrialList : boolean;
begin
  result := (FClinicalTrialList <> nil) and (FClinicalTrialList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetCodeList : TFhirCodingList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodingList.Create;
  result := FCodeList;
end;

function TFhirMedicinalProductDefinition.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetNameList : TFhirMedicinalProductDefinitionNameList;
begin
  if FNameList = nil then
    FNameList := TFhirMedicinalProductDefinitionNameList.Create;
  result := FNameList;
end;

function TFhirMedicinalProductDefinition.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetCrossReferenceList : TFhirMedicinalProductDefinitionCrossReferenceList;
begin
  if FCrossReferenceList = nil then
    FCrossReferenceList := TFhirMedicinalProductDefinitionCrossReferenceList.Create;
  result := FCrossReferenceList;
end;

function TFhirMedicinalProductDefinition.GetHasCrossReferenceList : boolean;
begin
  result := (FCrossReferenceList <> nil) and (FCrossReferenceList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetOperationList : TFhirMedicinalProductDefinitionOperationList;
begin
  if FOperationList = nil then
    FOperationList := TFhirMedicinalProductDefinitionOperationList.Create;
  result := FOperationList;
end;

function TFhirMedicinalProductDefinition.GetHasOperationList : boolean;
begin
  result := (FOperationList <> nil) and (FOperationList.count > 0);
end;

function TFhirMedicinalProductDefinition.GetCharacteristicList : TFhirMedicinalProductDefinitionCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirMedicinalProductDefinitionCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirMedicinalProductDefinition.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

{ TFhirMedicinalProductDefinitionListEnumerator }

constructor TFhirMedicinalProductDefinitionListEnumerator.Create(list : TFhirMedicinalProductDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicinalProductDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicinalProductDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicinalProductDefinitionListEnumerator.GetCurrent : TFhirMedicinalProductDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirMedicinalProductDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicinalProductDefinitionList }

function TFhirMedicinalProductDefinitionList.AddItem(value: TFhirMedicinalProductDefinition): TFhirMedicinalProductDefinition;
begin
  assert(value.ClassName = 'TFhirMedicinalProductDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicinalProductDefinition');
  add(value);
  result := value;
end;

function TFhirMedicinalProductDefinitionList.Append: TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicinalProductDefinitionList.GetEnumerator : TFhirMedicinalProductDefinitionListEnumerator;
begin
  result := TFhirMedicinalProductDefinitionListEnumerator.Create(self.link);
end;

function TFhirMedicinalProductDefinitionList.Clone: TFhirMedicinalProductDefinitionList;
begin
  result := TFhirMedicinalProductDefinitionList(inherited Clone);
end;

function TFhirMedicinalProductDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicinalProductDefinitionList.GetItemN(index: Integer): TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicinalProductDefinition;
end;
function TFhirMedicinalProductDefinitionList.IndexOf(value: TFhirMedicinalProductDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicinalProductDefinitionList.Insert(index: Integer): TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicinalProductDefinitionList.InsertItem(index: Integer; value: TFhirMedicinalProductDefinition);
begin
  assert(value is TFhirMedicinalProductDefinition);
  Inherited Insert(index, value);
end;

function TFhirMedicinalProductDefinitionList.Item(index: Integer): TFhirMedicinalProductDefinition;
begin
  result := TFhirMedicinalProductDefinition(ObjectByIndex[index]);
end;

function TFhirMedicinalProductDefinitionList.Link: TFhirMedicinalProductDefinitionList;
begin
  result := TFhirMedicinalProductDefinitionList(inherited Link);
end;

procedure TFhirMedicinalProductDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicinalProductDefinitionList.SetItemByIndex(index: Integer; value: TFhirMedicinalProductDefinition);
begin
  assert(value is TFhirMedicinalProductDefinition);
  FhirMedicinalProductDefinitions[index] := value;
end;

procedure TFhirMedicinalProductDefinitionList.SetItemN(index: Integer; value: TFhirMedicinalProductDefinition);
begin
  assert(value is TFhirMedicinalProductDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICINALPRODUCTDEFINITION}
{$IFDEF FHIR_NUTRITIONPRODUCT}
{ TFhirNutritionProductNutrient }

constructor TFhirNutritionProductNutrient.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductNutrient.Destroy;
begin
  FItem.free;
  FAmountList.Free;
  inherited;
end;

procedure TFhirNutritionProductNutrient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirNutritionProductNutrient(oSource).item.Clone;
  if (TFhirNutritionProductNutrient(oSource).FAmountList = nil) then
  begin
    FAmountList.free;
    FAmountList := nil;
  end
  else
  begin
    if FAmountList = nil then
      FAmountList := TFhirRatioList.Create;
    FAmountList.Assign(TFhirNutritionProductNutrient(oSource).FAmountList);
  end;
end;

procedure TFhirNutritionProductNutrient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
    list.addAll(self, 'amount', FAmountList);
end;

procedure TFhirNutritionProductNutrient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', true, TFhirRatio, FAmountList.Link));
end;

function TFhirNutritionProductNutrient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    AmountList.add(propValue as TFhirRatio);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductNutrient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'amount') then AmountList.insertItem(index, propValue as TFhirRatio)
  else inherited;
end;

function TFhirNutritionProductNutrient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create()
  else if (propName = 'amount') then result := AmountList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductNutrient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'amount') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductNutrient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then deletePropertyValue('amount', AmountList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductNutrient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference
  else if (propName = 'amount') then replacePropertyValue('amount', AmountList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductNutrient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'amount') then AmountList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductNutrient.fhirType : string;
begin
  result := 'NutritionProduct.nutrient';
end;

function TFhirNutritionProductNutrient.Link : TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(inherited Link);
end;

function TFhirNutritionProductNutrient.Clone : TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(inherited Clone);
end;

function TFhirNutritionProductNutrient.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductNutrient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductNutrient)) then
    result := false
  else
  begin
    o := TFhirNutritionProductNutrient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountList, o.amountList, true);
  end;
end;

function TFhirNutritionProductNutrient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FamountList);
end;

procedure TFhirNutritionProductNutrient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

function TFhirNutritionProductNutrient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAmountList.sizeInBytes(magic));
end;

procedure TFhirNutritionProductNutrient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value;
end;

function TFhirNutritionProductNutrient.GetAmountList : TFhirRatioList;
begin
  if FAmountList = nil then
    FAmountList := TFhirRatioList.Create;
  result := FAmountList;
end;

function TFhirNutritionProductNutrient.GetHasAmountList : boolean;
begin
  result := (FAmountList <> nil) and (FAmountList.count > 0);
end;

{ TFhirNutritionProductNutrientListEnumerator }

constructor TFhirNutritionProductNutrientListEnumerator.Create(list : TFhirNutritionProductNutrientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductNutrientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductNutrientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductNutrientListEnumerator.GetCurrent : TFhirNutritionProductNutrient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductNutrientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductNutrientList }

function TFhirNutritionProductNutrientList.AddItem(value: TFhirNutritionProductNutrient): TFhirNutritionProductNutrient;
begin
  assert(value.ClassName = 'TFhirNutritionProductNutrient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductNutrient');
  add(value);
  result := value;
end;

function TFhirNutritionProductNutrientList.Append: TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductNutrientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductNutrientList.GetEnumerator : TFhirNutritionProductNutrientListEnumerator;
begin
  result := TFhirNutritionProductNutrientListEnumerator.Create(self.link);
end;

function TFhirNutritionProductNutrientList.Clone: TFhirNutritionProductNutrientList;
begin
  result := TFhirNutritionProductNutrientList(inherited Clone);
end;

function TFhirNutritionProductNutrientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductNutrientList.GetItemN(index: Integer): TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionProductNutrientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductNutrient;
end;
function TFhirNutritionProductNutrientList.IndexOf(value: TFhirNutritionProductNutrient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductNutrientList.Insert(index: Integer): TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductNutrientList.InsertItem(index: Integer; value: TFhirNutritionProductNutrient);
begin
  assert(value is TFhirNutritionProductNutrient);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductNutrientList.Item(index: Integer): TFhirNutritionProductNutrient;
begin
  result := TFhirNutritionProductNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionProductNutrientList.Link: TFhirNutritionProductNutrientList;
begin
  result := TFhirNutritionProductNutrientList(inherited Link);
end;

procedure TFhirNutritionProductNutrientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductNutrientList.SetItemByIndex(index: Integer; value: TFhirNutritionProductNutrient);
begin
  assert(value is TFhirNutritionProductNutrient);
  FhirNutritionProductNutrients[index] := value;
end;

procedure TFhirNutritionProductNutrientList.SetItemN(index: Integer; value: TFhirNutritionProductNutrient);
begin
  assert(value is TFhirNutritionProductNutrient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProductIngredient }

constructor TFhirNutritionProductIngredient.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductIngredient.Destroy;
begin
  FItem.free;
  FAmountList.Free;
  inherited;
end;

procedure TFhirNutritionProductIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirNutritionProductIngredient(oSource).item.Clone;
  if (TFhirNutritionProductIngredient(oSource).FAmountList = nil) then
  begin
    FAmountList.free;
    FAmountList := nil;
  end
  else
  begin
    if FAmountList = nil then
      FAmountList := TFhirRatioList.Create;
    FAmountList.Assign(TFhirNutritionProductIngredient(oSource).FAmountList);
  end;
end;

procedure TFhirNutritionProductIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
    list.addAll(self, 'amount', FAmountList);
end;

procedure TFhirNutritionProductIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Ratio', true, TFhirRatio, FAmountList.Link));
end;

function TFhirNutritionProductIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    AmountList.add(propValue as TFhirRatio);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'amount') then AmountList.insertItem(index, propValue as TFhirRatio)
  else inherited;
end;

function TFhirNutritionProductIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create()
  else if (propName = 'amount') then result := AmountList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'amount') then result := 'Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then deletePropertyValue('amount', AmountList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference
  else if (propName = 'amount') then replacePropertyValue('amount', AmountList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'amount') then AmountList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductIngredient.fhirType : string;
begin
  result := 'NutritionProduct.ingredient';
end;

function TFhirNutritionProductIngredient.Link : TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(inherited Link);
end;

function TFhirNutritionProductIngredient.Clone : TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(inherited Clone);
end;

function TFhirNutritionProductIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductIngredient)) then
    result := false
  else
  begin
    o := TFhirNutritionProductIngredient(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountList, o.amountList, true);
  end;
end;

function TFhirNutritionProductIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FamountList);
end;

procedure TFhirNutritionProductIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

function TFhirNutritionProductIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAmountList.sizeInBytes(magic));
end;

procedure TFhirNutritionProductIngredient.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value;
end;

function TFhirNutritionProductIngredient.GetAmountList : TFhirRatioList;
begin
  if FAmountList = nil then
    FAmountList := TFhirRatioList.Create;
  result := FAmountList;
end;

function TFhirNutritionProductIngredient.GetHasAmountList : boolean;
begin
  result := (FAmountList <> nil) and (FAmountList.count > 0);
end;

{ TFhirNutritionProductIngredientListEnumerator }

constructor TFhirNutritionProductIngredientListEnumerator.Create(list : TFhirNutritionProductIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductIngredientListEnumerator.GetCurrent : TFhirNutritionProductIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductIngredientList }

function TFhirNutritionProductIngredientList.AddItem(value: TFhirNutritionProductIngredient): TFhirNutritionProductIngredient;
begin
  assert(value.ClassName = 'TFhirNutritionProductIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductIngredient');
  add(value);
  result := value;
end;

function TFhirNutritionProductIngredientList.Append: TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductIngredientList.GetEnumerator : TFhirNutritionProductIngredientListEnumerator;
begin
  result := TFhirNutritionProductIngredientListEnumerator.Create(self.link);
end;

function TFhirNutritionProductIngredientList.Clone: TFhirNutritionProductIngredientList;
begin
  result := TFhirNutritionProductIngredientList(inherited Clone);
end;

function TFhirNutritionProductIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductIngredientList.GetItemN(index: Integer): TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(ObjectByIndex[index]);
end;

function TFhirNutritionProductIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductIngredient;
end;
function TFhirNutritionProductIngredientList.IndexOf(value: TFhirNutritionProductIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductIngredientList.Insert(index: Integer): TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductIngredientList.InsertItem(index: Integer; value: TFhirNutritionProductIngredient);
begin
  assert(value is TFhirNutritionProductIngredient);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductIngredientList.Item(index: Integer): TFhirNutritionProductIngredient;
begin
  result := TFhirNutritionProductIngredient(ObjectByIndex[index]);
end;

function TFhirNutritionProductIngredientList.Link: TFhirNutritionProductIngredientList;
begin
  result := TFhirNutritionProductIngredientList(inherited Link);
end;

procedure TFhirNutritionProductIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductIngredientList.SetItemByIndex(index: Integer; value: TFhirNutritionProductIngredient);
begin
  assert(value is TFhirNutritionProductIngredient);
  FhirNutritionProductIngredients[index] := value;
end;

procedure TFhirNutritionProductIngredientList.SetItemN(index: Integer; value: TFhirNutritionProductIngredient);
begin
  assert(value is TFhirNutritionProductIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProductProductCharacteristic }

constructor TFhirNutritionProductProductCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductProductCharacteristic.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirNutritionProductProductCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirNutritionProductProductCharacteristic(oSource).type_.Clone;
  value := TFhirNutritionProductProductCharacteristic(oSource).value.Clone;
end;

procedure TFhirNutritionProductProductCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirNutritionProductProductCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|string|Quantity|base64Binary|Attachment|boolean', false, TFhirDataType, FValue.Link));
end;

function TFhirNutritionProductProductCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductProductCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionProductProductCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductProductCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|string|Quantity|base64Binary|Attachment|boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductProductCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductProductCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'String', 'Quantity', 'Base64Binary', 'Attachment', 'Boolean'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductProductCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductProductCharacteristic.fhirType : string;
begin
  result := 'NutritionProduct.productCharacteristic';
end;

function TFhirNutritionProductProductCharacteristic.Link : TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic(inherited Link);
end;

function TFhirNutritionProductProductCharacteristic.Clone : TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic(inherited Clone);
end;

function TFhirNutritionProductProductCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductProductCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductProductCharacteristic)) then
    result := false
  else
  begin
    o := TFhirNutritionProductProductCharacteristic(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirNutritionProductProductCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirNutritionProductProductCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirNutritionProductProductCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirNutritionProductProductCharacteristic.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirNutritionProductProductCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirNutritionProductProductCharacteristicListEnumerator }

constructor TFhirNutritionProductProductCharacteristicListEnumerator.Create(list : TFhirNutritionProductProductCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductProductCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductProductCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductProductCharacteristicListEnumerator.GetCurrent : TFhirNutritionProductProductCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductProductCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductProductCharacteristicList }

function TFhirNutritionProductProductCharacteristicList.AddItem(value: TFhirNutritionProductProductCharacteristic): TFhirNutritionProductProductCharacteristic;
begin
  assert(value.ClassName = 'TFhirNutritionProductProductCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductProductCharacteristic');
  add(value);
  result := value;
end;

function TFhirNutritionProductProductCharacteristicList.Append: TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductProductCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductProductCharacteristicList.GetEnumerator : TFhirNutritionProductProductCharacteristicListEnumerator;
begin
  result := TFhirNutritionProductProductCharacteristicListEnumerator.Create(self.link);
end;

function TFhirNutritionProductProductCharacteristicList.Clone: TFhirNutritionProductProductCharacteristicList;
begin
  result := TFhirNutritionProductProductCharacteristicList(inherited Clone);
end;

function TFhirNutritionProductProductCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductProductCharacteristicList.GetItemN(index: Integer): TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic(ObjectByIndex[index]);
end;

function TFhirNutritionProductProductCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductProductCharacteristic;
end;
function TFhirNutritionProductProductCharacteristicList.IndexOf(value: TFhirNutritionProductProductCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductProductCharacteristicList.Insert(index: Integer): TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductProductCharacteristicList.InsertItem(index: Integer; value: TFhirNutritionProductProductCharacteristic);
begin
  assert(value is TFhirNutritionProductProductCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductProductCharacteristicList.Item(index: Integer): TFhirNutritionProductProductCharacteristic;
begin
  result := TFhirNutritionProductProductCharacteristic(ObjectByIndex[index]);
end;

function TFhirNutritionProductProductCharacteristicList.Link: TFhirNutritionProductProductCharacteristicList;
begin
  result := TFhirNutritionProductProductCharacteristicList(inherited Link);
end;

procedure TFhirNutritionProductProductCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductProductCharacteristicList.SetItemByIndex(index: Integer; value: TFhirNutritionProductProductCharacteristic);
begin
  assert(value is TFhirNutritionProductProductCharacteristic);
  FhirNutritionProductProductCharacteristics[index] := value;
end;

procedure TFhirNutritionProductProductCharacteristicList.SetItemN(index: Integer; value: TFhirNutritionProductProductCharacteristic);
begin
  assert(value is TFhirNutritionProductProductCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProductInstance }

constructor TFhirNutritionProductInstance.Create;
begin
  inherited;
end;

destructor TFhirNutritionProductInstance.Destroy;
begin
  FQuantity.free;
  FIdentifierList.Free;
  FLotNumber.free;
  FExpiry.free;
  FUseBy.free;
  inherited;
end;

procedure TFhirNutritionProductInstance.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirNutritionProductInstance(oSource).quantity.Clone;
  if (TFhirNutritionProductInstance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirNutritionProductInstance(oSource).FIdentifierList);
  end;
  lotNumberElement := TFhirNutritionProductInstance(oSource).lotNumberElement.Clone;
  expiryElement := TFhirNutritionProductInstance(oSource).expiryElement.Clone;
  useByElement := TFhirNutritionProductInstance(oSource).useByElement.Clone;
end;

procedure TFhirNutritionProductInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expiry') Then
     list.add(self.link, 'expiry', FExpiry.Link);
  if (child_name = 'useBy') Then
     list.add(self.link, 'useBy', FUseBy.Link);
end;

procedure TFhirNutritionProductInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', false, TFhirDateTime, FExpiry.Link));
  oList.add(TFHIRProperty.create(self, 'useBy', 'dateTime', false, TFhirDateTime, FUseBy.Link));
end;

function TFhirNutritionProductInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expiry') then
  begin
    ExpiryElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'useBy') then
  begin
    UseByElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProductInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirNutritionProductInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'lotNumber') then result := TFhirString.create()
  else if (propName = 'expiry') then result := TFhirDateTime.create()
  else if (propName = 'useBy') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProductInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expiry') then result := 'dateTime'
  else if (propName = 'useBy') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProductInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expiry') then ExpiryElement := nil
  else if (propName = 'useBy') then UseByElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProductInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'lotNumber') then LotNumberElement := asString(new)
  else if (propName = 'expiry') then ExpiryElement := asDateTime(new)
  else if (propName = 'useBy') then UseByElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProductInstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProductInstance.fhirType : string;
begin
  result := 'NutritionProduct.instance';
end;

function TFhirNutritionProductInstance.Link : TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(inherited Link);
end;

function TFhirNutritionProductInstance.Clone : TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(inherited Clone);
end;

function TFhirNutritionProductInstance.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProductInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProductInstance)) then
    result := false
  else
  begin
    o := TFhirNutritionProductInstance(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expiryElement, o.expiryElement, true) and 
      compareDeep(useByElement, o.useByElement, true);
  end;
end;

function TFhirNutritionProductInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FidentifierList) and isEmptyProp(FLotNumber) and isEmptyProp(FExpiry) and isEmptyProp(FUseBy);
end;

procedure TFhirNutritionProductInstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('identifier');
  fields.add('lotNumber');
  fields.add('expiry');
  fields.add('useBy');
end;

function TFhirNutritionProductInstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

procedure TFhirNutritionProductInstance.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirNutritionProductInstance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirNutritionProductInstance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirNutritionProductInstance.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

function TFhirNutritionProductInstance.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirNutritionProductInstance.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirNutritionProductInstance.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value;
end;

function TFhirNutritionProductInstance.GetExpiryST : TFslDateTime;
begin
  if FExpiry = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpiry.value;
end;

procedure TFhirNutritionProductInstance.SetExpiryST(value : TFslDateTime);
begin
  if FExpiry = nil then
    FExpiry := TFhirDateTime.create;
  FExpiry.value := value
end;

procedure TFhirNutritionProductInstance.SetUseBy(value : TFhirDateTime);
begin
  FUseBy.free;
  FUseBy := value;
end;

function TFhirNutritionProductInstance.GetUseByST : TFslDateTime;
begin
  if FUseBy = nil then
    result := TFslDateTime.makeNull
  else
    result := FUseBy.value;
end;

procedure TFhirNutritionProductInstance.SetUseByST(value : TFslDateTime);
begin
  if FUseBy = nil then
    FUseBy := TFhirDateTime.create;
  FUseBy.value := value
end;

{ TFhirNutritionProductInstanceListEnumerator }

constructor TFhirNutritionProductInstanceListEnumerator.Create(list : TFhirNutritionProductInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductInstanceListEnumerator.GetCurrent : TFhirNutritionProductInstance;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductInstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductInstanceList }

function TFhirNutritionProductInstanceList.AddItem(value: TFhirNutritionProductInstance): TFhirNutritionProductInstance;
begin
  assert(value.ClassName = 'TFhirNutritionProductInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProductInstance');
  add(value);
  result := value;
end;

function TFhirNutritionProductInstanceList.Append: TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductInstanceList.GetEnumerator : TFhirNutritionProductInstanceListEnumerator;
begin
  result := TFhirNutritionProductInstanceListEnumerator.Create(self.link);
end;

function TFhirNutritionProductInstanceList.Clone: TFhirNutritionProductInstanceList;
begin
  result := TFhirNutritionProductInstanceList(inherited Clone);
end;

function TFhirNutritionProductInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductInstanceList.GetItemN(index: Integer): TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(ObjectByIndex[index]);
end;

function TFhirNutritionProductInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProductInstance;
end;
function TFhirNutritionProductInstanceList.IndexOf(value: TFhirNutritionProductInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductInstanceList.Insert(index: Integer): TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductInstanceList.InsertItem(index: Integer; value: TFhirNutritionProductInstance);
begin
  assert(value is TFhirNutritionProductInstance);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductInstanceList.Item(index: Integer): TFhirNutritionProductInstance;
begin
  result := TFhirNutritionProductInstance(ObjectByIndex[index]);
end;

function TFhirNutritionProductInstanceList.Link: TFhirNutritionProductInstanceList;
begin
  result := TFhirNutritionProductInstanceList(inherited Link);
end;

procedure TFhirNutritionProductInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductInstanceList.SetItemByIndex(index: Integer; value: TFhirNutritionProductInstance);
begin
  assert(value is TFhirNutritionProductInstance);
  FhirNutritionProductInstances[index] := value;
end;

procedure TFhirNutritionProductInstanceList.SetItemN(index: Integer; value: TFhirNutritionProductInstance);
begin
  assert(value is TFhirNutritionProductInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionProduct }

constructor TFhirNutritionProduct.Create;
begin
  inherited;
end;

destructor TFhirNutritionProduct.Destroy;
begin
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FManufacturerList.Free;
  FNutrientList.Free;
  FIngredientList.Free;
  FKnownAllergenList.Free;
  FProductCharacteristicList.Free;
  FInstance.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirNutritionProduct.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirNutritionProduct(oSource).statusElement.Clone;
  if (TFhirNutritionProduct(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirNutritionProduct(oSource).FCategoryList);
  end;
  code := TFhirNutritionProduct(oSource).code.Clone;
  if (TFhirNutritionProduct(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirNutritionProduct(oSource).FManufacturerList);
  end;
  if (TFhirNutritionProduct(oSource).FNutrientList = nil) then
  begin
    FNutrientList.free;
    FNutrientList := nil;
  end
  else
  begin
    if FNutrientList = nil then
      FNutrientList := TFhirNutritionProductNutrientList.Create;
    FNutrientList.Assign(TFhirNutritionProduct(oSource).FNutrientList);
  end;
  if (TFhirNutritionProduct(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirNutritionProductIngredientList.Create;
    FIngredientList.Assign(TFhirNutritionProduct(oSource).FIngredientList);
  end;
  if (TFhirNutritionProduct(oSource).FKnownAllergenList = nil) then
  begin
    FKnownAllergenList.free;
    FKnownAllergenList := nil;
  end
  else
  begin
    if FKnownAllergenList = nil then
      FKnownAllergenList := TFhirCodeableReferenceList.Create;
    FKnownAllergenList.Assign(TFhirNutritionProduct(oSource).FKnownAllergenList);
  end;
  if (TFhirNutritionProduct(oSource).FProductCharacteristicList = nil) then
  begin
    FProductCharacteristicList.free;
    FProductCharacteristicList := nil;
  end
  else
  begin
    if FProductCharacteristicList = nil then
      FProductCharacteristicList := TFhirNutritionProductProductCharacteristicList.Create;
    FProductCharacteristicList.Assign(TFhirNutritionProduct(oSource).FProductCharacteristicList);
  end;
  instance := TFhirNutritionProduct(oSource).instance.Clone;
  if (TFhirNutritionProduct(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirNutritionProduct(oSource).FNoteList);
  end;
end;

function TFhirNutritionProduct.GetResourceType : TFhirResourceType;
begin
  result := frtNutritionProduct;
end;

procedure TFhirNutritionProduct.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'nutrient') Then
    list.addAll(self, 'nutrient', FNutrientList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
  if (child_name = 'knownAllergen') Then
    list.addAll(self, 'knownAllergen', FKnownAllergenList);
  if (child_name = 'productCharacteristic') Then
    list.addAll(self, 'productCharacteristic', FProductCharacteristicList);
  if (child_name = 'instance') Then
     list.add(self.link, 'instance', FInstance.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirNutritionProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'nutrient', 'BackboneElement', true, TFhirNutritionProductNutrient, FNutrientList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirNutritionProductIngredient, FIngredientList.Link));
  oList.add(TFHIRProperty.create(self, 'knownAllergen', 'CodeableReference', true, TFhirCodeableReference, FKnownAllergenList.Link));
  oList.add(TFHIRProperty.create(self, 'productCharacteristic', 'BackboneElement', true, TFhirNutritionProductProductCharacteristic, FProductCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'instance', 'BackboneElement', false, TFhirNutritionProductInstance, FInstance.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirNutritionProduct.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirNutritionProductStatusEnum, CODES_TFhirNutritionProductStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'nutrient') then
  begin
    NutrientList.add(propValue as TFhirNutritionProductNutrient);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirNutritionProductIngredient);
    result := propValue;
  end
  else if (propName = 'knownAllergen') then
  begin
    KnownAllergenList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'productCharacteristic') then
  begin
    ProductCharacteristicList.add(propValue as TFhirNutritionProductProductCharacteristic);
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    Instance := propValue as TFhirNutritionProductInstance;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionProduct.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'nutrient') then NutrientList.insertItem(index, propValue as TFhirNutritionProductNutrient)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirNutritionProductIngredient)
  else if (propName = 'knownAllergen') then KnownAllergenList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'productCharacteristic') then ProductCharacteristicList.insertItem(index, propValue as TFhirNutritionProductProductCharacteristic)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirNutritionProduct.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirNutritionProductStatusEnum[NutritionProductStatusNull], CODES_TFhirNutritionProductStatusEnum[NutritionProductStatusNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'nutrient') then result := NutrientList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else if (propName = 'knownAllergen') then result := KnownAllergenList.new()
  else if (propName = 'productCharacteristic') then result := ProductCharacteristicList.new()
  else if (propName = 'instance') then result := TFhirNutritionProductInstance.create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionProduct.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'nutrient') then result := 'BackboneElement'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else if (propName = 'knownAllergen') then result := 'CodeableReference'
  else if (propName = 'productCharacteristic') then result := 'BackboneElement'
  else if (propName = 'instance') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionProduct.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'nutrient') then deletePropertyValue('nutrient', NutrientList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else if (propName = 'knownAllergen') then deletePropertyValue('knownAllergen', KnownAllergenList, value)
  else if (propName = 'productCharacteristic') then deletePropertyValue('productCharacteristic', ProductCharacteristicList, value)
  else if (propName = 'instance') then InstanceElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionProduct.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirNutritionProductStatusEnum, CODES_TFhirNutritionProductStatusEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'nutrient') then replacePropertyValue('nutrient', NutrientList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else if (propName = 'knownAllergen') then replacePropertyValue('knownAllergen', KnownAllergenList, existing, new)
  else if (propName = 'productCharacteristic') then replacePropertyValue('productCharacteristic', ProductCharacteristicList, existing, new)
  else if (propName = 'instance') then InstanceElement := new as TFhirNutritionProductInstance
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionProduct.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else if (propName = 'nutrient') then NutrientList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else if (propName = 'knownAllergen') then KnownAllergenList.move(source, destination)
  else if (propName = 'productCharacteristic') then ProductCharacteristicList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionProduct.fhirType : string;
begin
  result := 'NutritionProduct';
end;

function TFhirNutritionProduct.Link : TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(inherited Link);
end;

function TFhirNutritionProduct.Clone : TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(inherited Clone);
end;

function TFhirNutritionProduct.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionProduct;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionProduct)) then
    result := false
  else
  begin
    o := TFhirNutritionProduct(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(manufacturerList, o.manufacturerList, true) and 
      compareDeep(nutrientList, o.nutrientList, true) and compareDeep(ingredientList, o.ingredientList, true) and 
      compareDeep(knownAllergenList, o.knownAllergenList, true) and compareDeep(productCharacteristicList, o.productCharacteristicList, true) and 
      compareDeep(instanceElement, o.instanceElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirNutritionProduct.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FmanufacturerList) and isEmptyProp(FnutrientList) and isEmptyProp(FingredientList) and isEmptyProp(FknownAllergenList) and isEmptyProp(FproductCharacteristicList) and isEmptyProp(FInstance) and isEmptyProp(FnoteList);
end;

procedure TFhirNutritionProduct.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('manufacturer');
  fields.add('nutrient');
  fields.add('ingredient');
  fields.add('knownAllergen');
  fields.add('productCharacteristic');
  fields.add('instance');
  fields.add('note');
end;

function TFhirNutritionProduct.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
  inc(result, FNutrientList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
  inc(result, FKnownAllergenList.sizeInBytes(magic));
  inc(result, FProductCharacteristicList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirNutritionProduct.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirNutritionProduct.GetStatusST : TFhirNutritionProductStatusEnum;
begin
  if FStatus = nil then
    result := TFhirNutritionProductStatusEnum(0)
  else
    result := TFhirNutritionProductStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirNutritionProductStatusEnum, FStatus.value));
end;

procedure TFhirNutritionProduct.SetStatusST(value : TFhirNutritionProductStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirNutritionProductStatusEnum[value], CODES_TFhirNutritionProductStatusEnum[value]);
end;

function TFhirNutritionProduct.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirNutritionProduct.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirNutritionProduct.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirNutritionProduct.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirNutritionProduct.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirNutritionProduct.GetNutrientList : TFhirNutritionProductNutrientList;
begin
  if FNutrientList = nil then
    FNutrientList := TFhirNutritionProductNutrientList.Create;
  result := FNutrientList;
end;

function TFhirNutritionProduct.GetHasNutrientList : boolean;
begin
  result := (FNutrientList <> nil) and (FNutrientList.count > 0);
end;

function TFhirNutritionProduct.GetIngredientList : TFhirNutritionProductIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirNutritionProductIngredientList.Create;
  result := FIngredientList;
end;

function TFhirNutritionProduct.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

function TFhirNutritionProduct.GetKnownAllergenList : TFhirCodeableReferenceList;
begin
  if FKnownAllergenList = nil then
    FKnownAllergenList := TFhirCodeableReferenceList.Create;
  result := FKnownAllergenList;
end;

function TFhirNutritionProduct.GetHasKnownAllergenList : boolean;
begin
  result := (FKnownAllergenList <> nil) and (FKnownAllergenList.count > 0);
end;

function TFhirNutritionProduct.GetProductCharacteristicList : TFhirNutritionProductProductCharacteristicList;
begin
  if FProductCharacteristicList = nil then
    FProductCharacteristicList := TFhirNutritionProductProductCharacteristicList.Create;
  result := FProductCharacteristicList;
end;

function TFhirNutritionProduct.GetHasProductCharacteristicList : boolean;
begin
  result := (FProductCharacteristicList <> nil) and (FProductCharacteristicList.count > 0);
end;

procedure TFhirNutritionProduct.SetInstance(value : TFhirNutritionProductInstance);
begin
  FInstance.free;
  FInstance := value;
end;

function TFhirNutritionProduct.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirNutritionProduct.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirNutritionProductListEnumerator }

constructor TFhirNutritionProductListEnumerator.Create(list : TFhirNutritionProductList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionProductListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionProductListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionProductListEnumerator.GetCurrent : TFhirNutritionProduct;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionProductListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionProductList }

function TFhirNutritionProductList.AddItem(value: TFhirNutritionProduct): TFhirNutritionProduct;
begin
  assert(value.ClassName = 'TFhirNutritionProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionProduct');
  add(value);
  result := value;
end;

function TFhirNutritionProductList.Append: TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionProductList.GetEnumerator : TFhirNutritionProductListEnumerator;
begin
  result := TFhirNutritionProductListEnumerator.Create(self.link);
end;

function TFhirNutritionProductList.Clone: TFhirNutritionProductList;
begin
  result := TFhirNutritionProductList(inherited Clone);
end;

function TFhirNutritionProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionProductList.GetItemN(index: Integer): TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(ObjectByIndex[index]);
end;

function TFhirNutritionProductList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionProduct;
end;
function TFhirNutritionProductList.IndexOf(value: TFhirNutritionProduct): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionProductList.Insert(index: Integer): TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionProductList.InsertItem(index: Integer; value: TFhirNutritionProduct);
begin
  assert(value is TFhirNutritionProduct);
  Inherited Insert(index, value);
end;

function TFhirNutritionProductList.Item(index: Integer): TFhirNutritionProduct;
begin
  result := TFhirNutritionProduct(ObjectByIndex[index]);
end;

function TFhirNutritionProductList.Link: TFhirNutritionProductList;
begin
  result := TFhirNutritionProductList(inherited Link);
end;

procedure TFhirNutritionProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionProductList.SetItemByIndex(index: Integer; value: TFhirNutritionProduct);
begin
  assert(value is TFhirNutritionProduct);
  FhirNutritionProducts[index] := value;
end;

procedure TFhirNutritionProductList.SetItemN(index: Integer; value: TFhirNutritionProduct);
begin
  assert(value is TFhirNutritionProduct);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NUTRITIONPRODUCT}
{$IFDEF FHIR_PACKAGEDPRODUCTDEFINITION}
{ TFhirPackagedProductDefinitionLegalStatusOfSupply }

constructor TFhirPackagedProductDefinitionLegalStatusOfSupply.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionLegalStatusOfSupply.Destroy;
begin
  FCode.free;
  FJurisdiction.free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirPackagedProductDefinitionLegalStatusOfSupply(oSource).code.Clone;
  jurisdiction := TFhirPackagedProductDefinitionLegalStatusOfSupply(oSource).jurisdiction.Clone;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', false, TFhirCodeableConcept, FJurisdiction.Link));
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    Jurisdiction := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'jurisdiction') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'jurisdiction') then JurisdictionElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.fhirType : string;
begin
  result := 'PackagedProductDefinition.legalStatusOfSupply';
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.Link : TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply(inherited Link);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.Clone : TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply(inherited Clone);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionLegalStatusOfSupply)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionLegalStatusOfSupply(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true);
  end;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FJurisdiction);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('jurisdiction');
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupply.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupply.SetJurisdiction(value : TFhirCodeableConcept);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

{ TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator }

constructor TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.Create(list : TFhirPackagedProductDefinitionLegalStatusOfSupplyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.GetCurrent : TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionLegalStatusOfSupplyList }

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.AddItem(value: TFhirPackagedProductDefinitionLegalStatusOfSupply): TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionLegalStatusOfSupply', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionLegalStatusOfSupply');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Append: TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.GetEnumerator : TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupplyListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Clone: TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupplyList(inherited Clone);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.GetItemN(index: Integer): TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply;
end;
function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.IndexOf(value: TFhirPackagedProductDefinitionLegalStatusOfSupply): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Insert(index: Integer): TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionLegalStatusOfSupply);
begin
  assert(value is TFhirPackagedProductDefinitionLegalStatusOfSupply);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Item(index: Integer): TFhirPackagedProductDefinitionLegalStatusOfSupply;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupply(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Link: TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
begin
  result := TFhirPackagedProductDefinitionLegalStatusOfSupplyList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionLegalStatusOfSupply);
begin
  assert(value is TFhirPackagedProductDefinitionLegalStatusOfSupply);
  FhirPackagedProductDefinitionLegalStatusOfSupplies[index] := value;
end;

procedure TFhirPackagedProductDefinitionLegalStatusOfSupplyList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionLegalStatusOfSupply);
begin
  assert(value is TFhirPackagedProductDefinitionLegalStatusOfSupply);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinitionPackage }

constructor TFhirPackagedProductDefinitionPackage.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionPackage.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FQuantity.free;
  FMaterialList.Free;
  FAlternateMaterialList.Free;
  FShelfLifeStorageList.Free;
  FManufacturerList.Free;
  FProperty_List.Free;
  FContainedItemList.Free;
  FPackageList.Free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionPackage.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPackagedProductDefinitionPackage(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FIdentifierList);
  end;
  type_ := TFhirPackagedProductDefinitionPackage(oSource).type_.Clone;
  quantityElement := TFhirPackagedProductDefinitionPackage(oSource).quantityElement.Clone;
  if (TFhirPackagedProductDefinitionPackage(oSource).FMaterialList = nil) then
  begin
    FMaterialList.free;
    FMaterialList := nil;
  end
  else
  begin
    if FMaterialList = nil then
      FMaterialList := TFhirCodeableConceptList.Create;
    FMaterialList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FMaterialList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FAlternateMaterialList = nil) then
  begin
    FAlternateMaterialList.free;
    FAlternateMaterialList := nil;
  end
  else
  begin
    if FAlternateMaterialList = nil then
      FAlternateMaterialList := TFhirCodeableConceptList.Create;
    FAlternateMaterialList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FAlternateMaterialList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FShelfLifeStorageList = nil) then
  begin
    FShelfLifeStorageList.free;
    FShelfLifeStorageList := nil;
  end
  else
  begin
    if FShelfLifeStorageList = nil then
      FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
    FShelfLifeStorageList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FShelfLifeStorageList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FManufacturerList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirPackagedProductDefinitionPackagePropertyList.Create;
    FProperty_List.Assign(TFhirPackagedProductDefinitionPackage(oSource).FProperty_List);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FContainedItemList = nil) then
  begin
    FContainedItemList.free;
    FContainedItemList := nil;
  end
  else
  begin
    if FContainedItemList = nil then
      FContainedItemList := TFhirPackagedProductDefinitionPackageContainedItemList.Create;
    FContainedItemList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FContainedItemList);
  end;
  if (TFhirPackagedProductDefinitionPackage(oSource).FPackageList = nil) then
  begin
    FPackageList.free;
    FPackageList := nil;
  end
  else
  begin
    if FPackageList = nil then
      FPackageList := TFhirPackagedProductDefinitionPackageList.Create;
    FPackageList.Assign(TFhirPackagedProductDefinitionPackage(oSource).FPackageList);
  end;
end;

procedure TFhirPackagedProductDefinitionPackage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'material') Then
    list.addAll(self, 'material', FMaterialList);
  if (child_name = 'alternateMaterial') Then
    list.addAll(self, 'alternateMaterial', FAlternateMaterialList);
  if (child_name = 'shelfLifeStorage') Then
    list.addAll(self, 'shelfLifeStorage', FShelfLifeStorageList);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'containedItem') Then
    list.addAll(self, 'containedItem', FContainedItemList);
  if (child_name = 'package') Then
    list.addAll(self, 'package', FPackageList);
end;

procedure TFhirPackagedProductDefinitionPackage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'integer', false, TFhirInteger, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'material', 'CodeableConcept', true, TFhirCodeableConcept, FMaterialList.Link));
  oList.add(TFHIRProperty.create(self, 'alternateMaterial', 'CodeableConcept', true, TFhirCodeableConcept, FAlternateMaterialList.Link));
  oList.add(TFHIRProperty.create(self, 'shelfLifeStorage', 'ProductShelfLife', true, TFhirProductShelfLife, FShelfLifeStorageList.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirPackagedProductDefinitionPackageProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'containedItem', 'BackboneElement', true, TFhirPackagedProductDefinitionPackageContainedItem, FContainedItemList.Link));
  oList.add(TFHIRProperty.create(self, 'package', '', true, TFhirPackagedProductDefinitionPackage, FPackageList.Link));
end;

function TFhirPackagedProductDefinitionPackage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'material') then
  begin
    MaterialList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'alternateMaterial') then
  begin
    AlternateMaterialList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'shelfLifeStorage') then
  begin
    ShelfLifeStorageList.add(propValue as TFhirProductShelfLife);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirPackagedProductDefinitionPackageProperty);
    result := propValue;
  end
  else if (propName = 'containedItem') then
  begin
    ContainedItemList.add(propValue as TFhirPackagedProductDefinitionPackageContainedItem);
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    PackageList.add(propValue as TFhirPackagedProductDefinitionPackage);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionPackage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'material') then MaterialList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'alternateMaterial') then AlternateMaterialList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.insertItem(index, propValue as TFhirProductShelfLife)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirPackagedProductDefinitionPackageProperty)
  else if (propName = 'containedItem') then ContainedItemList.insertItem(index, propValue as TFhirPackagedProductDefinitionPackageContainedItem)
  else if (propName = 'package') then PackageList.insertItem(index, propValue as TFhirPackagedProductDefinitionPackage)
  else inherited;
end;

function TFhirPackagedProductDefinitionPackage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'quantity') then result := TFhirInteger.create()
  else if (propName = 'material') then result := MaterialList.new()
  else if (propName = 'alternateMaterial') then result := AlternateMaterialList.new()
  else if (propName = 'shelfLifeStorage') then result := ShelfLifeStorageList.new()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'containedItem') then result := ContainedItemList.new()
  else if (propName = 'package') then result := PackageList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionPackage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'integer'
  else if (propName = 'material') then result := 'CodeableConcept'
  else if (propName = 'alternateMaterial') then result := 'CodeableConcept'
  else if (propName = 'shelfLifeStorage') then result := 'ProductShelfLife'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'containedItem') then result := 'BackboneElement'
  else if (propName = 'package') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionPackage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'material') then deletePropertyValue('material', MaterialList, value)
  else if (propName = 'alternateMaterial') then deletePropertyValue('alternateMaterial', AlternateMaterialList, value)
  else if (propName = 'shelfLifeStorage') then deletePropertyValue('shelfLifeStorage', ShelfLifeStorageList, value)
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'containedItem') then deletePropertyValue('containedItem', ContainedItemList, value)
  else if (propName = 'package') then deletePropertyValue('package', PackageList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionPackage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'quantity') then QuantityElement := asInteger(new)
  else if (propName = 'material') then replacePropertyValue('material', MaterialList, existing, new)
  else if (propName = 'alternateMaterial') then replacePropertyValue('alternateMaterial', AlternateMaterialList, existing, new)
  else if (propName = 'shelfLifeStorage') then replacePropertyValue('shelfLifeStorage', ShelfLifeStorageList, existing, new)
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'containedItem') then replacePropertyValue('containedItem', ContainedItemList, existing, new)
  else if (propName = 'package') then replacePropertyValue('package', PackageList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionPackage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'material') then MaterialList.move(source, destination)
  else if (propName = 'alternateMaterial') then AlternateMaterialList.move(source, destination)
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'containedItem') then ContainedItemList.move(source, destination)
  else if (propName = 'package') then PackageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionPackage.fhirType : string;
begin
  result := 'PackagedProductDefinition.package';
end;

function TFhirPackagedProductDefinitionPackage.Link : TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage(inherited Link);
end;

function TFhirPackagedProductDefinitionPackage.Clone : TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackage.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionPackage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionPackage)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionPackage(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(materialList, o.materialList, true) and 
      compareDeep(alternateMaterialList, o.alternateMaterialList, true) and compareDeep(shelfLifeStorageList, o.shelfLifeStorageList, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(containedItemList, o.containedItemList, true) and compareDeep(packageList, o.packageList, true);
  end;
end;

function TFhirPackagedProductDefinitionPackage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FmaterialList) and isEmptyProp(FalternateMaterialList) and isEmptyProp(FshelfLifeStorageList) and isEmptyProp(FmanufacturerList) and isEmptyProp(Fproperty_List) and isEmptyProp(FcontainedItemList) and isEmptyProp(FpackageList);
end;

procedure TFhirPackagedProductDefinitionPackage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('quantity');
  fields.add('material');
  fields.add('alternateMaterial');
  fields.add('shelfLifeStorage');
  fields.add('manufacturer');
  fields.add('property');
  fields.add('containedItem');
  fields.add('package');
end;

function TFhirPackagedProductDefinitionPackage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FMaterialList.sizeInBytes(magic));
  inc(result, FAlternateMaterialList.sizeInBytes(magic));
  inc(result, FShelfLifeStorageList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FContainedItemList.sizeInBytes(magic));
  inc(result, FPackageList.sizeInBytes(magic));
end;

function TFhirPackagedProductDefinitionPackage.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPackagedProductDefinitionPackage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirPackagedProductDefinitionPackage.SetQuantity(value : TFhirInteger);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirPackagedProductDefinitionPackage.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

procedure TFhirPackagedProductDefinitionPackage.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirInteger.create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

function TFhirPackagedProductDefinitionPackage.GetMaterialList : TFhirCodeableConceptList;
begin
  if FMaterialList = nil then
    FMaterialList := TFhirCodeableConceptList.Create;
  result := FMaterialList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasMaterialList : boolean;
begin
  result := (FMaterialList <> nil) and (FMaterialList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetAlternateMaterialList : TFhirCodeableConceptList;
begin
  if FAlternateMaterialList = nil then
    FAlternateMaterialList := TFhirCodeableConceptList.Create;
  result := FAlternateMaterialList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasAlternateMaterialList : boolean;
begin
  result := (FAlternateMaterialList <> nil) and (FAlternateMaterialList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetShelfLifeStorageList : TFhirProductShelfLifeList;
begin
  if FShelfLifeStorageList = nil then
    FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
  result := FShelfLifeStorageList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasShelfLifeStorageList : boolean;
begin
  result := (FShelfLifeStorageList <> nil) and (FShelfLifeStorageList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetProperty_List : TFhirPackagedProductDefinitionPackagePropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirPackagedProductDefinitionPackagePropertyList.Create;
  result := FProperty_List;
end;

function TFhirPackagedProductDefinitionPackage.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetContainedItemList : TFhirPackagedProductDefinitionPackageContainedItemList;
begin
  if FContainedItemList = nil then
    FContainedItemList := TFhirPackagedProductDefinitionPackageContainedItemList.Create;
  result := FContainedItemList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasContainedItemList : boolean;
begin
  result := (FContainedItemList <> nil) and (FContainedItemList.count > 0);
end;

function TFhirPackagedProductDefinitionPackage.GetPackageList : TFhirPackagedProductDefinitionPackageList;
begin
  if FPackageList = nil then
    FPackageList := TFhirPackagedProductDefinitionPackageList.Create;
  result := FPackageList;
end;

function TFhirPackagedProductDefinitionPackage.GetHasPackageList : boolean;
begin
  result := (FPackageList <> nil) and (FPackageList.count > 0);
end;

{ TFhirPackagedProductDefinitionPackageListEnumerator }

constructor TFhirPackagedProductDefinitionPackageListEnumerator.Create(list : TFhirPackagedProductDefinitionPackageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionPackageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionPackageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionPackageListEnumerator.GetCurrent : TFhirPackagedProductDefinitionPackage;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionPackageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionPackageList }

function TFhirPackagedProductDefinitionPackageList.AddItem(value: TFhirPackagedProductDefinitionPackage): TFhirPackagedProductDefinitionPackage;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionPackage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionPackage');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionPackageList.Append: TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackageList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionPackageList.GetEnumerator : TFhirPackagedProductDefinitionPackageListEnumerator;
begin
  result := TFhirPackagedProductDefinitionPackageListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionPackageList.Clone: TFhirPackagedProductDefinitionPackageList;
begin
  result := TFhirPackagedProductDefinitionPackageList(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionPackageList.GetItemN(index: Integer): TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackageList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionPackage;
end;
function TFhirPackagedProductDefinitionPackageList.IndexOf(value: TFhirPackagedProductDefinitionPackage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionPackageList.Insert(index: Integer): TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackageList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionPackage);
begin
  assert(value is TFhirPackagedProductDefinitionPackage);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionPackageList.Item(index: Integer): TFhirPackagedProductDefinitionPackage;
begin
  result := TFhirPackagedProductDefinitionPackage(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackageList.Link: TFhirPackagedProductDefinitionPackageList;
begin
  result := TFhirPackagedProductDefinitionPackageList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionPackageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionPackageList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionPackage);
begin
  assert(value is TFhirPackagedProductDefinitionPackage);
  FhirPackagedProductDefinitionPackages[index] := value;
end;

procedure TFhirPackagedProductDefinitionPackageList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionPackage);
begin
  assert(value is TFhirPackagedProductDefinitionPackage);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinitionPackageProperty }

constructor TFhirPackagedProductDefinitionPackageProperty.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionPackageProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionPackageProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirPackagedProductDefinitionPackageProperty(oSource).type_.Clone;
  value := TFhirPackagedProductDefinitionPackageProperty(oSource).value.Clone;
end;

procedure TFhirPackagedProductDefinitionPackageProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirPackagedProductDefinitionPackageProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPackagedProductDefinitionPackageProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionPackageProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionPackageProperty.fhirType : string;
begin
  result := 'PackagedProductDefinition.package.property';
end;

function TFhirPackagedProductDefinitionPackageProperty.Link : TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty(inherited Link);
end;

function TFhirPackagedProductDefinitionPackageProperty.Clone : TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackageProperty.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionPackageProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionPackageProperty)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionPackageProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirPackagedProductDefinitionPackageProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirPackagedProductDefinitionPackageProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPackagedProductDefinitionPackageProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirPackagedProductDefinitionPackageProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirPackagedProductDefinitionPackagePropertyListEnumerator }

constructor TFhirPackagedProductDefinitionPackagePropertyListEnumerator.Create(list : TFhirPackagedProductDefinitionPackagePropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionPackagePropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionPackagePropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionPackagePropertyListEnumerator.GetCurrent : TFhirPackagedProductDefinitionPackageProperty;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionPackagePropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionPackagePropertyList }

function TFhirPackagedProductDefinitionPackagePropertyList.AddItem(value: TFhirPackagedProductDefinitionPackageProperty): TFhirPackagedProductDefinitionPackageProperty;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionPackageProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionPackageProperty');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Append: TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionPackagePropertyList.GetEnumerator : TFhirPackagedProductDefinitionPackagePropertyListEnumerator;
begin
  result := TFhirPackagedProductDefinitionPackagePropertyListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Clone: TFhirPackagedProductDefinitionPackagePropertyList;
begin
  result := TFhirPackagedProductDefinitionPackagePropertyList(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionPackagePropertyList.GetItemN(index: Integer): TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionPackageProperty;
end;
function TFhirPackagedProductDefinitionPackagePropertyList.IndexOf(value: TFhirPackagedProductDefinitionPackageProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Insert(index: Integer): TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionPackageProperty);
begin
  assert(value is TFhirPackagedProductDefinitionPackageProperty);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Item(index: Integer): TFhirPackagedProductDefinitionPackageProperty;
begin
  result := TFhirPackagedProductDefinitionPackageProperty(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackagePropertyList.Link: TFhirPackagedProductDefinitionPackagePropertyList;
begin
  result := TFhirPackagedProductDefinitionPackagePropertyList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionPackageProperty);
begin
  assert(value is TFhirPackagedProductDefinitionPackageProperty);
  FhirPackagedProductDefinitionPackageProperties[index] := value;
end;

procedure TFhirPackagedProductDefinitionPackagePropertyList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionPackageProperty);
begin
  assert(value is TFhirPackagedProductDefinitionPackageProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinitionPackageContainedItem }

constructor TFhirPackagedProductDefinitionPackageContainedItem.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinitionPackageContainedItem.Destroy;
begin
  FItem.free;
  FAmount.free;
  inherited;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirPackagedProductDefinitionPackageContainedItem(oSource).item.Clone;
  amount := TFhirPackagedProductDefinitionPackageContainedItem(oSource).amount.Clone;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item', 'CodeableReference', false, TFhirCodeableReference, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));
end;

function TFhirPackagedProductDefinitionPackageContainedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'item') then
  begin
    Item := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPackagedProductDefinitionPackageContainedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'item') then result := TFhirCodeableReference.create()
  else if (propName = 'amount') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinitionPackageContainedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item') then result := 'CodeableReference'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'item') then ItemElement := new as TFhirCodeableReference
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinitionPackageContainedItem.fhirType : string;
begin
  result := 'PackagedProductDefinition.package.containedItem';
end;

function TFhirPackagedProductDefinitionPackageContainedItem.Link : TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem(inherited Link);
end;

function TFhirPackagedProductDefinitionPackageContainedItem.Clone : TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackageContainedItem.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinitionPackageContainedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinitionPackageContainedItem)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinitionPackageContainedItem(other);
    result := compareDeep(itemElement, o.itemElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirPackagedProductDefinitionPackageContainedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem) and isEmptyProp(FAmount);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item');
  fields.add('amount');
end;

function TFhirPackagedProductDefinitionPackageContainedItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.SetItem(value : TFhirCodeableReference);
begin
  FItem.free;
  FItem := value;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItem.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirPackagedProductDefinitionPackageContainedItemListEnumerator }

constructor TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.Create(list : TFhirPackagedProductDefinitionPackageContainedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.GetCurrent : TFhirPackagedProductDefinitionPackageContainedItem;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionPackageContainedItemList }

function TFhirPackagedProductDefinitionPackageContainedItemList.AddItem(value: TFhirPackagedProductDefinitionPackageContainedItem): TFhirPackagedProductDefinitionPackageContainedItem;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinitionPackageContainedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinitionPackageContainedItem');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Append: TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.GetEnumerator : TFhirPackagedProductDefinitionPackageContainedItemListEnumerator;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItemListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Clone: TFhirPackagedProductDefinitionPackageContainedItemList;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItemList(inherited Clone);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.GetItemN(index: Integer): TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem;
end;
function TFhirPackagedProductDefinitionPackageContainedItemList.IndexOf(value: TFhirPackagedProductDefinitionPackageContainedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Insert(index: Integer): TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.InsertItem(index: Integer; value: TFhirPackagedProductDefinitionPackageContainedItem);
begin
  assert(value is TFhirPackagedProductDefinitionPackageContainedItem);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Item(index: Integer): TFhirPackagedProductDefinitionPackageContainedItem;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItem(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionPackageContainedItemList.Link: TFhirPackagedProductDefinitionPackageContainedItemList;
begin
  result := TFhirPackagedProductDefinitionPackageContainedItemList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinitionPackageContainedItem);
begin
  assert(value is TFhirPackagedProductDefinitionPackageContainedItem);
  FhirPackagedProductDefinitionPackageContainedItems[index] := value;
end;

procedure TFhirPackagedProductDefinitionPackageContainedItemList.SetItemN(index: Integer; value: TFhirPackagedProductDefinitionPackageContainedItem);
begin
  assert(value is TFhirPackagedProductDefinitionPackageContainedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirPackagedProductDefinition }

constructor TFhirPackagedProductDefinition.Create;
begin
  inherited;
end;

destructor TFhirPackagedProductDefinition.Destroy;
begin
  FIdentifierList.Free;
  FName.free;
  FType_.free;
  FPackageForList.Free;
  FStatus.free;
  FStatusDate.free;
  FContainedItemQuantityList.Free;
  FDescription.free;
  FLegalStatusOfSupplyList.Free;
  FMarketingStatusList.Free;
  FCharacteristicList.Free;
  FCopackagedIndicator.free;
  FManufacturerList.Free;
  FPackage.free;
  inherited;
end;

procedure TFhirPackagedProductDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPackagedProductDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPackagedProductDefinition(oSource).FIdentifierList);
  end;
  nameElement := TFhirPackagedProductDefinition(oSource).nameElement.Clone;
  type_ := TFhirPackagedProductDefinition(oSource).type_.Clone;
  if (TFhirPackagedProductDefinition(oSource).FPackageForList = nil) then
  begin
    FPackageForList.free;
    FPackageForList := nil;
  end
  else
  begin
    if FPackageForList = nil then
      FPackageForList := TFhirReferenceList.Create;
    FPackageForList.Assign(TFhirPackagedProductDefinition(oSource).FPackageForList);
  end;
  status := TFhirPackagedProductDefinition(oSource).status.Clone;
  statusDateElement := TFhirPackagedProductDefinition(oSource).statusDateElement.Clone;
  if (TFhirPackagedProductDefinition(oSource).FContainedItemQuantityList = nil) then
  begin
    FContainedItemQuantityList.free;
    FContainedItemQuantityList := nil;
  end
  else
  begin
    if FContainedItemQuantityList = nil then
      FContainedItemQuantityList := TFhirQuantityList.Create;
    FContainedItemQuantityList.Assign(TFhirPackagedProductDefinition(oSource).FContainedItemQuantityList);
  end;
  descriptionElement := TFhirPackagedProductDefinition(oSource).descriptionElement.Clone;
  if (TFhirPackagedProductDefinition(oSource).FLegalStatusOfSupplyList = nil) then
  begin
    FLegalStatusOfSupplyList.free;
    FLegalStatusOfSupplyList := nil;
  end
  else
  begin
    if FLegalStatusOfSupplyList = nil then
      FLegalStatusOfSupplyList := TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Create;
    FLegalStatusOfSupplyList.Assign(TFhirPackagedProductDefinition(oSource).FLegalStatusOfSupplyList);
  end;
  if (TFhirPackagedProductDefinition(oSource).FMarketingStatusList = nil) then
  begin
    FMarketingStatusList.free;
    FMarketingStatusList := nil;
  end
  else
  begin
    if FMarketingStatusList = nil then
      FMarketingStatusList := TFhirMarketingStatusList.Create;
    FMarketingStatusList.Assign(TFhirPackagedProductDefinition(oSource).FMarketingStatusList);
  end;
  if (TFhirPackagedProductDefinition(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirCodeableConceptList.Create;
    FCharacteristicList.Assign(TFhirPackagedProductDefinition(oSource).FCharacteristicList);
  end;
  copackagedIndicatorElement := TFhirPackagedProductDefinition(oSource).copackagedIndicatorElement.Clone;
  if (TFhirPackagedProductDefinition(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirPackagedProductDefinition(oSource).FManufacturerList);
  end;
  package := TFhirPackagedProductDefinition(oSource).package.Clone;
end;

function TFhirPackagedProductDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtPackagedProductDefinition;
end;

procedure TFhirPackagedProductDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'packageFor') Then
    list.addAll(self, 'packageFor', FPackageForList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'containedItemQuantity') Then
    list.addAll(self, 'containedItemQuantity', FContainedItemQuantityList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'legalStatusOfSupply') Then
    list.addAll(self, 'legalStatusOfSupply', FLegalStatusOfSupplyList);
  if (child_name = 'marketingStatus') Then
    list.addAll(self, 'marketingStatus', FMarketingStatusList);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'copackagedIndicator') Then
     list.add(self.link, 'copackagedIndicator', FCopackagedIndicator.Link);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'package') Then
     list.add(self.link, 'package', FPackage.Link);
end;

procedure TFhirPackagedProductDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'packageFor', 'Reference', true, TFhirReference, FPackageForList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'containedItemQuantity', 'Quantity', true, TFhirQuantity, FContainedItemQuantityList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'legalStatusOfSupply', 'BackboneElement', true, TFhirPackagedProductDefinitionLegalStatusOfSupply, FLegalStatusOfSupplyList.Link));
  oList.add(TFHIRProperty.create(self, 'marketingStatus', 'MarketingStatus', true, TFhirMarketingStatus, FMarketingStatusList.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'CodeableConcept', true, TFhirCodeableConcept, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'copackagedIndicator', 'boolean', false, TFhirBoolean, FCopackagedIndicator.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'package', 'BackboneElement', false, TFhirPackagedProductDefinitionPackage, FPackage.Link));
end;

function TFhirPackagedProductDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'packageFor') then
  begin
    PackageForList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'containedItemQuantity') then
  begin
    ContainedItemQuantityList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'legalStatusOfSupply') then
  begin
    LegalStatusOfSupplyList.add(propValue as TFhirPackagedProductDefinitionLegalStatusOfSupply);
    result := propValue;
  end
  else if (propName = 'marketingStatus') then
  begin
    MarketingStatusList.add(propValue as TFhirMarketingStatus);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'copackagedIndicator') then
  begin
    CopackagedIndicatorElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'package') then
  begin
    Package := propValue as TFhirPackagedProductDefinitionPackage;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPackagedProductDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'packageFor') then PackageForList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'containedItemQuantity') then ContainedItemQuantityList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyList.insertItem(index, propValue as TFhirPackagedProductDefinitionLegalStatusOfSupply)
  else if (propName = 'marketingStatus') then MarketingStatusList.insertItem(index, propValue as TFhirMarketingStatus)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirPackagedProductDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'packageFor') then result := PackageForList.new()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'containedItemQuantity') then result := ContainedItemQuantityList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'legalStatusOfSupply') then result := LegalStatusOfSupplyList.new()
  else if (propName = 'marketingStatus') then result := MarketingStatusList.new()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'copackagedIndicator') then result := TFhirBoolean.create()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'package') then result := TFhirPackagedProductDefinitionPackage.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPackagedProductDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'packageFor') then result := 'Reference'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'containedItemQuantity') then result := 'Quantity'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'legalStatusOfSupply') then result := 'BackboneElement'
  else if (propName = 'marketingStatus') then result := 'MarketingStatus'
  else if (propName = 'characteristic') then result := 'CodeableConcept'
  else if (propName = 'copackagedIndicator') then result := 'boolean'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'package') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPackagedProductDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'packageFor') then deletePropertyValue('packageFor', PackageForList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'containedItemQuantity') then deletePropertyValue('containedItemQuantity', ContainedItemQuantityList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'legalStatusOfSupply') then deletePropertyValue('legalStatusOfSupply', LegalStatusOfSupplyList, value)
  else if (propName = 'marketingStatus') then deletePropertyValue('marketingStatus', MarketingStatusList, value)
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'copackagedIndicator') then CopackagedIndicatorElement := nil
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'package') then PackageElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPackagedProductDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'packageFor') then replacePropertyValue('packageFor', PackageForList, existing, new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'containedItemQuantity') then replacePropertyValue('containedItemQuantity', ContainedItemQuantityList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'legalStatusOfSupply') then replacePropertyValue('legalStatusOfSupply', LegalStatusOfSupplyList, existing, new)
  else if (propName = 'marketingStatus') then replacePropertyValue('marketingStatus', MarketingStatusList, existing, new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'copackagedIndicator') then CopackagedIndicatorElement := asBoolean(new)
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'package') then PackageElement := new as TFhirPackagedProductDefinitionPackage
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPackagedProductDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'packageFor') then PackageForList.move(source, destination)
  else if (propName = 'containedItemQuantity') then ContainedItemQuantityList.move(source, destination)
  else if (propName = 'legalStatusOfSupply') then LegalStatusOfSupplyList.move(source, destination)
  else if (propName = 'marketingStatus') then MarketingStatusList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPackagedProductDefinition.fhirType : string;
begin
  result := 'PackagedProductDefinition';
end;

function TFhirPackagedProductDefinition.Link : TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(inherited Link);
end;

function TFhirPackagedProductDefinition.Clone : TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(inherited Clone);
end;

function TFhirPackagedProductDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirPackagedProductDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPackagedProductDefinition)) then
    result := false
  else
  begin
    o := TFhirPackagedProductDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(packageForList, o.packageForList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusDateElement, o.statusDateElement, true) and 
      compareDeep(containedItemQuantityList, o.containedItemQuantityList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(legalStatusOfSupplyList, o.legalStatusOfSupplyList, true) and 
      compareDeep(marketingStatusList, o.marketingStatusList, true) and compareDeep(characteristicList, o.characteristicList, true) and 
      compareDeep(copackagedIndicatorElement, o.copackagedIndicatorElement, true) and 
      compareDeep(manufacturerList, o.manufacturerList, true) and compareDeep(packageElement, o.packageElement, true);
  end;
end;

function TFhirPackagedProductDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FpackageForList) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FcontainedItemQuantityList) and isEmptyProp(FDescription) and isEmptyProp(FlegalStatusOfSupplyList) and isEmptyProp(FmarketingStatusList) and isEmptyProp(FcharacteristicList) and isEmptyProp(FCopackagedIndicator) and isEmptyProp(FmanufacturerList) and isEmptyProp(FPackage);
end;

procedure TFhirPackagedProductDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('type');
  fields.add('packageFor');
  fields.add('status');
  fields.add('statusDate');
  fields.add('containedItemQuantity');
  fields.add('description');
  fields.add('legalStatusOfSupply');
  fields.add('marketingStatus');
  fields.add('characteristic');
  fields.add('copackagedIndicator');
  fields.add('manufacturer');
  fields.add('package');
end;

function TFhirPackagedProductDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPackageForList.sizeInBytes(magic));
  inc(result, FContainedItemQuantityList.sizeInBytes(magic));
  inc(result, FLegalStatusOfSupplyList.sizeInBytes(magic));
  inc(result, FMarketingStatusList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
end;

function TFhirPackagedProductDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPackagedProductDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirPackagedProductDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirPackagedProductDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirPackagedProductDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPackagedProductDefinition.GetPackageForList : TFhirReferenceList;
begin
  if FPackageForList = nil then
    FPackageForList := TFhirReferenceList.Create;
  result := FPackageForList;
end;

function TFhirPackagedProductDefinition.GetHasPackageForList : boolean;
begin
  result := (FPackageForList <> nil) and (FPackageForList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirPackagedProductDefinition.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirPackagedProductDefinition.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirPackagedProductDefinition.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

function TFhirPackagedProductDefinition.GetContainedItemQuantityList : TFhirQuantityList;
begin
  if FContainedItemQuantityList = nil then
    FContainedItemQuantityList := TFhirQuantityList.Create;
  result := FContainedItemQuantityList;
end;

function TFhirPackagedProductDefinition.GetHasContainedItemQuantityList : boolean;
begin
  result := (FContainedItemQuantityList <> nil) and (FContainedItemQuantityList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirPackagedProductDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPackagedProductDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirPackagedProductDefinition.GetLegalStatusOfSupplyList : TFhirPackagedProductDefinitionLegalStatusOfSupplyList;
begin
  if FLegalStatusOfSupplyList = nil then
    FLegalStatusOfSupplyList := TFhirPackagedProductDefinitionLegalStatusOfSupplyList.Create;
  result := FLegalStatusOfSupplyList;
end;

function TFhirPackagedProductDefinition.GetHasLegalStatusOfSupplyList : boolean;
begin
  result := (FLegalStatusOfSupplyList <> nil) and (FLegalStatusOfSupplyList.count > 0);
end;

function TFhirPackagedProductDefinition.GetMarketingStatusList : TFhirMarketingStatusList;
begin
  if FMarketingStatusList = nil then
    FMarketingStatusList := TFhirMarketingStatusList.Create;
  result := FMarketingStatusList;
end;

function TFhirPackagedProductDefinition.GetHasMarketingStatusList : boolean;
begin
  result := (FMarketingStatusList <> nil) and (FMarketingStatusList.count > 0);
end;

function TFhirPackagedProductDefinition.GetCharacteristicList : TFhirCodeableConceptList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirCodeableConceptList.Create;
  result := FCharacteristicList;
end;

function TFhirPackagedProductDefinition.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetCopackagedIndicator(value : TFhirBoolean);
begin
  FCopackagedIndicator.free;
  FCopackagedIndicator := value;
end;

function TFhirPackagedProductDefinition.GetCopackagedIndicatorST : Boolean;
begin
  if FCopackagedIndicator = nil then
    result := false
  else
    result := FCopackagedIndicator.value;
end;

procedure TFhirPackagedProductDefinition.SetCopackagedIndicatorST(value : Boolean);
begin
  if FCopackagedIndicator = nil then
    FCopackagedIndicator := TFhirBoolean.create;
  FCopackagedIndicator.value := value
end;

function TFhirPackagedProductDefinition.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirPackagedProductDefinition.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

procedure TFhirPackagedProductDefinition.SetPackage(value : TFhirPackagedProductDefinitionPackage);
begin
  FPackage.free;
  FPackage := value;
end;

{ TFhirPackagedProductDefinitionListEnumerator }

constructor TFhirPackagedProductDefinitionListEnumerator.Create(list : TFhirPackagedProductDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPackagedProductDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPackagedProductDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPackagedProductDefinitionListEnumerator.GetCurrent : TFhirPackagedProductDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirPackagedProductDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPackagedProductDefinitionList }

function TFhirPackagedProductDefinitionList.AddItem(value: TFhirPackagedProductDefinition): TFhirPackagedProductDefinition;
begin
  assert(value.ClassName = 'TFhirPackagedProductDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPackagedProductDefinition');
  add(value);
  result := value;
end;

function TFhirPackagedProductDefinitionList.Append: TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirPackagedProductDefinitionList.GetEnumerator : TFhirPackagedProductDefinitionListEnumerator;
begin
  result := TFhirPackagedProductDefinitionListEnumerator.Create(self.link);
end;

function TFhirPackagedProductDefinitionList.Clone: TFhirPackagedProductDefinitionList;
begin
  result := TFhirPackagedProductDefinitionList(inherited Clone);
end;

function TFhirPackagedProductDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPackagedProductDefinitionList.GetItemN(index: Integer): TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPackagedProductDefinition;
end;
function TFhirPackagedProductDefinitionList.IndexOf(value: TFhirPackagedProductDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPackagedProductDefinitionList.Insert(index: Integer): TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPackagedProductDefinitionList.InsertItem(index: Integer; value: TFhirPackagedProductDefinition);
begin
  assert(value is TFhirPackagedProductDefinition);
  Inherited Insert(index, value);
end;

function TFhirPackagedProductDefinitionList.Item(index: Integer): TFhirPackagedProductDefinition;
begin
  result := TFhirPackagedProductDefinition(ObjectByIndex[index]);
end;

function TFhirPackagedProductDefinitionList.Link: TFhirPackagedProductDefinitionList;
begin
  result := TFhirPackagedProductDefinitionList(inherited Link);
end;

procedure TFhirPackagedProductDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPackagedProductDefinitionList.SetItemByIndex(index: Integer; value: TFhirPackagedProductDefinition);
begin
  assert(value is TFhirPackagedProductDefinition);
  FhirPackagedProductDefinitions[index] := value;
end;

procedure TFhirPackagedProductDefinitionList.SetItemN(index: Integer; value: TFhirPackagedProductDefinition);
begin
  assert(value is TFhirPackagedProductDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PACKAGEDPRODUCTDEFINITION}
{$IFDEF FHIR_REGULATEDAUTHORIZATION}
{ TFhirRegulatedAuthorizationCase }

constructor TFhirRegulatedAuthorizationCase.Create;
begin
  inherited;
end;

destructor TFhirRegulatedAuthorizationCase.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FStatus.free;
  FDate.free;
  FApplicationList.Free;
  inherited;
end;

procedure TFhirRegulatedAuthorizationCase.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirRegulatedAuthorizationCase(oSource).identifier.Clone;
  type_ := TFhirRegulatedAuthorizationCase(oSource).type_.Clone;
  status := TFhirRegulatedAuthorizationCase(oSource).status.Clone;
  date := TFhirRegulatedAuthorizationCase(oSource).date.Clone;
  if (TFhirRegulatedAuthorizationCase(oSource).FApplicationList = nil) then
  begin
    FApplicationList.free;
    FApplicationList := nil;
  end
  else
  begin
    if FApplicationList = nil then
      FApplicationList := TFhirRegulatedAuthorizationCaseList.Create;
    FApplicationList.Assign(TFhirRegulatedAuthorizationCase(oSource).FApplicationList);
  end;
end;

procedure TFhirRegulatedAuthorizationCase.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date[x]') or (child_name = 'date') Then
     list.add(self.link, 'date[x]', FDate.Link);
  if (child_name = 'application') Then
    list.addAll(self, 'application', FApplicationList);
end;

procedure TFhirRegulatedAuthorizationCase.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'date[x]', 'Period|dateTime', false, TFhirDataType, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'application', '', true, TFhirRegulatedAuthorizationCase, FApplicationList.Link));
end;

function TFhirRegulatedAuthorizationCase.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then
  begin
    Date := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'application') then
  begin
    ApplicationList.add(propValue as TFhirRegulatedAuthorizationCase);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRegulatedAuthorizationCase.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'application') then ApplicationList.insertItem(index, propValue as TFhirRegulatedAuthorizationCase)
  else inherited;
end;

function TFhirRegulatedAuthorizationCase.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Date')
  else if (propName = 'application') then result := ApplicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRegulatedAuthorizationCase.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'date[x]') then result := 'Period|dateTime'
  else if (propName = 'application') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRegulatedAuthorizationCase.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := nil
  else if (propName = 'application') then deletePropertyValue('application', ApplicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRegulatedAuthorizationCase.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'date', ['Period', 'DateTime'])) then DateElement := new as TFhirDataType
  else if (propName = 'application') then replacePropertyValue('application', ApplicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRegulatedAuthorizationCase.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'application') then ApplicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRegulatedAuthorizationCase.fhirType : string;
begin
  result := 'RegulatedAuthorization.case';
end;

function TFhirRegulatedAuthorizationCase.Link : TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(inherited Link);
end;

function TFhirRegulatedAuthorizationCase.Clone : TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(inherited Clone);
end;

function TFhirRegulatedAuthorizationCase.equals(other : TObject) : boolean; 
var
  o : TFhirRegulatedAuthorizationCase;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRegulatedAuthorizationCase)) then
    result := false
  else
  begin
    o := TFhirRegulatedAuthorizationCase(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(applicationList, o.applicationList, true);
  end;
end;

function TFhirRegulatedAuthorizationCase.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FapplicationList);
end;

procedure TFhirRegulatedAuthorizationCase.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('status');
  fields.add('date[x]');
  fields.add('application');
end;

function TFhirRegulatedAuthorizationCase.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FApplicationList.sizeInBytes(magic));
end;

procedure TFhirRegulatedAuthorizationCase.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirRegulatedAuthorizationCase.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirRegulatedAuthorizationCase.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirRegulatedAuthorizationCase.SetDate(value : TFhirDataType);
begin
  FDate.free;
  FDate := value;
end;

function TFhirRegulatedAuthorizationCase.GetApplicationList : TFhirRegulatedAuthorizationCaseList;
begin
  if FApplicationList = nil then
    FApplicationList := TFhirRegulatedAuthorizationCaseList.Create;
  result := FApplicationList;
end;

function TFhirRegulatedAuthorizationCase.GetHasApplicationList : boolean;
begin
  result := (FApplicationList <> nil) and (FApplicationList.count > 0);
end;

{ TFhirRegulatedAuthorizationCaseListEnumerator }

constructor TFhirRegulatedAuthorizationCaseListEnumerator.Create(list : TFhirRegulatedAuthorizationCaseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRegulatedAuthorizationCaseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRegulatedAuthorizationCaseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRegulatedAuthorizationCaseListEnumerator.GetCurrent : TFhirRegulatedAuthorizationCase;
begin
  Result := FList[FIndex];
end;

function TFhirRegulatedAuthorizationCaseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRegulatedAuthorizationCaseList }

function TFhirRegulatedAuthorizationCaseList.AddItem(value: TFhirRegulatedAuthorizationCase): TFhirRegulatedAuthorizationCase;
begin
  assert(value.ClassName = 'TFhirRegulatedAuthorizationCase', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRegulatedAuthorizationCase');
  add(value);
  result := value;
end;

function TFhirRegulatedAuthorizationCaseList.Append: TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationCaseList.ClearItems;
begin
  Clear;
end;

function TFhirRegulatedAuthorizationCaseList.GetEnumerator : TFhirRegulatedAuthorizationCaseListEnumerator;
begin
  result := TFhirRegulatedAuthorizationCaseListEnumerator.Create(self.link);
end;

function TFhirRegulatedAuthorizationCaseList.Clone: TFhirRegulatedAuthorizationCaseList;
begin
  result := TFhirRegulatedAuthorizationCaseList(inherited Clone);
end;

function TFhirRegulatedAuthorizationCaseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRegulatedAuthorizationCaseList.GetItemN(index: Integer): TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationCaseList.ItemClass: TFslObjectClass;
begin
  result := TFhirRegulatedAuthorizationCase;
end;
function TFhirRegulatedAuthorizationCaseList.IndexOf(value: TFhirRegulatedAuthorizationCase): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRegulatedAuthorizationCaseList.Insert(index: Integer): TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationCaseList.InsertItem(index: Integer; value: TFhirRegulatedAuthorizationCase);
begin
  assert(value is TFhirRegulatedAuthorizationCase);
  Inherited Insert(index, value);
end;

function TFhirRegulatedAuthorizationCaseList.Item(index: Integer): TFhirRegulatedAuthorizationCase;
begin
  result := TFhirRegulatedAuthorizationCase(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationCaseList.Link: TFhirRegulatedAuthorizationCaseList;
begin
  result := TFhirRegulatedAuthorizationCaseList(inherited Link);
end;

procedure TFhirRegulatedAuthorizationCaseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRegulatedAuthorizationCaseList.SetItemByIndex(index: Integer; value: TFhirRegulatedAuthorizationCase);
begin
  assert(value is TFhirRegulatedAuthorizationCase);
  FhirRegulatedAuthorizationCases[index] := value;
end;

procedure TFhirRegulatedAuthorizationCaseList.SetItemN(index: Integer; value: TFhirRegulatedAuthorizationCase);
begin
  assert(value is TFhirRegulatedAuthorizationCase);
  ObjectByIndex[index] := value;
end;

{ TFhirRegulatedAuthorization }

constructor TFhirRegulatedAuthorization.Create;
begin
  inherited;
end;

destructor TFhirRegulatedAuthorization.Destroy;
begin
  FIdentifierList.Free;
  FSubjectList.Free;
  FType_.free;
  FDescription.free;
  FRegionList.Free;
  FStatus.free;
  FStatusDate.free;
  FValidityPeriod.free;
  FIndication.free;
  FIntendedUse.free;
  FBasisList.Free;
  FHolder.free;
  FRegulator.free;
  FCase_.free;
  inherited;
end;

procedure TFhirRegulatedAuthorization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRegulatedAuthorization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRegulatedAuthorization(oSource).FIdentifierList);
  end;
  if (TFhirRegulatedAuthorization(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirRegulatedAuthorization(oSource).FSubjectList);
  end;
  type_ := TFhirRegulatedAuthorization(oSource).type_.Clone;
  descriptionElement := TFhirRegulatedAuthorization(oSource).descriptionElement.Clone;
  if (TFhirRegulatedAuthorization(oSource).FRegionList = nil) then
  begin
    FRegionList.free;
    FRegionList := nil;
  end
  else
  begin
    if FRegionList = nil then
      FRegionList := TFhirCodeableConceptList.Create;
    FRegionList.Assign(TFhirRegulatedAuthorization(oSource).FRegionList);
  end;
  status := TFhirRegulatedAuthorization(oSource).status.Clone;
  statusDateElement := TFhirRegulatedAuthorization(oSource).statusDateElement.Clone;
  validityPeriod := TFhirRegulatedAuthorization(oSource).validityPeriod.Clone;
  indication := TFhirRegulatedAuthorization(oSource).indication.Clone;
  intendedUse := TFhirRegulatedAuthorization(oSource).intendedUse.Clone;
  if (TFhirRegulatedAuthorization(oSource).FBasisList = nil) then
  begin
    FBasisList.free;
    FBasisList := nil;
  end
  else
  begin
    if FBasisList = nil then
      FBasisList := TFhirCodeableConceptList.Create;
    FBasisList.Assign(TFhirRegulatedAuthorization(oSource).FBasisList);
  end;
  holder := TFhirRegulatedAuthorization(oSource).holder.Clone;
  regulator := TFhirRegulatedAuthorization(oSource).regulator.Clone;
  case_ := TFhirRegulatedAuthorization(oSource).case_.Clone;
end;

function TFhirRegulatedAuthorization.GetResourceType : TFhirResourceType;
begin
  result := frtRegulatedAuthorization;
end;

procedure TFhirRegulatedAuthorization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'region') Then
    list.addAll(self, 'region', FRegionList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'indication') Then
     list.add(self.link, 'indication', FIndication.Link);
  if (child_name = 'intendedUse') Then
     list.add(self.link, 'intendedUse', FIntendedUse.Link);
  if (child_name = 'basis') Then
    list.addAll(self, 'basis', FBasisList);
  if (child_name = 'holder') Then
     list.add(self.link, 'holder', FHolder.Link);
  if (child_name = 'regulator') Then
     list.add(self.link, 'regulator', FRegulator.Link);
  if (child_name = 'case') Then
     list.add(self.link, 'case', FCase_.Link);
end;

procedure TFhirRegulatedAuthorization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'region', 'CodeableConcept', true, TFhirCodeableConcept, FRegionList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'indication', 'CodeableReference', false, TFhirCodeableReference, FIndication.Link));
  oList.add(TFHIRProperty.create(self, 'intendedUse', 'CodeableConcept', false, TFhirCodeableConcept, FIntendedUse.Link));
  oList.add(TFHIRProperty.create(self, 'basis', 'CodeableConcept', true, TFhirCodeableConcept, FBasisList.Link));
  oList.add(TFHIRProperty.create(self, 'holder', 'Reference', false, TFhirReference, FHolder.Link));
  oList.add(TFHIRProperty.create(self, 'regulator', 'Reference', false, TFhirReference, FRegulator.Link));
  oList.add(TFHIRProperty.create(self, 'case', 'BackboneElement', false, TFhirRegulatedAuthorizationCase, FCase_.Link));
end;

function TFhirRegulatedAuthorization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'region') then
  begin
    RegionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    Indication := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'intendedUse') then
  begin
    IntendedUse := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'holder') then
  begin
    Holder := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'regulator') then
  begin
    Regulator := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'case') then
  begin
    Case_ := propValue as TFhirRegulatedAuthorizationCase;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRegulatedAuthorization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'region') then RegionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'basis') then BasisList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirRegulatedAuthorization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'subject') then result := SubjectList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'region') then result := RegionList.new()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'validityPeriod') then result := TFhirPeriod.create()
  else if (propName = 'indication') then result := TFhirCodeableReference.create()
  else if (propName = 'intendedUse') then result := TFhirCodeableConcept.create()
  else if (propName = 'basis') then result := BasisList.new()
  else if (propName = 'holder') then result := TFhirReference.create()
  else if (propName = 'regulator') then result := TFhirReference.create()
  else if (propName = 'case') then result := TFhirRegulatedAuthorizationCase.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRegulatedAuthorization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'region') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'indication') then result := 'CodeableReference'
  else if (propName = 'intendedUse') then result := 'CodeableConcept'
  else if (propName = 'basis') then result := 'CodeableConcept'
  else if (propName = 'holder') then result := 'Reference'
  else if (propName = 'regulator') then result := 'Reference'
  else if (propName = 'case') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRegulatedAuthorization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'region') then deletePropertyValue('region', RegionList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (propName = 'indication') then IndicationElement := nil
  else if (propName = 'intendedUse') then IntendedUseElement := nil
  else if (propName = 'basis') then deletePropertyValue('basis', BasisList, value)
  else if (propName = 'holder') then HolderElement := nil
  else if (propName = 'regulator') then RegulatorElement := nil
  else if (propName = 'case') then Case_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRegulatedAuthorization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'region') then replacePropertyValue('region', RegionList, existing, new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod
  else if (propName = 'indication') then IndicationElement := new as TFhirCodeableReference
  else if (propName = 'intendedUse') then IntendedUseElement := new as TFhirCodeableConcept
  else if (propName = 'basis') then replacePropertyValue('basis', BasisList, existing, new)
  else if (propName = 'holder') then HolderElement := new as TFhirReference
  else if (propName = 'regulator') then RegulatorElement := new as TFhirReference
  else if (propName = 'case') then Case_Element := new as TFhirRegulatedAuthorizationCase
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRegulatedAuthorization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'subject') then SubjectList.move(source, destination)
  else if (propName = 'region') then RegionList.move(source, destination)
  else if (propName = 'basis') then BasisList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRegulatedAuthorization.fhirType : string;
begin
  result := 'RegulatedAuthorization';
end;

function TFhirRegulatedAuthorization.Link : TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(inherited Link);
end;

function TFhirRegulatedAuthorization.Clone : TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(inherited Clone);
end;

function TFhirRegulatedAuthorization.equals(other : TObject) : boolean; 
var
  o : TFhirRegulatedAuthorization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRegulatedAuthorization)) then
    result := false
  else
  begin
    o := TFhirRegulatedAuthorization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(regionList, o.regionList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(validityPeriodElement, o.validityPeriodElement, true) and 
      compareDeep(indicationElement, o.indicationElement, true) and compareDeep(intendedUseElement, o.intendedUseElement, true) and 
      compareDeep(basisList, o.basisList, true) and compareDeep(holderElement, o.holderElement, true) and 
      compareDeep(regulatorElement, o.regulatorElement, true) and compareDeep(case_Element, o.case_Element, true);
  end;
end;

function TFhirRegulatedAuthorization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FsubjectList) and isEmptyProp(FType_) and isEmptyProp(FDescription) and isEmptyProp(FregionList) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FValidityPeriod) and isEmptyProp(FIndication) and isEmptyProp(FIntendedUse) and isEmptyProp(FbasisList) and isEmptyProp(FHolder) and isEmptyProp(FRegulator) and isEmptyProp(FCase_);
end;

procedure TFhirRegulatedAuthorization.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('subject');
  fields.add('type');
  fields.add('description');
  fields.add('region');
  fields.add('status');
  fields.add('statusDate');
  fields.add('validityPeriod');
  fields.add('indication');
  fields.add('intendedUse');
  fields.add('basis');
  fields.add('holder');
  fields.add('regulator');
  fields.add('case');
end;

function TFhirRegulatedAuthorization.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FSubjectList.sizeInBytes(magic));
  inc(result, FRegionList.sizeInBytes(magic));
  inc(result, FBasisList.sizeInBytes(magic));
end;

function TFhirRegulatedAuthorization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRegulatedAuthorization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirRegulatedAuthorization.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirRegulatedAuthorization.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirRegulatedAuthorization.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirRegulatedAuthorization.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirRegulatedAuthorization.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirRegulatedAuthorization.GetRegionList : TFhirCodeableConceptList;
begin
  if FRegionList = nil then
    FRegionList := TFhirCodeableConceptList.Create;
  result := FRegionList;
end;

function TFhirRegulatedAuthorization.GetHasRegionList : boolean;
begin
  result := (FRegionList <> nil) and (FRegionList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirRegulatedAuthorization.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirRegulatedAuthorization.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirRegulatedAuthorization.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

procedure TFhirRegulatedAuthorization.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

procedure TFhirRegulatedAuthorization.SetIndication(value : TFhirCodeableReference);
begin
  FIndication.free;
  FIndication := value;
end;

procedure TFhirRegulatedAuthorization.SetIntendedUse(value : TFhirCodeableConcept);
begin
  FIntendedUse.free;
  FIntendedUse := value;
end;

function TFhirRegulatedAuthorization.GetBasisList : TFhirCodeableConceptList;
begin
  if FBasisList = nil then
    FBasisList := TFhirCodeableConceptList.Create;
  result := FBasisList;
end;

function TFhirRegulatedAuthorization.GetHasBasisList : boolean;
begin
  result := (FBasisList <> nil) and (FBasisList.count > 0);
end;

procedure TFhirRegulatedAuthorization.SetHolder(value : TFhirReference);
begin
  FHolder.free;
  FHolder := value;
end;

procedure TFhirRegulatedAuthorization.SetRegulator(value : TFhirReference);
begin
  FRegulator.free;
  FRegulator := value;
end;

procedure TFhirRegulatedAuthorization.SetCase_(value : TFhirRegulatedAuthorizationCase);
begin
  FCase_.free;
  FCase_ := value;
end;

{ TFhirRegulatedAuthorizationListEnumerator }

constructor TFhirRegulatedAuthorizationListEnumerator.Create(list : TFhirRegulatedAuthorizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRegulatedAuthorizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRegulatedAuthorizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRegulatedAuthorizationListEnumerator.GetCurrent : TFhirRegulatedAuthorization;
begin
  Result := FList[FIndex];
end;

function TFhirRegulatedAuthorizationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRegulatedAuthorizationList }

function TFhirRegulatedAuthorizationList.AddItem(value: TFhirRegulatedAuthorization): TFhirRegulatedAuthorization;
begin
  assert(value.ClassName = 'TFhirRegulatedAuthorization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRegulatedAuthorization');
  add(value);
  result := value;
end;

function TFhirRegulatedAuthorizationList.Append: TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationList.ClearItems;
begin
  Clear;
end;

function TFhirRegulatedAuthorizationList.GetEnumerator : TFhirRegulatedAuthorizationListEnumerator;
begin
  result := TFhirRegulatedAuthorizationListEnumerator.Create(self.link);
end;

function TFhirRegulatedAuthorizationList.Clone: TFhirRegulatedAuthorizationList;
begin
  result := TFhirRegulatedAuthorizationList(inherited Clone);
end;

function TFhirRegulatedAuthorizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRegulatedAuthorizationList.GetItemN(index: Integer): TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirRegulatedAuthorization;
end;
function TFhirRegulatedAuthorizationList.IndexOf(value: TFhirRegulatedAuthorization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRegulatedAuthorizationList.Insert(index: Integer): TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRegulatedAuthorizationList.InsertItem(index: Integer; value: TFhirRegulatedAuthorization);
begin
  assert(value is TFhirRegulatedAuthorization);
  Inherited Insert(index, value);
end;

function TFhirRegulatedAuthorizationList.Item(index: Integer): TFhirRegulatedAuthorization;
begin
  result := TFhirRegulatedAuthorization(ObjectByIndex[index]);
end;

function TFhirRegulatedAuthorizationList.Link: TFhirRegulatedAuthorizationList;
begin
  result := TFhirRegulatedAuthorizationList(inherited Link);
end;

procedure TFhirRegulatedAuthorizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRegulatedAuthorizationList.SetItemByIndex(index: Integer; value: TFhirRegulatedAuthorization);
begin
  assert(value is TFhirRegulatedAuthorization);
  FhirRegulatedAuthorizations[index] := value;
end;

procedure TFhirRegulatedAuthorizationList.SetItemN(index: Integer; value: TFhirRegulatedAuthorization);
begin
  assert(value is TFhirRegulatedAuthorization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REGULATEDAUTHORIZATION}
{$IFDEF FHIR_SUBSTANCE}
{ TFhirSubstanceInstance }

constructor TFhirSubstanceInstance.Create;
begin
  inherited;
end;

destructor TFhirSubstanceInstance.Destroy;
begin
  FIdentifier.free;
  FExpiry.free;
  FQuantity.free;
  inherited;
end;

procedure TFhirSubstanceInstance.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirSubstanceInstance(oSource).identifier.Clone;
  expiryElement := TFhirSubstanceInstance(oSource).expiryElement.Clone;
  quantity := TFhirSubstanceInstance(oSource).quantity.Clone;
end;

procedure TFhirSubstanceInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'expiry') Then
     list.add(self.link, 'expiry', FExpiry.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
end;

procedure TFhirSubstanceInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'expiry', 'dateTime', false, TFhirDateTime, FExpiry.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
end;

function TFhirSubstanceInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'expiry') then
  begin
    ExpiryElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'expiry') then result := TFhirDateTime.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'expiry') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'expiry') then ExpiryElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'expiry') then ExpiryElement := asDateTime(new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceInstance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceInstance.fhirType : string;
begin
  result := 'Substance.instance';
end;

function TFhirSubstanceInstance.Link : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Link);
end;

function TFhirSubstanceInstance.Clone : TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(inherited Clone);
end;

function TFhirSubstanceInstance.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceInstance)) then
    result := false
  else
  begin
    o := TFhirSubstanceInstance(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(expiryElement, o.expiryElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true);
  end;
end;

function TFhirSubstanceInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FExpiry) and isEmptyProp(FQuantity);
end;

procedure TFhirSubstanceInstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('expiry');
  fields.add('quantity');
end;

function TFhirSubstanceInstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceInstance.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirSubstanceInstance.SetExpiry(value : TFhirDateTime);
begin
  FExpiry.free;
  FExpiry := value;
end;

function TFhirSubstanceInstance.GetExpiryST : TFslDateTime;
begin
  if FExpiry = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpiry.value;
end;

procedure TFhirSubstanceInstance.SetExpiryST(value : TFslDateTime);
begin
  if FExpiry = nil then
    FExpiry := TFhirDateTime.create;
  FExpiry.value := value
end;

procedure TFhirSubstanceInstance.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

{ TFhirSubstanceInstanceListEnumerator }

constructor TFhirSubstanceInstanceListEnumerator.Create(list : TFhirSubstanceInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceInstanceListEnumerator.GetCurrent : TFhirSubstanceInstance;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceInstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceInstanceList }

function TFhirSubstanceInstanceList.AddItem(value: TFhirSubstanceInstance): TFhirSubstanceInstance;
begin
  assert(value.ClassName = 'TFhirSubstanceInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceInstance');
  add(value);
  result := value;
end;

function TFhirSubstanceInstanceList.Append: TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceInstanceList.GetEnumerator : TFhirSubstanceInstanceListEnumerator;
begin
  result := TFhirSubstanceInstanceListEnumerator.Create(self.link);
end;

function TFhirSubstanceInstanceList.Clone: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Clone);
end;

function TFhirSubstanceInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceInstanceList.GetItemN(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceInstance;
end;
function TFhirSubstanceInstanceList.IndexOf(value: TFhirSubstanceInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceInstanceList.Insert(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceInstanceList.InsertItem(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  Inherited Insert(index, value);
end;

function TFhirSubstanceInstanceList.Item(index: Integer): TFhirSubstanceInstance;
begin
  result := TFhirSubstanceInstance(ObjectByIndex[index]);
end;

function TFhirSubstanceInstanceList.Link: TFhirSubstanceInstanceList;
begin
  result := TFhirSubstanceInstanceList(inherited Link);
end;

procedure TFhirSubstanceInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceInstanceList.SetItemByIndex(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  FhirSubstanceInstances[index] := value;
end;

procedure TFhirSubstanceInstanceList.SetItemN(index: Integer; value: TFhirSubstanceInstance);
begin
  assert(value is TFhirSubstanceInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceIngredient }

constructor TFhirSubstanceIngredient.Create;
begin
  inherited;
end;

destructor TFhirSubstanceIngredient.Destroy;
begin
  FQuantity.free;
  FSubstance.free;
  inherited;
end;

procedure TFhirSubstanceIngredient.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirSubstanceIngredient(oSource).quantity.Clone;
  substance := TFhirSubstanceIngredient(oSource).substance.Clone;
end;

procedure TFhirSubstanceIngredient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'substance[x]') or (child_name = 'substance') Then
     list.add(self.link, 'substance[x]', FSubstance.Link);
end;

procedure TFhirSubstanceIngredient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Ratio', false, TFhirRatio, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'substance[x]', 'CodeableConcept|Reference', false, TFhirDataType, FSubstance.Link));
end;

function TFhirSubstanceIngredient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirRatio;
    result := propValue;
  end
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then
  begin
    Substance := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceIngredient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceIngredient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirRatio.create()
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Substance')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceIngredient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Ratio'
  else if (propName = 'substance[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceIngredient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceIngredient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirRatio
  else if (isMatchingName(propName, 'substance', ['CodeableConcept', 'Reference'])) then SubstanceElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceIngredient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceIngredient.fhirType : string;
begin
  result := 'Substance.ingredient';
end;

function TFhirSubstanceIngredient.Link : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Link);
end;

function TFhirSubstanceIngredient.Clone : TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(inherited Clone);
end;

function TFhirSubstanceIngredient.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceIngredient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceIngredient)) then
    result := false
  else
  begin
    o := TFhirSubstanceIngredient(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(substanceElement, o.substanceElement, true);
  end;
end;

function TFhirSubstanceIngredient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FSubstance);
end;

procedure TFhirSubstanceIngredient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('substance[x]');
end;

function TFhirSubstanceIngredient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceIngredient.SetQuantity(value : TFhirRatio);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirSubstanceIngredient.SetSubstance(value : TFhirDataType);
begin
  FSubstance.free;
  FSubstance := value;
end;

{ TFhirSubstanceIngredientListEnumerator }

constructor TFhirSubstanceIngredientListEnumerator.Create(list : TFhirSubstanceIngredientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceIngredientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceIngredientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceIngredientListEnumerator.GetCurrent : TFhirSubstanceIngredient;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceIngredientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceIngredientList }

function TFhirSubstanceIngredientList.AddItem(value: TFhirSubstanceIngredient): TFhirSubstanceIngredient;
begin
  assert(value.ClassName = 'TFhirSubstanceIngredient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceIngredient');
  add(value);
  result := value;
end;

function TFhirSubstanceIngredientList.Append: TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceIngredientList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceIngredientList.GetEnumerator : TFhirSubstanceIngredientListEnumerator;
begin
  result := TFhirSubstanceIngredientListEnumerator.Create(self.link);
end;

function TFhirSubstanceIngredientList.Clone: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Clone);
end;

function TFhirSubstanceIngredientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceIngredientList.GetItemN(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceIngredient;
end;
function TFhirSubstanceIngredientList.IndexOf(value: TFhirSubstanceIngredient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceIngredientList.Insert(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceIngredientList.InsertItem(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  Inherited Insert(index, value);
end;

function TFhirSubstanceIngredientList.Item(index: Integer): TFhirSubstanceIngredient;
begin
  result := TFhirSubstanceIngredient(ObjectByIndex[index]);
end;

function TFhirSubstanceIngredientList.Link: TFhirSubstanceIngredientList;
begin
  result := TFhirSubstanceIngredientList(inherited Link);
end;

procedure TFhirSubstanceIngredientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceIngredientList.SetItemByIndex(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  FhirSubstanceIngredients[index] := value;
end;

procedure TFhirSubstanceIngredientList.SetItemN(index: Integer; value: TFhirSubstanceIngredient);
begin
  assert(value is TFhirSubstanceIngredient);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstance }

constructor TFhirSubstance.Create;
begin
  inherited;
end;

destructor TFhirSubstance.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FDescription.free;
  FInstanceList.Free;
  FIngredientList.Free;
  inherited;
end;

procedure TFhirSubstance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSubstance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSubstance(oSource).FIdentifierList);
  end;
  statusElement := TFhirSubstance(oSource).statusElement.Clone;
  if (TFhirSubstance(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirSubstance(oSource).FCategoryList);
  end;
  code := TFhirSubstance(oSource).code.Clone;
  descriptionElement := TFhirSubstance(oSource).descriptionElement.Clone;
  if (TFhirSubstance(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirSubstanceInstanceList.Create;
    FInstanceList.Assign(TFhirSubstance(oSource).FInstanceList);
  end;
  if (TFhirSubstance(oSource).FIngredientList = nil) then
  begin
    FIngredientList.free;
    FIngredientList := nil;
  end
  else
  begin
    if FIngredientList = nil then
      FIngredientList := TFhirSubstanceIngredientList.Create;
    FIngredientList.Assign(TFhirSubstance(oSource).FIngredientList);
  end;
end;

function TFhirSubstance.GetResourceType : TFhirResourceType;
begin
  result := frtSubstance;
end;

procedure TFhirSubstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
  if (child_name = 'ingredient') Then
    list.addAll(self, 'ingredient', FIngredientList);
end;

procedure TFhirSubstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'instance', 'BackboneElement', true, TFhirSubstanceInstance, FInstanceList.Link));
  oList.add(TFHIRProperty.create(self, 'ingredient', 'BackboneElement', true, TFhirSubstanceIngredient, FIngredientList.Link));
end;

function TFhirSubstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFHIRSubstanceStatusEnum, CODES_TFhirFHIRSubstanceStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirSubstanceInstance);
    result := propValue;
  end
  else if (propName = 'ingredient') then
  begin
    IngredientList.add(propValue as TFhirSubstanceIngredient);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirSubstanceInstance)
  else if (propName = 'ingredient') then IngredientList.insertItem(index, propValue as TFhirSubstanceIngredient)
  else inherited;
end;

function TFhirSubstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFHIRSubstanceStatusEnum[FHIRSubstanceStatusNull], CODES_TFhirFHIRSubstanceStatusEnum[FHIRSubstanceStatusNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'instance') then result := InstanceList.new()
  else if (propName = 'ingredient') then result := IngredientList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'instance') then result := 'BackboneElement'
  else if (propName = 'ingredient') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value)
  else if (propName = 'ingredient') then deletePropertyValue('ingredient', IngredientList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFHIRSubstanceStatusEnum, CODES_TFhirFHIRSubstanceStatusEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new)
  else if (propName = 'ingredient') then replacePropertyValue('ingredient', IngredientList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'instance') then InstanceList.move(source, destination)
  else if (propName = 'ingredient') then IngredientList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstance.fhirType : string;
begin
  result := 'Substance';
end;

function TFhirSubstance.Link : TFhirSubstance;
begin
  result := TFhirSubstance(inherited Link);
end;

function TFhirSubstance.Clone : TFhirSubstance;
begin
  result := TFhirSubstance(inherited Clone);
end;

function TFhirSubstance.equals(other : TObject) : boolean; 
var
  o : TFhirSubstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstance)) then
    result := false
  else
  begin
    o := TFhirSubstance(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(instanceList, o.instanceList, true) and 
      compareDeep(ingredientList, o.ingredientList, true);
  end;
end;

function TFhirSubstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FinstanceList) and isEmptyProp(FingredientList);
end;

procedure TFhirSubstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('description');
  fields.add('instance');
  fields.add('ingredient');
end;

function TFhirSubstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FInstanceList.sizeInBytes(magic));
  inc(result, FIngredientList.sizeInBytes(magic));
end;

function TFhirSubstance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSubstance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSubstance.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubstance.GetStatusST : TFhirFHIRSubstanceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFHIRSubstanceStatusEnum(0)
  else
    result := TFhirFHIRSubstanceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRSubstanceStatusEnum, FStatus.value));
end;

procedure TFhirSubstance.SetStatusST(value : TFhirFHIRSubstanceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFHIRSubstanceStatusEnum[value], CODES_TFhirFHIRSubstanceStatusEnum[value]);
end;

function TFhirSubstance.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirSubstance.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirSubstance.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirSubstance.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubstance.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubstance.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirSubstance.GetInstanceList : TFhirSubstanceInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirSubstanceInstanceList.Create;
  result := FInstanceList;
end;

function TFhirSubstance.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

function TFhirSubstance.GetIngredientList : TFhirSubstanceIngredientList;
begin
  if FIngredientList = nil then
    FIngredientList := TFhirSubstanceIngredientList.Create;
  result := FIngredientList;
end;

function TFhirSubstance.GetHasIngredientList : boolean;
begin
  result := (FIngredientList <> nil) and (FIngredientList.count > 0);
end;

{ TFhirSubstanceListEnumerator }

constructor TFhirSubstanceListEnumerator.Create(list : TFhirSubstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceListEnumerator.GetCurrent : TFhirSubstance;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceList }

function TFhirSubstanceList.AddItem(value: TFhirSubstance): TFhirSubstance;
begin
  assert(value.ClassName = 'TFhirSubstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstance');
  add(value);
  result := value;
end;

function TFhirSubstanceList.Append: TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceList.GetEnumerator : TFhirSubstanceListEnumerator;
begin
  result := TFhirSubstanceListEnumerator.Create(self.link);
end;

function TFhirSubstanceList.Clone: TFhirSubstanceList;
begin
  result := TFhirSubstanceList(inherited Clone);
end;

function TFhirSubstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceList.GetItemN(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance(ObjectByIndex[index]);
end;

function TFhirSubstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstance;
end;
function TFhirSubstanceList.IndexOf(value: TFhirSubstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceList.Insert(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceList.InsertItem(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  Inherited Insert(index, value);
end;

function TFhirSubstanceList.Item(index: Integer): TFhirSubstance;
begin
  result := TFhirSubstance(ObjectByIndex[index]);
end;

function TFhirSubstanceList.Link: TFhirSubstanceList;
begin
  result := TFhirSubstanceList(inherited Link);
end;

procedure TFhirSubstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceList.SetItemByIndex(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  FhirSubstances[index] := value;
end;

procedure TFhirSubstanceList.SetItemN(index: Integer; value: TFhirSubstance);
begin
  assert(value is TFhirSubstance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCE}
{$IFDEF FHIR_SUBSTANCEDEFINITION}
{ TFhirSubstanceDefinitionMoiety }

constructor TFhirSubstanceDefinitionMoiety.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionMoiety.Destroy;
begin
  FRole.free;
  FIdentifier.free;
  FName.free;
  FStereochemistry.free;
  FOpticalActivity.free;
  FMolecularFormula.free;
  FAmount.free;
  FAmountType.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionMoiety.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirSubstanceDefinitionMoiety(oSource).role.Clone;
  identifier := TFhirSubstanceDefinitionMoiety(oSource).identifier.Clone;
  nameElement := TFhirSubstanceDefinitionMoiety(oSource).nameElement.Clone;
  stereochemistry := TFhirSubstanceDefinitionMoiety(oSource).stereochemistry.Clone;
  opticalActivity := TFhirSubstanceDefinitionMoiety(oSource).opticalActivity.Clone;
  molecularFormulaElement := TFhirSubstanceDefinitionMoiety(oSource).molecularFormulaElement.Clone;
  amount := TFhirSubstanceDefinitionMoiety(oSource).amount.Clone;
  amountType := TFhirSubstanceDefinitionMoiety(oSource).amountType.Clone;
end;

procedure TFhirSubstanceDefinitionMoiety.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'stereochemistry') Then
     list.add(self.link, 'stereochemistry', FStereochemistry.Link);
  if (child_name = 'opticalActivity') Then
     list.add(self.link, 'opticalActivity', FOpticalActivity.Link);
  if (child_name = 'molecularFormula') Then
     list.add(self.link, 'molecularFormula', FMolecularFormula.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'amountType') Then
     list.add(self.link, 'amountType', FAmountType.Link);
end;

procedure TFhirSubstanceDefinitionMoiety.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'stereochemistry', 'CodeableConcept', false, TFhirCodeableConcept, FStereochemistry.Link));
  oList.add(TFHIRProperty.create(self, 'opticalActivity', 'CodeableConcept', false, TFhirCodeableConcept, FOpticalActivity.Link));
  oList.add(TFHIRProperty.create(self, 'molecularFormula', 'string', false, TFhirString, FMolecularFormula.Link));
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|string', false, TFhirDataType, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'amountType', 'CodeableConcept', false, TFhirCodeableConcept, FAmountType.Link));
end;

function TFhirSubstanceDefinitionMoiety.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'stereochemistry') then
  begin
    Stereochemistry := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'opticalActivity') then
  begin
    OpticalActivity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'molecularFormula') then
  begin
    MolecularFormulaElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then
  begin
    Amount := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'amountType') then
  begin
    AmountType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionMoiety.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionMoiety.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'stereochemistry') then result := TFhirCodeableConcept.create()
  else if (propName = 'opticalActivity') then result := TFhirCodeableConcept.create()
  else if (propName = 'molecularFormula') then result := TFhirString.create()
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then raise EFHIRException.create('Cannot make property Amount')
  else if (propName = 'amountType') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionMoiety.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'stereochemistry') then result := 'CodeableConcept'
  else if (propName = 'opticalActivity') then result := 'CodeableConcept'
  else if (propName = 'molecularFormula') then result := 'string'
  else if (propName = 'amount[x]') then result := 'Quantity|string'
  else if (propName = 'amountType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionMoiety.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'stereochemistry') then StereochemistryElement := nil
  else if (propName = 'opticalActivity') then OpticalActivityElement := nil
  else if (propName = 'molecularFormula') then MolecularFormulaElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := nil
  else if (propName = 'amountType') then AmountTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionMoiety.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'stereochemistry') then StereochemistryElement := new as TFhirCodeableConcept
  else if (propName = 'opticalActivity') then OpticalActivityElement := new as TFhirCodeableConcept
  else if (propName = 'molecularFormula') then MolecularFormulaElement := asString(new)
  else if (isMatchingName(propName, 'amount', ['Quantity', 'String'])) then AmountElement := new as TFhirDataType
  else if (propName = 'amountType') then AmountTypeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionMoiety.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionMoiety.fhirType : string;
begin
  result := 'SubstanceDefinition.moiety';
end;

function TFhirSubstanceDefinitionMoiety.Link : TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(inherited Link);
end;

function TFhirSubstanceDefinitionMoiety.Clone : TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(inherited Clone);
end;

function TFhirSubstanceDefinitionMoiety.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionMoiety;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionMoiety)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionMoiety(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(stereochemistryElement, o.stereochemistryElement, true) and 
      compareDeep(opticalActivityElement, o.opticalActivityElement, true) and compareDeep(molecularFormulaElement, o.molecularFormulaElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(amountTypeElement, o.amountTypeElement, true);
  end;
end;

function TFhirSubstanceDefinitionMoiety.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FStereochemistry) and isEmptyProp(FOpticalActivity) and isEmptyProp(FMolecularFormula) and isEmptyProp(FAmount) and isEmptyProp(FAmountType);
end;

procedure TFhirSubstanceDefinitionMoiety.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('identifier');
  fields.add('name');
  fields.add('stereochemistry');
  fields.add('opticalActivity');
  fields.add('molecularFormula');
  fields.add('amount[x]');
  fields.add('amountType');
end;

function TFhirSubstanceDefinitionMoiety.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionMoiety.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirSubstanceDefinitionMoiety.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceDefinitionMoiety.SetStereochemistry(value : TFhirCodeableConcept);
begin
  FStereochemistry.free;
  FStereochemistry := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetOpticalActivity(value : TFhirCodeableConcept);
begin
  FOpticalActivity.free;
  FOpticalActivity := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetMolecularFormula(value : TFhirString);
begin
  FMolecularFormula.free;
  FMolecularFormula := value;
end;

function TFhirSubstanceDefinitionMoiety.GetMolecularFormulaST : String;
begin
  if FMolecularFormula = nil then
    result := ''
  else
    result := FMolecularFormula.value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormula = nil then
      FMolecularFormula := TFhirString.create;
    FMolecularFormula.value := value
  end
  else if FMolecularFormula <> nil then
    FMolecularFormula.value := '';
end;

procedure TFhirSubstanceDefinitionMoiety.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirSubstanceDefinitionMoiety.SetAmountType(value : TFhirCodeableConcept);
begin
  FAmountType.free;
  FAmountType := value;
end;

{ TFhirSubstanceDefinitionMoietyListEnumerator }

constructor TFhirSubstanceDefinitionMoietyListEnumerator.Create(list : TFhirSubstanceDefinitionMoietyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionMoietyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionMoietyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionMoietyListEnumerator.GetCurrent : TFhirSubstanceDefinitionMoiety;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionMoietyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionMoietyList }

function TFhirSubstanceDefinitionMoietyList.AddItem(value: TFhirSubstanceDefinitionMoiety): TFhirSubstanceDefinitionMoiety;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionMoiety', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionMoiety');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionMoietyList.Append: TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMoietyList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionMoietyList.GetEnumerator : TFhirSubstanceDefinitionMoietyListEnumerator;
begin
  result := TFhirSubstanceDefinitionMoietyListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionMoietyList.Clone: TFhirSubstanceDefinitionMoietyList;
begin
  result := TFhirSubstanceDefinitionMoietyList(inherited Clone);
end;

function TFhirSubstanceDefinitionMoietyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionMoietyList.GetItemN(index: Integer): TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMoietyList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionMoiety;
end;
function TFhirSubstanceDefinitionMoietyList.IndexOf(value: TFhirSubstanceDefinitionMoiety): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionMoietyList.Insert(index: Integer): TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMoietyList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value is TFhirSubstanceDefinitionMoiety);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionMoietyList.Item(index: Integer): TFhirSubstanceDefinitionMoiety;
begin
  result := TFhirSubstanceDefinitionMoiety(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMoietyList.Link: TFhirSubstanceDefinitionMoietyList;
begin
  result := TFhirSubstanceDefinitionMoietyList(inherited Link);
end;

procedure TFhirSubstanceDefinitionMoietyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionMoietyList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value is TFhirSubstanceDefinitionMoiety);
  FhirSubstanceDefinitionMoieties[index] := value;
end;

procedure TFhirSubstanceDefinitionMoietyList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionMoiety);
begin
  assert(value is TFhirSubstanceDefinitionMoiety);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionProperty }

constructor TFhirSubstanceDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionProperty.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceDefinitionProperty(oSource).type_.Clone;
  value := TFhirSubstanceDefinitionProperty(oSource).value.Clone;
end;

procedure TFhirSubstanceDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirSubstanceDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|date|boolean|Attachment', false, TFhirDataType, FValue.Link));
end;

function TFhirSubstanceDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|date|boolean|Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Date', 'Boolean', 'Attachment'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionProperty.fhirType : string;
begin
  result := 'SubstanceDefinition.property';
end;

function TFhirSubstanceDefinitionProperty.Link : TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(inherited Link);
end;

function TFhirSubstanceDefinitionProperty.Clone : TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(inherited Clone);
end;

function TFhirSubstanceDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirSubstanceDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirSubstanceDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirSubstanceDefinitionProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionProperty.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirSubstanceDefinitionPropertyListEnumerator }

constructor TFhirSubstanceDefinitionPropertyListEnumerator.Create(list : TFhirSubstanceDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionPropertyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionPropertyListEnumerator.GetCurrent : TFhirSubstanceDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionPropertyList }

function TFhirSubstanceDefinitionPropertyList.AddItem(value: TFhirSubstanceDefinitionProperty): TFhirSubstanceDefinitionProperty;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionProperty');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionPropertyList.Append: TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionPropertyList.GetEnumerator : TFhirSubstanceDefinitionPropertyListEnumerator;
begin
  result := TFhirSubstanceDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionPropertyList.Clone: TFhirSubstanceDefinitionPropertyList;
begin
  result := TFhirSubstanceDefinitionPropertyList(inherited Clone);
end;

function TFhirSubstanceDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionPropertyList.GetItemN(index: Integer): TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionProperty;
end;
function TFhirSubstanceDefinitionPropertyList.IndexOf(value: TFhirSubstanceDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionPropertyList.Insert(index: Integer): TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionPropertyList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionProperty);
begin
  assert(value is TFhirSubstanceDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionPropertyList.Item(index: Integer): TFhirSubstanceDefinitionProperty;
begin
  result := TFhirSubstanceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionPropertyList.Link: TFhirSubstanceDefinitionPropertyList;
begin
  result := TFhirSubstanceDefinitionPropertyList(inherited Link);
end;

procedure TFhirSubstanceDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionProperty);
begin
  assert(value is TFhirSubstanceDefinitionProperty);
  FhirSubstanceDefinitionProperties[index] := value;
end;

procedure TFhirSubstanceDefinitionPropertyList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionProperty);
begin
  assert(value is TFhirSubstanceDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionMolecularWeight }

constructor TFhirSubstanceDefinitionMolecularWeight.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionMolecularWeight.Destroy;
begin
  FMethod.free;
  FType_.free;
  FAmount.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionMolecularWeight.Assign(oSource : TFslObject);
begin
  inherited;
  method := TFhirSubstanceDefinitionMolecularWeight(oSource).method.Clone;
  type_ := TFhirSubstanceDefinitionMolecularWeight(oSource).type_.Clone;
  amount := TFhirSubstanceDefinitionMolecularWeight(oSource).amount.Clone;
end;

procedure TFhirSubstanceDefinitionMolecularWeight.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));
end;

function TFhirSubstanceDefinitionMolecularWeight.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionMolecularWeight.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'method') then result := TFhirCodeableConcept.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionMolecularWeight.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionMolecularWeight.fhirType : string;
begin
  result := 'SubstanceDefinition.molecularWeight';
end;

function TFhirSubstanceDefinitionMolecularWeight.Link : TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight(inherited Link);
end;

function TFhirSubstanceDefinitionMolecularWeight.Clone : TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight(inherited Clone);
end;

function TFhirSubstanceDefinitionMolecularWeight.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionMolecularWeight;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionMolecularWeight)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionMolecularWeight(other);
    result := compareDeep(methodElement, o.methodElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirSubstanceDefinitionMolecularWeight.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMethod) and isEmptyProp(FType_) and isEmptyProp(FAmount);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('method');
  fields.add('type');
  fields.add('amount');
end;

function TFhirSubstanceDefinitionMolecularWeight.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionMolecularWeight.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

procedure TFhirSubstanceDefinitionMolecularWeight.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionMolecularWeight.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirSubstanceDefinitionMolecularWeightListEnumerator }

constructor TFhirSubstanceDefinitionMolecularWeightListEnumerator.Create(list : TFhirSubstanceDefinitionMolecularWeightList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionMolecularWeightListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionMolecularWeightListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionMolecularWeightListEnumerator.GetCurrent : TFhirSubstanceDefinitionMolecularWeight;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionMolecularWeightListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionMolecularWeightList }

function TFhirSubstanceDefinitionMolecularWeightList.AddItem(value: TFhirSubstanceDefinitionMolecularWeight): TFhirSubstanceDefinitionMolecularWeight;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionMolecularWeight', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionMolecularWeight');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionMolecularWeightList.Append: TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionMolecularWeightList.GetEnumerator : TFhirSubstanceDefinitionMolecularWeightListEnumerator;
begin
  result := TFhirSubstanceDefinitionMolecularWeightListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Clone: TFhirSubstanceDefinitionMolecularWeightList;
begin
  result := TFhirSubstanceDefinitionMolecularWeightList(inherited Clone);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionMolecularWeightList.GetItemN(index: Integer): TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMolecularWeightList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionMolecularWeight;
end;
function TFhirSubstanceDefinitionMolecularWeightList.IndexOf(value: TFhirSubstanceDefinitionMolecularWeight): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Insert(index: Integer): TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionMolecularWeight);
begin
  assert(value is TFhirSubstanceDefinitionMolecularWeight);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Item(index: Integer): TFhirSubstanceDefinitionMolecularWeight;
begin
  result := TFhirSubstanceDefinitionMolecularWeight(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionMolecularWeightList.Link: TFhirSubstanceDefinitionMolecularWeightList;
begin
  result := TFhirSubstanceDefinitionMolecularWeightList(inherited Link);
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionMolecularWeight);
begin
  assert(value is TFhirSubstanceDefinitionMolecularWeight);
  FhirSubstanceDefinitionMolecularWeights[index] := value;
end;

procedure TFhirSubstanceDefinitionMolecularWeightList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionMolecularWeight);
begin
  assert(value is TFhirSubstanceDefinitionMolecularWeight);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionStructure }

constructor TFhirSubstanceDefinitionStructure.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionStructure.Destroy;
begin
  FStereochemistry.free;
  FOpticalActivity.free;
  FMolecularFormula.free;
  FMolecularFormulaByMoiety.free;
  FMolecularWeight.free;
  FTechniqueList.Free;
  FSourceDocumentList.Free;
  FRepresentationList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionStructure.Assign(oSource : TFslObject);
begin
  inherited;
  stereochemistry := TFhirSubstanceDefinitionStructure(oSource).stereochemistry.Clone;
  opticalActivity := TFhirSubstanceDefinitionStructure(oSource).opticalActivity.Clone;
  molecularFormulaElement := TFhirSubstanceDefinitionStructure(oSource).molecularFormulaElement.Clone;
  molecularFormulaByMoietyElement := TFhirSubstanceDefinitionStructure(oSource).molecularFormulaByMoietyElement.Clone;
  molecularWeight := TFhirSubstanceDefinitionStructure(oSource).molecularWeight.Clone;
  if (TFhirSubstanceDefinitionStructure(oSource).FTechniqueList = nil) then
  begin
    FTechniqueList.free;
    FTechniqueList := nil;
  end
  else
  begin
    if FTechniqueList = nil then
      FTechniqueList := TFhirCodeableConceptList.Create;
    FTechniqueList.Assign(TFhirSubstanceDefinitionStructure(oSource).FTechniqueList);
  end;
  if (TFhirSubstanceDefinitionStructure(oSource).FSourceDocumentList = nil) then
  begin
    FSourceDocumentList.free;
    FSourceDocumentList := nil;
  end
  else
  begin
    if FSourceDocumentList = nil then
      FSourceDocumentList := TFhirReferenceList.Create;
    FSourceDocumentList.Assign(TFhirSubstanceDefinitionStructure(oSource).FSourceDocumentList);
  end;
  if (TFhirSubstanceDefinitionStructure(oSource).FRepresentationList = nil) then
  begin
    FRepresentationList.free;
    FRepresentationList := nil;
  end
  else
  begin
    if FRepresentationList = nil then
      FRepresentationList := TFhirSubstanceDefinitionStructureRepresentationList.Create;
    FRepresentationList.Assign(TFhirSubstanceDefinitionStructure(oSource).FRepresentationList);
  end;
end;

procedure TFhirSubstanceDefinitionStructure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'stereochemistry') Then
     list.add(self.link, 'stereochemistry', FStereochemistry.Link);
  if (child_name = 'opticalActivity') Then
     list.add(self.link, 'opticalActivity', FOpticalActivity.Link);
  if (child_name = 'molecularFormula') Then
     list.add(self.link, 'molecularFormula', FMolecularFormula.Link);
  if (child_name = 'molecularFormulaByMoiety') Then
     list.add(self.link, 'molecularFormulaByMoiety', FMolecularFormulaByMoiety.Link);
  if (child_name = 'molecularWeight') Then
     list.add(self.link, 'molecularWeight', FMolecularWeight.Link);
  if (child_name = 'technique') Then
    list.addAll(self, 'technique', FTechniqueList);
  if (child_name = 'sourceDocument') Then
    list.addAll(self, 'sourceDocument', FSourceDocumentList);
  if (child_name = 'representation') Then
    list.addAll(self, 'representation', FRepresentationList);
end;

procedure TFhirSubstanceDefinitionStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'stereochemistry', 'CodeableConcept', false, TFhirCodeableConcept, FStereochemistry.Link));
  oList.add(TFHIRProperty.create(self, 'opticalActivity', 'CodeableConcept', false, TFhirCodeableConcept, FOpticalActivity.Link));
  oList.add(TFHIRProperty.create(self, 'molecularFormula', 'string', false, TFhirString, FMolecularFormula.Link));
  oList.add(TFHIRProperty.create(self, 'molecularFormulaByMoiety', 'string', false, TFhirString, FMolecularFormulaByMoiety.Link));
  oList.add(TFHIRProperty.create(self, 'molecularWeight', '', false, TFhirSubstanceDefinitionMolecularWeight, FMolecularWeight.Link));
  oList.add(TFHIRProperty.create(self, 'technique', 'CodeableConcept', true, TFhirCodeableConcept, FTechniqueList.Link));
  oList.add(TFHIRProperty.create(self, 'sourceDocument', 'Reference', true, TFhirReference, FSourceDocumentList.Link));
  oList.add(TFHIRProperty.create(self, 'representation', 'BackboneElement', true, TFhirSubstanceDefinitionStructureRepresentation, FRepresentationList.Link));
end;

function TFhirSubstanceDefinitionStructure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'stereochemistry') then
  begin
    Stereochemistry := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'opticalActivity') then
  begin
    OpticalActivity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'molecularFormula') then
  begin
    MolecularFormulaElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'molecularFormulaByMoiety') then
  begin
    MolecularFormulaByMoietyElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeight := propValue as TFhirSubstanceDefinitionMolecularWeight;
    result := propValue;
  end
  else if (propName = 'technique') then
  begin
    TechniqueList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'sourceDocument') then
  begin
    SourceDocumentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationList.add(propValue as TFhirSubstanceDefinitionStructureRepresentation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionStructure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'technique') then TechniqueList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'sourceDocument') then SourceDocumentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'representation') then RepresentationList.insertItem(index, propValue as TFhirSubstanceDefinitionStructureRepresentation)
  else inherited;
end;

function TFhirSubstanceDefinitionStructure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'stereochemistry') then result := TFhirCodeableConcept.create()
  else if (propName = 'opticalActivity') then result := TFhirCodeableConcept.create()
  else if (propName = 'molecularFormula') then result := TFhirString.create()
  else if (propName = 'molecularFormulaByMoiety') then result := TFhirString.create()
  else if (propName = 'molecularWeight') then result := TFhirSubstanceDefinitionMolecularWeight.create()
  else if (propName = 'technique') then result := TechniqueList.new()
  else if (propName = 'sourceDocument') then result := SourceDocumentList.new()
  else if (propName = 'representation') then result := RepresentationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionStructure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'stereochemistry') then result := 'CodeableConcept'
  else if (propName = 'opticalActivity') then result := 'CodeableConcept'
  else if (propName = 'molecularFormula') then result := 'string'
  else if (propName = 'molecularFormulaByMoiety') then result := 'string'
  else if (propName = 'molecularWeight') then result := ''
  else if (propName = 'technique') then result := 'CodeableConcept'
  else if (propName = 'sourceDocument') then result := 'Reference'
  else if (propName = 'representation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionStructure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'stereochemistry') then StereochemistryElement := nil
  else if (propName = 'opticalActivity') then OpticalActivityElement := nil
  else if (propName = 'molecularFormula') then MolecularFormulaElement := nil
  else if (propName = 'molecularFormulaByMoiety') then MolecularFormulaByMoietyElement := nil
  else if (propName = 'molecularWeight') then MolecularWeightElement := nil
  else if (propName = 'technique') then deletePropertyValue('technique', TechniqueList, value)
  else if (propName = 'sourceDocument') then deletePropertyValue('sourceDocument', SourceDocumentList, value)
  else if (propName = 'representation') then deletePropertyValue('representation', RepresentationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionStructure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'stereochemistry') then StereochemistryElement := new as TFhirCodeableConcept
  else if (propName = 'opticalActivity') then OpticalActivityElement := new as TFhirCodeableConcept
  else if (propName = 'molecularFormula') then MolecularFormulaElement := asString(new)
  else if (propName = 'molecularFormulaByMoiety') then MolecularFormulaByMoietyElement := asString(new)
  else if (propName = 'molecularWeight') then MolecularWeightElement := new as TFhirSubstanceDefinitionMolecularWeight
  else if (propName = 'technique') then replacePropertyValue('technique', TechniqueList, existing, new)
  else if (propName = 'sourceDocument') then replacePropertyValue('sourceDocument', SourceDocumentList, existing, new)
  else if (propName = 'representation') then replacePropertyValue('representation', RepresentationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionStructure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'technique') then TechniqueList.move(source, destination)
  else if (propName = 'sourceDocument') then SourceDocumentList.move(source, destination)
  else if (propName = 'representation') then RepresentationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionStructure.fhirType : string;
begin
  result := 'SubstanceDefinition.structure';
end;

function TFhirSubstanceDefinitionStructure.Link : TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(inherited Link);
end;

function TFhirSubstanceDefinitionStructure.Clone : TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(inherited Clone);
end;

function TFhirSubstanceDefinitionStructure.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionStructure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionStructure)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionStructure(other);
    result := compareDeep(stereochemistryElement, o.stereochemistryElement, true) and 
      compareDeep(opticalActivityElement, o.opticalActivityElement, true) and compareDeep(molecularFormulaElement, o.molecularFormulaElement, true) and 
      compareDeep(molecularFormulaByMoietyElement, o.molecularFormulaByMoietyElement, true) and 
      compareDeep(molecularWeightElement, o.molecularWeightElement, true) and compareDeep(techniqueList, o.techniqueList, true) and 
      compareDeep(sourceDocumentList, o.sourceDocumentList, true) and compareDeep(representationList, o.representationList, true);
  end;
end;

function TFhirSubstanceDefinitionStructure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStereochemistry) and isEmptyProp(FOpticalActivity) and isEmptyProp(FMolecularFormula) and isEmptyProp(FMolecularFormulaByMoiety) and isEmptyProp(FMolecularWeight) and isEmptyProp(FtechniqueList) and isEmptyProp(FsourceDocumentList) and isEmptyProp(FrepresentationList);
end;

procedure TFhirSubstanceDefinitionStructure.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('stereochemistry');
  fields.add('opticalActivity');
  fields.add('molecularFormula');
  fields.add('molecularFormulaByMoiety');
  fields.add('molecularWeight');
  fields.add('technique');
  fields.add('sourceDocument');
  fields.add('representation');
end;

function TFhirSubstanceDefinitionStructure.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTechniqueList.sizeInBytes(magic));
  inc(result, FSourceDocumentList.sizeInBytes(magic));
  inc(result, FRepresentationList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionStructure.SetStereochemistry(value : TFhirCodeableConcept);
begin
  FStereochemistry.free;
  FStereochemistry := value;
end;

procedure TFhirSubstanceDefinitionStructure.SetOpticalActivity(value : TFhirCodeableConcept);
begin
  FOpticalActivity.free;
  FOpticalActivity := value;
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormula(value : TFhirString);
begin
  FMolecularFormula.free;
  FMolecularFormula := value;
end;

function TFhirSubstanceDefinitionStructure.GetMolecularFormulaST : String;
begin
  if FMolecularFormula = nil then
    result := ''
  else
    result := FMolecularFormula.value;
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormulaST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormula = nil then
      FMolecularFormula := TFhirString.create;
    FMolecularFormula.value := value
  end
  else if FMolecularFormula <> nil then
    FMolecularFormula.value := '';
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormulaByMoiety(value : TFhirString);
begin
  FMolecularFormulaByMoiety.free;
  FMolecularFormulaByMoiety := value;
end;

function TFhirSubstanceDefinitionStructure.GetMolecularFormulaByMoietyST : String;
begin
  if FMolecularFormulaByMoiety = nil then
    result := ''
  else
    result := FMolecularFormulaByMoiety.value;
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularFormulaByMoietyST(value : String);
begin
  if value <> '' then
  begin
    if FMolecularFormulaByMoiety = nil then
      FMolecularFormulaByMoiety := TFhirString.create;
    FMolecularFormulaByMoiety.value := value
  end
  else if FMolecularFormulaByMoiety <> nil then
    FMolecularFormulaByMoiety.value := '';
end;

procedure TFhirSubstanceDefinitionStructure.SetMolecularWeight(value : TFhirSubstanceDefinitionMolecularWeight);
begin
  FMolecularWeight.free;
  FMolecularWeight := value;
end;

function TFhirSubstanceDefinitionStructure.GetTechniqueList : TFhirCodeableConceptList;
begin
  if FTechniqueList = nil then
    FTechniqueList := TFhirCodeableConceptList.Create;
  result := FTechniqueList;
end;

function TFhirSubstanceDefinitionStructure.GetHasTechniqueList : boolean;
begin
  result := (FTechniqueList <> nil) and (FTechniqueList.count > 0);
end;

function TFhirSubstanceDefinitionStructure.GetSourceDocumentList : TFhirReferenceList;
begin
  if FSourceDocumentList = nil then
    FSourceDocumentList := TFhirReferenceList.Create;
  result := FSourceDocumentList;
end;

function TFhirSubstanceDefinitionStructure.GetHasSourceDocumentList : boolean;
begin
  result := (FSourceDocumentList <> nil) and (FSourceDocumentList.count > 0);
end;

function TFhirSubstanceDefinitionStructure.GetRepresentationList : TFhirSubstanceDefinitionStructureRepresentationList;
begin
  if FRepresentationList = nil then
    FRepresentationList := TFhirSubstanceDefinitionStructureRepresentationList.Create;
  result := FRepresentationList;
end;

function TFhirSubstanceDefinitionStructure.GetHasRepresentationList : boolean;
begin
  result := (FRepresentationList <> nil) and (FRepresentationList.count > 0);
end;

{ TFhirSubstanceDefinitionStructureListEnumerator }

constructor TFhirSubstanceDefinitionStructureListEnumerator.Create(list : TFhirSubstanceDefinitionStructureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionStructureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionStructureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionStructureListEnumerator.GetCurrent : TFhirSubstanceDefinitionStructure;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionStructureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionStructureList }

function TFhirSubstanceDefinitionStructureList.AddItem(value: TFhirSubstanceDefinitionStructure): TFhirSubstanceDefinitionStructure;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionStructure');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionStructureList.Append: TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionStructureList.GetEnumerator : TFhirSubstanceDefinitionStructureListEnumerator;
begin
  result := TFhirSubstanceDefinitionStructureListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionStructureList.Clone: TFhirSubstanceDefinitionStructureList;
begin
  result := TFhirSubstanceDefinitionStructureList(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionStructureList.GetItemN(index: Integer): TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionStructure;
end;
function TFhirSubstanceDefinitionStructureList.IndexOf(value: TFhirSubstanceDefinitionStructure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionStructureList.Insert(index: Integer): TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionStructure);
begin
  assert(value is TFhirSubstanceDefinitionStructure);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionStructureList.Item(index: Integer): TFhirSubstanceDefinitionStructure;
begin
  result := TFhirSubstanceDefinitionStructure(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureList.Link: TFhirSubstanceDefinitionStructureList;
begin
  result := TFhirSubstanceDefinitionStructureList(inherited Link);
end;

procedure TFhirSubstanceDefinitionStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionStructureList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionStructure);
begin
  assert(value is TFhirSubstanceDefinitionStructure);
  FhirSubstanceDefinitionStructures[index] := value;
end;

procedure TFhirSubstanceDefinitionStructureList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionStructure);
begin
  assert(value is TFhirSubstanceDefinitionStructure);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionStructureRepresentation }

constructor TFhirSubstanceDefinitionStructureRepresentation.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionStructureRepresentation.Destroy;
begin
  FType_.free;
  FRepresentation.free;
  FFormat.free;
  FDocument.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceDefinitionStructureRepresentation(oSource).type_.Clone;
  representationElement := TFhirSubstanceDefinitionStructureRepresentation(oSource).representationElement.Clone;
  format := TFhirSubstanceDefinitionStructureRepresentation(oSource).format.Clone;
  document := TFhirSubstanceDefinitionStructureRepresentation(oSource).document.Clone;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'representation') Then
     list.add(self.link, 'representation', FRepresentation.Link);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
  if (child_name = 'document') Then
     list.add(self.link, 'document', FDocument.Link);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'representation', 'string', false, TFhirString, FRepresentation.Link));
  oList.add(TFHIRProperty.create(self, 'format', 'CodeableConcept', false, TFhirCodeableConcept, FFormat.Link));
  oList.add(TFHIRProperty.create(self, 'document', 'Reference', false, TFhirReference, FDocument.Link));
end;

function TFhirSubstanceDefinitionStructureRepresentation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'representation') then
  begin
    RepresentationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    Format := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'document') then
  begin
    Document := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionStructureRepresentation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'representation') then result := TFhirString.create()
  else if (propName = 'format') then result := TFhirCodeableConcept.create()
  else if (propName = 'document') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionStructureRepresentation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'representation') then result := 'string'
  else if (propName = 'format') then result := 'CodeableConcept'
  else if (propName = 'document') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'representation') then RepresentationElement := nil
  else if (propName = 'format') then FormatElement := nil
  else if (propName = 'document') then DocumentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'representation') then RepresentationElement := asString(new)
  else if (propName = 'format') then FormatElement := new as TFhirCodeableConcept
  else if (propName = 'document') then DocumentElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionStructureRepresentation.fhirType : string;
begin
  result := 'SubstanceDefinition.structure.representation';
end;

function TFhirSubstanceDefinitionStructureRepresentation.Link : TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(inherited Link);
end;

function TFhirSubstanceDefinitionStructureRepresentation.Clone : TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureRepresentation.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionStructureRepresentation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionStructureRepresentation)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionStructureRepresentation(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(representationElement, o.representationElement, true) and 
      compareDeep(formatElement, o.formatElement, true) and compareDeep(documentElement, o.documentElement, true);
  end;
end;

function TFhirSubstanceDefinitionStructureRepresentation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRepresentation) and isEmptyProp(FFormat) and isEmptyProp(FDocument);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('representation');
  fields.add('format');
  fields.add('document');
end;

function TFhirSubstanceDefinitionStructureRepresentation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetRepresentation(value : TFhirString);
begin
  FRepresentation.free;
  FRepresentation := value;
end;

function TFhirSubstanceDefinitionStructureRepresentation.GetRepresentationST : String;
begin
  if FRepresentation = nil then
    result := ''
  else
    result := FRepresentation.value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetRepresentationST(value : String);
begin
  if value <> '' then
  begin
    if FRepresentation = nil then
      FRepresentation := TFhirString.create;
    FRepresentation.value := value
  end
  else if FRepresentation <> nil then
    FRepresentation.value := '';
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetFormat(value : TFhirCodeableConcept);
begin
  FFormat.free;
  FFormat := value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentation.SetDocument(value : TFhirReference);
begin
  FDocument.free;
  FDocument := value;
end;

{ TFhirSubstanceDefinitionStructureRepresentationListEnumerator }

constructor TFhirSubstanceDefinitionStructureRepresentationListEnumerator.Create(list : TFhirSubstanceDefinitionStructureRepresentationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionStructureRepresentationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionStructureRepresentationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionStructureRepresentationListEnumerator.GetCurrent : TFhirSubstanceDefinitionStructureRepresentation;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionStructureRepresentationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionStructureRepresentationList }

function TFhirSubstanceDefinitionStructureRepresentationList.AddItem(value: TFhirSubstanceDefinitionStructureRepresentation): TFhirSubstanceDefinitionStructureRepresentation;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionStructureRepresentation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionStructureRepresentation');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Append: TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionStructureRepresentationList.GetEnumerator : TFhirSubstanceDefinitionStructureRepresentationListEnumerator;
begin
  result := TFhirSubstanceDefinitionStructureRepresentationListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Clone: TFhirSubstanceDefinitionStructureRepresentationList;
begin
  result := TFhirSubstanceDefinitionStructureRepresentationList(inherited Clone);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionStructureRepresentationList.GetItemN(index: Integer): TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation;
end;
function TFhirSubstanceDefinitionStructureRepresentationList.IndexOf(value: TFhirSubstanceDefinitionStructureRepresentation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Insert(index: Integer): TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value is TFhirSubstanceDefinitionStructureRepresentation);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Item(index: Integer): TFhirSubstanceDefinitionStructureRepresentation;
begin
  result := TFhirSubstanceDefinitionStructureRepresentation(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionStructureRepresentationList.Link: TFhirSubstanceDefinitionStructureRepresentationList;
begin
  result := TFhirSubstanceDefinitionStructureRepresentationList(inherited Link);
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value is TFhirSubstanceDefinitionStructureRepresentation);
  FhirSubstanceDefinitionStructureRepresentations[index] := value;
end;

procedure TFhirSubstanceDefinitionStructureRepresentationList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionStructureRepresentation);
begin
  assert(value is TFhirSubstanceDefinitionStructureRepresentation);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionCode }

constructor TFhirSubstanceDefinitionCode.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionCode.Destroy;
begin
  FCode.free;
  FStatus.free;
  FStatusDate.free;
  FNoteList.Free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionCode.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirSubstanceDefinitionCode(oSource).code.Clone;
  status := TFhirSubstanceDefinitionCode(oSource).status.Clone;
  statusDateElement := TFhirSubstanceDefinitionCode(oSource).statusDateElement.Clone;
  if (TFhirSubstanceDefinitionCode(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirSubstanceDefinitionCode(oSource).FNoteList);
  end;
  if (TFhirSubstanceDefinitionCode(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionCode(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionCode.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionCode.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link));
end;

function TFhirSubstanceDefinitionCode.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionCode.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubstanceDefinitionCode.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'source') then result := SourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionCode.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionCode.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionCode.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionCode.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'source') then SourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionCode.fhirType : string;
begin
  result := 'SubstanceDefinition.code';
end;

function TFhirSubstanceDefinitionCode.Link : TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(inherited Link);
end;

function TFhirSubstanceDefinitionCode.Clone : TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(inherited Clone);
end;

function TFhirSubstanceDefinitionCode.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionCode;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionCode)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionCode(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionCode.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FnoteList) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionCode.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('status');
  fields.add('statusDate');
  fields.add('note');
  fields.add('source');
end;

function TFhirSubstanceDefinitionCode.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSourceList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionCode.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirSubstanceDefinitionCode.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirSubstanceDefinitionCode.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirSubstanceDefinitionCode.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirSubstanceDefinitionCode.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

function TFhirSubstanceDefinitionCode.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirSubstanceDefinitionCode.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirSubstanceDefinitionCode.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionCode.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

{ TFhirSubstanceDefinitionCodeListEnumerator }

constructor TFhirSubstanceDefinitionCodeListEnumerator.Create(list : TFhirSubstanceDefinitionCodeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionCodeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionCodeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionCodeListEnumerator.GetCurrent : TFhirSubstanceDefinitionCode;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionCodeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionCodeList }

function TFhirSubstanceDefinitionCodeList.AddItem(value: TFhirSubstanceDefinitionCode): TFhirSubstanceDefinitionCode;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionCode', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionCode');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionCodeList.Append: TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionCodeList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionCodeList.GetEnumerator : TFhirSubstanceDefinitionCodeListEnumerator;
begin
  result := TFhirSubstanceDefinitionCodeListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionCodeList.Clone: TFhirSubstanceDefinitionCodeList;
begin
  result := TFhirSubstanceDefinitionCodeList(inherited Clone);
end;

function TFhirSubstanceDefinitionCodeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionCodeList.GetItemN(index: Integer): TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionCodeList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionCode;
end;
function TFhirSubstanceDefinitionCodeList.IndexOf(value: TFhirSubstanceDefinitionCode): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionCodeList.Insert(index: Integer): TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionCodeList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionCode);
begin
  assert(value is TFhirSubstanceDefinitionCode);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionCodeList.Item(index: Integer): TFhirSubstanceDefinitionCode;
begin
  result := TFhirSubstanceDefinitionCode(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionCodeList.Link: TFhirSubstanceDefinitionCodeList;
begin
  result := TFhirSubstanceDefinitionCodeList(inherited Link);
end;

procedure TFhirSubstanceDefinitionCodeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionCodeList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionCode);
begin
  assert(value is TFhirSubstanceDefinitionCode);
  FhirSubstanceDefinitionCodes[index] := value;
end;

procedure TFhirSubstanceDefinitionCodeList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionCode);
begin
  assert(value is TFhirSubstanceDefinitionCode);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionName }

constructor TFhirSubstanceDefinitionName.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionName.Destroy;
begin
  FName.free;
  FType_.free;
  FStatus.free;
  FPreferred.free;
  FLanguageList.Free;
  FDomainList.Free;
  FJurisdictionList.Free;
  FSynonymList.Free;
  FTranslationList.Free;
  FOfficialList.Free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirSubstanceDefinitionName(oSource).nameElement.Clone;
  type_ := TFhirSubstanceDefinitionName(oSource).type_.Clone;
  status := TFhirSubstanceDefinitionName(oSource).status.Clone;
  preferredElement := TFhirSubstanceDefinitionName(oSource).preferredElement.Clone;
  if (TFhirSubstanceDefinitionName(oSource).FLanguageList = nil) then
  begin
    FLanguageList.free;
    FLanguageList := nil;
  end
  else
  begin
    if FLanguageList = nil then
      FLanguageList := TFhirCodeableConceptList.Create;
    FLanguageList.Assign(TFhirSubstanceDefinitionName(oSource).FLanguageList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FDomainList = nil) then
  begin
    FDomainList.free;
    FDomainList := nil;
  end
  else
  begin
    if FDomainList = nil then
      FDomainList := TFhirCodeableConceptList.Create;
    FDomainList.Assign(TFhirSubstanceDefinitionName(oSource).FDomainList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirSubstanceDefinitionName(oSource).FJurisdictionList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FSynonymList = nil) then
  begin
    FSynonymList.free;
    FSynonymList := nil;
  end
  else
  begin
    if FSynonymList = nil then
      FSynonymList := TFhirSubstanceDefinitionNameList.Create;
    FSynonymList.Assign(TFhirSubstanceDefinitionName(oSource).FSynonymList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FTranslationList = nil) then
  begin
    FTranslationList.free;
    FTranslationList := nil;
  end
  else
  begin
    if FTranslationList = nil then
      FTranslationList := TFhirSubstanceDefinitionNameList.Create;
    FTranslationList.Assign(TFhirSubstanceDefinitionName(oSource).FTranslationList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FOfficialList = nil) then
  begin
    FOfficialList.free;
    FOfficialList := nil;
  end
  else
  begin
    if FOfficialList = nil then
      FOfficialList := TFhirSubstanceDefinitionNameOfficialList.Create;
    FOfficialList.Assign(TFhirSubstanceDefinitionName(oSource).FOfficialList);
  end;
  if (TFhirSubstanceDefinitionName(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionName(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
  if (child_name = 'language') Then
    list.addAll(self, 'language', FLanguageList);
  if (child_name = 'domain') Then
    list.addAll(self, 'domain', FDomainList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'synonym') Then
    list.addAll(self, 'synonym', FSynonymList);
  if (child_name = 'translation') Then
    list.addAll(self, 'translation', FTranslationList);
  if (child_name = 'official') Then
    list.addAll(self, 'official', FOfficialList);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));
  oList.add(TFHIRProperty.create(self, 'language', 'CodeableConcept', true, TFhirCodeableConcept, FLanguageList.Link));
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', true, TFhirCodeableConcept, FDomainList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'synonym', '', true, TFhirSubstanceDefinitionName, FSynonymList.Link));
  oList.add(TFHIRProperty.create(self, 'translation', '', true, TFhirSubstanceDefinitionName, FTranslationList.Link));
  oList.add(TFHIRProperty.create(self, 'official', 'BackboneElement', true, TFhirSubstanceDefinitionNameOfficial, FOfficialList.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link));
end;

function TFhirSubstanceDefinitionName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'language') then
  begin
    LanguageList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    DomainList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'synonym') then
  begin
    SynonymList.add(propValue as TFhirSubstanceDefinitionName);
    result := propValue;
  end
  else if (propName = 'translation') then
  begin
    TranslationList.add(propValue as TFhirSubstanceDefinitionName);
    result := propValue;
  end
  else if (propName = 'official') then
  begin
    OfficialList.add(propValue as TFhirSubstanceDefinitionNameOfficial);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'language') then LanguageList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'domain') then DomainList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'synonym') then SynonymList.insertItem(index, propValue as TFhirSubstanceDefinitionName)
  else if (propName = 'translation') then TranslationList.insertItem(index, propValue as TFhirSubstanceDefinitionName)
  else if (propName = 'official') then OfficialList.insertItem(index, propValue as TFhirSubstanceDefinitionNameOfficial)
  else if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubstanceDefinitionName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'preferred') then result := TFhirBoolean.create()
  else if (propName = 'language') then result := LanguageList.new()
  else if (propName = 'domain') then result := DomainList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'synonym') then result := SynonymList.new()
  else if (propName = 'translation') then result := TranslationList.new()
  else if (propName = 'official') then result := OfficialList.new()
  else if (propName = 'source') then result := SourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'synonym') then result := ''
  else if (propName = 'translation') then result := ''
  else if (propName = 'official') then result := 'BackboneElement'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else if (propName = 'language') then deletePropertyValue('language', LanguageList, value)
  else if (propName = 'domain') then deletePropertyValue('domain', DomainList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'synonym') then deletePropertyValue('synonym', SynonymList, value)
  else if (propName = 'translation') then deletePropertyValue('translation', TranslationList, value)
  else if (propName = 'official') then deletePropertyValue('official', OfficialList, value)
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'preferred') then PreferredElement := asBoolean(new)
  else if (propName = 'language') then replacePropertyValue('language', LanguageList, existing, new)
  else if (propName = 'domain') then replacePropertyValue('domain', DomainList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'synonym') then replacePropertyValue('synonym', SynonymList, existing, new)
  else if (propName = 'translation') then replacePropertyValue('translation', TranslationList, existing, new)
  else if (propName = 'official') then replacePropertyValue('official', OfficialList, existing, new)
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionName.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'language') then LanguageList.move(source, destination)
  else if (propName = 'domain') then DomainList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'synonym') then SynonymList.move(source, destination)
  else if (propName = 'translation') then TranslationList.move(source, destination)
  else if (propName = 'official') then OfficialList.move(source, destination)
  else if (propName = 'source') then SourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionName.fhirType : string;
begin
  result := 'SubstanceDefinition.name';
end;

function TFhirSubstanceDefinitionName.Link : TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(inherited Link);
end;

function TFhirSubstanceDefinitionName.Clone : TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(inherited Clone);
end;

function TFhirSubstanceDefinitionName.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionName)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(preferredElement, o.preferredElement, true) and 
      compareDeep(languageList, o.languageList, true) and compareDeep(domainList, o.domainList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(synonymList, o.synonymList, true) and 
      compareDeep(translationList, o.translationList, true) and compareDeep(officialList, o.officialList, true) and 
      compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FPreferred) and isEmptyProp(FlanguageList) and isEmptyProp(FdomainList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FsynonymList) and isEmptyProp(FtranslationList) and isEmptyProp(FofficialList) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionName.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('status');
  fields.add('preferred');
  fields.add('language');
  fields.add('domain');
  fields.add('jurisdiction');
  fields.add('synonym');
  fields.add('translation');
  fields.add('official');
  fields.add('source');
end;

function TFhirSubstanceDefinitionName.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLanguageList.sizeInBytes(magic));
  inc(result, FDomainList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FSynonymList.sizeInBytes(magic));
  inc(result, FTranslationList.sizeInBytes(magic));
  inc(result, FOfficialList.sizeInBytes(magic));
  inc(result, FSourceList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirSubstanceDefinitionName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirSubstanceDefinitionName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirSubstanceDefinitionName.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionName.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirSubstanceDefinitionName.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

function TFhirSubstanceDefinitionName.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirSubstanceDefinitionName.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.create;
  FPreferred.value := value
end;

function TFhirSubstanceDefinitionName.GetLanguageList : TFhirCodeableConceptList;
begin
  if FLanguageList = nil then
    FLanguageList := TFhirCodeableConceptList.Create;
  result := FLanguageList;
end;

function TFhirSubstanceDefinitionName.GetHasLanguageList : boolean;
begin
  result := (FLanguageList <> nil) and (FLanguageList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetDomainList : TFhirCodeableConceptList;
begin
  if FDomainList = nil then
    FDomainList := TFhirCodeableConceptList.Create;
  result := FDomainList;
end;

function TFhirSubstanceDefinitionName.GetHasDomainList : boolean;
begin
  result := (FDomainList <> nil) and (FDomainList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirSubstanceDefinitionName.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetSynonymList : TFhirSubstanceDefinitionNameList;
begin
  if FSynonymList = nil then
    FSynonymList := TFhirSubstanceDefinitionNameList.Create;
  result := FSynonymList;
end;

function TFhirSubstanceDefinitionName.GetHasSynonymList : boolean;
begin
  result := (FSynonymList <> nil) and (FSynonymList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetTranslationList : TFhirSubstanceDefinitionNameList;
begin
  if FTranslationList = nil then
    FTranslationList := TFhirSubstanceDefinitionNameList.Create;
  result := FTranslationList;
end;

function TFhirSubstanceDefinitionName.GetHasTranslationList : boolean;
begin
  result := (FTranslationList <> nil) and (FTranslationList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetOfficialList : TFhirSubstanceDefinitionNameOfficialList;
begin
  if FOfficialList = nil then
    FOfficialList := TFhirSubstanceDefinitionNameOfficialList.Create;
  result := FOfficialList;
end;

function TFhirSubstanceDefinitionName.GetHasOfficialList : boolean;
begin
  result := (FOfficialList <> nil) and (FOfficialList.count > 0);
end;

function TFhirSubstanceDefinitionName.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionName.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

{ TFhirSubstanceDefinitionNameListEnumerator }

constructor TFhirSubstanceDefinitionNameListEnumerator.Create(list : TFhirSubstanceDefinitionNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionNameListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionNameListEnumerator.GetCurrent : TFhirSubstanceDefinitionName;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionNameListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionNameList }

function TFhirSubstanceDefinitionNameList.AddItem(value: TFhirSubstanceDefinitionName): TFhirSubstanceDefinitionName;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionName');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionNameList.Append: TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionNameList.GetEnumerator : TFhirSubstanceDefinitionNameListEnumerator;
begin
  result := TFhirSubstanceDefinitionNameListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionNameList.Clone: TFhirSubstanceDefinitionNameList;
begin
  result := TFhirSubstanceDefinitionNameList(inherited Clone);
end;

function TFhirSubstanceDefinitionNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionNameList.GetItemN(index: Integer): TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionName;
end;
function TFhirSubstanceDefinitionNameList.IndexOf(value: TFhirSubstanceDefinitionName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionNameList.Insert(index: Integer): TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionName);
begin
  assert(value is TFhirSubstanceDefinitionName);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionNameList.Item(index: Integer): TFhirSubstanceDefinitionName;
begin
  result := TFhirSubstanceDefinitionName(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameList.Link: TFhirSubstanceDefinitionNameList;
begin
  result := TFhirSubstanceDefinitionNameList(inherited Link);
end;

procedure TFhirSubstanceDefinitionNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionNameList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionName);
begin
  assert(value is TFhirSubstanceDefinitionName);
  FhirSubstanceDefinitionNames[index] := value;
end;

procedure TFhirSubstanceDefinitionNameList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionName);
begin
  assert(value is TFhirSubstanceDefinitionName);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionNameOfficial }

constructor TFhirSubstanceDefinitionNameOfficial.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionNameOfficial.Destroy;
begin
  FAuthority.free;
  FStatus.free;
  FDate.free;
  inherited;
end;

procedure TFhirSubstanceDefinitionNameOfficial.Assign(oSource : TFslObject);
begin
  inherited;
  authority := TFhirSubstanceDefinitionNameOfficial(oSource).authority.Clone;
  status := TFhirSubstanceDefinitionNameOfficial(oSource).status.Clone;
  dateElement := TFhirSubstanceDefinitionNameOfficial(oSource).dateElement.Clone;
end;

procedure TFhirSubstanceDefinitionNameOfficial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
end;

procedure TFhirSubstanceDefinitionNameOfficial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authority', 'CodeableConcept', false, TFhirCodeableConcept, FAuthority.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
end;

function TFhirSubstanceDefinitionNameOfficial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authority') then
  begin
    Authority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionNameOfficial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubstanceDefinitionNameOfficial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authority') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionNameOfficial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authority') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionNameOfficial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionNameOfficial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'date') then DateElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionNameOfficial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionNameOfficial.fhirType : string;
begin
  result := 'SubstanceDefinition.name.official';
end;

function TFhirSubstanceDefinitionNameOfficial.Link : TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(inherited Link);
end;

function TFhirSubstanceDefinitionNameOfficial.Clone : TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(inherited Clone);
end;

function TFhirSubstanceDefinitionNameOfficial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionNameOfficial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionNameOfficial)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionNameOfficial(other);
    result := compareDeep(authorityElement, o.authorityElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(dateElement, o.dateElement, true);
  end;
end;

function TFhirSubstanceDefinitionNameOfficial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthority) and isEmptyProp(FStatus) and isEmptyProp(FDate);
end;

procedure TFhirSubstanceDefinitionNameOfficial.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('authority');
  fields.add('status');
  fields.add('date');
end;

function TFhirSubstanceDefinitionNameOfficial.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetAuthority(value : TFhirCodeableConcept);
begin
  FAuthority.free;
  FAuthority := value;
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirSubstanceDefinitionNameOfficial.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirSubstanceDefinitionNameOfficial.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

{ TFhirSubstanceDefinitionNameOfficialListEnumerator }

constructor TFhirSubstanceDefinitionNameOfficialListEnumerator.Create(list : TFhirSubstanceDefinitionNameOfficialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionNameOfficialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionNameOfficialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionNameOfficialListEnumerator.GetCurrent : TFhirSubstanceDefinitionNameOfficial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionNameOfficialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionNameOfficialList }

function TFhirSubstanceDefinitionNameOfficialList.AddItem(value: TFhirSubstanceDefinitionNameOfficial): TFhirSubstanceDefinitionNameOfficial;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionNameOfficial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionNameOfficial');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionNameOfficialList.Append: TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameOfficialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionNameOfficialList.GetEnumerator : TFhirSubstanceDefinitionNameOfficialListEnumerator;
begin
  result := TFhirSubstanceDefinitionNameOfficialListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionNameOfficialList.Clone: TFhirSubstanceDefinitionNameOfficialList;
begin
  result := TFhirSubstanceDefinitionNameOfficialList(inherited Clone);
end;

function TFhirSubstanceDefinitionNameOfficialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionNameOfficialList.GetItemN(index: Integer): TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameOfficialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionNameOfficial;
end;
function TFhirSubstanceDefinitionNameOfficialList.IndexOf(value: TFhirSubstanceDefinitionNameOfficial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionNameOfficialList.Insert(index: Integer): TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionNameOfficialList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value is TFhirSubstanceDefinitionNameOfficial);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionNameOfficialList.Item(index: Integer): TFhirSubstanceDefinitionNameOfficial;
begin
  result := TFhirSubstanceDefinitionNameOfficial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionNameOfficialList.Link: TFhirSubstanceDefinitionNameOfficialList;
begin
  result := TFhirSubstanceDefinitionNameOfficialList(inherited Link);
end;

procedure TFhirSubstanceDefinitionNameOfficialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionNameOfficialList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value is TFhirSubstanceDefinitionNameOfficial);
  FhirSubstanceDefinitionNameOfficials[index] := value;
end;

procedure TFhirSubstanceDefinitionNameOfficialList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionNameOfficial);
begin
  assert(value is TFhirSubstanceDefinitionNameOfficial);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionRelationship }

constructor TFhirSubstanceDefinitionRelationship.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionRelationship.Destroy;
begin
  FSubstanceDefinition.free;
  FType_.free;
  FIsDefining.free;
  FAmount.free;
  FAmountRatioHighLimit.free;
  FAmountType.free;
  FSourceList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionRelationship.Assign(oSource : TFslObject);
begin
  inherited;
  substanceDefinition := TFhirSubstanceDefinitionRelationship(oSource).substanceDefinition.Clone;
  type_ := TFhirSubstanceDefinitionRelationship(oSource).type_.Clone;
  isDefiningElement := TFhirSubstanceDefinitionRelationship(oSource).isDefiningElement.Clone;
  amount := TFhirSubstanceDefinitionRelationship(oSource).amount.Clone;
  amountRatioHighLimit := TFhirSubstanceDefinitionRelationship(oSource).amountRatioHighLimit.Clone;
  amountType := TFhirSubstanceDefinitionRelationship(oSource).amountType.Clone;
  if (TFhirSubstanceDefinitionRelationship(oSource).FSourceList = nil) then
  begin
    FSourceList.free;
    FSourceList := nil;
  end
  else
  begin
    if FSourceList = nil then
      FSourceList := TFhirReferenceList.Create;
    FSourceList.Assign(TFhirSubstanceDefinitionRelationship(oSource).FSourceList);
  end;
end;

procedure TFhirSubstanceDefinitionRelationship.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substanceDefinition[x]') or (child_name = 'substanceDefinition') Then
     list.add(self.link, 'substanceDefinition[x]', FSubstanceDefinition.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'isDefining') Then
     list.add(self.link, 'isDefining', FIsDefining.Link);
  if (child_name = 'amount[x]') or (child_name = 'amount') Then
     list.add(self.link, 'amount[x]', FAmount.Link);
  if (child_name = 'amountRatioHighLimit') Then
     list.add(self.link, 'amountRatioHighLimit', FAmountRatioHighLimit.Link);
  if (child_name = 'amountType') Then
     list.add(self.link, 'amountType', FAmountType.Link);
  if (child_name = 'source') Then
    list.addAll(self, 'source', FSourceList);
end;

procedure TFhirSubstanceDefinitionRelationship.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substanceDefinition[x]', 'Reference|CodeableConcept', false, TFhirDataType, FSubstanceDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'isDefining', 'boolean', false, TFhirBoolean, FIsDefining.Link));
  oList.add(TFHIRProperty.create(self, 'amount[x]', 'Quantity|Ratio|string', false, TFhirDataType, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'amountRatioHighLimit', 'Ratio', false, TFhirRatio, FAmountRatioHighLimit.Link));
  oList.add(TFHIRProperty.create(self, 'amountType', 'CodeableConcept', false, TFhirCodeableConcept, FAmountType.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', true, TFhirReference, FSourceList.Link));
end;

function TFhirSubstanceDefinitionRelationship.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then
  begin
    SubstanceDefinition := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'isDefining') then
  begin
    IsDefiningElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Ratio', 'String'])) then
  begin
    Amount := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'amountRatioHighLimit') then
  begin
    AmountRatioHighLimit := propValue as TFhirRatio;
    result := propValue;
  end
  else if (propName = 'amountType') then
  begin
    AmountType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionRelationship.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'source') then SourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubstanceDefinitionRelationship.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property SubstanceDefinition')
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'isDefining') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Ratio', 'String'])) then raise EFHIRException.create('Cannot make property Amount')
  else if (propName = 'amountRatioHighLimit') then result := TFhirRatio.create()
  else if (propName = 'amountType') then result := TFhirCodeableConcept.create()
  else if (propName = 'source') then result := SourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionRelationship.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substanceDefinition[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'isDefining') then result := 'boolean'
  else if (propName = 'amount[x]') then result := 'Quantity|Ratio|string'
  else if (propName = 'amountRatioHighLimit') then result := 'Ratio'
  else if (propName = 'amountType') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionRelationship.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then SubstanceDefinitionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'isDefining') then IsDefiningElement := nil
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Ratio', 'String'])) then AmountElement := nil
  else if (propName = 'amountRatioHighLimit') then AmountRatioHighLimitElement := nil
  else if (propName = 'amountType') then AmountTypeElement := nil
  else if (propName = 'source') then deletePropertyValue('source', SourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionRelationship.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'substanceDefinition', ['Reference', 'CodeableConcept'])) then SubstanceDefinitionElement := new as TFhirDataType
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'isDefining') then IsDefiningElement := asBoolean(new)
  else if (isMatchingName(propName, 'amount', ['Quantity', 'Ratio', 'String'])) then AmountElement := new as TFhirDataType
  else if (propName = 'amountRatioHighLimit') then AmountRatioHighLimitElement := new as TFhirRatio
  else if (propName = 'amountType') then AmountTypeElement := new as TFhirCodeableConcept
  else if (propName = 'source') then replacePropertyValue('source', SourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionRelationship.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'source') then SourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionRelationship.fhirType : string;
begin
  result := 'SubstanceDefinition.relationship';
end;

function TFhirSubstanceDefinitionRelationship.Link : TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(inherited Link);
end;

function TFhirSubstanceDefinitionRelationship.Clone : TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(inherited Clone);
end;

function TFhirSubstanceDefinitionRelationship.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionRelationship;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionRelationship)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionRelationship(other);
    result := compareDeep(substanceDefinitionElement, o.substanceDefinitionElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(isDefiningElement, o.isDefiningElement, true) and 
      compareDeep(amountElement, o.amountElement, true) and compareDeep(amountRatioHighLimitElement, o.amountRatioHighLimitElement, true) and 
      compareDeep(amountTypeElement, o.amountTypeElement, true) and compareDeep(sourceList, o.sourceList, true);
  end;
end;

function TFhirSubstanceDefinitionRelationship.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstanceDefinition) and isEmptyProp(FType_) and isEmptyProp(FIsDefining) and isEmptyProp(FAmount) and isEmptyProp(FAmountRatioHighLimit) and isEmptyProp(FAmountType) and isEmptyProp(FsourceList);
end;

procedure TFhirSubstanceDefinitionRelationship.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('substanceDefinition[x]');
  fields.add('type');
  fields.add('isDefining');
  fields.add('amount[x]');
  fields.add('amountRatioHighLimit');
  fields.add('amountType');
  fields.add('source');
end;

function TFhirSubstanceDefinitionRelationship.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSourceList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionRelationship.SetSubstanceDefinition(value : TFhirDataType);
begin
  FSubstanceDefinition.free;
  FSubstanceDefinition := value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetIsDefining(value : TFhirBoolean);
begin
  FIsDefining.free;
  FIsDefining := value;
end;

function TFhirSubstanceDefinitionRelationship.GetIsDefiningST : Boolean;
begin
  if FIsDefining = nil then
    result := false
  else
    result := FIsDefining.value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetIsDefiningST(value : Boolean);
begin
  if FIsDefining = nil then
    FIsDefining := TFhirBoolean.create;
  FIsDefining.value := value
end;

procedure TFhirSubstanceDefinitionRelationship.SetAmount(value : TFhirDataType);
begin
  FAmount.free;
  FAmount := value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetAmountRatioHighLimit(value : TFhirRatio);
begin
  FAmountRatioHighLimit.free;
  FAmountRatioHighLimit := value;
end;

procedure TFhirSubstanceDefinitionRelationship.SetAmountType(value : TFhirCodeableConcept);
begin
  FAmountType.free;
  FAmountType := value;
end;

function TFhirSubstanceDefinitionRelationship.GetSourceList : TFhirReferenceList;
begin
  if FSourceList = nil then
    FSourceList := TFhirReferenceList.Create;
  result := FSourceList;
end;

function TFhirSubstanceDefinitionRelationship.GetHasSourceList : boolean;
begin
  result := (FSourceList <> nil) and (FSourceList.count > 0);
end;

{ TFhirSubstanceDefinitionRelationshipListEnumerator }

constructor TFhirSubstanceDefinitionRelationshipListEnumerator.Create(list : TFhirSubstanceDefinitionRelationshipList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionRelationshipListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionRelationshipListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionRelationshipListEnumerator.GetCurrent : TFhirSubstanceDefinitionRelationship;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionRelationshipListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionRelationshipList }

function TFhirSubstanceDefinitionRelationshipList.AddItem(value: TFhirSubstanceDefinitionRelationship): TFhirSubstanceDefinitionRelationship;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionRelationship', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionRelationship');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionRelationshipList.Append: TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionRelationshipList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionRelationshipList.GetEnumerator : TFhirSubstanceDefinitionRelationshipListEnumerator;
begin
  result := TFhirSubstanceDefinitionRelationshipListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionRelationshipList.Clone: TFhirSubstanceDefinitionRelationshipList;
begin
  result := TFhirSubstanceDefinitionRelationshipList(inherited Clone);
end;

function TFhirSubstanceDefinitionRelationshipList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionRelationshipList.GetItemN(index: Integer): TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionRelationshipList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionRelationship;
end;
function TFhirSubstanceDefinitionRelationshipList.IndexOf(value: TFhirSubstanceDefinitionRelationship): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionRelationshipList.Insert(index: Integer): TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionRelationshipList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value is TFhirSubstanceDefinitionRelationship);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionRelationshipList.Item(index: Integer): TFhirSubstanceDefinitionRelationship;
begin
  result := TFhirSubstanceDefinitionRelationship(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionRelationshipList.Link: TFhirSubstanceDefinitionRelationshipList;
begin
  result := TFhirSubstanceDefinitionRelationshipList(inherited Link);
end;

procedure TFhirSubstanceDefinitionRelationshipList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionRelationshipList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value is TFhirSubstanceDefinitionRelationship);
  FhirSubstanceDefinitionRelationships[index] := value;
end;

procedure TFhirSubstanceDefinitionRelationshipList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionRelationship);
begin
  assert(value is TFhirSubstanceDefinitionRelationship);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinitionSourceMaterial }

constructor TFhirSubstanceDefinitionSourceMaterial.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinitionSourceMaterial.Destroy;
begin
  FType_.free;
  FGenus.free;
  FSpecies.free;
  FPart.free;
  FCountryOfOriginList.Free;
  inherited;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirSubstanceDefinitionSourceMaterial(oSource).type_.Clone;
  genus := TFhirSubstanceDefinitionSourceMaterial(oSource).genus.Clone;
  species := TFhirSubstanceDefinitionSourceMaterial(oSource).species.Clone;
  part := TFhirSubstanceDefinitionSourceMaterial(oSource).part.Clone;
  if (TFhirSubstanceDefinitionSourceMaterial(oSource).FCountryOfOriginList = nil) then
  begin
    FCountryOfOriginList.free;
    FCountryOfOriginList := nil;
  end
  else
  begin
    if FCountryOfOriginList = nil then
      FCountryOfOriginList := TFhirCodeableConceptList.Create;
    FCountryOfOriginList.Assign(TFhirSubstanceDefinitionSourceMaterial(oSource).FCountryOfOriginList);
  end;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'genus') Then
     list.add(self.link, 'genus', FGenus.Link);
  if (child_name = 'species') Then
     list.add(self.link, 'species', FSpecies.Link);
  if (child_name = 'part') Then
     list.add(self.link, 'part', FPart.Link);
  if (child_name = 'countryOfOrigin') Then
    list.addAll(self, 'countryOfOrigin', FCountryOfOriginList);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'genus', 'CodeableConcept', false, TFhirCodeableConcept, FGenus.Link));
  oList.add(TFHIRProperty.create(self, 'species', 'CodeableConcept', false, TFhirCodeableConcept, FSpecies.Link));
  oList.add(TFHIRProperty.create(self, 'part', 'CodeableConcept', false, TFhirCodeableConcept, FPart.Link));
  oList.add(TFHIRProperty.create(self, 'countryOfOrigin', 'CodeableConcept', true, TFhirCodeableConcept, FCountryOfOriginList.Link));
end;

function TFhirSubstanceDefinitionSourceMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'genus') then
  begin
    Genus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'species') then
  begin
    Species := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    Part := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'countryOfOrigin') then
  begin
    CountryOfOriginList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'countryOfOrigin') then CountryOfOriginList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirSubstanceDefinitionSourceMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'genus') then result := TFhirCodeableConcept.create()
  else if (propName = 'species') then result := TFhirCodeableConcept.create()
  else if (propName = 'part') then result := TFhirCodeableConcept.create()
  else if (propName = 'countryOfOrigin') then result := CountryOfOriginList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinitionSourceMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'genus') then result := 'CodeableConcept'
  else if (propName = 'species') then result := 'CodeableConcept'
  else if (propName = 'part') then result := 'CodeableConcept'
  else if (propName = 'countryOfOrigin') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'genus') then GenusElement := nil
  else if (propName = 'species') then SpeciesElement := nil
  else if (propName = 'part') then PartElement := nil
  else if (propName = 'countryOfOrigin') then deletePropertyValue('countryOfOrigin', CountryOfOriginList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'genus') then GenusElement := new as TFhirCodeableConcept
  else if (propName = 'species') then SpeciesElement := new as TFhirCodeableConcept
  else if (propName = 'part') then PartElement := new as TFhirCodeableConcept
  else if (propName = 'countryOfOrigin') then replacePropertyValue('countryOfOrigin', CountryOfOriginList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'countryOfOrigin') then CountryOfOriginList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinitionSourceMaterial.fhirType : string;
begin
  result := 'SubstanceDefinition.sourceMaterial';
end;

function TFhirSubstanceDefinitionSourceMaterial.Link : TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial(inherited Link);
end;

function TFhirSubstanceDefinitionSourceMaterial.Clone : TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial(inherited Clone);
end;

function TFhirSubstanceDefinitionSourceMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinitionSourceMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinitionSourceMaterial)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinitionSourceMaterial(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(genusElement, o.genusElement, true) and 
      compareDeep(speciesElement, o.speciesElement, true) and compareDeep(partElement, o.partElement, true) and 
      compareDeep(countryOfOriginList, o.countryOfOriginList, true);
  end;
end;

function TFhirSubstanceDefinitionSourceMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FGenus) and isEmptyProp(FSpecies) and isEmptyProp(FPart) and isEmptyProp(FcountryOfOriginList);
end;

procedure TFhirSubstanceDefinitionSourceMaterial.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('genus');
  fields.add('species');
  fields.add('part');
  fields.add('countryOfOrigin');
end;

function TFhirSubstanceDefinitionSourceMaterial.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCountryOfOriginList.sizeInBytes(magic));
end;

procedure TFhirSubstanceDefinitionSourceMaterial.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.SetGenus(value : TFhirCodeableConcept);
begin
  FGenus.free;
  FGenus := value;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.SetSpecies(value : TFhirCodeableConcept);
begin
  FSpecies.free;
  FSpecies := value;
end;

procedure TFhirSubstanceDefinitionSourceMaterial.SetPart(value : TFhirCodeableConcept);
begin
  FPart.free;
  FPart := value;
end;

function TFhirSubstanceDefinitionSourceMaterial.GetCountryOfOriginList : TFhirCodeableConceptList;
begin
  if FCountryOfOriginList = nil then
    FCountryOfOriginList := TFhirCodeableConceptList.Create;
  result := FCountryOfOriginList;
end;

function TFhirSubstanceDefinitionSourceMaterial.GetHasCountryOfOriginList : boolean;
begin
  result := (FCountryOfOriginList <> nil) and (FCountryOfOriginList.count > 0);
end;

{ TFhirSubstanceDefinitionSourceMaterialListEnumerator }

constructor TFhirSubstanceDefinitionSourceMaterialListEnumerator.Create(list : TFhirSubstanceDefinitionSourceMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionSourceMaterialListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionSourceMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionSourceMaterialListEnumerator.GetCurrent : TFhirSubstanceDefinitionSourceMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionSourceMaterialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionSourceMaterialList }

function TFhirSubstanceDefinitionSourceMaterialList.AddItem(value: TFhirSubstanceDefinitionSourceMaterial): TFhirSubstanceDefinitionSourceMaterial;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinitionSourceMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinitionSourceMaterial');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionSourceMaterialList.Append: TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionSourceMaterialList.GetEnumerator : TFhirSubstanceDefinitionSourceMaterialListEnumerator;
begin
  result := TFhirSubstanceDefinitionSourceMaterialListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Clone: TFhirSubstanceDefinitionSourceMaterialList;
begin
  result := TFhirSubstanceDefinitionSourceMaterialList(inherited Clone);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionSourceMaterialList.GetItemN(index: Integer): TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionSourceMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinitionSourceMaterial;
end;
function TFhirSubstanceDefinitionSourceMaterialList.IndexOf(value: TFhirSubstanceDefinitionSourceMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Insert(index: Integer): TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.InsertItem(index: Integer; value: TFhirSubstanceDefinitionSourceMaterial);
begin
  assert(value is TFhirSubstanceDefinitionSourceMaterial);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Item(index: Integer): TFhirSubstanceDefinitionSourceMaterial;
begin
  result := TFhirSubstanceDefinitionSourceMaterial(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionSourceMaterialList.Link: TFhirSubstanceDefinitionSourceMaterialList;
begin
  result := TFhirSubstanceDefinitionSourceMaterialList(inherited Link);
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinitionSourceMaterial);
begin
  assert(value is TFhirSubstanceDefinitionSourceMaterial);
  FhirSubstanceDefinitionSourceMaterials[index] := value;
end;

procedure TFhirSubstanceDefinitionSourceMaterialList.SetItemN(index: Integer; value: TFhirSubstanceDefinitionSourceMaterial);
begin
  assert(value is TFhirSubstanceDefinitionSourceMaterial);
  ObjectByIndex[index] := value;
end;

{ TFhirSubstanceDefinition }

constructor TFhirSubstanceDefinition.Create;
begin
  inherited;
end;

destructor TFhirSubstanceDefinition.Destroy;
begin
  FIdentifierList.Free;
  FVersion.free;
  FStatus.free;
  FClassificationList.Free;
  FDomain.free;
  FGradeList.Free;
  FDescription.free;
  FInformationSourceList.Free;
  FNoteList.Free;
  FManufacturerList.Free;
  FSupplierList.Free;
  FMoietyList.Free;
  FProperty_List.Free;
  FMolecularWeightList.Free;
  FStructure.free;
  FCodeList.Free;
  FNameList.Free;
  FRelationshipList.Free;
  FSourceMaterial.free;
  inherited;
end;

procedure TFhirSubstanceDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSubstanceDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSubstanceDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirSubstanceDefinition(oSource).versionElement.Clone;
  status := TFhirSubstanceDefinition(oSource).status.Clone;
  if (TFhirSubstanceDefinition(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirSubstanceDefinition(oSource).FClassificationList);
  end;
  domain := TFhirSubstanceDefinition(oSource).domain.Clone;
  if (TFhirSubstanceDefinition(oSource).FGradeList = nil) then
  begin
    FGradeList.free;
    FGradeList := nil;
  end
  else
  begin
    if FGradeList = nil then
      FGradeList := TFhirCodeableConceptList.Create;
    FGradeList.Assign(TFhirSubstanceDefinition(oSource).FGradeList);
  end;
  descriptionElement := TFhirSubstanceDefinition(oSource).descriptionElement.Clone;
  if (TFhirSubstanceDefinition(oSource).FInformationSourceList = nil) then
  begin
    FInformationSourceList.free;
    FInformationSourceList := nil;
  end
  else
  begin
    if FInformationSourceList = nil then
      FInformationSourceList := TFhirReferenceList.Create;
    FInformationSourceList.Assign(TFhirSubstanceDefinition(oSource).FInformationSourceList);
  end;
  if (TFhirSubstanceDefinition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirSubstanceDefinition(oSource).FNoteList);
  end;
  if (TFhirSubstanceDefinition(oSource).FManufacturerList = nil) then
  begin
    FManufacturerList.free;
    FManufacturerList := nil;
  end
  else
  begin
    if FManufacturerList = nil then
      FManufacturerList := TFhirReferenceList.Create;
    FManufacturerList.Assign(TFhirSubstanceDefinition(oSource).FManufacturerList);
  end;
  if (TFhirSubstanceDefinition(oSource).FSupplierList = nil) then
  begin
    FSupplierList.free;
    FSupplierList := nil;
  end
  else
  begin
    if FSupplierList = nil then
      FSupplierList := TFhirReferenceList.Create;
    FSupplierList.Assign(TFhirSubstanceDefinition(oSource).FSupplierList);
  end;
  if (TFhirSubstanceDefinition(oSource).FMoietyList = nil) then
  begin
    FMoietyList.free;
    FMoietyList := nil;
  end
  else
  begin
    if FMoietyList = nil then
      FMoietyList := TFhirSubstanceDefinitionMoietyList.Create;
    FMoietyList.Assign(TFhirSubstanceDefinition(oSource).FMoietyList);
  end;
  if (TFhirSubstanceDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirSubstanceDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirSubstanceDefinition(oSource).FProperty_List);
  end;
  if (TFhirSubstanceDefinition(oSource).FMolecularWeightList = nil) then
  begin
    FMolecularWeightList.free;
    FMolecularWeightList := nil;
  end
  else
  begin
    if FMolecularWeightList = nil then
      FMolecularWeightList := TFhirSubstanceDefinitionMolecularWeightList.Create;
    FMolecularWeightList.Assign(TFhirSubstanceDefinition(oSource).FMolecularWeightList);
  end;
  structure := TFhirSubstanceDefinition(oSource).structure.Clone;
  if (TFhirSubstanceDefinition(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirSubstanceDefinitionCodeList.Create;
    FCodeList.Assign(TFhirSubstanceDefinition(oSource).FCodeList);
  end;
  if (TFhirSubstanceDefinition(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirSubstanceDefinitionNameList.Create;
    FNameList.Assign(TFhirSubstanceDefinition(oSource).FNameList);
  end;
  if (TFhirSubstanceDefinition(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirSubstanceDefinitionRelationshipList.Create;
    FRelationshipList.Assign(TFhirSubstanceDefinition(oSource).FRelationshipList);
  end;
  sourceMaterial := TFhirSubstanceDefinition(oSource).sourceMaterial.Clone;
end;

function TFhirSubstanceDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtSubstanceDefinition;
end;

procedure TFhirSubstanceDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'domain') Then
     list.add(self.link, 'domain', FDomain.Link);
  if (child_name = 'grade') Then
    list.addAll(self, 'grade', FGradeList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'informationSource') Then
    list.addAll(self, 'informationSource', FInformationSourceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'manufacturer') Then
    list.addAll(self, 'manufacturer', FManufacturerList);
  if (child_name = 'supplier') Then
    list.addAll(self, 'supplier', FSupplierList);
  if (child_name = 'moiety') Then
    list.addAll(self, 'moiety', FMoietyList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'molecularWeight') Then
    list.addAll(self, 'molecularWeight', FMolecularWeightList);
  if (child_name = 'structure') Then
     list.add(self.link, 'structure', FStructure.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'sourceMaterial') Then
     list.add(self.link, 'sourceMaterial', FSourceMaterial.Link);
end;

procedure TFhirSubstanceDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link));
  oList.add(TFHIRProperty.create(self, 'domain', 'CodeableConcept', false, TFhirCodeableConcept, FDomain.Link));
  oList.add(TFHIRProperty.create(self, 'grade', 'CodeableConcept', true, TFhirCodeableConcept, FGradeList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'informationSource', 'Reference', true, TFhirReference, FInformationSourceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', true, TFhirReference, FManufacturerList.Link));
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference', true, TFhirReference, FSupplierList.Link));
  oList.add(TFHIRProperty.create(self, 'moiety', 'BackboneElement', true, TFhirSubstanceDefinitionMoiety, FMoietyList.Link));
  oList.add(TFHIRProperty.create(self, 'property', 'BackboneElement', true, TFhirSubstanceDefinitionProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.create(self, 'molecularWeight', 'BackboneElement', true, TFhirSubstanceDefinitionMolecularWeight, FMolecularWeightList.Link));
  oList.add(TFHIRProperty.create(self, 'structure', 'BackboneElement', false, TFhirSubstanceDefinitionStructure, FStructure.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'BackboneElement', true, TFhirSubstanceDefinitionCode, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'BackboneElement', true, TFhirSubstanceDefinitionName, FNameList.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'BackboneElement', true, TFhirSubstanceDefinitionRelationship, FRelationshipList.Link));
  oList.add(TFHIRProperty.create(self, 'sourceMaterial', 'BackboneElement', false, TFhirSubstanceDefinitionSourceMaterial, FSourceMaterial.Link));
end;

function TFhirSubstanceDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    Domain := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'grade') then
  begin
    GradeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'informationSource') then
  begin
    InformationSourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    SupplierList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'moiety') then
  begin
    MoietyList.add(propValue as TFhirSubstanceDefinitionMoiety);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirSubstanceDefinitionProperty);
    result := propValue;
  end
  else if (propName = 'molecularWeight') then
  begin
    MolecularWeightList.add(propValue as TFhirSubstanceDefinitionMolecularWeight);
    result := propValue;
  end
  else if (propName = 'structure') then
  begin
    Structure := propValue as TFhirSubstanceDefinitionStructure;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirSubstanceDefinitionCode);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirSubstanceDefinitionName);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirSubstanceDefinitionRelationship);
    result := propValue;
  end
  else if (propName = 'sourceMaterial') then
  begin
    SourceMaterial := propValue as TFhirSubstanceDefinitionSourceMaterial;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubstanceDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'grade') then GradeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'informationSource') then InformationSourceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'manufacturer') then ManufacturerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'supplier') then SupplierList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'moiety') then MoietyList.insertItem(index, propValue as TFhirSubstanceDefinitionMoiety)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirSubstanceDefinitionProperty)
  else if (propName = 'molecularWeight') then MolecularWeightList.insertItem(index, propValue as TFhirSubstanceDefinitionMolecularWeight)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirSubstanceDefinitionCode)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirSubstanceDefinitionName)
  else if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirSubstanceDefinitionRelationship)
  else inherited;
end;

function TFhirSubstanceDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'classification') then result := ClassificationList.new()
  else if (propName = 'domain') then result := TFhirCodeableConcept.create()
  else if (propName = 'grade') then result := GradeList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'informationSource') then result := InformationSourceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'manufacturer') then result := ManufacturerList.new()
  else if (propName = 'supplier') then result := SupplierList.new()
  else if (propName = 'moiety') then result := MoietyList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'molecularWeight') then result := MolecularWeightList.new()
  else if (propName = 'structure') then result := TFhirSubstanceDefinitionStructure.create()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'relationship') then result := RelationshipList.new()
  else if (propName = 'sourceMaterial') then result := TFhirSubstanceDefinitionSourceMaterial.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubstanceDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'domain') then result := 'CodeableConcept'
  else if (propName = 'grade') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'informationSource') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'moiety') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'molecularWeight') then result := 'BackboneElement'
  else if (propName = 'structure') then result := 'BackboneElement'
  else if (propName = 'code') then result := 'BackboneElement'
  else if (propName = 'name') then result := 'BackboneElement'
  else if (propName = 'relationship') then result := 'BackboneElement'
  else if (propName = 'sourceMaterial') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubstanceDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else if (propName = 'domain') then DomainElement := nil
  else if (propName = 'grade') then deletePropertyValue('grade', GradeList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'informationSource') then deletePropertyValue('informationSource', InformationSourceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'manufacturer') then deletePropertyValue('manufacturer', ManufacturerList, value)
  else if (propName = 'supplier') then deletePropertyValue('supplier', SupplierList, value)
  else if (propName = 'moiety') then deletePropertyValue('moiety', MoietyList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'molecularWeight') then deletePropertyValue('molecularWeight', MolecularWeightList, value)
  else if (propName = 'structure') then StructureElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value)
  else if (propName = 'sourceMaterial') then SourceMaterialElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubstanceDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else if (propName = 'domain') then DomainElement := new as TFhirCodeableConcept
  else if (propName = 'grade') then replacePropertyValue('grade', GradeList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'informationSource') then replacePropertyValue('informationSource', InformationSourceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'manufacturer') then replacePropertyValue('manufacturer', ManufacturerList, existing, new)
  else if (propName = 'supplier') then replacePropertyValue('supplier', SupplierList, existing, new)
  else if (propName = 'moiety') then replacePropertyValue('moiety', MoietyList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'molecularWeight') then replacePropertyValue('molecularWeight', MolecularWeightList, existing, new)
  else if (propName = 'structure') then StructureElement := new as TFhirSubstanceDefinitionStructure
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new)
  else if (propName = 'sourceMaterial') then SourceMaterialElement := new as TFhirSubstanceDefinitionSourceMaterial
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubstanceDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'classification') then ClassificationList.move(source, destination)
  else if (propName = 'grade') then GradeList.move(source, destination)
  else if (propName = 'informationSource') then InformationSourceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'manufacturer') then ManufacturerList.move(source, destination)
  else if (propName = 'supplier') then SupplierList.move(source, destination)
  else if (propName = 'moiety') then MoietyList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'molecularWeight') then MolecularWeightList.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'relationship') then RelationshipList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubstanceDefinition.fhirType : string;
begin
  result := 'SubstanceDefinition';
end;

function TFhirSubstanceDefinition.Link : TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(inherited Link);
end;

function TFhirSubstanceDefinition.Clone : TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(inherited Clone);
end;

function TFhirSubstanceDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirSubstanceDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubstanceDefinition)) then
    result := false
  else
  begin
    o := TFhirSubstanceDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(versionElement, o.versionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(classificationList, o.classificationList, true) and 
      compareDeep(domainElement, o.domainElement, true) and compareDeep(gradeList, o.gradeList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(informationSourceList, o.informationSourceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(manufacturerList, o.manufacturerList, true) and 
      compareDeep(supplierList, o.supplierList, true) and compareDeep(moietyList, o.moietyList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(molecularWeightList, o.molecularWeightList, true) and 
      compareDeep(structureElement, o.structureElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(relationshipList, o.relationshipList, true) and 
      compareDeep(sourceMaterialElement, o.sourceMaterialElement, true);
  end;
end;

function TFhirSubstanceDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FclassificationList) and isEmptyProp(FDomain) and isEmptyProp(FgradeList) and isEmptyProp(FDescription) and isEmptyProp(FinformationSourceList) and isEmptyProp(FnoteList) and isEmptyProp(FmanufacturerList) and isEmptyProp(FsupplierList) and isEmptyProp(FmoietyList) and isEmptyProp(Fproperty_List) and isEmptyProp(FmolecularWeightList) and isEmptyProp(FStructure) and isEmptyProp(FcodeList) and isEmptyProp(FnameList) and isEmptyProp(FrelationshipList) and isEmptyProp(FSourceMaterial);
end;

procedure TFhirSubstanceDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('version');
  fields.add('status');
  fields.add('classification');
  fields.add('domain');
  fields.add('grade');
  fields.add('description');
  fields.add('informationSource');
  fields.add('note');
  fields.add('manufacturer');
  fields.add('supplier');
  fields.add('moiety');
  fields.add('property');
  fields.add('molecularWeight');
  fields.add('structure');
  fields.add('code');
  fields.add('name');
  fields.add('relationship');
  fields.add('sourceMaterial');
end;

function TFhirSubstanceDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FClassificationList.sizeInBytes(magic));
  inc(result, FGradeList.sizeInBytes(magic));
  inc(result, FInformationSourceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FManufacturerList.sizeInBytes(magic));
  inc(result, FSupplierList.sizeInBytes(magic));
  inc(result, FMoietyList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FMolecularWeightList.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FRelationshipList.sizeInBytes(magic));
end;

function TFhirSubstanceDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSubstanceDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirSubstanceDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirSubstanceDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirSubstanceDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubstanceDefinition.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirSubstanceDefinition.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetDomain(value : TFhirCodeableConcept);
begin
  FDomain.free;
  FDomain := value;
end;

function TFhirSubstanceDefinition.GetGradeList : TFhirCodeableConceptList;
begin
  if FGradeList = nil then
    FGradeList := TFhirCodeableConceptList.Create;
  result := FGradeList;
end;

function TFhirSubstanceDefinition.GetHasGradeList : boolean;
begin
  result := (FGradeList <> nil) and (FGradeList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubstanceDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubstanceDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirSubstanceDefinition.GetInformationSourceList : TFhirReferenceList;
begin
  if FInformationSourceList = nil then
    FInformationSourceList := TFhirReferenceList.Create;
  result := FInformationSourceList;
end;

function TFhirSubstanceDefinition.GetHasInformationSourceList : boolean;
begin
  result := (FInformationSourceList <> nil) and (FInformationSourceList.count > 0);
end;

function TFhirSubstanceDefinition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirSubstanceDefinition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirSubstanceDefinition.GetManufacturerList : TFhirReferenceList;
begin
  if FManufacturerList = nil then
    FManufacturerList := TFhirReferenceList.Create;
  result := FManufacturerList;
end;

function TFhirSubstanceDefinition.GetHasManufacturerList : boolean;
begin
  result := (FManufacturerList <> nil) and (FManufacturerList.count > 0);
end;

function TFhirSubstanceDefinition.GetSupplierList : TFhirReferenceList;
begin
  if FSupplierList = nil then
    FSupplierList := TFhirReferenceList.Create;
  result := FSupplierList;
end;

function TFhirSubstanceDefinition.GetHasSupplierList : boolean;
begin
  result := (FSupplierList <> nil) and (FSupplierList.count > 0);
end;

function TFhirSubstanceDefinition.GetMoietyList : TFhirSubstanceDefinitionMoietyList;
begin
  if FMoietyList = nil then
    FMoietyList := TFhirSubstanceDefinitionMoietyList.Create;
  result := FMoietyList;
end;

function TFhirSubstanceDefinition.GetHasMoietyList : boolean;
begin
  result := (FMoietyList <> nil) and (FMoietyList.count > 0);
end;

function TFhirSubstanceDefinition.GetProperty_List : TFhirSubstanceDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirSubstanceDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirSubstanceDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

function TFhirSubstanceDefinition.GetMolecularWeightList : TFhirSubstanceDefinitionMolecularWeightList;
begin
  if FMolecularWeightList = nil then
    FMolecularWeightList := TFhirSubstanceDefinitionMolecularWeightList.Create;
  result := FMolecularWeightList;
end;

function TFhirSubstanceDefinition.GetHasMolecularWeightList : boolean;
begin
  result := (FMolecularWeightList <> nil) and (FMolecularWeightList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetStructure(value : TFhirSubstanceDefinitionStructure);
begin
  FStructure.free;
  FStructure := value;
end;

function TFhirSubstanceDefinition.GetCodeList : TFhirSubstanceDefinitionCodeList;
begin
  if FCodeList = nil then
    FCodeList := TFhirSubstanceDefinitionCodeList.Create;
  result := FCodeList;
end;

function TFhirSubstanceDefinition.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirSubstanceDefinition.GetNameList : TFhirSubstanceDefinitionNameList;
begin
  if FNameList = nil then
    FNameList := TFhirSubstanceDefinitionNameList.Create;
  result := FNameList;
end;

function TFhirSubstanceDefinition.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirSubstanceDefinition.GetRelationshipList : TFhirSubstanceDefinitionRelationshipList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirSubstanceDefinitionRelationshipList.Create;
  result := FRelationshipList;
end;

function TFhirSubstanceDefinition.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

procedure TFhirSubstanceDefinition.SetSourceMaterial(value : TFhirSubstanceDefinitionSourceMaterial);
begin
  FSourceMaterial.free;
  FSourceMaterial := value;
end;

{ TFhirSubstanceDefinitionListEnumerator }

constructor TFhirSubstanceDefinitionListEnumerator.Create(list : TFhirSubstanceDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubstanceDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubstanceDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubstanceDefinitionListEnumerator.GetCurrent : TFhirSubstanceDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirSubstanceDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubstanceDefinitionList }

function TFhirSubstanceDefinitionList.AddItem(value: TFhirSubstanceDefinition): TFhirSubstanceDefinition;
begin
  assert(value.ClassName = 'TFhirSubstanceDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubstanceDefinition');
  add(value);
  result := value;
end;

function TFhirSubstanceDefinitionList.Append: TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirSubstanceDefinitionList.GetEnumerator : TFhirSubstanceDefinitionListEnumerator;
begin
  result := TFhirSubstanceDefinitionListEnumerator.Create(self.link);
end;

function TFhirSubstanceDefinitionList.Clone: TFhirSubstanceDefinitionList;
begin
  result := TFhirSubstanceDefinitionList(inherited Clone);
end;

function TFhirSubstanceDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubstanceDefinitionList.GetItemN(index: Integer): TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubstanceDefinition;
end;
function TFhirSubstanceDefinitionList.IndexOf(value: TFhirSubstanceDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubstanceDefinitionList.Insert(index: Integer): TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubstanceDefinitionList.InsertItem(index: Integer; value: TFhirSubstanceDefinition);
begin
  assert(value is TFhirSubstanceDefinition);
  Inherited Insert(index, value);
end;

function TFhirSubstanceDefinitionList.Item(index: Integer): TFhirSubstanceDefinition;
begin
  result := TFhirSubstanceDefinition(ObjectByIndex[index]);
end;

function TFhirSubstanceDefinitionList.Link: TFhirSubstanceDefinitionList;
begin
  result := TFhirSubstanceDefinitionList(inherited Link);
end;

procedure TFhirSubstanceDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubstanceDefinitionList.SetItemByIndex(index: Integer; value: TFhirSubstanceDefinition);
begin
  assert(value is TFhirSubstanceDefinition);
  FhirSubstanceDefinitions[index] := value;
end;

procedure TFhirSubstanceDefinitionList.SetItemN(index: Integer; value: TFhirSubstanceDefinition);
begin
  assert(value is TFhirSubstanceDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSTANCEDEFINITION}


end.

