unit fhir4b_resources_clinical;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir4b.inc}

interface

// Generated on Mon, Dec 27, 2021 21:46+1100 for FHIR v4.3.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities,  
  fhir4b_base, fhir4b_enums, fhir4b_types, fhir4b_resources_base, fhir4b_resources_canonical;



type
{$IFDEF FHIR_ADVERSEEVENT}
  TFhirAdverseEventSuspectEntity = class;
  TFhirAdverseEventSuspectEntityList = class;
  TFhirAdverseEventSuspectEntityCausality = class;
  TFhirAdverseEventSuspectEntityCausalityList = class;
  TFhirAdverseEvent = class;
  TFhirAdverseEventList = class;
{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  TFhirAllergyIntoleranceReaction = class;
  TFhirAllergyIntoleranceReactionList = class;
  TFhirAllergyIntolerance = class;
  TFhirAllergyIntoleranceList = class;
{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  TFhirAppointmentParticipant = class;
  TFhirAppointmentParticipantList = class;
  TFhirAppointment = class;
  TFhirAppointmentList = class;
{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  TFhirAppointmentResponse = class;
  TFhirAppointmentResponseList = class;
{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_BASIC}
  TFhirBasic = class;
  TFhirBasicList = class;
{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  TFhirBiologicallyDerivedProductCollection = class;
  TFhirBiologicallyDerivedProductCollectionList = class;
  TFhirBiologicallyDerivedProductProcessing = class;
  TFhirBiologicallyDerivedProductProcessingList = class;
  TFhirBiologicallyDerivedProductManipulation = class;
  TFhirBiologicallyDerivedProductManipulationList = class;
  TFhirBiologicallyDerivedProductStorage = class;
  TFhirBiologicallyDerivedProductStorageList = class;
  TFhirBiologicallyDerivedProduct = class;
  TFhirBiologicallyDerivedProductList = class;
{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  TFhirBodyStructure = class;
  TFhirBodyStructureList = class;
{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_CAREPLAN}
  TFhirCarePlanActivity = class;
  TFhirCarePlanActivityList = class;
  TFhirCarePlanActivityDetail = class;
  TFhirCarePlanActivityDetailList = class;
  TFhirCarePlan = class;
  TFhirCarePlanList = class;
{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  TFhirCareTeamParticipant = class;
  TFhirCareTeamParticipantList = class;
  TFhirCareTeam = class;
  TFhirCareTeamList = class;
{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CLINICALIMPRESSION}
  TFhirClinicalImpressionInvestigation = class;
  TFhirClinicalImpressionInvestigationList = class;
  TFhirClinicalImpressionFinding = class;
  TFhirClinicalImpressionFindingList = class;
  TFhirClinicalImpression = class;
  TFhirClinicalImpressionList = class;
{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
  TFhirClinicalUseDefinitionContraindication = class;
  TFhirClinicalUseDefinitionContraindicationList = class;
  TFhirClinicalUseDefinitionContraindicationOtherTherapy = class;
  TFhirClinicalUseDefinitionContraindicationOtherTherapyList = class;
  TFhirClinicalUseDefinitionIndication = class;
  TFhirClinicalUseDefinitionIndicationList = class;
  TFhirClinicalUseDefinitionInteraction = class;
  TFhirClinicalUseDefinitionInteractionList = class;
  TFhirClinicalUseDefinitionInteractionInteractant = class;
  TFhirClinicalUseDefinitionInteractionInteractantList = class;
  TFhirClinicalUseDefinitionUndesirableEffect = class;
  TFhirClinicalUseDefinitionUndesirableEffectList = class;
  TFhirClinicalUseDefinitionWarning = class;
  TFhirClinicalUseDefinitionWarningList = class;
  TFhirClinicalUseDefinition = class;
  TFhirClinicalUseDefinitionList = class;
{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_COMMUNICATION}
  TFhirCommunicationPayload = class;
  TFhirCommunicationPayloadList = class;
  TFhirCommunication = class;
  TFhirCommunicationList = class;
{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  TFhirCommunicationRequestPayload = class;
  TFhirCommunicationRequestPayloadList = class;
  TFhirCommunicationRequest = class;
  TFhirCommunicationRequestList = class;
{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  TFhirCompositionAttester = class;
  TFhirCompositionAttesterList = class;
  TFhirCompositionRelatesTo = class;
  TFhirCompositionRelatesToList = class;
  TFhirCompositionEvent = class;
  TFhirCompositionEventList = class;
  TFhirCompositionSection = class;
  TFhirCompositionSectionList = class;
  TFhirComposition = class;
  TFhirCompositionList = class;
{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONDITION}
  TFhirConditionStage = class;
  TFhirConditionStageList = class;
  TFhirConditionEvidence = class;
  TFhirConditionEvidenceList = class;
  TFhirCondition = class;
  TFhirConditionList = class;
{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_DETECTEDISSUE}
  TFhirDetectedIssueEvidence = class;
  TFhirDetectedIssueEvidenceList = class;
  TFhirDetectedIssueMitigation = class;
  TFhirDetectedIssueMitigationList = class;
  TFhirDetectedIssue = class;
  TFhirDetectedIssueList = class;
{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICEREQUEST}
  TFhirDeviceRequestParameter = class;
  TFhirDeviceRequestParameterList = class;
  TFhirDeviceRequest = class;
  TFhirDeviceRequestList = class;
{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  TFhirDeviceUseStatement = class;
  TFhirDeviceUseStatementList = class;
{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  TFhirDiagnosticReportMedia = class;
  TFhirDiagnosticReportMediaList = class;
  TFhirDiagnosticReport = class;
  TFhirDiagnosticReportList = class;
{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  TFhirDocumentManifestRelated = class;
  TFhirDocumentManifestRelatedList = class;
  TFhirDocumentManifest = class;
  TFhirDocumentManifestList = class;
{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  TFhirDocumentReferenceRelatesTo = class;
  TFhirDocumentReferenceRelatesToList = class;
  TFhirDocumentReferenceContent = class;
  TFhirDocumentReferenceContentList = class;
  TFhirDocumentReferenceContext = class;
  TFhirDocumentReferenceContextList = class;
  TFhirDocumentReference = class;
  TFhirDocumentReferenceList = class;
{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EPISODEOFCARE}
  TFhirEpisodeOfCareStatusHistory = class;
  TFhirEpisodeOfCareStatusHistoryList = class;
  TFhirEpisodeOfCareDiagnosis = class;
  TFhirEpisodeOfCareDiagnosisList = class;
  TFhirEpisodeOfCare = class;
  TFhirEpisodeOfCareList = class;
{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  TFhirFamilyMemberHistoryCondition = class;
  TFhirFamilyMemberHistoryConditionList = class;
  TFhirFamilyMemberHistory = class;
  TFhirFamilyMemberHistoryList = class;
{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  TFhirFlag = class;
  TFhirFlagList = class;
{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  TFhirGoalTarget = class;
  TFhirGoalTargetList = class;
  TFhirGoal = class;
  TFhirGoalList = class;
{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_IMAGINGSTUDY}
  TFhirImagingStudySeries = class;
  TFhirImagingStudySeriesList = class;
  TFhirImagingStudySeriesPerformer = class;
  TFhirImagingStudySeriesPerformerList = class;
  TFhirImagingStudySeriesInstance = class;
  TFhirImagingStudySeriesInstanceList = class;
  TFhirImagingStudy = class;
  TFhirImagingStudyList = class;
{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  TFhirImmunizationPerformer = class;
  TFhirImmunizationPerformerList = class;
  TFhirImmunizationEducation = class;
  TFhirImmunizationEducationList = class;
  TFhirImmunizationReaction = class;
  TFhirImmunizationReactionList = class;
  TFhirImmunizationProtocolApplied = class;
  TFhirImmunizationProtocolAppliedList = class;
  TFhirImmunization = class;
  TFhirImmunizationList = class;
{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  TFhirImmunizationEvaluation = class;
  TFhirImmunizationEvaluationList = class;
{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  TFhirImmunizationRecommendationRecommendation = class;
  TFhirImmunizationRecommendationRecommendationList = class;
  TFhirImmunizationRecommendationRecommendationDateCriterion = class;
  TFhirImmunizationRecommendationRecommendationDateCriterionList = class;
  TFhirImmunizationRecommendation = class;
  TFhirImmunizationRecommendationList = class;
{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  TFhirMedicationAdministrationPerformer = class;
  TFhirMedicationAdministrationPerformerList = class;
  TFhirMedicationAdministrationDosage = class;
  TFhirMedicationAdministrationDosageList = class;
  TFhirMedicationAdministration = class;
  TFhirMedicationAdministrationList = class;
{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  TFhirMedicationDispensePerformer = class;
  TFhirMedicationDispensePerformerList = class;
  TFhirMedicationDispenseSubstitution = class;
  TFhirMedicationDispenseSubstitutionList = class;
  TFhirMedicationDispense = class;
  TFhirMedicationDispenseList = class;
{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  TFhirMedicationRequestDispenseRequest = class;
  TFhirMedicationRequestDispenseRequestList = class;
  TFhirMedicationRequestDispenseRequestInitialFill = class;
  TFhirMedicationRequestDispenseRequestInitialFillList = class;
  TFhirMedicationRequestSubstitution = class;
  TFhirMedicationRequestSubstitutionList = class;
  TFhirMedicationRequest = class;
  TFhirMedicationRequestList = class;
{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  TFhirMedicationStatement = class;
  TFhirMedicationStatementList = class;
{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  TFhirMolecularSequenceReferenceSeq = class;
  TFhirMolecularSequenceReferenceSeqList = class;
  TFhirMolecularSequenceVariant = class;
  TFhirMolecularSequenceVariantList = class;
  TFhirMolecularSequenceQuality = class;
  TFhirMolecularSequenceQualityList = class;
  TFhirMolecularSequenceQualityRoc = class;
  TFhirMolecularSequenceQualityRocList = class;
  TFhirMolecularSequenceRepository = class;
  TFhirMolecularSequenceRepositoryList = class;
  TFhirMolecularSequenceStructureVariant = class;
  TFhirMolecularSequenceStructureVariantList = class;
  TFhirMolecularSequenceStructureVariantOuter = class;
  TFhirMolecularSequenceStructureVariantOuterList = class;
  TFhirMolecularSequenceStructureVariantInner = class;
  TFhirMolecularSequenceStructureVariantInnerList = class;
  TFhirMolecularSequence = class;
  TFhirMolecularSequenceList = class;
{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NUTRITIONORDER}
  TFhirNutritionOrderOralDiet = class;
  TFhirNutritionOrderOralDietList = class;
  TFhirNutritionOrderOralDietNutrient = class;
  TFhirNutritionOrderOralDietNutrientList = class;
  TFhirNutritionOrderOralDietTexture = class;
  TFhirNutritionOrderOralDietTextureList = class;
  TFhirNutritionOrderSupplement = class;
  TFhirNutritionOrderSupplementList = class;
  TFhirNutritionOrderEnteralFormula = class;
  TFhirNutritionOrderEnteralFormulaList = class;
  TFhirNutritionOrderEnteralFormulaAdministration = class;
  TFhirNutritionOrderEnteralFormulaAdministrationList = class;
  TFhirNutritionOrder = class;
  TFhirNutritionOrderList = class;
{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  TFhirObservationReferenceRange = class;
  TFhirObservationReferenceRangeList = class;
  TFhirObservationComponent = class;
  TFhirObservationComponentList = class;
  TFhirObservation = class;
  TFhirObservationList = class;
{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_PROCEDURE}
  TFhirProcedurePerformer = class;
  TFhirProcedurePerformerList = class;
  TFhirProcedureFocalDevice = class;
  TFhirProcedureFocalDeviceList = class;
  TFhirProcedure = class;
  TFhirProcedureList = class;
{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_RISKASSESSMENT}
  TFhirRiskAssessmentPrediction = class;
  TFhirRiskAssessmentPredictionList = class;
  TFhirRiskAssessment = class;
  TFhirRiskAssessmentList = class;
{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SERVICEREQUEST}
  TFhirServiceRequest = class;
  TFhirServiceRequestList = class;
{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SPECIMEN}
  TFhirSpecimenCollection = class;
  TFhirSpecimenCollectionList = class;
  TFhirSpecimenProcessing = class;
  TFhirSpecimenProcessingList = class;
  TFhirSpecimenContainer = class;
  TFhirSpecimenContainerList = class;
  TFhirSpecimen = class;
  TFhirSpecimenList = class;
{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SUPPLYDELIVERY}
  TFhirSupplyDeliverySuppliedItem = class;
  TFhirSupplyDeliverySuppliedItemList = class;
  TFhirSupplyDelivery = class;
  TFhirSupplyDeliveryList = class;
{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  TFhirSupplyRequestParameter = class;
  TFhirSupplyRequestParameterList = class;
  TFhirSupplyRequest = class;
  TFhirSupplyRequestList = class;
{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  TFhirVisionPrescriptionLensSpecification = class;
  TFhirVisionPrescriptionLensSpecificationList = class;
  TFhirVisionPrescriptionLensSpecificationPrism = class;
  TFhirVisionPrescriptionLensSpecificationPrismList = class;
  TFhirVisionPrescription = class;
  TFhirVisionPrescriptionList = class;
{$ENDIF FHIR_VISIONPRESCRIPTION}




{$IFDEF FHIR_ADVERSEEVENT}
  // Describes the entity that is suspected to have caused the adverse event.
  TFhirAdverseEventSuspectEntity = class (TFhirBackboneElement)
  protected
    FInstance : TFhirReference;
    FcausalityList : TFhirAdverseEventSuspectEntityCausalityList;
    procedure SetInstance(value : TFhirReference);
    function GetCausalityList : TFhirAdverseEventSuspectEntityCausalityList;
    function GetHasCausalityList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventSuspectEntity; overload;
    function Clone : TFhirAdverseEventSuspectEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the actual instance of what caused the adverse event.  May be a substance, medication, medication administration, medication statement or a device. (defined for API consistency)
    property instance : TFhirReference read FInstance write SetInstance;
    // Identifies the actual instance of what caused the adverse event.  May be a substance, medication, medication administration, medication statement or a device.
    property instanceElement : TFhirReference read FInstance write SetInstance;

    // Information on the possible cause of the event.
    property causalityList : TFhirAdverseEventSuspectEntityCausalityList read GetCausalityList;
    property hasCausalityList : boolean read GetHasCausalityList;

  end;

  TFhirAdverseEventSuspectEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventSuspectEntityList;
    function GetCurrent : TFhirAdverseEventSuspectEntity;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventSuspectEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventSuspectEntity read GetCurrent;
  end;

  TFhirAdverseEventSuspectEntityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEventSuspectEntity;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventSuspectEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventSuspectEntityList; overload;
    function Clone : TFhirAdverseEventSuspectEntityList; overload;
    function GetEnumerator : TFhirAdverseEventSuspectEntityListEnumerator;
    
    //  Add a FhirAdverseEventSuspectEntity to the end of the list.
    function Append : TFhirAdverseEventSuspectEntity;
    
    // Add an already existing FhirAdverseEventSuspectEntity to the end of the list.
    function AddItem(value : TFhirAdverseEventSuspectEntity) : TFhirAdverseEventSuspectEntity; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventSuspectEntity) : Integer;
    
    // Insert FhirAdverseEventSuspectEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventSuspectEntity;
    
    // Insert an existing FhirAdverseEventSuspectEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventSuspectEntity);
    
    // Get the iIndexth FhirAdverseEventSuspectEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventSuspectEntity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventSuspectEntity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEventSuspectEntities[index : Integer] : TFhirAdverseEventSuspectEntity read GetItemN write SetItemN; default;
  End;

  // Information on the possible cause of the event.
  TFhirAdverseEventSuspectEntityCausality = class (TFhirBackboneElement)
  protected
    FAssessment : TFhirCodeableConcept;
    FProductRelatedness : TFhirString;
    FAuthor : TFhirReference;
    FMethod : TFhirCodeableConcept;
    procedure SetAssessment(value : TFhirCodeableConcept);
    procedure SetProductRelatedness(value : TFhirString);
    function GetProductRelatednessST : String;
    procedure SetProductRelatednessST(value : String);
    procedure SetAuthor(value : TFhirReference);
    procedure SetMethod(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEventSuspectEntityCausality; overload;
    function Clone : TFhirAdverseEventSuspectEntityCausality; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Assessment of if the entity caused the event. (defined for API consistency)
    property assessment : TFhirCodeableConcept read FAssessment write SetAssessment;
    // Assessment of if the entity caused the event.
    property assessmentElement : TFhirCodeableConcept read FAssessment write SetAssessment;

    // Typed access to AdverseEvent.suspectEntity.causalityProductRelatedness.
    property productRelatedness : String read GetProductRelatednessST write SetProductRelatednessST;
    // AdverseEvent.suspectEntity.causalityProductRelatedness.
    property productRelatednessElement : TFhirString read FProductRelatedness write SetProductRelatedness;

    // Typed access to AdverseEvent.suspectEntity.causalityAuthor. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // AdverseEvent.suspectEntity.causalityAuthor.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Typed access to ProbabilityScale | Bayesian | Checklist. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // ProbabilityScale | Bayesian | Checklist.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

  end;

  TFhirAdverseEventSuspectEntityCausalityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventSuspectEntityCausalityList;
    function GetCurrent : TFhirAdverseEventSuspectEntityCausality;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventSuspectEntityCausalityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEventSuspectEntityCausality read GetCurrent;
  end;

  TFhirAdverseEventSuspectEntityCausalityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEventSuspectEntityCausality;
    procedure SetItemN(index : Integer; value : TFhirAdverseEventSuspectEntityCausality);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventSuspectEntityCausalityList; overload;
    function Clone : TFhirAdverseEventSuspectEntityCausalityList; overload;
    function GetEnumerator : TFhirAdverseEventSuspectEntityCausalityListEnumerator;
    
    //  Add a FhirAdverseEventSuspectEntityCausality to the end of the list.
    function Append : TFhirAdverseEventSuspectEntityCausality;
    
    // Add an already existing FhirAdverseEventSuspectEntityCausality to the end of the list.
    function AddItem(value : TFhirAdverseEventSuspectEntityCausality) : TFhirAdverseEventSuspectEntityCausality; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEventSuspectEntityCausality) : Integer;
    
    // Insert FhirAdverseEventSuspectEntityCausality before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEventSuspectEntityCausality;
    
    // Insert an existing FhirAdverseEventSuspectEntityCausality before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEventSuspectEntityCausality);
    
    // Get the iIndexth FhirAdverseEventSuspectEntityCausality. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEventSuspectEntityCausality);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEventSuspectEntityCausality;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEventSuspectEntityCausalities[index : Integer] : TFhirAdverseEventSuspectEntityCausality read GetItemN write SetItemN; default;
  End;

  // Actual or  potential/avoided event causing unintended physical injury resulting from or contributed to by medical care, a research study or other healthcare setting factors that requires additional monitoring, treatment, or hospitalization, or that results in death.
  TFhirAdverseEvent = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FActuality : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FEvent : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FDate : TFhirDateTime;
    FDetected : TFhirDateTime;
    FRecordedDate : TFhirDateTime;
    FresultingConditionList : TFhirReferenceList;
    FLocation : TFhirReference;
    FSeriousness : TFhirCodeableConcept;
    FSeverity : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FRecorder : TFhirReference;
    FcontributorList : TFhirReferenceList;
    FsuspectEntityList : TFhirAdverseEventSuspectEntityList;
    FsubjectMedicalHistoryList : TFhirReferenceList;
    FreferenceDocumentList : TFhirReferenceList;
    FstudyList : TFhirReferenceList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetActuality(value : TFhirEnum);
    function GetActualityST : TFhirAdverseEventActualityEnum;
    procedure SetActualityST(value : TFhirAdverseEventActualityEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetEvent(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetDetected(value : TFhirDateTime);
    function GetDetectedST : TFslDateTime;
    procedure SetDetectedST(value : TFslDateTime);
    procedure SetRecordedDate(value : TFhirDateTime);
    function GetRecordedDateST : TFslDateTime;
    procedure SetRecordedDateST(value : TFslDateTime);
    function GetResultingConditionList : TFhirReferenceList;
    function GetHasResultingConditionList : Boolean;
    procedure SetLocation(value : TFhirReference);
    procedure SetSeriousness(value : TFhirCodeableConcept);
    procedure SetSeverity(value : TFhirCodeableConcept);
    procedure SetOutcome(value : TFhirCodeableConcept);
    procedure SetRecorder(value : TFhirReference);
    function GetContributorList : TFhirReferenceList;
    function GetHasContributorList : Boolean;
    function GetSuspectEntityList : TFhirAdverseEventSuspectEntityList;
    function GetHasSuspectEntityList : Boolean;
    function GetSubjectMedicalHistoryList : TFhirReferenceList;
    function GetHasSubjectMedicalHistoryList : Boolean;
    function GetReferenceDocumentList : TFhirReferenceList;
    function GetHasReferenceDocumentList : Boolean;
    function GetStudyList : TFhirReferenceList;
    function GetHasStudyList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAdverseEvent; overload;
    function Clone : TFhirAdverseEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Business identifiers assigned to this adverse event by the performer or other systems which remain constant as the resource is updated and propagates from server to server. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Business identifiers assigned to this adverse event by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Whether the event actually happened, or just had the potential to. Note that this is independent of whether anyone was affected or harmed or how severely.
    property actuality : TFhirAdverseEventActualityEnum read GetActualityST write SetActualityST;
    property actualityElement : TFhirEnum read FActuality write SetActuality;

    // The overall type of event, intended for search and filtering purposes.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to This element defines the specific type of event that occurred or that was prevented from occurring. (defined for API consistency)
    property event : TFhirCodeableConcept read FEvent write SetEvent;
    // This element defines the specific type of event that occurred or that was prevented from occurring.
    property eventElement : TFhirCodeableConcept read FEvent write SetEvent;

    // Typed access to This subject or group impacted by the event. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // This subject or group impacted by the event.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which AdverseEvent was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which AdverseEvent was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date (and perhaps time) when the adverse event occurred.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date (and perhaps time) when the adverse event occurred.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Estimated or actual date the AdverseEvent began, in the opinion of the reporter.
    property detected : TFslDateTime read GetDetectedST write SetDetectedST;
    // Estimated or actual date the AdverseEvent began, in the opinion of the reporter.
    property detectedElement : TFhirDateTime read FDetected write SetDetected;

    // Typed access to The date on which the existence of the AdverseEvent was first recorded.
    property recordedDate : TFslDateTime read GetRecordedDateST write SetRecordedDateST;
    // The date on which the existence of the AdverseEvent was first recorded.
    property recordedDateElement : TFhirDateTime read FRecordedDate write SetRecordedDate;

    // Includes information about the reaction that occurred as a result of exposure to a substance (for example, a drug or a chemical).
    property resultingConditionList : TFhirReferenceList read GetResultingConditionList;
    property hasResultingConditionList : boolean read GetHasResultingConditionList;

    // Typed access to The information about where the adverse event occurred. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The information about where the adverse event occurred.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to Assessment whether this event was of real importance. (defined for API consistency)
    property seriousness : TFhirCodeableConcept read FSeriousness write SetSeriousness;
    // Assessment whether this event was of real importance.
    property seriousnessElement : TFhirCodeableConcept read FSeriousness write SetSeriousness;

    // Typed access to Describes the severity of the adverse event, in relation to the subject. Contrast to AdverseEvent.seriousness - a severe rash might not be serious, but a mild heart problem is. (defined for API consistency)
    property severity : TFhirCodeableConcept read FSeverity write SetSeverity;
    // Describes the severity of the adverse event, in relation to the subject. Contrast to AdverseEvent.seriousness - a severe rash might not be serious, but a mild heart problem is.
    property severityElement : TFhirCodeableConcept read FSeverity write SetSeverity;

    // Typed access to Describes the type of outcome from the adverse event. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Describes the type of outcome from the adverse event.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to Information on who recorded the adverse event.  May be the patient or a practitioner. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // Information on who recorded the adverse event.  May be the patient or a practitioner.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // Parties that may or should contribute or have contributed information to the adverse event, which can consist of one or more activities.  Such information includes information leading to the decision to perform the activity and how to perform the activity (e.g. consultant), information that the activity itself seeks to reveal (e.g. informant of clinical history), or information about what activity was performed (e.g. informant witness).
    property contributorList : TFhirReferenceList read GetContributorList;
    property hasContributorList : boolean read GetHasContributorList;

    // Describes the entity that is suspected to have caused the adverse event.
    property suspectEntityList : TFhirAdverseEventSuspectEntityList read GetSuspectEntityList;
    property hasSuspectEntityList : boolean read GetHasSuspectEntityList;

    // AdverseEvent.subjectMedicalHistory.
    property subjectMedicalHistoryList : TFhirReferenceList read GetSubjectMedicalHistoryList;
    property hasSubjectMedicalHistoryList : boolean read GetHasSubjectMedicalHistoryList;

    // AdverseEvent.referenceDocument.
    property referenceDocumentList : TFhirReferenceList read GetReferenceDocumentList;
    property hasReferenceDocumentList : boolean read GetHasReferenceDocumentList;

    // AdverseEvent.study.
    property studyList : TFhirReferenceList read GetStudyList;
    property hasStudyList : boolean read GetHasStudyList;

  end;

  TFhirAdverseEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAdverseEventList;
    function GetCurrent : TFhirAdverseEvent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAdverseEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAdverseEvent read GetCurrent;
  end;

  TFhirAdverseEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAdverseEvent;
    procedure SetItemN(index : Integer; value : TFhirAdverseEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAdverseEventList; overload;
    function Clone : TFhirAdverseEventList; overload;
    function GetEnumerator : TFhirAdverseEventListEnumerator;
    
    //  Add a FhirAdverseEvent to the end of the list.
    function Append : TFhirAdverseEvent;
    
    // Add an already existing FhirAdverseEvent to the end of the list.
    function AddItem(value : TFhirAdverseEvent) : TFhirAdverseEvent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAdverseEvent) : Integer;
    
    // Insert FhirAdverseEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAdverseEvent;
    
    // Insert an existing FhirAdverseEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAdverseEvent);
    
    // Get the iIndexth FhirAdverseEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAdverseEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAdverseEvent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAdverseEvents[index : Integer] : TFhirAdverseEvent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
  // Details about each adverse reaction event linked to exposure to the identified substance.
  TFhirAllergyIntoleranceReaction = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableConcept;
    FmanifestationList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FOnset : TFhirDateTime;
    FSeverity : TFhirEnum;
    FExposureRoute : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    procedure SetSubstance(value : TFhirCodeableConcept);
    function GetManifestationList : TFhirCodeableConceptList;
    function GetHasManifestationList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetOnset(value : TFhirDateTime);
    function GetOnsetST : TFslDateTime;
    procedure SetOnsetST(value : TFslDateTime);
    procedure SetSeverity(value : TFhirEnum);
    function GetSeverityST : TFhirAllergyIntoleranceSeverityEnum;
    procedure SetSeverityST(value : TFhirAllergyIntoleranceSeverityEnum);
    procedure SetExposureRoute(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAllergyIntoleranceReaction; overload;
    function Clone : TFhirAllergyIntoleranceReaction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identification of the specific substance (or pharmaceutical product) considered to be responsible for the Adverse Reaction event. Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'.  If a receiving system is unable to confirm that AllergyIntolerance.reaction.substance falls within the semantic scope of AllergyIntolerance.code, then the receiving system should ignore AllergyIntolerance.reaction.substance. (defined for API consistency)
    property substance : TFhirCodeableConcept read FSubstance write SetSubstance;
    // Identification of the specific substance (or pharmaceutical product) considered to be responsible for the Adverse Reaction event. Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'.  If a receiving system is unable to confirm that AllergyIntolerance.reaction.substance falls within the semantic scope of AllergyIntolerance.code, then the receiving system should ignore AllergyIntolerance.reaction.substance.
    property substanceElement : TFhirCodeableConcept read FSubstance write SetSubstance;

    // Clinical symptoms and/or signs that are observed or associated with the adverse reaction event.
    property manifestationList : TFhirCodeableConceptList read GetManifestationList;
    property hasManifestationList : boolean read GetHasManifestationList;

    // Typed access to Text description about the reaction as a whole, including details of the manifestation if required.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Text description about the reaction as a whole, including details of the manifestation if required.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Record of the date and/or time of the onset of the Reaction.
    property onset : TFslDateTime read GetOnsetST write SetOnsetST;
    // Record of the date and/or time of the onset of the Reaction.
    property onsetElement : TFhirDateTime read FOnset write SetOnset;

    // Clinical assessment of the severity of the reaction event as a whole, potentially considering multiple different manifestations.
    property severity : TFhirAllergyIntoleranceSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Typed access to Identification of the route by which the subject was exposed to the substance. (defined for API consistency)
    property exposureRoute : TFhirCodeableConcept read FExposureRoute write SetExposureRoute;
    // Identification of the route by which the subject was exposed to the substance.
    property exposureRouteElement : TFhirCodeableConcept read FExposureRoute write SetExposureRoute;

    // Additional text about the adverse reaction event not captured in other fields.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirAllergyIntoleranceReactionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAllergyIntoleranceReactionList;
    function GetCurrent : TFhirAllergyIntoleranceReaction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAllergyIntoleranceReactionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAllergyIntoleranceReaction read GetCurrent;
  end;

  TFhirAllergyIntoleranceReactionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAllergyIntoleranceReaction;
    procedure SetItemN(index : Integer; value : TFhirAllergyIntoleranceReaction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAllergyIntoleranceReactionList; overload;
    function Clone : TFhirAllergyIntoleranceReactionList; overload;
    function GetEnumerator : TFhirAllergyIntoleranceReactionListEnumerator;
    
    //  Add a FhirAllergyIntoleranceReaction to the end of the list.
    function Append : TFhirAllergyIntoleranceReaction;
    
    // Add an already existing FhirAllergyIntoleranceReaction to the end of the list.
    function AddItem(value : TFhirAllergyIntoleranceReaction) : TFhirAllergyIntoleranceReaction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAllergyIntoleranceReaction) : Integer;
    
    // Insert FhirAllergyIntoleranceReaction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAllergyIntoleranceReaction;
    
    // Insert an existing FhirAllergyIntoleranceReaction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAllergyIntoleranceReaction);
    
    // Get the iIndexth FhirAllergyIntoleranceReaction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAllergyIntoleranceReaction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAllergyIntoleranceReaction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAllergyIntoleranceReactions[index : Integer] : TFhirAllergyIntoleranceReaction read GetItemN write SetItemN; default;
  End;

  // Risk of harmful or undesirable, physiological response which is unique to an individual and associated with exposure to a substance.
  TFhirAllergyIntolerance = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FClinicalStatus : TFhirCodeableConcept;
    FVerificationStatus : TFhirCodeableConcept;
    FType_ : TFhirEnum;
    FCategory : TFhirEnumList;
    FCriticality : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FOnset : TFhirDataType;
    FRecordedDate : TFhirDateTime;
    FRecorder : TFhirReference;
    FAsserter : TFhirReference;
    FLastOccurrence : TFhirDateTime;
    FnoteList : TFhirAnnotationList;
    FreactionList : TFhirAllergyIntoleranceReactionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetClinicalStatus(value : TFhirCodeableConcept);
    procedure SetVerificationStatus(value : TFhirCodeableConcept);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirAllergyIntoleranceTypeEnum;
    procedure SetType_ST(value : TFhirAllergyIntoleranceTypeEnum);
    function GetCategory : TFhirEnumList;
    function GetHasCategory : Boolean;
    function GetCategoryST : TFhirAllergyIntoleranceCategoryEnumList;
    procedure SetCategoryST(value : TFhirAllergyIntoleranceCategoryEnumList);
    procedure SetCriticality(value : TFhirEnum);
    function GetCriticalityST : TFhirAllergyIntoleranceCriticalityEnum;
    procedure SetCriticalityST(value : TFhirAllergyIntoleranceCriticalityEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOnset(value : TFhirDataType);
    procedure SetRecordedDate(value : TFhirDateTime);
    function GetRecordedDateST : TFslDateTime;
    procedure SetRecordedDateST(value : TFslDateTime);
    procedure SetRecorder(value : TFhirReference);
    procedure SetAsserter(value : TFhirReference);
    procedure SetLastOccurrence(value : TFhirDateTime);
    function GetLastOccurrenceST : TFslDateTime;
    procedure SetLastOccurrenceST(value : TFslDateTime);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetReactionList : TFhirAllergyIntoleranceReactionList;
    function GetHasReactionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAllergyIntolerance; overload;
    function Clone : TFhirAllergyIntolerance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this AllergyIntolerance by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The clinical status of the allergy or intolerance. (defined for API consistency)
    property clinicalStatus : TFhirCodeableConcept read FClinicalStatus write SetClinicalStatus;
    // The clinical status of the allergy or intolerance.
    property clinicalStatusElement : TFhirCodeableConcept read FClinicalStatus write SetClinicalStatus;

    // Typed access to Assertion about certainty associated with the propensity, or potential risk, of a reaction to the identified substance (including pharmaceutical product). (defined for API consistency)
    property verificationStatus : TFhirCodeableConcept read FVerificationStatus write SetVerificationStatus;
    // Assertion about certainty associated with the propensity, or potential risk, of a reaction to the identified substance (including pharmaceutical product).
    property verificationStatusElement : TFhirCodeableConcept read FVerificationStatus write SetVerificationStatus;

    // Identification of the underlying physiological mechanism for the reaction risk.
    property type_ : TFhirAllergyIntoleranceTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Category of the identified substance.
    property category : TFhirAllergyIntoleranceCategoryEnumList read GetCategoryST write SetCategoryST;
    property categoryList : TFhirEnumList read GetCategory;
    property hasCategory : boolean read GetHasCategory;
    // Estimate of the potential clinical harm, or seriousness, of the reaction to the identified substance.
    property criticality : TFhirAllergyIntoleranceCriticalityEnum read GetCriticalityST write SetCriticalityST;
    property criticalityElement : TFhirEnum read FCriticality write SetCriticality;

    // Typed access to Code for an allergy or intolerance statement (either a positive or a negated/excluded statement).  This may be a code for a substance or pharmaceutical product that is considered to be responsible for the adverse reaction risk (e.g., "Latex"), an allergy or intolerance condition (e.g., "Latex allergy"), or a negated/excluded code for a specific substance or class (e.g., "No latex allergy") or a general or categorical negated statement (e.g.,  "No known allergy", "No known drug allergies").  Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'.  If a receiving system is unable to confirm that AllergyIntolerance.reaction.substance falls within
    //  the semantic scope of AllergyIntolerance.code, then the receiving system should ignore AllergyIntolerance.reaction.substance. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Code for an allergy or intolerance statement (either a positive or a negated/excluded statement).  This may be a code for a substance or pharmaceutical product that is considered to be responsible for the adverse reaction risk (e.g., "Latex"), an allergy or intolerance condition (e.g., "Latex allergy"), or a negated/excluded code for a specific substance or class (e.g., "No latex allergy") or a general or categorical negated statement (e.g.,  "No known allergy", "No known drug allergies").  Note: the substance for a specific reaction may be different from the substance identified as the cause of the risk, but it must be consistent with it. For instance, it may be a more specific substance (e.g. a brand medication) or a composite product that includes the identified substance. It must be clinically safe to only process the 'code' and ignore the 'reaction.substance'.  If a receiving system is unable to confirm that AllergyIntolerance.reaction.substance falls within
    //  the semantic scope of AllergyIntolerance.code, then the receiving system should ignore AllergyIntolerance.reaction.substance.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient who has the allergy or intolerance. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient who has the allergy or intolerance.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The encounter when the allergy or intolerance was asserted. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter when the allergy or intolerance was asserted.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Estimated or actual date,  date-time, or age when allergy or intolerance was identified. (defined for API consistency)
    property onset : TFhirDataType read FOnset write SetOnset;
    // Estimated or actual date,  date-time, or age when allergy or intolerance was identified.
    property onsetElement : TFhirDataType read FOnset write SetOnset;

    // Typed access to The recordedDate represents when this particular AllergyIntolerance record was created in the system, which is often a system-generated date.
    property recordedDate : TFslDateTime read GetRecordedDateST write SetRecordedDateST;
    // The recordedDate represents when this particular AllergyIntolerance record was created in the system, which is often a system-generated date.
    property recordedDateElement : TFhirDateTime read FRecordedDate write SetRecordedDate;

    // Typed access to Individual who recorded the record and takes responsibility for its content. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // Individual who recorded the record and takes responsibility for its content.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // Typed access to The source of the information about the allergy that is recorded. (defined for API consistency)
    property asserter : TFhirReference read FAsserter write SetAsserter;
    // The source of the information about the allergy that is recorded.
    property asserterElement : TFhirReference read FAsserter write SetAsserter;

    // Typed access to Represents the date and/or time of the last known occurrence of a reaction event.
    property lastOccurrence : TFslDateTime read GetLastOccurrenceST write SetLastOccurrenceST;
    // Represents the date and/or time of the last known occurrence of a reaction event.
    property lastOccurrenceElement : TFhirDateTime read FLastOccurrence write SetLastOccurrence;

    // Additional narrative about the propensity for the Adverse Reaction, not captured in other fields.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Details about each adverse reaction event linked to exposure to the identified substance.
    property reactionList : TFhirAllergyIntoleranceReactionList read GetReactionList;
    property hasReactionList : boolean read GetHasReactionList;

  end;

  TFhirAllergyIntoleranceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAllergyIntoleranceList;
    function GetCurrent : TFhirAllergyIntolerance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAllergyIntoleranceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAllergyIntolerance read GetCurrent;
  end;

  TFhirAllergyIntoleranceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAllergyIntolerance;
    procedure SetItemN(index : Integer; value : TFhirAllergyIntolerance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAllergyIntoleranceList; overload;
    function Clone : TFhirAllergyIntoleranceList; overload;
    function GetEnumerator : TFhirAllergyIntoleranceListEnumerator;
    
    //  Add a FhirAllergyIntolerance to the end of the list.
    function Append : TFhirAllergyIntolerance;
    
    // Add an already existing FhirAllergyIntolerance to the end of the list.
    function AddItem(value : TFhirAllergyIntolerance) : TFhirAllergyIntolerance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAllergyIntolerance) : Integer;
    
    // Insert FhirAllergyIntolerance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAllergyIntolerance;
    
    // Insert an existing FhirAllergyIntolerance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAllergyIntolerance);
    
    // Get the iIndexth FhirAllergyIntolerance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAllergyIntolerance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAllergyIntolerance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAllergyIntolerances[index : Integer] : TFhirAllergyIntolerance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
  // List of participants involved in the appointment.
  TFhirAppointmentParticipant = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FActor : TFhirReference;
    FRequired : TFhirEnum;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetActor(value : TFhirReference);
    procedure SetRequired(value : TFhirEnum);
    function GetRequiredST : TFhirParticipantRequiredEnum;
    procedure SetRequiredST(value : TFhirParticipantRequiredEnum);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirParticipationStatusEnum;
    procedure SetStatusST(value : TFhirParticipationStatusEnum);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointmentParticipant; overload;
    function Clone : TFhirAppointmentParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Role of participant in the appointment.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A Person, Location/HealthcareService or Device that is participating in the appointment. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // A Person, Location/HealthcareService or Device that is participating in the appointment.
    property actorElement : TFhirReference read FActor write SetActor;

    // Whether this participant is required to be present at the meeting. This covers a use-case where two doctors need to meet to discuss the results for a specific patient, and the patient is not required to be present.
    property required : TFhirParticipantRequiredEnum read GetRequiredST write SetRequiredST;
    property requiredElement : TFhirEnum read FRequired write SetRequired;

    // Participation status of the actor.
    property status : TFhirParticipationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Participation period of the actor. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Participation period of the actor.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirAppointmentParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentParticipantList;
    function GetCurrent : TFhirAppointmentParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointmentParticipant read GetCurrent;
  end;

  TFhirAppointmentParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAppointmentParticipant;
    procedure SetItemN(index : Integer; value : TFhirAppointmentParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAppointmentParticipantList; overload;
    function Clone : TFhirAppointmentParticipantList; overload;
    function GetEnumerator : TFhirAppointmentParticipantListEnumerator;
    
    //  Add a FhirAppointmentParticipant to the end of the list.
    function Append : TFhirAppointmentParticipant;
    
    // Add an already existing FhirAppointmentParticipant to the end of the list.
    function AddItem(value : TFhirAppointmentParticipant) : TFhirAppointmentParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointmentParticipant) : Integer;
    
    // Insert FhirAppointmentParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointmentParticipant;
    
    // Insert an existing FhirAppointmentParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointmentParticipant);
    
    // Get the iIndexth FhirAppointmentParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointmentParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointmentParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAppointmentParticipants[index : Integer] : TFhirAppointmentParticipant read GetItemN write SetItemN; default;
  End;

  // A booking of a healthcare event among patient(s), practitioner(s), related person(s) and/or device(s) for a specific date/time. This may result in one or more Encounter(s).
  TFhirAppointment = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCancelationReason : TFhirCodeableConcept;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FAppointmentType : TFhirCodeableConcept;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FPriority : TFhirUnsignedInt;
    FDescription : TFhirString;
    FsupportingInformationList : TFhirReferenceList;
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FMinutesDuration : TFhirPositiveInt;
    FslotList : TFhirReferenceList;
    FCreated : TFhirDateTime;
    FComment : TFhirString;
    FPatientInstruction : TFhirString;
    FbasedOnList : TFhirReferenceList;
    FparticipantList : TFhirAppointmentParticipantList;
    FrequestedPeriodList : TFhirPeriodList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirAppointmentStatusEnum;
    procedure SetStatusST(value : TFhirAppointmentStatusEnum);
    procedure SetCancelationReason(value : TFhirCodeableConcept);
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableConceptList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    procedure SetAppointmentType(value : TFhirCodeableConcept);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    procedure SetPriority(value : TFhirUnsignedInt);
    function GetPriorityST : String;
    procedure SetPriorityST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
    procedure SetStart(value : TFhirInstant);
    function GetStartST : TFslDateTime;
    procedure SetStartST(value : TFslDateTime);
    procedure SetEnd_(value : TFhirInstant);
    function GetEnd_ST : TFslDateTime;
    procedure SetEnd_ST(value : TFslDateTime);
    procedure SetMinutesDuration(value : TFhirPositiveInt);
    function GetMinutesDurationST : String;
    procedure SetMinutesDurationST(value : String);
    function GetSlotList : TFhirReferenceList;
    function GetHasSlotList : Boolean;
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    procedure SetPatientInstruction(value : TFhirString);
    function GetPatientInstructionST : String;
    procedure SetPatientInstructionST(value : String);
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetParticipantList : TFhirAppointmentParticipantList;
    function GetHasParticipantList : Boolean;
    function GetRequestedPeriodList : TFhirPeriodList;
    function GetHasRequestedPeriodList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointment; overload;
    function Clone : TFhirAppointment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this appointment concern that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The overall status of the Appointment. Each of the participants has their own participation status which indicates their involvement in the process, however this status indicates the shared status.
    property status : TFhirAppointmentStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The coded reason for the appointment being cancelled. This is often used in reporting/billing/futher processing to determine if further actions are required, or specific fees apply. (defined for API consistency)
    property cancelationReason : TFhirCodeableConcept read FCancelationReason write SetCancelationReason;
    // The coded reason for the appointment being cancelled. This is often used in reporting/billing/futher processing to determine if further actions are required, or specific fees apply.
    property cancelationReasonElement : TFhirCodeableConcept read FCancelationReason write SetCancelationReason;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The specific service that is to be performed during this appointment.
    property serviceTypeList : TFhirCodeableConceptList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Typed access to The style of appointment or patient that has been booked in the slot (not service type). (defined for API consistency)
    property appointmentType : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;
    // The style of appointment or patient that has been booked in the slot (not service type).
    property appointmentTypeElement : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;

    // The coded reason that this appointment is being scheduled. This is more clinical than administrative.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Reason the appointment has been scheduled to take place, as specified using information from another resource. When the patient arrives and the encounter begins it may be used as the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Typed access to The priority of the appointment. Can be used to make informed decisions if needing to re-prioritize appointments. (The iCal Standard specifies 0 as undefined, 1 as highest, 9 as lowest priority).
    property priority : String read GetPriorityST write SetPriorityST;
    // The priority of the appointment. Can be used to make informed decisions if needing to re-prioritize appointments. (The iCal Standard specifies 0 as undefined, 1 as highest, 9 as lowest priority).
    property priorityElement : TFhirUnsignedInt read FPriority write SetPriority;

    // Typed access to The brief description of the appointment as would be shown on a subject line in a meeting request, or appointment list. Detailed or expanded information should be put in the comment field.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The brief description of the appointment as would be shown on a subject line in a meeting request, or appointment list. Detailed or expanded information should be put in the comment field.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Additional information to support the appointment provided when making the appointment.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to Date/Time that the appointment is to take place.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the appointment is to take place.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to Date/Time that the appointment is to conclude.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // Date/Time that the appointment is to conclude.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to Number of minutes that the appointment is to take. This can be less than the duration between the start and end times.  For example, where the actual time of appointment is only an estimate or if a 30 minute appointment is being requested, but any time would work.  Also, if there is, for example, a planned 15 minute break in the middle of a long appointment, the duration may be 15 minutes less than the difference between the start and end.
    property minutesDuration : String read GetMinutesDurationST write SetMinutesDurationST;
    // Number of minutes that the appointment is to take. This can be less than the duration between the start and end times.  For example, where the actual time of appointment is only an estimate or if a 30 minute appointment is being requested, but any time would work.  Also, if there is, for example, a planned 15 minute break in the middle of a long appointment, the duration may be 15 minutes less than the difference between the start and end.
    property minutesDurationElement : TFhirPositiveInt read FMinutesDuration write SetMinutesDuration;

    // The slots from the participants' schedules that will be filled by the appointment.
    property slotList : TFhirReferenceList read GetSlotList;
    property hasSlotList : boolean read GetHasSlotList;

    // Typed access to The date that this appointment was initially created. This could be different to the meta.lastModified value on the initial entry, as this could have been before the resource was created on the FHIR server, and should remain unchanged over the lifespan of the appointment.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date that this appointment was initially created. This could be different to the meta.lastModified value on the initial entry, as this could have been before the resource was created on the FHIR server, and should remain unchanged over the lifespan of the appointment.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to Additional comments about the appointment.
    property comment : String read GetCommentST write SetCommentST;
    // Additional comments about the appointment.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to While Appointment.comment contains information for internal use, Appointment.patientInstructions is used to capture patient facing information about the Appointment (e.g. please bring your referral or fast from 8pm night before).
    property patientInstruction : String read GetPatientInstructionST write SetPatientInstructionST;
    // While Appointment.comment contains information for internal use, Appointment.patientInstructions is used to capture patient facing information about the Appointment (e.g. please bring your referral or fast from 8pm night before).
    property patientInstructionElement : TFhirString read FPatientInstruction write SetPatientInstruction;

    // The service request this appointment is allocated to assess (e.g. incoming referral or procedure request).
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // List of participants involved in the appointment.
    property participantList : TFhirAppointmentParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // A set of date ranges (potentially including times) that the appointment is preferred to be scheduled within.  The duration (usually in minutes) could also be provided to indicate the length of the appointment to fill and populate the start/end times for the actual allocated time. However, in other situations the duration may be calculated by the scheduling system.
    property requestedPeriodList : TFhirPeriodList read GetRequestedPeriodList;
    property hasRequestedPeriodList : boolean read GetHasRequestedPeriodList;

  end;

  TFhirAppointmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentList;
    function GetCurrent : TFhirAppointment;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointment read GetCurrent;
  end;

  TFhirAppointmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAppointment;
    procedure SetItemN(index : Integer; value : TFhirAppointment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAppointmentList; overload;
    function Clone : TFhirAppointmentList; overload;
    function GetEnumerator : TFhirAppointmentListEnumerator;
    
    //  Add a FhirAppointment to the end of the list.
    function Append : TFhirAppointment;
    
    // Add an already existing FhirAppointment to the end of the list.
    function AddItem(value : TFhirAppointment) : TFhirAppointment; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointment) : Integer;
    
    // Insert FhirAppointment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointment;
    
    // Insert an existing FhirAppointment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointment);
    
    // Get the iIndexth FhirAppointment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAppointments[index : Integer] : TFhirAppointment read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
  // A reply to an appointment request for a patient and/or practitioner(s), such as a confirmation or rejection.
  TFhirAppointmentResponse = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FAppointment : TFhirReference;
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FparticipantTypeList : TFhirCodeableConceptList;
    FActor : TFhirReference;
    FParticipantStatus : TFhirEnum;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetAppointment(value : TFhirReference);
    procedure SetStart(value : TFhirInstant);
    function GetStartST : TFslDateTime;
    procedure SetStartST(value : TFslDateTime);
    procedure SetEnd_(value : TFhirInstant);
    function GetEnd_ST : TFslDateTime;
    procedure SetEnd_ST(value : TFslDateTime);
    function GetParticipantTypeList : TFhirCodeableConceptList;
    function GetHasParticipantTypeList : Boolean;
    procedure SetActor(value : TFhirReference);
    procedure SetParticipantStatus(value : TFhirEnum);
    function GetParticipantStatusST : TFhirParticipationStatusEnum;
    procedure SetParticipantStatusST(value : TFhirParticipationStatusEnum);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAppointmentResponse; overload;
    function Clone : TFhirAppointmentResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this appointment response concern that are defined by business processes and/ or used to refer to it when a direct URL reference to the resource itself is not appropriate.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Appointment that this response is replying to. (defined for API consistency)
    property appointment : TFhirReference read FAppointment write SetAppointment;
    // Appointment that this response is replying to.
    property appointmentElement : TFhirReference read FAppointment write SetAppointment;

    // Typed access to Date/Time that the appointment is to take place, or requested new start time.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the appointment is to take place, or requested new start time.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to This may be either the same as the appointment request to confirm the details of the appointment, or alternately a new time to request a re-negotiation of the end time.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // This may be either the same as the appointment request to confirm the details of the appointment, or alternately a new time to request a re-negotiation of the end time.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Role of participant in the appointment.
    property participantTypeList : TFhirCodeableConceptList read GetParticipantTypeList;
    property hasParticipantTypeList : boolean read GetHasParticipantTypeList;

    // Typed access to A Person, Location, HealthcareService, or Device that is participating in the appointment. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // A Person, Location, HealthcareService, or Device that is participating in the appointment.
    property actorElement : TFhirReference read FActor write SetActor;

    // Participation status of the participant. When the status is declined or tentative if the start/end times are different to the appointment, then these times should be interpreted as a requested time change. When the status is accepted, the times can either be the time of the appointment (as a confirmation of the time) or can be empty.
    property participantStatus : TFhirParticipationStatusEnum read GetParticipantStatusST write SetParticipantStatusST;
    property participantStatusElement : TFhirEnum read FParticipantStatus write SetParticipantStatus;

    // Typed access to Additional comments about the appointment.
    property comment : String read GetCommentST write SetCommentST;
    // Additional comments about the appointment.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirAppointmentResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAppointmentResponseList;
    function GetCurrent : TFhirAppointmentResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAppointmentResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAppointmentResponse read GetCurrent;
  end;

  TFhirAppointmentResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAppointmentResponse;
    procedure SetItemN(index : Integer; value : TFhirAppointmentResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAppointmentResponseList; overload;
    function Clone : TFhirAppointmentResponseList; overload;
    function GetEnumerator : TFhirAppointmentResponseListEnumerator;
    
    //  Add a FhirAppointmentResponse to the end of the list.
    function Append : TFhirAppointmentResponse;
    
    // Add an already existing FhirAppointmentResponse to the end of the list.
    function AddItem(value : TFhirAppointmentResponse) : TFhirAppointmentResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAppointmentResponse) : Integer;
    
    // Insert FhirAppointmentResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAppointmentResponse;
    
    // Insert an existing FhirAppointmentResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAppointmentResponse);
    
    // Get the iIndexth FhirAppointmentResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAppointmentResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAppointmentResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAppointmentResponses[index : Integer] : TFhirAppointmentResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_BASIC}
  // Basic is used for handling concepts not yet defined in FHIR, narrative-only resources that don't map to an existing resource, and custom resources not appropriate for inclusion in the FHIR specification.
  TFhirBasic = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FCreated : TFhirDate;
    FAuthor : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetCreated(value : TFhirDate);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBasic; overload;
    function Clone : TFhirBasic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier assigned to the resource for business purposes, outside the context of FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Identifies the 'type' of resource - equivalent to the resource name for other resources. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identifies the 'type' of resource - equivalent to the resource name for other resources.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Identifies the patient, practitioner, device or any other resource that is the "focus" of this resource. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Identifies the patient, practitioner, device or any other resource that is the "focus" of this resource.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Identifies when the resource was first created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // Identifies when the resource was first created.
    property createdElement : TFhirDate read FCreated write SetCreated;

    // Typed access to Indicates who was responsible for creating the resource instance. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Indicates who was responsible for creating the resource instance.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

  end;

  TFhirBasicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBasicList;
    function GetCurrent : TFhirBasic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBasicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBasic read GetCurrent;
  end;

  TFhirBasicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBasic;
    procedure SetItemN(index : Integer; value : TFhirBasic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBasicList; overload;
    function Clone : TFhirBasicList; overload;
    function GetEnumerator : TFhirBasicListEnumerator;
    
    //  Add a FhirBasic to the end of the list.
    function Append : TFhirBasic;
    
    // Add an already existing FhirBasic to the end of the list.
    function AddItem(value : TFhirBasic) : TFhirBasic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBasic) : Integer;
    
    // Insert FhirBasic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBasic;
    
    // Insert an existing FhirBasic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBasic);
    
    // Get the iIndexth FhirBasic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBasic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBasic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBasics[index : Integer] : TFhirBasic read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
  // How this product was collected.
  TFhirBiologicallyDerivedProductCollection = class (TFhirBackboneElement)
  protected
    FCollector : TFhirReference;
    FSource : TFhirReference;
    FCollected : TFhirDataType;
    procedure SetCollector(value : TFhirReference);
    procedure SetSource(value : TFhirReference);
    procedure SetCollected(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductCollection; overload;
    function Clone : TFhirBiologicallyDerivedProductCollection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Healthcare professional who is performing the collection. (defined for API consistency)
    property collector : TFhirReference read FCollector write SetCollector;
    // Healthcare professional who is performing the collection.
    property collectorElement : TFhirReference read FCollector write SetCollector;

    // Typed access to The patient or entity, such as a hospital or vendor in the case of a processed/manipulated/manufactured product, providing the product. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // The patient or entity, such as a hospital or vendor in the case of a processed/manipulated/manufactured product, providing the product.
    property sourceElement : TFhirReference read FSource write SetSource;

    // Typed access to Time of product collection. (defined for API consistency)
    property collected : TFhirDataType read FCollected write SetCollected;
    // Time of product collection.
    property collectedElement : TFhirDataType read FCollected write SetCollected;

  end;

  TFhirBiologicallyDerivedProductCollectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductCollectionList;
    function GetCurrent : TFhirBiologicallyDerivedProductCollection;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductCollectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductCollection read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductCollectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductCollection;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductCollection);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductCollectionList; overload;
    function Clone : TFhirBiologicallyDerivedProductCollectionList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductCollectionListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProductCollection to the end of the list.
    function Append : TFhirBiologicallyDerivedProductCollection;
    
    // Add an already existing FhirBiologicallyDerivedProductCollection to the end of the list.
    function AddItem(value : TFhirBiologicallyDerivedProductCollection) : TFhirBiologicallyDerivedProductCollection; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductCollection) : Integer;
    
    // Insert FhirBiologicallyDerivedProductCollection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductCollection;
    
    // Insert an existing FhirBiologicallyDerivedProductCollection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductCollection);
    
    // Get the iIndexth FhirBiologicallyDerivedProductCollection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductCollection);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductCollection;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProductCollections[index : Integer] : TFhirBiologicallyDerivedProductCollection read GetItemN write SetItemN; default;
  End;

  // Any processing of the product during collection that does not change the fundamental nature of the product. For example adding anti-coagulants during the collection of Peripheral Blood Stem Cells.
  TFhirBiologicallyDerivedProductProcessing = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FAdditive : TFhirReference;
    FTime : TFhirDataType;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetProcedure_(value : TFhirCodeableConcept);
    procedure SetAdditive(value : TFhirReference);
    procedure SetTime(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductProcessing; overload;
    function Clone : TFhirBiologicallyDerivedProductProcessing; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of of processing.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of of processing.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Procesing code. (defined for API consistency)
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;
    // Procesing code.
    property procedure_Element : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    // Typed access to Substance added during processing. (defined for API consistency)
    property additive : TFhirReference read FAdditive write SetAdditive;
    // Substance added during processing.
    property additiveElement : TFhirReference read FAdditive write SetAdditive;

    // Typed access to Time of processing. (defined for API consistency)
    property time : TFhirDataType read FTime write SetTime;
    // Time of processing.
    property timeElement : TFhirDataType read FTime write SetTime;

  end;

  TFhirBiologicallyDerivedProductProcessingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductProcessingList;
    function GetCurrent : TFhirBiologicallyDerivedProductProcessing;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductProcessingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductProcessing read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductProcessingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductProcessing;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductProcessing);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductProcessingList; overload;
    function Clone : TFhirBiologicallyDerivedProductProcessingList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductProcessingListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProductProcessing to the end of the list.
    function Append : TFhirBiologicallyDerivedProductProcessing;
    
    // Add an already existing FhirBiologicallyDerivedProductProcessing to the end of the list.
    function AddItem(value : TFhirBiologicallyDerivedProductProcessing) : TFhirBiologicallyDerivedProductProcessing; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductProcessing) : Integer;
    
    // Insert FhirBiologicallyDerivedProductProcessing before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductProcessing;
    
    // Insert an existing FhirBiologicallyDerivedProductProcessing before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductProcessing);
    
    // Get the iIndexth FhirBiologicallyDerivedProductProcessing. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductProcessing);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductProcessing;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProductProcessings[index : Integer] : TFhirBiologicallyDerivedProductProcessing read GetItemN write SetItemN; default;
  End;

  // Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion.
  TFhirBiologicallyDerivedProductManipulation = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FTime : TFhirDataType;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetTime(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductManipulation; overload;
    function Clone : TFhirBiologicallyDerivedProductManipulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of manipulation.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of manipulation.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Time of manipulation. (defined for API consistency)
    property time : TFhirDataType read FTime write SetTime;
    // Time of manipulation.
    property timeElement : TFhirDataType read FTime write SetTime;

  end;

  TFhirBiologicallyDerivedProductManipulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductManipulationList;
    function GetCurrent : TFhirBiologicallyDerivedProductManipulation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductManipulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductManipulation read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductManipulationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductManipulation;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductManipulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductManipulationList; overload;
    function Clone : TFhirBiologicallyDerivedProductManipulationList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductManipulationListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProductManipulation to the end of the list.
    function Append : TFhirBiologicallyDerivedProductManipulation;
    
    // Add an already existing FhirBiologicallyDerivedProductManipulation to the end of the list.
    function AddItem(value : TFhirBiologicallyDerivedProductManipulation) : TFhirBiologicallyDerivedProductManipulation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductManipulation) : Integer;
    
    // Insert FhirBiologicallyDerivedProductManipulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductManipulation;
    
    // Insert an existing FhirBiologicallyDerivedProductManipulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductManipulation);
    
    // Get the iIndexth FhirBiologicallyDerivedProductManipulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductManipulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductManipulation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProductManipulations[index : Integer] : TFhirBiologicallyDerivedProductManipulation read GetItemN write SetItemN; default;
  End;

  // Product storage.
  TFhirBiologicallyDerivedProductStorage = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FTemperature : TFhirDecimal;
    FScale : TFhirEnum;
    FDuration : TFhirPeriod;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetTemperature(value : TFhirDecimal);
    function GetTemperatureST : String;
    procedure SetTemperatureST(value : String);
    procedure SetScale(value : TFhirEnum);
    function GetScaleST : TFhirBiologicallyDerivedProductStorageScaleEnum;
    procedure SetScaleST(value : TFhirBiologicallyDerivedProductStorageScaleEnum);
    procedure SetDuration(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProductStorage; overload;
    function Clone : TFhirBiologicallyDerivedProductStorage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of storage.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of storage.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Storage temperature.
    property temperature : String read GetTemperatureST write SetTemperatureST;
    // Storage temperature.
    property temperatureElement : TFhirDecimal read FTemperature write SetTemperature;

    // Temperature scale used.
    property scale : TFhirBiologicallyDerivedProductStorageScaleEnum read GetScaleST write SetScaleST;
    property scaleElement : TFhirEnum read FScale write SetScale;

    // Typed access to Storage timeperiod. (defined for API consistency)
    property duration : TFhirPeriod read FDuration write SetDuration;
    // Storage timeperiod.
    property durationElement : TFhirPeriod read FDuration write SetDuration;

  end;

  TFhirBiologicallyDerivedProductStorageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductStorageList;
    function GetCurrent : TFhirBiologicallyDerivedProductStorage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductStorageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProductStorage read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductStorageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProductStorage;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProductStorage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductStorageList; overload;
    function Clone : TFhirBiologicallyDerivedProductStorageList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductStorageListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProductStorage to the end of the list.
    function Append : TFhirBiologicallyDerivedProductStorage;
    
    // Add an already existing FhirBiologicallyDerivedProductStorage to the end of the list.
    function AddItem(value : TFhirBiologicallyDerivedProductStorage) : TFhirBiologicallyDerivedProductStorage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProductStorage) : Integer;
    
    // Insert FhirBiologicallyDerivedProductStorage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProductStorage;
    
    // Insert an existing FhirBiologicallyDerivedProductStorage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProductStorage);
    
    // Get the iIndexth FhirBiologicallyDerivedProductStorage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProductStorage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProductStorage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProductStorages[index : Integer] : TFhirBiologicallyDerivedProductStorage read GetItemN write SetItemN; default;
  End;

  // A material substance originating from a biological entity intended to be transplanted or infused into another (possibly the same) biological entity.
  TFhirBiologicallyDerivedProduct = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FProductCategory : TFhirEnum;
    FProductCode : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FrequestList : TFhirReferenceList;
    FQuantity : TFhirInteger;
    FparentList : TFhirReferenceList;
    FCollection : TFhirBiologicallyDerivedProductCollection;
    FprocessingList : TFhirBiologicallyDerivedProductProcessingList;
    FManipulation : TFhirBiologicallyDerivedProductManipulation;
    FstorageList : TFhirBiologicallyDerivedProductStorageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetProductCategory(value : TFhirEnum);
    function GetProductCategoryST : TFhirBiologicallyDerivedProductCategoryEnum;
    procedure SetProductCategoryST(value : TFhirBiologicallyDerivedProductCategoryEnum);
    procedure SetProductCode(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirBiologicallyDerivedProductStatusEnum;
    procedure SetStatusST(value : TFhirBiologicallyDerivedProductStatusEnum);
    function GetRequestList : TFhirReferenceList;
    function GetHasRequestList : Boolean;
    procedure SetQuantity(value : TFhirInteger);
    function GetQuantityST : String;
    procedure SetQuantityST(value : String);
    function GetParentList : TFhirReferenceList;
    function GetHasParentList : Boolean;
    procedure SetCollection(value : TFhirBiologicallyDerivedProductCollection);
    function GetProcessingList : TFhirBiologicallyDerivedProductProcessingList;
    function GetHasProcessingList : Boolean;
    procedure SetManipulation(value : TFhirBiologicallyDerivedProductManipulation);
    function GetStorageList : TFhirBiologicallyDerivedProductStorageList;
    function GetHasStorageList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBiologicallyDerivedProduct; overload;
    function Clone : TFhirBiologicallyDerivedProduct; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This records identifiers associated with this biologically derived product instance that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate (e.g. in CDA documents, or in written / printed documentation).
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Broad category of this product.
    property productCategory : TFhirBiologicallyDerivedProductCategoryEnum read GetProductCategoryST write SetProductCategoryST;
    property productCategoryElement : TFhirEnum read FProductCategory write SetProductCategory;

    // Typed access to A code that identifies the kind of this biologically derived product (SNOMED Ctcode). (defined for API consistency)
    property productCode : TFhirCodeableConcept read FProductCode write SetProductCode;
    // A code that identifies the kind of this biologically derived product (SNOMED Ctcode).
    property productCodeElement : TFhirCodeableConcept read FProductCode write SetProductCode;

    // Whether the product is currently available.
    property status : TFhirBiologicallyDerivedProductStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Procedure request to obtain this biologically derived product.
    property requestList : TFhirReferenceList read GetRequestList;
    property hasRequestList : boolean read GetHasRequestList;

    // Typed access to Number of discrete units within this product.
    property quantity : String read GetQuantityST write SetQuantityST;
    // Number of discrete units within this product.
    property quantityElement : TFhirInteger read FQuantity write SetQuantity;

    // Parent product (if any).
    property parentList : TFhirReferenceList read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // Typed access to How this product was collected. (defined for API consistency)
    property collection : TFhirBiologicallyDerivedProductCollection read FCollection write SetCollection;
    // How this product was collected.
    property collectionElement : TFhirBiologicallyDerivedProductCollection read FCollection write SetCollection;

    // Any processing of the product during collection that does not change the fundamental nature of the product. For example adding anti-coagulants during the collection of Peripheral Blood Stem Cells.
    property processingList : TFhirBiologicallyDerivedProductProcessingList read GetProcessingList;
    property hasProcessingList : boolean read GetHasProcessingList;

    // Typed access to Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion. (defined for API consistency)
    property manipulation : TFhirBiologicallyDerivedProductManipulation read FManipulation write SetManipulation;
    // Any manipulation of product post-collection that is intended to alter the product.  For example a buffy-coat enrichment or CD8 reduction of Peripheral Blood Stem Cells to make it more suitable for infusion.
    property manipulationElement : TFhirBiologicallyDerivedProductManipulation read FManipulation write SetManipulation;

    // Product storage.
    property storageList : TFhirBiologicallyDerivedProductStorageList read GetStorageList;
    property hasStorageList : boolean read GetHasStorageList;

  end;

  TFhirBiologicallyDerivedProductListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBiologicallyDerivedProductList;
    function GetCurrent : TFhirBiologicallyDerivedProduct;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBiologicallyDerivedProductList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBiologicallyDerivedProduct read GetCurrent;
  end;

  TFhirBiologicallyDerivedProductList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBiologicallyDerivedProduct;
    procedure SetItemN(index : Integer; value : TFhirBiologicallyDerivedProduct);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBiologicallyDerivedProductList; overload;
    function Clone : TFhirBiologicallyDerivedProductList; overload;
    function GetEnumerator : TFhirBiologicallyDerivedProductListEnumerator;
    
    //  Add a FhirBiologicallyDerivedProduct to the end of the list.
    function Append : TFhirBiologicallyDerivedProduct;
    
    // Add an already existing FhirBiologicallyDerivedProduct to the end of the list.
    function AddItem(value : TFhirBiologicallyDerivedProduct) : TFhirBiologicallyDerivedProduct; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBiologicallyDerivedProduct) : Integer;
    
    // Insert FhirBiologicallyDerivedProduct before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBiologicallyDerivedProduct;
    
    // Insert an existing FhirBiologicallyDerivedProduct before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBiologicallyDerivedProduct);
    
    // Get the iIndexth FhirBiologicallyDerivedProduct. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBiologicallyDerivedProduct);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBiologicallyDerivedProduct;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBiologicallyDerivedProducts[index : Integer] : TFhirBiologicallyDerivedProduct read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
  // Record details about an anatomical structure.  This resource may be used when a coded concept does not provide the necessary detail needed for the use case.
  TFhirBodyStructure = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FMorphology : TFhirCodeableConcept;
    FLocation : TFhirCodeableConcept;
    FlocationQualifierList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FimageList : TFhirAttachmentList;
    FPatient : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetMorphology(value : TFhirCodeableConcept);
    procedure SetLocation(value : TFhirCodeableConcept);
    function GetLocationQualifierList : TFhirCodeableConceptList;
    function GetHasLocationQualifierList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetImageList : TFhirAttachmentList;
    function GetHasImageList : Boolean;
    procedure SetPatient(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBodyStructure; overload;
    function Clone : TFhirBodyStructure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for this instance of the anatomical structure.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this body site is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this body site is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The kind of structure being represented by the body structure at `BodyStructure.location`.  This can define both normal and abnormal morphologies. (defined for API consistency)
    property morphology : TFhirCodeableConcept read FMorphology write SetMorphology;
    // The kind of structure being represented by the body structure at `BodyStructure.location`.  This can define both normal and abnormal morphologies.
    property morphologyElement : TFhirCodeableConcept read FMorphology write SetMorphology;

    // Typed access to The anatomical location or region of the specimen, lesion, or body structure. (defined for API consistency)
    property location : TFhirCodeableConcept read FLocation write SetLocation;
    // The anatomical location or region of the specimen, lesion, or body structure.
    property locationElement : TFhirCodeableConcept read FLocation write SetLocation;

    // Qualifier to refine the anatomical location.  These include qualifiers for laterality, relative location, directionality, number, and plane.
    property locationQualifierList : TFhirCodeableConceptList read GetLocationQualifierList;
    property hasLocationQualifierList : boolean read GetHasLocationQualifierList;

    // Typed access to A summary, characterization or explanation of the body structure.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A summary, characterization or explanation of the body structure.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Image or images used to identify a location.
    property imageList : TFhirAttachmentList read GetImageList;
    property hasImageList : boolean read GetHasImageList;

    // Typed access to The person to which the body site belongs. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The person to which the body site belongs.
    property patientElement : TFhirReference read FPatient write SetPatient;

  end;

  TFhirBodyStructureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBodyStructureList;
    function GetCurrent : TFhirBodyStructure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBodyStructureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBodyStructure read GetCurrent;
  end;

  TFhirBodyStructureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBodyStructure;
    procedure SetItemN(index : Integer; value : TFhirBodyStructure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBodyStructureList; overload;
    function Clone : TFhirBodyStructureList; overload;
    function GetEnumerator : TFhirBodyStructureListEnumerator;
    
    //  Add a FhirBodyStructure to the end of the list.
    function Append : TFhirBodyStructure;
    
    // Add an already existing FhirBodyStructure to the end of the list.
    function AddItem(value : TFhirBodyStructure) : TFhirBodyStructure; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBodyStructure) : Integer;
    
    // Insert FhirBodyStructure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBodyStructure;
    
    // Insert an existing FhirBodyStructure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBodyStructure);
    
    // Get the iIndexth FhirBodyStructure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBodyStructure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBodyStructure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBodyStructures[index : Integer] : TFhirBodyStructure read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_CAREPLAN}
  // Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
  TFhirCarePlanActivity = class (TFhirBackboneElement)
  protected
    FoutcomeCodeableConceptList : TFhirCodeableConceptList;
    FoutcomeReferenceList : TFhirReferenceList;
    FprogressList : TFhirAnnotationList;
    FReference : TFhirReference;
    FDetail : TFhirCarePlanActivityDetail;
    function GetOutcomeCodeableConceptList : TFhirCodeableConceptList;
    function GetHasOutcomeCodeableConceptList : Boolean;
    function GetOutcomeReferenceList : TFhirReferenceList;
    function GetHasOutcomeReferenceList : Boolean;
    function GetProgressList : TFhirAnnotationList;
    function GetHasProgressList : Boolean;
    procedure SetReference(value : TFhirReference);
    procedure SetDetail(value : TFhirCarePlanActivityDetail);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanActivity; overload;
    function Clone : TFhirCarePlanActivity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifies the outcome at the point when the status of the activity is assessed.  For example, the outcome of an education activity could be patient understands (or not).
    property outcomeCodeableConceptList : TFhirCodeableConceptList read GetOutcomeCodeableConceptList;
    property hasOutcomeCodeableConceptList : boolean read GetHasOutcomeCodeableConceptList;

    // Details of the outcome or action resulting from the activity.  The reference to an "event" resource, such as Procedure or Encounter or Observation, is the result/outcome of the activity itself.  The activity can be conveyed using CarePlan.activity.detail OR using the CarePlan.activity.reference (a reference to a request resource).
    property outcomeReferenceList : TFhirReferenceList read GetOutcomeReferenceList;
    property hasOutcomeReferenceList : boolean read GetHasOutcomeReferenceList;

    // Notes about the adherence/status/progress of the activity.
    property progressList : TFhirAnnotationList read GetProgressList;
    property hasProgressList : boolean read GetHasProgressList;

    // Typed access to The details of the proposed activity represented in a specific resource. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // The details of the proposed activity represented in a specific resource.
    property referenceElement : TFhirReference read FReference write SetReference;

    // Typed access to A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc. (defined for API consistency)
    property detail : TFhirCarePlanActivityDetail read FDetail write SetDetail;
    // A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
    property detailElement : TFhirCarePlanActivityDetail read FDetail write SetDetail;

  end;

  TFhirCarePlanActivityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivityList;
    function GetCurrent : TFhirCarePlanActivity;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanActivityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivity read GetCurrent;
  end;

  TFhirCarePlanActivityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanActivity;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCarePlanActivityList; overload;
    function Clone : TFhirCarePlanActivityList; overload;
    function GetEnumerator : TFhirCarePlanActivityListEnumerator;
    
    //  Add a FhirCarePlanActivity to the end of the list.
    function Append : TFhirCarePlanActivity;
    
    // Add an already existing FhirCarePlanActivity to the end of the list.
    function AddItem(value : TFhirCarePlanActivity) : TFhirCarePlanActivity; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanActivity) : Integer;
    
    // Insert FhirCarePlanActivity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanActivity;
    
    // Insert an existing FhirCarePlanActivity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivity);
    
    // Get the iIndexth FhirCarePlanActivity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanActivity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCarePlanActivities[index : Integer] : TFhirCarePlanActivity read GetItemN write SetItemN; default;
  End;

  // A simple summary of a planned activity suitable for a general care plan system (e.g. form driven) that doesn't know about specific resources such as procedure etc.
  TFhirCarePlanActivityDetail = class (TFhirBackboneElement)
  protected
    FKind : TFhirEnum;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FCode : TFhirCodeableConcept;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FgoalList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FDoNotPerform : TFhirBoolean;
    FScheduled : TFhirDataType;
    FLocation : TFhirReference;
    FperformerList : TFhirReferenceList;
    FProduct : TFhirDataType;
    FDailyAmount : TFhirQuantity;
    FQuantity : TFhirQuantity;
    FDescription : TFhirString;
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirCarePlanActivityKindEnum;
    procedure SetKindST(value : TFhirCarePlanActivityKindEnum);
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetGoalList : TFhirReferenceList;
    function GetHasGoalList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirCarePlanActivityStatusEnum;
    procedure SetStatusST(value : TFhirCarePlanActivityStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetScheduled(value : TFhirDataType);
    procedure SetLocation(value : TFhirReference);
    function GetPerformerList : TFhirReferenceList;
    function GetHasPerformerList : Boolean;
    procedure SetProduct(value : TFhirDataType);
    procedure SetDailyAmount(value : TFhirQuantity);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlanActivityDetail; overload;
    function Clone : TFhirCarePlanActivityDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A description of the kind of resource the in-line definition of a care plan activity is representing.  The CarePlan.activity.detail is an in-line definition when a resource is not referenced using CarePlan.activity.reference.  For example, a MedicationRequest, a ServiceRequest, or a CommunicationRequest.
    property kind : TFhirCarePlanActivityKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // The URL pointing to a FHIR-defined protocol, guideline, questionnaire or other definition that is adhered to in whole or in part by this CarePlan activity.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, questionnaire or other definition that is adhered to in whole or in part by this CarePlan activity.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // Typed access to Detailed description of the type of planned activity; e.g. what lab test, what procedure, what kind of encounter. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Detailed description of the type of planned activity; e.g. what lab test, what procedure, what kind of encounter.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Provides the rationale that drove the inclusion of this particular activity as part of the plan or the reason why the activity was prohibited.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource, such as the health condition(s), whose existence justifies this request and drove the inclusion of this particular activity as part of the plan.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Internal reference that identifies the goals that this activity is intended to contribute towards meeting.
    property goalList : TFhirReferenceList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Identifies what progress is being made for the specific activity.
    property status : TFhirCarePlanActivityStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Provides reason why the activity isn't yet started, is on hold, was cancelled, etc. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Provides reason why the activity isn't yet started, is on hold, was cancelled, etc.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to If true, indicates that the described activity is one that must NOT be engaged in when following the plan.  If false, or missing, indicates that the described activity is one that should be engaged in when following the plan.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // If true, indicates that the described activity is one that must NOT be engaged in when following the plan.  If false, or missing, indicates that the described activity is one that should be engaged in when following the plan.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to The period, timing or frequency upon which the described activity is to occur. (defined for API consistency)
    property scheduled : TFhirDataType read FScheduled write SetScheduled;
    // The period, timing or frequency upon which the described activity is to occur.
    property scheduledElement : TFhirDataType read FScheduled write SetScheduled;

    // Typed access to Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Identifies who's expected to be involved in the activity.
    property performerList : TFhirReferenceList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to Identifies the food, drug or other product to be consumed or supplied in the activity. (defined for API consistency)
    property product : TFhirDataType read FProduct write SetProduct;
    // Identifies the food, drug or other product to be consumed or supplied in the activity.
    property productElement : TFhirDataType read FProduct write SetProduct;

    // Typed access to Identifies the quantity expected to be consumed in a given day. (defined for API consistency)
    property dailyAmount : TFhirQuantity read FDailyAmount write SetDailyAmount;
    // Identifies the quantity expected to be consumed in a given day.
    property dailyAmountElement : TFhirQuantity read FDailyAmount write SetDailyAmount;

    // Typed access to Identifies the quantity expected to be supplied, administered or consumed by the subject. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Identifies the quantity expected to be supplied, administered or consumed by the subject.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to This provides a textual description of constraints on the intended activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    property description : String read GetDescriptionST write SetDescriptionST;
    // This provides a textual description of constraints on the intended activity occurrence, including relation to other activities.  It may also include objectives, pre-conditions and end-conditions.  Finally, it may convey specifics about the activity such as body site, method, route, etc.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirCarePlanActivityDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanActivityDetailList;
    function GetCurrent : TFhirCarePlanActivityDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanActivityDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlanActivityDetail read GetCurrent;
  end;

  TFhirCarePlanActivityDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlanActivityDetail;
    procedure SetItemN(index : Integer; value : TFhirCarePlanActivityDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCarePlanActivityDetailList; overload;
    function Clone : TFhirCarePlanActivityDetailList; overload;
    function GetEnumerator : TFhirCarePlanActivityDetailListEnumerator;
    
    //  Add a FhirCarePlanActivityDetail to the end of the list.
    function Append : TFhirCarePlanActivityDetail;
    
    // Add an already existing FhirCarePlanActivityDetail to the end of the list.
    function AddItem(value : TFhirCarePlanActivityDetail) : TFhirCarePlanActivityDetail; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlanActivityDetail) : Integer;
    
    // Insert FhirCarePlanActivityDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlanActivityDetail;
    
    // Insert an existing FhirCarePlanActivityDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlanActivityDetail);
    
    // Get the iIndexth FhirCarePlanActivityDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlanActivityDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlanActivityDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCarePlanActivityDetails[index : Integer] : TFhirCarePlanActivityDetail read GetItemN write SetItemN; default;
  End;

  // Describes the intention of how one or more practitioners intend to deliver care for a particular patient, group or community for a period of time, possibly limited to care for a specific condition or set of conditions.
  TFhirCarePlan = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FreplacesList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FPeriod : TFhirPeriod;
    FCreated : TFhirDateTime;
    FAuthor : TFhirReference;
    FcontributorList : TFhirReferenceList;
    FcareTeamList : TFhirReferenceList;
    FaddressesList : TFhirReferenceList;
    FsupportingInfoList : TFhirReferenceList;
    FgoalList : TFhirReferenceList;
    FactivityList : TFhirCarePlanActivityList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList;
    function GetHasReplacesList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirCarePlanIntentEnum;
    procedure SetIntentST(value : TFhirCarePlanIntentEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
    function GetContributorList : TFhirReferenceList;
    function GetHasContributorList : Boolean;
    function GetCareTeamList : TFhirReferenceList;
    function GetHasCareTeamList : Boolean;
    function GetAddressesList : TFhirReferenceList;
    function GetHasAddressesList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetGoalList : TFhirReferenceList;
    function GetHasGoalList : Boolean;
    function GetActivityList : TFhirCarePlanActivityList;
    function GetHasActivityList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCarePlan; overload;
    function Clone : TFhirCarePlan; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this care plan by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, questionnaire or other definition that is adhered to in whole or in part by this CarePlan.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, questionnaire or other definition that is adhered to in whole or in part by this CarePlan.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A care plan that is fulfilled in whole or in part by this care plan.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated care plan whose function is taken by this new care plan.
    property replacesList : TFhirReferenceList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // A larger care plan of which this particular care plan is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Indicates whether the plan is currently being acted upon, represents future intentions or is now a historical record.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the level of authority/intentionality associated with the care plan and where the care plan fits into the workflow chain.
    property intent : TFhirCarePlanIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Identifies what "kind" of plan this is to support differentiation between multiple co-existing plans; e.g. "Home health", "psychiatric", "asthma", "disease management", "wellness plan", etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Human-friendly name for the care plan.
    property title : String read GetTitleST write SetTitleST;
    // Human-friendly name for the care plan.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A description of the scope and nature of the plan.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the scope and nature of the plan.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Identifies the patient or group whose intended care is described by the plan. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Identifies the patient or group whose intended care is described by the plan.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this CarePlan was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this CarePlan was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Indicates when the plan did (or is intended to) come into effect and end. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates when the plan did (or is intended to) come into effect and end.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Represents when this particular CarePlan record was created in the system, which is often a system-generated date.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // Represents when this particular CarePlan record was created in the system, which is often a system-generated date.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to When populated, the author is responsible for the care plan.  The care plan is attributed to the author. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // When populated, the author is responsible for the care plan.  The care plan is attributed to the author.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Identifies the individual(s) or organization who provided the contents of the care plan.
    property contributorList : TFhirReferenceList read GetContributorList;
    property hasContributorList : boolean read GetHasContributorList;

    // Identifies all people and organizations who are expected to be involved in the care envisioned by this plan.
    property careTeamList : TFhirReferenceList read GetCareTeamList;
    property hasCareTeamList : boolean read GetHasCareTeamList;

    // Identifies the conditions/problems/concerns/diagnoses/etc. whose management and/or mitigation are handled by this plan.
    property addressesList : TFhirReferenceList read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Identifies portions of the patient's record that specifically influenced the formation of the plan.  These might include comorbidities, recent procedures, limitations, recent assessments, etc.
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Describes the intended objective(s) of carrying out the care plan.
    property goalList : TFhirReferenceList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // Identifies a planned action to occur as part of the plan.  For example, a medication to be used, lab tests to perform, self-monitoring, education, etc.
    property activityList : TFhirCarePlanActivityList read GetActivityList;
    property hasActivityList : boolean read GetHasActivityList;

    // General notes about the care plan not covered elsewhere.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCarePlanListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCarePlanList;
    function GetCurrent : TFhirCarePlan;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCarePlanList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCarePlan read GetCurrent;
  end;

  TFhirCarePlanList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCarePlan;
    procedure SetItemN(index : Integer; value : TFhirCarePlan);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCarePlanList; overload;
    function Clone : TFhirCarePlanList; overload;
    function GetEnumerator : TFhirCarePlanListEnumerator;
    
    //  Add a FhirCarePlan to the end of the list.
    function Append : TFhirCarePlan;
    
    // Add an already existing FhirCarePlan to the end of the list.
    function AddItem(value : TFhirCarePlan) : TFhirCarePlan; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCarePlan) : Integer;
    
    // Insert FhirCarePlan before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCarePlan;
    
    // Insert an existing FhirCarePlan before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCarePlan);
    
    // Get the iIndexth FhirCarePlan. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCarePlan);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCarePlan;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCarePlans[index : Integer] : TFhirCarePlan read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
  // Identifies all people and organizations who are expected to be involved in the care team.
  TFhirCareTeamParticipant = class (TFhirBackboneElement)
  protected
    FroleList : TFhirCodeableConceptList;
    FMember : TFhirReference;
    FOnBehalfOf : TFhirReference;
    FPeriod : TFhirPeriod;
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    procedure SetMember(value : TFhirReference);
    procedure SetOnBehalfOf(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCareTeamParticipant; overload;
    function Clone : TFhirCareTeamParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates specific responsibility of an individual within the care team, such as "Primary care physician", "Trained social worker counselor", "Caregiver", etc.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to The specific person or organization who is participating/expected to participate in the care team. (defined for API consistency)
    property member : TFhirReference read FMember write SetMember;
    // The specific person or organization who is participating/expected to participate in the care team.
    property memberElement : TFhirReference read FMember write SetMember;

    // Typed access to The organization of the practitioner. (defined for API consistency)
    property onBehalfOf : TFhirReference read FOnBehalfOf write SetOnBehalfOf;
    // The organization of the practitioner.
    property onBehalfOfElement : TFhirReference read FOnBehalfOf write SetOnBehalfOf;

    // Typed access to Indicates when the specific member or organization did (or is intended to) come into effect and end. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates when the specific member or organization did (or is intended to) come into effect and end.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirCareTeamParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCareTeamParticipantList;
    function GetCurrent : TFhirCareTeamParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCareTeamParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCareTeamParticipant read GetCurrent;
  end;

  TFhirCareTeamParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCareTeamParticipant;
    procedure SetItemN(index : Integer; value : TFhirCareTeamParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCareTeamParticipantList; overload;
    function Clone : TFhirCareTeamParticipantList; overload;
    function GetEnumerator : TFhirCareTeamParticipantListEnumerator;
    
    //  Add a FhirCareTeamParticipant to the end of the list.
    function Append : TFhirCareTeamParticipant;
    
    // Add an already existing FhirCareTeamParticipant to the end of the list.
    function AddItem(value : TFhirCareTeamParticipant) : TFhirCareTeamParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCareTeamParticipant) : Integer;
    
    // Insert FhirCareTeamParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCareTeamParticipant;
    
    // Insert an existing FhirCareTeamParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCareTeamParticipant);
    
    // Get the iIndexth FhirCareTeamParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCareTeamParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCareTeamParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCareTeamParticipants[index : Integer] : TFhirCareTeamParticipant read GetItemN write SetItemN; default;
  End;

  // The Care Team includes all the people and organizations who plan to participate in the coordination and delivery of care for a patient.
  TFhirCareTeam = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FName : TFhirString;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FPeriod : TFhirPeriod;
    FparticipantList : TFhirCareTeamParticipantList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FmanagingOrganizationList : TFhirReferenceList;
    FtelecomList : TFhirContactPointList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirCareTeamStatusEnum;
    procedure SetStatusST(value : TFhirCareTeamStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    function GetParticipantList : TFhirCareTeamParticipantList;
    function GetHasParticipantList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetManagingOrganizationList : TFhirReferenceList;
    function GetHasManagingOrganizationList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCareTeam; overload;
    function Clone : TFhirCareTeam; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this care team by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of the care team.
    property status : TFhirCareTeamStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Identifies what kind of team.  This is to support differentiation between multiple co-existing teams, such as care plan team, episode of care team, longitudinal care team.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A label for human use intended to distinguish like teams.  E.g. the "red" vs. "green" trauma teams.
    property name : String read GetNameST write SetNameST;
    // A label for human use intended to distinguish like teams.  E.g. the "red" vs. "green" trauma teams.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Identifies the patient or group whose intended care is handled by the team. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Identifies the patient or group whose intended care is handled by the team.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this CareTeam was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this CareTeam was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Indicates when the team did (or is intended to) come into effect and end. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Indicates when the team did (or is intended to) come into effect and end.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Identifies all people and organizations who are expected to be involved in the care team.
    property participantList : TFhirCareTeamParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Describes why the care team exists.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Condition(s) that this care team addresses.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // The organization responsible for the care team.
    property managingOrganizationList : TFhirReferenceList read GetManagingOrganizationList;
    property hasManagingOrganizationList : boolean read GetHasManagingOrganizationList;

    // A central contact detail for the care team (that applies to all members).
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Comments made about the CareTeam.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCareTeamListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCareTeamList;
    function GetCurrent : TFhirCareTeam;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCareTeamList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCareTeam read GetCurrent;
  end;

  TFhirCareTeamList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCareTeam;
    procedure SetItemN(index : Integer; value : TFhirCareTeam);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCareTeamList; overload;
    function Clone : TFhirCareTeamList; overload;
    function GetEnumerator : TFhirCareTeamListEnumerator;
    
    //  Add a FhirCareTeam to the end of the list.
    function Append : TFhirCareTeam;
    
    // Add an already existing FhirCareTeam to the end of the list.
    function AddItem(value : TFhirCareTeam) : TFhirCareTeam; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCareTeam) : Integer;
    
    // Insert FhirCareTeam before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCareTeam;
    
    // Insert an existing FhirCareTeam before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCareTeam);
    
    // Get the iIndexth FhirCareTeam. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCareTeam);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCareTeam;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCareTeams[index : Integer] : TFhirCareTeam read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CLINICALIMPRESSION}
  // One or more sets of investigations (signs, symptoms, etc.). The actual grouping of investigations varies greatly depending on the type and context of the assessment. These investigations may include data generated during the assessment process, or data previously generated and recorded that is pertinent to the outcomes.
  TFhirClinicalImpressionInvestigation = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FitemList : TFhirReferenceList;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetItemList : TFhirReferenceList;
    function GetHasItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpressionInvestigation; overload;
    function Clone : TFhirClinicalImpressionInvestigation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A name/code for the group ("set") of investigations. Typically, this will be something like "signs", "symptoms", "clinical", "diagnostic", but the list is not constrained, and others such groups such as (exposure|family|travel|nutritional) history may be used. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A name/code for the group ("set") of investigations. Typically, this will be something like "signs", "symptoms", "clinical", "diagnostic", but the list is not constrained, and others such groups such as (exposure|family|travel|nutritional) history may be used.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // A record of a specific investigation that was undertaken.
    property itemList : TFhirReferenceList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirClinicalImpressionInvestigationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionInvestigationList;
    function GetCurrent : TFhirClinicalImpressionInvestigation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionInvestigationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpressionInvestigation read GetCurrent;
  end;

  TFhirClinicalImpressionInvestigationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalImpressionInvestigation;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpressionInvestigation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalImpressionInvestigationList; overload;
    function Clone : TFhirClinicalImpressionInvestigationList; overload;
    function GetEnumerator : TFhirClinicalImpressionInvestigationListEnumerator;
    
    //  Add a FhirClinicalImpressionInvestigation to the end of the list.
    function Append : TFhirClinicalImpressionInvestigation;
    
    // Add an already existing FhirClinicalImpressionInvestigation to the end of the list.
    function AddItem(value : TFhirClinicalImpressionInvestigation) : TFhirClinicalImpressionInvestigation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpressionInvestigation) : Integer;
    
    // Insert FhirClinicalImpressionInvestigation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpressionInvestigation;
    
    // Insert an existing FhirClinicalImpressionInvestigation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpressionInvestigation);
    
    // Get the iIndexth FhirClinicalImpressionInvestigation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpressionInvestigation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpressionInvestigation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalImpressionInvestigations[index : Integer] : TFhirClinicalImpressionInvestigation read GetItemN write SetItemN; default;
  End;

  // Specific findings or diagnoses that were considered likely or relevant to ongoing treatment.
  TFhirClinicalImpressionFinding = class (TFhirBackboneElement)
  protected
    FItemCodeableConcept : TFhirCodeableConcept;
    FItemReference : TFhirReference;
    FBasis : TFhirString;
    procedure SetItemCodeableConcept(value : TFhirCodeableConcept);
    procedure SetItemReference(value : TFhirReference);
    procedure SetBasis(value : TFhirString);
    function GetBasisST : String;
    procedure SetBasisST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpressionFinding; overload;
    function Clone : TFhirClinicalImpressionFinding; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specific text or code for finding or diagnosis, which may include ruled-out or resolved conditions. (defined for API consistency)
    property itemCodeableConcept : TFhirCodeableConcept read FItemCodeableConcept write SetItemCodeableConcept;
    // Specific text or code for finding or diagnosis, which may include ruled-out or resolved conditions.
    property itemCodeableConceptElement : TFhirCodeableConcept read FItemCodeableConcept write SetItemCodeableConcept;

    // Typed access to Specific reference for finding or diagnosis, which may include ruled-out or resolved conditions. (defined for API consistency)
    property itemReference : TFhirReference read FItemReference write SetItemReference;
    // Specific reference for finding or diagnosis, which may include ruled-out or resolved conditions.
    property itemReferenceElement : TFhirReference read FItemReference write SetItemReference;

    // Typed access to Which investigations support finding or diagnosis.
    property basis : String read GetBasisST write SetBasisST;
    // Which investigations support finding or diagnosis.
    property basisElement : TFhirString read FBasis write SetBasis;

  end;

  TFhirClinicalImpressionFindingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionFindingList;
    function GetCurrent : TFhirClinicalImpressionFinding;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionFindingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpressionFinding read GetCurrent;
  end;

  TFhirClinicalImpressionFindingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalImpressionFinding;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpressionFinding);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalImpressionFindingList; overload;
    function Clone : TFhirClinicalImpressionFindingList; overload;
    function GetEnumerator : TFhirClinicalImpressionFindingListEnumerator;
    
    //  Add a FhirClinicalImpressionFinding to the end of the list.
    function Append : TFhirClinicalImpressionFinding;
    
    // Add an already existing FhirClinicalImpressionFinding to the end of the list.
    function AddItem(value : TFhirClinicalImpressionFinding) : TFhirClinicalImpressionFinding; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpressionFinding) : Integer;
    
    // Insert FhirClinicalImpressionFinding before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpressionFinding;
    
    // Insert an existing FhirClinicalImpressionFinding before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpressionFinding);
    
    // Get the iIndexth FhirClinicalImpressionFinding. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpressionFinding);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpressionFinding;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalImpressionFindings[index : Integer] : TFhirClinicalImpressionFinding read GetItemN write SetItemN; default;
  End;

  // A record of a clinical assessment performed to determine what problem(s) may affect the patient and before planning the treatments or management strategies that are best to manage a patient's condition. Assessments are often 1:1 with a clinical consultation / encounter,  but this varies greatly depending on the clinical workflow. This resource is called "ClinicalImpression" rather than "ClinicalAssessment" to avoid confusion with the recording of assessment tools such as Apgar score.
  TFhirClinicalImpression = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FEffective : TFhirDataType;
    FDate : TFhirDateTime;
    FAssessor : TFhirReference;
    FPrevious : TFhirReference;
    FproblemList : TFhirReferenceList;
    FinvestigationList : TFhirClinicalImpressionInvestigationList;
    FprotocolList : TFhirUriList;
    FSummary : TFhirString;
    FfindingList : TFhirClinicalImpressionFindingList;
    FprognosisCodeableConceptList : TFhirCodeableConceptList;
    FprognosisReferenceList : TFhirReferenceList;
    FsupportingInfoList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirClinicalImpressionStatusEnum;
    procedure SetStatusST(value : TFhirClinicalImpressionStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetEffective(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAssessor(value : TFhirReference);
    procedure SetPrevious(value : TFhirReference);
    function GetProblemList : TFhirReferenceList;
    function GetHasProblemList : Boolean;
    function GetInvestigationList : TFhirClinicalImpressionInvestigationList;
    function GetHasInvestigationList : Boolean;
    function GetProtocolList : TFhirUriList;
    function GetHasProtocolList : Boolean;
    procedure SetSummary(value : TFhirString);
    function GetSummaryST : String;
    procedure SetSummaryST(value : String);
    function GetFindingList : TFhirClinicalImpressionFindingList;
    function GetHasFindingList : Boolean;
    function GetPrognosisCodeableConceptList : TFhirCodeableConceptList;
    function GetHasPrognosisCodeableConceptList : Boolean;
    function GetPrognosisReferenceList : TFhirReferenceList;
    function GetHasPrognosisReferenceList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalImpression; overload;
    function Clone : TFhirClinicalImpression; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this clinical impression by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Identifies the workflow status of the assessment.
    property status : TFhirClinicalImpressionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the ClinicalImpression. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the ClinicalImpression.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to Categorizes the type of clinical assessment performed. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Categorizes the type of clinical assessment performed.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A summary of the context and/or cause of the assessment - why / where it was performed, and what patient events/status prompted it.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A summary of the context and/or cause of the assessment - why / where it was performed, and what patient events/status prompted it.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The patient or group of individuals assessed as part of this record. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group of individuals assessed as part of this record.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this ClinicalImpression was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this ClinicalImpression was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The point in time or period over which the subject was assessed. (defined for API consistency)
    property effective : TFhirDataType read FEffective write SetEffective;
    // The point in time or period over which the subject was assessed.
    property effectiveElement : TFhirDataType read FEffective write SetEffective;

    // Typed access to Indicates when the documentation of the assessment was complete.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Indicates when the documentation of the assessment was complete.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The clinician performing the assessment. (defined for API consistency)
    property assessor : TFhirReference read FAssessor write SetAssessor;
    // The clinician performing the assessment.
    property assessorElement : TFhirReference read FAssessor write SetAssessor;

    // Typed access to A reference to the last assessment that was conducted on this patient. Assessments are often/usually ongoing in nature; a care provider (practitioner or team) will make new assessments on an ongoing basis as new data arises or the patient's conditions changes. (defined for API consistency)
    property previous : TFhirReference read FPrevious write SetPrevious;
    // A reference to the last assessment that was conducted on this patient. Assessments are often/usually ongoing in nature; a care provider (practitioner or team) will make new assessments on an ongoing basis as new data arises or the patient's conditions changes.
    property previousElement : TFhirReference read FPrevious write SetPrevious;

    // A list of the relevant problems/conditions for a patient.
    property problemList : TFhirReferenceList read GetProblemList;
    property hasProblemList : boolean read GetHasProblemList;

    // One or more sets of investigations (signs, symptoms, etc.). The actual grouping of investigations varies greatly depending on the type and context of the assessment. These investigations may include data generated during the assessment process, or data previously generated and recorded that is pertinent to the outcomes.
    property investigationList : TFhirClinicalImpressionInvestigationList read GetInvestigationList;
    property hasInvestigationList : boolean read GetHasInvestigationList;

    // Reference to a specific published clinical protocol that was followed during this assessment, and/or that provides evidence in support of the diagnosis.
    property protocolList : TFhirUriList read GetProtocolList;
    property hasProtocolList : boolean read GetHasProtocolList;

    // Typed access to A text summary of the investigations and the diagnosis.
    property summary : String read GetSummaryST write SetSummaryST;
    // A text summary of the investigations and the diagnosis.
    property summaryElement : TFhirString read FSummary write SetSummary;

    // Specific findings or diagnoses that were considered likely or relevant to ongoing treatment.
    property findingList : TFhirClinicalImpressionFindingList read GetFindingList;
    property hasFindingList : boolean read GetHasFindingList;

    // Estimate of likely outcome.
    property prognosisCodeableConceptList : TFhirCodeableConceptList read GetPrognosisCodeableConceptList;
    property hasPrognosisCodeableConceptList : boolean read GetHasPrognosisCodeableConceptList;

    // RiskAssessment expressing likely outcome.
    property prognosisReferenceList : TFhirReferenceList read GetPrognosisReferenceList;
    property hasPrognosisReferenceList : boolean read GetHasPrognosisReferenceList;

    // Information supporting the clinical impression.
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Commentary about the impression, typically recorded after the impression itself was made, though supplemental notes by the original author could also appear.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirClinicalImpressionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalImpressionList;
    function GetCurrent : TFhirClinicalImpression;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalImpressionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalImpression read GetCurrent;
  end;

  TFhirClinicalImpressionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalImpression;
    procedure SetItemN(index : Integer; value : TFhirClinicalImpression);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalImpressionList; overload;
    function Clone : TFhirClinicalImpressionList; overload;
    function GetEnumerator : TFhirClinicalImpressionListEnumerator;
    
    //  Add a FhirClinicalImpression to the end of the list.
    function Append : TFhirClinicalImpression;
    
    // Add an already existing FhirClinicalImpression to the end of the list.
    function AddItem(value : TFhirClinicalImpression) : TFhirClinicalImpression; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalImpression) : Integer;
    
    // Insert FhirClinicalImpression before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalImpression;
    
    // Insert an existing FhirClinicalImpression before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalImpression);
    
    // Get the iIndexth FhirClinicalImpression. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalImpression);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalImpression;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalImpressions[index : Integer] : TFhirClinicalImpression read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
  // Specifics for when this is a contraindication.
  TFhirClinicalUseDefinitionContraindication = class (TFhirBackboneElement)
  protected
    FDiseaseSymptomProcedure : TFhirCodeableReference;
    FDiseaseStatus : TFhirCodeableReference;
    FcomorbidityList : TFhirCodeableReferenceList;
    FindicationList : TFhirReferenceList;
    FotherTherapyList : TFhirClinicalUseDefinitionContraindicationOtherTherapyList;
    procedure SetDiseaseSymptomProcedure(value : TFhirCodeableReference);
    procedure SetDiseaseStatus(value : TFhirCodeableReference);
    function GetComorbidityList : TFhirCodeableReferenceList;
    function GetHasComorbidityList : Boolean;
    function GetIndicationList : TFhirReferenceList;
    function GetHasIndicationList : Boolean;
    function GetOtherTherapyList : TFhirClinicalUseDefinitionContraindicationOtherTherapyList;
    function GetHasOtherTherapyList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseDefinitionContraindication; overload;
    function Clone : TFhirClinicalUseDefinitionContraindication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The situation that is being documented as contraindicating against this item. (defined for API consistency)
    property diseaseSymptomProcedure : TFhirCodeableReference read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;
    // The situation that is being documented as contraindicating against this item.
    property diseaseSymptomProcedureElement : TFhirCodeableReference read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;

    // Typed access to The status of the disease or symptom for the contraindication. (defined for API consistency)
    property diseaseStatus : TFhirCodeableReference read FDiseaseStatus write SetDiseaseStatus;
    // The status of the disease or symptom for the contraindication.
    property diseaseStatusElement : TFhirCodeableReference read FDiseaseStatus write SetDiseaseStatus;

    // A comorbidity (concurrent condition) or coinfection.
    property comorbidityList : TFhirCodeableReferenceList read GetComorbidityList;
    property hasComorbidityList : boolean read GetHasComorbidityList;

    // The indication which this is a contraidication for.
    property indicationList : TFhirReferenceList read GetIndicationList;
    property hasIndicationList : boolean read GetHasIndicationList;

    // Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
    property otherTherapyList : TFhirClinicalUseDefinitionContraindicationOtherTherapyList read GetOtherTherapyList;
    property hasOtherTherapyList : boolean read GetHasOtherTherapyList;

  end;

  TFhirClinicalUseDefinitionContraindicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseDefinitionContraindicationList;
    function GetCurrent : TFhirClinicalUseDefinitionContraindication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseDefinitionContraindicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseDefinitionContraindication read GetCurrent;
  end;

  TFhirClinicalUseDefinitionContraindicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseDefinitionContraindication;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseDefinitionContraindication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseDefinitionContraindicationList; overload;
    function Clone : TFhirClinicalUseDefinitionContraindicationList; overload;
    function GetEnumerator : TFhirClinicalUseDefinitionContraindicationListEnumerator;
    
    //  Add a FhirClinicalUseDefinitionContraindication to the end of the list.
    function Append : TFhirClinicalUseDefinitionContraindication;
    
    // Add an already existing FhirClinicalUseDefinitionContraindication to the end of the list.
    function AddItem(value : TFhirClinicalUseDefinitionContraindication) : TFhirClinicalUseDefinitionContraindication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseDefinitionContraindication) : Integer;
    
    // Insert FhirClinicalUseDefinitionContraindication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseDefinitionContraindication;
    
    // Insert an existing FhirClinicalUseDefinitionContraindication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseDefinitionContraindication);
    
    // Get the iIndexth FhirClinicalUseDefinitionContraindication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseDefinitionContraindication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseDefinitionContraindication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseDefinitionContraindications[index : Integer] : TFhirClinicalUseDefinitionContraindication read GetItemN write SetItemN; default;
  End;

  // Information about the use of the medicinal product in relation to other therapies described as part of the contraindication.
  TFhirClinicalUseDefinitionContraindicationOtherTherapy = class (TFhirBackboneElement)
  protected
    FRelationshipType : TFhirCodeableConcept;
    FTherapy : TFhirCodeableReference;
    procedure SetRelationshipType(value : TFhirCodeableConcept);
    procedure SetTherapy(value : TFhirCodeableReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseDefinitionContraindicationOtherTherapy; overload;
    function Clone : TFhirClinicalUseDefinitionContraindicationOtherTherapy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of relationship between the medicinal product indication or contraindication and another therapy. (defined for API consistency)
    property relationshipType : TFhirCodeableConcept read FRelationshipType write SetRelationshipType;
    // The type of relationship between the medicinal product indication or contraindication and another therapy.
    property relationshipTypeElement : TFhirCodeableConcept read FRelationshipType write SetRelationshipType;

    // Typed access to Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication. (defined for API consistency)
    property therapy : TFhirCodeableReference read FTherapy write SetTherapy;
    // Reference to a specific medication (active substance, medicinal product or class of products) as part of an indication or contraindication.
    property therapyElement : TFhirCodeableReference read FTherapy write SetTherapy;

  end;

  TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseDefinitionContraindicationOtherTherapyList;
    function GetCurrent : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseDefinitionContraindicationOtherTherapyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseDefinitionContraindicationOtherTherapy read GetCurrent;
  end;

  TFhirClinicalUseDefinitionContraindicationOtherTherapyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseDefinitionContraindicationOtherTherapyList; overload;
    function Clone : TFhirClinicalUseDefinitionContraindicationOtherTherapyList; overload;
    function GetEnumerator : TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator;
    
    //  Add a FhirClinicalUseDefinitionContraindicationOtherTherapy to the end of the list.
    function Append : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
    
    // Add an already existing FhirClinicalUseDefinitionContraindicationOtherTherapy to the end of the list.
    function AddItem(value : TFhirClinicalUseDefinitionContraindicationOtherTherapy) : TFhirClinicalUseDefinitionContraindicationOtherTherapy; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseDefinitionContraindicationOtherTherapy) : Integer;
    
    // Insert FhirClinicalUseDefinitionContraindicationOtherTherapy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
    
    // Insert an existing FhirClinicalUseDefinitionContraindicationOtherTherapy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy);
    
    // Get the iIndexth FhirClinicalUseDefinitionContraindicationOtherTherapy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseDefinitionContraindicationOtherTherapy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseDefinitionContraindicationOtherTherapies[index : Integer] : TFhirClinicalUseDefinitionContraindicationOtherTherapy read GetItemN write SetItemN; default;
  End;

  // Specifics for when this is an indication.
  TFhirClinicalUseDefinitionIndication = class (TFhirBackboneElement)
  protected
    FDiseaseSymptomProcedure : TFhirCodeableReference;
    FDiseaseStatus : TFhirCodeableReference;
    FcomorbidityList : TFhirCodeableReferenceList;
    FIntendedEffect : TFhirCodeableReference;
    FDuration : TFhirQuantity;
    FundesirableEffectList : TFhirReferenceList;
    FotherTherapyList : TFhirClinicalUseDefinitionContraindicationOtherTherapyList;
    procedure SetDiseaseSymptomProcedure(value : TFhirCodeableReference);
    procedure SetDiseaseStatus(value : TFhirCodeableReference);
    function GetComorbidityList : TFhirCodeableReferenceList;
    function GetHasComorbidityList : Boolean;
    procedure SetIntendedEffect(value : TFhirCodeableReference);
    procedure SetDuration(value : TFhirQuantity);
    function GetUndesirableEffectList : TFhirReferenceList;
    function GetHasUndesirableEffectList : Boolean;
    function GetOtherTherapyList : TFhirClinicalUseDefinitionContraindicationOtherTherapyList;
    function GetHasOtherTherapyList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseDefinitionIndication; overload;
    function Clone : TFhirClinicalUseDefinitionIndication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The situation that is being documented as an indicaton for this item. (defined for API consistency)
    property diseaseSymptomProcedure : TFhirCodeableReference read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;
    // The situation that is being documented as an indicaton for this item.
    property diseaseSymptomProcedureElement : TFhirCodeableReference read FDiseaseSymptomProcedure write SetDiseaseSymptomProcedure;

    // Typed access to The status of the disease or symptom for the indication. (defined for API consistency)
    property diseaseStatus : TFhirCodeableReference read FDiseaseStatus write SetDiseaseStatus;
    // The status of the disease or symptom for the indication.
    property diseaseStatusElement : TFhirCodeableReference read FDiseaseStatus write SetDiseaseStatus;

    // A comorbidity (concurrent condition) or coinfection as part of the indication.
    property comorbidityList : TFhirCodeableReferenceList read GetComorbidityList;
    property hasComorbidityList : boolean read GetHasComorbidityList;

    // Typed access to The intended effect, aim or strategy to be achieved. (defined for API consistency)
    property intendedEffect : TFhirCodeableReference read FIntendedEffect write SetIntendedEffect;
    // The intended effect, aim or strategy to be achieved.
    property intendedEffectElement : TFhirCodeableReference read FIntendedEffect write SetIntendedEffect;

    // Typed access to Timing or duration information. (defined for API consistency)
    property duration : TFhirQuantity read FDuration write SetDuration;
    // Timing or duration information.
    property durationElement : TFhirQuantity read FDuration write SetDuration;

    // The specific undesirable effects of the medicinal product.
    property undesirableEffectList : TFhirReferenceList read GetUndesirableEffectList;
    property hasUndesirableEffectList : boolean read GetHasUndesirableEffectList;

    // Information about the use of the medicinal product in relation to other therapies described as part of the indication.
    property otherTherapyList : TFhirClinicalUseDefinitionContraindicationOtherTherapyList read GetOtherTherapyList;
    property hasOtherTherapyList : boolean read GetHasOtherTherapyList;

  end;

  TFhirClinicalUseDefinitionIndicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseDefinitionIndicationList;
    function GetCurrent : TFhirClinicalUseDefinitionIndication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseDefinitionIndicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseDefinitionIndication read GetCurrent;
  end;

  TFhirClinicalUseDefinitionIndicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseDefinitionIndication;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseDefinitionIndication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseDefinitionIndicationList; overload;
    function Clone : TFhirClinicalUseDefinitionIndicationList; overload;
    function GetEnumerator : TFhirClinicalUseDefinitionIndicationListEnumerator;
    
    //  Add a FhirClinicalUseDefinitionIndication to the end of the list.
    function Append : TFhirClinicalUseDefinitionIndication;
    
    // Add an already existing FhirClinicalUseDefinitionIndication to the end of the list.
    function AddItem(value : TFhirClinicalUseDefinitionIndication) : TFhirClinicalUseDefinitionIndication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseDefinitionIndication) : Integer;
    
    // Insert FhirClinicalUseDefinitionIndication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseDefinitionIndication;
    
    // Insert an existing FhirClinicalUseDefinitionIndication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseDefinitionIndication);
    
    // Get the iIndexth FhirClinicalUseDefinitionIndication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseDefinitionIndication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseDefinitionIndication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseDefinitionIndications[index : Integer] : TFhirClinicalUseDefinitionIndication read GetItemN write SetItemN; default;
  End;

  // Specifics for when this is an interaction.
  TFhirClinicalUseDefinitionInteraction = class (TFhirBackboneElement)
  protected
    FinteractantList : TFhirClinicalUseDefinitionInteractionInteractantList;
    FType_ : TFhirCodeableConcept;
    FEffect : TFhirCodeableReference;
    FIncidence : TFhirCodeableConcept;
    FmanagementList : TFhirCodeableConceptList;
    function GetInteractantList : TFhirClinicalUseDefinitionInteractionInteractantList;
    function GetHasInteractantList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetEffect(value : TFhirCodeableReference);
    procedure SetIncidence(value : TFhirCodeableConcept);
    function GetManagementList : TFhirCodeableConceptList;
    function GetHasManagementList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseDefinitionInteraction; overload;
    function Clone : TFhirClinicalUseDefinitionInteraction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The specific medication, food, substance or laboratory test that interacts.
    property interactantList : TFhirClinicalUseDefinitionInteractionInteractantList read GetInteractantList;
    property hasInteractantList : boolean read GetHasInteractantList;

    // Typed access to The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the interaction e.g. drug-drug interaction, drug-food interaction, drug-lab test interaction.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The effect of the interaction, for example "reduced gastric absorption of primary medication". (defined for API consistency)
    property effect : TFhirCodeableReference read FEffect write SetEffect;
    // The effect of the interaction, for example "reduced gastric absorption of primary medication".
    property effectElement : TFhirCodeableReference read FEffect write SetEffect;

    // Typed access to The incidence of the interaction, e.g. theoretical, observed. (defined for API consistency)
    property incidence : TFhirCodeableConcept read FIncidence write SetIncidence;
    // The incidence of the interaction, e.g. theoretical, observed.
    property incidenceElement : TFhirCodeableConcept read FIncidence write SetIncidence;

    // Actions for managing the interaction.
    property managementList : TFhirCodeableConceptList read GetManagementList;
    property hasManagementList : boolean read GetHasManagementList;

  end;

  TFhirClinicalUseDefinitionInteractionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseDefinitionInteractionList;
    function GetCurrent : TFhirClinicalUseDefinitionInteraction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseDefinitionInteractionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseDefinitionInteraction read GetCurrent;
  end;

  TFhirClinicalUseDefinitionInteractionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseDefinitionInteraction;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseDefinitionInteraction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseDefinitionInteractionList; overload;
    function Clone : TFhirClinicalUseDefinitionInteractionList; overload;
    function GetEnumerator : TFhirClinicalUseDefinitionInteractionListEnumerator;
    
    //  Add a FhirClinicalUseDefinitionInteraction to the end of the list.
    function Append : TFhirClinicalUseDefinitionInteraction;
    
    // Add an already existing FhirClinicalUseDefinitionInteraction to the end of the list.
    function AddItem(value : TFhirClinicalUseDefinitionInteraction) : TFhirClinicalUseDefinitionInteraction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseDefinitionInteraction) : Integer;
    
    // Insert FhirClinicalUseDefinitionInteraction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseDefinitionInteraction;
    
    // Insert an existing FhirClinicalUseDefinitionInteraction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseDefinitionInteraction);
    
    // Get the iIndexth FhirClinicalUseDefinitionInteraction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseDefinitionInteraction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseDefinitionInteraction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseDefinitionInteractions[index : Integer] : TFhirClinicalUseDefinitionInteraction read GetItemN write SetItemN; default;
  End;

  // The specific medication, food, substance or laboratory test that interacts.
  TFhirClinicalUseDefinitionInteractionInteractant = class (TFhirBackboneElement)
  protected
    FItem : TFhirDataType;
    procedure SetItem(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseDefinitionInteractionInteractant; overload;
    function Clone : TFhirClinicalUseDefinitionInteractionInteractant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The specific medication, food or laboratory test that interacts. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // The specific medication, food or laboratory test that interacts.
    property itemElement : TFhirDataType read FItem write SetItem;

  end;

  TFhirClinicalUseDefinitionInteractionInteractantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseDefinitionInteractionInteractantList;
    function GetCurrent : TFhirClinicalUseDefinitionInteractionInteractant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseDefinitionInteractionInteractantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseDefinitionInteractionInteractant read GetCurrent;
  end;

  TFhirClinicalUseDefinitionInteractionInteractantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseDefinitionInteractionInteractant;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseDefinitionInteractionInteractant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseDefinitionInteractionInteractantList; overload;
    function Clone : TFhirClinicalUseDefinitionInteractionInteractantList; overload;
    function GetEnumerator : TFhirClinicalUseDefinitionInteractionInteractantListEnumerator;
    
    //  Add a FhirClinicalUseDefinitionInteractionInteractant to the end of the list.
    function Append : TFhirClinicalUseDefinitionInteractionInteractant;
    
    // Add an already existing FhirClinicalUseDefinitionInteractionInteractant to the end of the list.
    function AddItem(value : TFhirClinicalUseDefinitionInteractionInteractant) : TFhirClinicalUseDefinitionInteractionInteractant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseDefinitionInteractionInteractant) : Integer;
    
    // Insert FhirClinicalUseDefinitionInteractionInteractant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseDefinitionInteractionInteractant;
    
    // Insert an existing FhirClinicalUseDefinitionInteractionInteractant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseDefinitionInteractionInteractant);
    
    // Get the iIndexth FhirClinicalUseDefinitionInteractionInteractant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseDefinitionInteractionInteractant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseDefinitionInteractionInteractant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseDefinitionInteractionInteractants[index : Integer] : TFhirClinicalUseDefinitionInteractionInteractant read GetItemN write SetItemN; default;
  End;

  // Describe the undesirable effects of the medicinal product.
  TFhirClinicalUseDefinitionUndesirableEffect = class (TFhirBackboneElement)
  protected
    FSymptomConditionEffect : TFhirCodeableReference;
    FClassification : TFhirCodeableConcept;
    FFrequencyOfOccurrence : TFhirCodeableConcept;
    procedure SetSymptomConditionEffect(value : TFhirCodeableReference);
    procedure SetClassification(value : TFhirCodeableConcept);
    procedure SetFrequencyOfOccurrence(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseDefinitionUndesirableEffect; overload;
    function Clone : TFhirClinicalUseDefinitionUndesirableEffect; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The situation in which the undesirable effect may manifest. (defined for API consistency)
    property symptomConditionEffect : TFhirCodeableReference read FSymptomConditionEffect write SetSymptomConditionEffect;
    // The situation in which the undesirable effect may manifest.
    property symptomConditionEffectElement : TFhirCodeableReference read FSymptomConditionEffect write SetSymptomConditionEffect;

    // Typed access to High level classification of the effect. (defined for API consistency)
    property classification : TFhirCodeableConcept read FClassification write SetClassification;
    // High level classification of the effect.
    property classificationElement : TFhirCodeableConcept read FClassification write SetClassification;

    // Typed access to How often the effect is seen. (defined for API consistency)
    property frequencyOfOccurrence : TFhirCodeableConcept read FFrequencyOfOccurrence write SetFrequencyOfOccurrence;
    // How often the effect is seen.
    property frequencyOfOccurrenceElement : TFhirCodeableConcept read FFrequencyOfOccurrence write SetFrequencyOfOccurrence;

  end;

  TFhirClinicalUseDefinitionUndesirableEffectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseDefinitionUndesirableEffectList;
    function GetCurrent : TFhirClinicalUseDefinitionUndesirableEffect;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseDefinitionUndesirableEffectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseDefinitionUndesirableEffect read GetCurrent;
  end;

  TFhirClinicalUseDefinitionUndesirableEffectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseDefinitionUndesirableEffect;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseDefinitionUndesirableEffect);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseDefinitionUndesirableEffectList; overload;
    function Clone : TFhirClinicalUseDefinitionUndesirableEffectList; overload;
    function GetEnumerator : TFhirClinicalUseDefinitionUndesirableEffectListEnumerator;
    
    //  Add a FhirClinicalUseDefinitionUndesirableEffect to the end of the list.
    function Append : TFhirClinicalUseDefinitionUndesirableEffect;
    
    // Add an already existing FhirClinicalUseDefinitionUndesirableEffect to the end of the list.
    function AddItem(value : TFhirClinicalUseDefinitionUndesirableEffect) : TFhirClinicalUseDefinitionUndesirableEffect; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseDefinitionUndesirableEffect) : Integer;
    
    // Insert FhirClinicalUseDefinitionUndesirableEffect before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseDefinitionUndesirableEffect;
    
    // Insert an existing FhirClinicalUseDefinitionUndesirableEffect before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseDefinitionUndesirableEffect);
    
    // Get the iIndexth FhirClinicalUseDefinitionUndesirableEffect. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseDefinitionUndesirableEffect);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseDefinitionUndesirableEffect;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseDefinitionUndesirableEffects[index : Integer] : TFhirClinicalUseDefinitionUndesirableEffect read GetItemN write SetItemN; default;
  End;

  // A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.
  TFhirClinicalUseDefinitionWarning = class (TFhirBackboneElement)
  protected
    FDescription : TFhirMarkdown;
    FCode : TFhirCodeableConcept;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseDefinitionWarning; overload;
    function Clone : TFhirClinicalUseDefinitionWarning; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A textual definition of this warning, with formatting.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A textual definition of this warning, with formatting.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to A coded or unformatted textual definition of this warning. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A coded or unformatted textual definition of this warning.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

  end;

  TFhirClinicalUseDefinitionWarningListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseDefinitionWarningList;
    function GetCurrent : TFhirClinicalUseDefinitionWarning;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseDefinitionWarningList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseDefinitionWarning read GetCurrent;
  end;

  TFhirClinicalUseDefinitionWarningList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseDefinitionWarning;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseDefinitionWarning);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseDefinitionWarningList; overload;
    function Clone : TFhirClinicalUseDefinitionWarningList; overload;
    function GetEnumerator : TFhirClinicalUseDefinitionWarningListEnumerator;
    
    //  Add a FhirClinicalUseDefinitionWarning to the end of the list.
    function Append : TFhirClinicalUseDefinitionWarning;
    
    // Add an already existing FhirClinicalUseDefinitionWarning to the end of the list.
    function AddItem(value : TFhirClinicalUseDefinitionWarning) : TFhirClinicalUseDefinitionWarning; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseDefinitionWarning) : Integer;
    
    // Insert FhirClinicalUseDefinitionWarning before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseDefinitionWarning;
    
    // Insert an existing FhirClinicalUseDefinitionWarning before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseDefinitionWarning);
    
    // Get the iIndexth FhirClinicalUseDefinitionWarning. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseDefinitionWarning);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseDefinitionWarning;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseDefinitionWarnings[index : Integer] : TFhirClinicalUseDefinitionWarning read GetItemN write SetItemN; default;
  End;

  // A single issue - either an indication, contraindication, interaction or an undesirable effect for a medicinal product, medication, device or procedure.
  TFhirClinicalUseDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FsubjectList : TFhirReferenceList;
    FStatus : TFhirCodeableConcept;
    FContraindication : TFhirClinicalUseDefinitionContraindication;
    FIndication : TFhirClinicalUseDefinitionIndication;
    FInteraction : TFhirClinicalUseDefinitionInteraction;
    FpopulationList : TFhirReferenceList;
    FUndesirableEffect : TFhirClinicalUseDefinitionUndesirableEffect;
    FWarning : TFhirClinicalUseDefinitionWarning;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirClinicalUseIssueTypeEnum;
    procedure SetType_ST(value : TFhirClinicalUseIssueTypeEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetContraindication(value : TFhirClinicalUseDefinitionContraindication);
    procedure SetIndication(value : TFhirClinicalUseDefinitionIndication);
    procedure SetInteraction(value : TFhirClinicalUseDefinitionInteraction);
    function GetPopulationList : TFhirReferenceList;
    function GetHasPopulationList : Boolean;
    procedure SetUndesirableEffect(value : TFhirClinicalUseDefinitionUndesirableEffect);
    procedure SetWarning(value : TFhirClinicalUseDefinitionWarning);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirClinicalUseDefinition; overload;
    function Clone : TFhirClinicalUseDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier for this issue.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // indication | contraindication | interaction | undesirable-effect | warning.
    property type_ : TFhirClinicalUseIssueTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // A categorisation of the issue, primarily for dividing warnings into subject heading areas such as "Pregnancy and Lactation", "Overdose", "Effects on Ability to Drive and Use Machines".
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The medication or procedure for which this is an indication.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to Whether this is a current issue or one that has been retired etc. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Whether this is a current issue or one that has been retired etc.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Specifics for when this is a contraindication. (defined for API consistency)
    property contraindication : TFhirClinicalUseDefinitionContraindication read FContraindication write SetContraindication;
    // Specifics for when this is a contraindication.
    property contraindicationElement : TFhirClinicalUseDefinitionContraindication read FContraindication write SetContraindication;

    // Typed access to Specifics for when this is an indication. (defined for API consistency)
    property indication : TFhirClinicalUseDefinitionIndication read FIndication write SetIndication;
    // Specifics for when this is an indication.
    property indicationElement : TFhirClinicalUseDefinitionIndication read FIndication write SetIndication;

    // Typed access to Specifics for when this is an interaction. (defined for API consistency)
    property interaction : TFhirClinicalUseDefinitionInteraction read FInteraction write SetInteraction;
    // Specifics for when this is an interaction.
    property interactionElement : TFhirClinicalUseDefinitionInteraction read FInteraction write SetInteraction;

    // The population group to which this applies.
    property populationList : TFhirReferenceList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to Describe the undesirable effects of the medicinal product. (defined for API consistency)
    property undesirableEffect : TFhirClinicalUseDefinitionUndesirableEffect read FUndesirableEffect write SetUndesirableEffect;
    // Describe the undesirable effects of the medicinal product.
    property undesirableEffectElement : TFhirClinicalUseDefinitionUndesirableEffect read FUndesirableEffect write SetUndesirableEffect;

    // Typed access to A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'. (defined for API consistency)
    property warning : TFhirClinicalUseDefinitionWarning read FWarning write SetWarning;
    // A critical piece of information about environmental, health or physical risks or hazards that serve as caution to the user. For example 'Do not operate heavy machinery', 'May cause drowsiness', or 'Get medical advice/attention if you feel unwell'.
    property warningElement : TFhirClinicalUseDefinitionWarning read FWarning write SetWarning;

  end;

  TFhirClinicalUseDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirClinicalUseDefinitionList;
    function GetCurrent : TFhirClinicalUseDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirClinicalUseDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirClinicalUseDefinition read GetCurrent;
  end;

  TFhirClinicalUseDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirClinicalUseDefinition;
    procedure SetItemN(index : Integer; value : TFhirClinicalUseDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirClinicalUseDefinitionList; overload;
    function Clone : TFhirClinicalUseDefinitionList; overload;
    function GetEnumerator : TFhirClinicalUseDefinitionListEnumerator;
    
    //  Add a FhirClinicalUseDefinition to the end of the list.
    function Append : TFhirClinicalUseDefinition;
    
    // Add an already existing FhirClinicalUseDefinition to the end of the list.
    function AddItem(value : TFhirClinicalUseDefinition) : TFhirClinicalUseDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirClinicalUseDefinition) : Integer;
    
    // Insert FhirClinicalUseDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirClinicalUseDefinition;
    
    // Insert an existing FhirClinicalUseDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirClinicalUseDefinition);
    
    // Get the iIndexth FhirClinicalUseDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirClinicalUseDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirClinicalUseDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirClinicalUseDefinitions[index : Integer] : TFhirClinicalUseDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_COMMUNICATION}
  // Text, attachment(s), or resource(s) that was communicated to the recipient.
  TFhirCommunicationPayload = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationPayload; overload;
    function Clone : TFhirCommunicationPayload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A communicated content (or for multi-part communications, one portion of the communication). (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // A communicated content (or for multi-part communications, one portion of the communication).
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirCommunicationPayloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationPayloadList;
    function GetCurrent : TFhirCommunicationPayload;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationPayloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationPayload read GetCurrent;
  end;

  TFhirCommunicationPayloadList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCommunicationPayload;
    procedure SetItemN(index : Integer; value : TFhirCommunicationPayload);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCommunicationPayloadList; overload;
    function Clone : TFhirCommunicationPayloadList; overload;
    function GetEnumerator : TFhirCommunicationPayloadListEnumerator;
    
    //  Add a FhirCommunicationPayload to the end of the list.
    function Append : TFhirCommunicationPayload;
    
    // Add an already existing FhirCommunicationPayload to the end of the list.
    function AddItem(value : TFhirCommunicationPayload) : TFhirCommunicationPayload; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationPayload) : Integer;
    
    // Insert FhirCommunicationPayload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationPayload;
    
    // Insert an existing FhirCommunicationPayload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationPayload);
    
    // Get the iIndexth FhirCommunicationPayload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationPayload);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationPayload;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCommunicationPayloads[index : Integer] : TFhirCommunicationPayload read GetItemN write SetItemN; default;
  End;

  // An occurrence of information being transmitted; e.g. an alert that was sent to a responsible provider, a public health agency that was notified about a reportable condition.
  TFhirCommunication = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FinResponseToList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirEnum;
    FmediumList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FTopic : TFhirCodeableConcept;
    FaboutList : TFhirReferenceList;
    FEncounter : TFhirReference;
    FSent : TFhirDateTime;
    FReceived : TFhirDateTime;
    FrecipientList : TFhirReferenceList;
    FSender : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FpayloadList : TFhirCommunicationPayloadList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    function GetInResponseToList : TFhirReferenceList;
    function GetHasInResponseToList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEventStatusEnum;
    procedure SetStatusST(value : TFhirEventStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    function GetMediumList : TFhirCodeableConceptList;
    function GetHasMediumList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetTopic(value : TFhirCodeableConcept);
    function GetAboutList : TFhirReferenceList;
    function GetHasAboutList : Boolean;
    procedure SetEncounter(value : TFhirReference);
    procedure SetSent(value : TFhirDateTime);
    function GetSentST : TFslDateTime;
    procedure SetSentST(value : TFslDateTime);
    procedure SetReceived(value : TFhirDateTime);
    function GetReceivedST : TFslDateTime;
    procedure SetReceivedST(value : TFslDateTime);
    function GetRecipientList : TFhirReferenceList;
    function GetHasRecipientList : Boolean;
    procedure SetSender(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetPayloadList : TFhirCommunicationPayloadList;
    function GetHasPayloadList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunication; overload;
    function Clone : TFhirCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this communication by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Communication.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Communication.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // An order, proposal or plan fulfilled in whole or in part by this Communication.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Part of this action.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Prior communication that this communication is in response to.
    property inResponseToList : TFhirReferenceList read GetInResponseToList;
    property hasInResponseToList : boolean read GetHasInResponseToList;

    // The status of the transmission.
    property status : TFhirEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the Communication. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the Communication.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // The type of message conveyed such as alert, notification, reminder, instruction, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Characterizes how quickly the planned or in progress communication must be addressed. Includes concepts such as stat, urgent, routine.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // A channel that was used for this communication (e.g. email, fax).
    property mediumList : TFhirCodeableConceptList read GetMediumList;
    property hasMediumList : boolean read GetHasMediumList;

    // Typed access to The patient or group that was the focus of this communication. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group that was the focus of this communication.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Description of the purpose/content, similar to a subject line in an email. (defined for API consistency)
    property topic : TFhirCodeableConcept read FTopic write SetTopic;
    // Description of the purpose/content, similar to a subject line in an email.
    property topicElement : TFhirCodeableConcept read FTopic write SetTopic;

    // Other resources that pertain to this communication and to which this communication should be associated.
    property aboutList : TFhirReferenceList read GetAboutList;
    property hasAboutList : boolean read GetHasAboutList;

    // Typed access to The Encounter during which this Communication was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this Communication was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The time when this communication was sent.
    property sent : TFslDateTime read GetSentST write SetSentST;
    // The time when this communication was sent.
    property sentElement : TFhirDateTime read FSent write SetSent;

    // Typed access to The time when this communication arrived at the destination.
    property received : TFslDateTime read GetReceivedST write SetReceivedST;
    // The time when this communication arrived at the destination.
    property receivedElement : TFhirDateTime read FReceived write SetReceived;

    // The entity (e.g. person, organization, clinical information system, care team or device) which was the target of the communication. If receipts need to be tracked by an individual, a separate resource instance will need to be created for each recipient.  Multiple recipient communications are intended where either receipts are not tracked (e.g. a mass mail-out) or a receipt is captured in aggregate (all emails confirmed received by a particular time).
    property recipientList : TFhirReferenceList read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Typed access to The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication. (defined for API consistency)
    property sender : TFhirReference read FSender write SetSender;
    // The entity (e.g. person, organization, clinical information system, or device) which was the source of the communication.
    property senderElement : TFhirReference read FSender write SetSender;

    // The reason or justification for the communication.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies this communication.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Text, attachment(s), or resource(s) that was communicated to the recipient.
    property payloadList : TFhirCommunicationPayloadList read GetPayloadList;
    property hasPayloadList : boolean read GetHasPayloadList;

    // Additional notes or commentary about the communication by the sender, receiver or other interested parties.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationList;
    function GetCurrent : TFhirCommunication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunication read GetCurrent;
  end;

  TFhirCommunicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCommunication;
    procedure SetItemN(index : Integer; value : TFhirCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCommunicationList; overload;
    function Clone : TFhirCommunicationList; overload;
    function GetEnumerator : TFhirCommunicationListEnumerator;
    
    //  Add a FhirCommunication to the end of the list.
    function Append : TFhirCommunication;
    
    // Add an already existing FhirCommunication to the end of the list.
    function AddItem(value : TFhirCommunication) : TFhirCommunication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunication) : Integer;
    
    // Insert FhirCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunication;
    
    // Insert an existing FhirCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunication);
    
    // Get the iIndexth FhirCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCommunications[index : Integer] : TFhirCommunication read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
  // Text, attachment(s), or resource(s) to be communicated to the recipient.
  TFhirCommunicationRequestPayload = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationRequestPayload; overload;
    function Clone : TFhirCommunicationRequestPayload; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The communicated content (or for multi-part communications, one portion of the communication). (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // The communicated content (or for multi-part communications, one portion of the communication).
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirCommunicationRequestPayloadListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationRequestPayloadList;
    function GetCurrent : TFhirCommunicationRequestPayload;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationRequestPayloadList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationRequestPayload read GetCurrent;
  end;

  TFhirCommunicationRequestPayloadList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCommunicationRequestPayload;
    procedure SetItemN(index : Integer; value : TFhirCommunicationRequestPayload);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCommunicationRequestPayloadList; overload;
    function Clone : TFhirCommunicationRequestPayloadList; overload;
    function GetEnumerator : TFhirCommunicationRequestPayloadListEnumerator;
    
    //  Add a FhirCommunicationRequestPayload to the end of the list.
    function Append : TFhirCommunicationRequestPayload;
    
    // Add an already existing FhirCommunicationRequestPayload to the end of the list.
    function AddItem(value : TFhirCommunicationRequestPayload) : TFhirCommunicationRequestPayload; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationRequestPayload) : Integer;
    
    // Insert FhirCommunicationRequestPayload before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationRequestPayload;
    
    // Insert an existing FhirCommunicationRequestPayload before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationRequestPayload);
    
    // Get the iIndexth FhirCommunicationRequestPayload. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationRequestPayload);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationRequestPayload;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCommunicationRequestPayloads[index : Integer] : TFhirCommunicationRequestPayload read GetItemN write SetItemN; default;
  End;

  // A request to convey information; e.g. the CDS system proposes that an alert be sent to a responsible provider, the CDS system proposes that the public health agency be notified about a reportable condition.
  TFhirCommunicationRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FreplacesList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FmediumList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FaboutList : TFhirReferenceList;
    FEncounter : TFhirReference;
    FpayloadList : TFhirCommunicationRequestPayloadList;
    FOccurrence : TFhirDataType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FrecipientList : TFhirReferenceList;
    FSender : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList;
    function GetHasReplacesList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    function GetMediumList : TFhirCodeableConceptList;
    function GetHasMediumList : Boolean;
    procedure SetSubject(value : TFhirReference);
    function GetAboutList : TFhirReferenceList;
    function GetHasAboutList : Boolean;
    procedure SetEncounter(value : TFhirReference);
    function GetPayloadList : TFhirCommunicationRequestPayloadList;
    function GetHasPayloadList : Boolean;
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    function GetRecipientList : TFhirReferenceList;
    function GetHasRecipientList : Boolean;
    procedure SetSender(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCommunicationRequest; overload;
    function Clone : TFhirCommunicationRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this communication request by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan or proposal that is fulfilled in whole or in part by this request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated request(s) whose function is taken by this new request.
    property replacesList : TFhirReferenceList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The status of the proposal or order.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the CommunicationRequest. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the CommunicationRequest.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // The type of message to be sent such as alert, notification, reminder, instruction, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Characterizes how quickly the proposed act must be initiated. Includes concepts such as stat, urgent, routine.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to If true indicates that the CommunicationRequest is asking for the specified action to *not* occur.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // If true indicates that the CommunicationRequest is asking for the specified action to *not* occur.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // A channel that was used for this communication (e.g. email, fax).
    property mediumList : TFhirCodeableConceptList read GetMediumList;
    property hasMediumList : boolean read GetHasMediumList;

    // Typed access to The patient or group that is the focus of this communication request. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group that is the focus of this communication request.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Other resources that pertain to this communication request and to which this communication request should be associated.
    property aboutList : TFhirReferenceList read GetAboutList;
    property hasAboutList : boolean read GetHasAboutList;

    // Typed access to The Encounter during which this CommunicationRequest was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this CommunicationRequest was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Text, attachment(s), or resource(s) to be communicated to the recipient.
    property payloadList : TFhirCommunicationRequestPayloadList read GetPayloadList;
    property hasPayloadList : boolean read GetHasPayloadList;

    // Typed access to The time when this communication is to occur. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The time when this communication is to occur.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to For draft requests, indicates the date of initial creation.  For requests with other statuses, indicates the date of activation.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // For draft requests, indicates the date of initial creation.  For requests with other statuses, indicates the date of activation.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The device, individual, or organization who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The device, individual, or organization who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // The entity (e.g. person, organization, clinical information system, device, group, or care team) which is the intended target of the communication.
    property recipientList : TFhirReferenceList read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Typed access to The entity (e.g. person, organization, clinical information system, or device) which is to be the source of the communication. (defined for API consistency)
    property sender : TFhirReference read FSender write SetSender;
    // The entity (e.g. person, organization, clinical information system, or device) which is to be the source of the communication.
    property senderElement : TFhirReference read FSender write SetSender;

    // Describes why the request is being made in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies this request.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Comments made about the request by the requester, sender, recipient, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirCommunicationRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCommunicationRequestList;
    function GetCurrent : TFhirCommunicationRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCommunicationRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCommunicationRequest read GetCurrent;
  end;

  TFhirCommunicationRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCommunicationRequest;
    procedure SetItemN(index : Integer; value : TFhirCommunicationRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCommunicationRequestList; overload;
    function Clone : TFhirCommunicationRequestList; overload;
    function GetEnumerator : TFhirCommunicationRequestListEnumerator;
    
    //  Add a FhirCommunicationRequest to the end of the list.
    function Append : TFhirCommunicationRequest;
    
    // Add an already existing FhirCommunicationRequest to the end of the list.
    function AddItem(value : TFhirCommunicationRequest) : TFhirCommunicationRequest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCommunicationRequest) : Integer;
    
    // Insert FhirCommunicationRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCommunicationRequest;
    
    // Insert an existing FhirCommunicationRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCommunicationRequest);
    
    // Get the iIndexth FhirCommunicationRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCommunicationRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCommunicationRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCommunicationRequests[index : Integer] : TFhirCommunicationRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
  // A participant who has attested to the accuracy of the composition/document.
  TFhirCompositionAttester = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FTime : TFhirDateTime;
    FParty : TFhirReference;
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirCompositionAttestationModeEnum;
    procedure SetModeST(value : TFhirCompositionAttestationModeEnum);
    procedure SetTime(value : TFhirDateTime);
    function GetTimeST : TFslDateTime;
    procedure SetTimeST(value : TFslDateTime);
    procedure SetParty(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionAttester; overload;
    function Clone : TFhirCompositionAttester; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of attestation the authenticator offers.
    property mode : TFhirCompositionAttestationModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to When the composition was attested by the party.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // When the composition was attested by the party.
    property timeElement : TFhirDateTime read FTime write SetTime;

    // Typed access to Who attested the composition in the specified way. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Who attested the composition in the specified way.
    property partyElement : TFhirReference read FParty write SetParty;

  end;

  TFhirCompositionAttesterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionAttesterList;
    function GetCurrent : TFhirCompositionAttester;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCompositionAttesterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionAttester read GetCurrent;
  end;

  TFhirCompositionAttesterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionAttester;
    procedure SetItemN(index : Integer; value : TFhirCompositionAttester);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionAttesterList; overload;
    function Clone : TFhirCompositionAttesterList; overload;
    function GetEnumerator : TFhirCompositionAttesterListEnumerator;
    
    //  Add a FhirCompositionAttester to the end of the list.
    function Append : TFhirCompositionAttester;
    
    // Add an already existing FhirCompositionAttester to the end of the list.
    function AddItem(value : TFhirCompositionAttester) : TFhirCompositionAttester; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionAttester) : Integer;
    
    // Insert FhirCompositionAttester before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionAttester;
    
    // Insert an existing FhirCompositionAttester before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionAttester);
    
    // Get the iIndexth FhirCompositionAttester. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionAttester);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionAttester;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositionAttesters[index : Integer] : TFhirCompositionAttester read GetItemN write SetItemN; default;
  End;

  // Relationships that this composition has with other compositions or documents that already exist.
  TFhirCompositionRelatesTo = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FTarget : TFhirDataType;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirDocumentRelationshipTypeEnum;
    procedure SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
    procedure SetTarget(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionRelatesTo; overload;
    function Clone : TFhirCompositionRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of relationship that this composition has with anther composition or document.
    property code : TFhirDocumentRelationshipTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to The target composition/document of this relationship. (defined for API consistency)
    property target : TFhirDataType read FTarget write SetTarget;
    // The target composition/document of this relationship.
    property targetElement : TFhirDataType read FTarget write SetTarget;

  end;

  TFhirCompositionRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionRelatesToList;
    function GetCurrent : TFhirCompositionRelatesTo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCompositionRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionRelatesTo read GetCurrent;
  end;

  TFhirCompositionRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirCompositionRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionRelatesToList; overload;
    function Clone : TFhirCompositionRelatesToList; overload;
    function GetEnumerator : TFhirCompositionRelatesToListEnumerator;
    
    //  Add a FhirCompositionRelatesTo to the end of the list.
    function Append : TFhirCompositionRelatesTo;
    
    // Add an already existing FhirCompositionRelatesTo to the end of the list.
    function AddItem(value : TFhirCompositionRelatesTo) : TFhirCompositionRelatesTo; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionRelatesTo) : Integer;
    
    // Insert FhirCompositionRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionRelatesTo;
    
    // Insert an existing FhirCompositionRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionRelatesTo);
    
    // Get the iIndexth FhirCompositionRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionRelatesTo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionRelatesTo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositionRelatesTos[index : Integer] : TFhirCompositionRelatesTo read GetItemN write SetItemN; default;
  End;

  // The clinical service, such as a colonoscopy or an appendectomy, being documented.
  TFhirCompositionEvent = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FdetailList : TFhirReferenceList;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    function GetDetailList : TFhirReferenceList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionEvent; overload;
    function Clone : TFhirCompositionEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the typeCode, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time covered by the documentation. There is no assertion that the documentation is a complete representation for this period, only that it documents events during this time.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The description and/or reference of the event(s) being documented. For example, this could be used to document such a colonoscopy or an appendectomy.
    property detailList : TFhirReferenceList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirCompositionEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionEventList;
    function GetCurrent : TFhirCompositionEvent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCompositionEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionEvent read GetCurrent;
  end;

  TFhirCompositionEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionEvent;
    procedure SetItemN(index : Integer; value : TFhirCompositionEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionEventList; overload;
    function Clone : TFhirCompositionEventList; overload;
    function GetEnumerator : TFhirCompositionEventListEnumerator;
    
    //  Add a FhirCompositionEvent to the end of the list.
    function Append : TFhirCompositionEvent;
    
    // Add an already existing FhirCompositionEvent to the end of the list.
    function AddItem(value : TFhirCompositionEvent) : TFhirCompositionEvent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionEvent) : Integer;
    
    // Insert FhirCompositionEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionEvent;
    
    // Insert an existing FhirCompositionEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionEvent);
    
    // Get the iIndexth FhirCompositionEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionEvent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositionEvents[index : Integer] : TFhirCompositionEvent read GetItemN write SetItemN; default;
  End;

  // The root of the sections that make up the composition.
  TFhirCompositionSection = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FauthorList : TFhirReferenceList;
    FFocus : TFhirReference;
    FText : TFhirNarrative;
    FMode : TFhirEnum;
    FOrderedBy : TFhirCodeableConcept;
    FentryList : TFhirReferenceList;
    FEmptyReason : TFhirCodeableConcept;
    FsectionList : TFhirCompositionSectionList;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    procedure SetFocus(value : TFhirReference);
    procedure SetText(value : TFhirNarrative);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirListModeEnum;
    procedure SetModeST(value : TFhirListModeEnum);
    procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetEntryList : TFhirReferenceList;
    function GetHasEntryList : Boolean;
    procedure SetEmptyReason(value : TFhirCodeableConcept);
    function GetSectionList : TFhirCompositionSectionList;
    function GetHasSectionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCompositionSection; overload;
    function Clone : TFhirCompositionSection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property title : String read GetTitleST write SetTitleST;
    // The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A code identifying the kind of content contained within the section. This must be consistent with the section title. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code identifying the kind of content contained within the section. This must be consistent with the section title.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Identifies who is responsible for the information in this section, not necessarily who typed it in.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to The actual focus of the section when it is not the subject of the composition, but instead represents something or someone associated with the subject such as (for a patient subject) a spouse, parent, fetus, or donor. If not focus is specified, the focus is assumed to be focus of the parent section, or, for a section in the Composition itself, the subject of the composition. Sections with a focus SHALL only include resources where the logical subject (patient, subject, focus, etc.) matches the section focus, or the resources have no logical subject (few resources). (defined for API consistency)
    property focus : TFhirReference read FFocus write SetFocus;
    // The actual focus of the section when it is not the subject of the composition, but instead represents something or someone associated with the subject such as (for a patient subject) a spouse, parent, fetus, or donor. If not focus is specified, the focus is assumed to be focus of the parent section, or, for a section in the Composition itself, the subject of the composition. Sections with a focus SHALL only include resources where the logical subject (patient, subject, focus, etc.) matches the section focus, or the resources have no logical subject (few resources).
    property focusElement : TFhirReference read FFocus write SetFocus;

    // Typed access to A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative. (defined for API consistency)
    property text : TFhirNarrative read FText write SetText;
    // A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is required to contain sufficient detail to make it "clinically safe" for a human to just read the narrative.
    property textElement : TFhirNarrative read FText write SetText;

    // How the entry list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Specifies the order applied to the items in the section entries. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // Specifies the order applied to the items in the section entries.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // A reference to the actual resource from which the narrative in the section is derived.
    property entryList : TFhirReferenceList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

    // A nested sub-section within this section.
    property sectionList : TFhirCompositionSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirCompositionSectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionSectionList;
    function GetCurrent : TFhirCompositionSection;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCompositionSectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCompositionSection read GetCurrent;
  end;

  TFhirCompositionSectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCompositionSection;
    procedure SetItemN(index : Integer; value : TFhirCompositionSection);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionSectionList; overload;
    function Clone : TFhirCompositionSectionList; overload;
    function GetEnumerator : TFhirCompositionSectionListEnumerator;
    
    //  Add a FhirCompositionSection to the end of the list.
    function Append : TFhirCompositionSection;
    
    // Add an already existing FhirCompositionSection to the end of the list.
    function AddItem(value : TFhirCompositionSection) : TFhirCompositionSection; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCompositionSection) : Integer;
    
    // Insert FhirCompositionSection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCompositionSection;
    
    // Insert an existing FhirCompositionSection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCompositionSection);
    
    // Get the iIndexth FhirCompositionSection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCompositionSection);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCompositionSection;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositionSections[index : Integer] : TFhirCompositionSection read GetItemN write SetItemN; default;
  End;

  // A set of healthcare-related information that is assembled together into a single logical package that provides a single coherent statement of meaning, establishes its own context and that has clinical attestation with regard to who is making the statement. A Composition defines the structure and narrative content necessary for a document. However, a Composition alone does not constitute a document. Rather, the Composition must be the first entry in a Bundle where Bundle.type=document, and any other resources referenced from Composition must be included as subsequent entries in the Bundle (for example Patient, Practitioner, Encounter, etc.).
  TFhirComposition = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FDate : TFhirDateTime;
    FauthorList : TFhirReferenceList;
    FTitle : TFhirString;
    FConfidentiality : TFhirCode;
    FattesterList : TFhirCompositionAttesterList;
    FCustodian : TFhirReference;
    FrelatesToList : TFhirCompositionRelatesToList;
    FeventList : TFhirCompositionEventList;
    FsectionList : TFhirCompositionSectionList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirCompositionStatusEnum;
    procedure SetStatusST(value : TFhirCompositionStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetConfidentiality(value : TFhirCode);
    function GetConfidentialityST : String;
    procedure SetConfidentialityST(value : String);
    function GetAttesterList : TFhirCompositionAttesterList;
    function GetHasAttesterList : Boolean;
    procedure SetCustodian(value : TFhirReference);
    function GetRelatesToList : TFhirCompositionRelatesToList;
    function GetHasRelatesToList : Boolean;
    function GetEventList : TFhirCompositionEventList;
    function GetHasEventList : Boolean;
    function GetSectionList : TFhirCompositionSectionList;
    function GetHasSectionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirComposition; overload;
    function Clone : TFhirComposition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A version-independent identifier for the Composition. This identifier stays constant as the composition is changed over time. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A version-independent identifier for the Composition. This identifier stays constant as the composition is changed over time.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The workflow/clinical status of this composition. The status is a marker for the clinical standing of the document.
    property status : TFhirCompositionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Specifies the particular kind of composition (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the composition. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the particular kind of composition (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the composition.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // A categorization for the type of the composition - helps for indexing and searching. This may be implied by or derived from the code specified in the Composition Type.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Who or what the composition is about. The composition can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of livestock, or a set of patients that share a common exposure). (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Who or what the composition is about. The composition can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of livestock, or a set of patients that share a common exposure).
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Describes the clinical encounter or type of care this documentation is associated with. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // Describes the clinical encounter or type of care this documentation is associated with.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The composition editing time, when the composition was last logically changed by the author.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The composition editing time, when the composition was last logically changed by the author.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Identifies who is responsible for the information in the composition, not necessarily who typed it in.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to Official human-readable label for the composition.
    property title : String read GetTitleST write SetTitleST;
    // Official human-readable label for the composition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The code specifying the level of confidentiality of the Composition.
    property confidentiality : String read GetConfidentialityST write SetConfidentialityST;
    // The code specifying the level of confidentiality of the Composition.
    property confidentialityElement : TFhirCode read FConfidentiality write SetConfidentiality;

    // A participant who has attested to the accuracy of the composition/document.
    property attesterList : TFhirCompositionAttesterList read GetAttesterList;
    property hasAttesterList : boolean read GetHasAttesterList;

    // Typed access to Identifies the organization or group who is responsible for ongoing maintenance of and access to the composition/document information. (defined for API consistency)
    property custodian : TFhirReference read FCustodian write SetCustodian;
    // Identifies the organization or group who is responsible for ongoing maintenance of and access to the composition/document information.
    property custodianElement : TFhirReference read FCustodian write SetCustodian;

    // Relationships that this composition has with other compositions or documents that already exist.
    property relatesToList : TFhirCompositionRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // The clinical service, such as a colonoscopy or an appendectomy, being documented.
    property eventList : TFhirCompositionEventList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // The root of the sections that make up the composition.
    property sectionList : TFhirCompositionSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirCompositionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCompositionList;
    function GetCurrent : TFhirComposition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCompositionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirComposition read GetCurrent;
  end;

  TFhirCompositionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirComposition;
    procedure SetItemN(index : Integer; value : TFhirComposition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCompositionList; overload;
    function Clone : TFhirCompositionList; overload;
    function GetEnumerator : TFhirCompositionListEnumerator;
    
    //  Add a FhirComposition to the end of the list.
    function Append : TFhirComposition;
    
    // Add an already existing FhirComposition to the end of the list.
    function AddItem(value : TFhirComposition) : TFhirComposition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirComposition) : Integer;
    
    // Insert FhirComposition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirComposition;
    
    // Insert an existing FhirComposition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirComposition);
    
    // Get the iIndexth FhirComposition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirComposition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirComposition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCompositions[index : Integer] : TFhirComposition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONDITION}
  // Clinical stage or grade of a condition. May include formal severity assessments.
  TFhirConditionStage = class (TFhirBackboneElement)
  protected
    FSummary : TFhirCodeableConcept;
    FassessmentList : TFhirReferenceList;
    FType_ : TFhirCodeableConcept;
    procedure SetSummary(value : TFhirCodeableConcept);
    function GetAssessmentList : TFhirReferenceList;
    function GetHasAssessmentList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConditionStage; overload;
    function Clone : TFhirConditionStage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific. (defined for API consistency)
    property summary : TFhirCodeableConcept read FSummary write SetSummary;
    // A simple summary of the stage such as "Stage 3". The determination of the stage is disease-specific.
    property summaryElement : TFhirCodeableConcept read FSummary write SetSummary;

    // Reference to a formal record of the evidence on which the staging assessment is based.
    property assessmentList : TFhirReferenceList read GetAssessmentList;
    property hasAssessmentList : boolean read GetHasAssessmentList;

    // Typed access to The kind of staging, such as pathological or clinical staging. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of staging, such as pathological or clinical staging.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirConditionStageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionStageList;
    function GetCurrent : TFhirConditionStage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConditionStageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionStage read GetCurrent;
  end;

  TFhirConditionStageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionStage;
    procedure SetItemN(index : Integer; value : TFhirConditionStage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConditionStageList; overload;
    function Clone : TFhirConditionStageList; overload;
    function GetEnumerator : TFhirConditionStageListEnumerator;
    
    //  Add a FhirConditionStage to the end of the list.
    function Append : TFhirConditionStage;
    
    // Add an already existing FhirConditionStage to the end of the list.
    function AddItem(value : TFhirConditionStage) : TFhirConditionStage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConditionStage) : Integer;
    
    // Insert FhirConditionStage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConditionStage;
    
    // Insert an existing FhirConditionStage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConditionStage);
    
    // Get the iIndexth FhirConditionStage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConditionStage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConditionStage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConditionStages[index : Integer] : TFhirConditionStage read GetItemN write SetItemN; default;
  End;

  // Supporting evidence / manifestations that are the basis of the Condition's verification status, such as evidence that confirmed or refuted the condition.
  TFhirConditionEvidence = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FdetailList : TFhirReferenceList;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDetailList : TFhirReferenceList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConditionEvidence; overload;
    function Clone : TFhirConditionEvidence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A manifestation or symptom that led to the recording of this condition.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Links to other relevant information, including pathology reports.
    property detailList : TFhirReferenceList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirConditionEvidenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionEvidenceList;
    function GetCurrent : TFhirConditionEvidence;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConditionEvidenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConditionEvidence read GetCurrent;
  end;

  TFhirConditionEvidenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConditionEvidence;
    procedure SetItemN(index : Integer; value : TFhirConditionEvidence);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConditionEvidenceList; overload;
    function Clone : TFhirConditionEvidenceList; overload;
    function GetEnumerator : TFhirConditionEvidenceListEnumerator;
    
    //  Add a FhirConditionEvidence to the end of the list.
    function Append : TFhirConditionEvidence;
    
    // Add an already existing FhirConditionEvidence to the end of the list.
    function AddItem(value : TFhirConditionEvidence) : TFhirConditionEvidence; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConditionEvidence) : Integer;
    
    // Insert FhirConditionEvidence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConditionEvidence;
    
    // Insert an existing FhirConditionEvidence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConditionEvidence);
    
    // Get the iIndexth FhirConditionEvidence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConditionEvidence);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConditionEvidence;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConditionEvidences[index : Integer] : TFhirConditionEvidence read GetItemN write SetItemN; default;
  End;

  // A clinical condition, problem, diagnosis, or other event, situation, issue, or clinical concept that has risen to a level of concern.
  TFhirCondition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FClinicalStatus : TFhirCodeableConcept;
    FVerificationStatus : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FSeverity : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FbodySiteList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOnset : TFhirDataType;
    FAbatement : TFhirDataType;
    FRecordedDate : TFhirDateTime;
    FRecorder : TFhirReference;
    FAsserter : TFhirReference;
    FstageList : TFhirConditionStageList;
    FevidenceList : TFhirConditionEvidenceList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetClinicalStatus(value : TFhirCodeableConcept);
    procedure SetVerificationStatus(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetSeverity(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOnset(value : TFhirDataType);
    procedure SetAbatement(value : TFhirDataType);
    procedure SetRecordedDate(value : TFhirDateTime);
    function GetRecordedDateST : TFslDateTime;
    procedure SetRecordedDateST(value : TFslDateTime);
    procedure SetRecorder(value : TFhirReference);
    procedure SetAsserter(value : TFhirReference);
    function GetStageList : TFhirConditionStageList;
    function GetHasStageList : Boolean;
    function GetEvidenceList : TFhirConditionEvidenceList;
    function GetHasEvidenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCondition; overload;
    function Clone : TFhirCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this condition by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The clinical status of the condition. (defined for API consistency)
    property clinicalStatus : TFhirCodeableConcept read FClinicalStatus write SetClinicalStatus;
    // The clinical status of the condition.
    property clinicalStatusElement : TFhirCodeableConcept read FClinicalStatus write SetClinicalStatus;

    // Typed access to The verification status to support the clinical status of the condition. (defined for API consistency)
    property verificationStatus : TFhirCodeableConcept read FVerificationStatus write SetVerificationStatus;
    // The verification status to support the clinical status of the condition.
    property verificationStatusElement : TFhirCodeableConcept read FVerificationStatus write SetVerificationStatus;

    // A category assigned to the condition.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A subjective assessment of the severity of the condition as evaluated by the clinician. (defined for API consistency)
    property severity : TFhirCodeableConcept read FSeverity write SetSeverity;
    // A subjective assessment of the severity of the condition as evaluated by the clinician.
    property severityElement : TFhirCodeableConcept read FSeverity write SetSeverity;

    // Typed access to Identification of the condition, problem or diagnosis. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identification of the condition, problem or diagnosis.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The anatomical location where this condition manifests itself.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to Indicates the patient or group who the condition record is associated with. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Indicates the patient or group who the condition record is associated with.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this Condition was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this Condition was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Estimated or actual date or date-time  the condition began, in the opinion of the clinician. (defined for API consistency)
    property onset : TFhirDataType read FOnset write SetOnset;
    // Estimated or actual date or date-time  the condition began, in the opinion of the clinician.
    property onsetElement : TFhirDataType read FOnset write SetOnset;

    // Typed access to The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate. (defined for API consistency)
    property abatement : TFhirDataType read FAbatement write SetAbatement;
    // The date or estimated date that the condition resolved or went into remission. This is called "abatement" because of the many overloaded connotations associated with "remission" or "resolution" - Conditions are never really resolved, but they can abate.
    property abatementElement : TFhirDataType read FAbatement write SetAbatement;

    // Typed access to The recordedDate represents when this particular Condition record was created in the system, which is often a system-generated date.
    property recordedDate : TFslDateTime read GetRecordedDateST write SetRecordedDateST;
    // The recordedDate represents when this particular Condition record was created in the system, which is often a system-generated date.
    property recordedDateElement : TFhirDateTime read FRecordedDate write SetRecordedDate;

    // Typed access to Individual who recorded the record and takes responsibility for its content. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // Individual who recorded the record and takes responsibility for its content.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // Typed access to Individual who is making the condition statement. (defined for API consistency)
    property asserter : TFhirReference read FAsserter write SetAsserter;
    // Individual who is making the condition statement.
    property asserterElement : TFhirReference read FAsserter write SetAsserter;

    // Clinical stage or grade of a condition. May include formal severity assessments.
    property stageList : TFhirConditionStageList read GetStageList;
    property hasStageList : boolean read GetHasStageList;

    // Supporting evidence / manifestations that are the basis of the Condition's verification status, such as evidence that confirmed or refuted the condition.
    property evidenceList : TFhirConditionEvidenceList read GetEvidenceList;
    property hasEvidenceList : boolean read GetHasEvidenceList;

    // Additional information about the Condition. This is a general notes/comments entry  for description of the Condition, its diagnosis and prognosis.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConditionList;
    function GetCurrent : TFhirCondition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCondition read GetCurrent;
  end;

  TFhirConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCondition;
    procedure SetItemN(index : Integer; value : TFhirCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConditionList; overload;
    function Clone : TFhirConditionList; overload;
    function GetEnumerator : TFhirConditionListEnumerator;
    
    //  Add a FhirCondition to the end of the list.
    function Append : TFhirCondition;
    
    // Add an already existing FhirCondition to the end of the list.
    function AddItem(value : TFhirCondition) : TFhirCondition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCondition) : Integer;
    
    // Insert FhirCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCondition;
    
    // Insert an existing FhirCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCondition);
    
    // Get the iIndexth FhirCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCondition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConditions[index : Integer] : TFhirCondition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_DETECTEDISSUE}
  // Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
  TFhirDetectedIssueEvidence = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FdetailList : TFhirReferenceList;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDetailList : TFhirReferenceList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssueEvidence; overload;
    function Clone : TFhirDetectedIssueEvidence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A manifestation that led to the recording of this detected issue.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Links to resources that constitute evidence for the detected issue such as a GuidanceResponse or MeasureReport.
    property detailList : TFhirReferenceList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirDetectedIssueEvidenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueEvidenceList;
    function GetCurrent : TFhirDetectedIssueEvidence;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueEvidenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssueEvidence read GetCurrent;
  end;

  TFhirDetectedIssueEvidenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDetectedIssueEvidence;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssueEvidence);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDetectedIssueEvidenceList; overload;
    function Clone : TFhirDetectedIssueEvidenceList; overload;
    function GetEnumerator : TFhirDetectedIssueEvidenceListEnumerator;
    
    //  Add a FhirDetectedIssueEvidence to the end of the list.
    function Append : TFhirDetectedIssueEvidence;
    
    // Add an already existing FhirDetectedIssueEvidence to the end of the list.
    function AddItem(value : TFhirDetectedIssueEvidence) : TFhirDetectedIssueEvidence; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssueEvidence) : Integer;
    
    // Insert FhirDetectedIssueEvidence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssueEvidence;
    
    // Insert an existing FhirDetectedIssueEvidence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssueEvidence);
    
    // Get the iIndexth FhirDetectedIssueEvidence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssueEvidence);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssueEvidence;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDetectedIssueEvidences[index : Integer] : TFhirDetectedIssueEvidence read GetItemN write SetItemN; default;
  End;

  // Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
  TFhirDetectedIssueMitigation = class (TFhirBackboneElement)
  protected
    FAction : TFhirCodeableConcept;
    FDate : TFhirDateTime;
    FAuthor : TFhirReference;
    procedure SetAction(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssueMitigation; overload;
    function Clone : TFhirDetectedIssueMitigation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the action that was taken or the observation that was made that reduces/eliminates the risk associated with the identified issue. (defined for API consistency)
    property action : TFhirCodeableConcept read FAction write SetAction;
    // Describes the action that was taken or the observation that was made that reduces/eliminates the risk associated with the identified issue.
    property actionElement : TFhirCodeableConcept read FAction write SetAction;

    // Typed access to Indicates when the mitigating action was documented.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Indicates when the mitigating action was documented.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Identifies the practitioner who determined the mitigation and takes responsibility for the mitigation step occurring.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

  end;

  TFhirDetectedIssueMitigationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueMitigationList;
    function GetCurrent : TFhirDetectedIssueMitigation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueMitigationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssueMitigation read GetCurrent;
  end;

  TFhirDetectedIssueMitigationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDetectedIssueMitigation;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssueMitigation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDetectedIssueMitigationList; overload;
    function Clone : TFhirDetectedIssueMitigationList; overload;
    function GetEnumerator : TFhirDetectedIssueMitigationListEnumerator;
    
    //  Add a FhirDetectedIssueMitigation to the end of the list.
    function Append : TFhirDetectedIssueMitigation;
    
    // Add an already existing FhirDetectedIssueMitigation to the end of the list.
    function AddItem(value : TFhirDetectedIssueMitigation) : TFhirDetectedIssueMitigation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssueMitigation) : Integer;
    
    // Insert FhirDetectedIssueMitigation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssueMitigation;
    
    // Insert an existing FhirDetectedIssueMitigation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssueMitigation);
    
    // Get the iIndexth FhirDetectedIssueMitigation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssueMitigation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssueMitigation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDetectedIssueMitigations[index : Integer] : TFhirDetectedIssueMitigation read GetItemN write SetItemN; default;
  End;

  // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, Ineffective treatment frequency, Procedure-condition conflict, etc.
  TFhirDetectedIssue = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FSeverity : TFhirEnum;
    FPatient : TFhirReference;
    FIdentified : TFhirDataType;
    FAuthor : TFhirReference;
    FimplicatedList : TFhirReferenceList;
    FevidenceList : TFhirDetectedIssueEvidenceList;
    FDetail : TFhirString;
    FReference : TFhirUri;
    FmitigationList : TFhirDetectedIssueMitigationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirObservationStatusEnum;
    procedure SetStatusST(value : TFhirObservationStatusEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSeverity(value : TFhirEnum);
    function GetSeverityST : TFhirDetectedIssueSeverityEnum;
    procedure SetSeverityST(value : TFhirDetectedIssueSeverityEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetIdentified(value : TFhirDataType);
    procedure SetAuthor(value : TFhirReference);
    function GetImplicatedList : TFhirReferenceList;
    function GetHasImplicatedList : Boolean;
    function GetEvidenceList : TFhirDetectedIssueEvidenceList;
    function GetHasEvidenceList : Boolean;
    procedure SetDetail(value : TFhirString);
    function GetDetailST : String;
    procedure SetDetailST(value : String);
    procedure SetReference(value : TFhirUri);
    function GetReferenceST : String;
    procedure SetReferenceST(value : String);
    function GetMitigationList : TFhirDetectedIssueMitigationList;
    function GetHasMitigationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDetectedIssue; overload;
    function Clone : TFhirDetectedIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier associated with the detected issue record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the status of the detected issue.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Identifies the general type of issue identified. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Identifies the general type of issue identified.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Indicates the degree of importance associated with the identified issue based on the potential impact on the patient.
    property severity : TFhirDetectedIssueSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Typed access to Indicates the patient whose record the detected issue is associated with. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // Indicates the patient whose record the detected issue is associated with.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date or period when the detected issue was initially identified. (defined for API consistency)
    property identified : TFhirDataType read FIdentified write SetIdentified;
    // The date or period when the detected issue was initially identified.
    property identifiedElement : TFhirDataType read FIdentified write SetIdentified;

    // Typed access to Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Individual or device responsible for the issue being raised.  For example, a decision support application or a pharmacist conducting a medication review.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Indicates the resource representing the current activity or proposed activity that is potentially problematic.
    property implicatedList : TFhirReferenceList read GetImplicatedList;
    property hasImplicatedList : boolean read GetHasImplicatedList;

    // Supporting evidence or manifestations that provide the basis for identifying the detected issue such as a GuidanceResponse or MeasureReport.
    property evidenceList : TFhirDetectedIssueEvidenceList read GetEvidenceList;
    property hasEvidenceList : boolean read GetHasEvidenceList;

    // Typed access to A textual explanation of the detected issue.
    property detail : String read GetDetailST write SetDetailST;
    // A textual explanation of the detected issue.
    property detailElement : TFhirString read FDetail write SetDetail;

    // Typed access to The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
    property reference : String read GetReferenceST write SetReferenceST;
    // The literature, knowledge-base or similar reference that describes the propensity for the detected issue identified.
    property referenceElement : TFhirUri read FReference write SetReference;

    // Indicates an action that has been taken or is committed to reduce or eliminate the likelihood of the risk identified by the detected issue from manifesting.  Can also reflect an observation of known mitigating factors that may reduce/eliminate the need for any action.
    property mitigationList : TFhirDetectedIssueMitigationList read GetMitigationList;
    property hasMitigationList : boolean read GetHasMitigationList;

  end;

  TFhirDetectedIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDetectedIssueList;
    function GetCurrent : TFhirDetectedIssue;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDetectedIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDetectedIssue read GetCurrent;
  end;

  TFhirDetectedIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDetectedIssue;
    procedure SetItemN(index : Integer; value : TFhirDetectedIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDetectedIssueList; overload;
    function Clone : TFhirDetectedIssueList; overload;
    function GetEnumerator : TFhirDetectedIssueListEnumerator;
    
    //  Add a FhirDetectedIssue to the end of the list.
    function Append : TFhirDetectedIssue;
    
    // Add an already existing FhirDetectedIssue to the end of the list.
    function AddItem(value : TFhirDetectedIssue) : TFhirDetectedIssue; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDetectedIssue) : Integer;
    
    // Insert FhirDetectedIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDetectedIssue;
    
    // Insert an existing FhirDetectedIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDetectedIssue);
    
    // Get the iIndexth FhirDetectedIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDetectedIssue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDetectedIssue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDetectedIssues[index : Integer] : TFhirDetectedIssue read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICEREQUEST}
  // Specific parameters for the ordered item.  For example, the prism value for lenses.
  TFhirDeviceRequestParameter = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceRequestParameter; overload;
    function Clone : TFhirDeviceRequestParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code or string that identifies the device detail being asserted. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code or string that identifies the device detail being asserted.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The value of the device detail. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the device detail.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirDeviceRequestParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceRequestParameterList;
    function GetCurrent : TFhirDeviceRequestParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceRequestParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceRequestParameter read GetCurrent;
  end;

  TFhirDeviceRequestParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceRequestParameter;
    procedure SetItemN(index : Integer; value : TFhirDeviceRequestParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceRequestParameterList; overload;
    function Clone : TFhirDeviceRequestParameterList; overload;
    function GetEnumerator : TFhirDeviceRequestParameterListEnumerator;
    
    //  Add a FhirDeviceRequestParameter to the end of the list.
    function Append : TFhirDeviceRequestParameter;
    
    // Add an already existing FhirDeviceRequestParameter to the end of the list.
    function AddItem(value : TFhirDeviceRequestParameter) : TFhirDeviceRequestParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceRequestParameter) : Integer;
    
    // Insert FhirDeviceRequestParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceRequestParameter;
    
    // Insert an existing FhirDeviceRequestParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceRequestParameter);
    
    // Get the iIndexth FhirDeviceRequestParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceRequestParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceRequestParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceRequestParameters[index : Integer] : TFhirDeviceRequestParameter read GetItemN write SetItemN; default;
  End;

  // Represents a request for a patient to employ a medical device. The device may be an implantable device, or an external assistive device, such as a walker.
  TFhirDeviceRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FpriorRequestList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FCode : TFhirDataType;
    FparameterList : TFhirDeviceRequestParameterList;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FPerformerType : TFhirCodeableConcept;
    FPerformer : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FinsuranceList : TFhirReferenceList;
    FsupportingInfoList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FrelevantHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPriorRequestList : TFhirReferenceList;
    function GetHasPriorRequestList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetCode(value : TFhirDataType);
    function GetParameterList : TFhirDeviceRequestParameterList;
    function GetHasParameterList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    procedure SetPerformerType(value : TFhirCodeableConcept);
    procedure SetPerformer(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetInsuranceList : TFhirReferenceList;
    function GetHasInsuranceList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList;
    function GetHasRelevantHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceRequest; overload;
    function Clone : TFhirDeviceRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this order by the orderer or by the receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this DeviceRequest.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this DeviceRequest.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // Plan/proposal/order fulfilled by this request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The request takes the place of the referenced completed or terminated request(s).
    property priorRequestList : TFhirReferenceList read GetPriorRequestList;
    property hasPriorRequestList : boolean read GetHasPriorRequestList;

    // Typed access to Composite request this is part of. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // Composite request this is part of.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The status of the request.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether the request is a proposal, plan, an original order or a reflex order.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the {{title)))) should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to The details of the device to be used. (defined for API consistency)
    property code : TFhirDataType read FCode write SetCode;
    // The details of the device to be used.
    property codeElement : TFhirDataType read FCode write SetCode;

    // Specific parameters for the ordered item.  For example, the prism value for lenses.
    property parameterList : TFhirDeviceRequestParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // Typed access to The patient who will use the device. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient who will use the device.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to An encounter that provides additional context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // An encounter that provides additional context in which this request is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The timing schedule for the use of the device. The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013". (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The timing schedule for the use of the device. The Schedule data type allows many different expressions, for example. "Every 8 hours"; "Three times a day"; "1/2 an hour before breakfast for 10 days from 23-Dec 2011:"; "15 Oct 2013, 17 Oct 2013 and 1 Nov 2013".
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to When the request transitioned to being actionable.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // When the request transitioned to being actionable.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The individual who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // Typed access to Desired type of performer for doing the diagnostic testing. (defined for API consistency)
    property performerType : TFhirCodeableConcept read FPerformerType write SetPerformerType;
    // Desired type of performer for doing the diagnostic testing.
    property performerTypeElement : TFhirCodeableConcept read FPerformerType write SetPerformerType;

    // Typed access to The desired performer for doing the diagnostic testing. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // The desired performer for doing the diagnostic testing.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Reason or justification for the use of this device.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Reason or justification for the use of this device.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be required for delivering the requested service.
    property insuranceList : TFhirReferenceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Additional clinical information about the patient that may influence the request fulfilment.  For example, this may include where on the subject's body the device will be used (i.e. the target site).
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Details about this request that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Key events in the history of the request.
    property relevantHistoryList : TFhirReferenceList read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

  end;

  TFhirDeviceRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceRequestList;
    function GetCurrent : TFhirDeviceRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceRequest read GetCurrent;
  end;

  TFhirDeviceRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceRequest;
    procedure SetItemN(index : Integer; value : TFhirDeviceRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceRequestList; overload;
    function Clone : TFhirDeviceRequestList; overload;
    function GetEnumerator : TFhirDeviceRequestListEnumerator;
    
    //  Add a FhirDeviceRequest to the end of the list.
    function Append : TFhirDeviceRequest;
    
    // Add an already existing FhirDeviceRequest to the end of the list.
    function AddItem(value : TFhirDeviceRequest) : TFhirDeviceRequest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceRequest) : Integer;
    
    // Insert FhirDeviceRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceRequest;
    
    // Insert an existing FhirDeviceRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceRequest);
    
    // Get the iIndexth FhirDeviceRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceRequests[index : Integer] : TFhirDeviceRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
  // A record of a device being used by a patient where the record is the result of a report from the patient or another clinician.
  TFhirDeviceUseStatement = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FSubject : TFhirReference;
    FderivedFromList : TFhirReferenceList;
    FTiming : TFhirDataType;
    FRecordedOn : TFhirDateTime;
    FSource : TFhirReference;
    FDevice : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FBodySite : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirDeviceUseStatementStatusEnum;
    procedure SetStatusST(value : TFhirDeviceUseStatementStatusEnum);
    procedure SetSubject(value : TFhirReference);
    function GetDerivedFromList : TFhirReferenceList;
    function GetHasDerivedFromList : Boolean;
    procedure SetTiming(value : TFhirDataType);
    procedure SetRecordedOn(value : TFhirDateTime);
    function GetRecordedOnST : TFslDateTime;
    procedure SetRecordedOnST(value : TFslDateTime);
    procedure SetSource(value : TFhirReference);
    procedure SetDevice(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    procedure SetBodySite(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceUseStatement; overload;
    function Clone : TFhirDeviceUseStatement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An external identifier for this statement such as an IRI.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this DeviceUseStatement.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A code representing the patient or other source's judgment about the state of the device used that this statement is about.  Generally this will be active or completed.
    property status : TFhirDeviceUseStatementStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The patient who used the device. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient who used the device.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Allows linking the DeviceUseStatement to the underlying Request, or to other information that supports or is used to derive the DeviceUseStatement.
    property derivedFromList : TFhirReferenceList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // Typed access to How often the device was used. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // How often the device was used.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to The time at which the statement was made/recorded.
    property recordedOn : TFslDateTime read GetRecordedOnST write SetRecordedOnST;
    // The time at which the statement was made/recorded.
    property recordedOnElement : TFhirDateTime read FRecordedOn write SetRecordedOn;

    // Typed access to Who reported the device was being used by the patient. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // Who reported the device was being used by the patient.
    property sourceElement : TFhirReference read FSource write SetSource;

    // Typed access to The details of the device used. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // The details of the device used.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Reason or justification for the use of the device.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies this DeviceUseStatement.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Typed access to Indicates the anotomic location on the subject's body where the device was used ( i.e. the target). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Indicates the anotomic location on the subject's body where the device was used ( i.e. the target).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Details about the device statement that were not represented at all or sufficiently in one of the attributes provided in a class. These may include for example a comment, an instruction, or a note associated with the statement.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirDeviceUseStatementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceUseStatementList;
    function GetCurrent : TFhirDeviceUseStatement;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceUseStatementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceUseStatement read GetCurrent;
  end;

  TFhirDeviceUseStatementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceUseStatement;
    procedure SetItemN(index : Integer; value : TFhirDeviceUseStatement);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceUseStatementList; overload;
    function Clone : TFhirDeviceUseStatementList; overload;
    function GetEnumerator : TFhirDeviceUseStatementListEnumerator;
    
    //  Add a FhirDeviceUseStatement to the end of the list.
    function Append : TFhirDeviceUseStatement;
    
    // Add an already existing FhirDeviceUseStatement to the end of the list.
    function AddItem(value : TFhirDeviceUseStatement) : TFhirDeviceUseStatement; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceUseStatement) : Integer;
    
    // Insert FhirDeviceUseStatement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceUseStatement;
    
    // Insert an existing FhirDeviceUseStatement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceUseStatement);
    
    // Get the iIndexth FhirDeviceUseStatement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceUseStatement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceUseStatement;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceUseStatements[index : Integer] : TFhirDeviceUseStatement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
  // A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
  TFhirDiagnosticReportMedia = class (TFhirBackboneElement)
  protected
    FComment : TFhirString;
    FLink_ : TFhirReference;
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    procedure SetLink_(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticReportMedia; overload;
    function Clone : TFhirDiagnosticReportMedia; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    property comment : String read GetCommentST write SetCommentST;
    // A comment about the image. Typically, this is used to provide an explanation for why the image is included, or to draw the viewer's attention to important features.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Reference to the image source. (defined for API consistency)
    property link_ : TFhirReference read FLink_ write SetLink_;
    // Reference to the image source.
    property link_Element : TFhirReference read FLink_ write SetLink_;

  end;

  TFhirDiagnosticReportMediaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportMediaList;
    function GetCurrent : TFhirDiagnosticReportMedia;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticReportMediaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReportMedia read GetCurrent;
  end;

  TFhirDiagnosticReportMediaList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticReportMedia;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReportMedia);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDiagnosticReportMediaList; overload;
    function Clone : TFhirDiagnosticReportMediaList; overload;
    function GetEnumerator : TFhirDiagnosticReportMediaListEnumerator;
    
    //  Add a FhirDiagnosticReportMedia to the end of the list.
    function Append : TFhirDiagnosticReportMedia;
    
    // Add an already existing FhirDiagnosticReportMedia to the end of the list.
    function AddItem(value : TFhirDiagnosticReportMedia) : TFhirDiagnosticReportMedia; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticReportMedia) : Integer;
    
    // Insert FhirDiagnosticReportMedia before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticReportMedia;
    
    // Insert an existing FhirDiagnosticReportMedia before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReportMedia);
    
    // Get the iIndexth FhirDiagnosticReportMedia. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReportMedia);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticReportMedia;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDiagnosticReportMedia[index : Integer] : TFhirDiagnosticReportMedia read GetItemN write SetItemN; default;
  End;

  // The findings and interpretation of diagnostic  tests performed on patients, groups of patients, devices, and locations, and/or specimens derived from these. The report includes clinical context such as requesting and provider information, and some mix of atomic results, images, textual and coded interpretations, and formatted representation of diagnostic reports.
  TFhirDiagnosticReport = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FEffective : TFhirDataType;
    FIssued : TFhirInstant;
    FperformerList : TFhirReferenceList;
    FresultsInterpreterList : TFhirReferenceList;
    FspecimenList : TFhirReferenceList;
    FresultList : TFhirReferenceList;
    FimagingStudyList : TFhirReferenceList;
    FmediaList : TFhirDiagnosticReportMediaList;
    FConclusion : TFhirString;
    FconclusionCodeList : TFhirCodeableConceptList;
    FpresentedFormList : TFhirAttachmentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirDiagnosticReportStatusEnum;
    procedure SetStatusST(value : TFhirDiagnosticReportStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetEffective(value : TFhirDataType);
    procedure SetIssued(value : TFhirInstant);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    function GetPerformerList : TFhirReferenceList;
    function GetHasPerformerList : Boolean;
    function GetResultsInterpreterList : TFhirReferenceList;
    function GetHasResultsInterpreterList : Boolean;
    function GetSpecimenList : TFhirReferenceList;
    function GetHasSpecimenList : Boolean;
    function GetResultList : TFhirReferenceList;
    function GetHasResultList : Boolean;
    function GetImagingStudyList : TFhirReferenceList;
    function GetHasImagingStudyList : Boolean;
    function GetMediaList : TFhirDiagnosticReportMediaList;
    function GetHasMediaList : Boolean;
    procedure SetConclusion(value : TFhirString);
    function GetConclusionST : String;
    procedure SetConclusionST(value : String);
    function GetConclusionCodeList : TFhirCodeableConceptList;
    function GetHasConclusionCodeList : Boolean;
    function GetPresentedFormList : TFhirAttachmentList;
    function GetHasPresentedFormList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDiagnosticReport; overload;
    function Clone : TFhirDiagnosticReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this report by the performer or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Details concerning a service requested.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The status of the diagnostic report.
    property status : TFhirDiagnosticReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code that classifies the clinical discipline, department or diagnostic service that created the report (e.g. cardiology, biochemistry, hematology, MRI). This is used for searching, sorting and display purposes.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to A code or name that describes this diagnostic report. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code or name that describes this diagnostic report.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The subject of the report. Usually, but not always, this is a patient. However, diagnostic services also perform analyses on specimens collected from a variety of other sources. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The subject of the report. Usually, but not always, this is a patient. However, diagnostic services also perform analyses on specimens collected from a variety of other sources.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) which this DiagnosticReport is about. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) which this DiagnosticReport is about.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The time or time-period the observed values are related to. When the subject of the report is a patient, this is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself. (defined for API consistency)
    property effective : TFhirDataType read FEffective write SetEffective;
    // The time or time-period the observed values are related to. When the subject of the report is a patient, this is usually either the time of the procedure or of specimen collection(s), but very often the source of the date/time is not known, only the date/time itself.
    property effectiveElement : TFhirDataType read FEffective write SetEffective;

    // Typed access to The date and time that this version of the report was made available to providers, typically after the report was reviewed and verified.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // The date and time that this version of the report was made available to providers, typically after the report was reviewed and verified.
    property issuedElement : TFhirInstant read FIssued write SetIssued;

    // The diagnostic service that is responsible for issuing the report.
    property performerList : TFhirReferenceList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // The practitioner or organization that is responsible for the report's conclusions and interpretations.
    property resultsInterpreterList : TFhirReferenceList read GetResultsInterpreterList;
    property hasResultsInterpreterList : boolean read GetHasResultsInterpreterList;

    // Details about the specimens on which this diagnostic report is based.
    property specimenList : TFhirReferenceList read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // [Observations](observation.html)  that are part of this diagnostic report.
    property resultList : TFhirReferenceList read GetResultList;
    property hasResultList : boolean read GetHasResultList;

    // One or more links to full details of any imaging performed during the diagnostic investigation. Typically, this is imaging performed by DICOM enabled modalities, but this is not required. A fully enabled PACS viewer can use this information to provide views of the source images.
    property imagingStudyList : TFhirReferenceList read GetImagingStudyList;
    property hasImagingStudyList : boolean read GetHasImagingStudyList;

    // A list of key images associated with this report. The images are generally created during the diagnostic process, and may be directly of the patient, or of treated specimens (i.e. slides of interest).
    property mediaList : TFhirDiagnosticReportMediaList read GetMediaList;
    property hasMediaList : boolean read GetHasMediaList;

    // Typed access to Concise and clinically contextualized summary conclusion (interpretation/impression) of the diagnostic report.
    property conclusion : String read GetConclusionST write SetConclusionST;
    // Concise and clinically contextualized summary conclusion (interpretation/impression) of the diagnostic report.
    property conclusionElement : TFhirString read FConclusion write SetConclusion;

    // One or more codes that represent the summary conclusion (interpretation/impression) of the diagnostic report.
    property conclusionCodeList : TFhirCodeableConceptList read GetConclusionCodeList;
    property hasConclusionCodeList : boolean read GetHasConclusionCodeList;

    // Rich text representation of the entire result as issued by the diagnostic service. Multiple formats are allowed but they SHALL be semantically equivalent.
    property presentedFormList : TFhirAttachmentList read GetPresentedFormList;
    property hasPresentedFormList : boolean read GetHasPresentedFormList;

  end;

  TFhirDiagnosticReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDiagnosticReportList;
    function GetCurrent : TFhirDiagnosticReport;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDiagnosticReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDiagnosticReport read GetCurrent;
  end;

  TFhirDiagnosticReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDiagnosticReport;
    procedure SetItemN(index : Integer; value : TFhirDiagnosticReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDiagnosticReportList; overload;
    function Clone : TFhirDiagnosticReportList; overload;
    function GetEnumerator : TFhirDiagnosticReportListEnumerator;
    
    //  Add a FhirDiagnosticReport to the end of the list.
    function Append : TFhirDiagnosticReport;
    
    // Add an already existing FhirDiagnosticReport to the end of the list.
    function AddItem(value : TFhirDiagnosticReport) : TFhirDiagnosticReport; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDiagnosticReport) : Integer;
    
    // Insert FhirDiagnosticReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDiagnosticReport;
    
    // Insert an existing FhirDiagnosticReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDiagnosticReport);
    
    // Get the iIndexth FhirDiagnosticReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDiagnosticReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDiagnosticReport;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDiagnosticReports[index : Integer] : TFhirDiagnosticReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
  // Related identifiers or resources associated with the DocumentManifest.
  TFhirDocumentManifestRelated = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FRef : TFhirReference;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetRef(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifestRelated; overload;
    function Clone : TFhirDocumentManifestRelated; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Related identifier to this DocumentManifest.  For example, Order numbers, accession numbers, XDW workflow numbers. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Related identifier to this DocumentManifest.  For example, Order numbers, accession numbers, XDW workflow numbers.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Related Resource to this DocumentManifest. For example, Order, ServiceRequest,  Procedure, EligibilityRequest, etc. (defined for API consistency)
    property ref : TFhirReference read FRef write SetRef;
    // Related Resource to this DocumentManifest. For example, Order, ServiceRequest,  Procedure, EligibilityRequest, etc.
    property refElement : TFhirReference read FRef write SetRef;

  end;

  TFhirDocumentManifestRelatedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestRelatedList;
    function GetCurrent : TFhirDocumentManifestRelated;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestRelatedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifestRelated read GetCurrent;
  end;

  TFhirDocumentManifestRelatedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentManifestRelated;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifestRelated);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentManifestRelatedList; overload;
    function Clone : TFhirDocumentManifestRelatedList; overload;
    function GetEnumerator : TFhirDocumentManifestRelatedListEnumerator;
    
    //  Add a FhirDocumentManifestRelated to the end of the list.
    function Append : TFhirDocumentManifestRelated;
    
    // Add an already existing FhirDocumentManifestRelated to the end of the list.
    function AddItem(value : TFhirDocumentManifestRelated) : TFhirDocumentManifestRelated; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifestRelated) : Integer;
    
    // Insert FhirDocumentManifestRelated before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifestRelated;
    
    // Insert an existing FhirDocumentManifestRelated before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifestRelated);
    
    // Get the iIndexth FhirDocumentManifestRelated. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifestRelated);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifestRelated;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentManifestRelateds[index : Integer] : TFhirDocumentManifestRelated read GetItemN write SetItemN; default;
  End;

  // A collection of documents compiled for a purpose together with metadata that applies to the collection.
  TFhirDocumentManifest = class (TFhirDomainResource)
  protected
    FMasterIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FCreated : TFhirDateTime;
    FauthorList : TFhirReferenceList;
    FrecipientList : TFhirReferenceList;
    FSource : TFhirUri;
    FDescription : TFhirString;
    FcontentList : TFhirReferenceList;
    FrelatedList : TFhirDocumentManifestRelatedList;
    procedure SetMasterIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirDocumentReferenceStatusEnum;
    procedure SetStatusST(value : TFhirDocumentReferenceStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    function GetRecipientList : TFhirReferenceList;
    function GetHasRecipientList : Boolean;
    procedure SetSource(value : TFhirUri);
    function GetSourceST : String;
    procedure SetSourceST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetContentList : TFhirReferenceList;
    function GetHasContentList : Boolean;
    function GetRelatedList : TFhirDocumentManifestRelatedList;
    function GetHasRelatedList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentManifest; overload;
    function Clone : TFhirDocumentManifest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A single identifier that uniquely identifies this manifest. Principally used to refer to the manifest in non-FHIR contexts. (defined for API consistency)
    property masterIdentifier : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;
    // A single identifier that uniquely identifies this manifest. Principally used to refer to the manifest in non-FHIR contexts.
    property masterIdentifierElement : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;

    // Other identifiers associated with the document manifest, including version independent  identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of this document manifest.
    property status : TFhirDocumentReferenceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The code specifying the type of clinical activity that resulted in placing the associated content into the DocumentManifest. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The code specifying the type of clinical activity that resulted in placing the associated content into the DocumentManifest.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Who or what the set of documents is about. The documents can be about a person, (patient or healthcare practitioner), a device (i.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). If the documents cross more than one subject, then more than one subject is allowed here (unusual use case). (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Who or what the set of documents is about. The documents can be about a person, (patient or healthcare practitioner), a device (i.e. machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). If the documents cross more than one subject, then more than one subject is allowed here (unusual use case).
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to When the document manifest was created for submission to the server (not necessarily the same thing as the actual resource last modified time, since it may be modified, replicated, etc.).
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // When the document manifest was created for submission to the server (not necessarily the same thing as the actual resource last modified time, since it may be modified, replicated, etc.).
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Identifies who is the author of the manifest. Manifest author is not necessarly the author of the references included.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // A patient, practitioner, or organization for which this set of documents is intended.
    property recipientList : TFhirReferenceList read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

    // Typed access to Identifies the source system, application, or software that produced the document manifest.
    property source : String read GetSourceST write SetSourceST;
    // Identifies the source system, application, or software that produced the document manifest.
    property sourceElement : TFhirUri read FSource write SetSource;

    // Typed access to Human-readable description of the source document. This is sometimes known as the "title".
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable description of the source document. This is sometimes known as the "title".
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // The list of Resources that consist of the parts of this manifest.
    property contentList : TFhirReferenceList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Related identifiers or resources associated with the DocumentManifest.
    property relatedList : TFhirDocumentManifestRelatedList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

  end;

  TFhirDocumentManifestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentManifestList;
    function GetCurrent : TFhirDocumentManifest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDocumentManifestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentManifest read GetCurrent;
  end;

  TFhirDocumentManifestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentManifest;
    procedure SetItemN(index : Integer; value : TFhirDocumentManifest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentManifestList; overload;
    function Clone : TFhirDocumentManifestList; overload;
    function GetEnumerator : TFhirDocumentManifestListEnumerator;
    
    //  Add a FhirDocumentManifest to the end of the list.
    function Append : TFhirDocumentManifest;
    
    // Add an already existing FhirDocumentManifest to the end of the list.
    function AddItem(value : TFhirDocumentManifest) : TFhirDocumentManifest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentManifest) : Integer;
    
    // Insert FhirDocumentManifest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentManifest;
    
    // Insert an existing FhirDocumentManifest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentManifest);
    
    // Get the iIndexth FhirDocumentManifest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentManifest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentManifest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentManifests[index : Integer] : TFhirDocumentManifest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
  // Relationships that this document has with other document references that already exist.
  TFhirDocumentReferenceRelatesTo = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FTarget : TFhirReference;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirDocumentRelationshipTypeEnum;
    procedure SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
    procedure SetTarget(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceRelatesTo; overload;
    function Clone : TFhirDocumentReferenceRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of relationship that this document has with anther document.
    property code : TFhirDocumentRelationshipTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to The target document of this relationship. (defined for API consistency)
    property target : TFhirReference read FTarget write SetTarget;
    // The target document of this relationship.
    property targetElement : TFhirReference read FTarget write SetTarget;

  end;

  TFhirDocumentReferenceRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceRelatesToList;
    function GetCurrent : TFhirDocumentReferenceRelatesTo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceRelatesTo read GetCurrent;
  end;

  TFhirDocumentReferenceRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentReferenceRelatesToList; overload;
    function Clone : TFhirDocumentReferenceRelatesToList; overload;
    function GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;
    
    //  Add a FhirDocumentReferenceRelatesTo to the end of the list.
    function Append : TFhirDocumentReferenceRelatesTo;
    
    // Add an already existing FhirDocumentReferenceRelatesTo to the end of the list.
    function AddItem(value : TFhirDocumentReferenceRelatesTo) : TFhirDocumentReferenceRelatesTo; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceRelatesTo) : Integer;
    
    // Insert FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceRelatesTo;
    
    // Insert an existing FhirDocumentReferenceRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceRelatesTo);
    
    // Get the iIndexth FhirDocumentReferenceRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceRelatesTo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceRelatesTo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentReferenceRelatesTos[index : Integer] : TFhirDocumentReferenceRelatesTo read GetItemN write SetItemN; default;
  End;

  // The document and format referenced. There may be multiple content element repetitions, each with a different format.
  TFhirDocumentReferenceContent = class (TFhirBackboneElement)
  protected
    FAttachment : TFhirAttachment;
    FFormat : TFhirCoding;
    procedure SetAttachment(value : TFhirAttachment);
    procedure SetFormat(value : TFhirCoding);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceContent; overload;
    function Clone : TFhirDocumentReferenceContent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The document or URL of the document along with critical metadata to prove content has integrity. (defined for API consistency)
    property attachment : TFhirAttachment read FAttachment write SetAttachment;
    // The document or URL of the document along with critical metadata to prove content has integrity.
    property attachmentElement : TFhirAttachment read FAttachment write SetAttachment;

    // Typed access to An identifier of the document encoding, structure, and template that the document conforms to beyond the base format indicated in the mimeType. (defined for API consistency)
    property format : TFhirCoding read FFormat write SetFormat;
    // An identifier of the document encoding, structure, and template that the document conforms to beyond the base format indicated in the mimeType.
    property formatElement : TFhirCoding read FFormat write SetFormat;

  end;

  TFhirDocumentReferenceContentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContentList;
    function GetCurrent : TFhirDocumentReferenceContent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceContentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContent read GetCurrent;
  end;

  TFhirDocumentReferenceContentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceContent;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentReferenceContentList; overload;
    function Clone : TFhirDocumentReferenceContentList; overload;
    function GetEnumerator : TFhirDocumentReferenceContentListEnumerator;
    
    //  Add a FhirDocumentReferenceContent to the end of the list.
    function Append : TFhirDocumentReferenceContent;
    
    // Add an already existing FhirDocumentReferenceContent to the end of the list.
    function AddItem(value : TFhirDocumentReferenceContent) : TFhirDocumentReferenceContent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceContent) : Integer;
    
    // Insert FhirDocumentReferenceContent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceContent;
    
    // Insert an existing FhirDocumentReferenceContent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContent);
    
    // Get the iIndexth FhirDocumentReferenceContent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceContent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentReferenceContents[index : Integer] : TFhirDocumentReferenceContent read GetItemN write SetItemN; default;
  End;

  // The clinical context in which the document was prepared.
  TFhirDocumentReferenceContext = class (TFhirBackboneElement)
  protected
    FencounterList : TFhirReferenceList;
    FeventList : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FFacilityType : TFhirCodeableConcept;
    FPracticeSetting : TFhirCodeableConcept;
    FSourcePatientInfo : TFhirReference;
    FrelatedList : TFhirReferenceList;
    function GetEncounterList : TFhirReferenceList;
    function GetHasEncounterList : Boolean;
    function GetEventList : TFhirCodeableConceptList;
    function GetHasEventList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetFacilityType(value : TFhirCodeableConcept);
    procedure SetPracticeSetting(value : TFhirCodeableConcept);
    procedure SetSourcePatientInfo(value : TFhirReference);
    function GetRelatedList : TFhirReferenceList;
    function GetHasRelatedList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReferenceContext; overload;
    function Clone : TFhirDocumentReferenceContext; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Describes the clinical encounter or type of care that the document content is associated with.
    property encounterList : TFhirReferenceList read GetEncounterList;
    property hasEncounterList : boolean read GetHasEncounterList;

    // This list of codes represents the main clinical acts, such as a colonoscopy or an appendectomy, being documented. In some cases, the event is inherent in the type Code, such as a "History and Physical Report" in which the procedure being documented is necessarily a "History and Physical" act.
    property eventList : TFhirCodeableConceptList read GetEventList;
    property hasEventList : boolean read GetHasEventList;

    // Typed access to The time period over which the service that is described by the document was provided. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time period over which the service that is described by the document was provided.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The kind of facility where the patient was seen. (defined for API consistency)
    property facilityType : TFhirCodeableConcept read FFacilityType write SetFacilityType;
    // The kind of facility where the patient was seen.
    property facilityTypeElement : TFhirCodeableConcept read FFacilityType write SetFacilityType;

    // Typed access to This property may convey specifics about the practice setting where the content was created, often reflecting the clinical specialty. (defined for API consistency)
    property practiceSetting : TFhirCodeableConcept read FPracticeSetting write SetPracticeSetting;
    // This property may convey specifics about the practice setting where the content was created, often reflecting the clinical specialty.
    property practiceSettingElement : TFhirCodeableConcept read FPracticeSetting write SetPracticeSetting;

    // Typed access to The Patient Information as known when the document was published. May be a reference to a version specific, or contained. (defined for API consistency)
    property sourcePatientInfo : TFhirReference read FSourcePatientInfo write SetSourcePatientInfo;
    // The Patient Information as known when the document was published. May be a reference to a version specific, or contained.
    property sourcePatientInfoElement : TFhirReference read FSourcePatientInfo write SetSourcePatientInfo;

    // Related identifiers or resources associated with the DocumentReference.
    property relatedList : TFhirReferenceList read GetRelatedList;
    property hasRelatedList : boolean read GetHasRelatedList;

  end;

  TFhirDocumentReferenceContextListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceContextList;
    function GetCurrent : TFhirDocumentReferenceContext;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceContextList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReferenceContext read GetCurrent;
  end;

  TFhirDocumentReferenceContextList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReferenceContext;
    procedure SetItemN(index : Integer; value : TFhirDocumentReferenceContext);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentReferenceContextList; overload;
    function Clone : TFhirDocumentReferenceContextList; overload;
    function GetEnumerator : TFhirDocumentReferenceContextListEnumerator;
    
    //  Add a FhirDocumentReferenceContext to the end of the list.
    function Append : TFhirDocumentReferenceContext;
    
    // Add an already existing FhirDocumentReferenceContext to the end of the list.
    function AddItem(value : TFhirDocumentReferenceContext) : TFhirDocumentReferenceContext; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReferenceContext) : Integer;
    
    // Insert FhirDocumentReferenceContext before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReferenceContext;
    
    // Insert an existing FhirDocumentReferenceContext before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReferenceContext);
    
    // Get the iIndexth FhirDocumentReferenceContext. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReferenceContext);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReferenceContext;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentReferenceContexts[index : Integer] : TFhirDocumentReferenceContext read GetItemN write SetItemN; default;
  End;

  // A reference to a document of any kind for any purpose. Provides metadata about the document so that the document can be discovered and managed. The scope of a document is any seralized object with a mime-type, so includes formal patient centric documents (CDA), cliical notes, scanned paper, and non-patient specific documents like policy text.
  TFhirDocumentReference = class (TFhirDomainResource)
  protected
    FMasterIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FDocStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FSubject : TFhirReference;
    FDate : TFhirInstant;
    FauthorList : TFhirReferenceList;
    FAuthenticator : TFhirReference;
    FCustodian : TFhirReference;
    FrelatesToList : TFhirDocumentReferenceRelatesToList;
    FDescription : TFhirString;
    FsecurityLabelList : TFhirCodeableConceptList;
    FcontentList : TFhirDocumentReferenceContentList;
    FContext : TFhirDocumentReferenceContext;
    procedure SetMasterIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirDocumentReferenceStatusEnum;
    procedure SetStatusST(value : TFhirDocumentReferenceStatusEnum);
    procedure SetDocStatus(value : TFhirEnum);
    function GetDocStatusST : TFhirCompositionStatusEnum;
    procedure SetDocStatusST(value : TFhirCompositionStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetDate(value : TFhirInstant);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    procedure SetAuthenticator(value : TFhirReference);
    procedure SetCustodian(value : TFhirReference);
    function GetRelatesToList : TFhirDocumentReferenceRelatesToList;
    function GetHasRelatesToList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetSecurityLabelList : TFhirCodeableConceptList;
    function GetHasSecurityLabelList : Boolean;
    function GetContentList : TFhirDocumentReferenceContentList;
    function GetHasContentList : Boolean;
    procedure SetContext(value : TFhirDocumentReferenceContext);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDocumentReference; overload;
    function Clone : TFhirDocumentReference; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Document identifier as assigned by the source of the document. This identifier is specific to this version of the document. This unique identifier may be used elsewhere to identify this version of the document. (defined for API consistency)
    property masterIdentifier : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;
    // Document identifier as assigned by the source of the document. This identifier is specific to this version of the document. This unique identifier may be used elsewhere to identify this version of the document.
    property masterIdentifierElement : TFhirIdentifier read FMasterIdentifier write SetMasterIdentifier;

    // Other identifiers associated with the document, including version independent identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of this document reference.
    property status : TFhirDocumentReferenceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The status of the underlying document.
    property docStatus : TFhirCompositionStatusEnum read GetDocStatusST write SetDocStatusST;
    property docStatusElement : TFhirEnum read FDocStatus write SetDocStatus;

    // Typed access to Specifies the particular kind of document referenced  (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the document referenced. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the particular kind of document referenced  (e.g. History and Physical, Discharge Summary, Progress Note). This usually equates to the purpose of making the document referenced.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // A categorization for the type of document referenced - helps for indexing and searching. This may be implied by or derived from the code specified in the DocumentReference.type.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Who or what the document is about. The document can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure). (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Who or what the document is about. The document can be about a person, (patient or healthcare practitioner), a device (e.g. a machine) or even a group of subjects (such as a document about a herd of farm animals, or a set of patients that share a common exposure).
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to When the document reference was created.
    property date : TFslDateTime read GetDateST write SetDateST;
    // When the document reference was created.
    property dateElement : TFhirInstant read FDate write SetDate;

    // Identifies who is responsible for adding the information to the document.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to Which person or organization authenticates that this document is valid. (defined for API consistency)
    property authenticator : TFhirReference read FAuthenticator write SetAuthenticator;
    // Which person or organization authenticates that this document is valid.
    property authenticatorElement : TFhirReference read FAuthenticator write SetAuthenticator;

    // Typed access to Identifies the organization or group who is responsible for ongoing maintenance of and access to the document. (defined for API consistency)
    property custodian : TFhirReference read FCustodian write SetCustodian;
    // Identifies the organization or group who is responsible for ongoing maintenance of and access to the document.
    property custodianElement : TFhirReference read FCustodian write SetCustodian;

    // Relationships that this document has with other document references that already exist.
    property relatesToList : TFhirDocumentReferenceRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // Typed access to Human-readable description of the source document.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable description of the source document.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // A set of Security-Tag codes specifying the level of privacy/security of the Document. Note that DocumentReference.meta.security contains the security labels of the "reference" to the document, while DocumentReference.securityLabel contains a snapshot of the security labels on the document the reference refers to.
    property securityLabelList : TFhirCodeableConceptList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // The document and format referenced. There may be multiple content element repetitions, each with a different format.
    property contentList : TFhirDocumentReferenceContentList read GetContentList;
    property hasContentList : boolean read GetHasContentList;

    // Typed access to The clinical context in which the document was prepared. (defined for API consistency)
    property context : TFhirDocumentReferenceContext read FContext write SetContext;
    // The clinical context in which the document was prepared.
    property contextElement : TFhirDocumentReferenceContext read FContext write SetContext;

  end;

  TFhirDocumentReferenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDocumentReferenceList;
    function GetCurrent : TFhirDocumentReference;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDocumentReferenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDocumentReference read GetCurrent;
  end;

  TFhirDocumentReferenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDocumentReference;
    procedure SetItemN(index : Integer; value : TFhirDocumentReference);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDocumentReferenceList; overload;
    function Clone : TFhirDocumentReferenceList; overload;
    function GetEnumerator : TFhirDocumentReferenceListEnumerator;
    
    //  Add a FhirDocumentReference to the end of the list.
    function Append : TFhirDocumentReference;
    
    // Add an already existing FhirDocumentReference to the end of the list.
    function AddItem(value : TFhirDocumentReference) : TFhirDocumentReference; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDocumentReference) : Integer;
    
    // Insert FhirDocumentReference before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDocumentReference;
    
    // Insert an existing FhirDocumentReference before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDocumentReference);
    
    // Get the iIndexth FhirDocumentReference. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDocumentReference);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDocumentReference;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDocumentReferences[index : Integer] : TFhirDocumentReference read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EPISODEOFCARE}
  // The history of statuses that the EpisodeOfCare has been through (without requiring processing the history of the resource).
  TFhirEpisodeOfCareStatusHistory = class (TFhirBackboneElement)
  protected
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEpisodeOfCareStatusEnum;
    procedure SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEpisodeOfCareStatusHistory; overload;
    function Clone : TFhirEpisodeOfCareStatusHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // planned | waitlist | active | onhold | finished | cancelled.
    property status : TFhirEpisodeOfCareStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The period during this EpisodeOfCare that the specific status applied. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during this EpisodeOfCare that the specific status applied.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEpisodeOfCareStatusHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEpisodeOfCareStatusHistoryList;
    function GetCurrent : TFhirEpisodeOfCareStatusHistory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEpisodeOfCareStatusHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEpisodeOfCareStatusHistory read GetCurrent;
  end;

  TFhirEpisodeOfCareStatusHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEpisodeOfCareStatusHistory;
    procedure SetItemN(index : Integer; value : TFhirEpisodeOfCareStatusHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEpisodeOfCareStatusHistoryList; overload;
    function Clone : TFhirEpisodeOfCareStatusHistoryList; overload;
    function GetEnumerator : TFhirEpisodeOfCareStatusHistoryListEnumerator;
    
    //  Add a FhirEpisodeOfCareStatusHistory to the end of the list.
    function Append : TFhirEpisodeOfCareStatusHistory;
    
    // Add an already existing FhirEpisodeOfCareStatusHistory to the end of the list.
    function AddItem(value : TFhirEpisodeOfCareStatusHistory) : TFhirEpisodeOfCareStatusHistory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEpisodeOfCareStatusHistory) : Integer;
    
    // Insert FhirEpisodeOfCareStatusHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEpisodeOfCareStatusHistory;
    
    // Insert an existing FhirEpisodeOfCareStatusHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEpisodeOfCareStatusHistory);
    
    // Get the iIndexth FhirEpisodeOfCareStatusHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEpisodeOfCareStatusHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEpisodeOfCareStatusHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEpisodeOfCareStatusHistories[index : Integer] : TFhirEpisodeOfCareStatusHistory read GetItemN write SetItemN; default;
  End;

  // The list of diagnosis relevant to this episode of care.
  TFhirEpisodeOfCareDiagnosis = class (TFhirBackboneElement)
  protected
    FCondition : TFhirReference;
    FRole : TFhirCodeableConcept;
    FRank : TFhirPositiveInt;
    procedure SetCondition(value : TFhirReference);
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetRank(value : TFhirPositiveInt);
    function GetRankST : String;
    procedure SetRankST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEpisodeOfCareDiagnosis; overload;
    function Clone : TFhirEpisodeOfCareDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A list of conditions/problems/diagnoses that this episode of care is intended to be providing care for. (defined for API consistency)
    property condition : TFhirReference read FCondition write SetCondition;
    // A list of conditions/problems/diagnoses that this episode of care is intended to be providing care for.
    property conditionElement : TFhirReference read FCondition write SetCondition;

    // Typed access to Role that this diagnosis has within the episode of care (e.g. admission, billing, discharge ). (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role that this diagnosis has within the episode of care (e.g. admission, billing, discharge ).
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to Ranking of the diagnosis (for each role type).
    property rank : String read GetRankST write SetRankST;
    // Ranking of the diagnosis (for each role type).
    property rankElement : TFhirPositiveInt read FRank write SetRank;

  end;

  TFhirEpisodeOfCareDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEpisodeOfCareDiagnosisList;
    function GetCurrent : TFhirEpisodeOfCareDiagnosis;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEpisodeOfCareDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEpisodeOfCareDiagnosis read GetCurrent;
  end;

  TFhirEpisodeOfCareDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEpisodeOfCareDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirEpisodeOfCareDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEpisodeOfCareDiagnosisList; overload;
    function Clone : TFhirEpisodeOfCareDiagnosisList; overload;
    function GetEnumerator : TFhirEpisodeOfCareDiagnosisListEnumerator;
    
    //  Add a FhirEpisodeOfCareDiagnosis to the end of the list.
    function Append : TFhirEpisodeOfCareDiagnosis;
    
    // Add an already existing FhirEpisodeOfCareDiagnosis to the end of the list.
    function AddItem(value : TFhirEpisodeOfCareDiagnosis) : TFhirEpisodeOfCareDiagnosis; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEpisodeOfCareDiagnosis) : Integer;
    
    // Insert FhirEpisodeOfCareDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEpisodeOfCareDiagnosis;
    
    // Insert an existing FhirEpisodeOfCareDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEpisodeOfCareDiagnosis);
    
    // Get the iIndexth FhirEpisodeOfCareDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEpisodeOfCareDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEpisodeOfCareDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEpisodeOfCareDiagnoses[index : Integer] : TFhirEpisodeOfCareDiagnosis read GetItemN write SetItemN; default;
  End;

  // An association between a patient and an organization / healthcare provider(s) during which time encounters may occur. The managing organization assumes a level of responsibility for the patient during this time.
  TFhirEpisodeOfCare = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FstatusHistoryList : TFhirEpisodeOfCareStatusHistoryList;
    Ftype_List : TFhirCodeableConceptList;
    FdiagnosisList : TFhirEpisodeOfCareDiagnosisList;
    FPatient : TFhirReference;
    FManagingOrganization : TFhirReference;
    FPeriod : TFhirPeriod;
    FreferralRequestList : TFhirReferenceList;
    FCareManager : TFhirReference;
    FteamList : TFhirReferenceList;
    FaccountList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEpisodeOfCareStatusEnum;
    procedure SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
    function GetStatusHistoryList : TFhirEpisodeOfCareStatusHistoryList;
    function GetHasStatusHistoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetDiagnosisList : TFhirEpisodeOfCareDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    procedure SetPatient(value : TFhirReference);
    procedure SetManagingOrganization(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    function GetReferralRequestList : TFhirReferenceList;
    function GetHasReferralRequestList : Boolean;
    procedure SetCareManager(value : TFhirReference);
    function GetTeamList : TFhirReferenceList;
    function GetHasTeamList : Boolean;
    function GetAccountList : TFhirReferenceList;
    function GetHasAccountList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEpisodeOfCare; overload;
    function Clone : TFhirEpisodeOfCare; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The EpisodeOfCare may be known by different identifiers for different contexts of use, such as when an external agency is tracking the Episode for funding purposes.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // planned | waitlist | active | onhold | finished | cancelled.
    property status : TFhirEpisodeOfCareStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The history of statuses that the EpisodeOfCare has been through (without requiring processing the history of the resource).
    property statusHistoryList : TFhirEpisodeOfCareStatusHistoryList read GetStatusHistoryList;
    property hasStatusHistoryList : boolean read GetHasStatusHistoryList;

    // A classification of the type of episode of care; e.g. specialist referral, disease management, type of funded care.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The list of diagnosis relevant to this episode of care.
    property diagnosisList : TFhirEpisodeOfCareDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // Typed access to The patient who is the focus of this episode of care. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient who is the focus of this episode of care.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The organization that has assumed the specific responsibilities for the specified duration. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization that has assumed the specific responsibilities for the specified duration.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Typed access to The interval during which the managing organization assumes the defined responsibility. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The interval during which the managing organization assumes the defined responsibility.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Referral Request(s) that are fulfilled by this EpisodeOfCare, incoming referrals.
    property referralRequestList : TFhirReferenceList read GetReferralRequestList;
    property hasReferralRequestList : boolean read GetHasReferralRequestList;

    // Typed access to The practitioner that is the care manager/care coordinator for this patient. (defined for API consistency)
    property careManager : TFhirReference read FCareManager write SetCareManager;
    // The practitioner that is the care manager/care coordinator for this patient.
    property careManagerElement : TFhirReference read FCareManager write SetCareManager;

    // The list of practitioners that may be facilitating this episode of care for specific purposes.
    property teamList : TFhirReferenceList read GetTeamList;
    property hasTeamList : boolean read GetHasTeamList;

    // The set of accounts that may be used for billing for this EpisodeOfCare.
    property accountList : TFhirReferenceList read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

  end;

  TFhirEpisodeOfCareListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEpisodeOfCareList;
    function GetCurrent : TFhirEpisodeOfCare;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEpisodeOfCareList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEpisodeOfCare read GetCurrent;
  end;

  TFhirEpisodeOfCareList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEpisodeOfCare;
    procedure SetItemN(index : Integer; value : TFhirEpisodeOfCare);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEpisodeOfCareList; overload;
    function Clone : TFhirEpisodeOfCareList; overload;
    function GetEnumerator : TFhirEpisodeOfCareListEnumerator;
    
    //  Add a FhirEpisodeOfCare to the end of the list.
    function Append : TFhirEpisodeOfCare;
    
    // Add an already existing FhirEpisodeOfCare to the end of the list.
    function AddItem(value : TFhirEpisodeOfCare) : TFhirEpisodeOfCare; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEpisodeOfCare) : Integer;
    
    // Insert FhirEpisodeOfCare before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEpisodeOfCare;
    
    // Insert an existing FhirEpisodeOfCare before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEpisodeOfCare);
    
    // Get the iIndexth FhirEpisodeOfCare. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEpisodeOfCare);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEpisodeOfCare;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEpisodeOfCares[index : Integer] : TFhirEpisodeOfCare read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
  // The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
  TFhirFamilyMemberHistoryCondition = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FOutcome : TFhirCodeableConcept;
    FContributedToDeath : TFhirBoolean;
    FOnset : TFhirDataType;
    FnoteList : TFhirAnnotationList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetOutcome(value : TFhirCodeableConcept);
    procedure SetContributedToDeath(value : TFhirBoolean);
    function GetContributedToDeathST : Boolean;
    procedure SetContributedToDeathST(value : Boolean);
    procedure SetOnset(value : TFhirDataType);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFamilyMemberHistoryCondition; overload;
    function Clone : TFhirFamilyMemberHistoryCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The actual condition specified. Could be a coded condition (like MI or Diabetes) or a less specific string like 'cancer' depending on how much is known about the condition and the capabilities of the creating system.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Indicates what happened following the condition.  If the condition resulted in death, deceased date is captured on the relation. (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // Indicates what happened following the condition.  If the condition resulted in death, deceased date is captured on the relation.
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to This condition contributed to the cause of death of the related person. If contributedToDeath is not populated, then it is unknown.
    property contributedToDeath : Boolean read GetContributedToDeathST write SetContributedToDeathST;
    // This condition contributed to the cause of death of the related person. If contributedToDeath is not populated, then it is unknown.
    property contributedToDeathElement : TFhirBoolean read FContributedToDeath write SetContributedToDeath;

    // Typed access to Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence. (defined for API consistency)
    property onset : TFhirDataType read FOnset write SetOnset;
    // Either the age of onset, range of approximate age or descriptive string can be recorded.  For conditions with multiple occurrences, this describes the first known occurrence.
    property onsetElement : TFhirDataType read FOnset write SetOnset;

    // An area where general notes can be placed about this specific condition.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirFamilyMemberHistoryConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFamilyMemberHistoryConditionList;
    function GetCurrent : TFhirFamilyMemberHistoryCondition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirFamilyMemberHistoryConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyMemberHistoryCondition read GetCurrent;
  end;

  TFhirFamilyMemberHistoryConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyMemberHistoryCondition;
    procedure SetItemN(index : Integer; value : TFhirFamilyMemberHistoryCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirFamilyMemberHistoryConditionList; overload;
    function Clone : TFhirFamilyMemberHistoryConditionList; overload;
    function GetEnumerator : TFhirFamilyMemberHistoryConditionListEnumerator;
    
    //  Add a FhirFamilyMemberHistoryCondition to the end of the list.
    function Append : TFhirFamilyMemberHistoryCondition;
    
    // Add an already existing FhirFamilyMemberHistoryCondition to the end of the list.
    function AddItem(value : TFhirFamilyMemberHistoryCondition) : TFhirFamilyMemberHistoryCondition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFamilyMemberHistoryCondition) : Integer;
    
    // Insert FhirFamilyMemberHistoryCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFamilyMemberHistoryCondition;
    
    // Insert an existing FhirFamilyMemberHistoryCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFamilyMemberHistoryCondition);
    
    // Get the iIndexth FhirFamilyMemberHistoryCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyMemberHistoryCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirFamilyMemberHistoryCondition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirFamilyMemberHistoryConditions[index : Integer] : TFhirFamilyMemberHistoryCondition read GetItemN write SetItemN; default;
  End;

  // Significant health conditions for a person related to the patient relevant in the context of care for the patient.
  TFhirFamilyMemberHistory = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FStatus : TFhirEnum;
    FDataAbsentReason : TFhirCodeableConcept;
    FPatient : TFhirReference;
    FDate : TFhirDateTime;
    FName : TFhirString;
    FRelationship : TFhirCodeableConcept;
    FSex : TFhirCodeableConcept;
    FBorn : TFhirDataType;
    FAge : TFhirDataType;
    FEstimatedAge : TFhirBoolean;
    FDeceased : TFhirDataType;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FconditionList : TFhirFamilyMemberHistoryConditionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFamilyHistoryStatusEnum;
    procedure SetStatusST(value : TFhirFamilyHistoryStatusEnum);
    procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    procedure SetPatient(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetRelationship(value : TFhirCodeableConcept);
    procedure SetSex(value : TFhirCodeableConcept);
    procedure SetBorn(value : TFhirDataType);
    procedure SetAge(value : TFhirDataType);
    procedure SetEstimatedAge(value : TFhirBoolean);
    function GetEstimatedAgeST : Boolean;
    procedure SetEstimatedAgeST(value : Boolean);
    procedure SetDeceased(value : TFhirDataType);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetConditionList : TFhirFamilyMemberHistoryConditionList;
    function GetHasConditionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFamilyMemberHistory; overload;
    function Clone : TFhirFamilyMemberHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this family member history by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this FamilyMemberHistory.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this FamilyMemberHistory.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A code specifying the status of the record of the family history of a specific family member.
    property status : TFhirFamilyHistoryStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Describes why the family member's history is not available. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Describes why the family member's history is not available.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // Typed access to The person who this history concerns. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The person who this history concerns.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date (and possibly time) when the family member history was recorded or last updated.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date (and possibly time) when the family member history was recorded or last updated.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to This will either be a name or a description; e.g. "Aunt Susan", "my cousin with the red hair".
    property name : String read GetNameST write SetNameST;
    // This will either be a name or a description; e.g. "Aunt Susan", "my cousin with the red hair".
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The type of relationship this person has to the patient (father, mother, brother etc.). (defined for API consistency)
    property relationship : TFhirCodeableConcept read FRelationship write SetRelationship;
    // The type of relationship this person has to the patient (father, mother, brother etc.).
    property relationshipElement : TFhirCodeableConcept read FRelationship write SetRelationship;

    // Typed access to The birth sex of the family member. (defined for API consistency)
    property sex : TFhirCodeableConcept read FSex write SetSex;
    // The birth sex of the family member.
    property sexElement : TFhirCodeableConcept read FSex write SetSex;

    // Typed access to The actual or approximate date of birth of the relative. (defined for API consistency)
    property born : TFhirDataType read FBorn write SetBorn;
    // The actual or approximate date of birth of the relative.
    property bornElement : TFhirDataType read FBorn write SetBorn;

    // Typed access to The age of the relative at the time the family member history is recorded. (defined for API consistency)
    property age : TFhirDataType read FAge write SetAge;
    // The age of the relative at the time the family member history is recorded.
    property ageElement : TFhirDataType read FAge write SetAge;

    // Typed access to If true, indicates that the age value specified is an estimated value.
    property estimatedAge : Boolean read GetEstimatedAgeST write SetEstimatedAgeST;
    // If true, indicates that the age value specified is an estimated value.
    property estimatedAgeElement : TFhirBoolean read FEstimatedAge write SetEstimatedAge;

    // Typed access to Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record. (defined for API consistency)
    property deceased : TFhirDataType read FDeceased write SetDeceased;
    // Deceased flag or the actual or approximate age of the relative at the time of death for the family member history record.
    property deceasedElement : TFhirDataType read FDeceased write SetDeceased;

    // Describes why the family member history occurred in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates a Condition, Observation, AllergyIntolerance, or QuestionnaireResponse that justifies this family member history event.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // This property allows a non condition-specific note to the made about the related person. Ideally, the note would be in the condition property, but this is not always possible.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The significant Conditions (or condition) that the family member had. This is a repeating section to allow a system to represent more than one condition per resource, though there is nothing stopping multiple resources - one per condition.
    property conditionList : TFhirFamilyMemberHistoryConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

  end;

  TFhirFamilyMemberHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFamilyMemberHistoryList;
    function GetCurrent : TFhirFamilyMemberHistory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirFamilyMemberHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFamilyMemberHistory read GetCurrent;
  end;

  TFhirFamilyMemberHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFamilyMemberHistory;
    procedure SetItemN(index : Integer; value : TFhirFamilyMemberHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirFamilyMemberHistoryList; overload;
    function Clone : TFhirFamilyMemberHistoryList; overload;
    function GetEnumerator : TFhirFamilyMemberHistoryListEnumerator;
    
    //  Add a FhirFamilyMemberHistory to the end of the list.
    function Append : TFhirFamilyMemberHistory;
    
    // Add an already existing FhirFamilyMemberHistory to the end of the list.
    function AddItem(value : TFhirFamilyMemberHistory) : TFhirFamilyMemberHistory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFamilyMemberHistory) : Integer;
    
    // Insert FhirFamilyMemberHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFamilyMemberHistory;
    
    // Insert an existing FhirFamilyMemberHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFamilyMemberHistory);
    
    // Get the iIndexth FhirFamilyMemberHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFamilyMemberHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirFamilyMemberHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirFamilyMemberHistories[index : Integer] : TFhirFamilyMemberHistory read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
  // Prospective warnings of potential issues when providing care to the patient.
  TFhirFlag = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FPeriod : TFhirPeriod;
    FEncounter : TFhirReference;
    FAuthor : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFlagStatusEnum;
    procedure SetStatusST(value : TFhirFlagStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetEncounter(value : TFhirReference);
    procedure SetAuthor(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirFlag; overload;
    function Clone : TFhirFlag; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this flag by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Supports basic workflow.
    property status : TFhirFlagStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Allows a flag to be divided into different categories like clinical, administrative etc. Intended to be used as a means of filtering which flags are displayed to particular user or in a given context.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The coded value or textual component of the flag to display to the user. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The coded value or textual component of the flag to display to the user.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient, location, group, organization, or practitioner etc. this is about record this flag is associated with. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient, location, group, organization, or practitioner etc. this is about record this flag is associated with.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The period of time from the activation of the flag to inactivation of the flag. If the flag is active, the end of the period should be unspecified. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time from the activation of the flag to inactivation of the flag. If the flag is active, the end of the period should be unspecified.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to This alert is only relevant during the encounter. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // This alert is only relevant during the encounter.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The person, organization or device that created the flag. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // The person, organization or device that created the flag.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

  end;

  TFhirFlagListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirFlagList;
    function GetCurrent : TFhirFlag;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirFlagList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirFlag read GetCurrent;
  end;

  TFhirFlagList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirFlag;
    procedure SetItemN(index : Integer; value : TFhirFlag);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirFlagList; overload;
    function Clone : TFhirFlagList; overload;
    function GetEnumerator : TFhirFlagListEnumerator;
    
    //  Add a FhirFlag to the end of the list.
    function Append : TFhirFlag;
    
    // Add an already existing FhirFlag to the end of the list.
    function AddItem(value : TFhirFlag) : TFhirFlag; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirFlag) : Integer;
    
    // Insert FhirFlag before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirFlag;
    
    // Insert an existing FhirFlag before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirFlag);
    
    // Get the iIndexth FhirFlag. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirFlag);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirFlag;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirFlags[index : Integer] : TFhirFlag read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
  // Indicates what should be done by when.
  TFhirGoalTarget = class (TFhirBackboneElement)
  protected
    FMeasure : TFhirCodeableConcept;
    FDetail : TFhirDataType;
    FDue : TFhirDataType;
    procedure SetMeasure(value : TFhirCodeableConcept);
    procedure SetDetail(value : TFhirDataType);
    procedure SetDue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGoalTarget; overload;
    function Clone : TFhirGoalTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The parameter whose value is being tracked, e.g. body weight, blood pressure, or hemoglobin A1c level. (defined for API consistency)
    property measure : TFhirCodeableConcept read FMeasure write SetMeasure;
    // The parameter whose value is being tracked, e.g. body weight, blood pressure, or hemoglobin A1c level.
    property measureElement : TFhirCodeableConcept read FMeasure write SetMeasure;

    // Typed access to The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value. (defined for API consistency)
    property detail : TFhirDataType read FDetail write SetDetail;
    // The target value of the focus to be achieved to signify the fulfillment of the goal, e.g. 150 pounds, 7.0%. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any focus value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any focus value at or above the low value.
    property detailElement : TFhirDataType read FDetail write SetDetail;

    // Typed access to Indicates either the date or the duration after start by which the goal should be met. (defined for API consistency)
    property due : TFhirDataType read FDue write SetDue;
    // Indicates either the date or the duration after start by which the goal should be met.
    property dueElement : TFhirDataType read FDue write SetDue;

  end;

  TFhirGoalTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGoalTargetList;
    function GetCurrent : TFhirGoalTarget;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGoalTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGoalTarget read GetCurrent;
  end;

  TFhirGoalTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGoalTarget;
    procedure SetItemN(index : Integer; value : TFhirGoalTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGoalTargetList; overload;
    function Clone : TFhirGoalTargetList; overload;
    function GetEnumerator : TFhirGoalTargetListEnumerator;
    
    //  Add a FhirGoalTarget to the end of the list.
    function Append : TFhirGoalTarget;
    
    // Add an already existing FhirGoalTarget to the end of the list.
    function AddItem(value : TFhirGoalTarget) : TFhirGoalTarget; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGoalTarget) : Integer;
    
    // Insert FhirGoalTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGoalTarget;
    
    // Insert an existing FhirGoalTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGoalTarget);
    
    // Get the iIndexth FhirGoalTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGoalTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGoalTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGoalTargets[index : Integer] : TFhirGoalTarget read GetItemN write SetItemN; default;
  End;

  // Describes the intended objective(s) for a patient, group or organization care, for example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, etc.
  TFhirGoal = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FLifecycleStatus : TFhirEnum;
    FAchievementStatus : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirCodeableConcept;
    FDescription : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FStart : TFhirDataType;
    FtargetList : TFhirGoalTargetList;
    FStatusDate : TFhirDate;
    FStatusReason : TFhirString;
    FExpressedBy : TFhirReference;
    FaddressesList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FoutcomeCodeList : TFhirCodeableConceptList;
    FoutcomeReferenceList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetLifecycleStatus(value : TFhirEnum);
    function GetLifecycleStatusST : TFhirGoalLifecycleStatusEnum;
    procedure SetLifecycleStatusST(value : TFhirGoalLifecycleStatusEnum);
    procedure SetAchievementStatus(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetStart(value : TFhirDataType);
    function GetTargetList : TFhirGoalTargetList;
    function GetHasTargetList : Boolean;
    procedure SetStatusDate(value : TFhirDate);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetStatusReason(value : TFhirString);
    function GetStatusReasonST : String;
    procedure SetStatusReasonST(value : String);
    procedure SetExpressedBy(value : TFhirReference);
    function GetAddressesList : TFhirReferenceList;
    function GetHasAddressesList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetOutcomeCodeList : TFhirCodeableConceptList;
    function GetHasOutcomeCodeList : Boolean;
    function GetOutcomeReferenceList : TFhirReferenceList;
    function GetHasOutcomeReferenceList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGoal; overload;
    function Clone : TFhirGoal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this goal by the performer or other systems which remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The state of the goal throughout its lifecycle.
    property lifecycleStatus : TFhirGoalLifecycleStatusEnum read GetLifecycleStatusST write SetLifecycleStatusST;
    property lifecycleStatusElement : TFhirEnum read FLifecycleStatus write SetLifecycleStatus;

    // Typed access to Describes the progression, or lack thereof, towards the goal against the target. (defined for API consistency)
    property achievementStatus : TFhirCodeableConcept read FAchievementStatus write SetAchievementStatus;
    // Describes the progression, or lack thereof, towards the goal against the target.
    property achievementStatusElement : TFhirCodeableConcept read FAchievementStatus write SetAchievementStatus;

    // Indicates a category the goal falls within.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Identifies the mutually agreed level of importance associated with reaching/sustaining the goal. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Identifies the mutually agreed level of importance associated with reaching/sustaining the goal.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding". (defined for API consistency)
    property description : TFhirCodeableConcept read FDescription write SetDescription;
    // Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding".
    property descriptionElement : TFhirCodeableConcept read FDescription write SetDescription;

    // Typed access to Identifies the patient, group or organization for whom the goal is being established. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Identifies the patient, group or organization for whom the goal is being established.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The date or event after which the goal should begin being pursued. (defined for API consistency)
    property start : TFhirDataType read FStart write SetStart;
    // The date or event after which the goal should begin being pursued.
    property startElement : TFhirDataType read FStart write SetStart;

    // Indicates what should be done by when.
    property targetList : TFhirGoalTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // Typed access to Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // Identifies when the current status.  I.e. When initially created, when achieved, when cancelled, etc.
    property statusDateElement : TFhirDate read FStatusDate write SetStatusDate;

    // Typed access to Captures the reason for the current status.
    property statusReason : String read GetStatusReasonST write SetStatusReasonST;
    // Captures the reason for the current status.
    property statusReasonElement : TFhirString read FStatusReason write SetStatusReason;

    // Typed access to Indicates whose goal this is - patient goal, practitioner goal, etc. (defined for API consistency)
    property expressedBy : TFhirReference read FExpressedBy write SetExpressedBy;
    // Indicates whose goal this is - patient goal, practitioner goal, etc.
    property expressedByElement : TFhirReference read FExpressedBy write SetExpressedBy;

    // The identified conditions and other health record elements that are intended to be addressed by the goal.
    property addressesList : TFhirReferenceList read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Any comments related to the goal.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Identifies the change (or lack of change) at the point when the status of the goal is assessed.
    property outcomeCodeList : TFhirCodeableConceptList read GetOutcomeCodeList;
    property hasOutcomeCodeList : boolean read GetHasOutcomeCodeList;

    // Details of what's changed (or not changed).
    property outcomeReferenceList : TFhirReferenceList read GetOutcomeReferenceList;
    property hasOutcomeReferenceList : boolean read GetHasOutcomeReferenceList;

  end;

  TFhirGoalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGoalList;
    function GetCurrent : TFhirGoal;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGoalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGoal read GetCurrent;
  end;

  TFhirGoalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGoal;
    procedure SetItemN(index : Integer; value : TFhirGoal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGoalList; overload;
    function Clone : TFhirGoalList; overload;
    function GetEnumerator : TFhirGoalListEnumerator;
    
    //  Add a FhirGoal to the end of the list.
    function Append : TFhirGoal;
    
    // Add an already existing FhirGoal to the end of the list.
    function AddItem(value : TFhirGoal) : TFhirGoal; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGoal) : Integer;
    
    // Insert FhirGoal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGoal;
    
    // Insert an existing FhirGoal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGoal);
    
    // Get the iIndexth FhirGoal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGoal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGoal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGoals[index : Integer] : TFhirGoal read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_IMAGINGSTUDY}
  // Each study has one or more series of images or other content.
  TFhirImagingStudySeries = class (TFhirBackboneElement)
  protected
    FUid : TFhirId;
    FNumber : TFhirUnsignedInt;
    FModality : TFhirCoding;
    FDescription : TFhirString;
    FNumberOfInstances : TFhirUnsignedInt;
    FendpointList : TFhirReferenceList;
    FBodySite : TFhirCoding;
    FLaterality : TFhirCoding;
    FspecimenList : TFhirReferenceList;
    FStarted : TFhirDateTime;
    FperformerList : TFhirImagingStudySeriesPerformerList;
    FinstanceList : TFhirImagingStudySeriesInstanceList;
    procedure SetUid(value : TFhirId);
    function GetUidST : String;
    procedure SetUidST(value : String);
    procedure SetNumber(value : TFhirUnsignedInt);
    function GetNumberST : String;
    procedure SetNumberST(value : String);
    procedure SetModality(value : TFhirCoding);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetNumberOfInstances(value : TFhirUnsignedInt);
    function GetNumberOfInstancesST : String;
    procedure SetNumberOfInstancesST(value : String);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
    procedure SetBodySite(value : TFhirCoding);
    procedure SetLaterality(value : TFhirCoding);
    function GetSpecimenList : TFhirReferenceList;
    function GetHasSpecimenList : Boolean;
    procedure SetStarted(value : TFhirDateTime);
    function GetStartedST : TFslDateTime;
    procedure SetStartedST(value : TFslDateTime);
    function GetPerformerList : TFhirImagingStudySeriesPerformerList;
    function GetHasPerformerList : Boolean;
    function GetInstanceList : TFhirImagingStudySeriesInstanceList;
    function GetHasInstanceList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeries; overload;
    function Clone : TFhirImagingStudySeries; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The DICOM Series Instance UID for the series.
    property uid : String read GetUidST write SetUidST;
    // The DICOM Series Instance UID for the series.
    property uidElement : TFhirId read FUid write SetUid;

    // Typed access to The numeric identifier of this series in the study.
    property number : String read GetNumberST write SetNumberST;
    // The numeric identifier of this series in the study.
    property numberElement : TFhirUnsignedInt read FNumber write SetNumber;

    // Typed access to The modality of this series sequence. (defined for API consistency)
    property modality : TFhirCoding read FModality write SetModality;
    // The modality of this series sequence.
    property modalityElement : TFhirCoding read FModality write SetModality;

    // Typed access to A description of the series.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the series.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Number of SOP Instances in the Study. The value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstances : String read GetNumberOfInstancesST write SetNumberOfInstancesST;
    // Number of SOP Instances in the Study. The value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstancesElement : TFhirUnsignedInt read FNumberOfInstances write SetNumberOfInstances;

    // The network service providing access (e.g., query, view, or retrieval) for this series. See implementation notes for information about using DICOM endpoints. A series-level endpoint, if present, has precedence over a study-level endpoint with the same Endpoint.connectionType.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Typed access to The anatomic structures examined. See DICOM Part 16 Annex L (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html) for DICOM to SNOMED-CT mappings. The bodySite may indicate the laterality of body part imaged; if so, it shall be consistent with any content of ImagingStudy.series.laterality. (defined for API consistency)
    property bodySite : TFhirCoding read FBodySite write SetBodySite;
    // The anatomic structures examined. See DICOM Part 16 Annex L (http://dicom.nema.org/medical/dicom/current/output/chtml/part16/chapter_L.html) for DICOM to SNOMED-CT mappings. The bodySite may indicate the laterality of body part imaged; if so, it shall be consistent with any content of ImagingStudy.series.laterality.
    property bodySiteElement : TFhirCoding read FBodySite write SetBodySite;

    // Typed access to The laterality of the (possibly paired) anatomic structures examined. E.g., the left knee, both lungs, or unpaired abdomen. If present, shall be consistent with any laterality information indicated in ImagingStudy.series.bodySite. (defined for API consistency)
    property laterality : TFhirCoding read FLaterality write SetLaterality;
    // The laterality of the (possibly paired) anatomic structures examined. E.g., the left knee, both lungs, or unpaired abdomen. If present, shall be consistent with any laterality information indicated in ImagingStudy.series.bodySite.
    property lateralityElement : TFhirCoding read FLaterality write SetLaterality;

    // The specimen imaged, e.g., for whole slide imaging of a biopsy.
    property specimenList : TFhirReferenceList read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // Typed access to The date and time the series was started.
    property started : TFslDateTime read GetStartedST write SetStartedST;
    // The date and time the series was started.
    property startedElement : TFhirDateTime read FStarted write SetStarted;

    // Indicates who or what performed the series and how they were involved.
    property performerList : TFhirImagingStudySeriesPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // A single SOP instance within the series, e.g. an image, or presentation state.
    property instanceList : TFhirImagingStudySeriesInstanceList read GetInstanceList;
    property hasInstanceList : boolean read GetHasInstanceList;

  end;

  TFhirImagingStudySeriesListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesList;
    function GetCurrent : TFhirImagingStudySeries;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeries read GetCurrent;
  end;

  TFhirImagingStudySeriesList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeries;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeries);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImagingStudySeriesList; overload;
    function Clone : TFhirImagingStudySeriesList; overload;
    function GetEnumerator : TFhirImagingStudySeriesListEnumerator;
    
    //  Add a FhirImagingStudySeries to the end of the list.
    function Append : TFhirImagingStudySeries;
    
    // Add an already existing FhirImagingStudySeries to the end of the list.
    function AddItem(value : TFhirImagingStudySeries) : TFhirImagingStudySeries; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeries) : Integer;
    
    // Insert FhirImagingStudySeries before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeries;
    
    // Insert an existing FhirImagingStudySeries before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeries);
    
    // Get the iIndexth FhirImagingStudySeries. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeries);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeries;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImagingStudySeries[index : Integer] : TFhirImagingStudySeries read GetItemN write SetItemN; default;
  End;

  // Indicates who or what performed the series and how they were involved.
  TFhirImagingStudySeriesPerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeriesPerformer; overload;
    function Clone : TFhirImagingStudySeriesPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distinguishes the type of involvement of the performer in the series. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Distinguishes the type of involvement of the performer in the series.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to Indicates who or what performed the series. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // Indicates who or what performed the series.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirImagingStudySeriesPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesPerformerList;
    function GetCurrent : TFhirImagingStudySeriesPerformer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeriesPerformer read GetCurrent;
  end;

  TFhirImagingStudySeriesPerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeriesPerformer;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeriesPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImagingStudySeriesPerformerList; overload;
    function Clone : TFhirImagingStudySeriesPerformerList; overload;
    function GetEnumerator : TFhirImagingStudySeriesPerformerListEnumerator;
    
    //  Add a FhirImagingStudySeriesPerformer to the end of the list.
    function Append : TFhirImagingStudySeriesPerformer;
    
    // Add an already existing FhirImagingStudySeriesPerformer to the end of the list.
    function AddItem(value : TFhirImagingStudySeriesPerformer) : TFhirImagingStudySeriesPerformer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeriesPerformer) : Integer;
    
    // Insert FhirImagingStudySeriesPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeriesPerformer;
    
    // Insert an existing FhirImagingStudySeriesPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeriesPerformer);
    
    // Get the iIndexth FhirImagingStudySeriesPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeriesPerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeriesPerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImagingStudySeriesPerformers[index : Integer] : TFhirImagingStudySeriesPerformer read GetItemN write SetItemN; default;
  End;

  // A single SOP instance within the series, e.g. an image, or presentation state.
  TFhirImagingStudySeriesInstance = class (TFhirBackboneElement)
  protected
    FUid : TFhirId;
    FSopClass : TFhirCoding;
    FNumber : TFhirUnsignedInt;
    FTitle : TFhirString;
    procedure SetUid(value : TFhirId);
    function GetUidST : String;
    procedure SetUidST(value : String);
    procedure SetSopClass(value : TFhirCoding);
    procedure SetNumber(value : TFhirUnsignedInt);
    function GetNumberST : String;
    procedure SetNumberST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudySeriesInstance; overload;
    function Clone : TFhirImagingStudySeriesInstance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The DICOM SOP Instance UID for this image or other DICOM content.
    property uid : String read GetUidST write SetUidST;
    // The DICOM SOP Instance UID for this image or other DICOM content.
    property uidElement : TFhirId read FUid write SetUid;

    // Typed access to DICOM instance  type. (defined for API consistency)
    property sopClass : TFhirCoding read FSopClass write SetSopClass;
    // DICOM instance  type.
    property sopClassElement : TFhirCoding read FSopClass write SetSopClass;

    // Typed access to The number of instance in the series.
    property number : String read GetNumberST write SetNumberST;
    // The number of instance in the series.
    property numberElement : TFhirUnsignedInt read FNumber write SetNumber;

    // Typed access to The description of the instance.
    property title : String read GetTitleST write SetTitleST;
    // The description of the instance.
    property titleElement : TFhirString read FTitle write SetTitle;

  end;

  TFhirImagingStudySeriesInstanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudySeriesInstanceList;
    function GetCurrent : TFhirImagingStudySeriesInstance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudySeriesInstanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudySeriesInstance read GetCurrent;
  end;

  TFhirImagingStudySeriesInstanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudySeriesInstance;
    procedure SetItemN(index : Integer; value : TFhirImagingStudySeriesInstance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImagingStudySeriesInstanceList; overload;
    function Clone : TFhirImagingStudySeriesInstanceList; overload;
    function GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;
    
    //  Add a FhirImagingStudySeriesInstance to the end of the list.
    function Append : TFhirImagingStudySeriesInstance;
    
    // Add an already existing FhirImagingStudySeriesInstance to the end of the list.
    function AddItem(value : TFhirImagingStudySeriesInstance) : TFhirImagingStudySeriesInstance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudySeriesInstance) : Integer;
    
    // Insert FhirImagingStudySeriesInstance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudySeriesInstance;
    
    // Insert an existing FhirImagingStudySeriesInstance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    // Get the iIndexth FhirImagingStudySeriesInstance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudySeriesInstance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudySeriesInstance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImagingStudySeriesInstances[index : Integer] : TFhirImagingStudySeriesInstance read GetItemN write SetItemN; default;
  End;

  // Representation of the content produced in a DICOM imaging study. A study comprises a set of series, each of which includes a set of Service-Object Pair Instances (SOP Instances - images or other data) acquired or produced in a common context.  A series is of only one modality (e.g. X-ray, CT, MR, ultrasound), but a study may have multiple series of different modalities.
  TFhirImagingStudy = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FmodalityList : TFhirCodingList;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FStarted : TFhirDateTime;
    FbasedOnList : TFhirReferenceList;
    FReferrer : TFhirReference;
    FinterpreterList : TFhirReferenceList;
    FendpointList : TFhirReferenceList;
    FNumberOfSeries : TFhirUnsignedInt;
    FNumberOfInstances : TFhirUnsignedInt;
    FProcedureReference : TFhirReference;
    FprocedureCodeList : TFhirCodeableConceptList;
    FLocation : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FDescription : TFhirString;
    FseriesList : TFhirImagingStudySeriesList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirImagingStudyStatusEnum;
    procedure SetStatusST(value : TFhirImagingStudyStatusEnum);
    function GetModalityList : TFhirCodingList;
    function GetHasModalityList : Boolean;
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetStarted(value : TFhirDateTime);
    function GetStartedST : TFslDateTime;
    procedure SetStartedST(value : TFslDateTime);
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetReferrer(value : TFhirReference);
    function GetInterpreterList : TFhirReferenceList;
    function GetHasInterpreterList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
    procedure SetNumberOfSeries(value : TFhirUnsignedInt);
    function GetNumberOfSeriesST : String;
    procedure SetNumberOfSeriesST(value : String);
    procedure SetNumberOfInstances(value : TFhirUnsignedInt);
    function GetNumberOfInstancesST : String;
    procedure SetNumberOfInstancesST(value : String);
    procedure SetProcedureReference(value : TFhirReference);
    function GetProcedureCodeList : TFhirCodeableConceptList;
    function GetHasProcedureCodeList : Boolean;
    procedure SetLocation(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetSeriesList : TFhirImagingStudySeriesList;
    function GetHasSeriesList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImagingStudy; overload;
    function Clone : TFhirImagingStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers for the ImagingStudy such as DICOM Study Instance UID, and Accession Number.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the ImagingStudy.
    property status : TFhirImagingStudyStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A list of all the series.modality values that are actual acquisition modalities, i.e. those in the DICOM Context Group 29 (value set OID 1.2.840.10008.6.1.19).
    property modalityList : TFhirCodingList read GetModalityList;
    property hasModalityList : boolean read GetHasModalityList;

    // Typed access to The subject, typically a patient, of the imaging study. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The subject, typically a patient, of the imaging study.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The healthcare event (e.g. a patient and healthcare provider interaction) during which this ImagingStudy is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The healthcare event (e.g. a patient and healthcare provider interaction) during which this ImagingStudy is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Date and time the study started.
    property started : TFslDateTime read GetStartedST write SetStartedST;
    // Date and time the study started.
    property startedElement : TFhirDateTime read FStarted write SetStarted;

    // A list of the diagnostic requests that resulted in this imaging study being performed.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to The requesting/referring physician. (defined for API consistency)
    property referrer : TFhirReference read FReferrer write SetReferrer;
    // The requesting/referring physician.
    property referrerElement : TFhirReference read FReferrer write SetReferrer;

    // Who read the study and interpreted the images or other content.
    property interpreterList : TFhirReferenceList read GetInterpreterList;
    property hasInterpreterList : boolean read GetHasInterpreterList;

    // The network service providing access (e.g., query, view, or retrieval) for the study. See implementation notes for information about using DICOM endpoints. A study-level endpoint applies to each series in the study, unless overridden by a series-level endpoint with the same Endpoint.connectionType.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

    // Typed access to Number of Series in the Study. This value given may be larger than the number of series elements this Resource contains due to resource availability, security, or other factors. This element should be present if any series elements are present.
    property numberOfSeries : String read GetNumberOfSeriesST write SetNumberOfSeriesST;
    // Number of Series in the Study. This value given may be larger than the number of series elements this Resource contains due to resource availability, security, or other factors. This element should be present if any series elements are present.
    property numberOfSeriesElement : TFhirUnsignedInt read FNumberOfSeries write SetNumberOfSeries;

    // Typed access to Number of SOP Instances in Study. This value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstances : String read GetNumberOfInstancesST write SetNumberOfInstancesST;
    // Number of SOP Instances in Study. This value given may be larger than the number of instance elements this resource contains due to resource availability, security, or other factors. This element should be present if any instance elements are present.
    property numberOfInstancesElement : TFhirUnsignedInt read FNumberOfInstances write SetNumberOfInstances;

    // Typed access to The procedure which this ImagingStudy was part of. (defined for API consistency)
    property procedureReference : TFhirReference read FProcedureReference write SetProcedureReference;
    // The procedure which this ImagingStudy was part of.
    property procedureReferenceElement : TFhirReference read FProcedureReference write SetProcedureReference;

    // The code for the performed procedure type.
    property procedureCodeList : TFhirCodeableConceptList read GetProcedureCodeList;
    property hasProcedureCodeList : boolean read GetHasProcedureCodeList;

    // Typed access to The principal physical location where the ImagingStudy was performed. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The principal physical location where the ImagingStudy was performed.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Description of clinical condition indicating why the ImagingStudy was requested.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies this Study.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Per the recommended DICOM mapping, this element is derived from the Study Description attribute (0008,1030). Observations or findings about the imaging study should be recorded in another resource, e.g. Observation, and not in this element.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The Imaging Manager description of the study. Institution-generated description or classification of the Study (component) performed.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The Imaging Manager description of the study. Institution-generated description or classification of the Study (component) performed.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Each study has one or more series of images or other content.
    property seriesList : TFhirImagingStudySeriesList read GetSeriesList;
    property hasSeriesList : boolean read GetHasSeriesList;

  end;

  TFhirImagingStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImagingStudyList;
    function GetCurrent : TFhirImagingStudy;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImagingStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImagingStudy read GetCurrent;
  end;

  TFhirImagingStudyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImagingStudy;
    procedure SetItemN(index : Integer; value : TFhirImagingStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImagingStudyList; overload;
    function Clone : TFhirImagingStudyList; overload;
    function GetEnumerator : TFhirImagingStudyListEnumerator;
    
    //  Add a FhirImagingStudy to the end of the list.
    function Append : TFhirImagingStudy;
    
    // Add an already existing FhirImagingStudy to the end of the list.
    function AddItem(value : TFhirImagingStudy) : TFhirImagingStudy; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImagingStudy) : Integer;
    
    // Insert FhirImagingStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImagingStudy;
    
    // Insert an existing FhirImagingStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImagingStudy);
    
    // Get the iIndexth FhirImagingStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImagingStudy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImagingStudy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImagingStudies[index : Integer] : TFhirImagingStudy read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
  // Indicates who performed the immunization event.
  TFhirImmunizationPerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationPerformer; overload;
    function Clone : TFhirImmunizationPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes the type of performance (e.g. ordering provider, administering provider, etc.). (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Describes the type of performance (e.g. ordering provider, administering provider, etc.).
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to The practitioner or organization who performed the action. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // The practitioner or organization who performed the action.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirImmunizationPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationPerformerList;
    function GetCurrent : TFhirImmunizationPerformer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationPerformer read GetCurrent;
  end;

  TFhirImmunizationPerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationPerformer;
    procedure SetItemN(index : Integer; value : TFhirImmunizationPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationPerformerList; overload;
    function Clone : TFhirImmunizationPerformerList; overload;
    function GetEnumerator : TFhirImmunizationPerformerListEnumerator;
    
    //  Add a FhirImmunizationPerformer to the end of the list.
    function Append : TFhirImmunizationPerformer;
    
    // Add an already existing FhirImmunizationPerformer to the end of the list.
    function AddItem(value : TFhirImmunizationPerformer) : TFhirImmunizationPerformer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationPerformer) : Integer;
    
    // Insert FhirImmunizationPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationPerformer;
    
    // Insert an existing FhirImmunizationPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationPerformer);
    
    // Get the iIndexth FhirImmunizationPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationPerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationPerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationPerformers[index : Integer] : TFhirImmunizationPerformer read GetItemN write SetItemN; default;
  End;

  // Educational material presented to the patient (or guardian) at the time of vaccine administration.
  TFhirImmunizationEducation = class (TFhirBackboneElement)
  protected
    FDocumentType : TFhirString;
    FReference : TFhirUri;
    FPublicationDate : TFhirDateTime;
    FPresentationDate : TFhirDateTime;
    procedure SetDocumentType(value : TFhirString);
    function GetDocumentTypeST : String;
    procedure SetDocumentTypeST(value : String);
    procedure SetReference(value : TFhirUri);
    function GetReferenceST : String;
    procedure SetReferenceST(value : String);
    procedure SetPublicationDate(value : TFhirDateTime);
    function GetPublicationDateST : TFslDateTime;
    procedure SetPublicationDateST(value : TFslDateTime);
    procedure SetPresentationDate(value : TFhirDateTime);
    function GetPresentationDateST : TFslDateTime;
    procedure SetPresentationDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationEducation; overload;
    function Clone : TFhirImmunizationEducation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier of the material presented to the patient.
    property documentType : String read GetDocumentTypeST write SetDocumentTypeST;
    // Identifier of the material presented to the patient.
    property documentTypeElement : TFhirString read FDocumentType write SetDocumentType;

    // Typed access to Reference pointer to the educational material given to the patient if the information was on line.
    property reference : String read GetReferenceST write SetReferenceST;
    // Reference pointer to the educational material given to the patient if the information was on line.
    property referenceElement : TFhirUri read FReference write SetReference;

    // Typed access to Date the educational material was published.
    property publicationDate : TFslDateTime read GetPublicationDateST write SetPublicationDateST;
    // Date the educational material was published.
    property publicationDateElement : TFhirDateTime read FPublicationDate write SetPublicationDate;

    // Typed access to Date the educational material was given to the patient.
    property presentationDate : TFslDateTime read GetPresentationDateST write SetPresentationDateST;
    // Date the educational material was given to the patient.
    property presentationDateElement : TFhirDateTime read FPresentationDate write SetPresentationDate;

  end;

  TFhirImmunizationEducationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationEducationList;
    function GetCurrent : TFhirImmunizationEducation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationEducationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationEducation read GetCurrent;
  end;

  TFhirImmunizationEducationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationEducation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationEducation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationEducationList; overload;
    function Clone : TFhirImmunizationEducationList; overload;
    function GetEnumerator : TFhirImmunizationEducationListEnumerator;
    
    //  Add a FhirImmunizationEducation to the end of the list.
    function Append : TFhirImmunizationEducation;
    
    // Add an already existing FhirImmunizationEducation to the end of the list.
    function AddItem(value : TFhirImmunizationEducation) : TFhirImmunizationEducation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationEducation) : Integer;
    
    // Insert FhirImmunizationEducation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationEducation;
    
    // Insert an existing FhirImmunizationEducation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationEducation);
    
    // Get the iIndexth FhirImmunizationEducation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationEducation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationEducation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationEducations[index : Integer] : TFhirImmunizationEducation read GetItemN write SetItemN; default;
  End;

  // Categorical data indicating that an adverse event is associated in time to an immunization.
  TFhirImmunizationReaction = class (TFhirBackboneElement)
  protected
    FDate : TFhirDateTime;
    FDetail : TFhirReference;
    FReported : TFhirBoolean;
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetDetail(value : TFhirReference);
    procedure SetReported(value : TFhirBoolean);
    function GetReportedST : Boolean;
    procedure SetReportedST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationReaction; overload;
    function Clone : TFhirImmunizationReaction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date of reaction to the immunization.
    property date : TFslDateTime read GetDateST write SetDateST;
    // Date of reaction to the immunization.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Details of the reaction. (defined for API consistency)
    property detail : TFhirReference read FDetail write SetDetail;
    // Details of the reaction.
    property detailElement : TFhirReference read FDetail write SetDetail;

    // Typed access to Self-reported indicator.
    property reported : Boolean read GetReportedST write SetReportedST;
    // Self-reported indicator.
    property reportedElement : TFhirBoolean read FReported write SetReported;

  end;

  TFhirImmunizationReactionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationReactionList;
    function GetCurrent : TFhirImmunizationReaction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationReactionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationReaction read GetCurrent;
  end;

  TFhirImmunizationReactionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationReaction;
    procedure SetItemN(index : Integer; value : TFhirImmunizationReaction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationReactionList; overload;
    function Clone : TFhirImmunizationReactionList; overload;
    function GetEnumerator : TFhirImmunizationReactionListEnumerator;
    
    //  Add a FhirImmunizationReaction to the end of the list.
    function Append : TFhirImmunizationReaction;
    
    // Add an already existing FhirImmunizationReaction to the end of the list.
    function AddItem(value : TFhirImmunizationReaction) : TFhirImmunizationReaction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationReaction) : Integer;
    
    // Insert FhirImmunizationReaction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationReaction;
    
    // Insert an existing FhirImmunizationReaction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationReaction);
    
    // Get the iIndexth FhirImmunizationReaction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationReaction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationReaction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationReactions[index : Integer] : TFhirImmunizationReaction read GetItemN write SetItemN; default;
  End;

  // The protocol (set of recommendations) being followed by the provider who administered the dose.
  TFhirImmunizationProtocolApplied = class (TFhirBackboneElement)
  protected
    FSeries : TFhirString;
    FAuthority : TFhirReference;
    FtargetDiseaseList : TFhirCodeableConceptList;
    FDoseNumber : TFhirDataType;
    FSeriesDoses : TFhirDataType;
    procedure SetSeries(value : TFhirString);
    function GetSeriesST : String;
    procedure SetSeriesST(value : String);
    procedure SetAuthority(value : TFhirReference);
    function GetTargetDiseaseList : TFhirCodeableConceptList;
    function GetHasTargetDiseaseList : Boolean;
    procedure SetDoseNumber(value : TFhirDataType);
    procedure SetSeriesDoses(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationProtocolApplied; overload;
    function Clone : TFhirImmunizationProtocolApplied; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

    // Typed access to Indicates the authority who published the protocol (e.g. ACIP) that is being followed. (defined for API consistency)
    property authority : TFhirReference read FAuthority write SetAuthority;
    // Indicates the authority who published the protocol (e.g. ACIP) that is being followed.
    property authorityElement : TFhirReference read FAuthority write SetAuthority;

    // The vaccine preventable disease the dose is being administered against.
    property targetDiseaseList : TFhirCodeableConceptList read GetTargetDiseaseList;
    property hasTargetDiseaseList : boolean read GetHasTargetDiseaseList;

    // Typed access to Nominal position in a series. (defined for API consistency)
    property doseNumber : TFhirDataType read FDoseNumber write SetDoseNumber;
    // Nominal position in a series.
    property doseNumberElement : TFhirDataType read FDoseNumber write SetDoseNumber;

    // Typed access to The recommended number of doses to achieve immunity. (defined for API consistency)
    property seriesDoses : TFhirDataType read FSeriesDoses write SetSeriesDoses;
    // The recommended number of doses to achieve immunity.
    property seriesDosesElement : TFhirDataType read FSeriesDoses write SetSeriesDoses;

  end;

  TFhirImmunizationProtocolAppliedListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationProtocolAppliedList;
    function GetCurrent : TFhirImmunizationProtocolApplied;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationProtocolAppliedList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationProtocolApplied read GetCurrent;
  end;

  TFhirImmunizationProtocolAppliedList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationProtocolApplied;
    procedure SetItemN(index : Integer; value : TFhirImmunizationProtocolApplied);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationProtocolAppliedList; overload;
    function Clone : TFhirImmunizationProtocolAppliedList; overload;
    function GetEnumerator : TFhirImmunizationProtocolAppliedListEnumerator;
    
    //  Add a FhirImmunizationProtocolApplied to the end of the list.
    function Append : TFhirImmunizationProtocolApplied;
    
    // Add an already existing FhirImmunizationProtocolApplied to the end of the list.
    function AddItem(value : TFhirImmunizationProtocolApplied) : TFhirImmunizationProtocolApplied; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationProtocolApplied) : Integer;
    
    // Insert FhirImmunizationProtocolApplied before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationProtocolApplied;
    
    // Insert an existing FhirImmunizationProtocolApplied before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationProtocolApplied);
    
    // Get the iIndexth FhirImmunizationProtocolApplied. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationProtocolApplied);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationProtocolApplied;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationProtocolApplieds[index : Integer] : TFhirImmunizationProtocolApplied read GetItemN write SetItemN; default;
  End;

  // Describes the event of a patient being administered a vaccine or a record of an immunization as reported by a patient, a clinician or another party.
  TFhirImmunization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FVaccineCode : TFhirCodeableConcept;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FRecorded : TFhirDateTime;
    FPrimarySource : TFhirBoolean;
    FReportOrigin : TFhirCodeableConcept;
    FLocation : TFhirReference;
    FManufacturer : TFhirReference;
    FLotNumber : TFhirString;
    FExpirationDate : TFhirDate;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FDoseQuantity : TFhirQuantity;
    FperformerList : TFhirImmunizationPerformerList;
    FnoteList : TFhirAnnotationList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FIsSubpotent : TFhirBoolean;
    FsubpotentReasonList : TFhirCodeableConceptList;
    FeducationList : TFhirImmunizationEducationList;
    FprogramEligibilityList : TFhirCodeableConceptList;
    FFundingSource : TFhirCodeableConcept;
    FreactionList : TFhirImmunizationReactionList;
    FprotocolAppliedList : TFhirImmunizationProtocolAppliedList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirImmunizationStatusCodesEnum;
    procedure SetStatusST(value : TFhirImmunizationStatusCodesEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetVaccineCode(value : TFhirCodeableConcept);
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetRecorded(value : TFhirDateTime);
    function GetRecordedST : TFslDateTime;
    procedure SetRecordedST(value : TFslDateTime);
    procedure SetPrimarySource(value : TFhirBoolean);
    function GetPrimarySourceST : Boolean;
    procedure SetPrimarySourceST(value : Boolean);
    procedure SetReportOrigin(value : TFhirCodeableConcept);
    procedure SetLocation(value : TFhirReference);
    procedure SetManufacturer(value : TFhirReference);
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetExpirationDate(value : TFhirDate);
    function GetExpirationDateST : TFslDateTime;
    procedure SetExpirationDateST(value : TFslDateTime);
    procedure SetSite(value : TFhirCodeableConcept);
    procedure SetRoute(value : TFhirCodeableConcept);
    procedure SetDoseQuantity(value : TFhirQuantity);
    function GetPerformerList : TFhirImmunizationPerformerList;
    function GetHasPerformerList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    procedure SetIsSubpotent(value : TFhirBoolean);
    function GetIsSubpotentST : Boolean;
    procedure SetIsSubpotentST(value : Boolean);
    function GetSubpotentReasonList : TFhirCodeableConceptList;
    function GetHasSubpotentReasonList : Boolean;
    function GetEducationList : TFhirImmunizationEducationList;
    function GetHasEducationList : Boolean;
    function GetProgramEligibilityList : TFhirCodeableConceptList;
    function GetHasProgramEligibilityList : Boolean;
    procedure SetFundingSource(value : TFhirCodeableConcept);
    function GetReactionList : TFhirImmunizationReactionList;
    function GetHasReactionList : Boolean;
    function GetProtocolAppliedList : TFhirImmunizationProtocolAppliedList;
    function GetHasProtocolAppliedList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunization; overload;
    function Clone : TFhirImmunization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this immunization record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current status of the immunization event.
    property status : TFhirImmunizationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Indicates the reason the immunization event was not performed. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Indicates the reason the immunization event was not performed.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to Vaccine that was administered or was to be administered. (defined for API consistency)
    property vaccineCode : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;
    // Vaccine that was administered or was to be administered.
    property vaccineCodeElement : TFhirCodeableConcept read FVaccineCode write SetVaccineCode;

    // Typed access to The patient who either received or did not receive the immunization. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient who either received or did not receive the immunization.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The visit or admission or other contact between patient and health care provider the immunization was performed as part of. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The visit or admission or other contact between patient and health care provider the immunization was performed as part of.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Date vaccine administered or was to be administered. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // Date vaccine administered or was to be administered.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to The date the occurrence of the immunization was first captured in the record - potentially significantly after the occurrence of the event.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The date the occurrence of the immunization was first captured in the record - potentially significantly after the occurrence of the event.
    property recordedElement : TFhirDateTime read FRecorded write SetRecorded;

    // Typed access to An indication that the content of the record is based on information from the person who administered the vaccine. This reflects the context under which the data was originally recorded.
    property primarySource : Boolean read GetPrimarySourceST write SetPrimarySourceST;
    // An indication that the content of the record is based on information from the person who administered the vaccine. This reflects the context under which the data was originally recorded.
    property primarySourceElement : TFhirBoolean read FPrimarySource write SetPrimarySource;

    // Typed access to The source of the data when the report of the immunization event is not based on information from the person who administered the vaccine. (defined for API consistency)
    property reportOrigin : TFhirCodeableConcept read FReportOrigin write SetReportOrigin;
    // The source of the data when the report of the immunization event is not based on information from the person who administered the vaccine.
    property reportOriginElement : TFhirCodeableConcept read FReportOrigin write SetReportOrigin;

    // Typed access to The service delivery location where the vaccine administration occurred. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The service delivery location where the vaccine administration occurred.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to Name of vaccine manufacturer. (defined for API consistency)
    property manufacturer : TFhirReference read FManufacturer write SetManufacturer;
    // Name of vaccine manufacturer.
    property manufacturerElement : TFhirReference read FManufacturer write SetManufacturer;

    // Typed access to Lot number of the  vaccine product.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // Lot number of the  vaccine product.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to Date vaccine batch expires.
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // Date vaccine batch expires.
    property expirationDateElement : TFhirDate read FExpirationDate write SetExpirationDate;

    // Typed access to Body site where vaccine was administered. (defined for API consistency)
    property site : TFhirCodeableConcept read FSite write SetSite;
    // Body site where vaccine was administered.
    property siteElement : TFhirCodeableConcept read FSite write SetSite;

    // Typed access to The path by which the vaccine product is taken into the body. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // The path by which the vaccine product is taken into the body.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to The quantity of vaccine product that was administered. (defined for API consistency)
    property doseQuantity : TFhirQuantity read FDoseQuantity write SetDoseQuantity;
    // The quantity of vaccine product that was administered.
    property doseQuantityElement : TFhirQuantity read FDoseQuantity write SetDoseQuantity;

    // Indicates who performed the immunization event.
    property performerList : TFhirImmunizationPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Extra information about the immunization that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Reasons why the vaccine was administered.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Condition, Observation or DiagnosticReport that supports why the immunization was administered.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Typed access to Indication if a dose is considered to be subpotent. By default, a dose should be considered to be potent.
    property isSubpotent : Boolean read GetIsSubpotentST write SetIsSubpotentST;
    // Indication if a dose is considered to be subpotent. By default, a dose should be considered to be potent.
    property isSubpotentElement : TFhirBoolean read FIsSubpotent write SetIsSubpotent;

    // Reason why a dose is considered to be subpotent.
    property subpotentReasonList : TFhirCodeableConceptList read GetSubpotentReasonList;
    property hasSubpotentReasonList : boolean read GetHasSubpotentReasonList;

    // Educational material presented to the patient (or guardian) at the time of vaccine administration.
    property educationList : TFhirImmunizationEducationList read GetEducationList;
    property hasEducationList : boolean read GetHasEducationList;

    // Indicates a patient's eligibility for a funding program.
    property programEligibilityList : TFhirCodeableConceptList read GetProgramEligibilityList;
    property hasProgramEligibilityList : boolean read GetHasProgramEligibilityList;

    // Typed access to Indicates the source of the vaccine actually administered. This may be different than the patient eligibility (e.g. the patient may be eligible for a publically purchased vaccine but due to inventory issues, vaccine purchased with private funds was actually administered). (defined for API consistency)
    property fundingSource : TFhirCodeableConcept read FFundingSource write SetFundingSource;
    // Indicates the source of the vaccine actually administered. This may be different than the patient eligibility (e.g. the patient may be eligible for a publically purchased vaccine but due to inventory issues, vaccine purchased with private funds was actually administered).
    property fundingSourceElement : TFhirCodeableConcept read FFundingSource write SetFundingSource;

    // Categorical data indicating that an adverse event is associated in time to an immunization.
    property reactionList : TFhirImmunizationReactionList read GetReactionList;
    property hasReactionList : boolean read GetHasReactionList;

    // The protocol (set of recommendations) being followed by the provider who administered the dose.
    property protocolAppliedList : TFhirImmunizationProtocolAppliedList read GetProtocolAppliedList;
    property hasProtocolAppliedList : boolean read GetHasProtocolAppliedList;

  end;

  TFhirImmunizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationList;
    function GetCurrent : TFhirImmunization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunization read GetCurrent;
  end;

  TFhirImmunizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunization;
    procedure SetItemN(index : Integer; value : TFhirImmunization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationList; overload;
    function Clone : TFhirImmunizationList; overload;
    function GetEnumerator : TFhirImmunizationListEnumerator;
    
    //  Add a FhirImmunization to the end of the list.
    function Append : TFhirImmunization;
    
    // Add an already existing FhirImmunization to the end of the list.
    function AddItem(value : TFhirImmunization) : TFhirImmunization; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunization) : Integer;
    
    // Insert FhirImmunization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunization;
    
    // Insert an existing FhirImmunization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunization);
    
    // Get the iIndexth FhirImmunization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizations[index : Integer] : TFhirImmunization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
  // Describes a comparison of an immunization event against published recommendations to determine if the administration is "valid" in relation to those  recommendations.
  TFhirImmunizationEvaluation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPatient : TFhirReference;
    FDate : TFhirDateTime;
    FAuthority : TFhirReference;
    FTargetDisease : TFhirCodeableConcept;
    FImmunizationEvent : TFhirReference;
    FDoseStatus : TFhirCodeableConcept;
    FdoseStatusReasonList : TFhirCodeableConceptList;
    FDescription : TFhirString;
    FSeries : TFhirString;
    FDoseNumber : TFhirDataType;
    FSeriesDoses : TFhirDataType;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirImmunizationEvaluationStatusCodesEnum;
    procedure SetStatusST(value : TFhirImmunizationEvaluationStatusCodesEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAuthority(value : TFhirReference);
    procedure SetTargetDisease(value : TFhirCodeableConcept);
    procedure SetImmunizationEvent(value : TFhirReference);
    procedure SetDoseStatus(value : TFhirCodeableConcept);
    function GetDoseStatusReasonList : TFhirCodeableConceptList;
    function GetHasDoseStatusReasonList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetSeries(value : TFhirString);
    function GetSeriesST : String;
    procedure SetSeriesST(value : String);
    procedure SetDoseNumber(value : TFhirDataType);
    procedure SetSeriesDoses(value : TFhirDataType);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationEvaluation; overload;
    function Clone : TFhirImmunizationEvaluation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this immunization evaluation record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current status of the evaluation of the vaccination administration event.
    property status : TFhirImmunizationEvaluationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The individual for whom the evaluation is being done. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The individual for whom the evaluation is being done.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date the evaluation of the vaccine administration event was performed.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date the evaluation of the vaccine administration event was performed.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Indicates the authority who published the protocol (e.g. ACIP). (defined for API consistency)
    property authority : TFhirReference read FAuthority write SetAuthority;
    // Indicates the authority who published the protocol (e.g. ACIP).
    property authorityElement : TFhirReference read FAuthority write SetAuthority;

    // Typed access to The vaccine preventable disease the dose is being evaluated against. (defined for API consistency)
    property targetDisease : TFhirCodeableConcept read FTargetDisease write SetTargetDisease;
    // The vaccine preventable disease the dose is being evaluated against.
    property targetDiseaseElement : TFhirCodeableConcept read FTargetDisease write SetTargetDisease;

    // Typed access to The vaccine administration event being evaluated. (defined for API consistency)
    property immunizationEvent : TFhirReference read FImmunizationEvent write SetImmunizationEvent;
    // The vaccine administration event being evaluated.
    property immunizationEventElement : TFhirReference read FImmunizationEvent write SetImmunizationEvent;

    // Typed access to Indicates if the dose is valid or not valid with respect to the published recommendations. (defined for API consistency)
    property doseStatus : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;
    // Indicates if the dose is valid or not valid with respect to the published recommendations.
    property doseStatusElement : TFhirCodeableConcept read FDoseStatus write SetDoseStatus;

    // Provides an explanation as to why the vaccine administration event is valid or not relative to the published recommendations.
    property doseStatusReasonList : TFhirCodeableConceptList read GetDoseStatusReasonList;
    property hasDoseStatusReasonList : boolean read GetHasDoseStatusReasonList;

    // Typed access to Additional information about the evaluation.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Additional information about the evaluation.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

    // Typed access to Nominal position in a series. (defined for API consistency)
    property doseNumber : TFhirDataType read FDoseNumber write SetDoseNumber;
    // Nominal position in a series.
    property doseNumberElement : TFhirDataType read FDoseNumber write SetDoseNumber;

    // Typed access to The recommended number of doses to achieve immunity. (defined for API consistency)
    property seriesDoses : TFhirDataType read FSeriesDoses write SetSeriesDoses;
    // The recommended number of doses to achieve immunity.
    property seriesDosesElement : TFhirDataType read FSeriesDoses write SetSeriesDoses;

  end;

  TFhirImmunizationEvaluationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationEvaluationList;
    function GetCurrent : TFhirImmunizationEvaluation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationEvaluationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationEvaluation read GetCurrent;
  end;

  TFhirImmunizationEvaluationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationEvaluation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationEvaluation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationEvaluationList; overload;
    function Clone : TFhirImmunizationEvaluationList; overload;
    function GetEnumerator : TFhirImmunizationEvaluationListEnumerator;
    
    //  Add a FhirImmunizationEvaluation to the end of the list.
    function Append : TFhirImmunizationEvaluation;
    
    // Add an already existing FhirImmunizationEvaluation to the end of the list.
    function AddItem(value : TFhirImmunizationEvaluation) : TFhirImmunizationEvaluation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationEvaluation) : Integer;
    
    // Insert FhirImmunizationEvaluation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationEvaluation;
    
    // Insert an existing FhirImmunizationEvaluation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationEvaluation);
    
    // Get the iIndexth FhirImmunizationEvaluation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationEvaluation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationEvaluation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationEvaluations[index : Integer] : TFhirImmunizationEvaluation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
  // Vaccine administration recommendations.
  TFhirImmunizationRecommendationRecommendation = class (TFhirBackboneElement)
  protected
    FvaccineCodeList : TFhirCodeableConceptList;
    FTargetDisease : TFhirCodeableConcept;
    FcontraindicatedVaccineCodeList : TFhirCodeableConceptList;
    FForecastStatus : TFhirCodeableConcept;
    FforecastReasonList : TFhirCodeableConceptList;
    FdateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    FDescription : TFhirString;
    FSeries : TFhirString;
    FDoseNumber : TFhirDataType;
    FSeriesDoses : TFhirDataType;
    FsupportingImmunizationList : TFhirReferenceList;
    FsupportingPatientInformationList : TFhirReferenceList;
    function GetVaccineCodeList : TFhirCodeableConceptList;
    function GetHasVaccineCodeList : Boolean;
    procedure SetTargetDisease(value : TFhirCodeableConcept);
    function GetContraindicatedVaccineCodeList : TFhirCodeableConceptList;
    function GetHasContraindicatedVaccineCodeList : Boolean;
    procedure SetForecastStatus(value : TFhirCodeableConcept);
    function GetForecastReasonList : TFhirCodeableConceptList;
    function GetHasForecastReasonList : Boolean;
    function GetDateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    function GetHasDateCriterionList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetSeries(value : TFhirString);
    function GetSeriesST : String;
    procedure SetSeriesST(value : String);
    procedure SetDoseNumber(value : TFhirDataType);
    procedure SetSeriesDoses(value : TFhirDataType);
    function GetSupportingImmunizationList : TFhirReferenceList;
    function GetHasSupportingImmunizationList : Boolean;
    function GetSupportingPatientInformationList : TFhirReferenceList;
    function GetHasSupportingPatientInformationList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendationRecommendation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Vaccine(s) or vaccine group that pertain to the recommendation.
    property vaccineCodeList : TFhirCodeableConceptList read GetVaccineCodeList;
    property hasVaccineCodeList : boolean read GetHasVaccineCodeList;

    // Typed access to The targeted disease for the recommendation. (defined for API consistency)
    property targetDisease : TFhirCodeableConcept read FTargetDisease write SetTargetDisease;
    // The targeted disease for the recommendation.
    property targetDiseaseElement : TFhirCodeableConcept read FTargetDisease write SetTargetDisease;

    // Vaccine(s) which should not be used to fulfill the recommendation.
    property contraindicatedVaccineCodeList : TFhirCodeableConceptList read GetContraindicatedVaccineCodeList;
    property hasContraindicatedVaccineCodeList : boolean read GetHasContraindicatedVaccineCodeList;

    // Typed access to Indicates the patient status with respect to the path to immunity for the target disease. (defined for API consistency)
    property forecastStatus : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;
    // Indicates the patient status with respect to the path to immunity for the target disease.
    property forecastStatusElement : TFhirCodeableConcept read FForecastStatus write SetForecastStatus;

    // The reason for the assigned forecast status.
    property forecastReasonList : TFhirCodeableConceptList read GetForecastReasonList;
    property hasForecastReasonList : boolean read GetHasForecastReasonList;

    // Vaccine date recommendations.  For example, earliest date to administer, latest date to administer, etc.
    property dateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList read GetDateCriterionList;
    property hasDateCriterionList : boolean read GetHasDateCriterionList;

    // Typed access to Contains the description about the protocol under which the vaccine was administered.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Contains the description about the protocol under which the vaccine was administered.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property series : String read GetSeriesST write SetSeriesST;
    // One possible path to achieve presumed immunity against a disease - within the context of an authority.
    property seriesElement : TFhirString read FSeries write SetSeries;

    // Typed access to Nominal position of the recommended dose in a series (e.g. dose 2 is the next recommended dose). (defined for API consistency)
    property doseNumber : TFhirDataType read FDoseNumber write SetDoseNumber;
    // Nominal position of the recommended dose in a series (e.g. dose 2 is the next recommended dose).
    property doseNumberElement : TFhirDataType read FDoseNumber write SetDoseNumber;

    // Typed access to The recommended number of doses to achieve immunity. (defined for API consistency)
    property seriesDoses : TFhirDataType read FSeriesDoses write SetSeriesDoses;
    // The recommended number of doses to achieve immunity.
    property seriesDosesElement : TFhirDataType read FSeriesDoses write SetSeriesDoses;

    // Immunization event history and/or evaluation that supports the status and recommendation.
    property supportingImmunizationList : TFhirReferenceList read GetSupportingImmunizationList;
    property hasSupportingImmunizationList : boolean read GetHasSupportingImmunizationList;

    // Patient Information that supports the status and recommendation.  This includes patient observations, adverse reactions and allergy/intolerance information.
    property supportingPatientInformationList : TFhirReferenceList read GetSupportingPatientInformationList;
    property hasSupportingPatientInformationList : boolean read GetHasSupportingPatientInformationList;

  end;

  TFhirImmunizationRecommendationRecommendationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendation read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationRecommendationRecommendationList; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationList; overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;
    
    //  Add a FhirImmunizationRecommendationRecommendation to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendation;
    
    // Add an already existing FhirImmunizationRecommendationRecommendation to the end of the list.
    function AddItem(value : TFhirImmunizationRecommendationRecommendation) : TFhirImmunizationRecommendationRecommendation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendation) : Integer;
    
    // Insert FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    
    // Insert an existing FhirImmunizationRecommendationRecommendation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
    
    // Get the iIndexth FhirImmunizationRecommendationRecommendation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationRecommendationRecommendations[index : Integer] : TFhirImmunizationRecommendationRecommendation read GetItemN write SetItemN; default;
  End;

  // Vaccine date recommendations.  For example, earliest date to administer, latest date to administer, etc.
  TFhirImmunizationRecommendationRecommendationDateCriterion = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDateTime;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDateTime);
    function GetValueST : TFslDateTime;
    procedure SetValueST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Date classification of recommendation.  For example, earliest date to give, latest date to give, etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Date classification of recommendation.  For example, earliest date to give, latest date to give, etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The date whose meaning is specified by dateCriterion.code.
    property value : TFslDateTime read GetValueST write SetValueST;
    // The date whose meaning is specified by dateCriterion.code.
    property valueElement : TFhirDateTime read FValue write SetValue;

  end;

  TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
    function GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendationRecommendationDateCriterion read GetCurrent;
  end;

  TFhirImmunizationRecommendationRecommendationDateCriterionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationRecommendationRecommendationDateCriterionList; overload;
    function Clone : TFhirImmunizationRecommendationRecommendationDateCriterionList; overload;
    function GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;
    
    //  Add a FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    function Append : TFhirImmunizationRecommendationRecommendationDateCriterion;
    
    // Add an already existing FhirImmunizationRecommendationRecommendationDateCriterion to the end of the list.
    function AddItem(value : TFhirImmunizationRecommendationRecommendationDateCriterion) : TFhirImmunizationRecommendationRecommendationDateCriterion; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendationRecommendationDateCriterion) : Integer;
    
    // Insert FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    
    // Insert an existing FhirImmunizationRecommendationRecommendationDateCriterion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    
    // Get the iIndexth FhirImmunizationRecommendationRecommendationDateCriterion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendationRecommendationDateCriterion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendationRecommendationDateCriterion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationRecommendationRecommendationDateCriterions[index : Integer] : TFhirImmunizationRecommendationRecommendationDateCriterion read GetItemN write SetItemN; default;
  End;

  // A patient's point-in-time set of recommendations (i.e. forecasting) according to a published schedule with optional supporting justification.
  TFhirImmunizationRecommendation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FPatient : TFhirReference;
    FDate : TFhirDateTime;
    FAuthority : TFhirReference;
    FrecommendationList : TFhirImmunizationRecommendationRecommendationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetPatient(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetAuthority(value : TFhirReference);
    function GetRecommendationList : TFhirImmunizationRecommendationRecommendationList;
    function GetHasRecommendationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirImmunizationRecommendation; overload;
    function Clone : TFhirImmunizationRecommendation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this particular recommendation record.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The patient the recommendation(s) are for. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient the recommendation(s) are for.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to The date the immunization recommendation(s) were created.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date the immunization recommendation(s) were created.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Indicates the authority who published the protocol (e.g. ACIP). (defined for API consistency)
    property authority : TFhirReference read FAuthority write SetAuthority;
    // Indicates the authority who published the protocol (e.g. ACIP).
    property authorityElement : TFhirReference read FAuthority write SetAuthority;

    // Vaccine administration recommendations.
    property recommendationList : TFhirImmunizationRecommendationRecommendationList read GetRecommendationList;
    property hasRecommendationList : boolean read GetHasRecommendationList;

  end;

  TFhirImmunizationRecommendationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirImmunizationRecommendationList;
    function GetCurrent : TFhirImmunizationRecommendation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirImmunizationRecommendationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirImmunizationRecommendation read GetCurrent;
  end;

  TFhirImmunizationRecommendationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirImmunizationRecommendation;
    procedure SetItemN(index : Integer; value : TFhirImmunizationRecommendation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirImmunizationRecommendationList; overload;
    function Clone : TFhirImmunizationRecommendationList; overload;
    function GetEnumerator : TFhirImmunizationRecommendationListEnumerator;
    
    //  Add a FhirImmunizationRecommendation to the end of the list.
    function Append : TFhirImmunizationRecommendation;
    
    // Add an already existing FhirImmunizationRecommendation to the end of the list.
    function AddItem(value : TFhirImmunizationRecommendation) : TFhirImmunizationRecommendation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirImmunizationRecommendation) : Integer;
    
    // Insert FhirImmunizationRecommendation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirImmunizationRecommendation;
    
    // Insert an existing FhirImmunizationRecommendation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirImmunizationRecommendation);
    
    // Get the iIndexth FhirImmunizationRecommendation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirImmunizationRecommendation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirImmunizationRecommendation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirImmunizationRecommendations[index : Integer] : TFhirImmunizationRecommendation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
  // Indicates who or what performed the medication administration and how they were involved.
  TFhirMedicationAdministrationPerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministrationPerformer; overload;
    function Clone : TFhirMedicationAdministrationPerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distinguishes the type of involvement of the performer in the medication administration. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Distinguishes the type of involvement of the performer in the medication administration.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to Indicates who or what performed the medication administration. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // Indicates who or what performed the medication administration.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirMedicationAdministrationPerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationPerformerList;
    function GetCurrent : TFhirMedicationAdministrationPerformer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationPerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministrationPerformer read GetCurrent;
  end;

  TFhirMedicationAdministrationPerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationAdministrationPerformer;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationPerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationAdministrationPerformerList; overload;
    function Clone : TFhirMedicationAdministrationPerformerList; overload;
    function GetEnumerator : TFhirMedicationAdministrationPerformerListEnumerator;
    
    //  Add a FhirMedicationAdministrationPerformer to the end of the list.
    function Append : TFhirMedicationAdministrationPerformer;
    
    // Add an already existing FhirMedicationAdministrationPerformer to the end of the list.
    function AddItem(value : TFhirMedicationAdministrationPerformer) : TFhirMedicationAdministrationPerformer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministrationPerformer) : Integer;
    
    // Insert FhirMedicationAdministrationPerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministrationPerformer;
    
    // Insert an existing FhirMedicationAdministrationPerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationPerformer);
    
    // Get the iIndexth FhirMedicationAdministrationPerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationPerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministrationPerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationAdministrationPerformers[index : Integer] : TFhirMedicationAdministrationPerformer read GetItemN write SetItemN; default;
  End;

  // Describes the medication dosage information details e.g. dose, rate, site, route, etc.
  TFhirMedicationAdministrationDosage = class (TFhirBackboneElement)
  protected
    FText : TFhirString;
    FSite : TFhirCodeableConcept;
    FRoute : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FDose : TFhirQuantity;
    FRate : TFhirDataType;
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    procedure SetSite(value : TFhirCodeableConcept);
    procedure SetRoute(value : TFhirCodeableConcept);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetDose(value : TFhirQuantity);
    procedure SetRate(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministrationDosage; overload;
    function Clone : TFhirMedicationAdministrationDosage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Free text dosage can be used for cases where the dosage administered is too complex to code. When coded dosage is present, the free text dosage may still be present for display to humans.  The dosage instructions should reflect the dosage of the medication that was administered.
    property text : String read GetTextST write SetTextST;
    // Free text dosage can be used for cases where the dosage administered is too complex to code. When coded dosage is present, the free text dosage may still be present for display to humans.  The dosage instructions should reflect the dosage of the medication that was administered.
    property textElement : TFhirString read FText write SetText;

    // Typed access to A coded specification of the anatomic site where the medication first entered the body.  For example, "left arm". (defined for API consistency)
    property site : TFhirCodeableConcept read FSite write SetSite;
    // A coded specification of the anatomic site where the medication first entered the body.  For example, "left arm".
    property siteElement : TFhirCodeableConcept read FSite write SetSite;

    // Typed access to A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.  For example, topical, intravenous, etc. (defined for API consistency)
    property route : TFhirCodeableConcept read FRoute write SetRoute;
    // A code specifying the route or physiological path of administration of a therapeutic agent into or onto the patient.  For example, topical, intravenous, etc.
    property routeElement : TFhirCodeableConcept read FRoute write SetRoute;

    // Typed access to A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value indicating the method by which the medication is intended to be or was introduced into or on the body.  This attribute will most often NOT be populated.  It is most commonly used for injections.  For example, Slow Push, Deep IV.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection. (defined for API consistency)
    property dose : TFhirQuantity read FDose write SetDose;
    // The amount of the medication given at one administration event.   Use this value when the administration is essentially an instantaneous event such as a swallowing a tablet or giving an injection.
    property doseElement : TFhirQuantity read FDose write SetDose;

    // Typed access to Identifies the speed with which the medication was or will be introduced into the patient.  Typically, the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time, e.g. 500 ml per 2 hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours. (defined for API consistency)
    property rate : TFhirDataType read FRate write SetRate;
    // Identifies the speed with which the medication was or will be introduced into the patient.  Typically, the rate for an infusion e.g. 100 ml per 1 hour or 100 ml/hr.  May also be expressed as a rate per unit of time, e.g. 500 ml per 2 hours.  Other examples:  200 mcg/min or 200 mcg/1 minute; 1 liter/8 hours.
    property rateElement : TFhirDataType read FRate write SetRate;

  end;

  TFhirMedicationAdministrationDosageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationDosageList;
    function GetCurrent : TFhirMedicationAdministrationDosage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationDosageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministrationDosage read GetCurrent;
  end;

  TFhirMedicationAdministrationDosageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationAdministrationDosage;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministrationDosage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationAdministrationDosageList; overload;
    function Clone : TFhirMedicationAdministrationDosageList; overload;
    function GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;
    
    //  Add a FhirMedicationAdministrationDosage to the end of the list.
    function Append : TFhirMedicationAdministrationDosage;
    
    // Add an already existing FhirMedicationAdministrationDosage to the end of the list.
    function AddItem(value : TFhirMedicationAdministrationDosage) : TFhirMedicationAdministrationDosage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministrationDosage) : Integer;
    
    // Insert FhirMedicationAdministrationDosage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministrationDosage;
    
    // Insert an existing FhirMedicationAdministrationDosage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    // Get the iIndexth FhirMedicationAdministrationDosage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministrationDosage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministrationDosage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationAdministrationDosages[index : Integer] : TFhirMedicationAdministrationDosage read GetItemN write SetItemN; default;
  End;

  // Describes the event of a patient consuming or otherwise being administered a medication.  This may be as simple as swallowing a tablet or it may be a long running infusion.  Related resources tie this event to the authorizing prescription, and the specific encounter between patient and health care practitioner.
  TFhirMedicationAdministration = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesList : TFhirUriList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FstatusReasonList : TFhirCodeableConceptList;
    FCategory : TFhirCodeableConcept;
    FMedication : TFhirDataType;
    FSubject : TFhirReference;
    FContext : TFhirReference;
    FsupportingInformationList : TFhirReferenceList;
    FEffective : TFhirDataType;
    FperformerList : TFhirMedicationAdministrationPerformerList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FRequest : TFhirReference;
    FdeviceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FDosage : TFhirMedicationAdministrationDosage;
    FeventHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesList : TFhirUriList;
    function GetHasInstantiatesList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationAdministrationStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationAdministrationStatusCodesEnum);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetMedication(value : TFhirDataType);
    procedure SetSubject(value : TFhirReference);
    procedure SetContext(value : TFhirReference);
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
    procedure SetEffective(value : TFhirDataType);
    function GetPerformerList : TFhirMedicationAdministrationPerformerList;
    function GetHasPerformerList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    procedure SetRequest(value : TFhirReference);
    function GetDeviceList : TFhirReferenceList;
    function GetHasDeviceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetDosage(value : TFhirMedicationAdministrationDosage);
    function GetEventHistoryList : TFhirReferenceList;
    function GetHasEventHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationAdministration; overload;
    function Clone : TFhirMedicationAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this Medication Administration that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. They are business identifiers assigned to this resource by the performer or other systems and remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A protocol, guideline, orderset, or other definition that was adhered to in whole or in part by this event.
    property instantiatesList : TFhirUriList read GetInstantiatesList;
    property hasInstantiatesList : boolean read GetHasInstantiatesList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Will generally be set to show that the administration has been completed.  For some long running administrations such as infusions, it is possible for an administration to be started but not completed or it may be paused while some other process is under way.
    property status : TFhirMedicationAdministrationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code indicating why the administration was not performed.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // Typed access to Indicates where the medication is expected to be consumed or administered. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates where the medication is expected to be consumed or administered.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Identifies the medication that was administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirDataType read FMedication write SetMedication;
    // Identifies the medication that was administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirDataType read FMedication write SetMedication;

    // Typed access to The person or animal or group receiving the medication. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The person or animal or group receiving the medication.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The visit, admission, or other contact between patient and health care provider during which the medication administration was performed. (defined for API consistency)
    property context : TFhirReference read FContext write SetContext;
    // The visit, admission, or other contact between patient and health care provider during which the medication administration was performed.
    property contextElement : TFhirReference read FContext write SetContext;

    // Additional information (for example, patient height and weight) that supports the administration of the medication.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to A specific date/time or interval of time during which the administration took place (or did not take place, when the 'notGiven' attribute is true). For many administrations, such as swallowing a tablet the use of dateTime is more appropriate. (defined for API consistency)
    property effective : TFhirDataType read FEffective write SetEffective;
    // A specific date/time or interval of time during which the administration took place (or did not take place, when the 'notGiven' attribute is true). For many administrations, such as swallowing a tablet the use of dateTime is more appropriate.
    property effectiveElement : TFhirDataType read FEffective write SetEffective;

    // Indicates who or what performed the medication administration and how they were involved.
    property performerList : TFhirMedicationAdministrationPerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // A code indicating why the medication was given.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Condition or observation that supports why the medication was administered.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Typed access to The original request, instruction or authority to perform the administration. (defined for API consistency)
    property request : TFhirReference read FRequest write SetRequest;
    // The original request, instruction or authority to perform the administration.
    property requestElement : TFhirReference read FRequest write SetRequest;

    // The device used in administering the medication to the patient.  For example, a particular infusion pump.
    property deviceList : TFhirReferenceList read GetDeviceList;
    property hasDeviceList : boolean read GetHasDeviceList;

    // Extra information about the medication administration that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Describes the medication dosage information details e.g. dose, rate, site, route, etc. (defined for API consistency)
    property dosage : TFhirMedicationAdministrationDosage read FDosage write SetDosage;
    // Describes the medication dosage information details e.g. dose, rate, site, route, etc.
    property dosageElement : TFhirMedicationAdministrationDosage read FDosage write SetDosage;

    // A summary of the events of interest that have occurred, such as when the administration was verified.
    property eventHistoryList : TFhirReferenceList read GetEventHistoryList;
    property hasEventHistoryList : boolean read GetHasEventHistoryList;

  end;

  TFhirMedicationAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationAdministrationList;
    function GetCurrent : TFhirMedicationAdministration;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationAdministration read GetCurrent;
  end;

  TFhirMedicationAdministrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationAdministration;
    procedure SetItemN(index : Integer; value : TFhirMedicationAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationAdministrationList; overload;
    function Clone : TFhirMedicationAdministrationList; overload;
    function GetEnumerator : TFhirMedicationAdministrationListEnumerator;
    
    //  Add a FhirMedicationAdministration to the end of the list.
    function Append : TFhirMedicationAdministration;
    
    // Add an already existing FhirMedicationAdministration to the end of the list.
    function AddItem(value : TFhirMedicationAdministration) : TFhirMedicationAdministration; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationAdministration) : Integer;
    
    // Insert FhirMedicationAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationAdministration;
    
    // Insert an existing FhirMedicationAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationAdministration);
    
    // Get the iIndexth FhirMedicationAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationAdministration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationAdministration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationAdministrations[index : Integer] : TFhirMedicationAdministration read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
  // Indicates who or what performed the event.
  TFhirMedicationDispensePerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispensePerformer; overload;
    function Clone : TFhirMedicationDispensePerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distinguishes the type of performer in the dispense.  For example, date enterer, packager, final checker. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Distinguishes the type of performer in the dispense.  For example, date enterer, packager, final checker.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to The device, practitioner, etc. who performed the action.  It should be assumed that the actor is the dispenser of the medication. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // The device, practitioner, etc. who performed the action.  It should be assumed that the actor is the dispenser of the medication.
    property actorElement : TFhirReference read FActor write SetActor;

  end;

  TFhirMedicationDispensePerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispensePerformerList;
    function GetCurrent : TFhirMedicationDispensePerformer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispensePerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispensePerformer read GetCurrent;
  end;

  TFhirMedicationDispensePerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispensePerformer;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispensePerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationDispensePerformerList; overload;
    function Clone : TFhirMedicationDispensePerformerList; overload;
    function GetEnumerator : TFhirMedicationDispensePerformerListEnumerator;
    
    //  Add a FhirMedicationDispensePerformer to the end of the list.
    function Append : TFhirMedicationDispensePerformer;
    
    // Add an already existing FhirMedicationDispensePerformer to the end of the list.
    function AddItem(value : TFhirMedicationDispensePerformer) : TFhirMedicationDispensePerformer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispensePerformer) : Integer;
    
    // Insert FhirMedicationDispensePerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispensePerformer;
    
    // Insert an existing FhirMedicationDispensePerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispensePerformer);
    
    // Get the iIndexth FhirMedicationDispensePerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispensePerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispensePerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationDispensePerformers[index : Integer] : TFhirMedicationDispensePerformer read GetItemN write SetItemN; default;
  End;

  // Indicates whether or not substitution was made as part of the dispense.  In some cases, substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done.
  TFhirMedicationDispenseSubstitution = class (TFhirBackboneElement)
  protected
    FWasSubstituted : TFhirBoolean;
    FType_ : TFhirCodeableConcept;
    FreasonList : TFhirCodeableConceptList;
    FresponsiblePartyList : TFhirReferenceList;
    procedure SetWasSubstituted(value : TFhirBoolean);
    function GetWasSubstitutedST : Boolean;
    procedure SetWasSubstitutedST(value : Boolean);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetResponsiblePartyList : TFhirReferenceList;
    function GetHasResponsiblePartyList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispenseSubstitution; overload;
    function Clone : TFhirMedicationDispenseSubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to True if the dispenser dispensed a different drug or product from what was prescribed.
    property wasSubstituted : Boolean read GetWasSubstitutedST write SetWasSubstitutedST;
    // True if the dispenser dispensed a different drug or product from what was prescribed.
    property wasSubstitutedElement : TFhirBoolean read FWasSubstituted write SetWasSubstituted;

    // Typed access to A code signifying whether a different drug was dispensed from what was prescribed. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code signifying whether a different drug was dispensed from what was prescribed.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Indicates the reason for the substitution (or lack of substitution) from what was prescribed.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // The person or organization that has primary responsibility for the substitution.
    property responsiblePartyList : TFhirReferenceList read GetResponsiblePartyList;
    property hasResponsiblePartyList : boolean read GetHasResponsiblePartyList;

  end;

  TFhirMedicationDispenseSubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseSubstitutionList;
    function GetCurrent : TFhirMedicationDispenseSubstitution;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispenseSubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispenseSubstitution read GetCurrent;
  end;

  TFhirMedicationDispenseSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispenseSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispenseSubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationDispenseSubstitutionList; overload;
    function Clone : TFhirMedicationDispenseSubstitutionList; overload;
    function GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;
    
    //  Add a FhirMedicationDispenseSubstitution to the end of the list.
    function Append : TFhirMedicationDispenseSubstitution;
    
    // Add an already existing FhirMedicationDispenseSubstitution to the end of the list.
    function AddItem(value : TFhirMedicationDispenseSubstitution) : TFhirMedicationDispenseSubstitution; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispenseSubstitution) : Integer;
    
    // Insert FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispenseSubstitution;
    
    // Insert an existing FhirMedicationDispenseSubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    // Get the iIndexth FhirMedicationDispenseSubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispenseSubstitution);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispenseSubstitution;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationDispenseSubstitutions[index : Integer] : TFhirMedicationDispenseSubstitution read GetItemN write SetItemN; default;
  End;

  // Indicates that a medication product is to be or has been dispensed for a named person/patient.  This includes a description of the medication product (supply) provided and the instructions for administering the medication.  The medication dispense is the result of a pharmacy system responding to a medication order.
  TFhirMedicationDispense = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirDataType;
    FCategory : TFhirCodeableConcept;
    FMedication : TFhirDataType;
    FSubject : TFhirReference;
    FContext : TFhirReference;
    FsupportingInformationList : TFhirReferenceList;
    FperformerList : TFhirMedicationDispensePerformerList;
    FLocation : TFhirReference;
    FauthorizingPrescriptionList : TFhirReferenceList;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FDaysSupply : TFhirQuantity;
    FWhenPrepared : TFhirDateTime;
    FWhenHandedOver : TFhirDateTime;
    FDestination : TFhirReference;
    FreceiverList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FdosageInstructionList : TFhirDosageList;
    FSubstitution : TFhirMedicationDispenseSubstitution;
    FdetectedIssueList : TFhirReferenceList;
    FeventHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationDispenseStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationDispenseStatusCodesEnum);
    procedure SetStatusReason(value : TFhirDataType);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetMedication(value : TFhirDataType);
    procedure SetSubject(value : TFhirReference);
    procedure SetContext(value : TFhirReference);
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
    function GetPerformerList : TFhirMedicationDispensePerformerList;
    function GetHasPerformerList : Boolean;
    procedure SetLocation(value : TFhirReference);
    function GetAuthorizingPrescriptionList : TFhirReferenceList;
    function GetHasAuthorizingPrescriptionList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetDaysSupply(value : TFhirQuantity);
    procedure SetWhenPrepared(value : TFhirDateTime);
    function GetWhenPreparedST : TFslDateTime;
    procedure SetWhenPreparedST(value : TFslDateTime);
    procedure SetWhenHandedOver(value : TFhirDateTime);
    function GetWhenHandedOverST : TFslDateTime;
    procedure SetWhenHandedOverST(value : TFslDateTime);
    procedure SetDestination(value : TFhirReference);
    function GetReceiverList : TFhirReferenceList;
    function GetHasReceiverList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetDosageInstructionList : TFhirDosageList;
    function GetHasDosageInstructionList : Boolean;
    procedure SetSubstitution(value : TFhirMedicationDispenseSubstitution);
    function GetDetectedIssueList : TFhirReferenceList;
    function GetHasDetectedIssueList : Boolean;
    function GetEventHistoryList : TFhirReferenceList;
    function GetHasEventHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationDispense; overload;
    function Clone : TFhirMedicationDispense; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this Medication Dispense that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. They are business identifiers assigned to this resource by the performer or other systems and remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The procedure that trigger the dispense.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code specifying the state of the set of dispense events.
    property status : TFhirMedicationDispenseStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Indicates the reason why a dispense was not performed. (defined for API consistency)
    property statusReason : TFhirDataType read FStatusReason write SetStatusReason;
    // Indicates the reason why a dispense was not performed.
    property statusReasonElement : TFhirDataType read FStatusReason write SetStatusReason;

    // Typed access to Indicates the type of medication dispense (for example, where the medication is expected to be consumed or administered (i.e. inpatient or outpatient)). (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates the type of medication dispense (for example, where the medication is expected to be consumed or administered (i.e. inpatient or outpatient)).
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirDataType read FMedication write SetMedication;
    // Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirDataType read FMedication write SetMedication;

    // Typed access to A link to a resource representing the person or the group to whom the medication will be given. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // A link to a resource representing the person or the group to whom the medication will be given.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter or episode of care that establishes the context for this event. (defined for API consistency)
    property context : TFhirReference read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this event.
    property contextElement : TFhirReference read FContext write SetContext;

    // Additional information that supports the medication being dispensed.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Indicates who or what performed the event.
    property performerList : TFhirMedicationDispensePerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The principal physical location where the dispense was performed. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The principal physical location where the dispense was performed.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Indicates the medication order that is being dispensed against.
    property authorizingPrescriptionList : TFhirReferenceList read GetAuthorizingPrescriptionList;
    property hasAuthorizingPrescriptionList : boolean read GetHasAuthorizingPrescriptionList;

    // Typed access to Indicates the type of dispensing event that is performed. For example, Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates the type of dispensing event that is performed. For example, Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The amount of medication that has been dispensed. Includes unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of medication that has been dispensed. Includes unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The amount of medication expressed as a timing amount. (defined for API consistency)
    property daysSupply : TFhirQuantity read FDaysSupply write SetDaysSupply;
    // The amount of medication expressed as a timing amount.
    property daysSupplyElement : TFhirQuantity read FDaysSupply write SetDaysSupply;

    // Typed access to The time when the dispensed product was packaged and reviewed.
    property whenPrepared : TFslDateTime read GetWhenPreparedST write SetWhenPreparedST;
    // The time when the dispensed product was packaged and reviewed.
    property whenPreparedElement : TFhirDateTime read FWhenPrepared write SetWhenPrepared;

    // Typed access to The time the dispensed product was provided to the patient or their representative.
    property whenHandedOver : TFslDateTime read GetWhenHandedOverST write SetWhenHandedOverST;
    // The time the dispensed product was provided to the patient or their representative.
    property whenHandedOverElement : TFhirDateTime read FWhenHandedOver write SetWhenHandedOver;

    // Typed access to Identification of the facility/location where the medication was shipped to, as part of the dispense event. (defined for API consistency)
    property destination : TFhirReference read FDestination write SetDestination;
    // Identification of the facility/location where the medication was shipped to, as part of the dispense event.
    property destinationElement : TFhirReference read FDestination write SetDestination;

    // Identifies the person who picked up the medication.  This will usually be a patient or their caregiver, but some cases exist where it can be a healthcare professional.
    property receiverList : TFhirReferenceList read GetReceiverList;
    property hasReceiverList : boolean read GetHasReceiverList;

    // Extra information about the dispense that could not be conveyed in the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Indicates how the medication is to be used by the patient.
    property dosageInstructionList : TFhirDosageList read GetDosageInstructionList;
    property hasDosageInstructionList : boolean read GetHasDosageInstructionList;

    // Typed access to Indicates whether or not substitution was made as part of the dispense.  In some cases, substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done. (defined for API consistency)
    property substitution : TFhirMedicationDispenseSubstitution read FSubstitution write SetSubstitution;
    // Indicates whether or not substitution was made as part of the dispense.  In some cases, substitution will be expected but does not happen, in other cases substitution is not expected but does happen.  This block explains what substitution did or did not happen and why.  If nothing is specified, substitution was not done.
    property substitutionElement : TFhirMedicationDispenseSubstitution read FSubstitution write SetSubstitution;

    // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. drug-drug interaction, duplicate therapy, dosage alert etc.
    property detectedIssueList : TFhirReferenceList read GetDetectedIssueList;
    property hasDetectedIssueList : boolean read GetHasDetectedIssueList;

    // A summary of the events of interest that have occurred, such as when the dispense was verified.
    property eventHistoryList : TFhirReferenceList read GetEventHistoryList;
    property hasEventHistoryList : boolean read GetHasEventHistoryList;

  end;

  TFhirMedicationDispenseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationDispenseList;
    function GetCurrent : TFhirMedicationDispense;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationDispenseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationDispense read GetCurrent;
  end;

  TFhirMedicationDispenseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationDispense;
    procedure SetItemN(index : Integer; value : TFhirMedicationDispense);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationDispenseList; overload;
    function Clone : TFhirMedicationDispenseList; overload;
    function GetEnumerator : TFhirMedicationDispenseListEnumerator;
    
    //  Add a FhirMedicationDispense to the end of the list.
    function Append : TFhirMedicationDispense;
    
    // Add an already existing FhirMedicationDispense to the end of the list.
    function AddItem(value : TFhirMedicationDispense) : TFhirMedicationDispense; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationDispense) : Integer;
    
    // Insert FhirMedicationDispense before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationDispense;
    
    // Insert an existing FhirMedicationDispense before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationDispense);
    
    // Get the iIndexth FhirMedicationDispense. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationDispense);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationDispense;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationDispenses[index : Integer] : TFhirMedicationDispense read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
  // Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department.
  TFhirMedicationRequestDispenseRequest = class (TFhirBackboneElement)
  protected
    FInitialFill : TFhirMedicationRequestDispenseRequestInitialFill;
    FDispenseInterval : TFhirDuration;
    FValidityPeriod : TFhirPeriod;
    FNumberOfRepeatsAllowed : TFhirUnsignedInt;
    FQuantity : TFhirQuantity;
    FExpectedSupplyDuration : TFhirDuration;
    FPerformer : TFhirReference;
    procedure SetInitialFill(value : TFhirMedicationRequestDispenseRequestInitialFill);
    procedure SetDispenseInterval(value : TFhirDuration);
    procedure SetValidityPeriod(value : TFhirPeriod);
    procedure SetNumberOfRepeatsAllowed(value : TFhirUnsignedInt);
    function GetNumberOfRepeatsAllowedST : String;
    procedure SetNumberOfRepeatsAllowedST(value : String);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetExpectedSupplyDuration(value : TFhirDuration);
    procedure SetPerformer(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequestDispenseRequest; overload;
    function Clone : TFhirMedicationRequestDispenseRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates the quantity or duration for the first dispense of the medication. (defined for API consistency)
    property initialFill : TFhirMedicationRequestDispenseRequestInitialFill read FInitialFill write SetInitialFill;
    // Indicates the quantity or duration for the first dispense of the medication.
    property initialFillElement : TFhirMedicationRequestDispenseRequestInitialFill read FInitialFill write SetInitialFill;

    // Typed access to The minimum period of time that must occur between dispenses of the medication. (defined for API consistency)
    property dispenseInterval : TFhirDuration read FDispenseInterval write SetDispenseInterval;
    // The minimum period of time that must occur between dispenses of the medication.
    property dispenseIntervalElement : TFhirDuration read FDispenseInterval write SetDispenseInterval;

    // Typed access to This indicates the validity period of a prescription (stale dating the Prescription). (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // This indicates the validity period of a prescription (stale dating the Prescription).
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Typed access to An integer indicating the number of times, in addition to the original dispense, (aka refills or repeats) that the patient can receive the prescribed medication. Usage Notes: This integer does not include the original order dispense. This means that if an order indicates dispense 30 tablets plus "3 repeats", then the order can be dispensed a total of 4 times and the patient can receive a total of 120 tablets.  A prescriber may explicitly say that zero refills are permitted after the initial dispense.
    property numberOfRepeatsAllowed : String read GetNumberOfRepeatsAllowedST write SetNumberOfRepeatsAllowedST;
    // An integer indicating the number of times, in addition to the original dispense, (aka refills or repeats) that the patient can receive the prescribed medication. Usage Notes: This integer does not include the original order dispense. This means that if an order indicates dispense 30 tablets plus "3 repeats", then the order can be dispensed a total of 4 times and the patient can receive a total of 120 tablets.  A prescriber may explicitly say that zero refills are permitted after the initial dispense.
    property numberOfRepeatsAllowedElement : TFhirUnsignedInt read FNumberOfRepeatsAllowed write SetNumberOfRepeatsAllowed;

    // Typed access to The amount that is to be dispensed for one fill. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount that is to be dispensed for one fill.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last. (defined for API consistency)
    property expectedSupplyDuration : TFhirDuration read FExpectedSupplyDuration write SetExpectedSupplyDuration;
    // Identifies the period time over which the supplied product is expected to be used, or the length of time the dispense is expected to last.
    property expectedSupplyDurationElement : TFhirDuration read FExpectedSupplyDuration write SetExpectedSupplyDuration;

    // Typed access to Indicates the intended dispensing Organization specified by the prescriber. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // Indicates the intended dispensing Organization specified by the prescriber.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

  end;

  TFhirMedicationRequestDispenseRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestDispenseRequestList;
    function GetCurrent : TFhirMedicationRequestDispenseRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestDispenseRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequestDispenseRequest read GetCurrent;
  end;

  TFhirMedicationRequestDispenseRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationRequestDispenseRequest;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequestDispenseRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationRequestDispenseRequestList; overload;
    function Clone : TFhirMedicationRequestDispenseRequestList; overload;
    function GetEnumerator : TFhirMedicationRequestDispenseRequestListEnumerator;
    
    //  Add a FhirMedicationRequestDispenseRequest to the end of the list.
    function Append : TFhirMedicationRequestDispenseRequest;
    
    // Add an already existing FhirMedicationRequestDispenseRequest to the end of the list.
    function AddItem(value : TFhirMedicationRequestDispenseRequest) : TFhirMedicationRequestDispenseRequest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequestDispenseRequest) : Integer;
    
    // Insert FhirMedicationRequestDispenseRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequestDispenseRequest;
    
    // Insert an existing FhirMedicationRequestDispenseRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequestDispenseRequest);
    
    // Get the iIndexth FhirMedicationRequestDispenseRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequestDispenseRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequestDispenseRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationRequestDispenseRequests[index : Integer] : TFhirMedicationRequestDispenseRequest read GetItemN write SetItemN; default;
  End;

  // Indicates the quantity or duration for the first dispense of the medication.
  TFhirMedicationRequestDispenseRequestInitialFill = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FDuration : TFhirDuration;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetDuration(value : TFhirDuration);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequestDispenseRequestInitialFill; overload;
    function Clone : TFhirMedicationRequestDispenseRequestInitialFill; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount or quantity to provide as part of the first dispense. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount or quantity to provide as part of the first dispense.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The length of time that the first dispense is expected to last. (defined for API consistency)
    property duration : TFhirDuration read FDuration write SetDuration;
    // The length of time that the first dispense is expected to last.
    property durationElement : TFhirDuration read FDuration write SetDuration;

  end;

  TFhirMedicationRequestDispenseRequestInitialFillListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestDispenseRequestInitialFillList;
    function GetCurrent : TFhirMedicationRequestDispenseRequestInitialFill;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestDispenseRequestInitialFillList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequestDispenseRequestInitialFill read GetCurrent;
  end;

  TFhirMedicationRequestDispenseRequestInitialFillList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationRequestDispenseRequestInitialFill;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequestDispenseRequestInitialFill);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationRequestDispenseRequestInitialFillList; overload;
    function Clone : TFhirMedicationRequestDispenseRequestInitialFillList; overload;
    function GetEnumerator : TFhirMedicationRequestDispenseRequestInitialFillListEnumerator;
    
    //  Add a FhirMedicationRequestDispenseRequestInitialFill to the end of the list.
    function Append : TFhirMedicationRequestDispenseRequestInitialFill;
    
    // Add an already existing FhirMedicationRequestDispenseRequestInitialFill to the end of the list.
    function AddItem(value : TFhirMedicationRequestDispenseRequestInitialFill) : TFhirMedicationRequestDispenseRequestInitialFill; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequestDispenseRequestInitialFill) : Integer;
    
    // Insert FhirMedicationRequestDispenseRequestInitialFill before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequestDispenseRequestInitialFill;
    
    // Insert an existing FhirMedicationRequestDispenseRequestInitialFill before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequestDispenseRequestInitialFill);
    
    // Get the iIndexth FhirMedicationRequestDispenseRequestInitialFill. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequestDispenseRequestInitialFill);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequestDispenseRequestInitialFill;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationRequestDispenseRequestInitialFills[index : Integer] : TFhirMedicationRequestDispenseRequestInitialFill read GetItemN write SetItemN; default;
  End;

  // Indicates whether or not substitution can or should be part of the dispense. In some cases, substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done.
  TFhirMedicationRequestSubstitution = class (TFhirBackboneElement)
  protected
    FAllowed : TFhirDataType;
    FReason : TFhirCodeableConcept;
    procedure SetAllowed(value : TFhirDataType);
    procedure SetReason(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequestSubstitution; overload;
    function Clone : TFhirMedicationRequestSubstitution; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to True if the prescriber allows a different drug to be dispensed from what was prescribed. (defined for API consistency)
    property allowed : TFhirDataType read FAllowed write SetAllowed;
    // True if the prescriber allows a different drug to be dispensed from what was prescribed.
    property allowedElement : TFhirDataType read FAllowed write SetAllowed;

    // Typed access to Indicates the reason for the substitution, or why substitution must or must not be performed. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Indicates the reason for the substitution, or why substitution must or must not be performed.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

  end;

  TFhirMedicationRequestSubstitutionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestSubstitutionList;
    function GetCurrent : TFhirMedicationRequestSubstitution;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestSubstitutionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequestSubstitution read GetCurrent;
  end;

  TFhirMedicationRequestSubstitutionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationRequestSubstitution;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequestSubstitution);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationRequestSubstitutionList; overload;
    function Clone : TFhirMedicationRequestSubstitutionList; overload;
    function GetEnumerator : TFhirMedicationRequestSubstitutionListEnumerator;
    
    //  Add a FhirMedicationRequestSubstitution to the end of the list.
    function Append : TFhirMedicationRequestSubstitution;
    
    // Add an already existing FhirMedicationRequestSubstitution to the end of the list.
    function AddItem(value : TFhirMedicationRequestSubstitution) : TFhirMedicationRequestSubstitution; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequestSubstitution) : Integer;
    
    // Insert FhirMedicationRequestSubstitution before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequestSubstitution;
    
    // Insert an existing FhirMedicationRequestSubstitution before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequestSubstitution);
    
    // Get the iIndexth FhirMedicationRequestSubstitution. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequestSubstitution);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequestSubstitution;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationRequestSubstitutions[index : Integer] : TFhirMedicationRequestSubstitution read GetItemN write SetItemN; default;
  End;

  // An order or request for both supply of the medication and the instructions for administration of the medication to a patient. The resource is called "MedicationRequest" rather than "MedicationPrescription" or "MedicationOrder" to generalize the use across inpatient and outpatient settings, including care plans, etc., and to harmonize with workflow patterns.
  TFhirMedicationRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FIntent : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FReported : TFhirDataType;
    FMedication : TFhirDataType;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FsupportingInformationList : TFhirReferenceList;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FPerformer : TFhirReference;
    FPerformerType : TFhirCodeableConcept;
    FRecorder : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FCourseOfTherapyType : TFhirCodeableConcept;
    FinsuranceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FdosageInstructionList : TFhirDosageList;
    FDispenseRequest : TFhirMedicationRequestDispenseRequest;
    FSubstitution : TFhirMedicationRequestSubstitution;
    FPriorPrescription : TFhirReference;
    FdetectedIssueList : TFhirReferenceList;
    FeventHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationrequestStatusEnum;
    procedure SetStatusST(value : TFhirMedicationrequestStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirMedicationRequestIntentEnum;
    procedure SetIntentST(value : TFhirMedicationRequestIntentEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetReported(value : TFhirDataType);
    procedure SetMedication(value : TFhirDataType);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    function GetSupportingInformationList : TFhirReferenceList;
    function GetHasSupportingInformationList : Boolean;
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    procedure SetPerformer(value : TFhirReference);
    procedure SetPerformerType(value : TFhirCodeableConcept);
    procedure SetRecorder(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    procedure SetCourseOfTherapyType(value : TFhirCodeableConcept);
    function GetInsuranceList : TFhirReferenceList;
    function GetHasInsuranceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetDosageInstructionList : TFhirDosageList;
    function GetHasDosageInstructionList : Boolean;
    procedure SetDispenseRequest(value : TFhirMedicationRequestDispenseRequest);
    procedure SetSubstitution(value : TFhirMedicationRequestSubstitution);
    procedure SetPriorPrescription(value : TFhirReference);
    function GetDetectedIssueList : TFhirReferenceList;
    function GetHasDetectedIssueList : Boolean;
    function GetEventHistoryList : TFhirReferenceList;
    function GetHasEventHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationRequest; overload;
    function Clone : TFhirMedicationRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this medication request that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. They are business identifiers assigned to this resource by the performer or other systems and remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A code specifying the current state of the order.  Generally, this will be active or completed state.
    property status : TFhirMedicationrequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the MedicationRequest. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the MedicationRequest.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Whether the request is a proposal, plan, or an original order.
    property intent : TFhirMedicationRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates the type of medication request (for example, where the medication is expected to be consumed or administered (i.e. inpatient or outpatient)).
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Indicates how quickly the Medication Request should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to If true indicates that the provider is asking for the medication request not to occur.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // If true indicates that the provider is asking for the medication request not to occur.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.  It may also indicate the source of the report. (defined for API consistency)
    property reported : TFhirDataType read FReported write SetReported;
    // Indicates if this record was captured as a secondary 'reported' record rather than as an original primary source-of-truth record.  It may also indicate the source of the report.
    property reportedElement : TFhirDataType read FReported write SetReported;

    // Typed access to Identifies the medication being requested. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirDataType read FMedication write SetMedication;
    // Identifies the medication being requested. This is a link to a resource that represents the medication which may be the details of the medication or simply an attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirDataType read FMedication write SetMedication;

    // Typed access to A link to a resource representing the person or set of individuals to whom the medication will be given. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // A link to a resource representing the person or set of individuals to whom the medication will be given.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this [x] was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this [x] was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Include additional information (for example, patient height and weight) that supports the ordering of the medication.
    property supportingInformationList : TFhirReferenceList read GetSupportingInformationList;
    property hasSupportingInformationList : boolean read GetHasSupportingInformationList;

    // Typed access to The date (and perhaps time) when the prescription was initially written or authored on.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // The date (and perhaps time) when the prescription was initially written or authored on.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual, organization, or device that initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The individual, organization, or device that initiated the request and has responsibility for its activation.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // Typed access to The specified desired performer of the medication treatment (e.g. the performer of the medication administration). (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // The specified desired performer of the medication treatment (e.g. the performer of the medication administration).
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Typed access to Indicates the type of performer of the administration of the medication. (defined for API consistency)
    property performerType : TFhirCodeableConcept read FPerformerType write SetPerformerType;
    // Indicates the type of performer of the administration of the medication.
    property performerTypeElement : TFhirCodeableConcept read FPerformerType write SetPerformerType;

    // Typed access to The person who entered the order on behalf of another individual for example in the case of a verbal or a telephone order. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // The person who entered the order on behalf of another individual for example in the case of a verbal or a telephone order.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // The reason or the indication for ordering or not ordering the medication.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Condition or observation that supports why the medication was ordered.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // The URL pointing to a protocol, guideline, orderset, or other definition that is adhered to in whole or in part by this MedicationRequest.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this MedicationRequest.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A plan or request that is fulfilled in whole or in part by this medication request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition or prescription. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition or prescription.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // Typed access to The description of the overall patte3rn of the administration of the medication to the patient. (defined for API consistency)
    property courseOfTherapyType : TFhirCodeableConcept read FCourseOfTherapyType write SetCourseOfTherapyType;
    // The description of the overall patte3rn of the administration of the medication to the patient.
    property courseOfTherapyTypeElement : TFhirCodeableConcept read FCourseOfTherapyType write SetCourseOfTherapyType;

    // Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be required for delivering the requested service.
    property insuranceList : TFhirReferenceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Extra information about the prescription that could not be conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Indicates how the medication is to be used by the patient.
    property dosageInstructionList : TFhirDosageList read GetDosageInstructionList;
    property hasDosageInstructionList : boolean read GetHasDosageInstructionList;

    // Typed access to Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department. (defined for API consistency)
    property dispenseRequest : TFhirMedicationRequestDispenseRequest read FDispenseRequest write SetDispenseRequest;
    // Indicates the specific details for the dispense or medication supply part of a medication request (also known as a Medication Prescription or Medication Order).  Note that this information is not always sent with the order.  There may be in some settings (e.g. hospitals) institutional or system support for completing the dispense details in the pharmacy department.
    property dispenseRequestElement : TFhirMedicationRequestDispenseRequest read FDispenseRequest write SetDispenseRequest;

    // Typed access to Indicates whether or not substitution can or should be part of the dispense. In some cases, substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done. (defined for API consistency)
    property substitution : TFhirMedicationRequestSubstitution read FSubstitution write SetSubstitution;
    // Indicates whether or not substitution can or should be part of the dispense. In some cases, substitution must happen, in other cases substitution must not happen. This block explains the prescriber's intent. If nothing is specified substitution may be done.
    property substitutionElement : TFhirMedicationRequestSubstitution read FSubstitution write SetSubstitution;

    // Typed access to A link to a resource representing an earlier order related order or prescription. (defined for API consistency)
    property priorPrescription : TFhirReference read FPriorPrescription write SetPriorPrescription;
    // A link to a resource representing an earlier order related order or prescription.
    property priorPrescriptionElement : TFhirReference read FPriorPrescription write SetPriorPrescription;

    // Indicates an actual or potential clinical issue with or between one or more active or proposed clinical actions for a patient; e.g. Drug-drug interaction, duplicate therapy, dosage alert etc.
    property detectedIssueList : TFhirReferenceList read GetDetectedIssueList;
    property hasDetectedIssueList : boolean read GetHasDetectedIssueList;

    // Links to Provenance records for past versions of this resource or fulfilling request or event resources that identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the resource.
    property eventHistoryList : TFhirReferenceList read GetEventHistoryList;
    property hasEventHistoryList : boolean read GetHasEventHistoryList;

  end;

  TFhirMedicationRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationRequestList;
    function GetCurrent : TFhirMedicationRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationRequest read GetCurrent;
  end;

  TFhirMedicationRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationRequest;
    procedure SetItemN(index : Integer; value : TFhirMedicationRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationRequestList; overload;
    function Clone : TFhirMedicationRequestList; overload;
    function GetEnumerator : TFhirMedicationRequestListEnumerator;
    
    //  Add a FhirMedicationRequest to the end of the list.
    function Append : TFhirMedicationRequest;
    
    // Add an already existing FhirMedicationRequest to the end of the list.
    function AddItem(value : TFhirMedicationRequest) : TFhirMedicationRequest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationRequest) : Integer;
    
    // Insert FhirMedicationRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationRequest;
    
    // Insert an existing FhirMedicationRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationRequest);
    
    // Get the iIndexth FhirMedicationRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationRequests[index : Integer] : TFhirMedicationRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
  // A record of a medication that is being consumed by a patient.   A MedicationStatement may indicate that the patient may be taking the medication now or has taken the medication in the past or will be taking the medication in the future.  The source of this information can be the patient, significant other (such as a family member or spouse), or a clinician.  A common scenario where this information is captured is during the history taking process during a patient visit or stay.   The medication information may come from sources such as the patient's memory, from a prescription bottle,  or from a list of medications the patient, clinician or other party maintains.   The primary difference between a medication statement and a medication administration is that the medication administration has complete administration information and is based on actual administration information from the person who administered the medication.  A medication statement is often, if not
    //  always, less specific.  There is no required date/time when the medication was administered, in fact we only know that a source has reported the patient is taking this medication, where details such as time, quantity, or rate or even medication product may be incomplete or missing or less precise.  As stated earlier, the medication statement information may come from the patient's memory, from a prescription bottle or from a list of medications the patient, clinician or other party maintains.  Medication administration is more formal and is not missing detailed information.
  TFhirMedicationStatement = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FstatusReasonList : TFhirCodeableConceptList;
    FCategory : TFhirCodeableConcept;
    FMedication : TFhirDataType;
    FSubject : TFhirReference;
    FContext : TFhirReference;
    FEffective : TFhirDataType;
    FDateAsserted : TFhirDateTime;
    FInformationSource : TFhirReference;
    FderivedFromList : TFhirReferenceList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FdosageList : TFhirDosageList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMedicationStatusCodesEnum;
    procedure SetStatusST(value : TFhirMedicationStatusCodesEnum);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetMedication(value : TFhirDataType);
    procedure SetSubject(value : TFhirReference);
    procedure SetContext(value : TFhirReference);
    procedure SetEffective(value : TFhirDataType);
    procedure SetDateAsserted(value : TFhirDateTime);
    function GetDateAssertedST : TFslDateTime;
    procedure SetDateAssertedST(value : TFslDateTime);
    procedure SetInformationSource(value : TFhirReference);
    function GetDerivedFromList : TFhirReferenceList;
    function GetHasDerivedFromList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedicationStatement; overload;
    function Clone : TFhirMedicationStatement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with this Medication Statement that are defined by business processes and/or used to refer to it when a direct URL reference to the resource itself is not appropriate. They are business identifiers assigned to this resource by the performer or other systems and remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code representing the patient or other source's judgment about the state of the medication used that this statement is about.  Generally, this will be active or completed.
    property status : TFhirMedicationStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Captures the reason for the current state of the MedicationStatement.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // Typed access to Indicates where the medication is expected to be consumed or administered. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates where the medication is expected to be consumed or administered.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications. (defined for API consistency)
    property medication : TFhirDataType read FMedication write SetMedication;
    // Identifies the medication being administered. This is either a link to a resource representing the details of the medication or a simple attribute carrying a code that identifies the medication from a known list of medications.
    property medicationElement : TFhirDataType read FMedication write SetMedication;

    // Typed access to The person, animal or group who is/was taking the medication. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The person, animal or group who is/was taking the medication.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter or episode of care that establishes the context for this MedicationStatement. (defined for API consistency)
    property context : TFhirReference read FContext write SetContext;
    // The encounter or episode of care that establishes the context for this MedicationStatement.
    property contextElement : TFhirReference read FContext write SetContext;

    // Typed access to The interval of time during which it is being asserted that the patient is/was/will be taking the medication (or was not taking, when the MedicationStatement.taken element is No). (defined for API consistency)
    property effective : TFhirDataType read FEffective write SetEffective;
    // The interval of time during which it is being asserted that the patient is/was/will be taking the medication (or was not taking, when the MedicationStatement.taken element is No).
    property effectiveElement : TFhirDataType read FEffective write SetEffective;

    // Typed access to The date when the medication statement was asserted by the information source.
    property dateAsserted : TFslDateTime read GetDateAssertedST write SetDateAssertedST;
    // The date when the medication statement was asserted by the information source.
    property dateAssertedElement : TFhirDateTime read FDateAsserted write SetDateAsserted;

    // Typed access to The person or organization that provided the information about the taking of this medication. Note: Use derivedFrom when a MedicationStatement is derived from other resources, e.g. Claim or MedicationRequest. (defined for API consistency)
    property informationSource : TFhirReference read FInformationSource write SetInformationSource;
    // The person or organization that provided the information about the taking of this medication. Note: Use derivedFrom when a MedicationStatement is derived from other resources, e.g. Claim or MedicationRequest.
    property informationSourceElement : TFhirReference read FInformationSource write SetInformationSource;

    // Allows linking the MedicationStatement to the underlying MedicationRequest, or to other information that supports or is used to derive the MedicationStatement.
    property derivedFromList : TFhirReferenceList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // A reason for why the medication is being/was taken.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Condition or observation that supports why the medication is being/was taken.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Provides extra information about the medication statement that is not conveyed by the other attributes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Indicates how the medication is/was or should be taken by the patient.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

  end;

  TFhirMedicationStatementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMedicationStatementList;
    function GetCurrent : TFhirMedicationStatement;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMedicationStatementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedicationStatement read GetCurrent;
  end;

  TFhirMedicationStatementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedicationStatement;
    procedure SetItemN(index : Integer; value : TFhirMedicationStatement);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMedicationStatementList; overload;
    function Clone : TFhirMedicationStatementList; overload;
    function GetEnumerator : TFhirMedicationStatementListEnumerator;
    
    //  Add a FhirMedicationStatement to the end of the list.
    function Append : TFhirMedicationStatement;
    
    // Add an already existing FhirMedicationStatement to the end of the list.
    function AddItem(value : TFhirMedicationStatement) : TFhirMedicationStatement; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedicationStatement) : Integer;
    
    // Insert FhirMedicationStatement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedicationStatement;
    
    // Insert an existing FhirMedicationStatement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedicationStatement);
    
    // Get the iIndexth FhirMedicationStatement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedicationStatement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedicationStatement;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedicationStatements[index : Integer] : TFhirMedicationStatement read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MOLECULARSEQUENCE}
  // A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
  TFhirMolecularSequenceReferenceSeq = class (TFhirBackboneElement)
  protected
    FChromosome : TFhirCodeableConcept;
    FGenomeBuild : TFhirString;
    FOrientation : TFhirEnum;
    FReferenceSeqId : TFhirCodeableConcept;
    FReferenceSeqPointer : TFhirReference;
    FReferenceSeqString : TFhirString;
    FStrand : TFhirEnum;
    FWindowStart : TFhirInteger;
    FWindowEnd : TFhirInteger;
    procedure SetChromosome(value : TFhirCodeableConcept);
    procedure SetGenomeBuild(value : TFhirString);
    function GetGenomeBuildST : String;
    procedure SetGenomeBuildST(value : String);
    procedure SetOrientation(value : TFhirEnum);
    function GetOrientationST : TFhirOrientationTypeEnum;
    procedure SetOrientationST(value : TFhirOrientationTypeEnum);
    procedure SetReferenceSeqId(value : TFhirCodeableConcept);
    procedure SetReferenceSeqPointer(value : TFhirReference);
    procedure SetReferenceSeqString(value : TFhirString);
    function GetReferenceSeqStringST : String;
    procedure SetReferenceSeqStringST(value : String);
    procedure SetStrand(value : TFhirEnum);
    function GetStrandST : TFhirStrandTypeEnum;
    procedure SetStrandST(value : TFhirStrandTypeEnum);
    procedure SetWindowStart(value : TFhirInteger);
    function GetWindowStartST : String;
    procedure SetWindowStartST(value : String);
    procedure SetWindowEnd(value : TFhirInteger);
    function GetWindowEndST : String;
    procedure SetWindowEndST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceReferenceSeq; overload;
    function Clone : TFhirMolecularSequenceReferenceSeq; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)). (defined for API consistency)
    property chromosome : TFhirCodeableConcept read FChromosome write SetChromosome;
    // Structural unit composed of a nucleic acid molecule which controls its own replication through the interaction of specific proteins at one or more origins of replication ([SO:0000340](http://www.sequenceontology.org/browser/current_svn/term/SO:0000340)).
    property chromosomeElement : TFhirCodeableConcept read FChromosome write SetChromosome;

    // Typed access to The Genome Build used for reference, following GRCh build versions e.g. 'GRCh 37'.  Version number must be included if a versioned release of a primary build was used.
    property genomeBuild : String read GetGenomeBuildST write SetGenomeBuildST;
    // The Genome Build used for reference, following GRCh build versions e.g. 'GRCh 37'.  Version number must be included if a versioned release of a primary build was used.
    property genomeBuildElement : TFhirString read FGenomeBuild write SetGenomeBuild;

    // A relative reference to a DNA strand based on gene orientation. The strand that contains the open reading frame of the gene is the "sense" strand, and the opposite complementary strand is the "antisense" strand.
    property orientation : TFhirOrientationTypeEnum read GetOrientationST write SetOrientationST;
    property orientationElement : TFhirEnum read FOrientation write SetOrientation;

    // Typed access to Reference identifier of reference sequence submitted to NCBI. It must match the type in the MolecularSequence.type field. For example, the prefix, NG_ identifies reference sequence for genes, NM_ for messenger RNA transcripts, and NP_ for amino acid sequences. (defined for API consistency)
    property referenceSeqId : TFhirCodeableConcept read FReferenceSeqId write SetReferenceSeqId;
    // Reference identifier of reference sequence submitted to NCBI. It must match the type in the MolecularSequence.type field. For example, the prefix, NG_ identifies reference sequence for genes, NM_ for messenger RNA transcripts, and NP_ for amino acid sequences.
    property referenceSeqIdElement : TFhirCodeableConcept read FReferenceSeqId write SetReferenceSeqId;

    // Typed access to A pointer to another MolecularSequence entity as reference sequence. (defined for API consistency)
    property referenceSeqPointer : TFhirReference read FReferenceSeqPointer write SetReferenceSeqPointer;
    // A pointer to another MolecularSequence entity as reference sequence.
    property referenceSeqPointerElement : TFhirReference read FReferenceSeqPointer write SetReferenceSeqPointer;

    // Typed access to A string like "ACGT".
    property referenceSeqString : String read GetReferenceSeqStringST write SetReferenceSeqStringST;
    // A string like "ACGT".
    property referenceSeqStringElement : TFhirString read FReferenceSeqString write SetReferenceSeqString;

    // An absolute reference to a strand. The Watson strand is the strand whose 5'-end is on the short arm of the chromosome, and the Crick strand as the one whose 5'-end is on the long arm.
    property strand : TFhirStrandTypeEnum read GetStrandST write SetStrandST;
    property strandElement : TFhirEnum read FStrand write SetStrand;

    // Typed access to Start position of the window on the reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property windowStart : String read GetWindowStartST write SetWindowStartST;
    // Start position of the window on the reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property windowStartElement : TFhirInteger read FWindowStart write SetWindowStart;

    // Typed access to End position of the window on the reference sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property windowEnd : String read GetWindowEndST write SetWindowEndST;
    // End position of the window on the reference sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property windowEndElement : TFhirInteger read FWindowEnd write SetWindowEnd;

  end;

  TFhirMolecularSequenceReferenceSeqListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceReferenceSeqList;
    function GetCurrent : TFhirMolecularSequenceReferenceSeq;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceReferenceSeqList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceReferenceSeq read GetCurrent;
  end;

  TFhirMolecularSequenceReferenceSeqList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceReferenceSeq;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceReferenceSeq);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceReferenceSeqList; overload;
    function Clone : TFhirMolecularSequenceReferenceSeqList; overload;
    function GetEnumerator : TFhirMolecularSequenceReferenceSeqListEnumerator;
    
    //  Add a FhirMolecularSequenceReferenceSeq to the end of the list.
    function Append : TFhirMolecularSequenceReferenceSeq;
    
    // Add an already existing FhirMolecularSequenceReferenceSeq to the end of the list.
    function AddItem(value : TFhirMolecularSequenceReferenceSeq) : TFhirMolecularSequenceReferenceSeq; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceReferenceSeq) : Integer;
    
    // Insert FhirMolecularSequenceReferenceSeq before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceReferenceSeq;
    
    // Insert an existing FhirMolecularSequenceReferenceSeq before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceReferenceSeq);
    
    // Get the iIndexth FhirMolecularSequenceReferenceSeq. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceReferenceSeq);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceReferenceSeq;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceReferenceSeqs[index : Integer] : TFhirMolecularSequenceReferenceSeq read GetItemN write SetItemN; default;
  End;

  // The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
  TFhirMolecularSequenceVariant = class (TFhirBackboneElement)
  protected
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    FObservedAllele : TFhirString;
    FReferenceAllele : TFhirString;
    FCigar : TFhirString;
    FVariantPointer : TFhirReference;
    procedure SetStart(value : TFhirInteger);
    function GetStartST : String;
    procedure SetStartST(value : String);
    procedure SetEnd_(value : TFhirInteger);
    function GetEnd_ST : String;
    procedure SetEnd_ST(value : String);
    procedure SetObservedAllele(value : TFhirString);
    function GetObservedAlleleST : String;
    procedure SetObservedAlleleST(value : String);
    procedure SetReferenceAllele(value : TFhirString);
    function GetReferenceAlleleST : String;
    procedure SetReferenceAlleleST(value : String);
    procedure SetCigar(value : TFhirString);
    function GetCigarST : String;
    procedure SetCigarST(value : String);
    procedure SetVariantPointer(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceVariant; overload;
    function Clone : TFhirMolecularSequenceVariant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Start position of the variant on the  reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Start position of the variant on the  reference sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to End position of the variant on the reference sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // End position of the variant on the reference sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

    // Typed access to An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).  Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the observed  sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property observedAllele : String read GetObservedAlleleST write SetObservedAlleleST;
    // An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)).  Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the observed  sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property observedAlleleElement : TFhirString read FObservedAllele write SetObservedAllele;

    // Typed access to An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the reference sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property referenceAllele : String read GetReferenceAlleleST write SetReferenceAlleleST;
    // An allele is one of a set of coexisting sequence variants of a gene ([SO:0001023](http://www.sequenceontology.org/browser/current_svn/term/SO:0001023)). Nucleotide(s)/amino acids from start position of sequence to stop position of sequence on the positive (+) strand of the reference sequence. When the sequence  type is DNA, it should be the sequence on the positive (+) strand. This will lay in the range between variant.start and variant.end.
    property referenceAlleleElement : TFhirString read FReferenceAllele write SetReferenceAllele;

    // Typed access to Extended CIGAR string for aligning the sequence with reference bases. See detailed documentation [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
    property cigar : String read GetCigarST write SetCigarST;
    // Extended CIGAR string for aligning the sequence with reference bases. See detailed documentation [here](http://support.illumina.com/help/SequencingAnalysisWorkflow/Content/Vault/Informatics/Sequencing_Analysis/CASAVA/swSEQ_mCA_ExtendedCIGARFormat.htm).
    property cigarElement : TFhirString read FCigar write SetCigar;

    // Typed access to A pointer to an Observation containing variant information. (defined for API consistency)
    property variantPointer : TFhirReference read FVariantPointer write SetVariantPointer;
    // A pointer to an Observation containing variant information.
    property variantPointerElement : TFhirReference read FVariantPointer write SetVariantPointer;

  end;

  TFhirMolecularSequenceVariantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceVariantList;
    function GetCurrent : TFhirMolecularSequenceVariant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceVariantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceVariant read GetCurrent;
  end;

  TFhirMolecularSequenceVariantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceVariant;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceVariant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceVariantList; overload;
    function Clone : TFhirMolecularSequenceVariantList; overload;
    function GetEnumerator : TFhirMolecularSequenceVariantListEnumerator;
    
    //  Add a FhirMolecularSequenceVariant to the end of the list.
    function Append : TFhirMolecularSequenceVariant;
    
    // Add an already existing FhirMolecularSequenceVariant to the end of the list.
    function AddItem(value : TFhirMolecularSequenceVariant) : TFhirMolecularSequenceVariant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceVariant) : Integer;
    
    // Insert FhirMolecularSequenceVariant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceVariant;
    
    // Insert an existing FhirMolecularSequenceVariant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceVariant);
    
    // Get the iIndexth FhirMolecularSequenceVariant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceVariant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceVariant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceVariants[index : Integer] : TFhirMolecularSequenceVariant read GetItemN write SetItemN; default;
  End;

  // An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
  TFhirMolecularSequenceQuality = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FStandardSequence : TFhirCodeableConcept;
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    FScore : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FTruthTP : TFhirDecimal;
    FQueryTP : TFhirDecimal;
    FTruthFN : TFhirDecimal;
    FQueryFP : TFhirDecimal;
    FGtFP : TFhirDecimal;
    FPrecision : TFhirDecimal;
    FRecall : TFhirDecimal;
    FFScore_ : TFhirDecimal;
    FRoc : TFhirMolecularSequenceQualityRoc;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirQualityTypeEnum;
    procedure SetType_ST(value : TFhirQualityTypeEnum);
    procedure SetStandardSequence(value : TFhirCodeableConcept);
    procedure SetStart(value : TFhirInteger);
    function GetStartST : String;
    procedure SetStartST(value : String);
    procedure SetEnd_(value : TFhirInteger);
    function GetEnd_ST : String;
    procedure SetEnd_ST(value : String);
    procedure SetScore(value : TFhirQuantity);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetTruthTP(value : TFhirDecimal);
    function GetTruthTPST : String;
    procedure SetTruthTPST(value : String);
    procedure SetQueryTP(value : TFhirDecimal);
    function GetQueryTPST : String;
    procedure SetQueryTPST(value : String);
    procedure SetTruthFN(value : TFhirDecimal);
    function GetTruthFNST : String;
    procedure SetTruthFNST(value : String);
    procedure SetQueryFP(value : TFhirDecimal);
    function GetQueryFPST : String;
    procedure SetQueryFPST(value : String);
    procedure SetGtFP(value : TFhirDecimal);
    function GetGtFPST : String;
    procedure SetGtFPST(value : String);
    procedure SetPrecision(value : TFhirDecimal);
    function GetPrecisionST : String;
    procedure SetPrecisionST(value : String);
    procedure SetRecall(value : TFhirDecimal);
    function GetRecallST : String;
    procedure SetRecallST(value : String);
    procedure SetFScore_(value : TFhirDecimal);
    function GetFScore_ST : String;
    procedure SetFScore_ST(value : String);
    procedure SetRoc(value : TFhirMolecularSequenceQualityRoc);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceQuality; overload;
    function Clone : TFhirMolecularSequenceQuality; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // INDEL / SNP / Undefined variant.
    property type_ : TFhirQualityTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Gold standard sequence used for comparing against. (defined for API consistency)
    property standardSequence : TFhirCodeableConcept read FStandardSequence write SetStandardSequence;
    // Gold standard sequence used for comparing against.
    property standardSequenceElement : TFhirCodeableConcept read FStandardSequence write SetStandardSequence;

    // Typed access to Start position of the sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Start position of the sequence. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to End position of the sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // End position of the sequence. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

    // Typed access to The score of an experimentally derived feature such as a p-value ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)). (defined for API consistency)
    property score : TFhirQuantity read FScore write SetScore;
    // The score of an experimentally derived feature such as a p-value ([SO:0001685](http://www.sequenceontology.org/browser/current_svn/term/SO:0001685)).
    property scoreElement : TFhirQuantity read FScore write SetScore;

    // Typed access to Which method is used to get sequence quality. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // Which method is used to get sequence quality.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to True positives, from the perspective of the truth data, i.e. the number of sites in the Truth Call Set for which there are paths through the Query Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property truthTP : String read GetTruthTPST write SetTruthTPST;
    // True positives, from the perspective of the truth data, i.e. the number of sites in the Truth Call Set for which there are paths through the Query Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property truthTPElement : TFhirDecimal read FTruthTP write SetTruthTP;

    // Typed access to True positives, from the perspective of the query data, i.e. the number of sites in the Query Call Set for which there are paths through the Truth Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property queryTP : String read GetQueryTPST write SetQueryTPST;
    // True positives, from the perspective of the query data, i.e. the number of sites in the Query Call Set for which there are paths through the Truth Call Set that are consistent with all of the alleles at this site, and for which there is an accurate genotype call for the event.
    property queryTPElement : TFhirDecimal read FQueryTP write SetQueryTP;

    // Typed access to False negatives, i.e. the number of sites in the Truth Call Set for which there is no path through the Query Call Set that is consistent with all of the alleles at this site, or sites for which there is an inaccurate genotype call for the event. Sites with correct variant but incorrect genotype are counted here.
    property truthFN : String read GetTruthFNST write SetTruthFNST;
    // False negatives, i.e. the number of sites in the Truth Call Set for which there is no path through the Query Call Set that is consistent with all of the alleles at this site, or sites for which there is an inaccurate genotype call for the event. Sites with correct variant but incorrect genotype are counted here.
    property truthFNElement : TFhirDecimal read FTruthFN write SetTruthFN;

    // Typed access to False positives, i.e. the number of sites in the Query Call Set for which there is no path through the Truth Call Set that is consistent with this site. Sites with correct variant but incorrect genotype are counted here.
    property queryFP : String read GetQueryFPST write SetQueryFPST;
    // False positives, i.e. the number of sites in the Query Call Set for which there is no path through the Truth Call Set that is consistent with this site. Sites with correct variant but incorrect genotype are counted here.
    property queryFPElement : TFhirDecimal read FQueryFP write SetQueryFP;

    // Typed access to The number of false positives where the non-REF alleles in the Truth and Query Call Sets match (i.e. cases where the truth is 1/1 and the query is 0/1 or similar).
    property gtFP : String read GetGtFPST write SetGtFPST;
    // The number of false positives where the non-REF alleles in the Truth and Query Call Sets match (i.e. cases where the truth is 1/1 and the query is 0/1 or similar).
    property gtFPElement : TFhirDecimal read FGtFP write SetGtFP;

    // Typed access to QUERY.TP / (QUERY.TP + QUERY.FP).
    property precision : String read GetPrecisionST write SetPrecisionST;
    // QUERY.TP / (QUERY.TP + QUERY.FP).
    property precisionElement : TFhirDecimal read FPrecision write SetPrecision;

    // Typed access to TRUTH.TP / (TRUTH.TP + TRUTH.FN).
    property recall : String read GetRecallST write SetRecallST;
    // TRUTH.TP / (TRUTH.TP + TRUTH.FN).
    property recallElement : TFhirDecimal read FRecall write SetRecall;

    // Typed access to Harmonic mean of Recall and Precision, computed as: 2 * precision * recall / (precision + recall).
    property fScore_ : String read GetFScore_ST write SetFScore_ST;
    // Harmonic mean of Recall and Precision, computed as: 2 * precision * recall / (precision + recall).
    property fScore_Element : TFhirDecimal read FFScore_ write SetFScore_;

    // Typed access to Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff. (defined for API consistency)
    property roc : TFhirMolecularSequenceQualityRoc read FRoc write SetRoc;
    // Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
    property rocElement : TFhirMolecularSequenceQualityRoc read FRoc write SetRoc;

  end;

  TFhirMolecularSequenceQualityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceQualityList;
    function GetCurrent : TFhirMolecularSequenceQuality;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceQualityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceQuality read GetCurrent;
  end;

  TFhirMolecularSequenceQualityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceQuality;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceQuality);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceQualityList; overload;
    function Clone : TFhirMolecularSequenceQualityList; overload;
    function GetEnumerator : TFhirMolecularSequenceQualityListEnumerator;
    
    //  Add a FhirMolecularSequenceQuality to the end of the list.
    function Append : TFhirMolecularSequenceQuality;
    
    // Add an already existing FhirMolecularSequenceQuality to the end of the list.
    function AddItem(value : TFhirMolecularSequenceQuality) : TFhirMolecularSequenceQuality; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceQuality) : Integer;
    
    // Insert FhirMolecularSequenceQuality before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceQuality;
    
    // Insert an existing FhirMolecularSequenceQuality before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceQuality);
    
    // Get the iIndexth FhirMolecularSequenceQuality. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceQuality);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceQuality;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceQualities[index : Integer] : TFhirMolecularSequenceQuality read GetItemN write SetItemN; default;
  End;

  // Receiver Operator Characteristic (ROC) Curve  to give sensitivity/specificity tradeoff.
  TFhirMolecularSequenceQualityRoc = class (TFhirBackboneElement)
  protected
    FscoreList : TFhirIntegerList;
    FnumTPList : TFhirIntegerList;
    FnumFPList : TFhirIntegerList;
    FnumFNList : TFhirIntegerList;
    FprecisionList : TFhirDecimalList;
    FsensitivityList : TFhirDecimalList;
    FfMeasureList : TFhirDecimalList;
    function GetScoreList : TFhirIntegerList;
    function GetHasScoreList : Boolean;
    function GetNumTPList : TFhirIntegerList;
    function GetHasNumTPList : Boolean;
    function GetNumFPList : TFhirIntegerList;
    function GetHasNumFPList : Boolean;
    function GetNumFNList : TFhirIntegerList;
    function GetHasNumFNList : Boolean;
    function GetPrecisionList : TFhirDecimalList;
    function GetHasPrecisionList : Boolean;
    function GetSensitivityList : TFhirDecimalList;
    function GetHasSensitivityList : Boolean;
    function GetFMeasureList : TFhirDecimalList;
    function GetHasFMeasureList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceQualityRoc; overload;
    function Clone : TFhirMolecularSequenceQualityRoc; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Invidual data point representing the GQ (genotype quality) score threshold.
    property scoreList : TFhirIntegerList read GetScoreList;
    property hasScoreList : boolean read GetHasScoreList;

    // The number of true positives if the GQ score threshold was set to "score" field value.
    property numTPList : TFhirIntegerList read GetNumTPList;
    property hasNumTPList : boolean read GetHasNumTPList;

    // The number of false positives if the GQ score threshold was set to "score" field value.
    property numFPList : TFhirIntegerList read GetNumFPList;
    property hasNumFPList : boolean read GetHasNumFPList;

    // The number of false negatives if the GQ score threshold was set to "score" field value.
    property numFNList : TFhirIntegerList read GetNumFNList;
    property hasNumFNList : boolean read GetHasNumFNList;

    // Calculated precision if the GQ score threshold was set to "score" field value.
    property precisionList : TFhirDecimalList read GetPrecisionList;
    property hasPrecisionList : boolean read GetHasPrecisionList;

    // Calculated sensitivity if the GQ score threshold was set to "score" field value.
    property sensitivityList : TFhirDecimalList read GetSensitivityList;
    property hasSensitivityList : boolean read GetHasSensitivityList;

    // Calculated fScore if the GQ score threshold was set to "score" field value.
    property fMeasureList : TFhirDecimalList read GetFMeasureList;
    property hasFMeasureList : boolean read GetHasFMeasureList;

  end;

  TFhirMolecularSequenceQualityRocListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceQualityRocList;
    function GetCurrent : TFhirMolecularSequenceQualityRoc;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceQualityRocList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceQualityRoc read GetCurrent;
  end;

  TFhirMolecularSequenceQualityRocList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceQualityRoc;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceQualityRoc);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceQualityRocList; overload;
    function Clone : TFhirMolecularSequenceQualityRocList; overload;
    function GetEnumerator : TFhirMolecularSequenceQualityRocListEnumerator;
    
    //  Add a FhirMolecularSequenceQualityRoc to the end of the list.
    function Append : TFhirMolecularSequenceQualityRoc;
    
    // Add an already existing FhirMolecularSequenceQualityRoc to the end of the list.
    function AddItem(value : TFhirMolecularSequenceQualityRoc) : TFhirMolecularSequenceQualityRoc; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceQualityRoc) : Integer;
    
    // Insert FhirMolecularSequenceQualityRoc before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceQualityRoc;
    
    // Insert an existing FhirMolecularSequenceQualityRoc before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceQualityRoc);
    
    // Get the iIndexth FhirMolecularSequenceQualityRoc. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceQualityRoc);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceQualityRoc;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceQualityRocs[index : Integer] : TFhirMolecularSequenceQualityRoc read GetItemN write SetItemN; default;
  End;

  // Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
  TFhirMolecularSequenceRepository = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FUrl : TFhirUri;
    FName : TFhirString;
    FDatasetId : TFhirString;
    FVariantsetId : TFhirString;
    FReadsetId : TFhirString;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirRepositoryTypeEnum;
    procedure SetType_ST(value : TFhirRepositoryTypeEnum);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDatasetId(value : TFhirString);
    function GetDatasetIdST : String;
    procedure SetDatasetIdST(value : String);
    procedure SetVariantsetId(value : TFhirString);
    function GetVariantsetIdST : String;
    procedure SetVariantsetIdST(value : String);
    procedure SetReadsetId(value : TFhirString);
    function GetReadsetIdST : String;
    procedure SetReadsetIdST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceRepository; overload;
    function Clone : TFhirMolecularSequenceRepository; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Click and see / RESTful API / Need login to see / RESTful API with authentication / Other ways to see resource.
    property type_ : TFhirRepositoryTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to URI of an external repository which contains further details about the genetics data.
    property url : String read GetUrlST write SetUrlST;
    // URI of an external repository which contains further details about the genetics data.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to URI of an external repository which contains further details about the genetics data.
    property name : String read GetNameST write SetNameST;
    // URI of an external repository which contains further details about the genetics data.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Id of the variant in this external repository. The server will understand how to use this id to call for more info about datasets in external repository.
    property datasetId : String read GetDatasetIdST write SetDatasetIdST;
    // Id of the variant in this external repository. The server will understand how to use this id to call for more info about datasets in external repository.
    property datasetIdElement : TFhirString read FDatasetId write SetDatasetId;

    // Typed access to Id of the variantset in this external repository. The server will understand how to use this id to call for more info about variantsets in external repository.
    property variantsetId : String read GetVariantsetIdST write SetVariantsetIdST;
    // Id of the variantset in this external repository. The server will understand how to use this id to call for more info about variantsets in external repository.
    property variantsetIdElement : TFhirString read FVariantsetId write SetVariantsetId;

    // Typed access to Id of the read in this external repository.
    property readsetId : String read GetReadsetIdST write SetReadsetIdST;
    // Id of the read in this external repository.
    property readsetIdElement : TFhirString read FReadsetId write SetReadsetId;

  end;

  TFhirMolecularSequenceRepositoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceRepositoryList;
    function GetCurrent : TFhirMolecularSequenceRepository;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceRepositoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceRepository read GetCurrent;
  end;

  TFhirMolecularSequenceRepositoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceRepository;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceRepository);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceRepositoryList; overload;
    function Clone : TFhirMolecularSequenceRepositoryList; overload;
    function GetEnumerator : TFhirMolecularSequenceRepositoryListEnumerator;
    
    //  Add a FhirMolecularSequenceRepository to the end of the list.
    function Append : TFhirMolecularSequenceRepository;
    
    // Add an already existing FhirMolecularSequenceRepository to the end of the list.
    function AddItem(value : TFhirMolecularSequenceRepository) : TFhirMolecularSequenceRepository; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceRepository) : Integer;
    
    // Insert FhirMolecularSequenceRepository before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceRepository;
    
    // Insert an existing FhirMolecularSequenceRepository before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceRepository);
    
    // Get the iIndexth FhirMolecularSequenceRepository. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceRepository);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceRepository;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceRepositories[index : Integer] : TFhirMolecularSequenceRepository read GetItemN write SetItemN; default;
  End;

  // Information about chromosome structure variation.
  TFhirMolecularSequenceStructureVariant = class (TFhirBackboneElement)
  protected
    FVariantType : TFhirCodeableConcept;
    FExact : TFhirBoolean;
    FLength : TFhirInteger;
    FOuter : TFhirMolecularSequenceStructureVariantOuter;
    FInner : TFhirMolecularSequenceStructureVariantInner;
    procedure SetVariantType(value : TFhirCodeableConcept);
    procedure SetExact(value : TFhirBoolean);
    function GetExactST : Boolean;
    procedure SetExactST(value : Boolean);
    procedure SetLength(value : TFhirInteger);
    function GetLengthST : String;
    procedure SetLengthST(value : String);
    procedure SetOuter(value : TFhirMolecularSequenceStructureVariantOuter);
    procedure SetInner(value : TFhirMolecularSequenceStructureVariantInner);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceStructureVariant; overload;
    function Clone : TFhirMolecularSequenceStructureVariant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Information about chromosome structure variation DNA change type. (defined for API consistency)
    property variantType : TFhirCodeableConcept read FVariantType write SetVariantType;
    // Information about chromosome structure variation DNA change type.
    property variantTypeElement : TFhirCodeableConcept read FVariantType write SetVariantType;

    // Typed access to Used to indicate if the outer and inner start-end values have the same meaning.
    property exact : Boolean read GetExactST write SetExactST;
    // Used to indicate if the outer and inner start-end values have the same meaning.
    property exactElement : TFhirBoolean read FExact write SetExact;

    // Typed access to Length of the variant chromosome.
    property length : String read GetLengthST write SetLengthST;
    // Length of the variant chromosome.
    property lengthElement : TFhirInteger read FLength write SetLength;

    // Typed access to Structural variant outer. (defined for API consistency)
    property outer : TFhirMolecularSequenceStructureVariantOuter read FOuter write SetOuter;
    // Structural variant outer.
    property outerElement : TFhirMolecularSequenceStructureVariantOuter read FOuter write SetOuter;

    // Typed access to Structural variant inner. (defined for API consistency)
    property inner : TFhirMolecularSequenceStructureVariantInner read FInner write SetInner;
    // Structural variant inner.
    property innerElement : TFhirMolecularSequenceStructureVariantInner read FInner write SetInner;

  end;

  TFhirMolecularSequenceStructureVariantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceStructureVariantList;
    function GetCurrent : TFhirMolecularSequenceStructureVariant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceStructureVariantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceStructureVariant read GetCurrent;
  end;

  TFhirMolecularSequenceStructureVariantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceStructureVariant;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceStructureVariant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceStructureVariantList; overload;
    function Clone : TFhirMolecularSequenceStructureVariantList; overload;
    function GetEnumerator : TFhirMolecularSequenceStructureVariantListEnumerator;
    
    //  Add a FhirMolecularSequenceStructureVariant to the end of the list.
    function Append : TFhirMolecularSequenceStructureVariant;
    
    // Add an already existing FhirMolecularSequenceStructureVariant to the end of the list.
    function AddItem(value : TFhirMolecularSequenceStructureVariant) : TFhirMolecularSequenceStructureVariant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceStructureVariant) : Integer;
    
    // Insert FhirMolecularSequenceStructureVariant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceStructureVariant;
    
    // Insert an existing FhirMolecularSequenceStructureVariant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceStructureVariant);
    
    // Get the iIndexth FhirMolecularSequenceStructureVariant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceStructureVariant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceStructureVariant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceStructureVariants[index : Integer] : TFhirMolecularSequenceStructureVariant read GetItemN write SetItemN; default;
  End;

  // Structural variant outer.
  TFhirMolecularSequenceStructureVariantOuter = class (TFhirBackboneElement)
  protected
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    procedure SetStart(value : TFhirInteger);
    function GetStartST : String;
    procedure SetStartST(value : String);
    procedure SetEnd_(value : TFhirInteger);
    function GetEnd_ST : String;
    procedure SetEnd_ST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceStructureVariantOuter; overload;
    function Clone : TFhirMolecularSequenceStructureVariantOuter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Structural variant outer start. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Structural variant outer start. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to Structural variant outer end. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // Structural variant outer end. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

  end;

  TFhirMolecularSequenceStructureVariantOuterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceStructureVariantOuterList;
    function GetCurrent : TFhirMolecularSequenceStructureVariantOuter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceStructureVariantOuterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceStructureVariantOuter read GetCurrent;
  end;

  TFhirMolecularSequenceStructureVariantOuterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceStructureVariantOuter;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceStructureVariantOuter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceStructureVariantOuterList; overload;
    function Clone : TFhirMolecularSequenceStructureVariantOuterList; overload;
    function GetEnumerator : TFhirMolecularSequenceStructureVariantOuterListEnumerator;
    
    //  Add a FhirMolecularSequenceStructureVariantOuter to the end of the list.
    function Append : TFhirMolecularSequenceStructureVariantOuter;
    
    // Add an already existing FhirMolecularSequenceStructureVariantOuter to the end of the list.
    function AddItem(value : TFhirMolecularSequenceStructureVariantOuter) : TFhirMolecularSequenceStructureVariantOuter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceStructureVariantOuter) : Integer;
    
    // Insert FhirMolecularSequenceStructureVariantOuter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceStructureVariantOuter;
    
    // Insert an existing FhirMolecularSequenceStructureVariantOuter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceStructureVariantOuter);
    
    // Get the iIndexth FhirMolecularSequenceStructureVariantOuter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceStructureVariantOuter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceStructureVariantOuter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceStructureVariantOuters[index : Integer] : TFhirMolecularSequenceStructureVariantOuter read GetItemN write SetItemN; default;
  End;

  // Structural variant inner.
  TFhirMolecularSequenceStructureVariantInner = class (TFhirBackboneElement)
  protected
    FStart : TFhirInteger;
    FEnd_ : TFhirInteger;
    procedure SetStart(value : TFhirInteger);
    function GetStartST : String;
    procedure SetStartST(value : String);
    procedure SetEnd_(value : TFhirInteger);
    function GetEnd_ST : String;
    procedure SetEnd_ST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequenceStructureVariantInner; overload;
    function Clone : TFhirMolecularSequenceStructureVariantInner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Structural variant inner start. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property start : String read GetStartST write SetStartST;
    // Structural variant inner start. If the coordinate system is either 0-based or 1-based, then start position is inclusive.
    property startElement : TFhirInteger read FStart write SetStart;

    // Typed access to Structural variant inner end. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_ : String read GetEnd_ST write SetEnd_ST;
    // Structural variant inner end. If the coordinate system is 0-based then end is exclusive and does not include the last position. If the coordinate system is 1-base, then end is inclusive and includes the last position.
    property end_Element : TFhirInteger read FEnd_ write SetEnd_;

  end;

  TFhirMolecularSequenceStructureVariantInnerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceStructureVariantInnerList;
    function GetCurrent : TFhirMolecularSequenceStructureVariantInner;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceStructureVariantInnerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequenceStructureVariantInner read GetCurrent;
  end;

  TFhirMolecularSequenceStructureVariantInnerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequenceStructureVariantInner;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequenceStructureVariantInner);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceStructureVariantInnerList; overload;
    function Clone : TFhirMolecularSequenceStructureVariantInnerList; overload;
    function GetEnumerator : TFhirMolecularSequenceStructureVariantInnerListEnumerator;
    
    //  Add a FhirMolecularSequenceStructureVariantInner to the end of the list.
    function Append : TFhirMolecularSequenceStructureVariantInner;
    
    // Add an already existing FhirMolecularSequenceStructureVariantInner to the end of the list.
    function AddItem(value : TFhirMolecularSequenceStructureVariantInner) : TFhirMolecularSequenceStructureVariantInner; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequenceStructureVariantInner) : Integer;
    
    // Insert FhirMolecularSequenceStructureVariantInner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequenceStructureVariantInner;
    
    // Insert an existing FhirMolecularSequenceStructureVariantInner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequenceStructureVariantInner);
    
    // Get the iIndexth FhirMolecularSequenceStructureVariantInner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequenceStructureVariantInner);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequenceStructureVariantInner;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequenceStructureVariantInners[index : Integer] : TFhirMolecularSequenceStructureVariantInner read GetItemN write SetItemN; default;
  End;

  // Raw data describing a biological sequence.
  TFhirMolecularSequence = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirEnum;
    FCoordinateSystem : TFhirInteger;
    FPatient : TFhirReference;
    FSpecimen : TFhirReference;
    FDevice : TFhirReference;
    FPerformer : TFhirReference;
    FQuantity : TFhirQuantity;
    FReferenceSeq : TFhirMolecularSequenceReferenceSeq;
    FvariantList : TFhirMolecularSequenceVariantList;
    FObservedSeq : TFhirString;
    FqualityList : TFhirMolecularSequenceQualityList;
    FReadCoverage : TFhirInteger;
    FrepositoryList : TFhirMolecularSequenceRepositoryList;
    FpointerList : TFhirReferenceList;
    FstructureVariantList : TFhirMolecularSequenceStructureVariantList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirSequenceTypeEnum;
    procedure SetType_ST(value : TFhirSequenceTypeEnum);
    procedure SetCoordinateSystem(value : TFhirInteger);
    function GetCoordinateSystemST : String;
    procedure SetCoordinateSystemST(value : String);
    procedure SetPatient(value : TFhirReference);
    procedure SetSpecimen(value : TFhirReference);
    procedure SetDevice(value : TFhirReference);
    procedure SetPerformer(value : TFhirReference);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetReferenceSeq(value : TFhirMolecularSequenceReferenceSeq);
    function GetVariantList : TFhirMolecularSequenceVariantList;
    function GetHasVariantList : Boolean;
    procedure SetObservedSeq(value : TFhirString);
    function GetObservedSeqST : String;
    procedure SetObservedSeqST(value : String);
    function GetQualityList : TFhirMolecularSequenceQualityList;
    function GetHasQualityList : Boolean;
    procedure SetReadCoverage(value : TFhirInteger);
    function GetReadCoverageST : String;
    procedure SetReadCoverageST(value : String);
    function GetRepositoryList : TFhirMolecularSequenceRepositoryList;
    function GetHasRepositoryList : Boolean;
    function GetPointerList : TFhirReferenceList;
    function GetHasPointerList : Boolean;
    function GetStructureVariantList : TFhirMolecularSequenceStructureVariantList;
    function GetHasStructureVariantList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMolecularSequence; overload;
    function Clone : TFhirMolecularSequence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier for this particular sequence instance. This is a FHIR-defined id.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Amino Acid Sequence/ DNA Sequence / RNA Sequence.
    property type_ : TFhirSequenceTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to Whether the sequence is numbered starting at 0 (0-based numbering or coordinates, inclusive start, exclusive end) or starting at 1 (1-based numbering, inclusive start and inclusive end).
    property coordinateSystem : String read GetCoordinateSystemST write SetCoordinateSystemST;
    // Whether the sequence is numbered starting at 0 (0-based numbering or coordinates, inclusive start, exclusive end) or starting at 1 (1-based numbering, inclusive start and inclusive end).
    property coordinateSystemElement : TFhirInteger read FCoordinateSystem write SetCoordinateSystem;

    // Typed access to The patient whose sequencing results are described by this resource. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient whose sequencing results are described by this resource.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to Specimen used for sequencing. (defined for API consistency)
    property specimen : TFhirReference read FSpecimen write SetSpecimen;
    // Specimen used for sequencing.
    property specimenElement : TFhirReference read FSpecimen write SetSpecimen;

    // Typed access to The method for sequencing, for example, chip information. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // The method for sequencing, for example, chip information.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Typed access to The organization or lab that should be responsible for this result. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // The organization or lab that should be responsible for this result.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Typed access to The number of copies of the sequence of interest. (RNASeq). (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The number of copies of the sequence of interest. (RNASeq).
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A sequence that is used as a reference to describe variants that are present in a sequence analyzed. (defined for API consistency)
    property referenceSeq : TFhirMolecularSequenceReferenceSeq read FReferenceSeq write SetReferenceSeq;
    // A sequence that is used as a reference to describe variants that are present in a sequence analyzed.
    property referenceSeqElement : TFhirMolecularSequenceReferenceSeq read FReferenceSeq write SetReferenceSeq;

    // The definition of variant here originates from Sequence ontology ([variant_of](http://www.sequenceontology.org/browser/current_svn/term/variant_of)). This element can represent amino acid or nucleic sequence change(including insertion,deletion,SNP,etc.)  It can represent some complex mutation or segment variation with the assist of CIGAR string.
    property variantList : TFhirMolecularSequenceVariantList read GetVariantList;
    property hasVariantList : boolean read GetHasVariantList;

    // Typed access to Sequence that was observed. It is the result marked by referenceSeq along with variant records on referenceSeq. This shall start from referenceSeq.windowStart and end by referenceSeq.windowEnd.
    property observedSeq : String read GetObservedSeqST write SetObservedSeqST;
    // Sequence that was observed. It is the result marked by referenceSeq along with variant records on referenceSeq. This shall start from referenceSeq.windowStart and end by referenceSeq.windowEnd.
    property observedSeqElement : TFhirString read FObservedSeq write SetObservedSeq;

    // An experimental feature attribute that defines the quality of the feature in a quantitative way, such as a phred quality score ([SO:0001686](http://www.sequenceontology.org/browser/current_svn/term/SO:0001686)).
    property qualityList : TFhirMolecularSequenceQualityList read GetQualityList;
    property hasQualityList : boolean read GetHasQualityList;

    // Typed access to Coverage (read depth or depth) is the average number of reads representing a given nucleotide in the reconstructed sequence.
    property readCoverage : String read GetReadCoverageST write SetReadCoverageST;
    // Coverage (read depth or depth) is the average number of reads representing a given nucleotide in the reconstructed sequence.
    property readCoverageElement : TFhirInteger read FReadCoverage write SetReadCoverage;

    // Configurations of the external repository. The repository shall store target's observedSeq or records related with target's observedSeq.
    property repositoryList : TFhirMolecularSequenceRepositoryList read GetRepositoryList;
    property hasRepositoryList : boolean read GetHasRepositoryList;

    // Pointer to next atomic sequence which at most contains one variant.
    property pointerList : TFhirReferenceList read GetPointerList;
    property hasPointerList : boolean read GetHasPointerList;

    // Information about chromosome structure variation.
    property structureVariantList : TFhirMolecularSequenceStructureVariantList read GetStructureVariantList;
    property hasStructureVariantList : boolean read GetHasStructureVariantList;

  end;

  TFhirMolecularSequenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMolecularSequenceList;
    function GetCurrent : TFhirMolecularSequence;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMolecularSequenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMolecularSequence read GetCurrent;
  end;

  TFhirMolecularSequenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMolecularSequence;
    procedure SetItemN(index : Integer; value : TFhirMolecularSequence);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMolecularSequenceList; overload;
    function Clone : TFhirMolecularSequenceList; overload;
    function GetEnumerator : TFhirMolecularSequenceListEnumerator;
    
    //  Add a FhirMolecularSequence to the end of the list.
    function Append : TFhirMolecularSequence;
    
    // Add an already existing FhirMolecularSequence to the end of the list.
    function AddItem(value : TFhirMolecularSequence) : TFhirMolecularSequence; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMolecularSequence) : Integer;
    
    // Insert FhirMolecularSequence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMolecularSequence;
    
    // Insert an existing FhirMolecularSequence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMolecularSequence);
    
    // Get the iIndexth FhirMolecularSequence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMolecularSequence);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMolecularSequence;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMolecularSequences[index : Integer] : TFhirMolecularSequence read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NUTRITIONORDER}
  // Diet given orally in contrast to enteral (tube) feeding.
  TFhirNutritionOrderOralDiet = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FscheduleList : TFhirTimingList;
    FnutrientList : TFhirNutritionOrderOralDietNutrientList;
    FtextureList : TFhirNutritionOrderOralDietTextureList;
    FfluidConsistencyTypeList : TFhirCodeableConceptList;
    FInstruction : TFhirString;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetScheduleList : TFhirTimingList;
    function GetHasScheduleList : Boolean;
    function GetNutrientList : TFhirNutritionOrderOralDietNutrientList;
    function GetHasNutrientList : Boolean;
    function GetTextureList : TFhirNutritionOrderOralDietTextureList;
    function GetHasTextureList : Boolean;
    function GetFluidConsistencyTypeList : TFhirCodeableConceptList;
    function GetHasFluidConsistencyTypeList : Boolean;
    procedure SetInstruction(value : TFhirString);
    function GetInstructionST : String;
    procedure SetInstructionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDiet; overload;
    function Clone : TFhirNutritionOrderOralDiet; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The kind of diet or dietary restriction such as fiber restricted diet or diabetic diet.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The time period and frequency at which the diet should be given.  The diet should be given for the combination of all schedules if more than one schedule is present.
    property scheduleList : TFhirTimingList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Class that defines the quantity and type of nutrient modifications (for example carbohydrate, fiber or sodium) required for the oral diet.
    property nutrientList : TFhirNutritionOrderOralDietNutrientList read GetNutrientList;
    property hasNutrientList : boolean read GetHasNutrientList;

    // Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
    property textureList : TFhirNutritionOrderOralDietTextureList read GetTextureList;
    property hasTextureList : boolean read GetHasTextureList;

    // The required consistency (e.g. honey-thick, nectar-thick, thin, thickened.) of liquids or fluids served to the patient.
    property fluidConsistencyTypeList : TFhirCodeableConceptList read GetFluidConsistencyTypeList;
    property hasFluidConsistencyTypeList : boolean read GetHasFluidConsistencyTypeList;

    // Typed access to Free text or additional instructions or information pertaining to the oral diet.
    property instruction : String read GetInstructionST write SetInstructionST;
    // Free text or additional instructions or information pertaining to the oral diet.
    property instructionElement : TFhirString read FInstruction write SetInstruction;

  end;

  TFhirNutritionOrderOralDietListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietList;
    function GetCurrent : TFhirNutritionOrderOralDiet;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDiet read GetCurrent;
  end;

  TFhirNutritionOrderOralDietList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderOralDiet;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDiet);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderOralDietList; overload;
    function Clone : TFhirNutritionOrderOralDietList; overload;
    function GetEnumerator : TFhirNutritionOrderOralDietListEnumerator;
    
    //  Add a FhirNutritionOrderOralDiet to the end of the list.
    function Append : TFhirNutritionOrderOralDiet;
    
    // Add an already existing FhirNutritionOrderOralDiet to the end of the list.
    function AddItem(value : TFhirNutritionOrderOralDiet) : TFhirNutritionOrderOralDiet; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDiet) : Integer;
    
    // Insert FhirNutritionOrderOralDiet before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDiet;
    
    // Insert an existing FhirNutritionOrderOralDiet before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDiet);
    
    // Get the iIndexth FhirNutritionOrderOralDiet. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDiet);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDiet;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderOralDiets[index : Integer] : TFhirNutritionOrderOralDiet read GetItemN write SetItemN; default;
  End;

  // Class that defines the quantity and type of nutrient modifications (for example carbohydrate, fiber or sodium) required for the oral diet.
  TFhirNutritionOrderOralDietNutrient = class (TFhirBackboneElement)
  protected
    FModifier : TFhirCodeableConcept;
    FAmount : TFhirQuantity;
    procedure SetModifier(value : TFhirCodeableConcept);
    procedure SetAmount(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDietNutrient; overload;
    function Clone : TFhirNutritionOrderOralDietNutrient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The nutrient that is being modified such as carbohydrate or sodium. (defined for API consistency)
    property modifier : TFhirCodeableConcept read FModifier write SetModifier;
    // The nutrient that is being modified such as carbohydrate or sodium.
    property modifierElement : TFhirCodeableConcept read FModifier write SetModifier;

    // Typed access to The quantity of the specified nutrient to include in diet. (defined for API consistency)
    property amount : TFhirQuantity read FAmount write SetAmount;
    // The quantity of the specified nutrient to include in diet.
    property amountElement : TFhirQuantity read FAmount write SetAmount;

  end;

  TFhirNutritionOrderOralDietNutrientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietNutrientList;
    function GetCurrent : TFhirNutritionOrderOralDietNutrient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietNutrientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDietNutrient read GetCurrent;
  end;

  TFhirNutritionOrderOralDietNutrientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderOralDietNutrient;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDietNutrient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderOralDietNutrientList; overload;
    function Clone : TFhirNutritionOrderOralDietNutrientList; overload;
    function GetEnumerator : TFhirNutritionOrderOralDietNutrientListEnumerator;
    
    //  Add a FhirNutritionOrderOralDietNutrient to the end of the list.
    function Append : TFhirNutritionOrderOralDietNutrient;
    
    // Add an already existing FhirNutritionOrderOralDietNutrient to the end of the list.
    function AddItem(value : TFhirNutritionOrderOralDietNutrient) : TFhirNutritionOrderOralDietNutrient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDietNutrient) : Integer;
    
    // Insert FhirNutritionOrderOralDietNutrient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDietNutrient;
    
    // Insert an existing FhirNutritionOrderOralDietNutrient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDietNutrient);
    
    // Get the iIndexth FhirNutritionOrderOralDietNutrient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDietNutrient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDietNutrient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderOralDietNutrients[index : Integer] : TFhirNutritionOrderOralDietNutrient read GetItemN write SetItemN; default;
  End;

  // Class that describes any texture modifications required for the patient to safely consume various types of solid foods.
  TFhirNutritionOrderOralDietTexture = class (TFhirBackboneElement)
  protected
    FModifier : TFhirCodeableConcept;
    FFoodType : TFhirCodeableConcept;
    procedure SetModifier(value : TFhirCodeableConcept);
    procedure SetFoodType(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderOralDietTexture; overload;
    function Clone : TFhirNutritionOrderOralDietTexture; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed. (defined for API consistency)
    property modifier : TFhirCodeableConcept read FModifier write SetModifier;
    // Any texture modifications (for solid foods) that should be made, e.g. easy to chew, chopped, ground, and pureed.
    property modifierElement : TFhirCodeableConcept read FModifier write SetModifier;

    // Typed access to The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types. (defined for API consistency)
    property foodType : TFhirCodeableConcept read FFoodType write SetFoodType;
    // The food type(s) (e.g. meats, all foods)  that the texture modification applies to.  This could be all foods types.
    property foodTypeElement : TFhirCodeableConcept read FFoodType write SetFoodType;

  end;

  TFhirNutritionOrderOralDietTextureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderOralDietTextureList;
    function GetCurrent : TFhirNutritionOrderOralDietTexture;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderOralDietTextureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderOralDietTexture read GetCurrent;
  end;

  TFhirNutritionOrderOralDietTextureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderOralDietTexture;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderOralDietTexture);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderOralDietTextureList; overload;
    function Clone : TFhirNutritionOrderOralDietTextureList; overload;
    function GetEnumerator : TFhirNutritionOrderOralDietTextureListEnumerator;
    
    //  Add a FhirNutritionOrderOralDietTexture to the end of the list.
    function Append : TFhirNutritionOrderOralDietTexture;
    
    // Add an already existing FhirNutritionOrderOralDietTexture to the end of the list.
    function AddItem(value : TFhirNutritionOrderOralDietTexture) : TFhirNutritionOrderOralDietTexture; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderOralDietTexture) : Integer;
    
    // Insert FhirNutritionOrderOralDietTexture before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderOralDietTexture;
    
    // Insert an existing FhirNutritionOrderOralDietTexture before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderOralDietTexture);
    
    // Get the iIndexth FhirNutritionOrderOralDietTexture. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderOralDietTexture);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderOralDietTexture;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderOralDietTextures[index : Integer] : TFhirNutritionOrderOralDietTexture read GetItemN write SetItemN; default;
  End;

  // Oral nutritional products given in order to add further nutritional value to the patient's diet.
  TFhirNutritionOrderSupplement = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FProductName : TFhirString;
    FscheduleList : TFhirTimingList;
    FQuantity : TFhirQuantity;
    FInstruction : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetProductName(value : TFhirString);
    function GetProductNameST : String;
    procedure SetProductNameST(value : String);
    function GetScheduleList : TFhirTimingList;
    function GetHasScheduleList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetInstruction(value : TFhirString);
    function GetInstructionST : String;
    procedure SetInstructionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderSupplement; overload;
    function Clone : TFhirNutritionOrderSupplement; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of nutritional supplement product required such as a high protein or pediatric clear liquid supplement.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The product or brand name of the nutritional supplement such as "Acme Protein Shake".
    property productName : String read GetProductNameST write SetProductNameST;
    // The product or brand name of the nutritional supplement such as "Acme Protein Shake".
    property productNameElement : TFhirString read FProductName write SetProductName;

    // The time period and frequency at which the supplement(s) should be given.  The supplement should be given for the combination of all schedules if more than one schedule is present.
    property scheduleList : TFhirTimingList read GetScheduleList;
    property hasScheduleList : boolean read GetHasScheduleList;

    // Typed access to The amount of the nutritional supplement to be given. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of the nutritional supplement to be given.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Free text or additional instructions or information pertaining to the oral supplement.
    property instruction : String read GetInstructionST write SetInstructionST;
    // Free text or additional instructions or information pertaining to the oral supplement.
    property instructionElement : TFhirString read FInstruction write SetInstruction;

  end;

  TFhirNutritionOrderSupplementListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderSupplementList;
    function GetCurrent : TFhirNutritionOrderSupplement;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderSupplementList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderSupplement read GetCurrent;
  end;

  TFhirNutritionOrderSupplementList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderSupplement;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderSupplement);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderSupplementList; overload;
    function Clone : TFhirNutritionOrderSupplementList; overload;
    function GetEnumerator : TFhirNutritionOrderSupplementListEnumerator;
    
    //  Add a FhirNutritionOrderSupplement to the end of the list.
    function Append : TFhirNutritionOrderSupplement;
    
    // Add an already existing FhirNutritionOrderSupplement to the end of the list.
    function AddItem(value : TFhirNutritionOrderSupplement) : TFhirNutritionOrderSupplement; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderSupplement) : Integer;
    
    // Insert FhirNutritionOrderSupplement before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderSupplement;
    
    // Insert an existing FhirNutritionOrderSupplement before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderSupplement);
    
    // Get the iIndexth FhirNutritionOrderSupplement. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderSupplement);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderSupplement;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderSupplements[index : Integer] : TFhirNutritionOrderSupplement read GetItemN write SetItemN; default;
  End;

  // Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
  TFhirNutritionOrderEnteralFormula = class (TFhirBackboneElement)
  protected
    FBaseFormulaType : TFhirCodeableConcept;
    FBaseFormulaProductName : TFhirString;
    FAdditiveType : TFhirCodeableConcept;
    FAdditiveProductName : TFhirString;
    FCaloricDensity : TFhirQuantity;
    FRouteofAdministration : TFhirCodeableConcept;
    FadministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    FMaxVolumeToDeliver : TFhirQuantity;
    FAdministrationInstruction : TFhirString;
    procedure SetBaseFormulaType(value : TFhirCodeableConcept);
    procedure SetBaseFormulaProductName(value : TFhirString);
    function GetBaseFormulaProductNameST : String;
    procedure SetBaseFormulaProductNameST(value : String);
    procedure SetAdditiveType(value : TFhirCodeableConcept);
    procedure SetAdditiveProductName(value : TFhirString);
    function GetAdditiveProductNameST : String;
    procedure SetAdditiveProductNameST(value : String);
    procedure SetCaloricDensity(value : TFhirQuantity);
    procedure SetRouteofAdministration(value : TFhirCodeableConcept);
    function GetAdministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    function GetHasAdministrationList : Boolean;
    procedure SetMaxVolumeToDeliver(value : TFhirQuantity);
    procedure SetAdministrationInstruction(value : TFhirString);
    function GetAdministrationInstructionST : String;
    procedure SetAdministrationInstructionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderEnteralFormula; overload;
    function Clone : TFhirNutritionOrderEnteralFormula; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula. (defined for API consistency)
    property baseFormulaType : TFhirCodeableConcept read FBaseFormulaType write SetBaseFormulaType;
    // The type of enteral or infant formula such as an adult standard formula with fiber or a soy-based infant formula.
    property baseFormulaTypeElement : TFhirCodeableConcept read FBaseFormulaType write SetBaseFormulaType;

    // Typed access to The product or brand name of the enteral or infant formula product such as "ACME Adult Standard Formula".
    property baseFormulaProductName : String read GetBaseFormulaProductNameST write SetBaseFormulaProductNameST;
    // The product or brand name of the enteral or infant formula product such as "ACME Adult Standard Formula".
    property baseFormulaProductNameElement : TFhirString read FBaseFormulaProductName write SetBaseFormulaProductName;

    // Typed access to Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula. (defined for API consistency)
    property additiveType : TFhirCodeableConcept read FAdditiveType write SetAdditiveType;
    // Indicates the type of modular component such as protein, carbohydrate, fat or fiber to be provided in addition to or mixed with the base formula.
    property additiveTypeElement : TFhirCodeableConcept read FAdditiveType write SetAdditiveType;

    // Typed access to The product or brand name of the type of modular component to be added to the formula.
    property additiveProductName : String read GetAdditiveProductNameST write SetAdditiveProductNameST;
    // The product or brand name of the type of modular component to be added to the formula.
    property additiveProductNameElement : TFhirString read FAdditiveProductName write SetAdditiveProductName;

    // Typed access to The amount of energy (calories) that the formula should provide per specified volume, typically per mL or fluid oz.  For example, an infant may require a formula that provides 24 calories per fluid ounce or an adult may require an enteral formula that provides 1.5 calorie/mL. (defined for API consistency)
    property caloricDensity : TFhirQuantity read FCaloricDensity write SetCaloricDensity;
    // The amount of energy (calories) that the formula should provide per specified volume, typically per mL or fluid oz.  For example, an infant may require a formula that provides 24 calories per fluid ounce or an adult may require an enteral formula that provides 1.5 calorie/mL.
    property caloricDensityElement : TFhirQuantity read FCaloricDensity write SetCaloricDensity;

    // Typed access to The route or physiological path of administration into the patient's gastrointestinal  tract for purposes of providing the formula feeding, e.g. nasogastric tube. (defined for API consistency)
    property routeofAdministration : TFhirCodeableConcept read FRouteofAdministration write SetRouteofAdministration;
    // The route or physiological path of administration into the patient's gastrointestinal  tract for purposes of providing the formula feeding, e.g. nasogastric tube.
    property routeofAdministrationElement : TFhirCodeableConcept read FRouteofAdministration write SetRouteofAdministration;

    // Formula administration instructions as structured data.  This repeating structure allows for changing the administration rate or volume over time for both bolus and continuous feeding.  An example of this would be an instruction to increase the rate of continuous feeding every 2 hours.
    property administrationList : TFhirNutritionOrderEnteralFormulaAdministrationList read GetAdministrationList;
    property hasAdministrationList : boolean read GetHasAdministrationList;

    // Typed access to The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours. (defined for API consistency)
    property maxVolumeToDeliver : TFhirQuantity read FMaxVolumeToDeliver write SetMaxVolumeToDeliver;
    // The maximum total quantity of formula that may be administered to a subject over the period of time, e.g. 1440 mL over 24 hours.
    property maxVolumeToDeliverElement : TFhirQuantity read FMaxVolumeToDeliver write SetMaxVolumeToDeliver;

    // Typed access to Free text formula administration, feeding instructions or additional instructions or information.
    property administrationInstruction : String read GetAdministrationInstructionST write SetAdministrationInstructionST;
    // Free text formula administration, feeding instructions or additional instructions or information.
    property administrationInstructionElement : TFhirString read FAdministrationInstruction write SetAdministrationInstruction;

  end;

  TFhirNutritionOrderEnteralFormulaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderEnteralFormulaList;
    function GetCurrent : TFhirNutritionOrderEnteralFormula;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderEnteralFormulaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderEnteralFormula read GetCurrent;
  end;

  TFhirNutritionOrderEnteralFormulaList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderEnteralFormula;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderEnteralFormula);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderEnteralFormulaList; overload;
    function Clone : TFhirNutritionOrderEnteralFormulaList; overload;
    function GetEnumerator : TFhirNutritionOrderEnteralFormulaListEnumerator;
    
    //  Add a FhirNutritionOrderEnteralFormula to the end of the list.
    function Append : TFhirNutritionOrderEnteralFormula;
    
    // Add an already existing FhirNutritionOrderEnteralFormula to the end of the list.
    function AddItem(value : TFhirNutritionOrderEnteralFormula) : TFhirNutritionOrderEnteralFormula; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderEnteralFormula) : Integer;
    
    // Insert FhirNutritionOrderEnteralFormula before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderEnteralFormula;
    
    // Insert an existing FhirNutritionOrderEnteralFormula before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderEnteralFormula);
    
    // Get the iIndexth FhirNutritionOrderEnteralFormula. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderEnteralFormula);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderEnteralFormula;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderEnteralFormulas[index : Integer] : TFhirNutritionOrderEnteralFormula read GetItemN write SetItemN; default;
  End;

  // Formula administration instructions as structured data.  This repeating structure allows for changing the administration rate or volume over time for both bolus and continuous feeding.  An example of this would be an instruction to increase the rate of continuous feeding every 2 hours.
  TFhirNutritionOrderEnteralFormulaAdministration = class (TFhirBackboneElement)
  protected
    FSchedule : TFhirTiming;
    FQuantity : TFhirQuantity;
    FRate : TFhirDataType;
    procedure SetSchedule(value : TFhirTiming);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetRate(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrderEnteralFormulaAdministration; overload;
    function Clone : TFhirNutritionOrderEnteralFormulaAdministration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The time period and frequency at which the enteral formula should be delivered to the patient. (defined for API consistency)
    property schedule : TFhirTiming read FSchedule write SetSchedule;
    // The time period and frequency at which the enteral formula should be delivered to the patient.
    property scheduleElement : TFhirTiming read FSchedule write SetSchedule;

    // Typed access to The volume of formula to provide to the patient per the specified administration schedule. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The volume of formula to provide to the patient per the specified administration schedule.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule. (defined for API consistency)
    property rate : TFhirDataType read FRate write SetRate;
    // The rate of administration of formula via a feeding pump, e.g. 60 mL per hour, according to the specified schedule.
    property rateElement : TFhirDataType read FRate write SetRate;

  end;

  TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderEnteralFormulaAdministrationList;
    function GetCurrent : TFhirNutritionOrderEnteralFormulaAdministration;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderEnteralFormulaAdministrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrderEnteralFormulaAdministration read GetCurrent;
  end;

  TFhirNutritionOrderEnteralFormulaAdministrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderEnteralFormulaAdministrationList; overload;
    function Clone : TFhirNutritionOrderEnteralFormulaAdministrationList; overload;
    function GetEnumerator : TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator;
    
    //  Add a FhirNutritionOrderEnteralFormulaAdministration to the end of the list.
    function Append : TFhirNutritionOrderEnteralFormulaAdministration;
    
    // Add an already existing FhirNutritionOrderEnteralFormulaAdministration to the end of the list.
    function AddItem(value : TFhirNutritionOrderEnteralFormulaAdministration) : TFhirNutritionOrderEnteralFormulaAdministration; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrderEnteralFormulaAdministration) : Integer;
    
    // Insert FhirNutritionOrderEnteralFormulaAdministration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;
    
    // Insert an existing FhirNutritionOrderEnteralFormulaAdministration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);
    
    // Get the iIndexth FhirNutritionOrderEnteralFormulaAdministration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrderEnteralFormulaAdministration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrderEnteralFormulaAdministration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrderEnteralFormulaAdministrations[index : Integer] : TFhirNutritionOrderEnteralFormulaAdministration read GetItemN write SetItemN; default;
  End;

  // A request to supply a diet, formula feeding (enteral) or oral nutritional supplement to a patient/resident.
  TFhirNutritionOrder = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FinstantiatesList : TFhirUriList;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FDateTime : TFhirDateTime;
    FOrderer : TFhirReference;
    FallergyIntoleranceList : TFhirReferenceList;
    FfoodPreferenceModifierList : TFhirCodeableConceptList;
    FexcludeFoodModifierList : TFhirCodeableConceptList;
    FOralDiet : TFhirNutritionOrderOralDiet;
    FsupplementList : TFhirNutritionOrderSupplementList;
    FEnteralFormula : TFhirNutritionOrderEnteralFormula;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetInstantiatesList : TFhirUriList;
    function GetHasInstantiatesList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetDateTime(value : TFhirDateTime);
    function GetDateTimeST : TFslDateTime;
    procedure SetDateTimeST(value : TFslDateTime);
    procedure SetOrderer(value : TFhirReference);
    function GetAllergyIntoleranceList : TFhirReferenceList;
    function GetHasAllergyIntoleranceList : Boolean;
    function GetFoodPreferenceModifierList : TFhirCodeableConceptList;
    function GetHasFoodPreferenceModifierList : Boolean;
    function GetExcludeFoodModifierList : TFhirCodeableConceptList;
    function GetHasExcludeFoodModifierList : Boolean;
    procedure SetOralDiet(value : TFhirNutritionOrderOralDiet);
    function GetSupplementList : TFhirNutritionOrderSupplementList;
    function GetHasSupplementList : Boolean;
    procedure SetEnteralFormula(value : TFhirNutritionOrderEnteralFormula);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirNutritionOrder; overload;
    function Clone : TFhirNutritionOrder; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this order by the order sender or by the order receiver.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this NutritionOrder.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this NutritionOrder.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // The URL pointing to a protocol, guideline, orderset or other definition that is adhered to in whole or in part by this NutritionOrder.
    property instantiatesList : TFhirUriList read GetInstantiatesList;
    property hasInstantiatesList : boolean read GetHasInstantiatesList;

    // The workflow status of the nutrition order/request.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the level of authority/intentionality associated with the NutrionOrder and where the request fits into the workflow chain.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Typed access to The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The person (patient) who needs the nutrition order for an oral diet, nutritional supplement and/or enteral or formula feeding.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to An encounter that provides additional information about the healthcare context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // An encounter that provides additional information about the healthcare context in which this request is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date and time that this nutrition order was requested.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // The date and time that this nutrition order was requested.
    property dateTimeElement : TFhirDateTime read FDateTime write SetDateTime;

    // Typed access to The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings. (defined for API consistency)
    property orderer : TFhirReference read FOrderer write SetOrderer;
    // The practitioner that holds legal responsibility for ordering the diet, nutritional supplement, or formula feedings.
    property ordererElement : TFhirReference read FOrderer write SetOrderer;

    // A link to a record of allergies or intolerances  which should be included in the nutrition order.
    property allergyIntoleranceList : TFhirReferenceList read GetAllergyIntoleranceList;
    property hasAllergyIntoleranceList : boolean read GetHasAllergyIntoleranceList;

    // This modifier is used to convey order-specific modifiers about the type of food that should be given. These can be derived from patient allergies, intolerances, or preferences such as Halal, Vegan or Kosher. This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    property foodPreferenceModifierList : TFhirCodeableConceptList read GetFoodPreferenceModifierList;
    property hasFoodPreferenceModifierList : boolean read GetHasFoodPreferenceModifierList;

    // This modifier is used to convey Order-specific modifier about the type of oral food or oral fluids that should not be given. These can be derived from patient allergies, intolerances, or preferences such as No Red Meat, No Soy or No Wheat or  Gluten-Free.  While it should not be necessary to repeat allergy or intolerance information captured in the referenced AllergyIntolerance resource in the excludeFoodModifier, this element may be used to convey additional specificity related to foods that should be eliminated from the patients diet for any reason.  This modifier applies to the entire nutrition order inclusive of the oral diet, nutritional supplements and enteral formula feedings.
    property excludeFoodModifierList : TFhirCodeableConceptList read GetExcludeFoodModifierList;
    property hasExcludeFoodModifierList : boolean read GetHasExcludeFoodModifierList;

    // Typed access to Diet given orally in contrast to enteral (tube) feeding. (defined for API consistency)
    property oralDiet : TFhirNutritionOrderOralDiet read FOralDiet write SetOralDiet;
    // Diet given orally in contrast to enteral (tube) feeding.
    property oralDietElement : TFhirNutritionOrderOralDiet read FOralDiet write SetOralDiet;

    // Oral nutritional products given in order to add further nutritional value to the patient's diet.
    property supplementList : TFhirNutritionOrderSupplementList read GetSupplementList;
    property hasSupplementList : boolean read GetHasSupplementList;

    // Typed access to Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity. (defined for API consistency)
    property enteralFormula : TFhirNutritionOrderEnteralFormula read FEnteralFormula write SetEnteralFormula;
    // Feeding provided through the gastrointestinal tract via a tube, catheter, or stoma that delivers nutrition distal to the oral cavity.
    property enteralFormulaElement : TFhirNutritionOrderEnteralFormula read FEnteralFormula write SetEnteralFormula;

    // Comments made about the {{title)))) by the requester, performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirNutritionOrderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirNutritionOrderList;
    function GetCurrent : TFhirNutritionOrder;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirNutritionOrderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirNutritionOrder read GetCurrent;
  end;

  TFhirNutritionOrderList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirNutritionOrder;
    procedure SetItemN(index : Integer; value : TFhirNutritionOrder);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirNutritionOrderList; overload;
    function Clone : TFhirNutritionOrderList; overload;
    function GetEnumerator : TFhirNutritionOrderListEnumerator;
    
    //  Add a FhirNutritionOrder to the end of the list.
    function Append : TFhirNutritionOrder;
    
    // Add an already existing FhirNutritionOrder to the end of the list.
    function AddItem(value : TFhirNutritionOrder) : TFhirNutritionOrder; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirNutritionOrder) : Integer;
    
    // Insert FhirNutritionOrder before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirNutritionOrder;
    
    // Insert an existing FhirNutritionOrder before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirNutritionOrder);
    
    // Get the iIndexth FhirNutritionOrder. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirNutritionOrder);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirNutritionOrder;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirNutritionOrders[index : Integer] : TFhirNutritionOrder read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
  // Guidance on how to interpret the value by comparison to a normal or recommended range.  Multiple reference ranges are interpreted as an "OR".   In other words, to represent two distinct target populations, two `referenceRange` elements would be used.
  TFhirObservationReferenceRange = class (TFhirBackboneElement)
  protected
    FLow : TFhirQuantity;
    FHigh : TFhirQuantity;
    FType_ : TFhirCodeableConcept;
    FappliesToList : TFhirCodeableConceptList;
    FAge : TFhirRange;
    FText : TFhirString;
    procedure SetLow(value : TFhirQuantity);
    procedure SetHigh(value : TFhirQuantity);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetAppliesToList : TFhirCodeableConceptList;
    function GetHasAppliesToList : Boolean;
    procedure SetAge(value : TFhirRange);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationReferenceRange; overload;
    function Clone : TFhirObservationReferenceRange; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9). If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3). (defined for API consistency)
    property low : TFhirQuantity read FLow write SetLow;
    // The value of the low bound of the reference range.  The low bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9). If the low bound is omitted,  it is assumed to be meaningless (e.g. reference range is <=2.3).
    property lowElement : TFhirQuantity read FLow write SetLow;

    // Typed access to The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9). If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3). (defined for API consistency)
    property high : TFhirQuantity read FHigh write SetHigh;
    // The value of the high bound of the reference range.  The high bound of the reference range endpoint is inclusive of the value (e.g.  reference range is >=5 - <=9). If the high bound is omitted,  it is assumed to be meaningless (e.g. reference range is >= 2.3).
    property highElement : TFhirQuantity read FHigh write SetHigh;

    // Typed access to Codes to indicate the what part of the targeted reference population it applies to. For example, the normal or therapeutic range. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Codes to indicate the what part of the targeted reference population it applies to. For example, the normal or therapeutic range.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Codes to indicate the target population this reference range applies to.  For example, a reference range may be based on the normal population or a particular sex or race.  Multiple `appliesTo`  are interpreted as an "AND" of the target populations.  For example, to represent a target population of African American females, both a code of female and a code for African American would be used.
    property appliesToList : TFhirCodeableConceptList read GetAppliesToList;
    property hasAppliesToList : boolean read GetHasAppliesToList;

    // Typed access to The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so. (defined for API consistency)
    property age : TFhirRange read FAge write SetAge;
    // The age at which this reference range is applicable. This is a neonatal age (e.g. number of weeks at term) if the meaning says so.
    property ageElement : TFhirRange read FAge write SetAge;

    // Typed access to Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of "normals".
    property text : String read GetTextST write SetTextST;
    // Text based reference range in an observation which may be used when a quantitative range is not appropriate for an observation.  An example would be a reference value of "Negative" or a list or table of "normals".
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirObservationReferenceRangeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationReferenceRangeList;
    function GetCurrent : TFhirObservationReferenceRange;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirObservationReferenceRangeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationReferenceRange read GetCurrent;
  end;

  TFhirObservationReferenceRangeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationReferenceRange;
    procedure SetItemN(index : Integer; value : TFhirObservationReferenceRange);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirObservationReferenceRangeList; overload;
    function Clone : TFhirObservationReferenceRangeList; overload;
    function GetEnumerator : TFhirObservationReferenceRangeListEnumerator;
    
    //  Add a FhirObservationReferenceRange to the end of the list.
    function Append : TFhirObservationReferenceRange;
    
    // Add an already existing FhirObservationReferenceRange to the end of the list.
    function AddItem(value : TFhirObservationReferenceRange) : TFhirObservationReferenceRange; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationReferenceRange) : Integer;
    
    // Insert FhirObservationReferenceRange before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationReferenceRange;
    
    // Insert an existing FhirObservationReferenceRange before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationReferenceRange);
    
    // Get the iIndexth FhirObservationReferenceRange. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationReferenceRange);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationReferenceRange;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirObservationReferenceRanges[index : Integer] : TFhirObservationReferenceRange read GetItemN write SetItemN; default;
  End;

  // Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations.
  TFhirObservationComponent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FDataAbsentReason : TFhirCodeableConcept;
    FinterpretationList : TFhirCodeableConceptList;
    FreferenceRangeList : TFhirObservationReferenceRangeList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    function GetInterpretationList : TFhirCodeableConceptList;
    function GetHasInterpretationList : Boolean;
    function GetReferenceRangeList : TFhirObservationReferenceRangeList;
    function GetHasReferenceRangeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservationComponent; overload;
    function Clone : TFhirObservationComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Describes what was observed. Sometimes this is called the observation "code". (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what was observed. Sometimes this is called the observation "code".
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The information determined as a result of making the observation, if the information has a simple value. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The information determined as a result of making the observation, if the information has a simple value.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Provides a reason why the expected value in the element Observation.component.value[x] is missing. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Provides a reason why the expected value in the element Observation.component.value[x] is missing.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // A categorical assessment of an observation value.  For example, high, low, normal.
    property interpretationList : TFhirCodeableConceptList read GetInterpretationList;
    property hasInterpretationList : boolean read GetHasInterpretationList;

    // Guidance on how to interpret the value by comparison to a normal or recommended range.
    property referenceRangeList : TFhirObservationReferenceRangeList read GetReferenceRangeList;
    property hasReferenceRangeList : boolean read GetHasReferenceRangeList;

  end;

  TFhirObservationComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationComponentList;
    function GetCurrent : TFhirObservationComponent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirObservationComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservationComponent read GetCurrent;
  end;

  TFhirObservationComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservationComponent;
    procedure SetItemN(index : Integer; value : TFhirObservationComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirObservationComponentList; overload;
    function Clone : TFhirObservationComponentList; overload;
    function GetEnumerator : TFhirObservationComponentListEnumerator;
    
    //  Add a FhirObservationComponent to the end of the list.
    function Append : TFhirObservationComponent;
    
    // Add an already existing FhirObservationComponent to the end of the list.
    function AddItem(value : TFhirObservationComponent) : TFhirObservationComponent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservationComponent) : Integer;
    
    // Insert FhirObservationComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservationComponent;
    
    // Insert an existing FhirObservationComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservationComponent);
    
    // Get the iIndexth FhirObservationComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservationComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirObservationComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirObservationComponents[index : Integer] : TFhirObservationComponent read GetItemN write SetItemN; default;
  End;

  // Measurements and simple assertions made about a patient, device or other subject.
  TFhirObservation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FfocusList : TFhirReferenceList;
    FEncounter : TFhirReference;
    FEffective : TFhirDataType;
    FIssued : TFhirInstant;
    FperformerList : TFhirReferenceList;
    FValue : TFhirDataType;
    FDataAbsentReason : TFhirCodeableConcept;
    FinterpretationList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FBodySite : TFhirCodeableConcept;
    FMethod : TFhirCodeableConcept;
    FSpecimen : TFhirReference;
    FDevice : TFhirReference;
    FreferenceRangeList : TFhirObservationReferenceRangeList;
    FhasMemberList : TFhirReferenceList;
    FderivedFromList : TFhirReferenceList;
    FcomponentList : TFhirObservationComponentList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirObservationStatusEnum;
    procedure SetStatusST(value : TFhirObservationStatusEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    function GetFocusList : TFhirReferenceList;
    function GetHasFocusList : Boolean;
    procedure SetEncounter(value : TFhirReference);
    procedure SetEffective(value : TFhirDataType);
    procedure SetIssued(value : TFhirInstant);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    function GetPerformerList : TFhirReferenceList;
    function GetHasPerformerList : Boolean;
    procedure SetValue(value : TFhirDataType);
    procedure SetDataAbsentReason(value : TFhirCodeableConcept);
    function GetInterpretationList : TFhirCodeableConceptList;
    function GetHasInterpretationList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetBodySite(value : TFhirCodeableConcept);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetSpecimen(value : TFhirReference);
    procedure SetDevice(value : TFhirReference);
    function GetReferenceRangeList : TFhirObservationReferenceRangeList;
    function GetHasReferenceRangeList : Boolean;
    function GetHasMemberList : TFhirReferenceList;
    function GetHasHasMemberList : Boolean;
    function GetDerivedFromList : TFhirReferenceList;
    function GetHasDerivedFromList : Boolean;
    function GetComponentList : TFhirObservationComponentList;
    function GetHasComponentList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirObservation; overload;
    function Clone : TFhirObservation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this observation.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.  For example, a MedicationRequest may require a patient to have laboratory test performed before  it is dispensed.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular Observation is a component or step.  For example,  an observation as part of a procedure.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The status of the result value.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // A code that classifies the general type of observation being made.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to Describes what was observed. Sometimes this is called the observation "name". (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Describes what was observed. Sometimes this is called the observation "name".
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient, or group of patients, location, or device this observation is about and into whose record the observation is placed. If the actual focus of the observation is different from the subject (or a sample of, part, or region of the subject), the `focus` element or the `code` itself specifies the actual focus of the observation. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient, or group of patients, location, or device this observation is about and into whose record the observation is placed. If the actual focus of the observation is different from the subject (or a sample of, part, or region of the subject), the `focus` element or the `code` itself specifies the actual focus of the observation.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // The actual focus of an observation when it is not the patient of record representing something or someone associated with the patient such as a spouse, parent, fetus, or donor. For example, fetus observations in a mother's record.  The focus of an observation could also be an existing condition,  an intervention, the subject's diet,  another observation of the subject,  or a body structure such as tumor or implanted device.   An example use case would be using the Observation resource to capture whether the mother is trained to change her child's tracheostomy tube. In this example, the child is the patient of record and the mother is the focus.
    property focusList : TFhirReferenceList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) during which this observation is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself. (defined for API consistency)
    property effective : TFhirDataType read FEffective write SetEffective;
    // The time or time-period the observed value is asserted as being true. For biological subjects - e.g. human patients - this is usually called the "physiologically relevant time". This is usually either the time of the procedure or of specimen collection, but very often the source of the date/time is not known, only the date/time itself.
    property effectiveElement : TFhirDataType read FEffective write SetEffective;

    // Typed access to The date and time this version of the observation was made available to providers, typically after the results have been reviewed and verified.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // The date and time this version of the observation was made available to providers, typically after the results have been reviewed and verified.
    property issuedElement : TFhirInstant read FIssued write SetIssued;

    // Who was responsible for asserting the observed value as "true".
    property performerList : TFhirReferenceList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The information determined as a result of making the observation, if the information has a simple value. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The information determined as a result of making the observation, if the information has a simple value.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Provides a reason why the expected value in the element Observation.value[x] is missing. (defined for API consistency)
    property dataAbsentReason : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;
    // Provides a reason why the expected value in the element Observation.value[x] is missing.
    property dataAbsentReasonElement : TFhirCodeableConcept read FDataAbsentReason write SetDataAbsentReason;

    // A categorical assessment of an observation value.  For example, high, low, normal.
    property interpretationList : TFhirCodeableConceptList read GetInterpretationList;
    property hasInterpretationList : boolean read GetHasInterpretationList;

    // Comments about the observation or the results.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Indicates the site on the subject's body where the observation was made (i.e. the target site). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Indicates the site on the subject's body where the observation was made (i.e. the target site).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Typed access to Indicates the mechanism used to perform the observation. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // Indicates the mechanism used to perform the observation.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The specimen that was used when this observation was made. (defined for API consistency)
    property specimen : TFhirReference read FSpecimen write SetSpecimen;
    // The specimen that was used when this observation was made.
    property specimenElement : TFhirReference read FSpecimen write SetSpecimen;

    // Typed access to The device used to generate the observation data. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // The device used to generate the observation data.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Guidance on how to interpret the value by comparison to a normal or recommended range.  Multiple reference ranges are interpreted as an "OR".   In other words, to represent two distinct target populations, two `referenceRange` elements would be used.
    property referenceRangeList : TFhirObservationReferenceRangeList read GetReferenceRangeList;
    property hasReferenceRangeList : boolean read GetHasReferenceRangeList;

    // This observation is a group observation (e.g. a battery, a panel of tests, a set of vital sign measurements) that includes the target as a member of the group.
    property hasMemberList : TFhirReferenceList read GetHasMemberList;
    property hasHasMemberList : boolean read GetHasHasMemberList;

    // The target resource that represents a measurement from which this observation value is derived. For example, a calculated anion gap or a fetal measurement based on an ultrasound image.
    property derivedFromList : TFhirReferenceList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // Some observations have multiple component observations.  These component observations are expressed as separate code value pairs that share the same attributes.  Examples include systolic and diastolic component observations for blood pressure measurement and multiple component observations for genetics observations.
    property componentList : TFhirObservationComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

  end;

  TFhirObservationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirObservationList;
    function GetCurrent : TFhirObservation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirObservationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirObservation read GetCurrent;
  end;

  TFhirObservationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirObservation;
    procedure SetItemN(index : Integer; value : TFhirObservation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirObservationList; overload;
    function Clone : TFhirObservationList; overload;
    function GetEnumerator : TFhirObservationListEnumerator;
    
    //  Add a FhirObservation to the end of the list.
    function Append : TFhirObservation;
    
    // Add an already existing FhirObservation to the end of the list.
    function AddItem(value : TFhirObservation) : TFhirObservation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirObservation) : Integer;
    
    // Insert FhirObservation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirObservation;
    
    // Insert an existing FhirObservation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirObservation);
    
    // Get the iIndexth FhirObservation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirObservation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirObservation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirObservations[index : Integer] : TFhirObservation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_PROCEDURE}
  // Limited to "real" people rather than equipment.
  TFhirProcedurePerformer = class (TFhirBackboneElement)
  protected
    FFunction_ : TFhirCodeableConcept;
    FActor : TFhirReference;
    FOnBehalfOf : TFhirReference;
    procedure SetFunction_(value : TFhirCodeableConcept);
    procedure SetActor(value : TFhirReference);
    procedure SetOnBehalfOf(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedurePerformer; overload;
    function Clone : TFhirProcedurePerformer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Distinguishes the type of involvement of the performer in the procedure. For example, surgeon, anaesthetist, endoscopist. (defined for API consistency)
    property function_ : TFhirCodeableConcept read FFunction_ write SetFunction_;
    // Distinguishes the type of involvement of the performer in the procedure. For example, surgeon, anaesthetist, endoscopist.
    property function_Element : TFhirCodeableConcept read FFunction_ write SetFunction_;

    // Typed access to The practitioner who was involved in the procedure. (defined for API consistency)
    property actor : TFhirReference read FActor write SetActor;
    // The practitioner who was involved in the procedure.
    property actorElement : TFhirReference read FActor write SetActor;

    // Typed access to The organization the device or practitioner was acting on behalf of. (defined for API consistency)
    property onBehalfOf : TFhirReference read FOnBehalfOf write SetOnBehalfOf;
    // The organization the device or practitioner was acting on behalf of.
    property onBehalfOfElement : TFhirReference read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirProcedurePerformerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedurePerformerList;
    function GetCurrent : TFhirProcedurePerformer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirProcedurePerformerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedurePerformer read GetCurrent;
  end;

  TFhirProcedurePerformerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedurePerformer;
    procedure SetItemN(index : Integer; value : TFhirProcedurePerformer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProcedurePerformerList; overload;
    function Clone : TFhirProcedurePerformerList; overload;
    function GetEnumerator : TFhirProcedurePerformerListEnumerator;
    
    //  Add a FhirProcedurePerformer to the end of the list.
    function Append : TFhirProcedurePerformer;
    
    // Add an already existing FhirProcedurePerformer to the end of the list.
    function AddItem(value : TFhirProcedurePerformer) : TFhirProcedurePerformer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedurePerformer) : Integer;
    
    // Insert FhirProcedurePerformer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedurePerformer;
    
    // Insert an existing FhirProcedurePerformer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedurePerformer);
    
    // Get the iIndexth FhirProcedurePerformer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedurePerformer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedurePerformer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProcedurePerformers[index : Integer] : TFhirProcedurePerformer read GetItemN write SetItemN; default;
  End;

  // A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
  TFhirProcedureFocalDevice = class (TFhirBackboneElement)
  protected
    FAction : TFhirCodeableConcept;
    FManipulated : TFhirReference;
    procedure SetAction(value : TFhirCodeableConcept);
    procedure SetManipulated(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedureFocalDevice; overload;
    function Clone : TFhirProcedureFocalDevice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The kind of change that happened to the device during the procedure. (defined for API consistency)
    property action : TFhirCodeableConcept read FAction write SetAction;
    // The kind of change that happened to the device during the procedure.
    property actionElement : TFhirCodeableConcept read FAction write SetAction;

    // Typed access to The device that was manipulated (changed) during the procedure. (defined for API consistency)
    property manipulated : TFhirReference read FManipulated write SetManipulated;
    // The device that was manipulated (changed) during the procedure.
    property manipulatedElement : TFhirReference read FManipulated write SetManipulated;

  end;

  TFhirProcedureFocalDeviceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureFocalDeviceList;
    function GetCurrent : TFhirProcedureFocalDevice;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirProcedureFocalDeviceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedureFocalDevice read GetCurrent;
  end;

  TFhirProcedureFocalDeviceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedureFocalDevice;
    procedure SetItemN(index : Integer; value : TFhirProcedureFocalDevice);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProcedureFocalDeviceList; overload;
    function Clone : TFhirProcedureFocalDeviceList; overload;
    function GetEnumerator : TFhirProcedureFocalDeviceListEnumerator;
    
    //  Add a FhirProcedureFocalDevice to the end of the list.
    function Append : TFhirProcedureFocalDevice;
    
    // Add an already existing FhirProcedureFocalDevice to the end of the list.
    function AddItem(value : TFhirProcedureFocalDevice) : TFhirProcedureFocalDevice; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedureFocalDevice) : Integer;
    
    // Insert FhirProcedureFocalDevice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedureFocalDevice;
    
    // Insert an existing FhirProcedureFocalDevice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedureFocalDevice);
    
    // Get the iIndexth FhirProcedureFocalDevice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedureFocalDevice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedureFocalDevice;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProcedureFocalDevices[index : Integer] : TFhirProcedureFocalDevice read GetItemN write SetItemN; default;
  End;

  // An action that is or was performed on or for a patient. This can be a physical intervention like an operation, or less invasive like long term services, counseling, or hypnotherapy.
  TFhirProcedure = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FPerformed : TFhirDataType;
    FRecorder : TFhirReference;
    FAsserter : TFhirReference;
    FperformerList : TFhirProcedurePerformerList;
    FLocation : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FbodySiteList : TFhirCodeableConceptList;
    FOutcome : TFhirCodeableConcept;
    FreportList : TFhirReferenceList;
    FcomplicationList : TFhirCodeableConceptList;
    FcomplicationDetailList : TFhirReferenceList;
    FfollowUpList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FfocalDeviceList : TFhirProcedureFocalDeviceList;
    FusedReferenceList : TFhirReferenceList;
    FusedCodeList : TFhirCodeableConceptList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEventStatusEnum;
    procedure SetStatusST(value : TFhirEventStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetPerformed(value : TFhirDataType);
    procedure SetRecorder(value : TFhirReference);
    procedure SetAsserter(value : TFhirReference);
    function GetPerformerList : TFhirProcedurePerformerList;
    function GetHasPerformerList : Boolean;
    procedure SetLocation(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    procedure SetOutcome(value : TFhirCodeableConcept);
    function GetReportList : TFhirReferenceList;
    function GetHasReportList : Boolean;
    function GetComplicationList : TFhirCodeableConceptList;
    function GetHasComplicationList : Boolean;
    function GetComplicationDetailList : TFhirReferenceList;
    function GetHasComplicationDetailList : Boolean;
    function GetFollowUpList : TFhirCodeableConceptList;
    function GetHasFollowUpList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetFocalDeviceList : TFhirProcedureFocalDeviceList;
    function GetHasFocalDeviceList : Boolean;
    function GetUsedReferenceList : TFhirReferenceList;
    function GetHasUsedReferenceList : Boolean;
    function GetUsedCodeList : TFhirCodeableConceptList;
    function GetHasUsedCodeList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProcedure; overload;
    function Clone : TFhirProcedure; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this procedure by the performer or other systems which remain constant as the resource is updated and is propagated from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, order set or other definition that is adhered to in whole or in part by this Procedure.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, order set or other definition that is adhered to in whole or in part by this Procedure.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A reference to a resource that contains details of the request for this procedure.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular procedure is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code specifying the state of the procedure. Generally, this will be the in-progress or completed state.
    property status : TFhirEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Captures the reason for the current state of the procedure. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // Captures the reason for the current state of the procedure.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure"). (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // A code that classifies the procedure for searching, sorting and display purposes (e.g. "Surgical Procedure").
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy"). (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The specific procedure that is performed. Use text if the exact nature of the procedure cannot be coded (e.g. "Laparoscopic Appendectomy").
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The person, animal or group on which the procedure was performed. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The person, animal or group on which the procedure was performed.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this Procedure was created or performed or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this Procedure was created or performed or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Estimated or actual date, date-time, period, or age when the procedure was performed.  Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured. (defined for API consistency)
    property performed : TFhirDataType read FPerformed write SetPerformed;
    // Estimated or actual date, date-time, period, or age when the procedure was performed.  Allows a period to support complex procedures that span more than one date, and also allows for the length of the procedure to be captured.
    property performedElement : TFhirDataType read FPerformed write SetPerformed;

    // Typed access to Individual who recorded the record and takes responsibility for its content. (defined for API consistency)
    property recorder : TFhirReference read FRecorder write SetRecorder;
    // Individual who recorded the record and takes responsibility for its content.
    property recorderElement : TFhirReference read FRecorder write SetRecorder;

    // Typed access to Individual who is making the procedure statement. (defined for API consistency)
    property asserter : TFhirReference read FAsserter write SetAsserter;
    // Individual who is making the procedure statement.
    property asserterElement : TFhirReference read FAsserter write SetAsserter;

    // Limited to "real" people rather than equipment.
    property performerList : TFhirProcedurePerformerList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // Typed access to The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The location where the procedure actually happened.  E.g. a newborn at home, a tracheostomy at a restaurant.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // The coded reason why the procedure was performed. This may be a coded entity of some type, or may simply be present as text.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // The justification of why the procedure was performed.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Detailed and structured anatomical location information. Multiple locations are allowed - e.g. multiple punch biopsies of a lesion.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Typed access to The outcome of the procedure - did it resolve the reasons for the procedure being performed? (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // The outcome of the procedure - did it resolve the reasons for the procedure being performed?
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // This could be a histology result, pathology report, surgical report, etc.
    property reportList : TFhirReferenceList read GetReportList;
    property hasReportList : boolean read GetHasReportList;

    // Any complications that occurred during the procedure, or in the immediate post-performance period. These are generally tracked separately from the notes, which will typically describe the procedure itself rather than any 'post procedure' issues.
    property complicationList : TFhirCodeableConceptList read GetComplicationList;
    property hasComplicationList : boolean read GetHasComplicationList;

    // Any complications that occurred during the procedure, or in the immediate post-performance period.
    property complicationDetailList : TFhirReferenceList read GetComplicationDetailList;
    property hasComplicationDetailList : boolean read GetHasComplicationDetailList;

    // If the procedure required specific follow up - e.g. removal of sutures. The follow up may be represented as a simple note or could potentially be more complex, in which case the CarePlan resource can be used.
    property followUpList : TFhirCodeableConceptList read GetFollowUpList;
    property hasFollowUpList : boolean read GetHasFollowUpList;

    // Any other notes and comments about the procedure.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // A device that is implanted, removed or otherwise manipulated (calibration, battery replacement, fitting a prosthesis, attaching a wound-vac, etc.) as a focal portion of the Procedure.
    property focalDeviceList : TFhirProcedureFocalDeviceList read GetFocalDeviceList;
    property hasFocalDeviceList : boolean read GetHasFocalDeviceList;

    // Identifies medications, devices and any other substance used as part of the procedure.
    property usedReferenceList : TFhirReferenceList read GetUsedReferenceList;
    property hasUsedReferenceList : boolean read GetHasUsedReferenceList;

    // Identifies coded items that were used as part of the procedure.
    property usedCodeList : TFhirCodeableConceptList read GetUsedCodeList;
    property hasUsedCodeList : boolean read GetHasUsedCodeList;

  end;

  TFhirProcedureListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProcedureList;
    function GetCurrent : TFhirProcedure;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirProcedureList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProcedure read GetCurrent;
  end;

  TFhirProcedureList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProcedure;
    procedure SetItemN(index : Integer; value : TFhirProcedure);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProcedureList; overload;
    function Clone : TFhirProcedureList; overload;
    function GetEnumerator : TFhirProcedureListEnumerator;
    
    //  Add a FhirProcedure to the end of the list.
    function Append : TFhirProcedure;
    
    // Add an already existing FhirProcedure to the end of the list.
    function AddItem(value : TFhirProcedure) : TFhirProcedure; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProcedure) : Integer;
    
    // Insert FhirProcedure before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProcedure;
    
    // Insert an existing FhirProcedure before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProcedure);
    
    // Get the iIndexth FhirProcedure. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProcedure);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProcedure;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProcedures[index : Integer] : TFhirProcedure read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_RISKASSESSMENT}
  // Describes the expected outcome for the subject.
  TFhirRiskAssessmentPrediction = class (TFhirBackboneElement)
  protected
    FOutcome : TFhirCodeableConcept;
    FProbability : TFhirDataType;
    FQualitativeRisk : TFhirCodeableConcept;
    FRelativeRisk : TFhirDecimal;
    FWhen : TFhirDataType;
    FRationale : TFhirString;
    procedure SetOutcome(value : TFhirCodeableConcept);
    procedure SetProbability(value : TFhirDataType);
    procedure SetQualitativeRisk(value : TFhirCodeableConcept);
    procedure SetRelativeRisk(value : TFhirDecimal);
    function GetRelativeRiskST : String;
    procedure SetRelativeRiskST(value : String);
    procedure SetWhen(value : TFhirDataType);
    procedure SetRationale(value : TFhirString);
    function GetRationaleST : String;
    procedure SetRationaleST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskAssessmentPrediction; overload;
    function Clone : TFhirRiskAssessmentPrediction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to One of the potential outcomes for the patient (e.g. remission, death,  a particular condition). (defined for API consistency)
    property outcome : TFhirCodeableConcept read FOutcome write SetOutcome;
    // One of the potential outcomes for the patient (e.g. remission, death,  a particular condition).
    property outcomeElement : TFhirCodeableConcept read FOutcome write SetOutcome;

    // Typed access to Indicates how likely the outcome is (in the specified timeframe). (defined for API consistency)
    property probability : TFhirDataType read FProbability write SetProbability;
    // Indicates how likely the outcome is (in the specified timeframe).
    property probabilityElement : TFhirDataType read FProbability write SetProbability;

    // Typed access to Indicates how likely the outcome is (in the specified timeframe), expressed as a qualitative value (e.g. low, medium, or high). (defined for API consistency)
    property qualitativeRisk : TFhirCodeableConcept read FQualitativeRisk write SetQualitativeRisk;
    // Indicates how likely the outcome is (in the specified timeframe), expressed as a qualitative value (e.g. low, medium, or high).
    property qualitativeRiskElement : TFhirCodeableConcept read FQualitativeRisk write SetQualitativeRisk;

    // Typed access to Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
    property relativeRisk : String read GetRelativeRiskST write SetRelativeRiskST;
    // Indicates the risk for this particular subject (with their specific characteristics) divided by the risk of the population in general.  (Numbers greater than 1 = higher risk than the population, numbers less than 1 = lower risk.).
    property relativeRiskElement : TFhirDecimal read FRelativeRisk write SetRelativeRisk;

    // Typed access to Indicates the period of time or age range of the subject to which the specified probability applies. (defined for API consistency)
    property when : TFhirDataType read FWhen write SetWhen;
    // Indicates the period of time or age range of the subject to which the specified probability applies.
    property whenElement : TFhirDataType read FWhen write SetWhen;

    // Typed access to Additional information explaining the basis for the prediction.
    property rationale : String read GetRationaleST write SetRationaleST;
    // Additional information explaining the basis for the prediction.
    property rationaleElement : TFhirString read FRationale write SetRationale;

  end;

  TFhirRiskAssessmentPredictionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskAssessmentPredictionList;
    function GetCurrent : TFhirRiskAssessmentPrediction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRiskAssessmentPredictionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskAssessmentPrediction read GetCurrent;
  end;

  TFhirRiskAssessmentPredictionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRiskAssessmentPrediction;
    procedure SetItemN(index : Integer; value : TFhirRiskAssessmentPrediction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRiskAssessmentPredictionList; overload;
    function Clone : TFhirRiskAssessmentPredictionList; overload;
    function GetEnumerator : TFhirRiskAssessmentPredictionListEnumerator;
    
    //  Add a FhirRiskAssessmentPrediction to the end of the list.
    function Append : TFhirRiskAssessmentPrediction;
    
    // Add an already existing FhirRiskAssessmentPrediction to the end of the list.
    function AddItem(value : TFhirRiskAssessmentPrediction) : TFhirRiskAssessmentPrediction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskAssessmentPrediction) : Integer;
    
    // Insert FhirRiskAssessmentPrediction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskAssessmentPrediction;
    
    // Insert an existing FhirRiskAssessmentPrediction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskAssessmentPrediction);
    
    // Get the iIndexth FhirRiskAssessmentPrediction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskAssessmentPrediction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskAssessmentPrediction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRiskAssessmentPredictions[index : Integer] : TFhirRiskAssessmentPrediction read GetItemN write SetItemN; default;
  End;

  // An assessment of the likely outcome(s) for a patient or other subject as well as the likelihood of each outcome.
  TFhirRiskAssessment = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FBasedOn : TFhirReference;
    FParent : TFhirReference;
    FStatus : TFhirEnum;
    FMethod : TFhirCodeableConcept;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FCondition : TFhirReference;
    FPerformer : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FbasisList : TFhirReferenceList;
    FpredictionList : TFhirRiskAssessmentPredictionList;
    FMitigation : TFhirString;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetBasedOn(value : TFhirReference);
    procedure SetParent(value : TFhirReference);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirObservationStatusEnum;
    procedure SetStatusST(value : TFhirObservationStatusEnum);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetCondition(value : TFhirReference);
    procedure SetPerformer(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetBasisList : TFhirReferenceList;
    function GetHasBasisList : Boolean;
    function GetPredictionList : TFhirRiskAssessmentPredictionList;
    function GetHasPredictionList : Boolean;
    procedure SetMitigation(value : TFhirString);
    function GetMitigationST : String;
    procedure SetMitigationST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRiskAssessment; overload;
    function Clone : TFhirRiskAssessment; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifier assigned to the risk assessment.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A reference to the request that is fulfilled by this risk assessment. (defined for API consistency)
    property basedOn : TFhirReference read FBasedOn write SetBasedOn;
    // A reference to the request that is fulfilled by this risk assessment.
    property basedOnElement : TFhirReference read FBasedOn write SetBasedOn;

    // Typed access to A reference to a resource that this risk assessment is part of, such as a Procedure. (defined for API consistency)
    property parent : TFhirReference read FParent write SetParent;
    // A reference to a resource that this risk assessment is part of, such as a Procedure.
    property parentElement : TFhirReference read FParent write SetParent;

    // The status of the RiskAssessment, using the same statuses as an Observation.
    property status : TFhirObservationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The algorithm, process or mechanism used to evaluate the risk. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // The algorithm, process or mechanism used to evaluate the risk.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to The type of the risk assessment performed. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the risk assessment performed.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The patient or group the risk assessment applies to. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group the risk assessment applies to.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter where the assessment was performed. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter where the assessment was performed.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date (and possibly time) the risk assessment was performed. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The date (and possibly time) the risk assessment was performed.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to For assessments or prognosis specific to a particular condition, indicates the condition being assessed. (defined for API consistency)
    property condition : TFhirReference read FCondition write SetCondition;
    // For assessments or prognosis specific to a particular condition, indicates the condition being assessed.
    property conditionElement : TFhirReference read FCondition write SetCondition;

    // Typed access to The provider or software application that performed the assessment. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // The provider or software application that performed the assessment.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // The reason the risk assessment was performed.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Resources supporting the reason the risk assessment was performed.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Indicates the source data considered as part of the assessment (for example, FamilyHistory, Observations, Procedures, Conditions, etc.).
    property basisList : TFhirReferenceList read GetBasisList;
    property hasBasisList : boolean read GetHasBasisList;

    // Describes the expected outcome for the subject.
    property predictionList : TFhirRiskAssessmentPredictionList read GetPredictionList;
    property hasPredictionList : boolean read GetHasPredictionList;

    // Typed access to A description of the steps that might be taken to reduce the identified risk(s).
    property mitigation : String read GetMitigationST write SetMitigationST;
    // A description of the steps that might be taken to reduce the identified risk(s).
    property mitigationElement : TFhirString read FMitigation write SetMitigation;

    // Additional comments about the risk assessment.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirRiskAssessmentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRiskAssessmentList;
    function GetCurrent : TFhirRiskAssessment;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRiskAssessmentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRiskAssessment read GetCurrent;
  end;

  TFhirRiskAssessmentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRiskAssessment;
    procedure SetItemN(index : Integer; value : TFhirRiskAssessment);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRiskAssessmentList; overload;
    function Clone : TFhirRiskAssessmentList; overload;
    function GetEnumerator : TFhirRiskAssessmentListEnumerator;
    
    //  Add a FhirRiskAssessment to the end of the list.
    function Append : TFhirRiskAssessment;
    
    // Add an already existing FhirRiskAssessment to the end of the list.
    function AddItem(value : TFhirRiskAssessment) : TFhirRiskAssessment; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRiskAssessment) : Integer;
    
    // Insert FhirRiskAssessment before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRiskAssessment;
    
    // Insert an existing FhirRiskAssessment before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRiskAssessment);
    
    // Get the iIndexth FhirRiskAssessment. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRiskAssessment);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRiskAssessment;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRiskAssessments[index : Integer] : TFhirRiskAssessment read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SERVICEREQUEST}
  // A record of a request for service such as diagnostic investigations, treatments, or operations to be performed.
  TFhirServiceRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FreplacesList : TFhirReferenceList;
    FRequisition : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FcategoryList : TFhirCodeableConceptList;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FCode : TFhirCodeableConcept;
    ForderDetailList : TFhirCodeableConceptList;
    FQuantity : TFhirDataType;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrence : TFhirDataType;
    FAsNeeded : TFhirDataType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FPerformerType : TFhirCodeableConcept;
    FperformerList : TFhirReferenceList;
    FlocationCodeList : TFhirCodeableConceptList;
    FlocationReferenceList : TFhirReferenceList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FinsuranceList : TFhirReferenceList;
    FsupportingInfoList : TFhirReferenceList;
    FspecimenList : TFhirReferenceList;
    FbodySiteList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    FPatientInstruction : TFhirString;
    FrelevantHistoryList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList;
    function GetHasReplacesList : Boolean;
    procedure SetRequisition(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetCode(value : TFhirCodeableConcept);
    function GetOrderDetailList : TFhirCodeableConceptList;
    function GetHasOrderDetailList : Boolean;
    procedure SetQuantity(value : TFhirDataType);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetAsNeeded(value : TFhirDataType);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    procedure SetPerformerType(value : TFhirCodeableConcept);
    function GetPerformerList : TFhirReferenceList;
    function GetHasPerformerList : Boolean;
    function GetLocationCodeList : TFhirCodeableConceptList;
    function GetHasLocationCodeList : Boolean;
    function GetLocationReferenceList : TFhirReferenceList;
    function GetHasLocationReferenceList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetInsuranceList : TFhirReferenceList;
    function GetHasInsuranceList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetSpecimenList : TFhirReferenceList;
    function GetHasSpecimenList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetPatientInstruction(value : TFhirString);
    function GetPatientInstructionST : String;
    procedure SetPatientInstructionST(value : String);
    function GetRelevantHistoryList : TFhirReferenceList;
    function GetHasRelevantHistoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirServiceRequest; overload;
    function Clone : TFhirServiceRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this order instance by the orderer and/or the receiver and/or order fulfiller.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The URL pointing to a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this ServiceRequest.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // The URL pointing to an externally maintained protocol, guideline, orderset or other definition that is adhered to in whole or in part by this ServiceRequest.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // Plan/proposal/order fulfilled by this request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The request takes the place of the referenced completed or terminated request(s).
    property replacesList : TFhirReferenceList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all service requests that were authorized more or less simultaneously by a single author, representing the composite or group identifier. (defined for API consistency)
    property requisition : TFhirIdentifier read FRequisition write SetRequisition;
    // A shared identifier common to all service requests that were authorized more or less simultaneously by a single author, representing the composite or group identifier.
    property requisitionElement : TFhirIdentifier read FRequisition write SetRequisition;

    // The status of the order.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Whether the request is a proposal, plan, an original order or a reflex order.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // A code that classifies the service for searching, sorting and display purposes (e.g. "Surgical Procedure").
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Indicates how quickly the ServiceRequest should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to Set this to true if the record is saying that the service/procedure should NOT be performed.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // Set this to true if the record is saying that the service/procedure should NOT be performed.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to A code that identifies a particular service (i.e., procedure, diagnostic investigation, or panel of investigations) that have been requested. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies a particular service (i.e., procedure, diagnostic investigation, or panel of investigations) that have been requested.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Additional details and instructions about the how the services are to be delivered.   For example, and order for a urinary catheter may have an order detail for an external or indwelling catheter, or an order for a bandage may require additional instructions specifying how the bandage should be applied.
    property orderDetailList : TFhirCodeableConceptList read GetOrderDetailList;
    property hasOrderDetailList : boolean read GetHasOrderDetailList;

    // Typed access to An amount of service being requested which can be a quantity ( for example $1,500 home modification), a ratio ( for example, 20 half day visits per month), or a range (2.0 to 1.8 Gy per fraction). (defined for API consistency)
    property quantity : TFhirDataType read FQuantity write SetQuantity;
    // An amount of service being requested which can be a quantity ( for example $1,500 home modification), a ratio ( for example, 20 half day visits per month), or a range (2.0 to 1.8 Gy per fraction).
    property quantityElement : TFhirDataType read FQuantity write SetQuantity;

    // Typed access to On whom or what the service is to be performed. This is usually a human patient, but can also be requested on animals, groups of humans or animals, devices such as dialysis machines, or even locations (typically for environmental scans). (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // On whom or what the service is to be performed. This is usually a human patient, but can also be requested on animals, groups of humans or animals, devices such as dialysis machines, or even locations (typically for environmental scans).
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to An encounter that provides additional information about the healthcare context in which this request is made. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // An encounter that provides additional information about the healthcare context in which this request is made.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date/time at which the requested service should occur. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The date/time at which the requested service should occur.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to If a CodeableConcept is present, it indicates the pre-condition for performing the service.  For example "pain", "on flare-up", etc. (defined for API consistency)
    property asNeeded : TFhirDataType read FAsNeeded write SetAsNeeded;
    // If a CodeableConcept is present, it indicates the pre-condition for performing the service.  For example "pain", "on flare-up", etc.
    property asNeededElement : TFhirDataType read FAsNeeded write SetAsNeeded;

    // Typed access to When the request transitioned to being actionable.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // When the request transitioned to being actionable.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The individual who initiated the request and has responsibility for its activation. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The individual who initiated the request and has responsibility for its activation.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // Typed access to Desired type of performer for doing the requested service. (defined for API consistency)
    property performerType : TFhirCodeableConcept read FPerformerType write SetPerformerType;
    // Desired type of performer for doing the requested service.
    property performerTypeElement : TFhirCodeableConcept read FPerformerType write SetPerformerType;

    // The desired performer for doing the requested service.  For example, the surgeon, dermatopathologist, endoscopist, etc.
    property performerList : TFhirReferenceList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // The preferred location(s) where the procedure should actually happen in coded or free text form. E.g. at home or nursing day care center.
    property locationCodeList : TFhirCodeableConceptList read GetLocationCodeList;
    property hasLocationCodeList : boolean read GetHasLocationCodeList;

    // A reference to the the preferred location(s) where the procedure should actually happen. E.g. at home or nursing day care center.
    property locationReferenceList : TFhirReferenceList read GetLocationReferenceList;
    property hasLocationReferenceList : boolean read GetHasLocationReferenceList;

    // An explanation or justification for why this service is being requested in coded or textual form.   This is often for billing purposes.  May relate to the resources referred to in `supportingInfo`.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource that provides a justification for why this service is being requested.   May relate to the resources referred to in `supportingInfo`.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be needed for delivering the requested service.
    property insuranceList : TFhirReferenceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Additional clinical information about the patient or specimen that may influence the services or their interpretations.     This information includes diagnosis, clinical findings and other observations.  In laboratory ordering these are typically referred to as "ask at order entry questions (AOEs)".  This includes observations explicitly requested by the producer (filler) to provide context or supporting information needed to complete the order. For example,  reporting the amount of inspired oxygen for blood gas measurements.
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // One or more specimens that the laboratory procedure will use.
    property specimenList : TFhirReferenceList read GetSpecimenList;
    property hasSpecimenList : boolean read GetHasSpecimenList;

    // Anatomic location where the procedure should be performed. This is the target site.
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Any other notes and comments made about the service request. For example, internal billing notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Instructions in terms that are understood by the patient or consumer.
    property patientInstruction : String read GetPatientInstructionST write SetPatientInstructionST;
    // Instructions in terms that are understood by the patient or consumer.
    property patientInstructionElement : TFhirString read FPatientInstruction write SetPatientInstruction;

    // Key events in the history of the request.
    property relevantHistoryList : TFhirReferenceList read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

  end;

  TFhirServiceRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirServiceRequestList;
    function GetCurrent : TFhirServiceRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirServiceRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirServiceRequest read GetCurrent;
  end;

  TFhirServiceRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirServiceRequest;
    procedure SetItemN(index : Integer; value : TFhirServiceRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirServiceRequestList; overload;
    function Clone : TFhirServiceRequestList; overload;
    function GetEnumerator : TFhirServiceRequestListEnumerator;
    
    //  Add a FhirServiceRequest to the end of the list.
    function Append : TFhirServiceRequest;
    
    // Add an already existing FhirServiceRequest to the end of the list.
    function AddItem(value : TFhirServiceRequest) : TFhirServiceRequest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirServiceRequest) : Integer;
    
    // Insert FhirServiceRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirServiceRequest;
    
    // Insert an existing FhirServiceRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirServiceRequest);
    
    // Get the iIndexth FhirServiceRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirServiceRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirServiceRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirServiceRequests[index : Integer] : TFhirServiceRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SPECIMEN}
  // Details concerning the specimen collection.
  TFhirSpecimenCollection = class (TFhirBackboneElement)
  protected
    FCollector : TFhirReference;
    FCollected : TFhirDataType;
    FDuration : TFhirDuration;
    FQuantity : TFhirQuantity;
    FMethod : TFhirCodeableConcept;
    FBodySite : TFhirCodeableConcept;
    FFastingStatus : TFhirDataType;
    procedure SetCollector(value : TFhirReference);
    procedure SetCollected(value : TFhirDataType);
    procedure SetDuration(value : TFhirDuration);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetBodySite(value : TFhirCodeableConcept);
    procedure SetFastingStatus(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenCollection; overload;
    function Clone : TFhirSpecimenCollection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Person who collected the specimen. (defined for API consistency)
    property collector : TFhirReference read FCollector write SetCollector;
    // Person who collected the specimen.
    property collectorElement : TFhirReference read FCollector write SetCollector;

    // Typed access to Time when specimen was collected from subject - the physiologically relevant time. (defined for API consistency)
    property collected : TFhirDataType read FCollected write SetCollected;
    // Time when specimen was collected from subject - the physiologically relevant time.
    property collectedElement : TFhirDataType read FCollected write SetCollected;

    // Typed access to The span of time over which the collection of a specimen occurred. (defined for API consistency)
    property duration : TFhirDuration read FDuration write SetDuration;
    // The span of time over which the collection of a specimen occurred.
    property durationElement : TFhirDuration read FDuration write SetDuration;

    // Typed access to The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The quantity of specimen collected; for instance the volume of a blood sample, or the physical measurement of an anatomic pathology sample.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A coded value specifying the technique that is used to perform the procedure. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // A coded value specifying the technique that is used to perform the procedure.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens. (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Anatomical location from which the specimen was collected (if subject is a patient). This is the target site.  This element is not used for environmental specimens.
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Typed access to Abstinence or reduction from some or all food, drink, or both, for a period of time prior to sample collection. (defined for API consistency)
    property fastingStatus : TFhirDataType read FFastingStatus write SetFastingStatus;
    // Abstinence or reduction from some or all food, drink, or both, for a period of time prior to sample collection.
    property fastingStatusElement : TFhirDataType read FFastingStatus write SetFastingStatus;

  end;

  TFhirSpecimenCollectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenCollectionList;
    function GetCurrent : TFhirSpecimenCollection;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenCollectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenCollection read GetCurrent;
  end;

  TFhirSpecimenCollectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenCollection;
    procedure SetItemN(index : Integer; value : TFhirSpecimenCollection);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenCollectionList; overload;
    function Clone : TFhirSpecimenCollectionList; overload;
    function GetEnumerator : TFhirSpecimenCollectionListEnumerator;
    
    //  Add a FhirSpecimenCollection to the end of the list.
    function Append : TFhirSpecimenCollection;
    
    // Add an already existing FhirSpecimenCollection to the end of the list.
    function AddItem(value : TFhirSpecimenCollection) : TFhirSpecimenCollection; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenCollection) : Integer;
    
    // Insert FhirSpecimenCollection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenCollection;
    
    // Insert an existing FhirSpecimenCollection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenCollection);
    
    // Get the iIndexth FhirSpecimenCollection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenCollection);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenCollection;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenCollections[index : Integer] : TFhirSpecimenCollection read GetItemN write SetItemN; default;
  End;

  // Details concerning processing and processing steps for the specimen.
  TFhirSpecimenProcessing = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FProcedure_ : TFhirCodeableConcept;
    FadditiveList : TFhirReferenceList;
    FTime : TFhirDataType;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetProcedure_(value : TFhirCodeableConcept);
    function GetAdditiveList : TFhirReferenceList;
    function GetHasAdditiveList : Boolean;
    procedure SetTime(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenProcessing; overload;
    function Clone : TFhirSpecimenProcessing; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Textual description of procedure.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of procedure.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A coded value specifying the procedure used to process the specimen. (defined for API consistency)
    property procedure_ : TFhirCodeableConcept read FProcedure_ write SetProcedure_;
    // A coded value specifying the procedure used to process the specimen.
    property procedure_Element : TFhirCodeableConcept read FProcedure_ write SetProcedure_;

    // Material used in the processing step.
    property additiveList : TFhirReferenceList read GetAdditiveList;
    property hasAdditiveList : boolean read GetHasAdditiveList;

    // Typed access to A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin. (defined for API consistency)
    property time : TFhirDataType read FTime write SetTime;
    // A record of the time or period when the specimen processing occurred.  For example the time of sample fixation or the period of time the sample was in formalin.
    property timeElement : TFhirDataType read FTime write SetTime;

  end;

  TFhirSpecimenProcessingListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenProcessingList;
    function GetCurrent : TFhirSpecimenProcessing;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenProcessingList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenProcessing read GetCurrent;
  end;

  TFhirSpecimenProcessingList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenProcessing;
    procedure SetItemN(index : Integer; value : TFhirSpecimenProcessing);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenProcessingList; overload;
    function Clone : TFhirSpecimenProcessingList; overload;
    function GetEnumerator : TFhirSpecimenProcessingListEnumerator;
    
    //  Add a FhirSpecimenProcessing to the end of the list.
    function Append : TFhirSpecimenProcessing;
    
    // Add an already existing FhirSpecimenProcessing to the end of the list.
    function AddItem(value : TFhirSpecimenProcessing) : TFhirSpecimenProcessing; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenProcessing) : Integer;
    
    // Insert FhirSpecimenProcessing before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenProcessing;
    
    // Insert an existing FhirSpecimenProcessing before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenProcessing);
    
    // Get the iIndexth FhirSpecimenProcessing. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenProcessing);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenProcessing;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenProcessings[index : Integer] : TFhirSpecimenProcessing read GetItemN write SetItemN; default;
  End;

  // The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
  TFhirSpecimenContainer = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FDescription : TFhirString;
    FType_ : TFhirCodeableConcept;
    FCapacity : TFhirQuantity;
    FSpecimenQuantity : TFhirQuantity;
    FAdditive : TFhirDataType;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetCapacity(value : TFhirQuantity);
    procedure SetSpecimenQuantity(value : TFhirQuantity);
    procedure SetAdditive(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimenContainer; overload;
    function Clone : TFhirSpecimenContainer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Id for container. There may be multiple; a manufacturer's bar code, lab assigned identifier, etc. The container ID may differ from the specimen id in some circumstances.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Textual description of the container.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of the container.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The type of container associated with the specimen (e.g. slide, aliquot, etc.). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of container associated with the specimen (e.g. slide, aliquot, etc.).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The capacity (volume or other measure) the container may contain. (defined for API consistency)
    property capacity : TFhirQuantity read FCapacity write SetCapacity;
    // The capacity (volume or other measure) the container may contain.
    property capacityElement : TFhirQuantity read FCapacity write SetCapacity;

    // Typed access to The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type. (defined for API consistency)
    property specimenQuantity : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;
    // The quantity of specimen in the container; may be volume, dimensions, or other appropriate measurements, depending on the specimen type.
    property specimenQuantityElement : TFhirQuantity read FSpecimenQuantity write SetSpecimenQuantity;

    // Typed access to Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA. (defined for API consistency)
    property additive : TFhirDataType read FAdditive write SetAdditive;
    // Introduced substance to preserve, maintain or enhance the specimen. Examples: Formalin, Citrate, EDTA.
    property additiveElement : TFhirDataType read FAdditive write SetAdditive;

  end;

  TFhirSpecimenContainerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenContainerList;
    function GetCurrent : TFhirSpecimenContainer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenContainerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimenContainer read GetCurrent;
  end;

  TFhirSpecimenContainerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimenContainer;
    procedure SetItemN(index : Integer; value : TFhirSpecimenContainer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenContainerList; overload;
    function Clone : TFhirSpecimenContainerList; overload;
    function GetEnumerator : TFhirSpecimenContainerListEnumerator;
    
    //  Add a FhirSpecimenContainer to the end of the list.
    function Append : TFhirSpecimenContainer;
    
    // Add an already existing FhirSpecimenContainer to the end of the list.
    function AddItem(value : TFhirSpecimenContainer) : TFhirSpecimenContainer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimenContainer) : Integer;
    
    // Insert FhirSpecimenContainer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimenContainer;
    
    // Insert an existing FhirSpecimenContainer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimenContainer);
    
    // Get the iIndexth FhirSpecimenContainer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimenContainer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimenContainer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimenContainers[index : Integer] : TFhirSpecimenContainer read GetItemN write SetItemN; default;
  End;

  // A sample to be used for analysis.
  TFhirSpecimen = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FAccessionIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FReceivedTime : TFhirDateTime;
    FparentList : TFhirReferenceList;
    FrequestList : TFhirReferenceList;
    FCollection : TFhirSpecimenCollection;
    FprocessingList : TFhirSpecimenProcessingList;
    FcontainerList : TFhirSpecimenContainerList;
    FconditionList : TFhirCodeableConceptList;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetAccessionIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSpecimenStatusEnum;
    procedure SetStatusST(value : TFhirSpecimenStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetReceivedTime(value : TFhirDateTime);
    function GetReceivedTimeST : TFslDateTime;
    procedure SetReceivedTimeST(value : TFslDateTime);
    function GetParentList : TFhirReferenceList;
    function GetHasParentList : Boolean;
    function GetRequestList : TFhirReferenceList;
    function GetHasRequestList : Boolean;
    procedure SetCollection(value : TFhirSpecimenCollection);
    function GetProcessingList : TFhirSpecimenProcessingList;
    function GetHasProcessingList : Boolean;
    function GetContainerList : TFhirSpecimenContainerList;
    function GetHasContainerList : Boolean;
    function GetConditionList : TFhirCodeableConceptList;
    function GetHasConditionList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSpecimen; overload;
    function Clone : TFhirSpecimen; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Id for specimen.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures. (defined for API consistency)
    property accessionIdentifier : TFhirIdentifier read FAccessionIdentifier write SetAccessionIdentifier;
    // The identifier assigned by the lab when accessioning specimen(s). This is not necessarily the same as the specimen identifier, depending on local lab procedures.
    property accessionIdentifierElement : TFhirIdentifier read FAccessionIdentifier write SetAccessionIdentifier;

    // The availability of the specimen.
    property status : TFhirSpecimenStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The kind of material that forms the specimen. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of material that forms the specimen.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Where the specimen came from. This may be from patient(s), from a location (e.g., the source of an environmental sample), or a sampling of a substance or a device. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Where the specimen came from. This may be from patient(s), from a location (e.g., the source of an environmental sample), or a sampling of a substance or a device.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Time when specimen was received for processing or testing.
    property receivedTime : TFslDateTime read GetReceivedTimeST write SetReceivedTimeST;
    // Time when specimen was received for processing or testing.
    property receivedTimeElement : TFhirDateTime read FReceivedTime write SetReceivedTime;

    // Reference to the parent (source) specimen which is used when the specimen was either derived from or a component of another specimen.
    property parentList : TFhirReferenceList read GetParentList;
    property hasParentList : boolean read GetHasParentList;

    // Details concerning a service request that required a specimen to be collected.
    property requestList : TFhirReferenceList read GetRequestList;
    property hasRequestList : boolean read GetHasRequestList;

    // Typed access to Details concerning the specimen collection. (defined for API consistency)
    property collection : TFhirSpecimenCollection read FCollection write SetCollection;
    // Details concerning the specimen collection.
    property collectionElement : TFhirSpecimenCollection read FCollection write SetCollection;

    // Details concerning processing and processing steps for the specimen.
    property processingList : TFhirSpecimenProcessingList read GetProcessingList;
    property hasProcessingList : boolean read GetHasProcessingList;

    // The container holding the specimen.  The recursive nature of containers; i.e. blood in tube in tray in rack is not addressed here.
    property containerList : TFhirSpecimenContainerList read GetContainerList;
    property hasContainerList : boolean read GetHasContainerList;

    // A mode or state of being that describes the nature of the specimen.
    property conditionList : TFhirCodeableConceptList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // To communicate any details or issues about the specimen or during the specimen collection. (for example: broken vial, sent with patient, frozen).
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirSpecimenListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSpecimenList;
    function GetCurrent : TFhirSpecimen;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSpecimenList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSpecimen read GetCurrent;
  end;

  TFhirSpecimenList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSpecimen;
    procedure SetItemN(index : Integer; value : TFhirSpecimen);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSpecimenList; overload;
    function Clone : TFhirSpecimenList; overload;
    function GetEnumerator : TFhirSpecimenListEnumerator;
    
    //  Add a FhirSpecimen to the end of the list.
    function Append : TFhirSpecimen;
    
    // Add an already existing FhirSpecimen to the end of the list.
    function AddItem(value : TFhirSpecimen) : TFhirSpecimen; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSpecimen) : Integer;
    
    // Insert FhirSpecimen before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSpecimen;
    
    // Insert an existing FhirSpecimen before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSpecimen);
    
    // Get the iIndexth FhirSpecimen. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSpecimen);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSpecimen;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSpecimen[index : Integer] : TFhirSpecimen read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SUPPLYDELIVERY}
  // The item that is being delivered or has been supplied.
  TFhirSupplyDeliverySuppliedItem = class (TFhirBackboneElement)
  protected
    FQuantity : TFhirQuantity;
    FItem : TFhirDataType;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetItem(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyDeliverySuppliedItem; overload;
    function Clone : TFhirSupplyDeliverySuppliedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The amount of supply that has been dispensed. Includes unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount of supply that has been dispensed. Includes unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Identifies the medication, substance or device being dispensed. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // Identifies the medication, substance or device being dispensed. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list.
    property itemElement : TFhirDataType read FItem write SetItem;

  end;

  TFhirSupplyDeliverySuppliedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyDeliverySuppliedItemList;
    function GetCurrent : TFhirSupplyDeliverySuppliedItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSupplyDeliverySuppliedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyDeliverySuppliedItem read GetCurrent;
  end;

  TFhirSupplyDeliverySuppliedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyDeliverySuppliedItem;
    procedure SetItemN(index : Integer; value : TFhirSupplyDeliverySuppliedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSupplyDeliverySuppliedItemList; overload;
    function Clone : TFhirSupplyDeliverySuppliedItemList; overload;
    function GetEnumerator : TFhirSupplyDeliverySuppliedItemListEnumerator;
    
    //  Add a FhirSupplyDeliverySuppliedItem to the end of the list.
    function Append : TFhirSupplyDeliverySuppliedItem;
    
    // Add an already existing FhirSupplyDeliverySuppliedItem to the end of the list.
    function AddItem(value : TFhirSupplyDeliverySuppliedItem) : TFhirSupplyDeliverySuppliedItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyDeliverySuppliedItem) : Integer;
    
    // Insert FhirSupplyDeliverySuppliedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyDeliverySuppliedItem;
    
    // Insert an existing FhirSupplyDeliverySuppliedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyDeliverySuppliedItem);
    
    // Get the iIndexth FhirSupplyDeliverySuppliedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDeliverySuppliedItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyDeliverySuppliedItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSupplyDeliverySuppliedItems[index : Integer] : TFhirSupplyDeliverySuppliedItem read GetItemN write SetItemN; default;
  End;

  // Record of delivery of what is supplied.
  TFhirSupplyDelivery = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FPatient : TFhirReference;
    FType_ : TFhirCodeableConcept;
    FSuppliedItem : TFhirSupplyDeliverySuppliedItem;
    FOccurrence : TFhirDataType;
    FSupplier : TFhirReference;
    FDestination : TFhirReference;
    FreceiverList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSupplyDeliveryStatusEnum;
    procedure SetStatusST(value : TFhirSupplyDeliveryStatusEnum);
    procedure SetPatient(value : TFhirReference);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSuppliedItem(value : TFhirSupplyDeliverySuppliedItem);
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetSupplier(value : TFhirReference);
    procedure SetDestination(value : TFhirReference);
    function GetReceiverList : TFhirReferenceList;
    function GetHasReceiverList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyDelivery; overload;
    function Clone : TFhirSupplyDelivery; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the supply delivery event that is used to identify it across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A plan, proposal or order that is fulfilled in whole or in part by this event.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // A code specifying the state of the dispense event.
    property status : TFhirSupplyDeliveryStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A link to a resource representing the person whom the delivered item is for. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // A link to a resource representing the person whom the delivered item is for.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Indicates the type of dispensing event that is performed. Examples include: Trial Fill, Completion of Trial, Partial Fill, Emergency Fill, Samples, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The item that is being delivered or has been supplied. (defined for API consistency)
    property suppliedItem : TFhirSupplyDeliverySuppliedItem read FSuppliedItem write SetSuppliedItem;
    // The item that is being delivered or has been supplied.
    property suppliedItemElement : TFhirSupplyDeliverySuppliedItem read FSuppliedItem write SetSuppliedItem;

    // Typed access to The date or time(s) the activity occurred. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // The date or time(s) the activity occurred.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to The individual responsible for dispensing the medication, supplier or device. (defined for API consistency)
    property supplier : TFhirReference read FSupplier write SetSupplier;
    // The individual responsible for dispensing the medication, supplier or device.
    property supplierElement : TFhirReference read FSupplier write SetSupplier;

    // Typed access to Identification of the facility/location where the Supply was shipped to, as part of the dispense event. (defined for API consistency)
    property destination : TFhirReference read FDestination write SetDestination;
    // Identification of the facility/location where the Supply was shipped to, as part of the dispense event.
    property destinationElement : TFhirReference read FDestination write SetDestination;

    // Identifies the person who picked up the Supply.
    property receiverList : TFhirReferenceList read GetReceiverList;
    property hasReceiverList : boolean read GetHasReceiverList;

  end;

  TFhirSupplyDeliveryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyDeliveryList;
    function GetCurrent : TFhirSupplyDelivery;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSupplyDeliveryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyDelivery read GetCurrent;
  end;

  TFhirSupplyDeliveryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyDelivery;
    procedure SetItemN(index : Integer; value : TFhirSupplyDelivery);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSupplyDeliveryList; overload;
    function Clone : TFhirSupplyDeliveryList; overload;
    function GetEnumerator : TFhirSupplyDeliveryListEnumerator;
    
    //  Add a FhirSupplyDelivery to the end of the list.
    function Append : TFhirSupplyDelivery;
    
    // Add an already existing FhirSupplyDelivery to the end of the list.
    function AddItem(value : TFhirSupplyDelivery) : TFhirSupplyDelivery; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyDelivery) : Integer;
    
    // Insert FhirSupplyDelivery before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyDelivery;
    
    // Insert an existing FhirSupplyDelivery before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyDelivery);
    
    // Get the iIndexth FhirSupplyDelivery. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyDelivery);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyDelivery;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSupplyDeliveries[index : Integer] : TFhirSupplyDelivery read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
  // Specific parameters for the ordered item.  For example, the size of the indicated item.
  TFhirSupplyRequestParameter = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyRequestParameter; overload;
    function Clone : TFhirSupplyRequestParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code or string that identifies the device detail being asserted. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code or string that identifies the device detail being asserted.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The value of the device detail. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the device detail.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirSupplyRequestParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyRequestParameterList;
    function GetCurrent : TFhirSupplyRequestParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSupplyRequestParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyRequestParameter read GetCurrent;
  end;

  TFhirSupplyRequestParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyRequestParameter;
    procedure SetItemN(index : Integer; value : TFhirSupplyRequestParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSupplyRequestParameterList; overload;
    function Clone : TFhirSupplyRequestParameterList; overload;
    function GetEnumerator : TFhirSupplyRequestParameterListEnumerator;
    
    //  Add a FhirSupplyRequestParameter to the end of the list.
    function Append : TFhirSupplyRequestParameter;
    
    // Add an already existing FhirSupplyRequestParameter to the end of the list.
    function AddItem(value : TFhirSupplyRequestParameter) : TFhirSupplyRequestParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyRequestParameter) : Integer;
    
    // Insert FhirSupplyRequestParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyRequestParameter;
    
    // Insert an existing FhirSupplyRequestParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyRequestParameter);
    
    // Get the iIndexth FhirSupplyRequestParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyRequestParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyRequestParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSupplyRequestParameters[index : Integer] : TFhirSupplyRequestParameter read GetItemN write SetItemN; default;
  End;

  // A record of a request for a medication, substance or device used in the healthcare setting.
  TFhirSupplyRequest = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCategory : TFhirCodeableConcept;
    FPriority : TFhirEnum;
    FItem : TFhirDataType;
    FQuantity : TFhirQuantity;
    FparameterList : TFhirSupplyRequestParameterList;
    FOccurrence : TFhirDataType;
    FAuthoredOn : TFhirDateTime;
    FRequester : TFhirReference;
    FsupplierList : TFhirReferenceList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FDeliverFrom : TFhirReference;
    FDeliverTo : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSupplyRequestStatusEnum;
    procedure SetStatusST(value : TFhirSupplyRequestStatusEnum);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetItem(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    function GetParameterList : TFhirSupplyRequestParameterList;
    function GetHasParameterList : Boolean;
    procedure SetOccurrence(value : TFhirDataType);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    function GetSupplierList : TFhirReferenceList;
    function GetHasSupplierList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    procedure SetDeliverFrom(value : TFhirReference);
    procedure SetDeliverTo(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSupplyRequest; overload;
    function Clone : TFhirSupplyRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers assigned to this SupplyRequest by the author and/or other systems. These identifiers remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Status of the supply request.
    property status : TFhirSupplyRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Category of supply, e.g.  central, non-stock, etc. This is used to support work flows associated with the supply process.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Indicates how quickly this SupplyRequest should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to The item that is requested to be supplied. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list. (defined for API consistency)
    property item : TFhirDataType read FItem write SetItem;
    // The item that is requested to be supplied. This is either a link to a resource representing the details of the item or a code that identifies the item from a known list.
    property itemElement : TFhirDataType read FItem write SetItem;

    // Typed access to The amount that is being ordered of the indicated item. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The amount that is being ordered of the indicated item.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Specific parameters for the ordered item.  For example, the size of the indicated item.
    property parameterList : TFhirSupplyRequestParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

    // Typed access to When the request should be fulfilled. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // When the request should be fulfilled.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Typed access to When the request was made.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // When the request was made.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The device, practitioner, etc. who initiated the request. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The device, practitioner, etc. who initiated the request.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // Who is intended to fulfill the request.
    property supplierList : TFhirReferenceList read GetSupplierList;
    property hasSupplierList : boolean read GetHasSupplierList;

    // The reason why the supply item was requested.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // The reason why the supply item was requested.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Typed access to Where the supply is expected to come from. (defined for API consistency)
    property deliverFrom : TFhirReference read FDeliverFrom write SetDeliverFrom;
    // Where the supply is expected to come from.
    property deliverFromElement : TFhirReference read FDeliverFrom write SetDeliverFrom;

    // Typed access to Where the supply is destined to go. (defined for API consistency)
    property deliverTo : TFhirReference read FDeliverTo write SetDeliverTo;
    // Where the supply is destined to go.
    property deliverToElement : TFhirReference read FDeliverTo write SetDeliverTo;

  end;

  TFhirSupplyRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSupplyRequestList;
    function GetCurrent : TFhirSupplyRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSupplyRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSupplyRequest read GetCurrent;
  end;

  TFhirSupplyRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSupplyRequest;
    procedure SetItemN(index : Integer; value : TFhirSupplyRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSupplyRequestList; overload;
    function Clone : TFhirSupplyRequestList; overload;
    function GetEnumerator : TFhirSupplyRequestListEnumerator;
    
    //  Add a FhirSupplyRequest to the end of the list.
    function Append : TFhirSupplyRequest;
    
    // Add an already existing FhirSupplyRequest to the end of the list.
    function AddItem(value : TFhirSupplyRequest) : TFhirSupplyRequest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSupplyRequest) : Integer;
    
    // Insert FhirSupplyRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSupplyRequest;
    
    // Insert an existing FhirSupplyRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSupplyRequest);
    
    // Get the iIndexth FhirSupplyRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSupplyRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSupplyRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSupplyRequests[index : Integer] : TFhirSupplyRequest read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_VISIONPRESCRIPTION}
  // Contain the details of  the individual lens specifications and serves as the authorization for the fullfillment by certified professionals.
  TFhirVisionPrescriptionLensSpecification = class (TFhirBackboneElement)
  protected
    FProduct : TFhirCodeableConcept;
    FEye : TFhirEnum;
    FSphere : TFhirDecimal;
    FCylinder : TFhirDecimal;
    FAxis : TFhirInteger;
    FprismList : TFhirVisionPrescriptionLensSpecificationPrismList;
    FAdd : TFhirDecimal;
    FPower : TFhirDecimal;
    FBackCurve : TFhirDecimal;
    FDiameter : TFhirDecimal;
    FDuration : TFhirQuantity;
    FColor : TFhirString;
    FBrand : TFhirString;
    FnoteList : TFhirAnnotationList;
    procedure SetProduct(value : TFhirCodeableConcept);
    procedure SetEye(value : TFhirEnum);
    function GetEyeST : TFhirVisionEyesEnum;
    procedure SetEyeST(value : TFhirVisionEyesEnum);
    procedure SetSphere(value : TFhirDecimal);
    function GetSphereST : String;
    procedure SetSphereST(value : String);
    procedure SetCylinder(value : TFhirDecimal);
    function GetCylinderST : String;
    procedure SetCylinderST(value : String);
    procedure SetAxis(value : TFhirInteger);
    function GetAxisST : String;
    procedure SetAxisST(value : String);
    function GetPrismList : TFhirVisionPrescriptionLensSpecificationPrismList;
    function GetHasPrismList : Boolean;
    procedure SetAdd(value : TFhirDecimal);
    function GetAddST : String;
    procedure SetAddST(value : String);
    procedure SetPower(value : TFhirDecimal);
    function GetPowerST : String;
    procedure SetPowerST(value : String);
    procedure SetBackCurve(value : TFhirDecimal);
    function GetBackCurveST : String;
    procedure SetBackCurveST(value : String);
    procedure SetDiameter(value : TFhirDecimal);
    function GetDiameterST : String;
    procedure SetDiameterST(value : String);
    procedure SetDuration(value : TFhirQuantity);
    procedure SetColor(value : TFhirString);
    function GetColorST : String;
    procedure SetColorST(value : String);
    procedure SetBrand(value : TFhirString);
    function GetBrandST : String;
    procedure SetBrandST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescriptionLensSpecification; overload;
    function Clone : TFhirVisionPrescriptionLensSpecification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies the type of vision correction product which is required for the patient. (defined for API consistency)
    property product : TFhirCodeableConcept read FProduct write SetProduct;
    // Identifies the type of vision correction product which is required for the patient.
    property productElement : TFhirCodeableConcept read FProduct write SetProduct;

    // The eye for which the lens specification applies.
    property eye : TFhirVisionEyesEnum read GetEyeST write SetEyeST;
    property eyeElement : TFhirEnum read FEye write SetEye;

    // Typed access to Lens power measured in dioptres (0.25 units).
    property sphere : String read GetSphereST write SetSphereST;
    // Lens power measured in dioptres (0.25 units).
    property sphereElement : TFhirDecimal read FSphere write SetSphere;

    // Typed access to Power adjustment for astigmatism measured in dioptres (0.25 units).
    property cylinder : String read GetCylinderST write SetCylinderST;
    // Power adjustment for astigmatism measured in dioptres (0.25 units).
    property cylinderElement : TFhirDecimal read FCylinder write SetCylinder;

    // Typed access to Adjustment for astigmatism measured in integer degrees.
    property axis : String read GetAxisST write SetAxisST;
    // Adjustment for astigmatism measured in integer degrees.
    property axisElement : TFhirInteger read FAxis write SetAxis;

    // Allows for adjustment on two axis.
    property prismList : TFhirVisionPrescriptionLensSpecificationPrismList read GetPrismList;
    property hasPrismList : boolean read GetHasPrismList;

    // Typed access to Power adjustment for multifocal lenses measured in dioptres (0.25 units).
    property add : String read GetAddST write SetAddST;
    // Power adjustment for multifocal lenses measured in dioptres (0.25 units).
    property addElement : TFhirDecimal read FAdd write SetAdd;

    // Typed access to Contact lens power measured in dioptres (0.25 units).
    property power : String read GetPowerST write SetPowerST;
    // Contact lens power measured in dioptres (0.25 units).
    property powerElement : TFhirDecimal read FPower write SetPower;

    // Typed access to Back curvature measured in millimetres.
    property backCurve : String read GetBackCurveST write SetBackCurveST;
    // Back curvature measured in millimetres.
    property backCurveElement : TFhirDecimal read FBackCurve write SetBackCurve;

    // Typed access to Contact lens diameter measured in millimetres.
    property diameter : String read GetDiameterST write SetDiameterST;
    // Contact lens diameter measured in millimetres.
    property diameterElement : TFhirDecimal read FDiameter write SetDiameter;

    // Typed access to The recommended maximum wear period for the lens. (defined for API consistency)
    property duration : TFhirQuantity read FDuration write SetDuration;
    // The recommended maximum wear period for the lens.
    property durationElement : TFhirQuantity read FDuration write SetDuration;

    // Typed access to Special color or pattern.
    property color : String read GetColorST write SetColorST;
    // Special color or pattern.
    property colorElement : TFhirString read FColor write SetColor;

    // Typed access to Brand recommendations or restrictions.
    property brand : String read GetBrandST write SetBrandST;
    // Brand recommendations or restrictions.
    property brandElement : TFhirString read FBrand write SetBrand;

    // Notes for special requirements such as coatings and lens materials.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirVisionPrescriptionLensSpecificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionLensSpecificationList;
    function GetCurrent : TFhirVisionPrescriptionLensSpecification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionLensSpecificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescriptionLensSpecification read GetCurrent;
  end;

  TFhirVisionPrescriptionLensSpecificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVisionPrescriptionLensSpecification;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescriptionLensSpecification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVisionPrescriptionLensSpecificationList; overload;
    function Clone : TFhirVisionPrescriptionLensSpecificationList; overload;
    function GetEnumerator : TFhirVisionPrescriptionLensSpecificationListEnumerator;
    
    //  Add a FhirVisionPrescriptionLensSpecification to the end of the list.
    function Append : TFhirVisionPrescriptionLensSpecification;
    
    // Add an already existing FhirVisionPrescriptionLensSpecification to the end of the list.
    function AddItem(value : TFhirVisionPrescriptionLensSpecification) : TFhirVisionPrescriptionLensSpecification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescriptionLensSpecification) : Integer;
    
    // Insert FhirVisionPrescriptionLensSpecification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescriptionLensSpecification;
    
    // Insert an existing FhirVisionPrescriptionLensSpecification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescriptionLensSpecification);
    
    // Get the iIndexth FhirVisionPrescriptionLensSpecification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescriptionLensSpecification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescriptionLensSpecification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVisionPrescriptionLensSpecifications[index : Integer] : TFhirVisionPrescriptionLensSpecification read GetItemN write SetItemN; default;
  End;

  // Allows for adjustment on two axis.
  TFhirVisionPrescriptionLensSpecificationPrism = class (TFhirBackboneElement)
  protected
    FAmount : TFhirDecimal;
    FBase : TFhirEnum;
    procedure SetAmount(value : TFhirDecimal);
    function GetAmountST : String;
    procedure SetAmountST(value : String);
    procedure SetBase(value : TFhirEnum);
    function GetBaseST : TFhirVisionBaseEnum;
    procedure SetBaseST(value : TFhirVisionBaseEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescriptionLensSpecificationPrism; overload;
    function Clone : TFhirVisionPrescriptionLensSpecificationPrism; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Amount of prism to compensate for eye alignment in fractional units.
    property amount : String read GetAmountST write SetAmountST;
    // Amount of prism to compensate for eye alignment in fractional units.
    property amountElement : TFhirDecimal read FAmount write SetAmount;

    // The relative base, or reference lens edge, for the prism.
    property base : TFhirVisionBaseEnum read GetBaseST write SetBaseST;
    property baseElement : TFhirEnum read FBase write SetBase;

  end;

  TFhirVisionPrescriptionLensSpecificationPrismListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionLensSpecificationPrismList;
    function GetCurrent : TFhirVisionPrescriptionLensSpecificationPrism;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionLensSpecificationPrismList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescriptionLensSpecificationPrism read GetCurrent;
  end;

  TFhirVisionPrescriptionLensSpecificationPrismList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVisionPrescriptionLensSpecificationPrism;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescriptionLensSpecificationPrism);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVisionPrescriptionLensSpecificationPrismList; overload;
    function Clone : TFhirVisionPrescriptionLensSpecificationPrismList; overload;
    function GetEnumerator : TFhirVisionPrescriptionLensSpecificationPrismListEnumerator;
    
    //  Add a FhirVisionPrescriptionLensSpecificationPrism to the end of the list.
    function Append : TFhirVisionPrescriptionLensSpecificationPrism;
    
    // Add an already existing FhirVisionPrescriptionLensSpecificationPrism to the end of the list.
    function AddItem(value : TFhirVisionPrescriptionLensSpecificationPrism) : TFhirVisionPrescriptionLensSpecificationPrism; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescriptionLensSpecificationPrism) : Integer;
    
    // Insert FhirVisionPrescriptionLensSpecificationPrism before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescriptionLensSpecificationPrism;
    
    // Insert an existing FhirVisionPrescriptionLensSpecificationPrism before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescriptionLensSpecificationPrism);
    
    // Get the iIndexth FhirVisionPrescriptionLensSpecificationPrism. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescriptionLensSpecificationPrism);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescriptionLensSpecificationPrism;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVisionPrescriptionLensSpecificationPrisms[index : Integer] : TFhirVisionPrescriptionLensSpecificationPrism read GetItemN write SetItemN; default;
  End;

  // An authorization for the provision of glasses and/or contact lenses to a patient.
  TFhirVisionPrescription = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FCreated : TFhirDateTime;
    FPatient : TFhirReference;
    FEncounter : TFhirReference;
    FDateWritten : TFhirDateTime;
    FPrescriber : TFhirReference;
    FlensSpecificationList : TFhirVisionPrescriptionLensSpecificationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFinancialResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
    procedure SetCreated(value : TFhirDateTime);
    function GetCreatedST : TFslDateTime;
    procedure SetCreatedST(value : TFslDateTime);
    procedure SetPatient(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetDateWritten(value : TFhirDateTime);
    function GetDateWrittenST : TFslDateTime;
    procedure SetDateWrittenST(value : TFslDateTime);
    procedure SetPrescriber(value : TFhirReference);
    function GetLensSpecificationList : TFhirVisionPrescriptionLensSpecificationList;
    function GetHasLensSpecificationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVisionPrescription; overload;
    function Clone : TFhirVisionPrescription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique identifier assigned to this vision prescription.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status of the resource instance.
    property status : TFhirFinancialResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date this resource was created.
    property created : TFslDateTime read GetCreatedST write SetCreatedST;
    // The date this resource was created.
    property createdElement : TFhirDateTime read FCreated write SetCreated;

    // Typed access to A resource reference to the person to whom the vision prescription applies. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // A resource reference to the person to whom the vision prescription applies.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to A reference to a resource that identifies the particular occurrence of contact between patient and health care provider during which the prescription was issued. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // A reference to a resource that identifies the particular occurrence of contact between patient and health care provider during which the prescription was issued.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date (and perhaps time) when the prescription was written.
    property dateWritten : TFslDateTime read GetDateWrittenST write SetDateWrittenST;
    // The date (and perhaps time) when the prescription was written.
    property dateWrittenElement : TFhirDateTime read FDateWritten write SetDateWritten;

    // Typed access to The healthcare professional responsible for authorizing the prescription. (defined for API consistency)
    property prescriber : TFhirReference read FPrescriber write SetPrescriber;
    // The healthcare professional responsible for authorizing the prescription.
    property prescriberElement : TFhirReference read FPrescriber write SetPrescriber;

    // Contain the details of  the individual lens specifications and serves as the authorization for the fullfillment by certified professionals.
    property lensSpecificationList : TFhirVisionPrescriptionLensSpecificationList read GetLensSpecificationList;
    property hasLensSpecificationList : boolean read GetHasLensSpecificationList;

  end;

  TFhirVisionPrescriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVisionPrescriptionList;
    function GetCurrent : TFhirVisionPrescription;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVisionPrescriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVisionPrescription read GetCurrent;
  end;

  TFhirVisionPrescriptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVisionPrescription;
    procedure SetItemN(index : Integer; value : TFhirVisionPrescription);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVisionPrescriptionList; overload;
    function Clone : TFhirVisionPrescriptionList; overload;
    function GetEnumerator : TFhirVisionPrescriptionListEnumerator;
    
    //  Add a FhirVisionPrescription to the end of the list.
    function Append : TFhirVisionPrescription;
    
    // Add an already existing FhirVisionPrescription to the end of the list.
    function AddItem(value : TFhirVisionPrescription) : TFhirVisionPrescription; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVisionPrescription) : Integer;
    
    // Insert FhirVisionPrescription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVisionPrescription;
    
    // Insert an existing FhirVisionPrescription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVisionPrescription);
    
    // Get the iIndexth FhirVisionPrescription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVisionPrescription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVisionPrescription;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVisionPrescriptions[index : Integer] : TFhirVisionPrescription read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VISIONPRESCRIPTION}



implementation

uses
  fhir4b_utilities;



{$IFDEF FHIR_ADVERSEEVENT}
{ TFhirAdverseEventSuspectEntity }

constructor TFhirAdverseEventSuspectEntity.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventSuspectEntity.Destroy;
begin
  FInstance.free;
  FCausalityList.Free;
  inherited;
end;

procedure TFhirAdverseEventSuspectEntity.Assign(oSource : TFslObject);
begin
  inherited;
  instance := TFhirAdverseEventSuspectEntity(oSource).instance.Clone;
  if (TFhirAdverseEventSuspectEntity(oSource).FCausalityList = nil) then
  begin
    FCausalityList.free;
    FCausalityList := nil;
  end
  else
  begin
    if FCausalityList = nil then
      FCausalityList := TFhirAdverseEventSuspectEntityCausalityList.Create;
    FCausalityList.Assign(TFhirAdverseEventSuspectEntity(oSource).FCausalityList);
  end;
end;

procedure TFhirAdverseEventSuspectEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'instance') Then
     list.add(self.link, 'instance', FInstance.Link);
  if (child_name = 'causality') Then
    list.addAll(self, 'causality', FCausalityList);
end;

procedure TFhirAdverseEventSuspectEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'instance', 'Reference', false, TFhirReference, FInstance.Link));
  oList.add(TFHIRProperty.create(self, 'causality', 'BackboneElement', true, TFhirAdverseEventSuspectEntityCausality, FCausalityList.Link));
end;

function TFhirAdverseEventSuspectEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'instance') then
  begin
    Instance := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'causality') then
  begin
    CausalityList.add(propValue as TFhirAdverseEventSuspectEntityCausality);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventSuspectEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'causality') then CausalityList.insertItem(index, propValue as TFhirAdverseEventSuspectEntityCausality)
  else inherited;
end;

function TFhirAdverseEventSuspectEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'instance') then result := TFhirReference.create()
  else if (propName = 'causality') then result := CausalityList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventSuspectEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'instance') then result := 'Reference'
  else if (propName = 'causality') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventSuspectEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'instance') then InstanceElement := nil
  else if (propName = 'causality') then deletePropertyValue('causality', CausalityList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventSuspectEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'instance') then InstanceElement := new as TFhirReference
  else if (propName = 'causality') then replacePropertyValue('causality', CausalityList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventSuspectEntity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'causality') then CausalityList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventSuspectEntity.fhirType : string;
begin
  result := 'AdverseEvent.suspectEntity';
end;

function TFhirAdverseEventSuspectEntity.Link : TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(inherited Link);
end;

function TFhirAdverseEventSuspectEntity.Clone : TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(inherited Clone);
end;

function TFhirAdverseEventSuspectEntity.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEventSuspectEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventSuspectEntity)) then
    result := false
  else
  begin
    o := TFhirAdverseEventSuspectEntity(other);
    result := compareDeep(instanceElement, o.instanceElement, true) and compareDeep(causalityList, o.causalityList, true);
  end;
end;

function TFhirAdverseEventSuspectEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FInstance) and isEmptyProp(FcausalityList);
end;

procedure TFhirAdverseEventSuspectEntity.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('instance');
  fields.add('causality');
end;

function TFhirAdverseEventSuspectEntity.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCausalityList.sizeInBytes(magic));
end;

procedure TFhirAdverseEventSuspectEntity.SetInstance(value : TFhirReference);
begin
  FInstance.free;
  FInstance := value;
end;

function TFhirAdverseEventSuspectEntity.GetCausalityList : TFhirAdverseEventSuspectEntityCausalityList;
begin
  if FCausalityList = nil then
    FCausalityList := TFhirAdverseEventSuspectEntityCausalityList.Create;
  result := FCausalityList;
end;

function TFhirAdverseEventSuspectEntity.GetHasCausalityList : boolean;
begin
  result := (FCausalityList <> nil) and (FCausalityList.count > 0);
end;

{ TFhirAdverseEventSuspectEntityListEnumerator }

constructor TFhirAdverseEventSuspectEntityListEnumerator.Create(list : TFhirAdverseEventSuspectEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventSuspectEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventSuspectEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventSuspectEntityListEnumerator.GetCurrent : TFhirAdverseEventSuspectEntity;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventSuspectEntityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdverseEventSuspectEntityList }

function TFhirAdverseEventSuspectEntityList.AddItem(value: TFhirAdverseEventSuspectEntity): TFhirAdverseEventSuspectEntity;
begin
  assert(value.ClassName = 'TFhirAdverseEventSuspectEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventSuspectEntity');
  add(value);
  result := value;
end;

function TFhirAdverseEventSuspectEntityList.Append: TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventSuspectEntityList.GetEnumerator : TFhirAdverseEventSuspectEntityListEnumerator;
begin
  result := TFhirAdverseEventSuspectEntityListEnumerator.Create(self.link);
end;

function TFhirAdverseEventSuspectEntityList.Clone: TFhirAdverseEventSuspectEntityList;
begin
  result := TFhirAdverseEventSuspectEntityList(inherited Clone);
end;

function TFhirAdverseEventSuspectEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventSuspectEntityList.GetItemN(index: Integer): TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventSuspectEntity;
end;
function TFhirAdverseEventSuspectEntityList.IndexOf(value: TFhirAdverseEventSuspectEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventSuspectEntityList.Insert(index: Integer): TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityList.InsertItem(index: Integer; value: TFhirAdverseEventSuspectEntity);
begin
  assert(value is TFhirAdverseEventSuspectEntity);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventSuspectEntityList.Item(index: Integer): TFhirAdverseEventSuspectEntity;
begin
  result := TFhirAdverseEventSuspectEntity(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityList.Link: TFhirAdverseEventSuspectEntityList;
begin
  result := TFhirAdverseEventSuspectEntityList(inherited Link);
end;

procedure TFhirAdverseEventSuspectEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventSuspectEntityList.SetItemByIndex(index: Integer; value: TFhirAdverseEventSuspectEntity);
begin
  assert(value is TFhirAdverseEventSuspectEntity);
  FhirAdverseEventSuspectEntities[index] := value;
end;

procedure TFhirAdverseEventSuspectEntityList.SetItemN(index: Integer; value: TFhirAdverseEventSuspectEntity);
begin
  assert(value is TFhirAdverseEventSuspectEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEventSuspectEntityCausality }

constructor TFhirAdverseEventSuspectEntityCausality.Create;
begin
  inherited;
end;

destructor TFhirAdverseEventSuspectEntityCausality.Destroy;
begin
  FAssessment.free;
  FProductRelatedness.free;
  FAuthor.free;
  FMethod.free;
  inherited;
end;

procedure TFhirAdverseEventSuspectEntityCausality.Assign(oSource : TFslObject);
begin
  inherited;
  assessment := TFhirAdverseEventSuspectEntityCausality(oSource).assessment.Clone;
  productRelatednessElement := TFhirAdverseEventSuspectEntityCausality(oSource).productRelatednessElement.Clone;
  author := TFhirAdverseEventSuspectEntityCausality(oSource).author.Clone;
  method := TFhirAdverseEventSuspectEntityCausality(oSource).method.Clone;
end;

procedure TFhirAdverseEventSuspectEntityCausality.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'assessment') Then
     list.add(self.link, 'assessment', FAssessment.Link);
  if (child_name = 'productRelatedness') Then
     list.add(self.link, 'productRelatedness', FProductRelatedness.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
end;

procedure TFhirAdverseEventSuspectEntityCausality.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'assessment', 'CodeableConcept', false, TFhirCodeableConcept, FAssessment.Link));
  oList.add(TFHIRProperty.create(self, 'productRelatedness', 'string', false, TFhirString, FProductRelatedness.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
end;

function TFhirAdverseEventSuspectEntityCausality.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'assessment') then
  begin
    Assessment := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productRelatedness') then
  begin
    ProductRelatednessElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEventSuspectEntityCausality.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAdverseEventSuspectEntityCausality.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'assessment') then result := TFhirCodeableConcept.create()
  else if (propName = 'productRelatedness') then result := TFhirString.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'method') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEventSuspectEntityCausality.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'assessment') then result := 'CodeableConcept'
  else if (propName = 'productRelatedness') then result := 'string'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'method') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEventSuspectEntityCausality.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'assessment') then AssessmentElement := nil
  else if (propName = 'productRelatedness') then ProductRelatednessElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'method') then MethodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEventSuspectEntityCausality.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'assessment') then AssessmentElement := new as TFhirCodeableConcept
  else if (propName = 'productRelatedness') then ProductRelatednessElement := asString(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEventSuspectEntityCausality.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEventSuspectEntityCausality.fhirType : string;
begin
  result := 'AdverseEvent.suspectEntity.causality';
end;

function TFhirAdverseEventSuspectEntityCausality.Link : TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality(inherited Link);
end;

function TFhirAdverseEventSuspectEntityCausality.Clone : TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality(inherited Clone);
end;

function TFhirAdverseEventSuspectEntityCausality.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEventSuspectEntityCausality;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEventSuspectEntityCausality)) then
    result := false
  else
  begin
    o := TFhirAdverseEventSuspectEntityCausality(other);
    result := compareDeep(assessmentElement, o.assessmentElement, true) and compareDeep(productRelatednessElement, o.productRelatednessElement, true) and 
      compareDeep(authorElement, o.authorElement, true) and compareDeep(methodElement, o.methodElement, true);
  end;
end;

function TFhirAdverseEventSuspectEntityCausality.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAssessment) and isEmptyProp(FProductRelatedness) and isEmptyProp(FAuthor) and isEmptyProp(FMethod);
end;

procedure TFhirAdverseEventSuspectEntityCausality.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('assessment');
  fields.add('productRelatedness');
  fields.add('author');
  fields.add('method');
end;

function TFhirAdverseEventSuspectEntityCausality.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAdverseEventSuspectEntityCausality.SetAssessment(value : TFhirCodeableConcept);
begin
  FAssessment.free;
  FAssessment := value;
end;

procedure TFhirAdverseEventSuspectEntityCausality.SetProductRelatedness(value : TFhirString);
begin
  FProductRelatedness.free;
  FProductRelatedness := value;
end;

function TFhirAdverseEventSuspectEntityCausality.GetProductRelatednessST : String;
begin
  if FProductRelatedness = nil then
    result := ''
  else
    result := FProductRelatedness.value;
end;

procedure TFhirAdverseEventSuspectEntityCausality.SetProductRelatednessST(value : String);
begin
  if value <> '' then
  begin
    if FProductRelatedness = nil then
      FProductRelatedness := TFhirString.create;
    FProductRelatedness.value := value
  end
  else if FProductRelatedness <> nil then
    FProductRelatedness.value := '';
end;

procedure TFhirAdverseEventSuspectEntityCausality.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

procedure TFhirAdverseEventSuspectEntityCausality.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

{ TFhirAdverseEventSuspectEntityCausalityListEnumerator }

constructor TFhirAdverseEventSuspectEntityCausalityListEnumerator.Create(list : TFhirAdverseEventSuspectEntityCausalityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventSuspectEntityCausalityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventSuspectEntityCausalityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventSuspectEntityCausalityListEnumerator.GetCurrent : TFhirAdverseEventSuspectEntityCausality;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventSuspectEntityCausalityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdverseEventSuspectEntityCausalityList }

function TFhirAdverseEventSuspectEntityCausalityList.AddItem(value: TFhirAdverseEventSuspectEntityCausality): TFhirAdverseEventSuspectEntityCausality;
begin
  assert(value.ClassName = 'TFhirAdverseEventSuspectEntityCausality', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEventSuspectEntityCausality');
  add(value);
  result := value;
end;

function TFhirAdverseEventSuspectEntityCausalityList.Append: TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventSuspectEntityCausalityList.GetEnumerator : TFhirAdverseEventSuspectEntityCausalityListEnumerator;
begin
  result := TFhirAdverseEventSuspectEntityCausalityListEnumerator.Create(self.link);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Clone: TFhirAdverseEventSuspectEntityCausalityList;
begin
  result := TFhirAdverseEventSuspectEntityCausalityList(inherited Clone);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventSuspectEntityCausalityList.GetItemN(index: Integer): TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityCausalityList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEventSuspectEntityCausality;
end;
function TFhirAdverseEventSuspectEntityCausalityList.IndexOf(value: TFhirAdverseEventSuspectEntityCausality): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Insert(index: Integer): TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.InsertItem(index: Integer; value: TFhirAdverseEventSuspectEntityCausality);
begin
  assert(value is TFhirAdverseEventSuspectEntityCausality);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Item(index: Integer): TFhirAdverseEventSuspectEntityCausality;
begin
  result := TFhirAdverseEventSuspectEntityCausality(ObjectByIndex[index]);
end;

function TFhirAdverseEventSuspectEntityCausalityList.Link: TFhirAdverseEventSuspectEntityCausalityList;
begin
  result := TFhirAdverseEventSuspectEntityCausalityList(inherited Link);
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.SetItemByIndex(index: Integer; value: TFhirAdverseEventSuspectEntityCausality);
begin
  assert(value is TFhirAdverseEventSuspectEntityCausality);
  FhirAdverseEventSuspectEntityCausalities[index] := value;
end;

procedure TFhirAdverseEventSuspectEntityCausalityList.SetItemN(index: Integer; value: TFhirAdverseEventSuspectEntityCausality);
begin
  assert(value is TFhirAdverseEventSuspectEntityCausality);
  ObjectByIndex[index] := value;
end;

{ TFhirAdverseEvent }

constructor TFhirAdverseEvent.Create;
begin
  inherited;
end;

destructor TFhirAdverseEvent.Destroy;
begin
  FIdentifier.free;
  FActuality.free;
  FCategoryList.Free;
  FEvent.free;
  FSubject.free;
  FEncounter.free;
  FDate.free;
  FDetected.free;
  FRecordedDate.free;
  FResultingConditionList.Free;
  FLocation.free;
  FSeriousness.free;
  FSeverity.free;
  FOutcome.free;
  FRecorder.free;
  FContributorList.Free;
  FSuspectEntityList.Free;
  FSubjectMedicalHistoryList.Free;
  FReferenceDocumentList.Free;
  FStudyList.Free;
  inherited;
end;

procedure TFhirAdverseEvent.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirAdverseEvent(oSource).identifier.Clone;
  actualityElement := TFhirAdverseEvent(oSource).actualityElement.Clone;
  if (TFhirAdverseEvent(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirAdverseEvent(oSource).FCategoryList);
  end;
  event := TFhirAdverseEvent(oSource).event.Clone;
  subject := TFhirAdverseEvent(oSource).subject.Clone;
  encounter := TFhirAdverseEvent(oSource).encounter.Clone;
  dateElement := TFhirAdverseEvent(oSource).dateElement.Clone;
  detectedElement := TFhirAdverseEvent(oSource).detectedElement.Clone;
  recordedDateElement := TFhirAdverseEvent(oSource).recordedDateElement.Clone;
  if (TFhirAdverseEvent(oSource).FResultingConditionList = nil) then
  begin
    FResultingConditionList.free;
    FResultingConditionList := nil;
  end
  else
  begin
    if FResultingConditionList = nil then
      FResultingConditionList := TFhirReferenceList.Create;
    FResultingConditionList.Assign(TFhirAdverseEvent(oSource).FResultingConditionList);
  end;
  location := TFhirAdverseEvent(oSource).location.Clone;
  seriousness := TFhirAdverseEvent(oSource).seriousness.Clone;
  severity := TFhirAdverseEvent(oSource).severity.Clone;
  outcome := TFhirAdverseEvent(oSource).outcome.Clone;
  recorder := TFhirAdverseEvent(oSource).recorder.Clone;
  if (TFhirAdverseEvent(oSource).FContributorList = nil) then
  begin
    FContributorList.free;
    FContributorList := nil;
  end
  else
  begin
    if FContributorList = nil then
      FContributorList := TFhirReferenceList.Create;
    FContributorList.Assign(TFhirAdverseEvent(oSource).FContributorList);
  end;
  if (TFhirAdverseEvent(oSource).FSuspectEntityList = nil) then
  begin
    FSuspectEntityList.free;
    FSuspectEntityList := nil;
  end
  else
  begin
    if FSuspectEntityList = nil then
      FSuspectEntityList := TFhirAdverseEventSuspectEntityList.Create;
    FSuspectEntityList.Assign(TFhirAdverseEvent(oSource).FSuspectEntityList);
  end;
  if (TFhirAdverseEvent(oSource).FSubjectMedicalHistoryList = nil) then
  begin
    FSubjectMedicalHistoryList.free;
    FSubjectMedicalHistoryList := nil;
  end
  else
  begin
    if FSubjectMedicalHistoryList = nil then
      FSubjectMedicalHistoryList := TFhirReferenceList.Create;
    FSubjectMedicalHistoryList.Assign(TFhirAdverseEvent(oSource).FSubjectMedicalHistoryList);
  end;
  if (TFhirAdverseEvent(oSource).FReferenceDocumentList = nil) then
  begin
    FReferenceDocumentList.free;
    FReferenceDocumentList := nil;
  end
  else
  begin
    if FReferenceDocumentList = nil then
      FReferenceDocumentList := TFhirReferenceList.Create;
    FReferenceDocumentList.Assign(TFhirAdverseEvent(oSource).FReferenceDocumentList);
  end;
  if (TFhirAdverseEvent(oSource).FStudyList = nil) then
  begin
    FStudyList.free;
    FStudyList := nil;
  end
  else
  begin
    if FStudyList = nil then
      FStudyList := TFhirReferenceList.Create;
    FStudyList.Assign(TFhirAdverseEvent(oSource).FStudyList);
  end;
end;

function TFhirAdverseEvent.GetResourceType : TFhirResourceType;
begin
  result := frtAdverseEvent;
end;

procedure TFhirAdverseEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'actuality') Then
     list.add(self.link, 'actuality', FActuality.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'event') Then
     list.add(self.link, 'event', FEvent.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'detected') Then
     list.add(self.link, 'detected', FDetected.Link);
  if (child_name = 'recordedDate') Then
     list.add(self.link, 'recordedDate', FRecordedDate.Link);
  if (child_name = 'resultingCondition') Then
    list.addAll(self, 'resultingCondition', FResultingConditionList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'seriousness') Then
     list.add(self.link, 'seriousness', FSeriousness.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'contributor') Then
    list.addAll(self, 'contributor', FContributorList);
  if (child_name = 'suspectEntity') Then
    list.addAll(self, 'suspectEntity', FSuspectEntityList);
  if (child_name = 'subjectMedicalHistory') Then
    list.addAll(self, 'subjectMedicalHistory', FSubjectMedicalHistoryList);
  if (child_name = 'referenceDocument') Then
    list.addAll(self, 'referenceDocument', FReferenceDocumentList);
  if (child_name = 'study') Then
    list.addAll(self, 'study', FStudyList);
end;

procedure TFhirAdverseEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'actuality', 'code', false, TFhirEnum, FActuality.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'event', 'CodeableConcept', false, TFhirCodeableConcept, FEvent.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'detected', 'dateTime', false, TFhirDateTime, FDetected.Link));
  oList.add(TFHIRProperty.create(self, 'recordedDate', 'dateTime', false, TFhirDateTime, FRecordedDate.Link));
  oList.add(TFHIRProperty.create(self, 'resultingCondition', 'Reference', true, TFhirReference, FResultingConditionList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'seriousness', 'CodeableConcept', false, TFhirCodeableConcept, FSeriousness.Link));
  oList.add(TFHIRProperty.create(self, 'severity', 'CodeableConcept', false, TFhirCodeableConcept, FSeverity.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link));
  oList.add(TFHIRProperty.create(self, 'contributor', 'Reference', true, TFhirReference, FContributorList.Link));
  oList.add(TFHIRProperty.create(self, 'suspectEntity', 'BackboneElement', true, TFhirAdverseEventSuspectEntity, FSuspectEntityList.Link));
  oList.add(TFHIRProperty.create(self, 'subjectMedicalHistory', 'Reference', true, TFhirReference, FSubjectMedicalHistoryList.Link));
  oList.add(TFHIRProperty.create(self, 'referenceDocument', 'Reference', true, TFhirReference, FReferenceDocumentList.Link));
  oList.add(TFHIRProperty.create(self, 'study', 'Reference', true, TFhirReference, FStudyList.Link));
end;

function TFhirAdverseEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'actuality') then
  begin
    ActualityElement := asEnum(SYSTEMS_TFhirAdverseEventActualityEnum, CODES_TFhirAdverseEventActualityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    Event := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'detected') then
  begin
    DetectedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'recordedDate') then
  begin
    RecordedDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'resultingCondition') then
  begin
    ResultingConditionList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'seriousness') then
  begin
    Seriousness := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    Severity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contributor') then
  begin
    ContributorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'suspectEntity') then
  begin
    SuspectEntityList.add(propValue as TFhirAdverseEventSuspectEntity);
    result := propValue;
  end
  else if (propName = 'subjectMedicalHistory') then
  begin
    SubjectMedicalHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'referenceDocument') then
  begin
    ReferenceDocumentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'study') then
  begin
    StudyList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAdverseEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'resultingCondition') then ResultingConditionList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'contributor') then ContributorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'suspectEntity') then SuspectEntityList.insertItem(index, propValue as TFhirAdverseEventSuspectEntity)
  else if (propName = 'subjectMedicalHistory') then SubjectMedicalHistoryList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'referenceDocument') then ReferenceDocumentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'study') then StudyList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirAdverseEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'actuality') then result := TFhirEnum.create(SYSTEMS_TFhirAdverseEventActualityEnum[AdverseEventActualityNull], CODES_TFhirAdverseEventActualityEnum[AdverseEventActualityNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'event') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'detected') then result := TFhirDateTime.create()
  else if (propName = 'recordedDate') then result := TFhirDateTime.create()
  else if (propName = 'resultingCondition') then result := ResultingConditionList.new()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'seriousness') then result := TFhirCodeableConcept.create()
  else if (propName = 'severity') then result := TFhirCodeableConcept.create()
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create()
  else if (propName = 'recorder') then result := TFhirReference.create()
  else if (propName = 'contributor') then result := ContributorList.new()
  else if (propName = 'suspectEntity') then result := SuspectEntityList.new()
  else if (propName = 'subjectMedicalHistory') then result := SubjectMedicalHistoryList.new()
  else if (propName = 'referenceDocument') then result := ReferenceDocumentList.new()
  else if (propName = 'study') then result := StudyList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAdverseEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'actuality') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'event') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'detected') then result := 'dateTime'
  else if (propName = 'recordedDate') then result := 'dateTime'
  else if (propName = 'resultingCondition') then result := 'Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'seriousness') then result := 'CodeableConcept'
  else if (propName = 'severity') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'contributor') then result := 'Reference'
  else if (propName = 'suspectEntity') then result := 'BackboneElement'
  else if (propName = 'subjectMedicalHistory') then result := 'Reference'
  else if (propName = 'referenceDocument') then result := 'Reference'
  else if (propName = 'study') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAdverseEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'actuality') then ActualityElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'event') then EventElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'detected') then DetectedElement := nil
  else if (propName = 'recordedDate') then RecordedDateElement := nil
  else if (propName = 'resultingCondition') then deletePropertyValue('resultingCondition', ResultingConditionList, value)
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'seriousness') then SeriousnessElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'contributor') then deletePropertyValue('contributor', ContributorList, value)
  else if (propName = 'suspectEntity') then deletePropertyValue('suspectEntity', SuspectEntityList, value)
  else if (propName = 'subjectMedicalHistory') then deletePropertyValue('subjectMedicalHistory', SubjectMedicalHistoryList, value)
  else if (propName = 'referenceDocument') then deletePropertyValue('referenceDocument', ReferenceDocumentList, value)
  else if (propName = 'study') then deletePropertyValue('study', StudyList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAdverseEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'actuality') then ActualityElement := asEnum(SYSTEMS_TFhirAdverseEventActualityEnum, CODES_TFhirAdverseEventActualityEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'event') then EventElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'detected') then DetectedElement := asDateTime(new)
  else if (propName = 'recordedDate') then RecordedDateElement := asDateTime(new)
  else if (propName = 'resultingCondition') then replacePropertyValue('resultingCondition', ResultingConditionList, existing, new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'seriousness') then SeriousnessElement := new as TFhirCodeableConcept
  else if (propName = 'severity') then SeverityElement := new as TFhirCodeableConcept
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference
  else if (propName = 'contributor') then replacePropertyValue('contributor', ContributorList, existing, new)
  else if (propName = 'suspectEntity') then replacePropertyValue('suspectEntity', SuspectEntityList, existing, new)
  else if (propName = 'subjectMedicalHistory') then replacePropertyValue('subjectMedicalHistory', SubjectMedicalHistoryList, existing, new)
  else if (propName = 'referenceDocument') then replacePropertyValue('referenceDocument', ReferenceDocumentList, existing, new)
  else if (propName = 'study') then replacePropertyValue('study', StudyList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAdverseEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'resultingCondition') then ResultingConditionList.move(source, destination)
  else if (propName = 'contributor') then ContributorList.move(source, destination)
  else if (propName = 'suspectEntity') then SuspectEntityList.move(source, destination)
  else if (propName = 'subjectMedicalHistory') then SubjectMedicalHistoryList.move(source, destination)
  else if (propName = 'referenceDocument') then ReferenceDocumentList.move(source, destination)
  else if (propName = 'study') then StudyList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAdverseEvent.fhirType : string;
begin
  result := 'AdverseEvent';
end;

function TFhirAdverseEvent.Link : TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(inherited Link);
end;

function TFhirAdverseEvent.Clone : TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(inherited Clone);
end;

function TFhirAdverseEvent.equals(other : TObject) : boolean; 
var
  o : TFhirAdverseEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAdverseEvent)) then
    result := false
  else
  begin
    o := TFhirAdverseEvent(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(actualityElement, o.actualityElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(eventElement, o.eventElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(detectedElement, o.detectedElement, true) and 
      compareDeep(recordedDateElement, o.recordedDateElement, true) and compareDeep(resultingConditionList, o.resultingConditionList, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(seriousnessElement, o.seriousnessElement, true) and 
      compareDeep(severityElement, o.severityElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(recorderElement, o.recorderElement, true) and compareDeep(contributorList, o.contributorList, true) and 
      compareDeep(suspectEntityList, o.suspectEntityList, true) and compareDeep(subjectMedicalHistoryList, o.subjectMedicalHistoryList, true) and 
      compareDeep(referenceDocumentList, o.referenceDocumentList, true) and compareDeep(studyList, o.studyList, true);
  end;
end;

function TFhirAdverseEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FActuality) and isEmptyProp(FcategoryList) and isEmptyProp(FEvent) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FDate) and isEmptyProp(FDetected) and isEmptyProp(FRecordedDate) and isEmptyProp(FresultingConditionList) and isEmptyProp(FLocation) and isEmptyProp(FSeriousness) and isEmptyProp(FSeverity) and isEmptyProp(FOutcome) and isEmptyProp(FRecorder) and isEmptyProp(FcontributorList) and isEmptyProp(FsuspectEntityList) and isEmptyProp(FsubjectMedicalHistoryList) and isEmptyProp(FreferenceDocumentList) and isEmptyProp(FstudyList);
end;

procedure TFhirAdverseEvent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('actuality');
  fields.add('category');
  fields.add('event');
  fields.add('subject');
  fields.add('encounter');
  fields.add('date');
  fields.add('detected');
  fields.add('recordedDate');
  fields.add('resultingCondition');
  fields.add('location');
  fields.add('seriousness');
  fields.add('severity');
  fields.add('outcome');
  fields.add('recorder');
  fields.add('contributor');
  fields.add('suspectEntity');
  fields.add('subjectMedicalHistory');
  fields.add('referenceDocument');
  fields.add('study');
end;

function TFhirAdverseEvent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FResultingConditionList.sizeInBytes(magic));
  inc(result, FContributorList.sizeInBytes(magic));
  inc(result, FSuspectEntityList.sizeInBytes(magic));
  inc(result, FSubjectMedicalHistoryList.sizeInBytes(magic));
  inc(result, FReferenceDocumentList.sizeInBytes(magic));
  inc(result, FStudyList.sizeInBytes(magic));
end;

procedure TFhirAdverseEvent.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirAdverseEvent.SetActuality(value : TFhirEnum);
begin
  FActuality.free;
  FActuality := value;
end;

function TFhirAdverseEvent.GetActualityST : TFhirAdverseEventActualityEnum;
begin
  if FActuality = nil then
    result := TFhirAdverseEventActualityEnum(0)
  else
    result := TFhirAdverseEventActualityEnum(StringArrayIndexOfSensitive(CODES_TFhirAdverseEventActualityEnum, FActuality.value));
end;

procedure TFhirAdverseEvent.SetActualityST(value : TFhirAdverseEventActualityEnum);
begin
  if ord(value) = 0 then
    ActualityElement := nil
  else
    ActualityElement := TFhirEnum.create(SYSTEMS_TFhirAdverseEventActualityEnum[value], CODES_TFhirAdverseEventActualityEnum[value]);
end;

function TFhirAdverseEvent.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirAdverseEvent.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirAdverseEvent.SetEvent(value : TFhirCodeableConcept);
begin
  FEvent.free;
  FEvent := value;
end;

procedure TFhirAdverseEvent.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirAdverseEvent.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirAdverseEvent.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirAdverseEvent.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirAdverseEvent.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirAdverseEvent.SetDetected(value : TFhirDateTime);
begin
  FDetected.free;
  FDetected := value;
end;

function TFhirAdverseEvent.GetDetectedST : TFslDateTime;
begin
  if FDetected = nil then
    result := TFslDateTime.makeNull
  else
    result := FDetected.value;
end;

procedure TFhirAdverseEvent.SetDetectedST(value : TFslDateTime);
begin
  if FDetected = nil then
    FDetected := TFhirDateTime.create;
  FDetected.value := value
end;

procedure TFhirAdverseEvent.SetRecordedDate(value : TFhirDateTime);
begin
  FRecordedDate.free;
  FRecordedDate := value;
end;

function TFhirAdverseEvent.GetRecordedDateST : TFslDateTime;
begin
  if FRecordedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedDate.value;
end;

procedure TFhirAdverseEvent.SetRecordedDateST(value : TFslDateTime);
begin
  if FRecordedDate = nil then
    FRecordedDate := TFhirDateTime.create;
  FRecordedDate.value := value
end;

function TFhirAdverseEvent.GetResultingConditionList : TFhirReferenceList;
begin
  if FResultingConditionList = nil then
    FResultingConditionList := TFhirReferenceList.Create;
  result := FResultingConditionList;
end;

function TFhirAdverseEvent.GetHasResultingConditionList : boolean;
begin
  result := (FResultingConditionList <> nil) and (FResultingConditionList.count > 0);
end;

procedure TFhirAdverseEvent.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirAdverseEvent.SetSeriousness(value : TFhirCodeableConcept);
begin
  FSeriousness.free;
  FSeriousness := value;
end;

procedure TFhirAdverseEvent.SetSeverity(value : TFhirCodeableConcept);
begin
  FSeverity.free;
  FSeverity := value;
end;

procedure TFhirAdverseEvent.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

procedure TFhirAdverseEvent.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value;
end;

function TFhirAdverseEvent.GetContributorList : TFhirReferenceList;
begin
  if FContributorList = nil then
    FContributorList := TFhirReferenceList.Create;
  result := FContributorList;
end;

function TFhirAdverseEvent.GetHasContributorList : boolean;
begin
  result := (FContributorList <> nil) and (FContributorList.count > 0);
end;

function TFhirAdverseEvent.GetSuspectEntityList : TFhirAdverseEventSuspectEntityList;
begin
  if FSuspectEntityList = nil then
    FSuspectEntityList := TFhirAdverseEventSuspectEntityList.Create;
  result := FSuspectEntityList;
end;

function TFhirAdverseEvent.GetHasSuspectEntityList : boolean;
begin
  result := (FSuspectEntityList <> nil) and (FSuspectEntityList.count > 0);
end;

function TFhirAdverseEvent.GetSubjectMedicalHistoryList : TFhirReferenceList;
begin
  if FSubjectMedicalHistoryList = nil then
    FSubjectMedicalHistoryList := TFhirReferenceList.Create;
  result := FSubjectMedicalHistoryList;
end;

function TFhirAdverseEvent.GetHasSubjectMedicalHistoryList : boolean;
begin
  result := (FSubjectMedicalHistoryList <> nil) and (FSubjectMedicalHistoryList.count > 0);
end;

function TFhirAdverseEvent.GetReferenceDocumentList : TFhirReferenceList;
begin
  if FReferenceDocumentList = nil then
    FReferenceDocumentList := TFhirReferenceList.Create;
  result := FReferenceDocumentList;
end;

function TFhirAdverseEvent.GetHasReferenceDocumentList : boolean;
begin
  result := (FReferenceDocumentList <> nil) and (FReferenceDocumentList.count > 0);
end;

function TFhirAdverseEvent.GetStudyList : TFhirReferenceList;
begin
  if FStudyList = nil then
    FStudyList := TFhirReferenceList.Create;
  result := FStudyList;
end;

function TFhirAdverseEvent.GetHasStudyList : boolean;
begin
  result := (FStudyList <> nil) and (FStudyList.count > 0);
end;

{ TFhirAdverseEventListEnumerator }

constructor TFhirAdverseEventListEnumerator.Create(list : TFhirAdverseEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAdverseEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAdverseEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAdverseEventListEnumerator.GetCurrent : TFhirAdverseEvent;
begin
  Result := FList[FIndex];
end;

function TFhirAdverseEventListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAdverseEventList }

function TFhirAdverseEventList.AddItem(value: TFhirAdverseEvent): TFhirAdverseEvent;
begin
  assert(value.ClassName = 'TFhirAdverseEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAdverseEvent');
  add(value);
  result := value;
end;

function TFhirAdverseEventList.Append: TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventList.ClearItems;
begin
  Clear;
end;

function TFhirAdverseEventList.GetEnumerator : TFhirAdverseEventListEnumerator;
begin
  result := TFhirAdverseEventListEnumerator.Create(self.link);
end;

function TFhirAdverseEventList.Clone: TFhirAdverseEventList;
begin
  result := TFhirAdverseEventList(inherited Clone);
end;

function TFhirAdverseEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAdverseEventList.GetItemN(index: Integer): TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(ObjectByIndex[index]);
end;

function TFhirAdverseEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirAdverseEvent;
end;
function TFhirAdverseEventList.IndexOf(value: TFhirAdverseEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAdverseEventList.Insert(index: Integer): TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAdverseEventList.InsertItem(index: Integer; value: TFhirAdverseEvent);
begin
  assert(value is TFhirAdverseEvent);
  Inherited Insert(index, value);
end;

function TFhirAdverseEventList.Item(index: Integer): TFhirAdverseEvent;
begin
  result := TFhirAdverseEvent(ObjectByIndex[index]);
end;

function TFhirAdverseEventList.Link: TFhirAdverseEventList;
begin
  result := TFhirAdverseEventList(inherited Link);
end;

procedure TFhirAdverseEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAdverseEventList.SetItemByIndex(index: Integer; value: TFhirAdverseEvent);
begin
  assert(value is TFhirAdverseEvent);
  FhirAdverseEvents[index] := value;
end;

procedure TFhirAdverseEventList.SetItemN(index: Integer; value: TFhirAdverseEvent);
begin
  assert(value is TFhirAdverseEvent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ADVERSEEVENT}
{$IFDEF FHIR_ALLERGYINTOLERANCE}
{ TFhirAllergyIntoleranceReaction }

constructor TFhirAllergyIntoleranceReaction.Create;
begin
  inherited;
end;

destructor TFhirAllergyIntoleranceReaction.Destroy;
begin
  FSubstance.free;
  FManifestationList.Free;
  FDescription.free;
  FOnset.free;
  FSeverity.free;
  FExposureRoute.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirAllergyIntoleranceReaction.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirAllergyIntoleranceReaction(oSource).substance.Clone;
  if (TFhirAllergyIntoleranceReaction(oSource).FManifestationList = nil) then
  begin
    FManifestationList.free;
    FManifestationList := nil;
  end
  else
  begin
    if FManifestationList = nil then
      FManifestationList := TFhirCodeableConceptList.Create;
    FManifestationList.Assign(TFhirAllergyIntoleranceReaction(oSource).FManifestationList);
  end;
  descriptionElement := TFhirAllergyIntoleranceReaction(oSource).descriptionElement.Clone;
  onsetElement := TFhirAllergyIntoleranceReaction(oSource).onsetElement.Clone;
  severityElement := TFhirAllergyIntoleranceReaction(oSource).severityElement.Clone;
  exposureRoute := TFhirAllergyIntoleranceReaction(oSource).exposureRoute.Clone;
  if (TFhirAllergyIntoleranceReaction(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirAllergyIntoleranceReaction(oSource).FNoteList);
  end;
end;

procedure TFhirAllergyIntoleranceReaction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'manifestation') Then
    list.addAll(self, 'manifestation', FManifestationList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'onset') Then
     list.add(self.link, 'onset', FOnset.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'exposureRoute') Then
     list.add(self.link, 'exposureRoute', FExposureRoute.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirAllergyIntoleranceReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'substance', 'CodeableConcept', false, TFhirCodeableConcept, FSubstance.Link));
  oList.add(TFHIRProperty.create(self, 'manifestation', 'CodeableConcept', true, TFhirCodeableConcept, FManifestationList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'onset', 'dateTime', false, TFhirDateTime, FOnset.Link));
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFhirEnum, FSeverity.Link));
  oList.add(TFHIRProperty.create(self, 'exposureRoute', 'CodeableConcept', false, TFhirCodeableConcept, FExposureRoute.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirAllergyIntoleranceReaction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'manifestation') then
  begin
    ManifestationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'onset') then
  begin
    OnsetElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceSeverityEnum, CODES_TFhirAllergyIntoleranceSeverityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'exposureRoute') then
  begin
    ExposureRoute := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAllergyIntoleranceReaction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'manifestation') then ManifestationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirAllergyIntoleranceReaction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableConcept.create()
  else if (propName = 'manifestation') then result := ManifestationList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'onset') then result := TFhirDateTime.create()
  else if (propName = 'severity') then result := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceSeverityEnum[AllergyIntoleranceSeverityNull], CODES_TFhirAllergyIntoleranceSeverityEnum[AllergyIntoleranceSeverityNull]) 
  else if (propName = 'exposureRoute') then result := TFhirCodeableConcept.create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAllergyIntoleranceReaction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableConcept'
  else if (propName = 'manifestation') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'onset') then result := 'dateTime'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'exposureRoute') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAllergyIntoleranceReaction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'manifestation') then deletePropertyValue('manifestation', ManifestationList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'onset') then OnsetElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'exposureRoute') then ExposureRouteElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAllergyIntoleranceReaction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableConcept
  else if (propName = 'manifestation') then replacePropertyValue('manifestation', ManifestationList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'onset') then OnsetElement := asDateTime(new)
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceSeverityEnum, CODES_TFhirAllergyIntoleranceSeverityEnum, new)
  else if (propName = 'exposureRoute') then ExposureRouteElement := new as TFhirCodeableConcept
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAllergyIntoleranceReaction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'manifestation') then ManifestationList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAllergyIntoleranceReaction.fhirType : string;
begin
  result := 'AllergyIntolerance.reaction';
end;

function TFhirAllergyIntoleranceReaction.Link : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(inherited Link);
end;

function TFhirAllergyIntoleranceReaction.Clone : TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(inherited Clone);
end;

function TFhirAllergyIntoleranceReaction.equals(other : TObject) : boolean; 
var
  o : TFhirAllergyIntoleranceReaction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAllergyIntoleranceReaction)) then
    result := false
  else
  begin
    o := TFhirAllergyIntoleranceReaction(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(manifestationList, o.manifestationList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(onsetElement, o.onsetElement, true) and 
      compareDeep(severityElement, o.severityElement, true) and compareDeep(exposureRouteElement, o.exposureRouteElement, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirAllergyIntoleranceReaction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FmanifestationList) and isEmptyProp(FDescription) and isEmptyProp(FOnset) and isEmptyProp(FSeverity) and isEmptyProp(FExposureRoute) and isEmptyProp(FnoteList);
end;

procedure TFhirAllergyIntoleranceReaction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('substance');
  fields.add('manifestation');
  fields.add('description');
  fields.add('onset');
  fields.add('severity');
  fields.add('exposureRoute');
  fields.add('note');
end;

function TFhirAllergyIntoleranceReaction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FManifestationList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirAllergyIntoleranceReaction.SetSubstance(value : TFhirCodeableConcept);
begin
  FSubstance.free;
  FSubstance := value;
end;

function TFhirAllergyIntoleranceReaction.GetManifestationList : TFhirCodeableConceptList;
begin
  if FManifestationList = nil then
    FManifestationList := TFhirCodeableConceptList.Create;
  result := FManifestationList;
end;

function TFhirAllergyIntoleranceReaction.GetHasManifestationList : boolean;
begin
  result := (FManifestationList <> nil) and (FManifestationList.count > 0);
end;

procedure TFhirAllergyIntoleranceReaction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirAllergyIntoleranceReaction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirAllergyIntoleranceReaction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirAllergyIntoleranceReaction.SetOnset(value : TFhirDateTime);
begin
  FOnset.free;
  FOnset := value;
end;

function TFhirAllergyIntoleranceReaction.GetOnsetST : TFslDateTime;
begin
  if FOnset = nil then
    result := TFslDateTime.makeNull
  else
    result := FOnset.value;
end;

procedure TFhirAllergyIntoleranceReaction.SetOnsetST(value : TFslDateTime);
begin
  if FOnset = nil then
    FOnset := TFhirDateTime.create;
  FOnset.value := value
end;

procedure TFhirAllergyIntoleranceReaction.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

function TFhirAllergyIntoleranceReaction.GetSeverityST : TFhirAllergyIntoleranceSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirAllergyIntoleranceSeverityEnum(0)
  else
    result := TFhirAllergyIntoleranceSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceSeverityEnum, FSeverity.value));
end;

procedure TFhirAllergyIntoleranceReaction.SetSeverityST(value : TFhirAllergyIntoleranceSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceSeverityEnum[value], CODES_TFhirAllergyIntoleranceSeverityEnum[value]);
end;

procedure TFhirAllergyIntoleranceReaction.SetExposureRoute(value : TFhirCodeableConcept);
begin
  FExposureRoute.free;
  FExposureRoute := value;
end;

function TFhirAllergyIntoleranceReaction.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirAllergyIntoleranceReaction.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirAllergyIntoleranceReactionListEnumerator }

constructor TFhirAllergyIntoleranceReactionListEnumerator.Create(list : TFhirAllergyIntoleranceReactionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAllergyIntoleranceReactionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAllergyIntoleranceReactionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAllergyIntoleranceReactionListEnumerator.GetCurrent : TFhirAllergyIntoleranceReaction;
begin
  Result := FList[FIndex];
end;

function TFhirAllergyIntoleranceReactionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAllergyIntoleranceReactionList }

function TFhirAllergyIntoleranceReactionList.AddItem(value: TFhirAllergyIntoleranceReaction): TFhirAllergyIntoleranceReaction;
begin
  assert(value.ClassName = 'TFhirAllergyIntoleranceReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAllergyIntoleranceReaction');
  add(value);
  result := value;
end;

function TFhirAllergyIntoleranceReactionList.Append: TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceReactionList.ClearItems;
begin
  Clear;
end;

function TFhirAllergyIntoleranceReactionList.GetEnumerator : TFhirAllergyIntoleranceReactionListEnumerator;
begin
  result := TFhirAllergyIntoleranceReactionListEnumerator.Create(self.link);
end;

function TFhirAllergyIntoleranceReactionList.Clone: TFhirAllergyIntoleranceReactionList;
begin
  result := TFhirAllergyIntoleranceReactionList(inherited Clone);
end;

function TFhirAllergyIntoleranceReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAllergyIntoleranceReactionList.GetItemN(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceReactionList.ItemClass: TFslObjectClass;
begin
  result := TFhirAllergyIntoleranceReaction;
end;
function TFhirAllergyIntoleranceReactionList.IndexOf(value: TFhirAllergyIntoleranceReaction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAllergyIntoleranceReactionList.Insert(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceReactionList.InsertItem(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  Inherited Insert(index, value);
end;

function TFhirAllergyIntoleranceReactionList.Item(index: Integer): TFhirAllergyIntoleranceReaction;
begin
  result := TFhirAllergyIntoleranceReaction(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceReactionList.Link: TFhirAllergyIntoleranceReactionList;
begin
  result := TFhirAllergyIntoleranceReactionList(inherited Link);
end;

procedure TFhirAllergyIntoleranceReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAllergyIntoleranceReactionList.SetItemByIndex(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  FhirAllergyIntoleranceReactions[index] := value;
end;

procedure TFhirAllergyIntoleranceReactionList.SetItemN(index: Integer; value: TFhirAllergyIntoleranceReaction);
begin
  assert(value is TFhirAllergyIntoleranceReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirAllergyIntolerance }

constructor TFhirAllergyIntolerance.Create;
begin
  inherited;
end;

destructor TFhirAllergyIntolerance.Destroy;
begin
  FIdentifierList.Free;
  FClinicalStatus.free;
  FVerificationStatus.free;
  FType_.free;
  FCategory.Free;
  FCriticality.free;
  FCode.free;
  FPatient.free;
  FEncounter.free;
  FOnset.free;
  FRecordedDate.free;
  FRecorder.free;
  FAsserter.free;
  FLastOccurrence.free;
  FNoteList.Free;
  FReactionList.Free;
  inherited;
end;

procedure TFhirAllergyIntolerance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAllergyIntolerance(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAllergyIntolerance(oSource).FIdentifierList);
  end;
  clinicalStatus := TFhirAllergyIntolerance(oSource).clinicalStatus.Clone;
  verificationStatus := TFhirAllergyIntolerance(oSource).verificationStatus.Clone;
  type_Element := TFhirAllergyIntolerance(oSource).type_Element.Clone;
  if (TFhirAllergyIntolerance(oSource).FCategory = nil) then
  begin
    FCategory.free;
    FCategory := nil;
  end
  else
  begin
    FCategory := TFhirEnumList.Create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
    FCategory.Assign(TFhirAllergyIntolerance(oSource).FCategory);
  end;
  criticalityElement := TFhirAllergyIntolerance(oSource).criticalityElement.Clone;
  code := TFhirAllergyIntolerance(oSource).code.Clone;
  patient := TFhirAllergyIntolerance(oSource).patient.Clone;
  encounter := TFhirAllergyIntolerance(oSource).encounter.Clone;
  onset := TFhirAllergyIntolerance(oSource).onset.Clone;
  recordedDateElement := TFhirAllergyIntolerance(oSource).recordedDateElement.Clone;
  recorder := TFhirAllergyIntolerance(oSource).recorder.Clone;
  asserter := TFhirAllergyIntolerance(oSource).asserter.Clone;
  lastOccurrenceElement := TFhirAllergyIntolerance(oSource).lastOccurrenceElement.Clone;
  if (TFhirAllergyIntolerance(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirAllergyIntolerance(oSource).FNoteList);
  end;
  if (TFhirAllergyIntolerance(oSource).FReactionList = nil) then
  begin
    FReactionList.free;
    FReactionList := nil;
  end
  else
  begin
    if FReactionList = nil then
      FReactionList := TFhirAllergyIntoleranceReactionList.Create;
    FReactionList.Assign(TFhirAllergyIntolerance(oSource).FReactionList);
  end;
end;

function TFhirAllergyIntolerance.GetResourceType : TFhirResourceType;
begin
  result := frtAllergyIntolerance;
end;

procedure TFhirAllergyIntolerance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'clinicalStatus') Then
     list.add(self.link, 'clinicalStatus', FClinicalStatus.Link);
  if (child_name = 'verificationStatus') Then
     list.add(self.link, 'verificationStatus', FVerificationStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
     list.addAll(self, 'category', FCategory);
  if (child_name = 'criticality') Then
     list.add(self.link, 'criticality', FCriticality.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'recordedDate') Then
     list.add(self.link, 'recordedDate', FRecordedDate.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'asserter') Then
     list.add(self.link, 'asserter', FAsserter.Link);
  if (child_name = 'lastOccurrence') Then
     list.add(self.link, 'lastOccurrence', FLastOccurrence.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'reaction') Then
    list.addAll(self, 'reaction', FReactionList);
end;

procedure TFhirAllergyIntolerance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'clinicalStatus', 'CodeableConcept', false, TFhirCodeableConcept, FClinicalStatus.Link));
  oList.add(TFHIRProperty.create(self, 'verificationStatus', 'CodeableConcept', false, TFhirCodeableConcept, FVerificationStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'code', true, TFhirEnum, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'criticality', 'code', false, TFhirEnum, FCriticality.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'dateTime|Age|Period|Range|string', false, TFhirDataType, FOnset.Link));
  oList.add(TFHIRProperty.create(self, 'recordedDate', 'dateTime', false, TFhirDateTime, FRecordedDate.Link));
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link));
  oList.add(TFHIRProperty.create(self, 'asserter', 'Reference', false, TFhirReference, FAsserter.Link));
  oList.add(TFHIRProperty.create(self, 'lastOccurrence', 'dateTime', false, TFhirDateTime, FLastOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'reaction', 'BackboneElement', true, TFhirAllergyIntoleranceReaction, FReactionList.Link));
end;

function TFhirAllergyIntolerance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'clinicalStatus') then
  begin
    ClinicalStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'verificationStatus') then
  begin
    VerificationStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAllergyIntoleranceTypeEnum, CODES_TFhirAllergyIntoleranceTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(asEnum(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum, propValue));
    result := propValue;
  end
  else if (propName = 'criticality') then
  begin
    CriticalityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, CODES_TFhirAllergyIntoleranceCriticalityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then
  begin
    Onset := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'recordedDate') then
  begin
    RecordedDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'asserter') then
  begin
    Asserter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'lastOccurrence') then
  begin
    LastOccurrenceElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'reaction') then
  begin
    ReactionList.add(propValue as TFhirAllergyIntoleranceReaction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAllergyIntolerance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then FCategory.insertItem(index, asEnum(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum, propValue))
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'reaction') then ReactionList.insertItem(index, propValue as TFhirAllergyIntoleranceReaction)
  else inherited;
end;

function TFhirAllergyIntolerance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'clinicalStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'verificationStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceTypeEnum[AllergyIntoleranceTypeNull], CODES_TFhirAllergyIntoleranceTypeEnum[AllergyIntoleranceTypeNull]) 
  else if (propName = 'criticality') then result := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum[AllergyIntoleranceCriticalityNull], CODES_TFhirAllergyIntoleranceCriticalityEnum[AllergyIntoleranceCriticalityNull]) 
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Onset')
  else if (propName = 'recordedDate') then result := TFhirDateTime.create()
  else if (propName = 'recorder') then result := TFhirReference.create()
  else if (propName = 'asserter') then result := TFhirReference.create()
  else if (propName = 'lastOccurrence') then result := TFhirDateTime.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'reaction') then result := ReactionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAllergyIntolerance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'clinicalStatus') then result := 'CodeableConcept'
  else if (propName = 'verificationStatus') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'criticality') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'onset[x]') then result := 'dateTime|Age|Period|Range|string'
  else if (propName = 'recordedDate') then result := 'dateTime'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'asserter') then result := 'Reference'
  else if (propName = 'lastOccurrence') then result := 'dateTime'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'reaction') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAllergyIntolerance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := nil
  else if (propName = 'verificationStatus') then VerificationStatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'criticality') then CriticalityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := nil
  else if (propName = 'recordedDate') then RecordedDateElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'asserter') then AsserterElement := nil
  else if (propName = 'lastOccurrence') then LastOccurrenceElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'reaction') then deletePropertyValue('reaction', ReactionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAllergyIntolerance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := new as TFhirCodeableConcept
  else if (propName = 'verificationStatus') then VerificationStatusElement := new as TFhirCodeableConcept
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAllergyIntoleranceTypeEnum, CODES_TFhirAllergyIntoleranceTypeEnum, new)
  else if (propName = 'criticality') then CriticalityElement := asEnum(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum, CODES_TFhirAllergyIntoleranceCriticalityEnum, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := new as TFhirDataType
  else if (propName = 'recordedDate') then RecordedDateElement := asDateTime(new)
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference
  else if (propName = 'asserter') then AsserterElement := new as TFhirReference
  else if (propName = 'lastOccurrence') then LastOccurrenceElement := asDateTime(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'reaction') then replacePropertyValue('reaction', ReactionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAllergyIntolerance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then FCategory.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'reaction') then ReactionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAllergyIntolerance.fhirType : string;
begin
  result := 'AllergyIntolerance';
end;

function TFhirAllergyIntolerance.Link : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(inherited Link);
end;

function TFhirAllergyIntolerance.Clone : TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(inherited Clone);
end;

function TFhirAllergyIntolerance.equals(other : TObject) : boolean; 
var
  o : TFhirAllergyIntolerance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAllergyIntolerance)) then
    result := false
  else
  begin
    o := TFhirAllergyIntolerance(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(clinicalStatusElement, o.clinicalStatusElement, true) and 
      compareDeep(verificationStatusElement, o.verificationStatusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(criticalityElement, o.criticalityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(recordedDateElement, o.recordedDateElement, true) and 
      compareDeep(recorderElement, o.recorderElement, true) and compareDeep(asserterElement, o.asserterElement, true) and 
      compareDeep(lastOccurrenceElement, o.lastOccurrenceElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(reactionList, o.reactionList, true);
  end;
end;

function TFhirAllergyIntolerance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FClinicalStatus) and isEmptyProp(FVerificationStatus) and isEmptyProp(FType_) and isEmptyProp(FCategory) and isEmptyProp(FCriticality) and isEmptyProp(FCode) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FOnset) and isEmptyProp(FRecordedDate) and isEmptyProp(FRecorder) and isEmptyProp(FAsserter) and isEmptyProp(FLastOccurrence) and isEmptyProp(FnoteList) and isEmptyProp(FreactionList);
end;

procedure TFhirAllergyIntolerance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('clinicalStatus');
  fields.add('verificationStatus');
  fields.add('type');
  fields.add('category');
  fields.add('criticality');
  fields.add('code');
  fields.add('patient');
  fields.add('encounter');
  fields.add('onset[x]');
  fields.add('recordedDate');
  fields.add('recorder');
  fields.add('asserter');
  fields.add('lastOccurrence');
  fields.add('note');
  fields.add('reaction');
end;

function TFhirAllergyIntolerance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategory.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FReactionList.sizeInBytes(magic));
end;

function TFhirAllergyIntolerance.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAllergyIntolerance.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAllergyIntolerance.SetClinicalStatus(value : TFhirCodeableConcept);
begin
  FClinicalStatus.free;
  FClinicalStatus := value;
end;

procedure TFhirAllergyIntolerance.SetVerificationStatus(value : TFhirCodeableConcept);
begin
  FVerificationStatus.free;
  FVerificationStatus := value;
end;

procedure TFhirAllergyIntolerance.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirAllergyIntolerance.GetType_ST : TFhirAllergyIntoleranceTypeEnum;
begin
  if FType_ = nil then
    result := TFhirAllergyIntoleranceTypeEnum(0)
  else
    result := TFhirAllergyIntoleranceTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceTypeEnum, FType_.value));
end;

procedure TFhirAllergyIntolerance.SetType_ST(value : TFhirAllergyIntoleranceTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceTypeEnum[value], CODES_TFhirAllergyIntoleranceTypeEnum[value]);
end;

function TFhirAllergyIntolerance.GetCategory : TFhirEnumList;
begin
  if FCategory = nil then
    FCategory := TFhirEnumList.Create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
  result := FCategory;
end;

function TFhirAllergyIntolerance.GetHasCategory : boolean;
begin
  result := (FCategory <> nil) and (FCategory.count > 0);
end;

function TFhirAllergyIntolerance.GetCategoryST : TFhirAllergyIntoleranceCategoryEnumList;
  var i : integer;
begin
  result := [];
  if Fcategory <> nil then
    for i := 0 to Fcategory.count - 1 do
      result := result + [TFhirAllergyIntoleranceCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceCategoryEnum, Fcategory[i].value))];
end;

procedure TFhirAllergyIntolerance.SetCategoryST(value : TFhirAllergyIntoleranceCategoryEnumList);
var a : TFhirAllergyIntoleranceCategoryEnum;
begin
  if Fcategory = nil then
    Fcategory := TFhirEnumList.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
  Fcategory.clear;
  for a := low(TFhirAllergyIntoleranceCategoryEnum) to high(TFhirAllergyIntoleranceCategoryEnum) do
    if a in value then
      begin
         if Fcategory = nil then
           Fcategory := TFhirEnumList.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum, CODES_TFhirAllergyIntoleranceCategoryEnum);
         Fcategory.add(TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCategoryEnum[a], CODES_TFhirAllergyIntoleranceCategoryEnum[a]));
      end;
end;

procedure TFhirAllergyIntolerance.SetCriticality(value : TFhirEnum);
begin
  FCriticality.free;
  FCriticality := value;
end;

function TFhirAllergyIntolerance.GetCriticalityST : TFhirAllergyIntoleranceCriticalityEnum;
begin
  if FCriticality = nil then
    result := TFhirAllergyIntoleranceCriticalityEnum(0)
  else
    result := TFhirAllergyIntoleranceCriticalityEnum(StringArrayIndexOfSensitive(CODES_TFhirAllergyIntoleranceCriticalityEnum, FCriticality.value));
end;

procedure TFhirAllergyIntolerance.SetCriticalityST(value : TFhirAllergyIntoleranceCriticalityEnum);
begin
  if ord(value) = 0 then
    CriticalityElement := nil
  else
    CriticalityElement := TFhirEnum.create(SYSTEMS_TFhirAllergyIntoleranceCriticalityEnum[value], CODES_TFhirAllergyIntoleranceCriticalityEnum[value]);
end;

procedure TFhirAllergyIntolerance.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirAllergyIntolerance.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirAllergyIntolerance.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirAllergyIntolerance.SetOnset(value : TFhirDataType);
begin
  FOnset.free;
  FOnset := value;
end;

procedure TFhirAllergyIntolerance.SetRecordedDate(value : TFhirDateTime);
begin
  FRecordedDate.free;
  FRecordedDate := value;
end;

function TFhirAllergyIntolerance.GetRecordedDateST : TFslDateTime;
begin
  if FRecordedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedDate.value;
end;

procedure TFhirAllergyIntolerance.SetRecordedDateST(value : TFslDateTime);
begin
  if FRecordedDate = nil then
    FRecordedDate := TFhirDateTime.create;
  FRecordedDate.value := value
end;

procedure TFhirAllergyIntolerance.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value;
end;

procedure TFhirAllergyIntolerance.SetAsserter(value : TFhirReference);
begin
  FAsserter.free;
  FAsserter := value;
end;

procedure TFhirAllergyIntolerance.SetLastOccurrence(value : TFhirDateTime);
begin
  FLastOccurrence.free;
  FLastOccurrence := value;
end;

function TFhirAllergyIntolerance.GetLastOccurrenceST : TFslDateTime;
begin
  if FLastOccurrence = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastOccurrence.value;
end;

procedure TFhirAllergyIntolerance.SetLastOccurrenceST(value : TFslDateTime);
begin
  if FLastOccurrence = nil then
    FLastOccurrence := TFhirDateTime.create;
  FLastOccurrence.value := value
end;

function TFhirAllergyIntolerance.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirAllergyIntolerance.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirAllergyIntolerance.GetReactionList : TFhirAllergyIntoleranceReactionList;
begin
  if FReactionList = nil then
    FReactionList := TFhirAllergyIntoleranceReactionList.Create;
  result := FReactionList;
end;

function TFhirAllergyIntolerance.GetHasReactionList : boolean;
begin
  result := (FReactionList <> nil) and (FReactionList.count > 0);
end;

{ TFhirAllergyIntoleranceListEnumerator }

constructor TFhirAllergyIntoleranceListEnumerator.Create(list : TFhirAllergyIntoleranceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAllergyIntoleranceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAllergyIntoleranceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAllergyIntoleranceListEnumerator.GetCurrent : TFhirAllergyIntolerance;
begin
  Result := FList[FIndex];
end;

function TFhirAllergyIntoleranceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAllergyIntoleranceList }

function TFhirAllergyIntoleranceList.AddItem(value: TFhirAllergyIntolerance): TFhirAllergyIntolerance;
begin
  assert(value.ClassName = 'TFhirAllergyIntolerance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAllergyIntolerance');
  add(value);
  result := value;
end;

function TFhirAllergyIntoleranceList.Append: TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceList.ClearItems;
begin
  Clear;
end;

function TFhirAllergyIntoleranceList.GetEnumerator : TFhirAllergyIntoleranceListEnumerator;
begin
  result := TFhirAllergyIntoleranceListEnumerator.Create(self.link);
end;

function TFhirAllergyIntoleranceList.Clone: TFhirAllergyIntoleranceList;
begin
  result := TFhirAllergyIntoleranceList(inherited Clone);
end;

function TFhirAllergyIntoleranceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAllergyIntoleranceList.GetItemN(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceList.ItemClass: TFslObjectClass;
begin
  result := TFhirAllergyIntolerance;
end;
function TFhirAllergyIntoleranceList.IndexOf(value: TFhirAllergyIntolerance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAllergyIntoleranceList.Insert(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAllergyIntoleranceList.InsertItem(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  Inherited Insert(index, value);
end;

function TFhirAllergyIntoleranceList.Item(index: Integer): TFhirAllergyIntolerance;
begin
  result := TFhirAllergyIntolerance(ObjectByIndex[index]);
end;

function TFhirAllergyIntoleranceList.Link: TFhirAllergyIntoleranceList;
begin
  result := TFhirAllergyIntoleranceList(inherited Link);
end;

procedure TFhirAllergyIntoleranceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAllergyIntoleranceList.SetItemByIndex(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  FhirAllergyIntolerances[index] := value;
end;

procedure TFhirAllergyIntoleranceList.SetItemN(index: Integer; value: TFhirAllergyIntolerance);
begin
  assert(value is TFhirAllergyIntolerance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ALLERGYINTOLERANCE}
{$IFDEF FHIR_APPOINTMENT}
{ TFhirAppointmentParticipant }

constructor TFhirAppointmentParticipant.Create;
begin
  inherited;
end;

destructor TFhirAppointmentParticipant.Destroy;
begin
  FType_List.Free;
  FActor.free;
  FRequired.free;
  FStatus.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirAppointmentParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointmentParticipant(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirAppointmentParticipant(oSource).FType_List);
  end;
  actor := TFhirAppointmentParticipant(oSource).actor.Clone;
  requiredElement := TFhirAppointmentParticipant(oSource).requiredElement.Clone;
  statusElement := TFhirAppointmentParticipant(oSource).statusElement.Clone;
  period := TFhirAppointmentParticipant(oSource).period.Clone;
end;

procedure TFhirAppointmentParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'required') Then
     list.add(self.link, 'required', FRequired.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirAppointmentParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
  oList.add(TFHIRProperty.create(self, 'required', 'code', false, TFhirEnum, FRequired.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirAppointmentParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'required') then
  begin
    RequiredElement := asEnum(SYSTEMS_TFhirParticipantRequiredEnum, CODES_TFhirParticipantRequiredEnum, propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirParticipationStatusEnum, CODES_TFhirParticipationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAppointmentParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirAppointmentParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new()
  else if (propName = 'actor') then result := TFhirReference.create()
  else if (propName = 'required') then result := TFhirEnum.create(SYSTEMS_TFhirParticipantRequiredEnum[ParticipantRequiredNull], CODES_TFhirParticipantRequiredEnum[ParticipantRequiredNull]) 
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirParticipationStatusEnum[ParticipationStatusNull], CODES_TFhirParticipationStatusEnum[ParticipationStatusNull]) 
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointmentParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'required') then result := 'code'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointmentParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'required') then RequiredElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointmentParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else if (propName = 'required') then RequiredElement := asEnum(SYSTEMS_TFhirParticipantRequiredEnum, CODES_TFhirParticipantRequiredEnum, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirParticipationStatusEnum, CODES_TFhirParticipationStatusEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointmentParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointmentParticipant.fhirType : string;
begin
  result := 'Appointment.participant';
end;

function TFhirAppointmentParticipant.Link : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(inherited Link);
end;

function TFhirAppointmentParticipant.Clone : TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(inherited Clone);
end;

function TFhirAppointmentParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirAppointmentParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointmentParticipant)) then
    result := false
  else
  begin
    o := TFhirAppointmentParticipant(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(actorElement, o.actorElement, true) and 
      compareDeep(requiredElement, o.requiredElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirAppointmentParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FActor) and isEmptyProp(FRequired) and isEmptyProp(FStatus) and isEmptyProp(FPeriod);
end;

procedure TFhirAppointmentParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('actor');
  fields.add('required');
  fields.add('status');
  fields.add('period');
end;

function TFhirAppointmentParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
end;

function TFhirAppointmentParticipant.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirAppointmentParticipant.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirAppointmentParticipant.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

procedure TFhirAppointmentParticipant.SetRequired(value : TFhirEnum);
begin
  FRequired.free;
  FRequired := value;
end;

function TFhirAppointmentParticipant.GetRequiredST : TFhirParticipantRequiredEnum;
begin
  if FRequired = nil then
    result := TFhirParticipantRequiredEnum(0)
  else
    result := TFhirParticipantRequiredEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipantRequiredEnum, FRequired.value));
end;

procedure TFhirAppointmentParticipant.SetRequiredST(value : TFhirParticipantRequiredEnum);
begin
  if ord(value) = 0 then
    RequiredElement := nil
  else
    RequiredElement := TFhirEnum.create(SYSTEMS_TFhirParticipantRequiredEnum[value], CODES_TFhirParticipantRequiredEnum[value]);
end;

procedure TFhirAppointmentParticipant.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirAppointmentParticipant.GetStatusST : TFhirParticipationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirParticipationStatusEnum(0)
  else
    result := TFhirParticipationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipationStatusEnum, FStatus.value));
end;

procedure TFhirAppointmentParticipant.SetStatusST(value : TFhirParticipationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirParticipationStatusEnum[value], CODES_TFhirParticipationStatusEnum[value]);
end;

procedure TFhirAppointmentParticipant.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirAppointmentParticipantListEnumerator }

constructor TFhirAppointmentParticipantListEnumerator.Create(list : TFhirAppointmentParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentParticipantListEnumerator.GetCurrent : TFhirAppointmentParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAppointmentParticipantList }

function TFhirAppointmentParticipantList.AddItem(value: TFhirAppointmentParticipant): TFhirAppointmentParticipant;
begin
  assert(value.ClassName = 'TFhirAppointmentParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointmentParticipant');
  add(value);
  result := value;
end;

function TFhirAppointmentParticipantList.Append: TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentParticipantList.GetEnumerator : TFhirAppointmentParticipantListEnumerator;
begin
  result := TFhirAppointmentParticipantListEnumerator.Create(self.link);
end;

function TFhirAppointmentParticipantList.Clone: TFhirAppointmentParticipantList;
begin
  result := TFhirAppointmentParticipantList(inherited Clone);
end;

function TFhirAppointmentParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentParticipantList.GetItemN(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(ObjectByIndex[index]);
end;

function TFhirAppointmentParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointmentParticipant;
end;
function TFhirAppointmentParticipantList.IndexOf(value: TFhirAppointmentParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentParticipantList.Insert(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentParticipantList.InsertItem(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  Inherited Insert(index, value);
end;

function TFhirAppointmentParticipantList.Item(index: Integer): TFhirAppointmentParticipant;
begin
  result := TFhirAppointmentParticipant(ObjectByIndex[index]);
end;

function TFhirAppointmentParticipantList.Link: TFhirAppointmentParticipantList;
begin
  result := TFhirAppointmentParticipantList(inherited Link);
end;

procedure TFhirAppointmentParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentParticipantList.SetItemByIndex(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  FhirAppointmentParticipants[index] := value;
end;

procedure TFhirAppointmentParticipantList.SetItemN(index: Integer; value: TFhirAppointmentParticipant);
begin
  assert(value is TFhirAppointmentParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirAppointment }

constructor TFhirAppointment.Create;
begin
  inherited;
end;

destructor TFhirAppointment.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCancelationReason.free;
  FServiceCategoryList.Free;
  FServiceTypeList.Free;
  FSpecialtyList.Free;
  FAppointmentType.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FPriority.free;
  FDescription.free;
  FSupportingInformationList.Free;
  FStart.free;
  FEnd_.free;
  FMinutesDuration.free;
  FSlotList.Free;
  FCreated.free;
  FComment.free;
  FPatientInstruction.free;
  FBasedOnList.Free;
  FParticipantList.Free;
  FRequestedPeriodList.Free;
  inherited;
end;

procedure TFhirAppointment.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointment(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAppointment(oSource).FIdentifierList);
  end;
  statusElement := TFhirAppointment(oSource).statusElement.Clone;
  cancelationReason := TFhirAppointment(oSource).cancelationReason.Clone;
  if (TFhirAppointment(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirAppointment(oSource).FServiceCategoryList);
  end;
  if (TFhirAppointment(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableConceptList.Create;
    FServiceTypeList.Assign(TFhirAppointment(oSource).FServiceTypeList);
  end;
  if (TFhirAppointment(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirAppointment(oSource).FSpecialtyList);
  end;
  appointmentType := TFhirAppointment(oSource).appointmentType.Clone;
  if (TFhirAppointment(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirAppointment(oSource).FReasonCodeList);
  end;
  if (TFhirAppointment(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirAppointment(oSource).FReasonReferenceList);
  end;
  priorityElement := TFhirAppointment(oSource).priorityElement.Clone;
  descriptionElement := TFhirAppointment(oSource).descriptionElement.Clone;
  if (TFhirAppointment(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirAppointment(oSource).FSupportingInformationList);
  end;
  startElement := TFhirAppointment(oSource).startElement.Clone;
  end_Element := TFhirAppointment(oSource).end_Element.Clone;
  minutesDurationElement := TFhirAppointment(oSource).minutesDurationElement.Clone;
  if (TFhirAppointment(oSource).FSlotList = nil) then
  begin
    FSlotList.free;
    FSlotList := nil;
  end
  else
  begin
    if FSlotList = nil then
      FSlotList := TFhirReferenceList.Create;
    FSlotList.Assign(TFhirAppointment(oSource).FSlotList);
  end;
  createdElement := TFhirAppointment(oSource).createdElement.Clone;
  commentElement := TFhirAppointment(oSource).commentElement.Clone;
  patientInstructionElement := TFhirAppointment(oSource).patientInstructionElement.Clone;
  if (TFhirAppointment(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirAppointment(oSource).FBasedOnList);
  end;
  if (TFhirAppointment(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirAppointmentParticipantList.Create;
    FParticipantList.Assign(TFhirAppointment(oSource).FParticipantList);
  end;
  if (TFhirAppointment(oSource).FRequestedPeriodList = nil) then
  begin
    FRequestedPeriodList.free;
    FRequestedPeriodList := nil;
  end
  else
  begin
    if FRequestedPeriodList = nil then
      FRequestedPeriodList := TFhirPeriodList.Create;
    FRequestedPeriodList.Assign(TFhirAppointment(oSource).FRequestedPeriodList);
  end;
end;

function TFhirAppointment.GetResourceType : TFhirResourceType;
begin
  result := frtAppointment;
end;

procedure TFhirAppointment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'cancelationReason') Then
     list.add(self.link, 'cancelationReason', FCancelationReason.Link);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'appointmentType') Then
     list.add(self.link, 'appointmentType', FAppointmentType.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'minutesDuration') Then
     list.add(self.link, 'minutesDuration', FMinutesDuration.Link);
  if (child_name = 'slot') Then
    list.addAll(self, 'slot', FSlotList);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'patientInstruction') Then
     list.add(self.link, 'patientInstruction', FPatientInstruction.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'requestedPeriod') Then
    list.addAll(self, 'requestedPeriod', FRequestedPeriodList);
end;

procedure TFhirAppointment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'cancelationReason', 'CodeableConcept', false, TFhirCodeableConcept, FCancelationReason.Link));
  oList.add(TFHIRProperty.create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'serviceType', 'CodeableConcept', true, TFhirCodeableConcept, FServiceTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.create(self, 'appointmentType', 'CodeableConcept', false, TFhirCodeableConcept, FAppointmentType.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'unsignedInt', false, TFhirUnsignedInt, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link));
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));
  oList.add(TFHIRProperty.create(self, 'minutesDuration', 'positiveInt', false, TFhirPositiveInt, FMinutesDuration.Link));
  oList.add(TFHIRProperty.create(self, 'slot', 'Reference', true, TFhirReference, FSlotList.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
  oList.add(TFHIRProperty.create(self, 'patientInstruction', 'string', false, TFhirString, FPatientInstruction.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirAppointmentParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'requestedPeriod', 'Period', true, TFhirPeriod, FRequestedPeriodList.Link));
end;

function TFhirAppointment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirAppointmentStatusEnum, CODES_TFhirAppointmentStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'cancelationReason') then
  begin
    CancelationReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'appointmentType') then
  begin
    AppointmentType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'minutesDuration') then
  begin
    MinutesDurationElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'slot') then
  begin
    SlotList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'patientInstruction') then
  begin
    PatientInstructionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirAppointmentParticipant);
    result := propValue;
  end
  else if (propName = 'requestedPeriod') then
  begin
    RequestedPeriodList.add(propValue as TFhirPeriod);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAppointment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'slot') then SlotList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirAppointmentParticipant)
  else if (propName = 'requestedPeriod') then RequestedPeriodList.insertItem(index, propValue as TFhirPeriod)
  else inherited;
end;

function TFhirAppointment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirAppointmentStatusEnum[AppointmentStatusNull], CODES_TFhirAppointmentStatusEnum[AppointmentStatusNull]) 
  else if (propName = 'cancelationReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new()
  else if (propName = 'serviceType') then result := ServiceTypeList.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'appointmentType') then result := TFhirCodeableConcept.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'priority') then result := TFhirUnsignedInt.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new()
  else if (propName = 'start') then result := TFhirInstant.create()
  else if (propName = 'end') then result := TFhirInstant.create()
  else if (propName = 'minutesDuration') then result := TFhirPositiveInt.create()
  else if (propName = 'slot') then result := SlotList.new()
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'comment') then result := TFhirString.create()
  else if (propName = 'patientInstruction') then result := TFhirString.create()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'requestedPeriod') then result := RequestedPeriodList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'cancelationReason') then result := 'CodeableConcept'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'appointmentType') then result := 'CodeableConcept'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'priority') then result := 'unsignedInt'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'minutesDuration') then result := 'positiveInt'
  else if (propName = 'slot') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'patientInstruction') then result := 'string'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'requestedPeriod') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'cancelationReason') then CancelationReasonElement := nil
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value)
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'appointmentType') then AppointmentTypeElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value)
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'minutesDuration') then MinutesDurationElement := nil
  else if (propName = 'slot') then deletePropertyValue('slot', SlotList, value)
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'patientInstruction') then PatientInstructionElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'requestedPeriod') then deletePropertyValue('requestedPeriod', RequestedPeriodList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirAppointmentStatusEnum, CODES_TFhirAppointmentStatusEnum, new)
  else if (propName = 'cancelationReason') then CancelationReasonElement := new as TFhirCodeableConcept
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new)
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'appointmentType') then AppointmentTypeElement := new as TFhirCodeableConcept
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'priority') then PriorityElement := asUnsignedInt(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new)
  else if (propName = 'start') then StartElement := asInstant(new)
  else if (propName = 'end') then End_Element := asInstant(new)
  else if (propName = 'minutesDuration') then MinutesDurationElement := asPositiveInt(new)
  else if (propName = 'slot') then replacePropertyValue('slot', SlotList, existing, new)
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else if (propName = 'patientInstruction') then PatientInstructionElement := asString(new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'requestedPeriod') then replacePropertyValue('requestedPeriod', RequestedPeriodList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination)
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination)
  else if (propName = 'slot') then SlotList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'requestedPeriod') then RequestedPeriodList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointment.fhirType : string;
begin
  result := 'Appointment';
end;

function TFhirAppointment.Link : TFhirAppointment;
begin
  result := TFhirAppointment(inherited Link);
end;

function TFhirAppointment.Clone : TFhirAppointment;
begin
  result := TFhirAppointment(inherited Clone);
end;

function TFhirAppointment.equals(other : TObject) : boolean; 
var
  o : TFhirAppointment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointment)) then
    result := false
  else
  begin
    o := TFhirAppointment(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(cancelationReasonElement, o.cancelationReasonElement, true) and compareDeep(serviceCategoryList, o.serviceCategoryList, true) and 
      compareDeep(serviceTypeList, o.serviceTypeList, true) and compareDeep(specialtyList, o.specialtyList, true) and 
      compareDeep(appointmentTypeElement, o.appointmentTypeElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(supportingInformationList, o.supportingInformationList, true) and 
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and 
      compareDeep(minutesDurationElement, o.minutesDurationElement, true) and compareDeep(slotList, o.slotList, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(commentElement, o.commentElement, true) and 
      compareDeep(patientInstructionElement, o.patientInstructionElement, true) and 
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(requestedPeriodList, o.requestedPeriodList, true);
  end;
end;

function TFhirAppointment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCancelationReason) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FAppointmentType) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FPriority) and isEmptyProp(FDescription) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FMinutesDuration) and isEmptyProp(FslotList) and isEmptyProp(FCreated) and isEmptyProp(FComment) and isEmptyProp(FPatientInstruction) and isEmptyProp(FbasedOnList) and isEmptyProp(FparticipantList) and isEmptyProp(FrequestedPeriodList);
end;

procedure TFhirAppointment.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('cancelationReason');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('appointmentType');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('priority');
  fields.add('description');
  fields.add('supportingInformation');
  fields.add('start');
  fields.add('end');
  fields.add('minutesDuration');
  fields.add('slot');
  fields.add('created');
  fields.add('comment');
  fields.add('patientInstruction');
  fields.add('basedOn');
  fields.add('participant');
  fields.add('requestedPeriod');
end;

function TFhirAppointment.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FServiceCategoryList.sizeInBytes(magic));
  inc(result, FServiceTypeList.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FSupportingInformationList.sizeInBytes(magic));
  inc(result, FSlotList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FRequestedPeriodList.sizeInBytes(magic));
end;

function TFhirAppointment.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAppointment.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAppointment.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirAppointment.GetStatusST : TFhirAppointmentStatusEnum;
begin
  if FStatus = nil then
    result := TFhirAppointmentStatusEnum(0)
  else
    result := TFhirAppointmentStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirAppointmentStatusEnum, FStatus.value));
end;

procedure TFhirAppointment.SetStatusST(value : TFhirAppointmentStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirAppointmentStatusEnum[value], CODES_TFhirAppointmentStatusEnum[value]);
end;

procedure TFhirAppointment.SetCancelationReason(value : TFhirCodeableConcept);
begin
  FCancelationReason.free;
  FCancelationReason := value;
end;

function TFhirAppointment.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

function TFhirAppointment.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

function TFhirAppointment.GetServiceTypeList : TFhirCodeableConceptList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableConceptList.Create;
  result := FServiceTypeList;
end;

function TFhirAppointment.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

function TFhirAppointment.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirAppointment.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

procedure TFhirAppointment.SetAppointmentType(value : TFhirCodeableConcept);
begin
  FAppointmentType.free;
  FAppointmentType := value;
end;

function TFhirAppointment.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirAppointment.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirAppointment.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirAppointment.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

procedure TFhirAppointment.SetPriority(value : TFhirUnsignedInt);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirAppointment.GetPriorityST : String;
begin
  if FPriority = nil then
    result := ''
  else
    result := FPriority.value;
end;

procedure TFhirAppointment.SetPriorityST(value : String);
begin
  if value <> '' then
  begin
    if FPriority = nil then
      FPriority := TFhirUnsignedInt.create;
    FPriority.value := value
  end
  else if FPriority <> nil then
    FPriority.value := '';
end;

procedure TFhirAppointment.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirAppointment.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirAppointment.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirAppointment.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirAppointment.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

procedure TFhirAppointment.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value;
end;

function TFhirAppointment.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

procedure TFhirAppointment.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

procedure TFhirAppointment.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirAppointment.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

procedure TFhirAppointment.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

procedure TFhirAppointment.SetMinutesDuration(value : TFhirPositiveInt);
begin
  FMinutesDuration.free;
  FMinutesDuration := value;
end;

function TFhirAppointment.GetMinutesDurationST : String;
begin
  if FMinutesDuration = nil then
    result := ''
  else
    result := FMinutesDuration.value;
end;

procedure TFhirAppointment.SetMinutesDurationST(value : String);
begin
  if value <> '' then
  begin
    if FMinutesDuration = nil then
      FMinutesDuration := TFhirPositiveInt.create;
    FMinutesDuration.value := value
  end
  else if FMinutesDuration <> nil then
    FMinutesDuration.value := '';
end;

function TFhirAppointment.GetSlotList : TFhirReferenceList;
begin
  if FSlotList = nil then
    FSlotList := TFhirReferenceList.Create;
  result := FSlotList;
end;

function TFhirAppointment.GetHasSlotList : boolean;
begin
  result := (FSlotList <> nil) and (FSlotList.count > 0);
end;

procedure TFhirAppointment.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirAppointment.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirAppointment.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirAppointment.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirAppointment.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirAppointment.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirAppointment.SetPatientInstruction(value : TFhirString);
begin
  FPatientInstruction.free;
  FPatientInstruction := value;
end;

function TFhirAppointment.GetPatientInstructionST : String;
begin
  if FPatientInstruction = nil then
    result := ''
  else
    result := FPatientInstruction.value;
end;

procedure TFhirAppointment.SetPatientInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FPatientInstruction = nil then
      FPatientInstruction := TFhirString.create;
    FPatientInstruction.value := value
  end
  else if FPatientInstruction <> nil then
    FPatientInstruction.value := '';
end;

function TFhirAppointment.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirAppointment.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirAppointment.GetParticipantList : TFhirAppointmentParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirAppointmentParticipantList.Create;
  result := FParticipantList;
end;

function TFhirAppointment.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

function TFhirAppointment.GetRequestedPeriodList : TFhirPeriodList;
begin
  if FRequestedPeriodList = nil then
    FRequestedPeriodList := TFhirPeriodList.Create;
  result := FRequestedPeriodList;
end;

function TFhirAppointment.GetHasRequestedPeriodList : boolean;
begin
  result := (FRequestedPeriodList <> nil) and (FRequestedPeriodList.count > 0);
end;

{ TFhirAppointmentListEnumerator }

constructor TFhirAppointmentListEnumerator.Create(list : TFhirAppointmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentListEnumerator.GetCurrent : TFhirAppointment;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAppointmentList }

function TFhirAppointmentList.AddItem(value: TFhirAppointment): TFhirAppointment;
begin
  assert(value.ClassName = 'TFhirAppointment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointment');
  add(value);
  result := value;
end;

function TFhirAppointmentList.Append: TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentList.GetEnumerator : TFhirAppointmentListEnumerator;
begin
  result := TFhirAppointmentListEnumerator.Create(self.link);
end;

function TFhirAppointmentList.Clone: TFhirAppointmentList;
begin
  result := TFhirAppointmentList(inherited Clone);
end;

function TFhirAppointmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentList.GetItemN(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment(ObjectByIndex[index]);
end;

function TFhirAppointmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointment;
end;
function TFhirAppointmentList.IndexOf(value: TFhirAppointment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentList.Insert(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentList.InsertItem(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  Inherited Insert(index, value);
end;

function TFhirAppointmentList.Item(index: Integer): TFhirAppointment;
begin
  result := TFhirAppointment(ObjectByIndex[index]);
end;

function TFhirAppointmentList.Link: TFhirAppointmentList;
begin
  result := TFhirAppointmentList(inherited Link);
end;

procedure TFhirAppointmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentList.SetItemByIndex(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  FhirAppointments[index] := value;
end;

procedure TFhirAppointmentList.SetItemN(index: Integer; value: TFhirAppointment);
begin
  assert(value is TFhirAppointment);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_APPOINTMENT}
{$IFDEF FHIR_APPOINTMENTRESPONSE}
{ TFhirAppointmentResponse }

constructor TFhirAppointmentResponse.Create;
begin
  inherited;
end;

destructor TFhirAppointmentResponse.Destroy;
begin
  FIdentifierList.Free;
  FAppointment.free;
  FStart.free;
  FEnd_.free;
  FParticipantTypeList.Free;
  FActor.free;
  FParticipantStatus.free;
  FComment.free;
  inherited;
end;

procedure TFhirAppointmentResponse.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirAppointmentResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirAppointmentResponse(oSource).FIdentifierList);
  end;
  appointment := TFhirAppointmentResponse(oSource).appointment.Clone;
  startElement := TFhirAppointmentResponse(oSource).startElement.Clone;
  end_Element := TFhirAppointmentResponse(oSource).end_Element.Clone;
  if (TFhirAppointmentResponse(oSource).FParticipantTypeList = nil) then
  begin
    FParticipantTypeList.free;
    FParticipantTypeList := nil;
  end
  else
  begin
    if FParticipantTypeList = nil then
      FParticipantTypeList := TFhirCodeableConceptList.Create;
    FParticipantTypeList.Assign(TFhirAppointmentResponse(oSource).FParticipantTypeList);
  end;
  actor := TFhirAppointmentResponse(oSource).actor.Clone;
  participantStatusElement := TFhirAppointmentResponse(oSource).participantStatusElement.Clone;
  commentElement := TFhirAppointmentResponse(oSource).commentElement.Clone;
end;

function TFhirAppointmentResponse.GetResourceType : TFhirResourceType;
begin
  result := frtAppointmentResponse;
end;

procedure TFhirAppointmentResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'appointment') Then
     list.add(self.link, 'appointment', FAppointment.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'participantType') Then
    list.addAll(self, 'participantType', FParticipantTypeList);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'participantStatus') Then
     list.add(self.link, 'participantStatus', FParticipantStatus.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirAppointmentResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'appointment', 'Reference', false, TFhirReference, FAppointment.Link));
  oList.add(TFHIRProperty.create(self, 'start', 'instant', false, TFhirInstant, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));
  oList.add(TFHIRProperty.create(self, 'participantType', 'CodeableConcept', true, TFhirCodeableConcept, FParticipantTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
  oList.add(TFHIRProperty.create(self, 'participantStatus', 'code', false, TFhirEnum, FParticipantStatus.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
end;

function TFhirAppointmentResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'appointment') then
  begin
    Appointment := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'participantType') then
  begin
    ParticipantTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'participantStatus') then
  begin
    ParticipantStatusElement := asEnum(SYSTEMS_TFhirParticipationStatusEnum, CODES_TFhirParticipationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAppointmentResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'participantType') then ParticipantTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirAppointmentResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'appointment') then result := TFhirReference.create()
  else if (propName = 'start') then result := TFhirInstant.create()
  else if (propName = 'end') then result := TFhirInstant.create()
  else if (propName = 'participantType') then result := ParticipantTypeList.new()
  else if (propName = 'actor') then result := TFhirReference.create()
  else if (propName = 'participantStatus') then result := TFhirEnum.create(SYSTEMS_TFhirParticipationStatusEnum[ParticipationStatusNull], CODES_TFhirParticipationStatusEnum[ParticipationStatusNull]) 
  else if (propName = 'comment') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAppointmentResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'appointment') then result := 'Reference'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'participantType') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'participantStatus') then result := 'code'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAppointmentResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'appointment') then AppointmentElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'participantType') then deletePropertyValue('participantType', ParticipantTypeList, value)
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'participantStatus') then ParticipantStatusElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAppointmentResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'appointment') then AppointmentElement := new as TFhirReference
  else if (propName = 'start') then StartElement := asInstant(new)
  else if (propName = 'end') then End_Element := asInstant(new)
  else if (propName = 'participantType') then replacePropertyValue('participantType', ParticipantTypeList, existing, new)
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else if (propName = 'participantStatus') then ParticipantStatusElement := asEnum(SYSTEMS_TFhirParticipationStatusEnum, CODES_TFhirParticipationStatusEnum, new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAppointmentResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'participantType') then ParticipantTypeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAppointmentResponse.fhirType : string;
begin
  result := 'AppointmentResponse';
end;

function TFhirAppointmentResponse.Link : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(inherited Link);
end;

function TFhirAppointmentResponse.Clone : TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(inherited Clone);
end;

function TFhirAppointmentResponse.equals(other : TObject) : boolean; 
var
  o : TFhirAppointmentResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAppointmentResponse)) then
    result := false
  else
  begin
    o := TFhirAppointmentResponse(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(appointmentElement, o.appointmentElement, true) and 
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and 
      compareDeep(participantTypeList, o.participantTypeList, true) and compareDeep(actorElement, o.actorElement, true) and 
      compareDeep(participantStatusElement, o.participantStatusElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirAppointmentResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FAppointment) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FparticipantTypeList) and isEmptyProp(FActor) and isEmptyProp(FParticipantStatus) and isEmptyProp(FComment);
end;

procedure TFhirAppointmentResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('appointment');
  fields.add('start');
  fields.add('end');
  fields.add('participantType');
  fields.add('actor');
  fields.add('participantStatus');
  fields.add('comment');
end;

function TFhirAppointmentResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FParticipantTypeList.sizeInBytes(magic));
end;

function TFhirAppointmentResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirAppointmentResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirAppointmentResponse.SetAppointment(value : TFhirReference);
begin
  FAppointment.free;
  FAppointment := value;
end;

procedure TFhirAppointmentResponse.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value;
end;

function TFhirAppointmentResponse.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

procedure TFhirAppointmentResponse.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.create;
  FStart.value := value
end;

procedure TFhirAppointmentResponse.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirAppointmentResponse.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

procedure TFhirAppointmentResponse.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

function TFhirAppointmentResponse.GetParticipantTypeList : TFhirCodeableConceptList;
begin
  if FParticipantTypeList = nil then
    FParticipantTypeList := TFhirCodeableConceptList.Create;
  result := FParticipantTypeList;
end;

function TFhirAppointmentResponse.GetHasParticipantTypeList : boolean;
begin
  result := (FParticipantTypeList <> nil) and (FParticipantTypeList.count > 0);
end;

procedure TFhirAppointmentResponse.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

procedure TFhirAppointmentResponse.SetParticipantStatus(value : TFhirEnum);
begin
  FParticipantStatus.free;
  FParticipantStatus := value;
end;

function TFhirAppointmentResponse.GetParticipantStatusST : TFhirParticipationStatusEnum;
begin
  if FParticipantStatus = nil then
    result := TFhirParticipationStatusEnum(0)
  else
    result := TFhirParticipationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirParticipationStatusEnum, FParticipantStatus.value));
end;

procedure TFhirAppointmentResponse.SetParticipantStatusST(value : TFhirParticipationStatusEnum);
begin
  if ord(value) = 0 then
    ParticipantStatusElement := nil
  else
    ParticipantStatusElement := TFhirEnum.create(SYSTEMS_TFhirParticipationStatusEnum[value], CODES_TFhirParticipationStatusEnum[value]);
end;

procedure TFhirAppointmentResponse.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirAppointmentResponse.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirAppointmentResponse.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirAppointmentResponseListEnumerator }

constructor TFhirAppointmentResponseListEnumerator.Create(list : TFhirAppointmentResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAppointmentResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAppointmentResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAppointmentResponseListEnumerator.GetCurrent : TFhirAppointmentResponse;
begin
  Result := FList[FIndex];
end;

function TFhirAppointmentResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAppointmentResponseList }

function TFhirAppointmentResponseList.AddItem(value: TFhirAppointmentResponse): TFhirAppointmentResponse;
begin
  assert(value.ClassName = 'TFhirAppointmentResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAppointmentResponse');
  add(value);
  result := value;
end;

function TFhirAppointmentResponseList.Append: TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentResponseList.ClearItems;
begin
  Clear;
end;

function TFhirAppointmentResponseList.GetEnumerator : TFhirAppointmentResponseListEnumerator;
begin
  result := TFhirAppointmentResponseListEnumerator.Create(self.link);
end;

function TFhirAppointmentResponseList.Clone: TFhirAppointmentResponseList;
begin
  result := TFhirAppointmentResponseList(inherited Clone);
end;

function TFhirAppointmentResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAppointmentResponseList.GetItemN(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(ObjectByIndex[index]);
end;

function TFhirAppointmentResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirAppointmentResponse;
end;
function TFhirAppointmentResponseList.IndexOf(value: TFhirAppointmentResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAppointmentResponseList.Insert(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAppointmentResponseList.InsertItem(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  Inherited Insert(index, value);
end;

function TFhirAppointmentResponseList.Item(index: Integer): TFhirAppointmentResponse;
begin
  result := TFhirAppointmentResponse(ObjectByIndex[index]);
end;

function TFhirAppointmentResponseList.Link: TFhirAppointmentResponseList;
begin
  result := TFhirAppointmentResponseList(inherited Link);
end;

procedure TFhirAppointmentResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAppointmentResponseList.SetItemByIndex(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  FhirAppointmentResponses[index] := value;
end;

procedure TFhirAppointmentResponseList.SetItemN(index: Integer; value: TFhirAppointmentResponse);
begin
  assert(value is TFhirAppointmentResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_APPOINTMENTRESPONSE}
{$IFDEF FHIR_BASIC}
{ TFhirBasic }

constructor TFhirBasic.Create;
begin
  inherited;
end;

destructor TFhirBasic.Destroy;
begin
  FIdentifierList.Free;
  FCode.free;
  FSubject.free;
  FCreated.free;
  FAuthor.free;
  inherited;
end;

procedure TFhirBasic.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBasic(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBasic(oSource).FIdentifierList);
  end;
  code := TFhirBasic(oSource).code.Clone;
  subject := TFhirBasic(oSource).subject.Clone;
  createdElement := TFhirBasic(oSource).createdElement.Clone;
  author := TFhirBasic(oSource).author.Clone;
end;

function TFhirBasic.GetResourceType : TFhirResourceType;
begin
  result := frtBasic;
end;

procedure TFhirBasic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirBasic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'date', false, TFhirDate, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
end;

function TFhirBasic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBasic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirBasic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'created') then result := TFhirDate.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBasic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'created') then result := 'date'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBasic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBasic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'created') then CreatedElement := asDate(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBasic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBasic.fhirType : string;
begin
  result := 'Basic';
end;

function TFhirBasic.Link : TFhirBasic;
begin
  result := TFhirBasic(inherited Link);
end;

function TFhirBasic.Clone : TFhirBasic;
begin
  result := TFhirBasic(inherited Clone);
end;

function TFhirBasic.equals(other : TObject) : boolean; 
var
  o : TFhirBasic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBasic)) then
    result := false
  else
  begin
    o := TFhirBasic(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirBasic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FCreated) and isEmptyProp(FAuthor);
end;

procedure TFhirBasic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('subject');
  fields.add('created');
  fields.add('author');
end;

function TFhirBasic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirBasic.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirBasic.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirBasic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirBasic.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirBasic.SetCreated(value : TFhirDate);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirBasic.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirBasic.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDate.create;
  FCreated.value := value
end;

procedure TFhirBasic.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

{ TFhirBasicListEnumerator }

constructor TFhirBasicListEnumerator.Create(list : TFhirBasicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBasicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBasicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBasicListEnumerator.GetCurrent : TFhirBasic;
begin
  Result := FList[FIndex];
end;

function TFhirBasicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBasicList }

function TFhirBasicList.AddItem(value: TFhirBasic): TFhirBasic;
begin
  assert(value.ClassName = 'TFhirBasic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBasic');
  add(value);
  result := value;
end;

function TFhirBasicList.Append: TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBasicList.ClearItems;
begin
  Clear;
end;

function TFhirBasicList.GetEnumerator : TFhirBasicListEnumerator;
begin
  result := TFhirBasicListEnumerator.Create(self.link);
end;

function TFhirBasicList.Clone: TFhirBasicList;
begin
  result := TFhirBasicList(inherited Clone);
end;

function TFhirBasicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBasicList.GetItemN(index: Integer): TFhirBasic;
begin
  result := TFhirBasic(ObjectByIndex[index]);
end;

function TFhirBasicList.ItemClass: TFslObjectClass;
begin
  result := TFhirBasic;
end;
function TFhirBasicList.IndexOf(value: TFhirBasic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBasicList.Insert(index: Integer): TFhirBasic;
begin
  result := TFhirBasic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBasicList.InsertItem(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  Inherited Insert(index, value);
end;

function TFhirBasicList.Item(index: Integer): TFhirBasic;
begin
  result := TFhirBasic(ObjectByIndex[index]);
end;

function TFhirBasicList.Link: TFhirBasicList;
begin
  result := TFhirBasicList(inherited Link);
end;

procedure TFhirBasicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBasicList.SetItemByIndex(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  FhirBasics[index] := value;
end;

procedure TFhirBasicList.SetItemN(index: Integer; value: TFhirBasic);
begin
  assert(value is TFhirBasic);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BASIC}
{$IFDEF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{ TFhirBiologicallyDerivedProductCollection }

constructor TFhirBiologicallyDerivedProductCollection.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductCollection.Destroy;
begin
  FCollector.free;
  FSource.free;
  FCollected.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductCollection.Assign(oSource : TFslObject);
begin
  inherited;
  collector := TFhirBiologicallyDerivedProductCollection(oSource).collector.Clone;
  source := TFhirBiologicallyDerivedProductCollection(oSource).source.Clone;
  collected := TFhirBiologicallyDerivedProductCollection(oSource).collected.Clone;
end;

procedure TFhirBiologicallyDerivedProductCollection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(self.link, 'collector', FCollector.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'collected[x]') or (child_name = 'collected') Then
     list.add(self.link, 'collected[x]', FCollected.Link);
end;

procedure TFhirBiologicallyDerivedProductCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'collector', 'Reference', false, TFhirReference, FCollector.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'collected[x]', 'dateTime|Period', false, TFhirDataType, FCollected.Link));
end;

function TFhirBiologicallyDerivedProductCollection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'collector') then
  begin
    Collector := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then
  begin
    Collected := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductCollection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductCollection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'collector') then result := TFhirReference.create()
  else if (propName = 'source') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Collected')
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductCollection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'collector') then result := 'Reference'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'collected[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductCollection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductCollection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := new as TFhirReference
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductCollection.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductCollection.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct.collection';
end;

function TFhirBiologicallyDerivedProductCollection.Link : TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(inherited Link);
end;

function TFhirBiologicallyDerivedProductCollection.Clone : TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(inherited Clone);
end;

function TFhirBiologicallyDerivedProductCollection.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductCollection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductCollection)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductCollection(other);
    result := compareDeep(collectorElement, o.collectorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(collectedElement, o.collectedElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductCollection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCollector) and isEmptyProp(FSource) and isEmptyProp(FCollected);
end;

procedure TFhirBiologicallyDerivedProductCollection.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('collector');
  fields.add('source');
  fields.add('collected[x]');
end;

function TFhirBiologicallyDerivedProductCollection.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBiologicallyDerivedProductCollection.SetCollector(value : TFhirReference);
begin
  FCollector.free;
  FCollector := value;
end;

procedure TFhirBiologicallyDerivedProductCollection.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirBiologicallyDerivedProductCollection.SetCollected(value : TFhirDataType);
begin
  FCollected.free;
  FCollected := value;
end;

{ TFhirBiologicallyDerivedProductCollectionListEnumerator }

constructor TFhirBiologicallyDerivedProductCollectionListEnumerator.Create(list : TFhirBiologicallyDerivedProductCollectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductCollectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductCollectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductCollectionListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductCollection;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductCollectionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductCollectionList }

function TFhirBiologicallyDerivedProductCollectionList.AddItem(value: TFhirBiologicallyDerivedProductCollection): TFhirBiologicallyDerivedProductCollection;
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProductCollection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProductCollection');
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductCollectionList.Append: TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductCollectionList.GetEnumerator : TFhirBiologicallyDerivedProductCollectionListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductCollectionListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductCollectionList.Clone: TFhirBiologicallyDerivedProductCollectionList;
begin
  result := TFhirBiologicallyDerivedProductCollectionList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductCollectionList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductCollectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductCollection;
end;
function TFhirBiologicallyDerivedProductCollectionList.IndexOf(value: TFhirBiologicallyDerivedProductCollection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductCollectionList.Insert(index: Integer): TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductCollectionList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value is TFhirBiologicallyDerivedProductCollection);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductCollectionList.Item(index: Integer): TFhirBiologicallyDerivedProductCollection;
begin
  result := TFhirBiologicallyDerivedProductCollection(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductCollectionList.Link: TFhirBiologicallyDerivedProductCollectionList;
begin
  result := TFhirBiologicallyDerivedProductCollectionList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductCollectionList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value is TFhirBiologicallyDerivedProductCollection);
  FhirBiologicallyDerivedProductCollections[index] := value;
end;

procedure TFhirBiologicallyDerivedProductCollectionList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductCollection);
begin
  assert(value is TFhirBiologicallyDerivedProductCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProductProcessing }

constructor TFhirBiologicallyDerivedProductProcessing.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductProcessing.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditive.free;
  FTime.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductProcessing.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirBiologicallyDerivedProductProcessing(oSource).descriptionElement.Clone;
  procedure_ := TFhirBiologicallyDerivedProductProcessing(oSource).procedure_.Clone;
  additive := TFhirBiologicallyDerivedProductProcessing(oSource).additive.Clone;
  time := TFhirBiologicallyDerivedProductProcessing(oSource).time.Clone;
end;

procedure TFhirBiologicallyDerivedProductProcessing.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'procedure') Then
     list.add(self.link, 'procedure', FProcedure_.Link);
  if (child_name = 'additive') Then
     list.add(self.link, 'additive', FAdditive.Link);
  if (child_name = 'time[x]') or (child_name = 'time') Then
     list.add(self.link, 'time[x]', FTime.Link);
end;

procedure TFhirBiologicallyDerivedProductProcessing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'procedure', 'CodeableConcept', false, TFhirCodeableConcept, FProcedure_.Link));
  oList.add(TFHIRProperty.create(self, 'additive', 'Reference', false, TFhirReference, FAdditive.Link));
  oList.add(TFHIRProperty.create(self, 'time[x]', 'dateTime|Period', false, TFhirDataType, FTime.Link));
end;

function TFhirBiologicallyDerivedProductProcessing.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'additive') then
  begin
    Additive := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then
  begin
    Time := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductProcessing.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductProcessing.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'procedure') then result := TFhirCodeableConcept.create()
  else if (propName = 'additive') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Time')
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductProcessing.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'procedure') then result := 'CodeableConcept'
  else if (propName = 'additive') then result := 'Reference'
  else if (propName = 'time[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductProcessing.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'procedure') then Procedure_Element := nil
  else if (propName = 'additive') then AdditiveElement := nil
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductProcessing.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'procedure') then Procedure_Element := new as TFhirCodeableConcept
  else if (propName = 'additive') then AdditiveElement := new as TFhirReference
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductProcessing.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductProcessing.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct.processing';
end;

function TFhirBiologicallyDerivedProductProcessing.Link : TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(inherited Link);
end;

function TFhirBiologicallyDerivedProductProcessing.Clone : TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(inherited Clone);
end;

function TFhirBiologicallyDerivedProductProcessing.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductProcessing;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductProcessing)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductProcessing(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(additiveElement, o.additiveElement, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductProcessing.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FProcedure_) and isEmptyProp(FAdditive) and isEmptyProp(FTime);
end;

procedure TFhirBiologicallyDerivedProductProcessing.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('procedure');
  fields.add('additive');
  fields.add('time[x]');
end;

function TFhirBiologicallyDerivedProductProcessing.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirBiologicallyDerivedProductProcessing.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetAdditive(value : TFhirReference);
begin
  FAdditive.free;
  FAdditive := value;
end;

procedure TFhirBiologicallyDerivedProductProcessing.SetTime(value : TFhirDataType);
begin
  FTime.free;
  FTime := value;
end;

{ TFhirBiologicallyDerivedProductProcessingListEnumerator }

constructor TFhirBiologicallyDerivedProductProcessingListEnumerator.Create(list : TFhirBiologicallyDerivedProductProcessingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductProcessingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductProcessingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductProcessingListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductProcessing;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductProcessingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductProcessingList }

function TFhirBiologicallyDerivedProductProcessingList.AddItem(value: TFhirBiologicallyDerivedProductProcessing): TFhirBiologicallyDerivedProductProcessing;
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProductProcessing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProductProcessing');
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductProcessingList.Append: TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductProcessingList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductProcessingList.GetEnumerator : TFhirBiologicallyDerivedProductProcessingListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductProcessingListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductProcessingList.Clone: TFhirBiologicallyDerivedProductProcessingList;
begin
  result := TFhirBiologicallyDerivedProductProcessingList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductProcessingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductProcessingList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductProcessingList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductProcessing;
end;
function TFhirBiologicallyDerivedProductProcessingList.IndexOf(value: TFhirBiologicallyDerivedProductProcessing): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductProcessingList.Insert(index: Integer): TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductProcessingList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value is TFhirBiologicallyDerivedProductProcessing);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductProcessingList.Item(index: Integer): TFhirBiologicallyDerivedProductProcessing;
begin
  result := TFhirBiologicallyDerivedProductProcessing(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductProcessingList.Link: TFhirBiologicallyDerivedProductProcessingList;
begin
  result := TFhirBiologicallyDerivedProductProcessingList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductProcessingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductProcessingList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value is TFhirBiologicallyDerivedProductProcessing);
  FhirBiologicallyDerivedProductProcessings[index] := value;
end;

procedure TFhirBiologicallyDerivedProductProcessingList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductProcessing);
begin
  assert(value is TFhirBiologicallyDerivedProductProcessing);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProductManipulation }

constructor TFhirBiologicallyDerivedProductManipulation.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductManipulation.Destroy;
begin
  FDescription.free;
  FTime.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductManipulation.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirBiologicallyDerivedProductManipulation(oSource).descriptionElement.Clone;
  time := TFhirBiologicallyDerivedProductManipulation(oSource).time.Clone;
end;

procedure TFhirBiologicallyDerivedProductManipulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'time[x]') or (child_name = 'time') Then
     list.add(self.link, 'time[x]', FTime.Link);
end;

procedure TFhirBiologicallyDerivedProductManipulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'time[x]', 'dateTime|Period', false, TFhirDataType, FTime.Link));
end;

function TFhirBiologicallyDerivedProductManipulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then
  begin
    Time := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductManipulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductManipulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Time')
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductManipulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'time[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductManipulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductManipulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductManipulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductManipulation.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct.manipulation';
end;

function TFhirBiologicallyDerivedProductManipulation.Link : TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(inherited Link);
end;

function TFhirBiologicallyDerivedProductManipulation.Clone : TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(inherited Clone);
end;

function TFhirBiologicallyDerivedProductManipulation.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductManipulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductManipulation)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductManipulation(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductManipulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FTime);
end;

procedure TFhirBiologicallyDerivedProductManipulation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('time[x]');
end;

function TFhirBiologicallyDerivedProductManipulation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBiologicallyDerivedProductManipulation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirBiologicallyDerivedProductManipulation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirBiologicallyDerivedProductManipulation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirBiologicallyDerivedProductManipulation.SetTime(value : TFhirDataType);
begin
  FTime.free;
  FTime := value;
end;

{ TFhirBiologicallyDerivedProductManipulationListEnumerator }

constructor TFhirBiologicallyDerivedProductManipulationListEnumerator.Create(list : TFhirBiologicallyDerivedProductManipulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductManipulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductManipulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductManipulationListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductManipulation;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductManipulationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductManipulationList }

function TFhirBiologicallyDerivedProductManipulationList.AddItem(value: TFhirBiologicallyDerivedProductManipulation): TFhirBiologicallyDerivedProductManipulation;
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProductManipulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProductManipulation');
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductManipulationList.Append: TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductManipulationList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductManipulationList.GetEnumerator : TFhirBiologicallyDerivedProductManipulationListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductManipulationListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductManipulationList.Clone: TFhirBiologicallyDerivedProductManipulationList;
begin
  result := TFhirBiologicallyDerivedProductManipulationList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductManipulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductManipulationList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductManipulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductManipulation;
end;
function TFhirBiologicallyDerivedProductManipulationList.IndexOf(value: TFhirBiologicallyDerivedProductManipulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductManipulationList.Insert(index: Integer): TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductManipulationList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value is TFhirBiologicallyDerivedProductManipulation);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductManipulationList.Item(index: Integer): TFhirBiologicallyDerivedProductManipulation;
begin
  result := TFhirBiologicallyDerivedProductManipulation(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductManipulationList.Link: TFhirBiologicallyDerivedProductManipulationList;
begin
  result := TFhirBiologicallyDerivedProductManipulationList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductManipulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductManipulationList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value is TFhirBiologicallyDerivedProductManipulation);
  FhirBiologicallyDerivedProductManipulations[index] := value;
end;

procedure TFhirBiologicallyDerivedProductManipulationList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductManipulation);
begin
  assert(value is TFhirBiologicallyDerivedProductManipulation);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProductStorage }

constructor TFhirBiologicallyDerivedProductStorage.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProductStorage.Destroy;
begin
  FDescription.free;
  FTemperature.free;
  FScale.free;
  FDuration.free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProductStorage.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirBiologicallyDerivedProductStorage(oSource).descriptionElement.Clone;
  temperatureElement := TFhirBiologicallyDerivedProductStorage(oSource).temperatureElement.Clone;
  scaleElement := TFhirBiologicallyDerivedProductStorage(oSource).scaleElement.Clone;
  duration := TFhirBiologicallyDerivedProductStorage(oSource).duration.Clone;
end;

procedure TFhirBiologicallyDerivedProductStorage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'temperature') Then
     list.add(self.link, 'temperature', FTemperature.Link);
  if (child_name = 'scale') Then
     list.add(self.link, 'scale', FScale.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
end;

procedure TFhirBiologicallyDerivedProductStorage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'temperature', 'decimal', false, TFhirDecimal, FTemperature.Link));
  oList.add(TFHIRProperty.create(self, 'scale', 'code', false, TFhirEnum, FScale.Link));
  oList.add(TFHIRProperty.create(self, 'duration', 'Period', false, TFhirPeriod, FDuration.Link));
end;

function TFhirBiologicallyDerivedProductStorage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'temperature') then
  begin
    TemperatureElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'scale') then
  begin
    ScaleElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductStorageScaleEnum, CODES_TFhirBiologicallyDerivedProductStorageScaleEnum, propValue);
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProductStorage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBiologicallyDerivedProductStorage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'temperature') then result := TFhirDecimal.create()
  else if (propName = 'scale') then result := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductStorageScaleEnum[BiologicallyDerivedProductStorageScaleNull], CODES_TFhirBiologicallyDerivedProductStorageScaleEnum[BiologicallyDerivedProductStorageScaleNull]) 
  else if (propName = 'duration') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProductStorage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'temperature') then result := 'decimal'
  else if (propName = 'scale') then result := 'code'
  else if (propName = 'duration') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProductStorage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'temperature') then TemperatureElement := nil
  else if (propName = 'scale') then ScaleElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProductStorage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'temperature') then TemperatureElement := asDecimal(new)
  else if (propName = 'scale') then ScaleElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductStorageScaleEnum, CODES_TFhirBiologicallyDerivedProductStorageScaleEnum, new)
  else if (propName = 'duration') then DurationElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProductStorage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProductStorage.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct.storage';
end;

function TFhirBiologicallyDerivedProductStorage.Link : TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(inherited Link);
end;

function TFhirBiologicallyDerivedProductStorage.Clone : TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(inherited Clone);
end;

function TFhirBiologicallyDerivedProductStorage.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProductStorage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProductStorage)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProductStorage(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(temperatureElement, o.temperatureElement, true) and 
      compareDeep(scaleElement, o.scaleElement, true) and compareDeep(durationElement, o.durationElement, true);
  end;
end;

function TFhirBiologicallyDerivedProductStorage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FTemperature) and isEmptyProp(FScale) and isEmptyProp(FDuration);
end;

procedure TFhirBiologicallyDerivedProductStorage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('temperature');
  fields.add('scale');
  fields.add('duration');
end;

function TFhirBiologicallyDerivedProductStorage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBiologicallyDerivedProductStorage.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirBiologicallyDerivedProductStorage.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirBiologicallyDerivedProductStorage.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirBiologicallyDerivedProductStorage.SetTemperature(value : TFhirDecimal);
begin
  FTemperature.free;
  FTemperature := value;
end;

function TFhirBiologicallyDerivedProductStorage.GetTemperatureST : String;
begin
  if FTemperature = nil then
    result := ''
  else
    result := FTemperature.value;
end;

procedure TFhirBiologicallyDerivedProductStorage.SetTemperatureST(value : String);
begin
  if value <> '' then
  begin
    if FTemperature = nil then
      FTemperature := TFhirDecimal.create;
    FTemperature.value := value
  end
  else if FTemperature <> nil then
    FTemperature.value := '';
end;

procedure TFhirBiologicallyDerivedProductStorage.SetScale(value : TFhirEnum);
begin
  FScale.free;
  FScale := value;
end;

function TFhirBiologicallyDerivedProductStorage.GetScaleST : TFhirBiologicallyDerivedProductStorageScaleEnum;
begin
  if FScale = nil then
    result := TFhirBiologicallyDerivedProductStorageScaleEnum(0)
  else
    result := TFhirBiologicallyDerivedProductStorageScaleEnum(StringArrayIndexOfSensitive(CODES_TFhirBiologicallyDerivedProductStorageScaleEnum, FScale.value));
end;

procedure TFhirBiologicallyDerivedProductStorage.SetScaleST(value : TFhirBiologicallyDerivedProductStorageScaleEnum);
begin
  if ord(value) = 0 then
    ScaleElement := nil
  else
    ScaleElement := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductStorageScaleEnum[value], CODES_TFhirBiologicallyDerivedProductStorageScaleEnum[value]);
end;

procedure TFhirBiologicallyDerivedProductStorage.SetDuration(value : TFhirPeriod);
begin
  FDuration.free;
  FDuration := value;
end;

{ TFhirBiologicallyDerivedProductStorageListEnumerator }

constructor TFhirBiologicallyDerivedProductStorageListEnumerator.Create(list : TFhirBiologicallyDerivedProductStorageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductStorageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductStorageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductStorageListEnumerator.GetCurrent : TFhirBiologicallyDerivedProductStorage;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductStorageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductStorageList }

function TFhirBiologicallyDerivedProductStorageList.AddItem(value: TFhirBiologicallyDerivedProductStorage): TFhirBiologicallyDerivedProductStorage;
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProductStorage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProductStorage');
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductStorageList.Append: TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductStorageList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductStorageList.GetEnumerator : TFhirBiologicallyDerivedProductStorageListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductStorageListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductStorageList.Clone: TFhirBiologicallyDerivedProductStorageList;
begin
  result := TFhirBiologicallyDerivedProductStorageList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductStorageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductStorageList.GetItemN(index: Integer): TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductStorageList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProductStorage;
end;
function TFhirBiologicallyDerivedProductStorageList.IndexOf(value: TFhirBiologicallyDerivedProductStorage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductStorageList.Insert(index: Integer): TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductStorageList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value is TFhirBiologicallyDerivedProductStorage);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductStorageList.Item(index: Integer): TFhirBiologicallyDerivedProductStorage;
begin
  result := TFhirBiologicallyDerivedProductStorage(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductStorageList.Link: TFhirBiologicallyDerivedProductStorageList;
begin
  result := TFhirBiologicallyDerivedProductStorageList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductStorageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductStorageList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value is TFhirBiologicallyDerivedProductStorage);
  FhirBiologicallyDerivedProductStorages[index] := value;
end;

procedure TFhirBiologicallyDerivedProductStorageList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProductStorage);
begin
  assert(value is TFhirBiologicallyDerivedProductStorage);
  ObjectByIndex[index] := value;
end;

{ TFhirBiologicallyDerivedProduct }

constructor TFhirBiologicallyDerivedProduct.Create;
begin
  inherited;
end;

destructor TFhirBiologicallyDerivedProduct.Destroy;
begin
  FIdentifierList.Free;
  FProductCategory.free;
  FProductCode.free;
  FStatus.free;
  FRequestList.Free;
  FQuantity.free;
  FParentList.Free;
  FCollection.free;
  FProcessingList.Free;
  FManipulation.free;
  FStorageList.Free;
  inherited;
end;

procedure TFhirBiologicallyDerivedProduct.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBiologicallyDerivedProduct(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBiologicallyDerivedProduct(oSource).FIdentifierList);
  end;
  productCategoryElement := TFhirBiologicallyDerivedProduct(oSource).productCategoryElement.Clone;
  productCode := TFhirBiologicallyDerivedProduct(oSource).productCode.Clone;
  statusElement := TFhirBiologicallyDerivedProduct(oSource).statusElement.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FRequestList = nil) then
  begin
    FRequestList.free;
    FRequestList := nil;
  end
  else
  begin
    if FRequestList = nil then
      FRequestList := TFhirReferenceList.Create;
    FRequestList.Assign(TFhirBiologicallyDerivedProduct(oSource).FRequestList);
  end;
  quantityElement := TFhirBiologicallyDerivedProduct(oSource).quantityElement.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirReferenceList.Create;
    FParentList.Assign(TFhirBiologicallyDerivedProduct(oSource).FParentList);
  end;
  collection := TFhirBiologicallyDerivedProduct(oSource).collection.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FProcessingList = nil) then
  begin
    FProcessingList.free;
    FProcessingList := nil;
  end
  else
  begin
    if FProcessingList = nil then
      FProcessingList := TFhirBiologicallyDerivedProductProcessingList.Create;
    FProcessingList.Assign(TFhirBiologicallyDerivedProduct(oSource).FProcessingList);
  end;
  manipulation := TFhirBiologicallyDerivedProduct(oSource).manipulation.Clone;
  if (TFhirBiologicallyDerivedProduct(oSource).FStorageList = nil) then
  begin
    FStorageList.free;
    FStorageList := nil;
  end
  else
  begin
    if FStorageList = nil then
      FStorageList := TFhirBiologicallyDerivedProductStorageList.Create;
    FStorageList.Assign(TFhirBiologicallyDerivedProduct(oSource).FStorageList);
  end;
end;

function TFhirBiologicallyDerivedProduct.GetResourceType : TFhirResourceType;
begin
  result := frtBiologicallyDerivedProduct;
end;

procedure TFhirBiologicallyDerivedProduct.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'productCategory') Then
     list.add(self.link, 'productCategory', FProductCategory.Link);
  if (child_name = 'productCode') Then
     list.add(self.link, 'productCode', FProductCode.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'request') Then
    list.addAll(self, 'request', FRequestList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'collection') Then
     list.add(self.link, 'collection', FCollection.Link);
  if (child_name = 'processing') Then
    list.addAll(self, 'processing', FProcessingList);
  if (child_name = 'manipulation') Then
     list.add(self.link, 'manipulation', FManipulation.Link);
  if (child_name = 'storage') Then
    list.addAll(self, 'storage', FStorageList);
end;

procedure TFhirBiologicallyDerivedProduct.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'productCategory', 'code', false, TFhirEnum, FProductCategory.Link));
  oList.add(TFHIRProperty.create(self, 'productCode', 'CodeableConcept', false, TFhirCodeableConcept, FProductCode.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', true, TFhirReference, FRequestList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'integer', false, TFhirInteger, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', true, TFhirReference, FParentList.Link));
  oList.add(TFHIRProperty.create(self, 'collection', 'BackboneElement', false, TFhirBiologicallyDerivedProductCollection, FCollection.Link));
  oList.add(TFHIRProperty.create(self, 'processing', 'BackboneElement', true, TFhirBiologicallyDerivedProductProcessing, FProcessingList.Link));
  oList.add(TFHIRProperty.create(self, 'manipulation', 'BackboneElement', false, TFhirBiologicallyDerivedProductManipulation, FManipulation.Link));
  oList.add(TFHIRProperty.create(self, 'storage', 'BackboneElement', true, TFhirBiologicallyDerivedProductStorage, FStorageList.Link));
end;

function TFhirBiologicallyDerivedProduct.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'productCategory') then
  begin
    ProductCategoryElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductCategoryEnum, CODES_TFhirBiologicallyDerivedProductCategoryEnum, propValue);
    result := propValue;
  end
  else if (propName = 'productCode') then
  begin
    ProductCode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductStatusEnum, CODES_TFhirBiologicallyDerivedProductStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    RequestList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'collection') then
  begin
    Collection := propValue as TFhirBiologicallyDerivedProductCollection;
    result := propValue;
  end
  else if (propName = 'processing') then
  begin
    ProcessingList.add(propValue as TFhirBiologicallyDerivedProductProcessing);
    result := propValue;
  end
  else if (propName = 'manipulation') then
  begin
    Manipulation := propValue as TFhirBiologicallyDerivedProductManipulation;
    result := propValue;
  end
  else if (propName = 'storage') then
  begin
    StorageList.add(propValue as TFhirBiologicallyDerivedProductStorage);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBiologicallyDerivedProduct.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'request') then RequestList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'parent') then ParentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'processing') then ProcessingList.insertItem(index, propValue as TFhirBiologicallyDerivedProductProcessing)
  else if (propName = 'storage') then StorageList.insertItem(index, propValue as TFhirBiologicallyDerivedProductStorage)
  else inherited;
end;

function TFhirBiologicallyDerivedProduct.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'productCategory') then result := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductCategoryEnum[BiologicallyDerivedProductCategoryNull], CODES_TFhirBiologicallyDerivedProductCategoryEnum[BiologicallyDerivedProductCategoryNull]) 
  else if (propName = 'productCode') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductStatusEnum[BiologicallyDerivedProductStatusNull], CODES_TFhirBiologicallyDerivedProductStatusEnum[BiologicallyDerivedProductStatusNull]) 
  else if (propName = 'request') then result := RequestList.new()
  else if (propName = 'quantity') then result := TFhirInteger.create()
  else if (propName = 'parent') then result := ParentList.new()
  else if (propName = 'collection') then result := TFhirBiologicallyDerivedProductCollection.create()
  else if (propName = 'processing') then result := ProcessingList.new()
  else if (propName = 'manipulation') then result := TFhirBiologicallyDerivedProductManipulation.create()
  else if (propName = 'storage') then result := StorageList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBiologicallyDerivedProduct.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'productCategory') then result := 'code'
  else if (propName = 'productCode') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'quantity') then result := 'integer'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'collection') then result := 'BackboneElement'
  else if (propName = 'processing') then result := 'BackboneElement'
  else if (propName = 'manipulation') then result := 'BackboneElement'
  else if (propName = 'storage') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBiologicallyDerivedProduct.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'productCategory') then ProductCategoryElement := nil
  else if (propName = 'productCode') then ProductCodeElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'request') then deletePropertyValue('request', RequestList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value)
  else if (propName = 'collection') then CollectionElement := nil
  else if (propName = 'processing') then deletePropertyValue('processing', ProcessingList, value)
  else if (propName = 'manipulation') then ManipulationElement := nil
  else if (propName = 'storage') then deletePropertyValue('storage', StorageList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBiologicallyDerivedProduct.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'productCategory') then ProductCategoryElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductCategoryEnum, CODES_TFhirBiologicallyDerivedProductCategoryEnum, new)
  else if (propName = 'productCode') then ProductCodeElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirBiologicallyDerivedProductStatusEnum, CODES_TFhirBiologicallyDerivedProductStatusEnum, new)
  else if (propName = 'request') then replacePropertyValue('request', RequestList, existing, new)
  else if (propName = 'quantity') then QuantityElement := asInteger(new)
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new)
  else if (propName = 'collection') then CollectionElement := new as TFhirBiologicallyDerivedProductCollection
  else if (propName = 'processing') then replacePropertyValue('processing', ProcessingList, existing, new)
  else if (propName = 'manipulation') then ManipulationElement := new as TFhirBiologicallyDerivedProductManipulation
  else if (propName = 'storage') then replacePropertyValue('storage', StorageList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBiologicallyDerivedProduct.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'request') then RequestList.move(source, destination)
  else if (propName = 'parent') then ParentList.move(source, destination)
  else if (propName = 'processing') then ProcessingList.move(source, destination)
  else if (propName = 'storage') then StorageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBiologicallyDerivedProduct.fhirType : string;
begin
  result := 'BiologicallyDerivedProduct';
end;

function TFhirBiologicallyDerivedProduct.Link : TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(inherited Link);
end;

function TFhirBiologicallyDerivedProduct.Clone : TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(inherited Clone);
end;

function TFhirBiologicallyDerivedProduct.equals(other : TObject) : boolean; 
var
  o : TFhirBiologicallyDerivedProduct;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBiologicallyDerivedProduct)) then
    result := false
  else
  begin
    o := TFhirBiologicallyDerivedProduct(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(productCategoryElement, o.productCategoryElement, true) and 
      compareDeep(productCodeElement, o.productCodeElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(requestList, o.requestList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(parentList, o.parentList, true) and compareDeep(collectionElement, o.collectionElement, true) and 
      compareDeep(processingList, o.processingList, true) and compareDeep(manipulationElement, o.manipulationElement, true) and 
      compareDeep(storageList, o.storageList, true);
  end;
end;

function TFhirBiologicallyDerivedProduct.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FProductCategory) and isEmptyProp(FProductCode) and isEmptyProp(FStatus) and isEmptyProp(FrequestList) and isEmptyProp(FQuantity) and isEmptyProp(FparentList) and isEmptyProp(FCollection) and isEmptyProp(FprocessingList) and isEmptyProp(FManipulation) and isEmptyProp(FstorageList);
end;

procedure TFhirBiologicallyDerivedProduct.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('productCategory');
  fields.add('productCode');
  fields.add('status');
  fields.add('request');
  fields.add('quantity');
  fields.add('parent');
  fields.add('collection');
  fields.add('processing');
  fields.add('manipulation');
  fields.add('storage');
end;

function TFhirBiologicallyDerivedProduct.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRequestList.sizeInBytes(magic));
  inc(result, FParentList.sizeInBytes(magic));
  inc(result, FProcessingList.sizeInBytes(magic));
  inc(result, FStorageList.sizeInBytes(magic));
end;

function TFhirBiologicallyDerivedProduct.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirBiologicallyDerivedProduct.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirBiologicallyDerivedProduct.SetProductCategory(value : TFhirEnum);
begin
  FProductCategory.free;
  FProductCategory := value;
end;

function TFhirBiologicallyDerivedProduct.GetProductCategoryST : TFhirBiologicallyDerivedProductCategoryEnum;
begin
  if FProductCategory = nil then
    result := TFhirBiologicallyDerivedProductCategoryEnum(0)
  else
    result := TFhirBiologicallyDerivedProductCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirBiologicallyDerivedProductCategoryEnum, FProductCategory.value));
end;

procedure TFhirBiologicallyDerivedProduct.SetProductCategoryST(value : TFhirBiologicallyDerivedProductCategoryEnum);
begin
  if ord(value) = 0 then
    ProductCategoryElement := nil
  else
    ProductCategoryElement := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductCategoryEnum[value], CODES_TFhirBiologicallyDerivedProductCategoryEnum[value]);
end;

procedure TFhirBiologicallyDerivedProduct.SetProductCode(value : TFhirCodeableConcept);
begin
  FProductCode.free;
  FProductCode := value;
end;

procedure TFhirBiologicallyDerivedProduct.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirBiologicallyDerivedProduct.GetStatusST : TFhirBiologicallyDerivedProductStatusEnum;
begin
  if FStatus = nil then
    result := TFhirBiologicallyDerivedProductStatusEnum(0)
  else
    result := TFhirBiologicallyDerivedProductStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirBiologicallyDerivedProductStatusEnum, FStatus.value));
end;

procedure TFhirBiologicallyDerivedProduct.SetStatusST(value : TFhirBiologicallyDerivedProductStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirBiologicallyDerivedProductStatusEnum[value], CODES_TFhirBiologicallyDerivedProductStatusEnum[value]);
end;

function TFhirBiologicallyDerivedProduct.GetRequestList : TFhirReferenceList;
begin
  if FRequestList = nil then
    FRequestList := TFhirReferenceList.Create;
  result := FRequestList;
end;

function TFhirBiologicallyDerivedProduct.GetHasRequestList : boolean;
begin
  result := (FRequestList <> nil) and (FRequestList.count > 0);
end;

procedure TFhirBiologicallyDerivedProduct.SetQuantity(value : TFhirInteger);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirBiologicallyDerivedProduct.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

procedure TFhirBiologicallyDerivedProduct.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirInteger.create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

function TFhirBiologicallyDerivedProduct.GetParentList : TFhirReferenceList;
begin
  if FParentList = nil then
    FParentList := TFhirReferenceList.Create;
  result := FParentList;
end;

function TFhirBiologicallyDerivedProduct.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

procedure TFhirBiologicallyDerivedProduct.SetCollection(value : TFhirBiologicallyDerivedProductCollection);
begin
  FCollection.free;
  FCollection := value;
end;

function TFhirBiologicallyDerivedProduct.GetProcessingList : TFhirBiologicallyDerivedProductProcessingList;
begin
  if FProcessingList = nil then
    FProcessingList := TFhirBiologicallyDerivedProductProcessingList.Create;
  result := FProcessingList;
end;

function TFhirBiologicallyDerivedProduct.GetHasProcessingList : boolean;
begin
  result := (FProcessingList <> nil) and (FProcessingList.count > 0);
end;

procedure TFhirBiologicallyDerivedProduct.SetManipulation(value : TFhirBiologicallyDerivedProductManipulation);
begin
  FManipulation.free;
  FManipulation := value;
end;

function TFhirBiologicallyDerivedProduct.GetStorageList : TFhirBiologicallyDerivedProductStorageList;
begin
  if FStorageList = nil then
    FStorageList := TFhirBiologicallyDerivedProductStorageList.Create;
  result := FStorageList;
end;

function TFhirBiologicallyDerivedProduct.GetHasStorageList : boolean;
begin
  result := (FStorageList <> nil) and (FStorageList.count > 0);
end;

{ TFhirBiologicallyDerivedProductListEnumerator }

constructor TFhirBiologicallyDerivedProductListEnumerator.Create(list : TFhirBiologicallyDerivedProductList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBiologicallyDerivedProductListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBiologicallyDerivedProductListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBiologicallyDerivedProductListEnumerator.GetCurrent : TFhirBiologicallyDerivedProduct;
begin
  Result := FList[FIndex];
end;

function TFhirBiologicallyDerivedProductListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBiologicallyDerivedProductList }

function TFhirBiologicallyDerivedProductList.AddItem(value: TFhirBiologicallyDerivedProduct): TFhirBiologicallyDerivedProduct;
begin
  assert(value.ClassName = 'TFhirBiologicallyDerivedProduct', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBiologicallyDerivedProduct');
  add(value);
  result := value;
end;

function TFhirBiologicallyDerivedProductList.Append: TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductList.ClearItems;
begin
  Clear;
end;

function TFhirBiologicallyDerivedProductList.GetEnumerator : TFhirBiologicallyDerivedProductListEnumerator;
begin
  result := TFhirBiologicallyDerivedProductListEnumerator.Create(self.link);
end;

function TFhirBiologicallyDerivedProductList.Clone: TFhirBiologicallyDerivedProductList;
begin
  result := TFhirBiologicallyDerivedProductList(inherited Clone);
end;

function TFhirBiologicallyDerivedProductList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBiologicallyDerivedProductList.GetItemN(index: Integer): TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductList.ItemClass: TFslObjectClass;
begin
  result := TFhirBiologicallyDerivedProduct;
end;
function TFhirBiologicallyDerivedProductList.IndexOf(value: TFhirBiologicallyDerivedProduct): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBiologicallyDerivedProductList.Insert(index: Integer): TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBiologicallyDerivedProductList.InsertItem(index: Integer; value: TFhirBiologicallyDerivedProduct);
begin
  assert(value is TFhirBiologicallyDerivedProduct);
  Inherited Insert(index, value);
end;

function TFhirBiologicallyDerivedProductList.Item(index: Integer): TFhirBiologicallyDerivedProduct;
begin
  result := TFhirBiologicallyDerivedProduct(ObjectByIndex[index]);
end;

function TFhirBiologicallyDerivedProductList.Link: TFhirBiologicallyDerivedProductList;
begin
  result := TFhirBiologicallyDerivedProductList(inherited Link);
end;

procedure TFhirBiologicallyDerivedProductList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBiologicallyDerivedProductList.SetItemByIndex(index: Integer; value: TFhirBiologicallyDerivedProduct);
begin
  assert(value is TFhirBiologicallyDerivedProduct);
  FhirBiologicallyDerivedProducts[index] := value;
end;

procedure TFhirBiologicallyDerivedProductList.SetItemN(index: Integer; value: TFhirBiologicallyDerivedProduct);
begin
  assert(value is TFhirBiologicallyDerivedProduct);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BIOLOGICALLYDERIVEDPRODUCT}
{$IFDEF FHIR_BODYSTRUCTURE}
{ TFhirBodyStructure }

constructor TFhirBodyStructure.Create;
begin
  inherited;
end;

destructor TFhirBodyStructure.Destroy;
begin
  FIdentifierList.Free;
  FActive.free;
  FMorphology.free;
  FLocation.free;
  FLocationQualifierList.Free;
  FDescription.free;
  FImageList.Free;
  FPatient.free;
  inherited;
end;

procedure TFhirBodyStructure.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBodyStructure(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirBodyStructure(oSource).FIdentifierList);
  end;
  activeElement := TFhirBodyStructure(oSource).activeElement.Clone;
  morphology := TFhirBodyStructure(oSource).morphology.Clone;
  location := TFhirBodyStructure(oSource).location.Clone;
  if (TFhirBodyStructure(oSource).FLocationQualifierList = nil) then
  begin
    FLocationQualifierList.free;
    FLocationQualifierList := nil;
  end
  else
  begin
    if FLocationQualifierList = nil then
      FLocationQualifierList := TFhirCodeableConceptList.Create;
    FLocationQualifierList.Assign(TFhirBodyStructure(oSource).FLocationQualifierList);
  end;
  descriptionElement := TFhirBodyStructure(oSource).descriptionElement.Clone;
  if (TFhirBodyStructure(oSource).FImageList = nil) then
  begin
    FImageList.free;
    FImageList := nil;
  end
  else
  begin
    if FImageList = nil then
      FImageList := TFhirAttachmentList.Create;
    FImageList.Assign(TFhirBodyStructure(oSource).FImageList);
  end;
  patient := TFhirBodyStructure(oSource).patient.Clone;
end;

function TFhirBodyStructure.GetResourceType : TFhirResourceType;
begin
  result := frtBodyStructure;
end;

procedure TFhirBodyStructure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'morphology') Then
     list.add(self.link, 'morphology', FMorphology.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'locationQualifier') Then
    list.addAll(self, 'locationQualifier', FLocationQualifierList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'image') Then
    list.addAll(self, 'image', FImageList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
end;

procedure TFhirBodyStructure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'morphology', 'CodeableConcept', false, TFhirCodeableConcept, FMorphology.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableConcept', false, TFhirCodeableConcept, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'locationQualifier', 'CodeableConcept', true, TFhirCodeableConcept, FLocationQualifierList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'image', 'Attachment', true, TFhirAttachment, FImageList.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
end;

function TFhirBodyStructure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'morphology') then
  begin
    Morphology := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'locationQualifier') then
  begin
    LocationQualifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'image') then
  begin
    ImageList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBodyStructure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'locationQualifier') then LocationQualifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'image') then ImageList.insertItem(index, propValue as TFhirAttachment)
  else inherited;
end;

function TFhirBodyStructure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'morphology') then result := TFhirCodeableConcept.create()
  else if (propName = 'location') then result := TFhirCodeableConcept.create()
  else if (propName = 'locationQualifier') then result := LocationQualifierList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'image') then result := ImageList.new()
  else if (propName = 'patient') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBodyStructure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'morphology') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'CodeableConcept'
  else if (propName = 'locationQualifier') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'image') then result := 'Attachment'
  else if (propName = 'patient') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBodyStructure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'morphology') then MorphologyElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'locationQualifier') then deletePropertyValue('locationQualifier', LocationQualifierList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'image') then deletePropertyValue('image', ImageList, value)
  else if (propName = 'patient') then PatientElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBodyStructure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'morphology') then MorphologyElement := new as TFhirCodeableConcept
  else if (propName = 'location') then LocationElement := new as TFhirCodeableConcept
  else if (propName = 'locationQualifier') then replacePropertyValue('locationQualifier', LocationQualifierList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'image') then replacePropertyValue('image', ImageList, existing, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBodyStructure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'locationQualifier') then LocationQualifierList.move(source, destination)
  else if (propName = 'image') then ImageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBodyStructure.fhirType : string;
begin
  result := 'BodyStructure';
end;

function TFhirBodyStructure.Link : TFhirBodyStructure;
begin
  result := TFhirBodyStructure(inherited Link);
end;

function TFhirBodyStructure.Clone : TFhirBodyStructure;
begin
  result := TFhirBodyStructure(inherited Clone);
end;

function TFhirBodyStructure.equals(other : TObject) : boolean; 
var
  o : TFhirBodyStructure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBodyStructure)) then
    result := false
  else
  begin
    o := TFhirBodyStructure(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(morphologyElement, o.morphologyElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(locationQualifierList, o.locationQualifierList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(imageList, o.imageList, true) and compareDeep(patientElement, o.patientElement, true);
  end;
end;

function TFhirBodyStructure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FMorphology) and isEmptyProp(FLocation) and isEmptyProp(FlocationQualifierList) and isEmptyProp(FDescription) and isEmptyProp(FimageList) and isEmptyProp(FPatient);
end;

procedure TFhirBodyStructure.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('morphology');
  fields.add('location');
  fields.add('locationQualifier');
  fields.add('description');
  fields.add('image');
  fields.add('patient');
end;

function TFhirBodyStructure.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FLocationQualifierList.sizeInBytes(magic));
  inc(result, FImageList.sizeInBytes(magic));
end;

function TFhirBodyStructure.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirBodyStructure.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirBodyStructure.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirBodyStructure.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirBodyStructure.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirBodyStructure.SetMorphology(value : TFhirCodeableConcept);
begin
  FMorphology.free;
  FMorphology := value;
end;

procedure TFhirBodyStructure.SetLocation(value : TFhirCodeableConcept);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirBodyStructure.GetLocationQualifierList : TFhirCodeableConceptList;
begin
  if FLocationQualifierList = nil then
    FLocationQualifierList := TFhirCodeableConceptList.Create;
  result := FLocationQualifierList;
end;

function TFhirBodyStructure.GetHasLocationQualifierList : boolean;
begin
  result := (FLocationQualifierList <> nil) and (FLocationQualifierList.count > 0);
end;

procedure TFhirBodyStructure.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirBodyStructure.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirBodyStructure.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirBodyStructure.GetImageList : TFhirAttachmentList;
begin
  if FImageList = nil then
    FImageList := TFhirAttachmentList.Create;
  result := FImageList;
end;

function TFhirBodyStructure.GetHasImageList : boolean;
begin
  result := (FImageList <> nil) and (FImageList.count > 0);
end;

procedure TFhirBodyStructure.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

{ TFhirBodyStructureListEnumerator }

constructor TFhirBodyStructureListEnumerator.Create(list : TFhirBodyStructureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBodyStructureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBodyStructureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBodyStructureListEnumerator.GetCurrent : TFhirBodyStructure;
begin
  Result := FList[FIndex];
end;

function TFhirBodyStructureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBodyStructureList }

function TFhirBodyStructureList.AddItem(value: TFhirBodyStructure): TFhirBodyStructure;
begin
  assert(value.ClassName = 'TFhirBodyStructure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBodyStructure');
  add(value);
  result := value;
end;

function TFhirBodyStructureList.Append: TFhirBodyStructure;
begin
  result := TFhirBodyStructure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBodyStructureList.ClearItems;
begin
  Clear;
end;

function TFhirBodyStructureList.GetEnumerator : TFhirBodyStructureListEnumerator;
begin
  result := TFhirBodyStructureListEnumerator.Create(self.link);
end;

function TFhirBodyStructureList.Clone: TFhirBodyStructureList;
begin
  result := TFhirBodyStructureList(inherited Clone);
end;

function TFhirBodyStructureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBodyStructureList.GetItemN(index: Integer): TFhirBodyStructure;
begin
  result := TFhirBodyStructure(ObjectByIndex[index]);
end;

function TFhirBodyStructureList.ItemClass: TFslObjectClass;
begin
  result := TFhirBodyStructure;
end;
function TFhirBodyStructureList.IndexOf(value: TFhirBodyStructure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBodyStructureList.Insert(index: Integer): TFhirBodyStructure;
begin
  result := TFhirBodyStructure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBodyStructureList.InsertItem(index: Integer; value: TFhirBodyStructure);
begin
  assert(value is TFhirBodyStructure);
  Inherited Insert(index, value);
end;

function TFhirBodyStructureList.Item(index: Integer): TFhirBodyStructure;
begin
  result := TFhirBodyStructure(ObjectByIndex[index]);
end;

function TFhirBodyStructureList.Link: TFhirBodyStructureList;
begin
  result := TFhirBodyStructureList(inherited Link);
end;

procedure TFhirBodyStructureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBodyStructureList.SetItemByIndex(index: Integer; value: TFhirBodyStructure);
begin
  assert(value is TFhirBodyStructure);
  FhirBodyStructures[index] := value;
end;

procedure TFhirBodyStructureList.SetItemN(index: Integer; value: TFhirBodyStructure);
begin
  assert(value is TFhirBodyStructure);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BODYSTRUCTURE}
{$IFDEF FHIR_CAREPLAN}
{ TFhirCarePlanActivity }

constructor TFhirCarePlanActivity.Create;
begin
  inherited;
end;

destructor TFhirCarePlanActivity.Destroy;
begin
  FOutcomeCodeableConceptList.Free;
  FOutcomeReferenceList.Free;
  FProgressList.Free;
  FReference.free;
  FDetail.free;
  inherited;
end;

procedure TFhirCarePlanActivity.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCarePlanActivity(oSource).FOutcomeCodeableConceptList = nil) then
  begin
    FOutcomeCodeableConceptList.free;
    FOutcomeCodeableConceptList := nil;
  end
  else
  begin
    if FOutcomeCodeableConceptList = nil then
      FOutcomeCodeableConceptList := TFhirCodeableConceptList.Create;
    FOutcomeCodeableConceptList.Assign(TFhirCarePlanActivity(oSource).FOutcomeCodeableConceptList);
  end;
  if (TFhirCarePlanActivity(oSource).FOutcomeReferenceList = nil) then
  begin
    FOutcomeReferenceList.free;
    FOutcomeReferenceList := nil;
  end
  else
  begin
    if FOutcomeReferenceList = nil then
      FOutcomeReferenceList := TFhirReferenceList.Create;
    FOutcomeReferenceList.Assign(TFhirCarePlanActivity(oSource).FOutcomeReferenceList);
  end;
  if (TFhirCarePlanActivity(oSource).FProgressList = nil) then
  begin
    FProgressList.free;
    FProgressList := nil;
  end
  else
  begin
    if FProgressList = nil then
      FProgressList := TFhirAnnotationList.Create;
    FProgressList.Assign(TFhirCarePlanActivity(oSource).FProgressList);
  end;
  reference := TFhirCarePlanActivity(oSource).reference.Clone;
  detail := TFhirCarePlanActivity(oSource).detail.Clone;
end;

procedure TFhirCarePlanActivity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'outcomeCodeableConcept') Then
    list.addAll(self, 'outcomeCodeableConcept', FOutcomeCodeableConceptList);
  if (child_name = 'outcomeReference') Then
    list.addAll(self, 'outcomeReference', FOutcomeReferenceList);
  if (child_name = 'progress') Then
    list.addAll(self, 'progress', FProgressList);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirCarePlanActivity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'outcomeCodeableConcept', 'CodeableConcept', true, TFhirCodeableConcept, FOutcomeCodeableConceptList.Link));
  oList.add(TFHIRProperty.create(self, 'outcomeReference', 'Reference', true, TFhirReference, FOutcomeReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'progress', 'Annotation', true, TFhirAnnotation, FProgressList.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', false, TFhirCarePlanActivityDetail, FDetail.Link));
end;

function TFhirCarePlanActivity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'outcomeCodeableConcept') then
  begin
    OutcomeCodeableConceptList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'outcomeReference') then
  begin
    OutcomeReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'progress') then
  begin
    ProgressList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    Detail := propValue as TFhirCarePlanActivityDetail;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanActivity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'outcomeCodeableConcept') then OutcomeCodeableConceptList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'outcomeReference') then OutcomeReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'progress') then ProgressList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirCarePlanActivity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'outcomeCodeableConcept') then result := OutcomeCodeableConceptList.new()
  else if (propName = 'outcomeReference') then result := OutcomeReferenceList.new()
  else if (propName = 'progress') then result := ProgressList.new()
  else if (propName = 'reference') then result := TFhirReference.create()
  else if (propName = 'detail') then result := TFhirCarePlanActivityDetail.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanActivity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'outcomeCodeableConcept') then result := 'CodeableConcept'
  else if (propName = 'outcomeReference') then result := 'Reference'
  else if (propName = 'progress') then result := 'Annotation'
  else if (propName = 'reference') then result := 'Reference'
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanActivity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'outcomeCodeableConcept') then deletePropertyValue('outcomeCodeableConcept', OutcomeCodeableConceptList, value)
  else if (propName = 'outcomeReference') then deletePropertyValue('outcomeReference', OutcomeReferenceList, value)
  else if (propName = 'progress') then deletePropertyValue('progress', ProgressList, value)
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanActivity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'outcomeCodeableConcept') then replacePropertyValue('outcomeCodeableConcept', OutcomeCodeableConceptList, existing, new)
  else if (propName = 'outcomeReference') then replacePropertyValue('outcomeReference', OutcomeReferenceList, existing, new)
  else if (propName = 'progress') then replacePropertyValue('progress', ProgressList, existing, new)
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else if (propName = 'detail') then DetailElement := new as TFhirCarePlanActivityDetail
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanActivity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'outcomeCodeableConcept') then OutcomeCodeableConceptList.move(source, destination)
  else if (propName = 'outcomeReference') then OutcomeReferenceList.move(source, destination)
  else if (propName = 'progress') then ProgressList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanActivity.fhirType : string;
begin
  result := 'CarePlan.activity';
end;

function TFhirCarePlanActivity.Link : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Link);
end;

function TFhirCarePlanActivity.Clone : TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(inherited Clone);
end;

function TFhirCarePlanActivity.equals(other : TObject) : boolean; 
var
  o : TFhirCarePlanActivity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanActivity)) then
    result := false
  else
  begin
    o := TFhirCarePlanActivity(other);
    result := compareDeep(outcomeCodeableConceptList, o.outcomeCodeableConceptList, true) and 
      compareDeep(outcomeReferenceList, o.outcomeReferenceList, true) and compareDeep(progressList, o.progressList, true) and 
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirCarePlanActivity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FoutcomeCodeableConceptList) and isEmptyProp(FoutcomeReferenceList) and isEmptyProp(FprogressList) and isEmptyProp(FReference) and isEmptyProp(FDetail);
end;

procedure TFhirCarePlanActivity.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('outcomeCodeableConcept');
  fields.add('outcomeReference');
  fields.add('progress');
  fields.add('reference');
  fields.add('detail');
end;

function TFhirCarePlanActivity.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FOutcomeCodeableConceptList.sizeInBytes(magic));
  inc(result, FOutcomeReferenceList.sizeInBytes(magic));
  inc(result, FProgressList.sizeInBytes(magic));
end;

function TFhirCarePlanActivity.GetOutcomeCodeableConceptList : TFhirCodeableConceptList;
begin
  if FOutcomeCodeableConceptList = nil then
    FOutcomeCodeableConceptList := TFhirCodeableConceptList.Create;
  result := FOutcomeCodeableConceptList;
end;

function TFhirCarePlanActivity.GetHasOutcomeCodeableConceptList : boolean;
begin
  result := (FOutcomeCodeableConceptList <> nil) and (FOutcomeCodeableConceptList.count > 0);
end;

function TFhirCarePlanActivity.GetOutcomeReferenceList : TFhirReferenceList;
begin
  if FOutcomeReferenceList = nil then
    FOutcomeReferenceList := TFhirReferenceList.Create;
  result := FOutcomeReferenceList;
end;

function TFhirCarePlanActivity.GetHasOutcomeReferenceList : boolean;
begin
  result := (FOutcomeReferenceList <> nil) and (FOutcomeReferenceList.count > 0);
end;

function TFhirCarePlanActivity.GetProgressList : TFhirAnnotationList;
begin
  if FProgressList = nil then
    FProgressList := TFhirAnnotationList.Create;
  result := FProgressList;
end;

function TFhirCarePlanActivity.GetHasProgressList : boolean;
begin
  result := (FProgressList <> nil) and (FProgressList.count > 0);
end;

procedure TFhirCarePlanActivity.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

procedure TFhirCarePlanActivity.SetDetail(value : TFhirCarePlanActivityDetail);
begin
  FDetail.free;
  FDetail := value;
end;

{ TFhirCarePlanActivityListEnumerator }

constructor TFhirCarePlanActivityListEnumerator.Create(list : TFhirCarePlanActivityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanActivityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanActivityListEnumerator.GetCurrent : TFhirCarePlanActivity;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanActivityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCarePlanActivityList }

function TFhirCarePlanActivityList.AddItem(value: TFhirCarePlanActivity): TFhirCarePlanActivity;
begin
  assert(value.ClassName = 'TFhirCarePlanActivity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivity');
  add(value);
  result := value;
end;

function TFhirCarePlanActivityList.Append: TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityList.GetEnumerator : TFhirCarePlanActivityListEnumerator;
begin
  result := TFhirCarePlanActivityListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivityList.Clone: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Clone);
end;

function TFhirCarePlanActivityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityList.GetItemN(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanActivity;
end;
function TFhirCarePlanActivityList.IndexOf(value: TFhirCarePlanActivity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanActivityList.Insert(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityList.InsertItem(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityList.Item(index: Integer): TFhirCarePlanActivity;
begin
  result := TFhirCarePlanActivity(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityList.Link: TFhirCarePlanActivityList;
begin
  result := TFhirCarePlanActivityList(inherited Link);
end;

procedure TFhirCarePlanActivityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  FhirCarePlanActivities[index] := value;
end;

procedure TFhirCarePlanActivityList.SetItemN(index: Integer; value: TFhirCarePlanActivity);
begin
  assert(value is TFhirCarePlanActivity);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlanActivityDetail }

constructor TFhirCarePlanActivityDetail.Create;
begin
  inherited;
end;

destructor TFhirCarePlanActivityDetail.Destroy;
begin
  FKind.free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FCode.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FGoalList.Free;
  FStatus.free;
  FStatusReason.free;
  FDoNotPerform.free;
  FScheduled.free;
  FLocation.free;
  FPerformerList.Free;
  FProduct.free;
  FDailyAmount.free;
  FQuantity.free;
  FDescription.free;
  inherited;
end;

procedure TFhirCarePlanActivityDetail.Assign(oSource : TFslObject);
begin
  inherited;
  kindElement := TFhirCarePlanActivityDetail(oSource).kindElement.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirCarePlanActivityDetail(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirCarePlanActivityDetail(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirCarePlanActivityDetail(oSource).FInstantiatesUriList);
  end;
  code := TFhirCarePlanActivityDetail(oSource).code.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirCarePlanActivityDetail(oSource).FReasonCodeList);
  end;
  if (TFhirCarePlanActivityDetail(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirCarePlanActivityDetail(oSource).FReasonReferenceList);
  end;
  if (TFhirCarePlanActivityDetail(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList.Create;
    FGoalList.Assign(TFhirCarePlanActivityDetail(oSource).FGoalList);
  end;
  statusElement := TFhirCarePlanActivityDetail(oSource).statusElement.Clone;
  statusReason := TFhirCarePlanActivityDetail(oSource).statusReason.Clone;
  doNotPerformElement := TFhirCarePlanActivityDetail(oSource).doNotPerformElement.Clone;
  scheduled := TFhirCarePlanActivityDetail(oSource).scheduled.Clone;
  location := TFhirCarePlanActivityDetail(oSource).location.Clone;
  if (TFhirCarePlanActivityDetail(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList.Create;
    FPerformerList.Assign(TFhirCarePlanActivityDetail(oSource).FPerformerList);
  end;
  product := TFhirCarePlanActivityDetail(oSource).product.Clone;
  dailyAmount := TFhirCarePlanActivityDetail(oSource).dailyAmount.Clone;
  quantity := TFhirCarePlanActivityDetail(oSource).quantity.Clone;
  descriptionElement := TFhirCarePlanActivityDetail(oSource).descriptionElement.Clone;
end;

procedure TFhirCarePlanActivityDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'scheduled[x]') or (child_name = 'scheduled') Then
     list.add(self.link, 'scheduled[x]', FScheduled.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'dailyAmount') Then
     list.add(self.link, 'dailyAmount', FDailyAmount.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirCarePlanActivityDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference', true, TFhirReference, FGoalList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));
  oList.add(TFHIRProperty.create(self, 'scheduled[x]', 'Timing|Period|string', false, TFhirDataType, FScheduled.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', true, TFhirReference, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'product[x]', 'CodeableConcept|Reference', false, TFhirDataType, FProduct.Link));
  oList.add(TFHIRProperty.create(self, 'dailyAmount', 'Quantity', false, TFhirQuantity, FDailyAmount.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
end;

function TFhirCarePlanActivityDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirCarePlanActivityKindEnum, CODES_TFhirCarePlanActivityKindEnum, propValue);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCarePlanActivityStatusEnum, CODES_TFhirCarePlanActivityStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then
  begin
    Scheduled := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then
  begin
    Product := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'dailyAmount') then
  begin
    DailyAmount := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlanActivityDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirCarePlanActivityDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityKindEnum[CarePlanActivityKindNull], CODES_TFhirCarePlanActivityKindEnum[CarePlanActivityKindNull]) 
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'goal') then result := GoalList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityStatusEnum[CarePlanActivityStatusNull], CODES_TFhirCarePlanActivityStatusEnum[CarePlanActivityStatusNull]) 
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then raise EFHIRException.create('Cannot make property Scheduled')
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'performer') then result := PerformerList.new()
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Product')
  else if (propName = 'dailyAmount') then result := TFhirQuantity.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'description') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlanActivityDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'scheduled[x]') then result := 'Timing|Period|string'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'product[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'dailyAmount') then result := 'Quantity'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlanActivityDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then ScheduledElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then ProductElement := nil
  else if (propName = 'dailyAmount') then DailyAmountElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlanActivityDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirCarePlanActivityKindEnum, CODES_TFhirCarePlanActivityKindEnum, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCarePlanActivityStatusEnum, CODES_TFhirCarePlanActivityStatusEnum, new)
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new)
  else if (isMatchingName(propName, 'scheduled', ['Timing', 'Period', 'String'])) then ScheduledElement := new as TFhirDataType
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (isMatchingName(propName, 'product', ['CodeableConcept', 'Reference'])) then ProductElement := new as TFhirDataType
  else if (propName = 'dailyAmount') then DailyAmountElement := new as TFhirQuantity
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'description') then DescriptionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlanActivityDetail.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'goal') then GoalList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlanActivityDetail.fhirType : string;
begin
  result := 'CarePlan.activity.detail';
end;

function TFhirCarePlanActivityDetail.Link : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(inherited Link);
end;

function TFhirCarePlanActivityDetail.Clone : TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(inherited Clone);
end;

function TFhirCarePlanActivityDetail.equals(other : TObject) : boolean; 
var
  o : TFhirCarePlanActivityDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlanActivityDetail)) then
    result := false
  else
  begin
    o := TFhirCarePlanActivityDetail(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(goalList, o.goalList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(doNotPerformElement, o.doNotPerformElement, true) and 
      compareDeep(scheduledElement, o.scheduledElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(productElement, o.productElement, true) and 
      compareDeep(dailyAmountElement, o.dailyAmountElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirCarePlanActivityDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FCode) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FgoalList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FDoNotPerform) and isEmptyProp(FScheduled) and isEmptyProp(FLocation) and isEmptyProp(FperformerList) and isEmptyProp(FProduct) and isEmptyProp(FDailyAmount) and isEmptyProp(FQuantity) and isEmptyProp(FDescription);
end;

procedure TFhirCarePlanActivityDetail.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('kind');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('code');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('goal');
  fields.add('status');
  fields.add('statusReason');
  fields.add('doNotPerform');
  fields.add('scheduled[x]');
  fields.add('location');
  fields.add('performer');
  fields.add('product[x]');
  fields.add('dailyAmount');
  fields.add('quantity');
  fields.add('description');
end;

function TFhirCarePlanActivityDetail.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FGoalList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
end;

procedure TFhirCarePlanActivityDetail.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirCarePlanActivityDetail.GetKindST : TFhirCarePlanActivityKindEnum;
begin
  if FKind = nil then
    result := TFhirCarePlanActivityKindEnum(0)
  else
    result := TFhirCarePlanActivityKindEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanActivityKindEnum, FKind.value));
end;

procedure TFhirCarePlanActivityDetail.SetKindST(value : TFhirCarePlanActivityKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityKindEnum[value], CODES_TFhirCarePlanActivityKindEnum[value]);
end;

function TFhirCarePlanActivityDetail.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirCarePlanActivityDetail.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirCarePlanActivityDetail.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirCarePlanActivityDetail.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

procedure TFhirCarePlanActivityDetail.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCarePlanActivityDetail.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirCarePlanActivityDetail.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirCarePlanActivityDetail.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirCarePlanActivityDetail.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirCarePlanActivityDetail.GetGoalList : TFhirReferenceList;
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList.Create;
  result := FGoalList;
end;

function TFhirCarePlanActivityDetail.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

procedure TFhirCarePlanActivityDetail.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCarePlanActivityDetail.GetStatusST : TFhirCarePlanActivityStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCarePlanActivityStatusEnum(0)
  else
    result := TFhirCarePlanActivityStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanActivityStatusEnum, FStatus.value));
end;

procedure TFhirCarePlanActivityDetail.SetStatusST(value : TFhirCarePlanActivityStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanActivityStatusEnum[value], CODES_TFhirCarePlanActivityStatusEnum[value]);
end;

procedure TFhirCarePlanActivityDetail.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

procedure TFhirCarePlanActivityDetail.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

function TFhirCarePlanActivityDetail.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirCarePlanActivityDetail.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirCarePlanActivityDetail.SetScheduled(value : TFhirDataType);
begin
  FScheduled.free;
  FScheduled := value;
end;

procedure TFhirCarePlanActivityDetail.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirCarePlanActivityDetail.GetPerformerList : TFhirReferenceList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList.Create;
  result := FPerformerList;
end;

function TFhirCarePlanActivityDetail.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirCarePlanActivityDetail.SetProduct(value : TFhirDataType);
begin
  FProduct.free;
  FProduct := value;
end;

procedure TFhirCarePlanActivityDetail.SetDailyAmount(value : TFhirQuantity);
begin
  FDailyAmount.free;
  FDailyAmount := value;
end;

procedure TFhirCarePlanActivityDetail.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirCarePlanActivityDetail.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCarePlanActivityDetail.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCarePlanActivityDetail.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirCarePlanActivityDetailListEnumerator }

constructor TFhirCarePlanActivityDetailListEnumerator.Create(list : TFhirCarePlanActivityDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanActivityDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanActivityDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanActivityDetailListEnumerator.GetCurrent : TFhirCarePlanActivityDetail;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanActivityDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCarePlanActivityDetailList }

function TFhirCarePlanActivityDetailList.AddItem(value: TFhirCarePlanActivityDetail): TFhirCarePlanActivityDetail;
begin
  assert(value.ClassName = 'TFhirCarePlanActivityDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlanActivityDetail');
  add(value);
  result := value;
end;

function TFhirCarePlanActivityDetailList.Append: TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityDetailList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanActivityDetailList.GetEnumerator : TFhirCarePlanActivityDetailListEnumerator;
begin
  result := TFhirCarePlanActivityDetailListEnumerator.Create(self.link);
end;

function TFhirCarePlanActivityDetailList.Clone: TFhirCarePlanActivityDetailList;
begin
  result := TFhirCarePlanActivityDetailList(inherited Clone);
end;

function TFhirCarePlanActivityDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanActivityDetailList.GetItemN(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlanActivityDetail;
end;
function TFhirCarePlanActivityDetailList.IndexOf(value: TFhirCarePlanActivityDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanActivityDetailList.Insert(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanActivityDetailList.InsertItem(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  Inherited Insert(index, value);
end;

function TFhirCarePlanActivityDetailList.Item(index: Integer): TFhirCarePlanActivityDetail;
begin
  result := TFhirCarePlanActivityDetail(ObjectByIndex[index]);
end;

function TFhirCarePlanActivityDetailList.Link: TFhirCarePlanActivityDetailList;
begin
  result := TFhirCarePlanActivityDetailList(inherited Link);
end;

procedure TFhirCarePlanActivityDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanActivityDetailList.SetItemByIndex(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  FhirCarePlanActivityDetails[index] := value;
end;

procedure TFhirCarePlanActivityDetailList.SetItemN(index: Integer; value: TFhirCarePlanActivityDetail);
begin
  assert(value is TFhirCarePlanActivityDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirCarePlan }

constructor TFhirCarePlan.Create;
begin
  inherited;
end;

destructor TFhirCarePlan.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FPartOfList.Free;
  FStatus.free;
  FIntent.free;
  FCategoryList.Free;
  FTitle.free;
  FDescription.free;
  FSubject.free;
  FEncounter.free;
  FPeriod.free;
  FCreated.free;
  FAuthor.free;
  FContributorList.Free;
  FCareTeamList.Free;
  FAddressesList.Free;
  FSupportingInfoList.Free;
  FGoalList.Free;
  FActivityList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCarePlan.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCarePlan(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCarePlan(oSource).FIdentifierList);
  end;
  if (TFhirCarePlan(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirCarePlan(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirCarePlan(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirCarePlan(oSource).FInstantiatesUriList);
  end;
  if (TFhirCarePlan(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirCarePlan(oSource).FBasedOnList);
  end;
  if (TFhirCarePlan(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList.Create;
    FReplacesList.Assign(TFhirCarePlan(oSource).FReplacesList);
  end;
  if (TFhirCarePlan(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirCarePlan(oSource).FPartOfList);
  end;
  statusElement := TFhirCarePlan(oSource).statusElement.Clone;
  intentElement := TFhirCarePlan(oSource).intentElement.Clone;
  if (TFhirCarePlan(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCarePlan(oSource).FCategoryList);
  end;
  titleElement := TFhirCarePlan(oSource).titleElement.Clone;
  descriptionElement := TFhirCarePlan(oSource).descriptionElement.Clone;
  subject := TFhirCarePlan(oSource).subject.Clone;
  encounter := TFhirCarePlan(oSource).encounter.Clone;
  period := TFhirCarePlan(oSource).period.Clone;
  createdElement := TFhirCarePlan(oSource).createdElement.Clone;
  author := TFhirCarePlan(oSource).author.Clone;
  if (TFhirCarePlan(oSource).FContributorList = nil) then
  begin
    FContributorList.free;
    FContributorList := nil;
  end
  else
  begin
    if FContributorList = nil then
      FContributorList := TFhirReferenceList.Create;
    FContributorList.Assign(TFhirCarePlan(oSource).FContributorList);
  end;
  if (TFhirCarePlan(oSource).FCareTeamList = nil) then
  begin
    FCareTeamList.free;
    FCareTeamList := nil;
  end
  else
  begin
    if FCareTeamList = nil then
      FCareTeamList := TFhirReferenceList.Create;
    FCareTeamList.Assign(TFhirCarePlan(oSource).FCareTeamList);
  end;
  if (TFhirCarePlan(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirReferenceList.Create;
    FAddressesList.Assign(TFhirCarePlan(oSource).FAddressesList);
  end;
  if (TFhirCarePlan(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirCarePlan(oSource).FSupportingInfoList);
  end;
  if (TFhirCarePlan(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirReferenceList.Create;
    FGoalList.Assign(TFhirCarePlan(oSource).FGoalList);
  end;
  if (TFhirCarePlan(oSource).FActivityList = nil) then
  begin
    FActivityList.free;
    FActivityList := nil;
  end
  else
  begin
    if FActivityList = nil then
      FActivityList := TFhirCarePlanActivityList.Create;
    FActivityList.Assign(TFhirCarePlan(oSource).FActivityList);
  end;
  if (TFhirCarePlan(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCarePlan(oSource).FNoteList);
  end;
end;

function TFhirCarePlan.GetResourceType : TFhirResourceType;
begin
  result := frtCarePlan;
end;

procedure TFhirCarePlan.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'contributor') Then
    list.addAll(self, 'contributor', FContributorList);
  if (child_name = 'careTeam') Then
    list.addAll(self, 'careTeam', FCareTeamList);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'activity') Then
    list.addAll(self, 'activity', FActivityList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCarePlan.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference', true, TFhirReference, FReplacesList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'contributor', 'Reference', true, TFhirReference, FContributorList.Link));
  oList.add(TFHIRProperty.create(self, 'careTeam', 'Reference', true, TFhirReference, FCareTeamList.Link));
  oList.add(TFHIRProperty.create(self, 'addresses', 'Reference', true, TFhirReference, FAddressesList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'goal', 'Reference', true, TFhirReference, FGoalList.Link));
  oList.add(TFHIRProperty.create(self, 'activity', 'BackboneElement', true, TFhirCarePlanActivity, FActivityList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirCarePlan.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirCarePlanIntentEnum, CODES_TFhirCarePlanIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contributor') then
  begin
    ContributorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'careTeam') then
  begin
    CareTeamList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    ActivityList.add(propValue as TFhirCarePlanActivity);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCarePlan.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'contributor') then ContributorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'careTeam') then CareTeamList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'activity') then ActivityList.insertItem(index, propValue as TFhirCarePlanActivity)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirCarePlan.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'replaces') then result := ReplacesList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull]) 
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirCarePlanIntentEnum[CarePlanIntentNull], CODES_TFhirCarePlanIntentEnum[CarePlanIntentNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'contributor') then result := ContributorList.new()
  else if (propName = 'careTeam') then result := CareTeamList.new()
  else if (propName = 'addresses') then result := AddressesList.new()
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new()
  else if (propName = 'goal') then result := GoalList.new()
  else if (propName = 'activity') then result := ActivityList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCarePlan.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'contributor') then result := 'Reference'
  else if (propName = 'careTeam') then result := 'Reference'
  else if (propName = 'addresses') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'goal') then result := 'Reference'
  else if (propName = 'activity') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCarePlan.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'contributor') then deletePropertyValue('contributor', ContributorList, value)
  else if (propName = 'careTeam') then deletePropertyValue('careTeam', CareTeamList, value)
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value)
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value)
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value)
  else if (propName = 'activity') then deletePropertyValue('activity', ActivityList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCarePlan.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new)
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirCarePlanIntentEnum, CODES_TFhirCarePlanIntentEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'contributor') then replacePropertyValue('contributor', ContributorList, existing, new)
  else if (propName = 'careTeam') then replacePropertyValue('careTeam', CareTeamList, existing, new)
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new)
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new)
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new)
  else if (propName = 'activity') then replacePropertyValue('activity', ActivityList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCarePlan.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'replaces') then ReplacesList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'contributor') then ContributorList.move(source, destination)
  else if (propName = 'careTeam') then CareTeamList.move(source, destination)
  else if (propName = 'addresses') then AddressesList.move(source, destination)
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination)
  else if (propName = 'goal') then GoalList.move(source, destination)
  else if (propName = 'activity') then ActivityList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCarePlan.fhirType : string;
begin
  result := 'CarePlan';
end;

function TFhirCarePlan.Link : TFhirCarePlan;
begin
  result := TFhirCarePlan(inherited Link);
end;

function TFhirCarePlan.Clone : TFhirCarePlan;
begin
  result := TFhirCarePlan(inherited Clone);
end;

function TFhirCarePlan.equals(other : TObject) : boolean; 
var
  o : TFhirCarePlan;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCarePlan)) then
    result := false
  else
  begin
    o := TFhirCarePlan(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(contributorList, o.contributorList, true) and compareDeep(careTeamList, o.careTeamList, true) and 
      compareDeep(addressesList, o.addressesList, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(goalList, o.goalList, true) and compareDeep(activityList, o.activityList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCarePlan.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FcategoryList) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FPeriod) and isEmptyProp(FCreated) and isEmptyProp(FAuthor) and isEmptyProp(FcontributorList) and isEmptyProp(FcareTeamList) and isEmptyProp(FaddressesList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FgoalList) and isEmptyProp(FactivityList) and isEmptyProp(FnoteList);
end;

procedure TFhirCarePlan.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('partOf');
  fields.add('status');
  fields.add('intent');
  fields.add('category');
  fields.add('title');
  fields.add('description');
  fields.add('subject');
  fields.add('encounter');
  fields.add('period');
  fields.add('created');
  fields.add('author');
  fields.add('contributor');
  fields.add('careTeam');
  fields.add('addresses');
  fields.add('supportingInfo');
  fields.add('goal');
  fields.add('activity');
  fields.add('note');
end;

function TFhirCarePlan.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FReplacesList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FContributorList.sizeInBytes(magic));
  inc(result, FCareTeamList.sizeInBytes(magic));
  inc(result, FAddressesList.sizeInBytes(magic));
  inc(result, FSupportingInfoList.sizeInBytes(magic));
  inc(result, FGoalList.sizeInBytes(magic));
  inc(result, FActivityList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirCarePlan.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCarePlan.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCarePlan.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirCarePlan.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirCarePlan.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirCarePlan.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirCarePlan.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirCarePlan.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirCarePlan.GetReplacesList : TFhirReferenceList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList.Create;
  result := FReplacesList;
end;

function TFhirCarePlan.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

function TFhirCarePlan.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirCarePlan.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirCarePlan.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCarePlan.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirCarePlan.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirCarePlan.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirCarePlan.GetIntentST : TFhirCarePlanIntentEnum;
begin
  if FIntent = nil then
    result := TFhirCarePlanIntentEnum(0)
  else
    result := TFhirCarePlanIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirCarePlanIntentEnum, FIntent.value));
end;

procedure TFhirCarePlan.SetIntentST(value : TFhirCarePlanIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirCarePlanIntentEnum[value], CODES_TFhirCarePlanIntentEnum[value]);
end;

function TFhirCarePlan.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCarePlan.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCarePlan.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirCarePlan.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCarePlan.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCarePlan.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirCarePlan.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirCarePlan.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirCarePlan.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirCarePlan.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirCarePlan.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirCarePlan.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirCarePlan.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirCarePlan.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirCarePlan.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirCarePlan.GetContributorList : TFhirReferenceList;
begin
  if FContributorList = nil then
    FContributorList := TFhirReferenceList.Create;
  result := FContributorList;
end;

function TFhirCarePlan.GetHasContributorList : boolean;
begin
  result := (FContributorList <> nil) and (FContributorList.count > 0);
end;

function TFhirCarePlan.GetCareTeamList : TFhirReferenceList;
begin
  if FCareTeamList = nil then
    FCareTeamList := TFhirReferenceList.Create;
  result := FCareTeamList;
end;

function TFhirCarePlan.GetHasCareTeamList : boolean;
begin
  result := (FCareTeamList <> nil) and (FCareTeamList.count > 0);
end;

function TFhirCarePlan.GetAddressesList : TFhirReferenceList;
begin
  if FAddressesList = nil then
    FAddressesList := TFhirReferenceList.Create;
  result := FAddressesList;
end;

function TFhirCarePlan.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

function TFhirCarePlan.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirCarePlan.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirCarePlan.GetGoalList : TFhirReferenceList;
begin
  if FGoalList = nil then
    FGoalList := TFhirReferenceList.Create;
  result := FGoalList;
end;

function TFhirCarePlan.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

function TFhirCarePlan.GetActivityList : TFhirCarePlanActivityList;
begin
  if FActivityList = nil then
    FActivityList := TFhirCarePlanActivityList.Create;
  result := FActivityList;
end;

function TFhirCarePlan.GetHasActivityList : boolean;
begin
  result := (FActivityList <> nil) and (FActivityList.count > 0);
end;

function TFhirCarePlan.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCarePlan.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirCarePlanListEnumerator }

constructor TFhirCarePlanListEnumerator.Create(list : TFhirCarePlanList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCarePlanListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCarePlanListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCarePlanListEnumerator.GetCurrent : TFhirCarePlan;
begin
  Result := FList[FIndex];
end;

function TFhirCarePlanListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCarePlanList }

function TFhirCarePlanList.AddItem(value: TFhirCarePlan): TFhirCarePlan;
begin
  assert(value.ClassName = 'TFhirCarePlan', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCarePlan');
  add(value);
  result := value;
end;

function TFhirCarePlanList.Append: TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanList.ClearItems;
begin
  Clear;
end;

function TFhirCarePlanList.GetEnumerator : TFhirCarePlanListEnumerator;
begin
  result := TFhirCarePlanListEnumerator.Create(self.link);
end;

function TFhirCarePlanList.Clone: TFhirCarePlanList;
begin
  result := TFhirCarePlanList(inherited Clone);
end;

function TFhirCarePlanList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCarePlanList.GetItemN(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan(ObjectByIndex[index]);
end;

function TFhirCarePlanList.ItemClass: TFslObjectClass;
begin
  result := TFhirCarePlan;
end;
function TFhirCarePlanList.IndexOf(value: TFhirCarePlan): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCarePlanList.Insert(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCarePlanList.InsertItem(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  Inherited Insert(index, value);
end;

function TFhirCarePlanList.Item(index: Integer): TFhirCarePlan;
begin
  result := TFhirCarePlan(ObjectByIndex[index]);
end;

function TFhirCarePlanList.Link: TFhirCarePlanList;
begin
  result := TFhirCarePlanList(inherited Link);
end;

procedure TFhirCarePlanList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCarePlanList.SetItemByIndex(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  FhirCarePlans[index] := value;
end;

procedure TFhirCarePlanList.SetItemN(index: Integer; value: TFhirCarePlan);
begin
  assert(value is TFhirCarePlan);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CAREPLAN}
{$IFDEF FHIR_CARETEAM}
{ TFhirCareTeamParticipant }

constructor TFhirCareTeamParticipant.Create;
begin
  inherited;
end;

destructor TFhirCareTeamParticipant.Destroy;
begin
  FRoleList.Free;
  FMember.free;
  FOnBehalfOf.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirCareTeamParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCareTeamParticipant(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirCareTeamParticipant(oSource).FRoleList);
  end;
  member := TFhirCareTeamParticipant(oSource).member.Clone;
  onBehalfOf := TFhirCareTeamParticipant(oSource).onBehalfOf.Clone;
  period := TFhirCareTeamParticipant(oSource).period.Clone;
end;

procedure TFhirCareTeamParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'member') Then
     list.add(self.link, 'member', FMember.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirCareTeamParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link));
  oList.add(TFHIRProperty.create(self, 'member', 'Reference', false, TFhirReference, FMember.Link));
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference', false, TFhirReference, FOnBehalfOf.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirCareTeamParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'member') then
  begin
    Member := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCareTeamParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirCareTeamParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := RoleList.new()
  else if (propName = 'member') then result := TFhirReference.create()
  else if (propName = 'onBehalfOf') then result := TFhirReference.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCareTeamParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'member') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCareTeamParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then deletePropertyValue('role', RoleList, value)
  else if (propName = 'member') then MemberElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCareTeamParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new)
  else if (propName = 'member') then MemberElement := new as TFhirReference
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCareTeamParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCareTeamParticipant.fhirType : string;
begin
  result := 'CareTeam.participant';
end;

function TFhirCareTeamParticipant.Link : TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(inherited Link);
end;

function TFhirCareTeamParticipant.Clone : TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(inherited Clone);
end;

function TFhirCareTeamParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirCareTeamParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCareTeamParticipant)) then
    result := false
  else
  begin
    o := TFhirCareTeamParticipant(other);
    result := compareDeep(roleList, o.roleList, true) and compareDeep(memberElement, o.memberElement, true) and 
      compareDeep(onBehalfOfElement, o.onBehalfOfElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirCareTeamParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FroleList) and isEmptyProp(FMember) and isEmptyProp(FOnBehalfOf) and isEmptyProp(FPeriod);
end;

procedure TFhirCareTeamParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('member');
  fields.add('onBehalfOf');
  fields.add('period');
end;

function TFhirCareTeamParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRoleList.sizeInBytes(magic));
end;

function TFhirCareTeamParticipant.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

function TFhirCareTeamParticipant.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

procedure TFhirCareTeamParticipant.SetMember(value : TFhirReference);
begin
  FMember.free;
  FMember := value;
end;

procedure TFhirCareTeamParticipant.SetOnBehalfOf(value : TFhirReference);
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

procedure TFhirCareTeamParticipant.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirCareTeamParticipantListEnumerator }

constructor TFhirCareTeamParticipantListEnumerator.Create(list : TFhirCareTeamParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCareTeamParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCareTeamParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCareTeamParticipantListEnumerator.GetCurrent : TFhirCareTeamParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirCareTeamParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCareTeamParticipantList }

function TFhirCareTeamParticipantList.AddItem(value: TFhirCareTeamParticipant): TFhirCareTeamParticipant;
begin
  assert(value.ClassName = 'TFhirCareTeamParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCareTeamParticipant');
  add(value);
  result := value;
end;

function TFhirCareTeamParticipantList.Append: TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirCareTeamParticipantList.GetEnumerator : TFhirCareTeamParticipantListEnumerator;
begin
  result := TFhirCareTeamParticipantListEnumerator.Create(self.link);
end;

function TFhirCareTeamParticipantList.Clone: TFhirCareTeamParticipantList;
begin
  result := TFhirCareTeamParticipantList(inherited Clone);
end;

function TFhirCareTeamParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCareTeamParticipantList.GetItemN(index: Integer): TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(ObjectByIndex[index]);
end;

function TFhirCareTeamParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirCareTeamParticipant;
end;
function TFhirCareTeamParticipantList.IndexOf(value: TFhirCareTeamParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCareTeamParticipantList.Insert(index: Integer): TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamParticipantList.InsertItem(index: Integer; value: TFhirCareTeamParticipant);
begin
  assert(value is TFhirCareTeamParticipant);
  Inherited Insert(index, value);
end;

function TFhirCareTeamParticipantList.Item(index: Integer): TFhirCareTeamParticipant;
begin
  result := TFhirCareTeamParticipant(ObjectByIndex[index]);
end;

function TFhirCareTeamParticipantList.Link: TFhirCareTeamParticipantList;
begin
  result := TFhirCareTeamParticipantList(inherited Link);
end;

procedure TFhirCareTeamParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCareTeamParticipantList.SetItemByIndex(index: Integer; value: TFhirCareTeamParticipant);
begin
  assert(value is TFhirCareTeamParticipant);
  FhirCareTeamParticipants[index] := value;
end;

procedure TFhirCareTeamParticipantList.SetItemN(index: Integer; value: TFhirCareTeamParticipant);
begin
  assert(value is TFhirCareTeamParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirCareTeam }

constructor TFhirCareTeam.Create;
begin
  inherited;
end;

destructor TFhirCareTeam.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FName.free;
  FSubject.free;
  FEncounter.free;
  FPeriod.free;
  FParticipantList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FManagingOrganizationList.Free;
  FTelecomList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCareTeam.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCareTeam(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCareTeam(oSource).FIdentifierList);
  end;
  statusElement := TFhirCareTeam(oSource).statusElement.Clone;
  if (TFhirCareTeam(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCareTeam(oSource).FCategoryList);
  end;
  nameElement := TFhirCareTeam(oSource).nameElement.Clone;
  subject := TFhirCareTeam(oSource).subject.Clone;
  encounter := TFhirCareTeam(oSource).encounter.Clone;
  period := TFhirCareTeam(oSource).period.Clone;
  if (TFhirCareTeam(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirCareTeamParticipantList.Create;
    FParticipantList.Assign(TFhirCareTeam(oSource).FParticipantList);
  end;
  if (TFhirCareTeam(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirCareTeam(oSource).FReasonCodeList);
  end;
  if (TFhirCareTeam(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirCareTeam(oSource).FReasonReferenceList);
  end;
  if (TFhirCareTeam(oSource).FManagingOrganizationList = nil) then
  begin
    FManagingOrganizationList.free;
    FManagingOrganizationList := nil;
  end
  else
  begin
    if FManagingOrganizationList = nil then
      FManagingOrganizationList := TFhirReferenceList.Create;
    FManagingOrganizationList.Assign(TFhirCareTeam(oSource).FManagingOrganizationList);
  end;
  if (TFhirCareTeam(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirCareTeam(oSource).FTelecomList);
  end;
  if (TFhirCareTeam(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCareTeam(oSource).FNoteList);
  end;
end;

function TFhirCareTeam.GetResourceType : TFhirResourceType;
begin
  result := frtCareTeam;
end;

procedure TFhirCareTeam.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'managingOrganization') Then
    list.addAll(self, 'managingOrganization', FManagingOrganizationList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCareTeam.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirCareTeamParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', true, TFhirReference, FManagingOrganizationList.Link));
  oList.add(TFHIRProperty.create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirCareTeam.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCareTeamStatusEnum, CODES_TFhirCareTeamStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirCareTeamParticipant);
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganizationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCareTeam.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirCareTeamParticipant)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'managingOrganization') then ManagingOrganizationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirCareTeam.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirCareTeamStatusEnum[CareTeamStatusNull], CODES_TFhirCareTeamStatusEnum[CareTeamStatusNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'managingOrganization') then result := ManagingOrganizationList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCareTeam.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCareTeam.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'managingOrganization') then deletePropertyValue('managingOrganization', ManagingOrganizationList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCareTeam.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCareTeamStatusEnum, CODES_TFhirCareTeamStatusEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'managingOrganization') then replacePropertyValue('managingOrganization', ManagingOrganizationList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCareTeam.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'managingOrganization') then ManagingOrganizationList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCareTeam.fhirType : string;
begin
  result := 'CareTeam';
end;

function TFhirCareTeam.Link : TFhirCareTeam;
begin
  result := TFhirCareTeam(inherited Link);
end;

function TFhirCareTeam.Clone : TFhirCareTeam;
begin
  result := TFhirCareTeam(inherited Clone);
end;

function TFhirCareTeam.equals(other : TObject) : boolean; 
var
  o : TFhirCareTeam;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCareTeam)) then
    result := false
  else
  begin
    o := TFhirCareTeam(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(managingOrganizationList, o.managingOrganizationList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCareTeam.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FName) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FPeriod) and isEmptyProp(FparticipantList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FmanagingOrganizationList) and isEmptyProp(FtelecomList) and isEmptyProp(FnoteList);
end;

procedure TFhirCareTeam.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('name');
  fields.add('subject');
  fields.add('encounter');
  fields.add('period');
  fields.add('participant');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('managingOrganization');
  fields.add('telecom');
  fields.add('note');
end;

function TFhirCareTeam.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FManagingOrganizationList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirCareTeam.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCareTeam.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCareTeam.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCareTeam.GetStatusST : TFhirCareTeamStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCareTeamStatusEnum(0)
  else
    result := TFhirCareTeamStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCareTeamStatusEnum, FStatus.value));
end;

procedure TFhirCareTeam.SetStatusST(value : TFhirCareTeamStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCareTeamStatusEnum[value], CODES_TFhirCareTeamStatusEnum[value]);
end;

function TFhirCareTeam.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCareTeam.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCareTeam.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirCareTeam.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirCareTeam.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirCareTeam.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirCareTeam.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirCareTeam.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirCareTeam.GetParticipantList : TFhirCareTeamParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirCareTeamParticipantList.Create;
  result := FParticipantList;
end;

function TFhirCareTeam.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

function TFhirCareTeam.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirCareTeam.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirCareTeam.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirCareTeam.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirCareTeam.GetManagingOrganizationList : TFhirReferenceList;
begin
  if FManagingOrganizationList = nil then
    FManagingOrganizationList := TFhirReferenceList.Create;
  result := FManagingOrganizationList;
end;

function TFhirCareTeam.GetHasManagingOrganizationList : boolean;
begin
  result := (FManagingOrganizationList <> nil) and (FManagingOrganizationList.count > 0);
end;

function TFhirCareTeam.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirCareTeam.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirCareTeam.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCareTeam.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirCareTeamListEnumerator }

constructor TFhirCareTeamListEnumerator.Create(list : TFhirCareTeamList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCareTeamListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCareTeamListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCareTeamListEnumerator.GetCurrent : TFhirCareTeam;
begin
  Result := FList[FIndex];
end;

function TFhirCareTeamListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCareTeamList }

function TFhirCareTeamList.AddItem(value: TFhirCareTeam): TFhirCareTeam;
begin
  assert(value.ClassName = 'TFhirCareTeam', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCareTeam');
  add(value);
  result := value;
end;

function TFhirCareTeamList.Append: TFhirCareTeam;
begin
  result := TFhirCareTeam.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamList.ClearItems;
begin
  Clear;
end;

function TFhirCareTeamList.GetEnumerator : TFhirCareTeamListEnumerator;
begin
  result := TFhirCareTeamListEnumerator.Create(self.link);
end;

function TFhirCareTeamList.Clone: TFhirCareTeamList;
begin
  result := TFhirCareTeamList(inherited Clone);
end;

function TFhirCareTeamList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCareTeamList.GetItemN(index: Integer): TFhirCareTeam;
begin
  result := TFhirCareTeam(ObjectByIndex[index]);
end;

function TFhirCareTeamList.ItemClass: TFslObjectClass;
begin
  result := TFhirCareTeam;
end;
function TFhirCareTeamList.IndexOf(value: TFhirCareTeam): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCareTeamList.Insert(index: Integer): TFhirCareTeam;
begin
  result := TFhirCareTeam.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCareTeamList.InsertItem(index: Integer; value: TFhirCareTeam);
begin
  assert(value is TFhirCareTeam);
  Inherited Insert(index, value);
end;

function TFhirCareTeamList.Item(index: Integer): TFhirCareTeam;
begin
  result := TFhirCareTeam(ObjectByIndex[index]);
end;

function TFhirCareTeamList.Link: TFhirCareTeamList;
begin
  result := TFhirCareTeamList(inherited Link);
end;

procedure TFhirCareTeamList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCareTeamList.SetItemByIndex(index: Integer; value: TFhirCareTeam);
begin
  assert(value is TFhirCareTeam);
  FhirCareTeams[index] := value;
end;

procedure TFhirCareTeamList.SetItemN(index: Integer; value: TFhirCareTeam);
begin
  assert(value is TFhirCareTeam);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CARETEAM}
{$IFDEF FHIR_CLINICALIMPRESSION}
{ TFhirClinicalImpressionInvestigation }

constructor TFhirClinicalImpressionInvestigation.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpressionInvestigation.Destroy;
begin
  FCode.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirClinicalImpressionInvestigation.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirClinicalImpressionInvestigation(oSource).code.Clone;
  if (TFhirClinicalImpressionInvestigation(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirReferenceList.Create;
    FItemList.Assign(TFhirClinicalImpressionInvestigation(oSource).FItemList);
  end;
end;

procedure TFhirClinicalImpressionInvestigation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirClinicalImpressionInvestigation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'Reference', true, TFhirReference, FItemList.Link));
end;

function TFhirClinicalImpressionInvestigation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpressionInvestigation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirClinicalImpressionInvestigation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpressionInvestigation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpressionInvestigation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpressionInvestigation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpressionInvestigation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpressionInvestigation.fhirType : string;
begin
  result := 'ClinicalImpression.investigation';
end;

function TFhirClinicalImpressionInvestigation.Link : TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation(inherited Link);
end;

function TFhirClinicalImpressionInvestigation.Clone : TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation(inherited Clone);
end;

function TFhirClinicalImpressionInvestigation.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalImpressionInvestigation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpressionInvestigation)) then
    result := false
  else
  begin
    o := TFhirClinicalImpressionInvestigation(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirClinicalImpressionInvestigation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FitemList);
end;

procedure TFhirClinicalImpressionInvestigation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('item');
end;

function TFhirClinicalImpressionInvestigation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirClinicalImpressionInvestigation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirClinicalImpressionInvestigation.GetItemList : TFhirReferenceList;
begin
  if FItemList = nil then
    FItemList := TFhirReferenceList.Create;
  result := FItemList;
end;

function TFhirClinicalImpressionInvestigation.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirClinicalImpressionInvestigationListEnumerator }

constructor TFhirClinicalImpressionInvestigationListEnumerator.Create(list : TFhirClinicalImpressionInvestigationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionInvestigationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionInvestigationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionInvestigationListEnumerator.GetCurrent : TFhirClinicalImpressionInvestigation;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionInvestigationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalImpressionInvestigationList }

function TFhirClinicalImpressionInvestigationList.AddItem(value: TFhirClinicalImpressionInvestigation): TFhirClinicalImpressionInvestigation;
begin
  assert(value.ClassName = 'TFhirClinicalImpressionInvestigation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpressionInvestigation');
  add(value);
  result := value;
end;

function TFhirClinicalImpressionInvestigationList.Append: TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionInvestigationList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionInvestigationList.GetEnumerator : TFhirClinicalImpressionInvestigationListEnumerator;
begin
  result := TFhirClinicalImpressionInvestigationListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionInvestigationList.Clone: TFhirClinicalImpressionInvestigationList;
begin
  result := TFhirClinicalImpressionInvestigationList(inherited Clone);
end;

function TFhirClinicalImpressionInvestigationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionInvestigationList.GetItemN(index: Integer): TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionInvestigationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpressionInvestigation;
end;
function TFhirClinicalImpressionInvestigationList.IndexOf(value: TFhirClinicalImpressionInvestigation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionInvestigationList.Insert(index: Integer): TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionInvestigationList.InsertItem(index: Integer; value: TFhirClinicalImpressionInvestigation);
begin
  assert(value is TFhirClinicalImpressionInvestigation);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionInvestigationList.Item(index: Integer): TFhirClinicalImpressionInvestigation;
begin
  result := TFhirClinicalImpressionInvestigation(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionInvestigationList.Link: TFhirClinicalImpressionInvestigationList;
begin
  result := TFhirClinicalImpressionInvestigationList(inherited Link);
end;

procedure TFhirClinicalImpressionInvestigationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionInvestigationList.SetItemByIndex(index: Integer; value: TFhirClinicalImpressionInvestigation);
begin
  assert(value is TFhirClinicalImpressionInvestigation);
  FhirClinicalImpressionInvestigations[index] := value;
end;

procedure TFhirClinicalImpressionInvestigationList.SetItemN(index: Integer; value: TFhirClinicalImpressionInvestigation);
begin
  assert(value is TFhirClinicalImpressionInvestigation);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalImpressionFinding }

constructor TFhirClinicalImpressionFinding.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpressionFinding.Destroy;
begin
  FItemCodeableConcept.free;
  FItemReference.free;
  FBasis.free;
  inherited;
end;

procedure TFhirClinicalImpressionFinding.Assign(oSource : TFslObject);
begin
  inherited;
  itemCodeableConcept := TFhirClinicalImpressionFinding(oSource).itemCodeableConcept.Clone;
  itemReference := TFhirClinicalImpressionFinding(oSource).itemReference.Clone;
  basisElement := TFhirClinicalImpressionFinding(oSource).basisElement.Clone;
end;

procedure TFhirClinicalImpressionFinding.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'itemCodeableConcept') Then
     list.add(self.link, 'itemCodeableConcept', FItemCodeableConcept.Link);
  if (child_name = 'itemReference') Then
     list.add(self.link, 'itemReference', FItemReference.Link);
  if (child_name = 'basis') Then
     list.add(self.link, 'basis', FBasis.Link);
end;

procedure TFhirClinicalImpressionFinding.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'itemCodeableConcept', 'CodeableConcept', false, TFhirCodeableConcept, FItemCodeableConcept.Link));
  oList.add(TFHIRProperty.create(self, 'itemReference', 'Reference', false, TFhirReference, FItemReference.Link));
  oList.add(TFHIRProperty.create(self, 'basis', 'string', false, TFhirString, FBasis.Link));
end;

function TFhirClinicalImpressionFinding.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'itemCodeableConcept') then
  begin
    ItemCodeableConcept := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'itemReference') then
  begin
    ItemReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpressionFinding.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalImpressionFinding.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'itemCodeableConcept') then result := TFhirCodeableConcept.create()
  else if (propName = 'itemReference') then result := TFhirReference.create()
  else if (propName = 'basis') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpressionFinding.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'itemCodeableConcept') then result := 'CodeableConcept'
  else if (propName = 'itemReference') then result := 'Reference'
  else if (propName = 'basis') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpressionFinding.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'itemCodeableConcept') then ItemCodeableConceptElement := nil
  else if (propName = 'itemReference') then ItemReferenceElement := nil
  else if (propName = 'basis') then BasisElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpressionFinding.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'itemCodeableConcept') then ItemCodeableConceptElement := new as TFhirCodeableConcept
  else if (propName = 'itemReference') then ItemReferenceElement := new as TFhirReference
  else if (propName = 'basis') then BasisElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpressionFinding.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpressionFinding.fhirType : string;
begin
  result := 'ClinicalImpression.finding';
end;

function TFhirClinicalImpressionFinding.Link : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(inherited Link);
end;

function TFhirClinicalImpressionFinding.Clone : TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(inherited Clone);
end;

function TFhirClinicalImpressionFinding.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalImpressionFinding;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpressionFinding)) then
    result := false
  else
  begin
    o := TFhirClinicalImpressionFinding(other);
    result := compareDeep(itemCodeableConceptElement, o.itemCodeableConceptElement, true) and 
      compareDeep(itemReferenceElement, o.itemReferenceElement, true) and compareDeep(basisElement, o.basisElement, true);
  end;
end;

function TFhirClinicalImpressionFinding.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItemCodeableConcept) and isEmptyProp(FItemReference) and isEmptyProp(FBasis);
end;

procedure TFhirClinicalImpressionFinding.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('itemCodeableConcept');
  fields.add('itemReference');
  fields.add('basis');
end;

function TFhirClinicalImpressionFinding.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClinicalImpressionFinding.SetItemCodeableConcept(value : TFhirCodeableConcept);
begin
  FItemCodeableConcept.free;
  FItemCodeableConcept := value;
end;

procedure TFhirClinicalImpressionFinding.SetItemReference(value : TFhirReference);
begin
  FItemReference.free;
  FItemReference := value;
end;

procedure TFhirClinicalImpressionFinding.SetBasis(value : TFhirString);
begin
  FBasis.free;
  FBasis := value;
end;

function TFhirClinicalImpressionFinding.GetBasisST : String;
begin
  if FBasis = nil then
    result := ''
  else
    result := FBasis.value;
end;

procedure TFhirClinicalImpressionFinding.SetBasisST(value : String);
begin
  if value <> '' then
  begin
    if FBasis = nil then
      FBasis := TFhirString.create;
    FBasis.value := value
  end
  else if FBasis <> nil then
    FBasis.value := '';
end;

{ TFhirClinicalImpressionFindingListEnumerator }

constructor TFhirClinicalImpressionFindingListEnumerator.Create(list : TFhirClinicalImpressionFindingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionFindingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionFindingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionFindingListEnumerator.GetCurrent : TFhirClinicalImpressionFinding;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionFindingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalImpressionFindingList }

function TFhirClinicalImpressionFindingList.AddItem(value: TFhirClinicalImpressionFinding): TFhirClinicalImpressionFinding;
begin
  assert(value.ClassName = 'TFhirClinicalImpressionFinding', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpressionFinding');
  add(value);
  result := value;
end;

function TFhirClinicalImpressionFindingList.Append: TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionFindingList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionFindingList.GetEnumerator : TFhirClinicalImpressionFindingListEnumerator;
begin
  result := TFhirClinicalImpressionFindingListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionFindingList.Clone: TFhirClinicalImpressionFindingList;
begin
  result := TFhirClinicalImpressionFindingList(inherited Clone);
end;

function TFhirClinicalImpressionFindingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionFindingList.GetItemN(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionFindingList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpressionFinding;
end;
function TFhirClinicalImpressionFindingList.IndexOf(value: TFhirClinicalImpressionFinding): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionFindingList.Insert(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionFindingList.InsertItem(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionFindingList.Item(index: Integer): TFhirClinicalImpressionFinding;
begin
  result := TFhirClinicalImpressionFinding(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionFindingList.Link: TFhirClinicalImpressionFindingList;
begin
  result := TFhirClinicalImpressionFindingList(inherited Link);
end;

procedure TFhirClinicalImpressionFindingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionFindingList.SetItemByIndex(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  FhirClinicalImpressionFindings[index] := value;
end;

procedure TFhirClinicalImpressionFindingList.SetItemN(index: Integer; value: TFhirClinicalImpressionFinding);
begin
  assert(value is TFhirClinicalImpressionFinding);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalImpression }

constructor TFhirClinicalImpression.Create;
begin
  inherited;
end;

destructor TFhirClinicalImpression.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FStatusReason.free;
  FCode.free;
  FDescription.free;
  FSubject.free;
  FEncounter.free;
  FEffective.free;
  FDate.free;
  FAssessor.free;
  FPrevious.free;
  FProblemList.Free;
  FInvestigationList.Free;
  FProtocolList.Free;
  FSummary.free;
  FFindingList.Free;
  FPrognosisCodeableConceptList.Free;
  FPrognosisReferenceList.Free;
  FSupportingInfoList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirClinicalImpression.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClinicalImpression(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClinicalImpression(oSource).FIdentifierList);
  end;
  statusElement := TFhirClinicalImpression(oSource).statusElement.Clone;
  statusReason := TFhirClinicalImpression(oSource).statusReason.Clone;
  code := TFhirClinicalImpression(oSource).code.Clone;
  descriptionElement := TFhirClinicalImpression(oSource).descriptionElement.Clone;
  subject := TFhirClinicalImpression(oSource).subject.Clone;
  encounter := TFhirClinicalImpression(oSource).encounter.Clone;
  effective := TFhirClinicalImpression(oSource).effective.Clone;
  dateElement := TFhirClinicalImpression(oSource).dateElement.Clone;
  assessor := TFhirClinicalImpression(oSource).assessor.Clone;
  previous := TFhirClinicalImpression(oSource).previous.Clone;
  if (TFhirClinicalImpression(oSource).FProblemList = nil) then
  begin
    FProblemList.free;
    FProblemList := nil;
  end
  else
  begin
    if FProblemList = nil then
      FProblemList := TFhirReferenceList.Create;
    FProblemList.Assign(TFhirClinicalImpression(oSource).FProblemList);
  end;
  if (TFhirClinicalImpression(oSource).FInvestigationList = nil) then
  begin
    FInvestigationList.free;
    FInvestigationList := nil;
  end
  else
  begin
    if FInvestigationList = nil then
      FInvestigationList := TFhirClinicalImpressionInvestigationList.Create;
    FInvestigationList.Assign(TFhirClinicalImpression(oSource).FInvestigationList);
  end;
  if (TFhirClinicalImpression(oSource).FProtocolList = nil) then
  begin
    FProtocolList.free;
    FProtocolList := nil;
  end
  else
  begin
    if FProtocolList = nil then
      FProtocolList := TFhirUriList.Create;
    FProtocolList.Assign(TFhirClinicalImpression(oSource).FProtocolList);
  end;
  summaryElement := TFhirClinicalImpression(oSource).summaryElement.Clone;
  if (TFhirClinicalImpression(oSource).FFindingList = nil) then
  begin
    FFindingList.free;
    FFindingList := nil;
  end
  else
  begin
    if FFindingList = nil then
      FFindingList := TFhirClinicalImpressionFindingList.Create;
    FFindingList.Assign(TFhirClinicalImpression(oSource).FFindingList);
  end;
  if (TFhirClinicalImpression(oSource).FPrognosisCodeableConceptList = nil) then
  begin
    FPrognosisCodeableConceptList.free;
    FPrognosisCodeableConceptList := nil;
  end
  else
  begin
    if FPrognosisCodeableConceptList = nil then
      FPrognosisCodeableConceptList := TFhirCodeableConceptList.Create;
    FPrognosisCodeableConceptList.Assign(TFhirClinicalImpression(oSource).FPrognosisCodeableConceptList);
  end;
  if (TFhirClinicalImpression(oSource).FPrognosisReferenceList = nil) then
  begin
    FPrognosisReferenceList.free;
    FPrognosisReferenceList := nil;
  end
  else
  begin
    if FPrognosisReferenceList = nil then
      FPrognosisReferenceList := TFhirReferenceList.Create;
    FPrognosisReferenceList.Assign(TFhirClinicalImpression(oSource).FPrognosisReferenceList);
  end;
  if (TFhirClinicalImpression(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirClinicalImpression(oSource).FSupportingInfoList);
  end;
  if (TFhirClinicalImpression(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirClinicalImpression(oSource).FNoteList);
  end;
end;

function TFhirClinicalImpression.GetResourceType : TFhirResourceType;
begin
  result := frtClinicalImpression;
end;

procedure TFhirClinicalImpression.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'assessor') Then
     list.add(self.link, 'assessor', FAssessor.Link);
  if (child_name = 'previous') Then
     list.add(self.link, 'previous', FPrevious.Link);
  if (child_name = 'problem') Then
    list.addAll(self, 'problem', FProblemList);
  if (child_name = 'investigation') Then
    list.addAll(self, 'investigation', FInvestigationList);
  if (child_name = 'protocol') Then
    list.addAll(self, 'protocol', FProtocolList);
  if (child_name = 'summary') Then
     list.add(self.link, 'summary', FSummary.Link);
  if (child_name = 'finding') Then
    list.addAll(self, 'finding', FFindingList);
  if (child_name = 'prognosisCodeableConcept') Then
    list.addAll(self, 'prognosisCodeableConcept', FPrognosisCodeableConceptList);
  if (child_name = 'prognosisReference') Then
    list.addAll(self, 'prognosisReference', FPrognosisReferenceList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirClinicalImpression.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirDataType, FEffective.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'assessor', 'Reference', false, TFhirReference, FAssessor.Link));
  oList.add(TFHIRProperty.create(self, 'previous', 'Reference', false, TFhirReference, FPrevious.Link));
  oList.add(TFHIRProperty.create(self, 'problem', 'Reference', true, TFhirReference, FProblemList.Link));
  oList.add(TFHIRProperty.create(self, 'investigation', 'BackboneElement', true, TFhirClinicalImpressionInvestigation, FInvestigationList.Link));
  oList.add(TFHIRProperty.create(self, 'protocol', 'uri', true, TFhirUri, FProtocolList.Link));
  oList.add(TFHIRProperty.create(self, 'summary', 'string', false, TFhirString, FSummary.Link));
  oList.add(TFHIRProperty.create(self, 'finding', 'BackboneElement', true, TFhirClinicalImpressionFinding, FFindingList.Link));
  oList.add(TFHIRProperty.create(self, 'prognosisCodeableConcept', 'CodeableConcept', true, TFhirCodeableConcept, FPrognosisCodeableConceptList.Link));
  oList.add(TFHIRProperty.create(self, 'prognosisReference', 'Reference', true, TFhirReference, FPrognosisReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirClinicalImpression.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirClinicalImpressionStatusEnum, CODES_TFhirClinicalImpressionStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'assessor') then
  begin
    Assessor := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'previous') then
  begin
    Previous := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'problem') then
  begin
    ProblemList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'investigation') then
  begin
    InvestigationList.add(propValue as TFhirClinicalImpressionInvestigation);
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    ProtocolList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'summary') then
  begin
    SummaryElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'finding') then
  begin
    FindingList.add(propValue as TFhirClinicalImpressionFinding);
    result := propValue;
  end
  else if (propName = 'prognosisCodeableConcept') then
  begin
    PrognosisCodeableConceptList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'prognosisReference') then
  begin
    PrognosisReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalImpression.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'problem') then ProblemList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'investigation') then InvestigationList.insertItem(index, propValue as TFhirClinicalImpressionInvestigation)
  else if (propName = 'protocol') then ProtocolList.insertItem(index, asUri(propValue))
  else if (propName = 'finding') then FindingList.insertItem(index, propValue as TFhirClinicalImpressionFinding)
  else if (propName = 'prognosisCodeableConcept') then PrognosisCodeableConceptList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'prognosisReference') then PrognosisReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirClinicalImpression.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirClinicalImpressionStatusEnum[ClinicalImpressionStatusNull], CODES_TFhirClinicalImpressionStatusEnum[ClinicalImpressionStatusNull]) 
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective')
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'assessor') then result := TFhirReference.create()
  else if (propName = 'previous') then result := TFhirReference.create()
  else if (propName = 'problem') then result := ProblemList.new()
  else if (propName = 'investigation') then result := InvestigationList.new()
  else if (propName = 'protocol') then result := ProtocolList.new()
  else if (propName = 'summary') then result := TFhirString.create()
  else if (propName = 'finding') then result := FindingList.new()
  else if (propName = 'prognosisCodeableConcept') then result := PrognosisCodeableConceptList.new()
  else if (propName = 'prognosisReference') then result := PrognosisReferenceList.new()
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalImpression.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'assessor') then result := 'Reference'
  else if (propName = 'previous') then result := 'Reference'
  else if (propName = 'problem') then result := 'Reference'
  else if (propName = 'investigation') then result := 'BackboneElement'
  else if (propName = 'protocol') then result := 'uri'
  else if (propName = 'summary') then result := 'string'
  else if (propName = 'finding') then result := 'BackboneElement'
  else if (propName = 'prognosisCodeableConcept') then result := 'CodeableConcept'
  else if (propName = 'prognosisReference') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalImpression.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'assessor') then AssessorElement := nil
  else if (propName = 'previous') then PreviousElement := nil
  else if (propName = 'problem') then deletePropertyValue('problem', ProblemList, value)
  else if (propName = 'investigation') then deletePropertyValue('investigation', InvestigationList, value)
  else if (propName = 'protocol') then deletePropertyValue('protocol', ProtocolList, value)
  else if (propName = 'summary') then SummaryElement := nil
  else if (propName = 'finding') then deletePropertyValue('finding', FindingList, value)
  else if (propName = 'prognosisCodeableConcept') then deletePropertyValue('prognosisCodeableConcept', PrognosisCodeableConceptList, value)
  else if (propName = 'prognosisReference') then deletePropertyValue('prognosisReference', PrognosisReferenceList, value)
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalImpression.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirClinicalImpressionStatusEnum, CODES_TFhirClinicalImpressionStatusEnum, new)
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirDataType
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'assessor') then AssessorElement := new as TFhirReference
  else if (propName = 'previous') then PreviousElement := new as TFhirReference
  else if (propName = 'problem') then replacePropertyValue('problem', ProblemList, existing, new)
  else if (propName = 'investigation') then replacePropertyValue('investigation', InvestigationList, existing, new)
  else if (propName = 'protocol') then replacePropertyValue('protocol', ProtocolList, existing, new)
  else if (propName = 'summary') then SummaryElement := asString(new)
  else if (propName = 'finding') then replacePropertyValue('finding', FindingList, existing, new)
  else if (propName = 'prognosisCodeableConcept') then replacePropertyValue('prognosisCodeableConcept', PrognosisCodeableConceptList, existing, new)
  else if (propName = 'prognosisReference') then replacePropertyValue('prognosisReference', PrognosisReferenceList, existing, new)
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalImpression.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'problem') then ProblemList.move(source, destination)
  else if (propName = 'investigation') then InvestigationList.move(source, destination)
  else if (propName = 'protocol') then ProtocolList.move(source, destination)
  else if (propName = 'finding') then FindingList.move(source, destination)
  else if (propName = 'prognosisCodeableConcept') then PrognosisCodeableConceptList.move(source, destination)
  else if (propName = 'prognosisReference') then PrognosisReferenceList.move(source, destination)
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalImpression.fhirType : string;
begin
  result := 'ClinicalImpression';
end;

function TFhirClinicalImpression.Link : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(inherited Link);
end;

function TFhirClinicalImpression.Clone : TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(inherited Clone);
end;

function TFhirClinicalImpression.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalImpression;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalImpression)) then
    result := false
  else
  begin
    o := TFhirClinicalImpression(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(assessorElement, o.assessorElement, true) and 
      compareDeep(previousElement, o.previousElement, true) and compareDeep(problemList, o.problemList, true) and 
      compareDeep(investigationList, o.investigationList, true) and compareDeep(protocolList, o.protocolList, true) and 
      compareDeep(summaryElement, o.summaryElement, true) and compareDeep(findingList, o.findingList, true) and 
      compareDeep(prognosisCodeableConceptList, o.prognosisCodeableConceptList, true) and 
      compareDeep(prognosisReferenceList, o.prognosisReferenceList, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirClinicalImpression.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FEffective) and isEmptyProp(FDate) and isEmptyProp(FAssessor) and isEmptyProp(FPrevious) and isEmptyProp(FproblemList) and isEmptyProp(FinvestigationList) and isEmptyProp(FprotocolList) and isEmptyProp(FSummary) and isEmptyProp(FfindingList) and isEmptyProp(FprognosisCodeableConceptList) and isEmptyProp(FprognosisReferenceList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FnoteList);
end;

procedure TFhirClinicalImpression.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('code');
  fields.add('description');
  fields.add('subject');
  fields.add('encounter');
  fields.add('effective[x]');
  fields.add('date');
  fields.add('assessor');
  fields.add('previous');
  fields.add('problem');
  fields.add('investigation');
  fields.add('protocol');
  fields.add('summary');
  fields.add('finding');
  fields.add('prognosisCodeableConcept');
  fields.add('prognosisReference');
  fields.add('supportingInfo');
  fields.add('note');
end;

function TFhirClinicalImpression.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FProblemList.sizeInBytes(magic));
  inc(result, FInvestigationList.sizeInBytes(magic));
  inc(result, FProtocolList.sizeInBytes(magic));
  inc(result, FFindingList.sizeInBytes(magic));
  inc(result, FPrognosisCodeableConceptList.sizeInBytes(magic));
  inc(result, FPrognosisReferenceList.sizeInBytes(magic));
  inc(result, FSupportingInfoList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirClinicalImpression.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirClinicalImpression.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirClinicalImpression.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirClinicalImpression.GetStatusST : TFhirClinicalImpressionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirClinicalImpressionStatusEnum(0)
  else
    result := TFhirClinicalImpressionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirClinicalImpressionStatusEnum, FStatus.value));
end;

procedure TFhirClinicalImpression.SetStatusST(value : TFhirClinicalImpressionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirClinicalImpressionStatusEnum[value], CODES_TFhirClinicalImpressionStatusEnum[value]);
end;

procedure TFhirClinicalImpression.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

procedure TFhirClinicalImpression.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirClinicalImpression.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirClinicalImpression.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirClinicalImpression.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirClinicalImpression.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirClinicalImpression.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirClinicalImpression.SetEffective(value : TFhirDataType);
begin
  FEffective.free;
  FEffective := value;
end;

procedure TFhirClinicalImpression.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirClinicalImpression.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirClinicalImpression.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirClinicalImpression.SetAssessor(value : TFhirReference);
begin
  FAssessor.free;
  FAssessor := value;
end;

procedure TFhirClinicalImpression.SetPrevious(value : TFhirReference);
begin
  FPrevious.free;
  FPrevious := value;
end;

function TFhirClinicalImpression.GetProblemList : TFhirReferenceList;
begin
  if FProblemList = nil then
    FProblemList := TFhirReferenceList.Create;
  result := FProblemList;
end;

function TFhirClinicalImpression.GetHasProblemList : boolean;
begin
  result := (FProblemList <> nil) and (FProblemList.count > 0);
end;

function TFhirClinicalImpression.GetInvestigationList : TFhirClinicalImpressionInvestigationList;
begin
  if FInvestigationList = nil then
    FInvestigationList := TFhirClinicalImpressionInvestigationList.Create;
  result := FInvestigationList;
end;

function TFhirClinicalImpression.GetHasInvestigationList : boolean;
begin
  result := (FInvestigationList <> nil) and (FInvestigationList.count > 0);
end;

function TFhirClinicalImpression.GetProtocolList : TFhirUriList;
begin
  if FProtocolList = nil then
    FProtocolList := TFhirUriList.Create;
  result := FProtocolList;
end;

function TFhirClinicalImpression.GetHasProtocolList : boolean;
begin
  result := (FProtocolList <> nil) and (FProtocolList.count > 0);
end;

procedure TFhirClinicalImpression.SetSummary(value : TFhirString);
begin
  FSummary.free;
  FSummary := value;
end;

function TFhirClinicalImpression.GetSummaryST : String;
begin
  if FSummary = nil then
    result := ''
  else
    result := FSummary.value;
end;

procedure TFhirClinicalImpression.SetSummaryST(value : String);
begin
  if value <> '' then
  begin
    if FSummary = nil then
      FSummary := TFhirString.create;
    FSummary.value := value
  end
  else if FSummary <> nil then
    FSummary.value := '';
end;

function TFhirClinicalImpression.GetFindingList : TFhirClinicalImpressionFindingList;
begin
  if FFindingList = nil then
    FFindingList := TFhirClinicalImpressionFindingList.Create;
  result := FFindingList;
end;

function TFhirClinicalImpression.GetHasFindingList : boolean;
begin
  result := (FFindingList <> nil) and (FFindingList.count > 0);
end;

function TFhirClinicalImpression.GetPrognosisCodeableConceptList : TFhirCodeableConceptList;
begin
  if FPrognosisCodeableConceptList = nil then
    FPrognosisCodeableConceptList := TFhirCodeableConceptList.Create;
  result := FPrognosisCodeableConceptList;
end;

function TFhirClinicalImpression.GetHasPrognosisCodeableConceptList : boolean;
begin
  result := (FPrognosisCodeableConceptList <> nil) and (FPrognosisCodeableConceptList.count > 0);
end;

function TFhirClinicalImpression.GetPrognosisReferenceList : TFhirReferenceList;
begin
  if FPrognosisReferenceList = nil then
    FPrognosisReferenceList := TFhirReferenceList.Create;
  result := FPrognosisReferenceList;
end;

function TFhirClinicalImpression.GetHasPrognosisReferenceList : boolean;
begin
  result := (FPrognosisReferenceList <> nil) and (FPrognosisReferenceList.count > 0);
end;

function TFhirClinicalImpression.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirClinicalImpression.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirClinicalImpression.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirClinicalImpression.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirClinicalImpressionListEnumerator }

constructor TFhirClinicalImpressionListEnumerator.Create(list : TFhirClinicalImpressionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalImpressionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalImpressionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalImpressionListEnumerator.GetCurrent : TFhirClinicalImpression;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalImpressionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalImpressionList }

function TFhirClinicalImpressionList.AddItem(value: TFhirClinicalImpression): TFhirClinicalImpression;
begin
  assert(value.ClassName = 'TFhirClinicalImpression', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalImpression');
  add(value);
  result := value;
end;

function TFhirClinicalImpressionList.Append: TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalImpressionList.GetEnumerator : TFhirClinicalImpressionListEnumerator;
begin
  result := TFhirClinicalImpressionListEnumerator.Create(self.link);
end;

function TFhirClinicalImpressionList.Clone: TFhirClinicalImpressionList;
begin
  result := TFhirClinicalImpressionList(inherited Clone);
end;

function TFhirClinicalImpressionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalImpressionList.GetItemN(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalImpression;
end;
function TFhirClinicalImpressionList.IndexOf(value: TFhirClinicalImpression): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalImpressionList.Insert(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalImpressionList.InsertItem(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  Inherited Insert(index, value);
end;

function TFhirClinicalImpressionList.Item(index: Integer): TFhirClinicalImpression;
begin
  result := TFhirClinicalImpression(ObjectByIndex[index]);
end;

function TFhirClinicalImpressionList.Link: TFhirClinicalImpressionList;
begin
  result := TFhirClinicalImpressionList(inherited Link);
end;

procedure TFhirClinicalImpressionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalImpressionList.SetItemByIndex(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  FhirClinicalImpressions[index] := value;
end;

procedure TFhirClinicalImpressionList.SetItemN(index: Integer; value: TFhirClinicalImpression);
begin
  assert(value is TFhirClinicalImpression);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLINICALIMPRESSION}
{$IFDEF FHIR_CLINICALUSEDEFINITION}
{ TFhirClinicalUseDefinitionContraindication }

constructor TFhirClinicalUseDefinitionContraindication.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseDefinitionContraindication.Destroy;
begin
  FDiseaseSymptomProcedure.free;
  FDiseaseStatus.free;
  FComorbidityList.Free;
  FIndicationList.Free;
  FOtherTherapyList.Free;
  inherited;
end;

procedure TFhirClinicalUseDefinitionContraindication.Assign(oSource : TFslObject);
begin
  inherited;
  diseaseSymptomProcedure := TFhirClinicalUseDefinitionContraindication(oSource).diseaseSymptomProcedure.Clone;
  diseaseStatus := TFhirClinicalUseDefinitionContraindication(oSource).diseaseStatus.Clone;
  if (TFhirClinicalUseDefinitionContraindication(oSource).FComorbidityList = nil) then
  begin
    FComorbidityList.free;
    FComorbidityList := nil;
  end
  else
  begin
    if FComorbidityList = nil then
      FComorbidityList := TFhirCodeableReferenceList.Create;
    FComorbidityList.Assign(TFhirClinicalUseDefinitionContraindication(oSource).FComorbidityList);
  end;
  if (TFhirClinicalUseDefinitionContraindication(oSource).FIndicationList = nil) then
  begin
    FIndicationList.free;
    FIndicationList := nil;
  end
  else
  begin
    if FIndicationList = nil then
      FIndicationList := TFhirReferenceList.Create;
    FIndicationList.Assign(TFhirClinicalUseDefinitionContraindication(oSource).FIndicationList);
  end;
  if (TFhirClinicalUseDefinitionContraindication(oSource).FOtherTherapyList = nil) then
  begin
    FOtherTherapyList.free;
    FOtherTherapyList := nil;
  end
  else
  begin
    if FOtherTherapyList = nil then
      FOtherTherapyList := TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Create;
    FOtherTherapyList.Assign(TFhirClinicalUseDefinitionContraindication(oSource).FOtherTherapyList);
  end;
end;

procedure TFhirClinicalUseDefinitionContraindication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'diseaseSymptomProcedure') Then
     list.add(self.link, 'diseaseSymptomProcedure', FDiseaseSymptomProcedure.Link);
  if (child_name = 'diseaseStatus') Then
     list.add(self.link, 'diseaseStatus', FDiseaseStatus.Link);
  if (child_name = 'comorbidity') Then
    list.addAll(self, 'comorbidity', FComorbidityList);
  if (child_name = 'indication') Then
    list.addAll(self, 'indication', FIndicationList);
  if (child_name = 'otherTherapy') Then
    list.addAll(self, 'otherTherapy', FOtherTherapyList);
end;

procedure TFhirClinicalUseDefinitionContraindication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'diseaseSymptomProcedure', 'CodeableReference', false, TFhirCodeableReference, FDiseaseSymptomProcedure.Link));
  oList.add(TFHIRProperty.create(self, 'diseaseStatus', 'CodeableReference', false, TFhirCodeableReference, FDiseaseStatus.Link));
  oList.add(TFHIRProperty.create(self, 'comorbidity', 'CodeableReference', true, TFhirCodeableReference, FComorbidityList.Link));
  oList.add(TFHIRProperty.create(self, 'indication', 'Reference', true, TFhirReference, FIndicationList.Link));
  oList.add(TFHIRProperty.create(self, 'otherTherapy', 'BackboneElement', true, TFhirClinicalUseDefinitionContraindicationOtherTherapy, FOtherTherapyList.Link));
end;

function TFhirClinicalUseDefinitionContraindication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'diseaseSymptomProcedure') then
  begin
    DiseaseSymptomProcedure := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'diseaseStatus') then
  begin
    DiseaseStatus := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'comorbidity') then
  begin
    ComorbidityList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    IndicationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'otherTherapy') then
  begin
    OtherTherapyList.add(propValue as TFhirClinicalUseDefinitionContraindicationOtherTherapy);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseDefinitionContraindication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'comorbidity') then ComorbidityList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'indication') then IndicationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'otherTherapy') then OtherTherapyList.insertItem(index, propValue as TFhirClinicalUseDefinitionContraindicationOtherTherapy)
  else inherited;
end;

function TFhirClinicalUseDefinitionContraindication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'diseaseSymptomProcedure') then result := TFhirCodeableReference.create()
  else if (propName = 'diseaseStatus') then result := TFhirCodeableReference.create()
  else if (propName = 'comorbidity') then result := ComorbidityList.new()
  else if (propName = 'indication') then result := IndicationList.new()
  else if (propName = 'otherTherapy') then result := OtherTherapyList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseDefinitionContraindication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'diseaseSymptomProcedure') then result := 'CodeableReference'
  else if (propName = 'diseaseStatus') then result := 'CodeableReference'
  else if (propName = 'comorbidity') then result := 'CodeableReference'
  else if (propName = 'indication') then result := 'Reference'
  else if (propName = 'otherTherapy') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseDefinitionContraindication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := nil
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := nil
  else if (propName = 'comorbidity') then deletePropertyValue('comorbidity', ComorbidityList, value)
  else if (propName = 'indication') then deletePropertyValue('indication', IndicationList, value)
  else if (propName = 'otherTherapy') then deletePropertyValue('otherTherapy', OtherTherapyList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseDefinitionContraindication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := new as TFhirCodeableReference
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := new as TFhirCodeableReference
  else if (propName = 'comorbidity') then replacePropertyValue('comorbidity', ComorbidityList, existing, new)
  else if (propName = 'indication') then replacePropertyValue('indication', IndicationList, existing, new)
  else if (propName = 'otherTherapy') then replacePropertyValue('otherTherapy', OtherTherapyList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseDefinitionContraindication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'comorbidity') then ComorbidityList.move(source, destination)
  else if (propName = 'indication') then IndicationList.move(source, destination)
  else if (propName = 'otherTherapy') then OtherTherapyList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseDefinitionContraindication.fhirType : string;
begin
  result := 'ClinicalUseDefinition.contraindication';
end;

function TFhirClinicalUseDefinitionContraindication.Link : TFhirClinicalUseDefinitionContraindication;
begin
  result := TFhirClinicalUseDefinitionContraindication(inherited Link);
end;

function TFhirClinicalUseDefinitionContraindication.Clone : TFhirClinicalUseDefinitionContraindication;
begin
  result := TFhirClinicalUseDefinitionContraindication(inherited Clone);
end;

function TFhirClinicalUseDefinitionContraindication.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseDefinitionContraindication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseDefinitionContraindication)) then
    result := false
  else
  begin
    o := TFhirClinicalUseDefinitionContraindication(other);
    result := compareDeep(diseaseSymptomProcedureElement, o.diseaseSymptomProcedureElement, true) and 
      compareDeep(diseaseStatusElement, o.diseaseStatusElement, true) and compareDeep(comorbidityList, o.comorbidityList, true) and 
      compareDeep(indicationList, o.indicationList, true) and compareDeep(otherTherapyList, o.otherTherapyList, true);
  end;
end;

function TFhirClinicalUseDefinitionContraindication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDiseaseSymptomProcedure) and isEmptyProp(FDiseaseStatus) and isEmptyProp(FcomorbidityList) and isEmptyProp(FindicationList) and isEmptyProp(FotherTherapyList);
end;

procedure TFhirClinicalUseDefinitionContraindication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('diseaseSymptomProcedure');
  fields.add('diseaseStatus');
  fields.add('comorbidity');
  fields.add('indication');
  fields.add('otherTherapy');
end;

function TFhirClinicalUseDefinitionContraindication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FComorbidityList.sizeInBytes(magic));
  inc(result, FIndicationList.sizeInBytes(magic));
  inc(result, FOtherTherapyList.sizeInBytes(magic));
end;

procedure TFhirClinicalUseDefinitionContraindication.SetDiseaseSymptomProcedure(value : TFhirCodeableReference);
begin
  FDiseaseSymptomProcedure.free;
  FDiseaseSymptomProcedure := value;
end;

procedure TFhirClinicalUseDefinitionContraindication.SetDiseaseStatus(value : TFhirCodeableReference);
begin
  FDiseaseStatus.free;
  FDiseaseStatus := value;
end;

function TFhirClinicalUseDefinitionContraindication.GetComorbidityList : TFhirCodeableReferenceList;
begin
  if FComorbidityList = nil then
    FComorbidityList := TFhirCodeableReferenceList.Create;
  result := FComorbidityList;
end;

function TFhirClinicalUseDefinitionContraindication.GetHasComorbidityList : boolean;
begin
  result := (FComorbidityList <> nil) and (FComorbidityList.count > 0);
end;

function TFhirClinicalUseDefinitionContraindication.GetIndicationList : TFhirReferenceList;
begin
  if FIndicationList = nil then
    FIndicationList := TFhirReferenceList.Create;
  result := FIndicationList;
end;

function TFhirClinicalUseDefinitionContraindication.GetHasIndicationList : boolean;
begin
  result := (FIndicationList <> nil) and (FIndicationList.count > 0);
end;

function TFhirClinicalUseDefinitionContraindication.GetOtherTherapyList : TFhirClinicalUseDefinitionContraindicationOtherTherapyList;
begin
  if FOtherTherapyList = nil then
    FOtherTherapyList := TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Create;
  result := FOtherTherapyList;
end;

function TFhirClinicalUseDefinitionContraindication.GetHasOtherTherapyList : boolean;
begin
  result := (FOtherTherapyList <> nil) and (FOtherTherapyList.count > 0);
end;

{ TFhirClinicalUseDefinitionContraindicationListEnumerator }

constructor TFhirClinicalUseDefinitionContraindicationListEnumerator.Create(list : TFhirClinicalUseDefinitionContraindicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseDefinitionContraindicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseDefinitionContraindicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseDefinitionContraindicationListEnumerator.GetCurrent : TFhirClinicalUseDefinitionContraindication;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseDefinitionContraindicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalUseDefinitionContraindicationList }

function TFhirClinicalUseDefinitionContraindicationList.AddItem(value: TFhirClinicalUseDefinitionContraindication): TFhirClinicalUseDefinitionContraindication;
begin
  assert(value.ClassName = 'TFhirClinicalUseDefinitionContraindication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseDefinitionContraindication');
  add(value);
  result := value;
end;

function TFhirClinicalUseDefinitionContraindicationList.Append: TFhirClinicalUseDefinitionContraindication;
begin
  result := TFhirClinicalUseDefinitionContraindication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionContraindicationList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseDefinitionContraindicationList.GetEnumerator : TFhirClinicalUseDefinitionContraindicationListEnumerator;
begin
  result := TFhirClinicalUseDefinitionContraindicationListEnumerator.Create(self.link);
end;

function TFhirClinicalUseDefinitionContraindicationList.Clone: TFhirClinicalUseDefinitionContraindicationList;
begin
  result := TFhirClinicalUseDefinitionContraindicationList(inherited Clone);
end;

function TFhirClinicalUseDefinitionContraindicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseDefinitionContraindicationList.GetItemN(index: Integer): TFhirClinicalUseDefinitionContraindication;
begin
  result := TFhirClinicalUseDefinitionContraindication(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionContraindicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseDefinitionContraindication;
end;
function TFhirClinicalUseDefinitionContraindicationList.IndexOf(value: TFhirClinicalUseDefinitionContraindication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseDefinitionContraindicationList.Insert(index: Integer): TFhirClinicalUseDefinitionContraindication;
begin
  result := TFhirClinicalUseDefinitionContraindication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionContraindicationList.InsertItem(index: Integer; value: TFhirClinicalUseDefinitionContraindication);
begin
  assert(value is TFhirClinicalUseDefinitionContraindication);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseDefinitionContraindicationList.Item(index: Integer): TFhirClinicalUseDefinitionContraindication;
begin
  result := TFhirClinicalUseDefinitionContraindication(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionContraindicationList.Link: TFhirClinicalUseDefinitionContraindicationList;
begin
  result := TFhirClinicalUseDefinitionContraindicationList(inherited Link);
end;

procedure TFhirClinicalUseDefinitionContraindicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseDefinitionContraindicationList.SetItemByIndex(index: Integer; value: TFhirClinicalUseDefinitionContraindication);
begin
  assert(value is TFhirClinicalUseDefinitionContraindication);
  FhirClinicalUseDefinitionContraindications[index] := value;
end;

procedure TFhirClinicalUseDefinitionContraindicationList.SetItemN(index: Integer; value: TFhirClinicalUseDefinitionContraindication);
begin
  assert(value is TFhirClinicalUseDefinitionContraindication);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseDefinitionContraindicationOtherTherapy }

constructor TFhirClinicalUseDefinitionContraindicationOtherTherapy.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseDefinitionContraindicationOtherTherapy.Destroy;
begin
  FRelationshipType.free;
  FTherapy.free;
  inherited;
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.Assign(oSource : TFslObject);
begin
  inherited;
  relationshipType := TFhirClinicalUseDefinitionContraindicationOtherTherapy(oSource).relationshipType.Clone;
  therapy := TFhirClinicalUseDefinitionContraindicationOtherTherapy(oSource).therapy.Clone;
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationshipType') Then
     list.add(self.link, 'relationshipType', FRelationshipType.Link);
  if (child_name = 'therapy') Then
     list.add(self.link, 'therapy', FTherapy.Link);
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relationshipType', 'CodeableConcept', false, TFhirCodeableConcept, FRelationshipType.Link));
  oList.add(TFHIRProperty.create(self, 'therapy', 'CodeableReference', false, TFhirCodeableReference, FTherapy.Link));
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationshipType') then
  begin
    RelationshipType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'therapy') then
  begin
    Therapy := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relationshipType') then result := TFhirCodeableConcept.create()
  else if (propName = 'therapy') then result := TFhirCodeableReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationshipType') then result := 'CodeableConcept'
  else if (propName = 'therapy') then result := 'CodeableReference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationshipType') then RelationshipTypeElement := nil
  else if (propName = 'therapy') then TherapyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationshipType') then RelationshipTypeElement := new as TFhirCodeableConcept
  else if (propName = 'therapy') then TherapyElement := new as TFhirCodeableReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapy.fhirType : string;
begin
  result := 'ClinicalUseDefinition.contraindication.otherTherapy';
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapy.Link : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapy(inherited Link);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapy.Clone : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapy(inherited Clone);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapy.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseDefinitionContraindicationOtherTherapy)) then
    result := false
  else
  begin
    o := TFhirClinicalUseDefinitionContraindicationOtherTherapy(other);
    result := compareDeep(relationshipTypeElement, o.relationshipTypeElement, true) and 
      compareDeep(therapyElement, o.therapyElement, true);
  end;
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelationshipType) and isEmptyProp(FTherapy);
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('relationshipType');
  fields.add('therapy');
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapy.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.SetRelationshipType(value : TFhirCodeableConcept);
begin
  FRelationshipType.free;
  FRelationshipType := value;
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapy.SetTherapy(value : TFhirCodeableReference);
begin
  FTherapy.free;
  FTherapy := value;
end;

{ TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator }

constructor TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator.Create(list : TFhirClinicalUseDefinitionContraindicationOtherTherapyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator.GetCurrent : TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalUseDefinitionContraindicationOtherTherapyList }

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.AddItem(value: TFhirClinicalUseDefinitionContraindicationOtherTherapy): TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  assert(value.ClassName = 'TFhirClinicalUseDefinitionContraindicationOtherTherapy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseDefinitionContraindicationOtherTherapy');
  add(value);
  result := value;
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Append: TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapyList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.GetEnumerator : TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapyListEnumerator.Create(self.link);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Clone: TFhirClinicalUseDefinitionContraindicationOtherTherapyList;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapyList(inherited Clone);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.GetItemN(index: Integer): TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapy(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapy;
end;
function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.IndexOf(value: TFhirClinicalUseDefinitionContraindicationOtherTherapy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Insert(index: Integer): TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapyList.InsertItem(index: Integer; value: TFhirClinicalUseDefinitionContraindicationOtherTherapy);
begin
  assert(value is TFhirClinicalUseDefinitionContraindicationOtherTherapy);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Item(index: Integer): TFhirClinicalUseDefinitionContraindicationOtherTherapy;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapy(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Link: TFhirClinicalUseDefinitionContraindicationOtherTherapyList;
begin
  result := TFhirClinicalUseDefinitionContraindicationOtherTherapyList(inherited Link);
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapyList.SetItemByIndex(index: Integer; value: TFhirClinicalUseDefinitionContraindicationOtherTherapy);
begin
  assert(value is TFhirClinicalUseDefinitionContraindicationOtherTherapy);
  FhirClinicalUseDefinitionContraindicationOtherTherapies[index] := value;
end;

procedure TFhirClinicalUseDefinitionContraindicationOtherTherapyList.SetItemN(index: Integer; value: TFhirClinicalUseDefinitionContraindicationOtherTherapy);
begin
  assert(value is TFhirClinicalUseDefinitionContraindicationOtherTherapy);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseDefinitionIndication }

constructor TFhirClinicalUseDefinitionIndication.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseDefinitionIndication.Destroy;
begin
  FDiseaseSymptomProcedure.free;
  FDiseaseStatus.free;
  FComorbidityList.Free;
  FIntendedEffect.free;
  FDuration.free;
  FUndesirableEffectList.Free;
  FOtherTherapyList.Free;
  inherited;
end;

procedure TFhirClinicalUseDefinitionIndication.Assign(oSource : TFslObject);
begin
  inherited;
  diseaseSymptomProcedure := TFhirClinicalUseDefinitionIndication(oSource).diseaseSymptomProcedure.Clone;
  diseaseStatus := TFhirClinicalUseDefinitionIndication(oSource).diseaseStatus.Clone;
  if (TFhirClinicalUseDefinitionIndication(oSource).FComorbidityList = nil) then
  begin
    FComorbidityList.free;
    FComorbidityList := nil;
  end
  else
  begin
    if FComorbidityList = nil then
      FComorbidityList := TFhirCodeableReferenceList.Create;
    FComorbidityList.Assign(TFhirClinicalUseDefinitionIndication(oSource).FComorbidityList);
  end;
  intendedEffect := TFhirClinicalUseDefinitionIndication(oSource).intendedEffect.Clone;
  duration := TFhirClinicalUseDefinitionIndication(oSource).duration.Clone;
  if (TFhirClinicalUseDefinitionIndication(oSource).FUndesirableEffectList = nil) then
  begin
    FUndesirableEffectList.free;
    FUndesirableEffectList := nil;
  end
  else
  begin
    if FUndesirableEffectList = nil then
      FUndesirableEffectList := TFhirReferenceList.Create;
    FUndesirableEffectList.Assign(TFhirClinicalUseDefinitionIndication(oSource).FUndesirableEffectList);
  end;
  if (TFhirClinicalUseDefinitionIndication(oSource).FOtherTherapyList = nil) then
  begin
    FOtherTherapyList.free;
    FOtherTherapyList := nil;
  end
  else
  begin
    if FOtherTherapyList = nil then
      FOtherTherapyList := TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Create;
    FOtherTherapyList.Assign(TFhirClinicalUseDefinitionIndication(oSource).FOtherTherapyList);
  end;
end;

procedure TFhirClinicalUseDefinitionIndication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'diseaseSymptomProcedure') Then
     list.add(self.link, 'diseaseSymptomProcedure', FDiseaseSymptomProcedure.Link);
  if (child_name = 'diseaseStatus') Then
     list.add(self.link, 'diseaseStatus', FDiseaseStatus.Link);
  if (child_name = 'comorbidity') Then
    list.addAll(self, 'comorbidity', FComorbidityList);
  if (child_name = 'intendedEffect') Then
     list.add(self.link, 'intendedEffect', FIntendedEffect.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'undesirableEffect') Then
    list.addAll(self, 'undesirableEffect', FUndesirableEffectList);
  if (child_name = 'otherTherapy') Then
    list.addAll(self, 'otherTherapy', FOtherTherapyList);
end;

procedure TFhirClinicalUseDefinitionIndication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'diseaseSymptomProcedure', 'CodeableReference', false, TFhirCodeableReference, FDiseaseSymptomProcedure.Link));
  oList.add(TFHIRProperty.create(self, 'diseaseStatus', 'CodeableReference', false, TFhirCodeableReference, FDiseaseStatus.Link));
  oList.add(TFHIRProperty.create(self, 'comorbidity', 'CodeableReference', true, TFhirCodeableReference, FComorbidityList.Link));
  oList.add(TFHIRProperty.create(self, 'intendedEffect', 'CodeableReference', false, TFhirCodeableReference, FIntendedEffect.Link));
  oList.add(TFHIRProperty.create(self, 'duration', 'Quantity', false, TFhirQuantity, FDuration.Link));
  oList.add(TFHIRProperty.create(self, 'undesirableEffect', 'Reference', true, TFhirReference, FUndesirableEffectList.Link));
  oList.add(TFHIRProperty.create(self, 'otherTherapy', '', true, TFhirClinicalUseDefinitionContraindicationOtherTherapy, FOtherTherapyList.Link));
end;

function TFhirClinicalUseDefinitionIndication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'diseaseSymptomProcedure') then
  begin
    DiseaseSymptomProcedure := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'diseaseStatus') then
  begin
    DiseaseStatus := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'comorbidity') then
  begin
    ComorbidityList.add(propValue as TFhirCodeableReference);
    result := propValue;
  end
  else if (propName = 'intendedEffect') then
  begin
    IntendedEffect := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'undesirableEffect') then
  begin
    UndesirableEffectList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'otherTherapy') then
  begin
    OtherTherapyList.add(propValue as TFhirClinicalUseDefinitionContraindicationOtherTherapy);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseDefinitionIndication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'comorbidity') then ComorbidityList.insertItem(index, propValue as TFhirCodeableReference)
  else if (propName = 'undesirableEffect') then UndesirableEffectList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'otherTherapy') then OtherTherapyList.insertItem(index, propValue as TFhirClinicalUseDefinitionContraindicationOtherTherapy)
  else inherited;
end;

function TFhirClinicalUseDefinitionIndication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'diseaseSymptomProcedure') then result := TFhirCodeableReference.create()
  else if (propName = 'diseaseStatus') then result := TFhirCodeableReference.create()
  else if (propName = 'comorbidity') then result := ComorbidityList.new()
  else if (propName = 'intendedEffect') then result := TFhirCodeableReference.create()
  else if (propName = 'duration') then result := TFhirQuantity.create()
  else if (propName = 'undesirableEffect') then result := UndesirableEffectList.new()
  else if (propName = 'otherTherapy') then result := OtherTherapyList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseDefinitionIndication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'diseaseSymptomProcedure') then result := 'CodeableReference'
  else if (propName = 'diseaseStatus') then result := 'CodeableReference'
  else if (propName = 'comorbidity') then result := 'CodeableReference'
  else if (propName = 'intendedEffect') then result := 'CodeableReference'
  else if (propName = 'duration') then result := 'Quantity'
  else if (propName = 'undesirableEffect') then result := 'Reference'
  else if (propName = 'otherTherapy') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseDefinitionIndication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := nil
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := nil
  else if (propName = 'comorbidity') then deletePropertyValue('comorbidity', ComorbidityList, value)
  else if (propName = 'intendedEffect') then IntendedEffectElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'undesirableEffect') then deletePropertyValue('undesirableEffect', UndesirableEffectList, value)
  else if (propName = 'otherTherapy') then deletePropertyValue('otherTherapy', OtherTherapyList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseDefinitionIndication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'diseaseSymptomProcedure') then DiseaseSymptomProcedureElement := new as TFhirCodeableReference
  else if (propName = 'diseaseStatus') then DiseaseStatusElement := new as TFhirCodeableReference
  else if (propName = 'comorbidity') then replacePropertyValue('comorbidity', ComorbidityList, existing, new)
  else if (propName = 'intendedEffect') then IntendedEffectElement := new as TFhirCodeableReference
  else if (propName = 'duration') then DurationElement := new as TFhirQuantity
  else if (propName = 'undesirableEffect') then replacePropertyValue('undesirableEffect', UndesirableEffectList, existing, new)
  else if (propName = 'otherTherapy') then replacePropertyValue('otherTherapy', OtherTherapyList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseDefinitionIndication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'comorbidity') then ComorbidityList.move(source, destination)
  else if (propName = 'undesirableEffect') then UndesirableEffectList.move(source, destination)
  else if (propName = 'otherTherapy') then OtherTherapyList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseDefinitionIndication.fhirType : string;
begin
  result := 'ClinicalUseDefinition.indication';
end;

function TFhirClinicalUseDefinitionIndication.Link : TFhirClinicalUseDefinitionIndication;
begin
  result := TFhirClinicalUseDefinitionIndication(inherited Link);
end;

function TFhirClinicalUseDefinitionIndication.Clone : TFhirClinicalUseDefinitionIndication;
begin
  result := TFhirClinicalUseDefinitionIndication(inherited Clone);
end;

function TFhirClinicalUseDefinitionIndication.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseDefinitionIndication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseDefinitionIndication)) then
    result := false
  else
  begin
    o := TFhirClinicalUseDefinitionIndication(other);
    result := compareDeep(diseaseSymptomProcedureElement, o.diseaseSymptomProcedureElement, true) and 
      compareDeep(diseaseStatusElement, o.diseaseStatusElement, true) and compareDeep(comorbidityList, o.comorbidityList, true) and 
      compareDeep(intendedEffectElement, o.intendedEffectElement, true) and compareDeep(durationElement, o.durationElement, true) and 
      compareDeep(undesirableEffectList, o.undesirableEffectList, true) and compareDeep(otherTherapyList, o.otherTherapyList, true);
  end;
end;

function TFhirClinicalUseDefinitionIndication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDiseaseSymptomProcedure) and isEmptyProp(FDiseaseStatus) and isEmptyProp(FcomorbidityList) and isEmptyProp(FIntendedEffect) and isEmptyProp(FDuration) and isEmptyProp(FundesirableEffectList) and isEmptyProp(FotherTherapyList);
end;

procedure TFhirClinicalUseDefinitionIndication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('diseaseSymptomProcedure');
  fields.add('diseaseStatus');
  fields.add('comorbidity');
  fields.add('intendedEffect');
  fields.add('duration');
  fields.add('undesirableEffect');
  fields.add('otherTherapy');
end;

function TFhirClinicalUseDefinitionIndication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FComorbidityList.sizeInBytes(magic));
  inc(result, FUndesirableEffectList.sizeInBytes(magic));
  inc(result, FOtherTherapyList.sizeInBytes(magic));
end;

procedure TFhirClinicalUseDefinitionIndication.SetDiseaseSymptomProcedure(value : TFhirCodeableReference);
begin
  FDiseaseSymptomProcedure.free;
  FDiseaseSymptomProcedure := value;
end;

procedure TFhirClinicalUseDefinitionIndication.SetDiseaseStatus(value : TFhirCodeableReference);
begin
  FDiseaseStatus.free;
  FDiseaseStatus := value;
end;

function TFhirClinicalUseDefinitionIndication.GetComorbidityList : TFhirCodeableReferenceList;
begin
  if FComorbidityList = nil then
    FComorbidityList := TFhirCodeableReferenceList.Create;
  result := FComorbidityList;
end;

function TFhirClinicalUseDefinitionIndication.GetHasComorbidityList : boolean;
begin
  result := (FComorbidityList <> nil) and (FComorbidityList.count > 0);
end;

procedure TFhirClinicalUseDefinitionIndication.SetIntendedEffect(value : TFhirCodeableReference);
begin
  FIntendedEffect.free;
  FIntendedEffect := value;
end;

procedure TFhirClinicalUseDefinitionIndication.SetDuration(value : TFhirQuantity);
begin
  FDuration.free;
  FDuration := value;
end;

function TFhirClinicalUseDefinitionIndication.GetUndesirableEffectList : TFhirReferenceList;
begin
  if FUndesirableEffectList = nil then
    FUndesirableEffectList := TFhirReferenceList.Create;
  result := FUndesirableEffectList;
end;

function TFhirClinicalUseDefinitionIndication.GetHasUndesirableEffectList : boolean;
begin
  result := (FUndesirableEffectList <> nil) and (FUndesirableEffectList.count > 0);
end;

function TFhirClinicalUseDefinitionIndication.GetOtherTherapyList : TFhirClinicalUseDefinitionContraindicationOtherTherapyList;
begin
  if FOtherTherapyList = nil then
    FOtherTherapyList := TFhirClinicalUseDefinitionContraindicationOtherTherapyList.Create;
  result := FOtherTherapyList;
end;

function TFhirClinicalUseDefinitionIndication.GetHasOtherTherapyList : boolean;
begin
  result := (FOtherTherapyList <> nil) and (FOtherTherapyList.count > 0);
end;

{ TFhirClinicalUseDefinitionIndicationListEnumerator }

constructor TFhirClinicalUseDefinitionIndicationListEnumerator.Create(list : TFhirClinicalUseDefinitionIndicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseDefinitionIndicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseDefinitionIndicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseDefinitionIndicationListEnumerator.GetCurrent : TFhirClinicalUseDefinitionIndication;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseDefinitionIndicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalUseDefinitionIndicationList }

function TFhirClinicalUseDefinitionIndicationList.AddItem(value: TFhirClinicalUseDefinitionIndication): TFhirClinicalUseDefinitionIndication;
begin
  assert(value.ClassName = 'TFhirClinicalUseDefinitionIndication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseDefinitionIndication');
  add(value);
  result := value;
end;

function TFhirClinicalUseDefinitionIndicationList.Append: TFhirClinicalUseDefinitionIndication;
begin
  result := TFhirClinicalUseDefinitionIndication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionIndicationList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseDefinitionIndicationList.GetEnumerator : TFhirClinicalUseDefinitionIndicationListEnumerator;
begin
  result := TFhirClinicalUseDefinitionIndicationListEnumerator.Create(self.link);
end;

function TFhirClinicalUseDefinitionIndicationList.Clone: TFhirClinicalUseDefinitionIndicationList;
begin
  result := TFhirClinicalUseDefinitionIndicationList(inherited Clone);
end;

function TFhirClinicalUseDefinitionIndicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseDefinitionIndicationList.GetItemN(index: Integer): TFhirClinicalUseDefinitionIndication;
begin
  result := TFhirClinicalUseDefinitionIndication(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionIndicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseDefinitionIndication;
end;
function TFhirClinicalUseDefinitionIndicationList.IndexOf(value: TFhirClinicalUseDefinitionIndication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseDefinitionIndicationList.Insert(index: Integer): TFhirClinicalUseDefinitionIndication;
begin
  result := TFhirClinicalUseDefinitionIndication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionIndicationList.InsertItem(index: Integer; value: TFhirClinicalUseDefinitionIndication);
begin
  assert(value is TFhirClinicalUseDefinitionIndication);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseDefinitionIndicationList.Item(index: Integer): TFhirClinicalUseDefinitionIndication;
begin
  result := TFhirClinicalUseDefinitionIndication(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionIndicationList.Link: TFhirClinicalUseDefinitionIndicationList;
begin
  result := TFhirClinicalUseDefinitionIndicationList(inherited Link);
end;

procedure TFhirClinicalUseDefinitionIndicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseDefinitionIndicationList.SetItemByIndex(index: Integer; value: TFhirClinicalUseDefinitionIndication);
begin
  assert(value is TFhirClinicalUseDefinitionIndication);
  FhirClinicalUseDefinitionIndications[index] := value;
end;

procedure TFhirClinicalUseDefinitionIndicationList.SetItemN(index: Integer; value: TFhirClinicalUseDefinitionIndication);
begin
  assert(value is TFhirClinicalUseDefinitionIndication);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseDefinitionInteraction }

constructor TFhirClinicalUseDefinitionInteraction.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseDefinitionInteraction.Destroy;
begin
  FInteractantList.Free;
  FType_.free;
  FEffect.free;
  FIncidence.free;
  FManagementList.Free;
  inherited;
end;

procedure TFhirClinicalUseDefinitionInteraction.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClinicalUseDefinitionInteraction(oSource).FInteractantList = nil) then
  begin
    FInteractantList.free;
    FInteractantList := nil;
  end
  else
  begin
    if FInteractantList = nil then
      FInteractantList := TFhirClinicalUseDefinitionInteractionInteractantList.Create;
    FInteractantList.Assign(TFhirClinicalUseDefinitionInteraction(oSource).FInteractantList);
  end;
  type_ := TFhirClinicalUseDefinitionInteraction(oSource).type_.Clone;
  effect := TFhirClinicalUseDefinitionInteraction(oSource).effect.Clone;
  incidence := TFhirClinicalUseDefinitionInteraction(oSource).incidence.Clone;
  if (TFhirClinicalUseDefinitionInteraction(oSource).FManagementList = nil) then
  begin
    FManagementList.free;
    FManagementList := nil;
  end
  else
  begin
    if FManagementList = nil then
      FManagementList := TFhirCodeableConceptList.Create;
    FManagementList.Assign(TFhirClinicalUseDefinitionInteraction(oSource).FManagementList);
  end;
end;

procedure TFhirClinicalUseDefinitionInteraction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'interactant') Then
    list.addAll(self, 'interactant', FInteractantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'effect') Then
     list.add(self.link, 'effect', FEffect.Link);
  if (child_name = 'incidence') Then
     list.add(self.link, 'incidence', FIncidence.Link);
  if (child_name = 'management') Then
    list.addAll(self, 'management', FManagementList);
end;

procedure TFhirClinicalUseDefinitionInteraction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'interactant', 'BackboneElement', true, TFhirClinicalUseDefinitionInteractionInteractant, FInteractantList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'effect', 'CodeableReference', false, TFhirCodeableReference, FEffect.Link));
  oList.add(TFHIRProperty.create(self, 'incidence', 'CodeableConcept', false, TFhirCodeableConcept, FIncidence.Link));
  oList.add(TFHIRProperty.create(self, 'management', 'CodeableConcept', true, TFhirCodeableConcept, FManagementList.Link));
end;

function TFhirClinicalUseDefinitionInteraction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'interactant') then
  begin
    InteractantList.add(propValue as TFhirClinicalUseDefinitionInteractionInteractant);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'effect') then
  begin
    Effect := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'incidence') then
  begin
    Incidence := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'management') then
  begin
    ManagementList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseDefinitionInteraction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'interactant') then InteractantList.insertItem(index, propValue as TFhirClinicalUseDefinitionInteractionInteractant)
  else if (propName = 'management') then ManagementList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirClinicalUseDefinitionInteraction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'interactant') then result := InteractantList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'effect') then result := TFhirCodeableReference.create()
  else if (propName = 'incidence') then result := TFhirCodeableConcept.create()
  else if (propName = 'management') then result := ManagementList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseDefinitionInteraction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'interactant') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'effect') then result := 'CodeableReference'
  else if (propName = 'incidence') then result := 'CodeableConcept'
  else if (propName = 'management') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseDefinitionInteraction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'interactant') then deletePropertyValue('interactant', InteractantList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'effect') then EffectElement := nil
  else if (propName = 'incidence') then IncidenceElement := nil
  else if (propName = 'management') then deletePropertyValue('management', ManagementList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseDefinitionInteraction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'interactant') then replacePropertyValue('interactant', InteractantList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'effect') then EffectElement := new as TFhirCodeableReference
  else if (propName = 'incidence') then IncidenceElement := new as TFhirCodeableConcept
  else if (propName = 'management') then replacePropertyValue('management', ManagementList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseDefinitionInteraction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'interactant') then InteractantList.move(source, destination)
  else if (propName = 'management') then ManagementList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseDefinitionInteraction.fhirType : string;
begin
  result := 'ClinicalUseDefinition.interaction';
end;

function TFhirClinicalUseDefinitionInteraction.Link : TFhirClinicalUseDefinitionInteraction;
begin
  result := TFhirClinicalUseDefinitionInteraction(inherited Link);
end;

function TFhirClinicalUseDefinitionInteraction.Clone : TFhirClinicalUseDefinitionInteraction;
begin
  result := TFhirClinicalUseDefinitionInteraction(inherited Clone);
end;

function TFhirClinicalUseDefinitionInteraction.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseDefinitionInteraction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseDefinitionInteraction)) then
    result := false
  else
  begin
    o := TFhirClinicalUseDefinitionInteraction(other);
    result := compareDeep(interactantList, o.interactantList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(effectElement, o.effectElement, true) and compareDeep(incidenceElement, o.incidenceElement, true) and 
      compareDeep(managementList, o.managementList, true);
  end;
end;

function TFhirClinicalUseDefinitionInteraction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FinteractantList) and isEmptyProp(FType_) and isEmptyProp(FEffect) and isEmptyProp(FIncidence) and isEmptyProp(FmanagementList);
end;

procedure TFhirClinicalUseDefinitionInteraction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('interactant');
  fields.add('type');
  fields.add('effect');
  fields.add('incidence');
  fields.add('management');
end;

function TFhirClinicalUseDefinitionInteraction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FInteractantList.sizeInBytes(magic));
  inc(result, FManagementList.sizeInBytes(magic));
end;

function TFhirClinicalUseDefinitionInteraction.GetInteractantList : TFhirClinicalUseDefinitionInteractionInteractantList;
begin
  if FInteractantList = nil then
    FInteractantList := TFhirClinicalUseDefinitionInteractionInteractantList.Create;
  result := FInteractantList;
end;

function TFhirClinicalUseDefinitionInteraction.GetHasInteractantList : boolean;
begin
  result := (FInteractantList <> nil) and (FInteractantList.count > 0);
end;

procedure TFhirClinicalUseDefinitionInteraction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirClinicalUseDefinitionInteraction.SetEffect(value : TFhirCodeableReference);
begin
  FEffect.free;
  FEffect := value;
end;

procedure TFhirClinicalUseDefinitionInteraction.SetIncidence(value : TFhirCodeableConcept);
begin
  FIncidence.free;
  FIncidence := value;
end;

function TFhirClinicalUseDefinitionInteraction.GetManagementList : TFhirCodeableConceptList;
begin
  if FManagementList = nil then
    FManagementList := TFhirCodeableConceptList.Create;
  result := FManagementList;
end;

function TFhirClinicalUseDefinitionInteraction.GetHasManagementList : boolean;
begin
  result := (FManagementList <> nil) and (FManagementList.count > 0);
end;

{ TFhirClinicalUseDefinitionInteractionListEnumerator }

constructor TFhirClinicalUseDefinitionInteractionListEnumerator.Create(list : TFhirClinicalUseDefinitionInteractionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseDefinitionInteractionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseDefinitionInteractionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseDefinitionInteractionListEnumerator.GetCurrent : TFhirClinicalUseDefinitionInteraction;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseDefinitionInteractionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalUseDefinitionInteractionList }

function TFhirClinicalUseDefinitionInteractionList.AddItem(value: TFhirClinicalUseDefinitionInteraction): TFhirClinicalUseDefinitionInteraction;
begin
  assert(value.ClassName = 'TFhirClinicalUseDefinitionInteraction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseDefinitionInteraction');
  add(value);
  result := value;
end;

function TFhirClinicalUseDefinitionInteractionList.Append: TFhirClinicalUseDefinitionInteraction;
begin
  result := TFhirClinicalUseDefinitionInteraction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionInteractionList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseDefinitionInteractionList.GetEnumerator : TFhirClinicalUseDefinitionInteractionListEnumerator;
begin
  result := TFhirClinicalUseDefinitionInteractionListEnumerator.Create(self.link);
end;

function TFhirClinicalUseDefinitionInteractionList.Clone: TFhirClinicalUseDefinitionInteractionList;
begin
  result := TFhirClinicalUseDefinitionInteractionList(inherited Clone);
end;

function TFhirClinicalUseDefinitionInteractionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseDefinitionInteractionList.GetItemN(index: Integer): TFhirClinicalUseDefinitionInteraction;
begin
  result := TFhirClinicalUseDefinitionInteraction(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionInteractionList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseDefinitionInteraction;
end;
function TFhirClinicalUseDefinitionInteractionList.IndexOf(value: TFhirClinicalUseDefinitionInteraction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseDefinitionInteractionList.Insert(index: Integer): TFhirClinicalUseDefinitionInteraction;
begin
  result := TFhirClinicalUseDefinitionInteraction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionInteractionList.InsertItem(index: Integer; value: TFhirClinicalUseDefinitionInteraction);
begin
  assert(value is TFhirClinicalUseDefinitionInteraction);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseDefinitionInteractionList.Item(index: Integer): TFhirClinicalUseDefinitionInteraction;
begin
  result := TFhirClinicalUseDefinitionInteraction(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionInteractionList.Link: TFhirClinicalUseDefinitionInteractionList;
begin
  result := TFhirClinicalUseDefinitionInteractionList(inherited Link);
end;

procedure TFhirClinicalUseDefinitionInteractionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseDefinitionInteractionList.SetItemByIndex(index: Integer; value: TFhirClinicalUseDefinitionInteraction);
begin
  assert(value is TFhirClinicalUseDefinitionInteraction);
  FhirClinicalUseDefinitionInteractions[index] := value;
end;

procedure TFhirClinicalUseDefinitionInteractionList.SetItemN(index: Integer; value: TFhirClinicalUseDefinitionInteraction);
begin
  assert(value is TFhirClinicalUseDefinitionInteraction);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseDefinitionInteractionInteractant }

constructor TFhirClinicalUseDefinitionInteractionInteractant.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseDefinitionInteractionInteractant.Destroy;
begin
  FItem.free;
  inherited;
end;

procedure TFhirClinicalUseDefinitionInteractionInteractant.Assign(oSource : TFslObject);
begin
  inherited;
  item := TFhirClinicalUseDefinitionInteractionInteractant(oSource).item.Clone;
end;

procedure TFhirClinicalUseDefinitionInteractionInteractant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirClinicalUseDefinitionInteractionInteractant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'item[x]', 'Reference|CodeableConcept', false, TFhirDataType, FItem.Link));
end;

function TFhirClinicalUseDefinitionInteractionInteractant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then
  begin
    Item := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseDefinitionInteractionInteractant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalUseDefinitionInteractionInteractant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Item')
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseDefinitionInteractionInteractant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'item[x]') then result := 'Reference|CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseDefinitionInteractionInteractant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseDefinitionInteractionInteractant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'item', ['Reference', 'CodeableConcept'])) then ItemElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseDefinitionInteractionInteractant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseDefinitionInteractionInteractant.fhirType : string;
begin
  result := 'ClinicalUseDefinition.interaction.interactant';
end;

function TFhirClinicalUseDefinitionInteractionInteractant.Link : TFhirClinicalUseDefinitionInteractionInteractant;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractant(inherited Link);
end;

function TFhirClinicalUseDefinitionInteractionInteractant.Clone : TFhirClinicalUseDefinitionInteractionInteractant;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractant(inherited Clone);
end;

function TFhirClinicalUseDefinitionInteractionInteractant.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseDefinitionInteractionInteractant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseDefinitionInteractionInteractant)) then
    result := false
  else
  begin
    o := TFhirClinicalUseDefinitionInteractionInteractant(other);
    result := compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirClinicalUseDefinitionInteractionInteractant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FItem);
end;

procedure TFhirClinicalUseDefinitionInteractionInteractant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('item[x]');
end;

function TFhirClinicalUseDefinitionInteractionInteractant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClinicalUseDefinitionInteractionInteractant.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value;
end;

{ TFhirClinicalUseDefinitionInteractionInteractantListEnumerator }

constructor TFhirClinicalUseDefinitionInteractionInteractantListEnumerator.Create(list : TFhirClinicalUseDefinitionInteractionInteractantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseDefinitionInteractionInteractantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseDefinitionInteractionInteractantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseDefinitionInteractionInteractantListEnumerator.GetCurrent : TFhirClinicalUseDefinitionInteractionInteractant;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseDefinitionInteractionInteractantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalUseDefinitionInteractionInteractantList }

function TFhirClinicalUseDefinitionInteractionInteractantList.AddItem(value: TFhirClinicalUseDefinitionInteractionInteractant): TFhirClinicalUseDefinitionInteractionInteractant;
begin
  assert(value.ClassName = 'TFhirClinicalUseDefinitionInteractionInteractant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseDefinitionInteractionInteractant');
  add(value);
  result := value;
end;

function TFhirClinicalUseDefinitionInteractionInteractantList.Append: TFhirClinicalUseDefinitionInteractionInteractant;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionInteractionInteractantList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseDefinitionInteractionInteractantList.GetEnumerator : TFhirClinicalUseDefinitionInteractionInteractantListEnumerator;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractantListEnumerator.Create(self.link);
end;

function TFhirClinicalUseDefinitionInteractionInteractantList.Clone: TFhirClinicalUseDefinitionInteractionInteractantList;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractantList(inherited Clone);
end;

function TFhirClinicalUseDefinitionInteractionInteractantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseDefinitionInteractionInteractantList.GetItemN(index: Integer): TFhirClinicalUseDefinitionInteractionInteractant;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractant(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionInteractionInteractantList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractant;
end;
function TFhirClinicalUseDefinitionInteractionInteractantList.IndexOf(value: TFhirClinicalUseDefinitionInteractionInteractant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseDefinitionInteractionInteractantList.Insert(index: Integer): TFhirClinicalUseDefinitionInteractionInteractant;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionInteractionInteractantList.InsertItem(index: Integer; value: TFhirClinicalUseDefinitionInteractionInteractant);
begin
  assert(value is TFhirClinicalUseDefinitionInteractionInteractant);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseDefinitionInteractionInteractantList.Item(index: Integer): TFhirClinicalUseDefinitionInteractionInteractant;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractant(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionInteractionInteractantList.Link: TFhirClinicalUseDefinitionInteractionInteractantList;
begin
  result := TFhirClinicalUseDefinitionInteractionInteractantList(inherited Link);
end;

procedure TFhirClinicalUseDefinitionInteractionInteractantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseDefinitionInteractionInteractantList.SetItemByIndex(index: Integer; value: TFhirClinicalUseDefinitionInteractionInteractant);
begin
  assert(value is TFhirClinicalUseDefinitionInteractionInteractant);
  FhirClinicalUseDefinitionInteractionInteractants[index] := value;
end;

procedure TFhirClinicalUseDefinitionInteractionInteractantList.SetItemN(index: Integer; value: TFhirClinicalUseDefinitionInteractionInteractant);
begin
  assert(value is TFhirClinicalUseDefinitionInteractionInteractant);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseDefinitionUndesirableEffect }

constructor TFhirClinicalUseDefinitionUndesirableEffect.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseDefinitionUndesirableEffect.Destroy;
begin
  FSymptomConditionEffect.free;
  FClassification.free;
  FFrequencyOfOccurrence.free;
  inherited;
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.Assign(oSource : TFslObject);
begin
  inherited;
  symptomConditionEffect := TFhirClinicalUseDefinitionUndesirableEffect(oSource).symptomConditionEffect.Clone;
  classification := TFhirClinicalUseDefinitionUndesirableEffect(oSource).classification.Clone;
  frequencyOfOccurrence := TFhirClinicalUseDefinitionUndesirableEffect(oSource).frequencyOfOccurrence.Clone;
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'symptomConditionEffect') Then
     list.add(self.link, 'symptomConditionEffect', FSymptomConditionEffect.Link);
  if (child_name = 'classification') Then
     list.add(self.link, 'classification', FClassification.Link);
  if (child_name = 'frequencyOfOccurrence') Then
     list.add(self.link, 'frequencyOfOccurrence', FFrequencyOfOccurrence.Link);
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'symptomConditionEffect', 'CodeableReference', false, TFhirCodeableReference, FSymptomConditionEffect.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'CodeableConcept', false, TFhirCodeableConcept, FClassification.Link));
  oList.add(TFHIRProperty.create(self, 'frequencyOfOccurrence', 'CodeableConcept', false, TFhirCodeableConcept, FFrequencyOfOccurrence.Link));
end;

function TFhirClinicalUseDefinitionUndesirableEffect.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'symptomConditionEffect') then
  begin
    SymptomConditionEffect := propValue as TFhirCodeableReference;
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    Classification := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'frequencyOfOccurrence') then
  begin
    FrequencyOfOccurrence := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalUseDefinitionUndesirableEffect.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'symptomConditionEffect') then result := TFhirCodeableReference.create()
  else if (propName = 'classification') then result := TFhirCodeableConcept.create()
  else if (propName = 'frequencyOfOccurrence') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseDefinitionUndesirableEffect.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'symptomConditionEffect') then result := 'CodeableReference'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'frequencyOfOccurrence') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'symptomConditionEffect') then SymptomConditionEffectElement := nil
  else if (propName = 'classification') then ClassificationElement := nil
  else if (propName = 'frequencyOfOccurrence') then FrequencyOfOccurrenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'symptomConditionEffect') then SymptomConditionEffectElement := new as TFhirCodeableReference
  else if (propName = 'classification') then ClassificationElement := new as TFhirCodeableConcept
  else if (propName = 'frequencyOfOccurrence') then FrequencyOfOccurrenceElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseDefinitionUndesirableEffect.fhirType : string;
begin
  result := 'ClinicalUseDefinition.undesirableEffect';
end;

function TFhirClinicalUseDefinitionUndesirableEffect.Link : TFhirClinicalUseDefinitionUndesirableEffect;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffect(inherited Link);
end;

function TFhirClinicalUseDefinitionUndesirableEffect.Clone : TFhirClinicalUseDefinitionUndesirableEffect;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffect(inherited Clone);
end;

function TFhirClinicalUseDefinitionUndesirableEffect.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseDefinitionUndesirableEffect;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseDefinitionUndesirableEffect)) then
    result := false
  else
  begin
    o := TFhirClinicalUseDefinitionUndesirableEffect(other);
    result := compareDeep(symptomConditionEffectElement, o.symptomConditionEffectElement, true) and 
      compareDeep(classificationElement, o.classificationElement, true) and compareDeep(frequencyOfOccurrenceElement, o.frequencyOfOccurrenceElement, true);
  end;
end;

function TFhirClinicalUseDefinitionUndesirableEffect.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSymptomConditionEffect) and isEmptyProp(FClassification) and isEmptyProp(FFrequencyOfOccurrence);
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('symptomConditionEffect');
  fields.add('classification');
  fields.add('frequencyOfOccurrence');
end;

function TFhirClinicalUseDefinitionUndesirableEffect.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.SetSymptomConditionEffect(value : TFhirCodeableReference);
begin
  FSymptomConditionEffect.free;
  FSymptomConditionEffect := value;
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.SetClassification(value : TFhirCodeableConcept);
begin
  FClassification.free;
  FClassification := value;
end;

procedure TFhirClinicalUseDefinitionUndesirableEffect.SetFrequencyOfOccurrence(value : TFhirCodeableConcept);
begin
  FFrequencyOfOccurrence.free;
  FFrequencyOfOccurrence := value;
end;

{ TFhirClinicalUseDefinitionUndesirableEffectListEnumerator }

constructor TFhirClinicalUseDefinitionUndesirableEffectListEnumerator.Create(list : TFhirClinicalUseDefinitionUndesirableEffectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseDefinitionUndesirableEffectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseDefinitionUndesirableEffectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseDefinitionUndesirableEffectListEnumerator.GetCurrent : TFhirClinicalUseDefinitionUndesirableEffect;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseDefinitionUndesirableEffectListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalUseDefinitionUndesirableEffectList }

function TFhirClinicalUseDefinitionUndesirableEffectList.AddItem(value: TFhirClinicalUseDefinitionUndesirableEffect): TFhirClinicalUseDefinitionUndesirableEffect;
begin
  assert(value.ClassName = 'TFhirClinicalUseDefinitionUndesirableEffect', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseDefinitionUndesirableEffect');
  add(value);
  result := value;
end;

function TFhirClinicalUseDefinitionUndesirableEffectList.Append: TFhirClinicalUseDefinitionUndesirableEffect;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffect.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionUndesirableEffectList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseDefinitionUndesirableEffectList.GetEnumerator : TFhirClinicalUseDefinitionUndesirableEffectListEnumerator;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffectListEnumerator.Create(self.link);
end;

function TFhirClinicalUseDefinitionUndesirableEffectList.Clone: TFhirClinicalUseDefinitionUndesirableEffectList;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffectList(inherited Clone);
end;

function TFhirClinicalUseDefinitionUndesirableEffectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseDefinitionUndesirableEffectList.GetItemN(index: Integer): TFhirClinicalUseDefinitionUndesirableEffect;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffect(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionUndesirableEffectList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffect;
end;
function TFhirClinicalUseDefinitionUndesirableEffectList.IndexOf(value: TFhirClinicalUseDefinitionUndesirableEffect): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseDefinitionUndesirableEffectList.Insert(index: Integer): TFhirClinicalUseDefinitionUndesirableEffect;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffect.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionUndesirableEffectList.InsertItem(index: Integer; value: TFhirClinicalUseDefinitionUndesirableEffect);
begin
  assert(value is TFhirClinicalUseDefinitionUndesirableEffect);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseDefinitionUndesirableEffectList.Item(index: Integer): TFhirClinicalUseDefinitionUndesirableEffect;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffect(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionUndesirableEffectList.Link: TFhirClinicalUseDefinitionUndesirableEffectList;
begin
  result := TFhirClinicalUseDefinitionUndesirableEffectList(inherited Link);
end;

procedure TFhirClinicalUseDefinitionUndesirableEffectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseDefinitionUndesirableEffectList.SetItemByIndex(index: Integer; value: TFhirClinicalUseDefinitionUndesirableEffect);
begin
  assert(value is TFhirClinicalUseDefinitionUndesirableEffect);
  FhirClinicalUseDefinitionUndesirableEffects[index] := value;
end;

procedure TFhirClinicalUseDefinitionUndesirableEffectList.SetItemN(index: Integer; value: TFhirClinicalUseDefinitionUndesirableEffect);
begin
  assert(value is TFhirClinicalUseDefinitionUndesirableEffect);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseDefinitionWarning }

constructor TFhirClinicalUseDefinitionWarning.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseDefinitionWarning.Destroy;
begin
  FDescription.free;
  FCode.free;
  inherited;
end;

procedure TFhirClinicalUseDefinitionWarning.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirClinicalUseDefinitionWarning(oSource).descriptionElement.Clone;
  code := TFhirClinicalUseDefinitionWarning(oSource).code.Clone;
end;

procedure TFhirClinicalUseDefinitionWarning.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
end;

procedure TFhirClinicalUseDefinitionWarning.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
end;

function TFhirClinicalUseDefinitionWarning.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseDefinitionWarning.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirClinicalUseDefinitionWarning.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseDefinitionWarning.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'code') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseDefinitionWarning.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'code') then CodeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseDefinitionWarning.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseDefinitionWarning.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseDefinitionWarning.fhirType : string;
begin
  result := 'ClinicalUseDefinition.warning';
end;

function TFhirClinicalUseDefinitionWarning.Link : TFhirClinicalUseDefinitionWarning;
begin
  result := TFhirClinicalUseDefinitionWarning(inherited Link);
end;

function TFhirClinicalUseDefinitionWarning.Clone : TFhirClinicalUseDefinitionWarning;
begin
  result := TFhirClinicalUseDefinitionWarning(inherited Clone);
end;

function TFhirClinicalUseDefinitionWarning.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseDefinitionWarning;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseDefinitionWarning)) then
    result := false
  else
  begin
    o := TFhirClinicalUseDefinitionWarning(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(codeElement, o.codeElement, true);
  end;
end;

function TFhirClinicalUseDefinitionWarning.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FCode);
end;

procedure TFhirClinicalUseDefinitionWarning.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('code');
end;

function TFhirClinicalUseDefinitionWarning.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirClinicalUseDefinitionWarning.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirClinicalUseDefinitionWarning.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirClinicalUseDefinitionWarning.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirClinicalUseDefinitionWarning.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

{ TFhirClinicalUseDefinitionWarningListEnumerator }

constructor TFhirClinicalUseDefinitionWarningListEnumerator.Create(list : TFhirClinicalUseDefinitionWarningList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseDefinitionWarningListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseDefinitionWarningListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseDefinitionWarningListEnumerator.GetCurrent : TFhirClinicalUseDefinitionWarning;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseDefinitionWarningListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalUseDefinitionWarningList }

function TFhirClinicalUseDefinitionWarningList.AddItem(value: TFhirClinicalUseDefinitionWarning): TFhirClinicalUseDefinitionWarning;
begin
  assert(value.ClassName = 'TFhirClinicalUseDefinitionWarning', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseDefinitionWarning');
  add(value);
  result := value;
end;

function TFhirClinicalUseDefinitionWarningList.Append: TFhirClinicalUseDefinitionWarning;
begin
  result := TFhirClinicalUseDefinitionWarning.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionWarningList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseDefinitionWarningList.GetEnumerator : TFhirClinicalUseDefinitionWarningListEnumerator;
begin
  result := TFhirClinicalUseDefinitionWarningListEnumerator.Create(self.link);
end;

function TFhirClinicalUseDefinitionWarningList.Clone: TFhirClinicalUseDefinitionWarningList;
begin
  result := TFhirClinicalUseDefinitionWarningList(inherited Clone);
end;

function TFhirClinicalUseDefinitionWarningList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseDefinitionWarningList.GetItemN(index: Integer): TFhirClinicalUseDefinitionWarning;
begin
  result := TFhirClinicalUseDefinitionWarning(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionWarningList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseDefinitionWarning;
end;
function TFhirClinicalUseDefinitionWarningList.IndexOf(value: TFhirClinicalUseDefinitionWarning): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseDefinitionWarningList.Insert(index: Integer): TFhirClinicalUseDefinitionWarning;
begin
  result := TFhirClinicalUseDefinitionWarning.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionWarningList.InsertItem(index: Integer; value: TFhirClinicalUseDefinitionWarning);
begin
  assert(value is TFhirClinicalUseDefinitionWarning);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseDefinitionWarningList.Item(index: Integer): TFhirClinicalUseDefinitionWarning;
begin
  result := TFhirClinicalUseDefinitionWarning(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionWarningList.Link: TFhirClinicalUseDefinitionWarningList;
begin
  result := TFhirClinicalUseDefinitionWarningList(inherited Link);
end;

procedure TFhirClinicalUseDefinitionWarningList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseDefinitionWarningList.SetItemByIndex(index: Integer; value: TFhirClinicalUseDefinitionWarning);
begin
  assert(value is TFhirClinicalUseDefinitionWarning);
  FhirClinicalUseDefinitionWarnings[index] := value;
end;

procedure TFhirClinicalUseDefinitionWarningList.SetItemN(index: Integer; value: TFhirClinicalUseDefinitionWarning);
begin
  assert(value is TFhirClinicalUseDefinitionWarning);
  ObjectByIndex[index] := value;
end;

{ TFhirClinicalUseDefinition }

constructor TFhirClinicalUseDefinition.Create;
begin
  inherited;
end;

destructor TFhirClinicalUseDefinition.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FCategoryList.Free;
  FSubjectList.Free;
  FStatus.free;
  FContraindication.free;
  FIndication.free;
  FInteraction.free;
  FPopulationList.Free;
  FUndesirableEffect.free;
  FWarning.free;
  inherited;
end;

procedure TFhirClinicalUseDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirClinicalUseDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirClinicalUseDefinition(oSource).FIdentifierList);
  end;
  type_Element := TFhirClinicalUseDefinition(oSource).type_Element.Clone;
  if (TFhirClinicalUseDefinition(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirClinicalUseDefinition(oSource).FCategoryList);
  end;
  if (TFhirClinicalUseDefinition(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirClinicalUseDefinition(oSource).FSubjectList);
  end;
  status := TFhirClinicalUseDefinition(oSource).status.Clone;
  contraindication := TFhirClinicalUseDefinition(oSource).contraindication.Clone;
  indication := TFhirClinicalUseDefinition(oSource).indication.Clone;
  interaction := TFhirClinicalUseDefinition(oSource).interaction.Clone;
  if (TFhirClinicalUseDefinition(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirReferenceList.Create;
    FPopulationList.Assign(TFhirClinicalUseDefinition(oSource).FPopulationList);
  end;
  undesirableEffect := TFhirClinicalUseDefinition(oSource).undesirableEffect.Clone;
  warning := TFhirClinicalUseDefinition(oSource).warning.Clone;
end;

function TFhirClinicalUseDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtClinicalUseDefinition;
end;

procedure TFhirClinicalUseDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'contraindication') Then
     list.add(self.link, 'contraindication', FContraindication.Link);
  if (child_name = 'indication') Then
     list.add(self.link, 'indication', FIndication.Link);
  if (child_name = 'interaction') Then
     list.add(self.link, 'interaction', FInteraction.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'undesirableEffect') Then
     list.add(self.link, 'undesirableEffect', FUndesirableEffect.Link);
  if (child_name = 'warning') Then
     list.add(self.link, 'warning', FWarning.Link);
end;

procedure TFhirClinicalUseDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'contraindication', 'BackboneElement', false, TFhirClinicalUseDefinitionContraindication, FContraindication.Link));
  oList.add(TFHIRProperty.create(self, 'indication', 'BackboneElement', false, TFhirClinicalUseDefinitionIndication, FIndication.Link));
  oList.add(TFHIRProperty.create(self, 'interaction', 'BackboneElement', false, TFhirClinicalUseDefinitionInteraction, FInteraction.Link));
  oList.add(TFHIRProperty.create(self, 'population', 'Reference', true, TFhirReference, FPopulationList.Link));
  oList.add(TFHIRProperty.create(self, 'undesirableEffect', 'BackboneElement', false, TFhirClinicalUseDefinitionUndesirableEffect, FUndesirableEffect.Link));
  oList.add(TFHIRProperty.create(self, 'warning', 'BackboneElement', false, TFhirClinicalUseDefinitionWarning, FWarning.Link));
end;

function TFhirClinicalUseDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirClinicalUseIssueTypeEnum, CODES_TFhirClinicalUseIssueTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'contraindication') then
  begin
    Contraindication := propValue as TFhirClinicalUseDefinitionContraindication;
    result := propValue;
  end
  else if (propName = 'indication') then
  begin
    Indication := propValue as TFhirClinicalUseDefinitionIndication;
    result := propValue;
  end
  else if (propName = 'interaction') then
  begin
    Interaction := propValue as TFhirClinicalUseDefinitionInteraction;
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'undesirableEffect') then
  begin
    UndesirableEffect := propValue as TFhirClinicalUseDefinitionUndesirableEffect;
    result := propValue;
  end
  else if (propName = 'warning') then
  begin
    Warning := propValue as TFhirClinicalUseDefinitionWarning;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirClinicalUseDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirClinicalUseDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirClinicalUseIssueTypeEnum[ClinicalUseIssueTypeNull], CODES_TFhirClinicalUseIssueTypeEnum[ClinicalUseIssueTypeNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'subject') then result := SubjectList.new()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'contraindication') then result := TFhirClinicalUseDefinitionContraindication.create()
  else if (propName = 'indication') then result := TFhirClinicalUseDefinitionIndication.create()
  else if (propName = 'interaction') then result := TFhirClinicalUseDefinitionInteraction.create()
  else if (propName = 'population') then result := PopulationList.new()
  else if (propName = 'undesirableEffect') then result := TFhirClinicalUseDefinitionUndesirableEffect.create()
  else if (propName = 'warning') then result := TFhirClinicalUseDefinitionWarning.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirClinicalUseDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'contraindication') then result := 'BackboneElement'
  else if (propName = 'indication') then result := 'BackboneElement'
  else if (propName = 'interaction') then result := 'BackboneElement'
  else if (propName = 'population') then result := 'Reference'
  else if (propName = 'undesirableEffect') then result := 'BackboneElement'
  else if (propName = 'warning') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirClinicalUseDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'contraindication') then ContraindicationElement := nil
  else if (propName = 'indication') then IndicationElement := nil
  else if (propName = 'interaction') then InteractionElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value)
  else if (propName = 'undesirableEffect') then UndesirableEffectElement := nil
  else if (propName = 'warning') then WarningElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirClinicalUseDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirClinicalUseIssueTypeEnum, CODES_TFhirClinicalUseIssueTypeEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'contraindication') then ContraindicationElement := new as TFhirClinicalUseDefinitionContraindication
  else if (propName = 'indication') then IndicationElement := new as TFhirClinicalUseDefinitionIndication
  else if (propName = 'interaction') then InteractionElement := new as TFhirClinicalUseDefinitionInteraction
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new)
  else if (propName = 'undesirableEffect') then UndesirableEffectElement := new as TFhirClinicalUseDefinitionUndesirableEffect
  else if (propName = 'warning') then WarningElement := new as TFhirClinicalUseDefinitionWarning
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirClinicalUseDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'subject') then SubjectList.move(source, destination)
  else if (propName = 'population') then PopulationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirClinicalUseDefinition.fhirType : string;
begin
  result := 'ClinicalUseDefinition';
end;

function TFhirClinicalUseDefinition.Link : TFhirClinicalUseDefinition;
begin
  result := TFhirClinicalUseDefinition(inherited Link);
end;

function TFhirClinicalUseDefinition.Clone : TFhirClinicalUseDefinition;
begin
  result := TFhirClinicalUseDefinition(inherited Clone);
end;

function TFhirClinicalUseDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirClinicalUseDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirClinicalUseDefinition)) then
    result := false
  else
  begin
    o := TFhirClinicalUseDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(contraindicationElement, o.contraindicationElement, true) and 
      compareDeep(indicationElement, o.indicationElement, true) and compareDeep(interactionElement, o.interactionElement, true) and 
      compareDeep(populationList, o.populationList, true) and compareDeep(undesirableEffectElement, o.undesirableEffectElement, true) and 
      compareDeep(warningElement, o.warningElement, true);
  end;
end;

function TFhirClinicalUseDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FcategoryList) and isEmptyProp(FsubjectList) and isEmptyProp(FStatus) and isEmptyProp(FContraindication) and isEmptyProp(FIndication) and isEmptyProp(FInteraction) and isEmptyProp(FpopulationList) and isEmptyProp(FUndesirableEffect) and isEmptyProp(FWarning);
end;

procedure TFhirClinicalUseDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('category');
  fields.add('subject');
  fields.add('status');
  fields.add('contraindication');
  fields.add('indication');
  fields.add('interaction');
  fields.add('population');
  fields.add('undesirableEffect');
  fields.add('warning');
end;

function TFhirClinicalUseDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FSubjectList.sizeInBytes(magic));
  inc(result, FPopulationList.sizeInBytes(magic));
end;

function TFhirClinicalUseDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirClinicalUseDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirClinicalUseDefinition.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirClinicalUseDefinition.GetType_ST : TFhirClinicalUseIssueTypeEnum;
begin
  if FType_ = nil then
    result := TFhirClinicalUseIssueTypeEnum(0)
  else
    result := TFhirClinicalUseIssueTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirClinicalUseIssueTypeEnum, FType_.value));
end;

procedure TFhirClinicalUseDefinition.SetType_ST(value : TFhirClinicalUseIssueTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirClinicalUseIssueTypeEnum[value], CODES_TFhirClinicalUseIssueTypeEnum[value]);
end;

function TFhirClinicalUseDefinition.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirClinicalUseDefinition.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

function TFhirClinicalUseDefinition.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirClinicalUseDefinition.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirClinicalUseDefinition.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirClinicalUseDefinition.SetContraindication(value : TFhirClinicalUseDefinitionContraindication);
begin
  FContraindication.free;
  FContraindication := value;
end;

procedure TFhirClinicalUseDefinition.SetIndication(value : TFhirClinicalUseDefinitionIndication);
begin
  FIndication.free;
  FIndication := value;
end;

procedure TFhirClinicalUseDefinition.SetInteraction(value : TFhirClinicalUseDefinitionInteraction);
begin
  FInteraction.free;
  FInteraction := value;
end;

function TFhirClinicalUseDefinition.GetPopulationList : TFhirReferenceList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirReferenceList.Create;
  result := FPopulationList;
end;

function TFhirClinicalUseDefinition.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

procedure TFhirClinicalUseDefinition.SetUndesirableEffect(value : TFhirClinicalUseDefinitionUndesirableEffect);
begin
  FUndesirableEffect.free;
  FUndesirableEffect := value;
end;

procedure TFhirClinicalUseDefinition.SetWarning(value : TFhirClinicalUseDefinitionWarning);
begin
  FWarning.free;
  FWarning := value;
end;

{ TFhirClinicalUseDefinitionListEnumerator }

constructor TFhirClinicalUseDefinitionListEnumerator.Create(list : TFhirClinicalUseDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirClinicalUseDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirClinicalUseDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirClinicalUseDefinitionListEnumerator.GetCurrent : TFhirClinicalUseDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirClinicalUseDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirClinicalUseDefinitionList }

function TFhirClinicalUseDefinitionList.AddItem(value: TFhirClinicalUseDefinition): TFhirClinicalUseDefinition;
begin
  assert(value.ClassName = 'TFhirClinicalUseDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirClinicalUseDefinition');
  add(value);
  result := value;
end;

function TFhirClinicalUseDefinitionList.Append: TFhirClinicalUseDefinition;
begin
  result := TFhirClinicalUseDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirClinicalUseDefinitionList.GetEnumerator : TFhirClinicalUseDefinitionListEnumerator;
begin
  result := TFhirClinicalUseDefinitionListEnumerator.Create(self.link);
end;

function TFhirClinicalUseDefinitionList.Clone: TFhirClinicalUseDefinitionList;
begin
  result := TFhirClinicalUseDefinitionList(inherited Clone);
end;

function TFhirClinicalUseDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirClinicalUseDefinitionList.GetItemN(index: Integer): TFhirClinicalUseDefinition;
begin
  result := TFhirClinicalUseDefinition(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirClinicalUseDefinition;
end;
function TFhirClinicalUseDefinitionList.IndexOf(value: TFhirClinicalUseDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirClinicalUseDefinitionList.Insert(index: Integer): TFhirClinicalUseDefinition;
begin
  result := TFhirClinicalUseDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirClinicalUseDefinitionList.InsertItem(index: Integer; value: TFhirClinicalUseDefinition);
begin
  assert(value is TFhirClinicalUseDefinition);
  Inherited Insert(index, value);
end;

function TFhirClinicalUseDefinitionList.Item(index: Integer): TFhirClinicalUseDefinition;
begin
  result := TFhirClinicalUseDefinition(ObjectByIndex[index]);
end;

function TFhirClinicalUseDefinitionList.Link: TFhirClinicalUseDefinitionList;
begin
  result := TFhirClinicalUseDefinitionList(inherited Link);
end;

procedure TFhirClinicalUseDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirClinicalUseDefinitionList.SetItemByIndex(index: Integer; value: TFhirClinicalUseDefinition);
begin
  assert(value is TFhirClinicalUseDefinition);
  FhirClinicalUseDefinitions[index] := value;
end;

procedure TFhirClinicalUseDefinitionList.SetItemN(index: Integer; value: TFhirClinicalUseDefinition);
begin
  assert(value is TFhirClinicalUseDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CLINICALUSEDEFINITION}
{$IFDEF FHIR_COMMUNICATION}
{ TFhirCommunicationPayload }

constructor TFhirCommunicationPayload.Create;
begin
  inherited;
end;

destructor TFhirCommunicationPayload.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirCommunicationPayload.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirCommunicationPayload(oSource).content.Clone;
end;

procedure TFhirCommunicationPayload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirCommunicationPayload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'string|Attachment|Reference', false, TFhirDataType, FContent.Link));
end;

function TFhirCommunicationPayload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationPayload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCommunicationPayload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content')
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationPayload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'string|Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationPayload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationPayload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationPayload.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationPayload.fhirType : string;
begin
  result := 'Communication.payload';
end;

function TFhirCommunicationPayload.Link : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(inherited Link);
end;

function TFhirCommunicationPayload.Clone : TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(inherited Clone);
end;

function TFhirCommunicationPayload.equals(other : TObject) : boolean; 
var
  o : TFhirCommunicationPayload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationPayload)) then
    result := false
  else
  begin
    o := TFhirCommunicationPayload(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirCommunicationPayload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirCommunicationPayload.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirCommunicationPayload.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCommunicationPayload.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value;
end;

{ TFhirCommunicationPayloadListEnumerator }

constructor TFhirCommunicationPayloadListEnumerator.Create(list : TFhirCommunicationPayloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationPayloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationPayloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationPayloadListEnumerator.GetCurrent : TFhirCommunicationPayload;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationPayloadListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCommunicationPayloadList }

function TFhirCommunicationPayloadList.AddItem(value: TFhirCommunicationPayload): TFhirCommunicationPayload;
begin
  assert(value.ClassName = 'TFhirCommunicationPayload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationPayload');
  add(value);
  result := value;
end;

function TFhirCommunicationPayloadList.Append: TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationPayloadList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationPayloadList.GetEnumerator : TFhirCommunicationPayloadListEnumerator;
begin
  result := TFhirCommunicationPayloadListEnumerator.Create(self.link);
end;

function TFhirCommunicationPayloadList.Clone: TFhirCommunicationPayloadList;
begin
  result := TFhirCommunicationPayloadList(inherited Clone);
end;

function TFhirCommunicationPayloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationPayloadList.GetItemN(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationPayloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationPayload;
end;
function TFhirCommunicationPayloadList.IndexOf(value: TFhirCommunicationPayload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationPayloadList.Insert(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationPayloadList.InsertItem(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  Inherited Insert(index, value);
end;

function TFhirCommunicationPayloadList.Item(index: Integer): TFhirCommunicationPayload;
begin
  result := TFhirCommunicationPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationPayloadList.Link: TFhirCommunicationPayloadList;
begin
  result := TFhirCommunicationPayloadList(inherited Link);
end;

procedure TFhirCommunicationPayloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationPayloadList.SetItemByIndex(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  FhirCommunicationPayloads[index] := value;
end;

procedure TFhirCommunicationPayloadList.SetItemN(index: Integer; value: TFhirCommunicationPayload);
begin
  assert(value is TFhirCommunicationPayload);
  ObjectByIndex[index] := value;
end;

{ TFhirCommunication }

constructor TFhirCommunication.Create;
begin
  inherited;
end;

destructor TFhirCommunication.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FInResponseToList.Free;
  FStatus.free;
  FStatusReason.free;
  FCategoryList.Free;
  FPriority.free;
  FMediumList.Free;
  FSubject.free;
  FTopic.free;
  FAboutList.Free;
  FEncounter.free;
  FSent.free;
  FReceived.free;
  FRecipientList.Free;
  FSender.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FPayloadList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCommunication(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCommunication(oSource).FIdentifierList);
  end;
  if (TFhirCommunication(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirCommunication(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirCommunication(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirCommunication(oSource).FInstantiatesUriList);
  end;
  if (TFhirCommunication(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirCommunication(oSource).FBasedOnList);
  end;
  if (TFhirCommunication(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirCommunication(oSource).FPartOfList);
  end;
  if (TFhirCommunication(oSource).FInResponseToList = nil) then
  begin
    FInResponseToList.free;
    FInResponseToList := nil;
  end
  else
  begin
    if FInResponseToList = nil then
      FInResponseToList := TFhirReferenceList.Create;
    FInResponseToList.Assign(TFhirCommunication(oSource).FInResponseToList);
  end;
  statusElement := TFhirCommunication(oSource).statusElement.Clone;
  statusReason := TFhirCommunication(oSource).statusReason.Clone;
  if (TFhirCommunication(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCommunication(oSource).FCategoryList);
  end;
  priorityElement := TFhirCommunication(oSource).priorityElement.Clone;
  if (TFhirCommunication(oSource).FMediumList = nil) then
  begin
    FMediumList.free;
    FMediumList := nil;
  end
  else
  begin
    if FMediumList = nil then
      FMediumList := TFhirCodeableConceptList.Create;
    FMediumList.Assign(TFhirCommunication(oSource).FMediumList);
  end;
  subject := TFhirCommunication(oSource).subject.Clone;
  topic := TFhirCommunication(oSource).topic.Clone;
  if (TFhirCommunication(oSource).FAboutList = nil) then
  begin
    FAboutList.free;
    FAboutList := nil;
  end
  else
  begin
    if FAboutList = nil then
      FAboutList := TFhirReferenceList.Create;
    FAboutList.Assign(TFhirCommunication(oSource).FAboutList);
  end;
  encounter := TFhirCommunication(oSource).encounter.Clone;
  sentElement := TFhirCommunication(oSource).sentElement.Clone;
  receivedElement := TFhirCommunication(oSource).receivedElement.Clone;
  if (TFhirCommunication(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList.Create;
    FRecipientList.Assign(TFhirCommunication(oSource).FRecipientList);
  end;
  sender := TFhirCommunication(oSource).sender.Clone;
  if (TFhirCommunication(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirCommunication(oSource).FReasonCodeList);
  end;
  if (TFhirCommunication(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirCommunication(oSource).FReasonReferenceList);
  end;
  if (TFhirCommunication(oSource).FPayloadList = nil) then
  begin
    FPayloadList.free;
    FPayloadList := nil;
  end
  else
  begin
    if FPayloadList = nil then
      FPayloadList := TFhirCommunicationPayloadList.Create;
    FPayloadList.Assign(TFhirCommunication(oSource).FPayloadList);
  end;
  if (TFhirCommunication(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCommunication(oSource).FNoteList);
  end;
end;

function TFhirCommunication.GetResourceType : TFhirResourceType;
begin
  result := frtCommunication;
end;

procedure TFhirCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'inResponseTo') Then
    list.addAll(self, 'inResponseTo', FInResponseToList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'medium') Then
    list.addAll(self, 'medium', FMediumList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'topic') Then
     list.add(self.link, 'topic', FTopic.Link);
  if (child_name = 'about') Then
    list.addAll(self, 'about', FAboutList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'sent') Then
     list.add(self.link, 'sent', FSent.Link);
  if (child_name = 'received') Then
     list.add(self.link, 'received', FReceived.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'payload') Then
    list.addAll(self, 'payload', FPayloadList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'inResponseTo', 'Reference', true, TFhirReference, FInResponseToList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'medium', 'CodeableConcept', true, TFhirCodeableConcept, FMediumList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', false, TFhirCodeableConcept, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'about', 'Reference', true, TFhirReference, FAboutList.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'sent', 'dateTime', false, TFhirDateTime, FSent.Link));
  oList.add(TFHIRProperty.create(self, 'received', 'dateTime', false, TFhirDateTime, FReceived.Link));
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', true, TFhirReference, FRecipientList.Link));
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference', false, TFhirReference, FSender.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'payload', 'BackboneElement', true, TFhirCommunicationPayload, FPayloadList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'inResponseTo') then
  begin
    InResponseToList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'medium') then
  begin
    MediumList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    Topic := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'about') then
  begin
    AboutList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'sent') then
  begin
    SentElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'received') then
  begin
    ReceivedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadList.add(propValue as TFhirCommunicationPayload);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'inResponseTo') then InResponseToList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'medium') then MediumList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'about') then AboutList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'payload') then PayloadList.insertItem(index, propValue as TFhirCommunicationPayload)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'inResponseTo') then result := InResponseToList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[EventStatusNull], CODES_TFhirEventStatusEnum[EventStatusNull]) 
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'medium') then result := MediumList.new()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'topic') then result := TFhirCodeableConcept.create()
  else if (propName = 'about') then result := AboutList.new()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'sent') then result := TFhirDateTime.create()
  else if (propName = 'received') then result := TFhirDateTime.create()
  else if (propName = 'recipient') then result := RecipientList.new()
  else if (propName = 'sender') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'payload') then result := PayloadList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'inResponseTo') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'medium') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'about') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'sent') then result := 'dateTime'
  else if (propName = 'received') then result := 'dateTime'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'payload') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'inResponseTo') then deletePropertyValue('inResponseTo', InResponseToList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'medium') then deletePropertyValue('medium', MediumList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'topic') then TopicElement := nil
  else if (propName = 'about') then deletePropertyValue('about', AboutList, value)
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'sent') then SentElement := nil
  else if (propName = 'received') then ReceivedElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value)
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'payload') then deletePropertyValue('payload', PayloadList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'inResponseTo') then replacePropertyValue('inResponseTo', InResponseToList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, new)
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'medium') then replacePropertyValue('medium', MediumList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'topic') then TopicElement := new as TFhirCodeableConcept
  else if (propName = 'about') then replacePropertyValue('about', AboutList, existing, new)
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'sent') then SentElement := asDateTime(new)
  else if (propName = 'received') then ReceivedElement := asDateTime(new)
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new)
  else if (propName = 'sender') then SenderElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'payload') then replacePropertyValue('payload', PayloadList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'inResponseTo') then InResponseToList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'medium') then MediumList.move(source, destination)
  else if (propName = 'about') then AboutList.move(source, destination)
  else if (propName = 'recipient') then RecipientList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'payload') then PayloadList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunication.fhirType : string;
begin
  result := 'Communication';
end;

function TFhirCommunication.Link : TFhirCommunication;
begin
  result := TFhirCommunication(inherited Link);
end;

function TFhirCommunication.Clone : TFhirCommunication;
begin
  result := TFhirCommunication(inherited Clone);
end;

function TFhirCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunication)) then
    result := false
  else
  begin
    o := TFhirCommunication(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(inResponseToList, o.inResponseToList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(mediumList, o.mediumList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(topicElement, o.topicElement, true) and compareDeep(aboutList, o.aboutList, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(sentElement, o.sentElement, true) and 
      compareDeep(receivedElement, o.receivedElement, true) and compareDeep(recipientList, o.recipientList, true) and 
      compareDeep(senderElement, o.senderElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(payloadList, o.payloadList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FinResponseToList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FmediumList) and isEmptyProp(FSubject) and isEmptyProp(FTopic) and isEmptyProp(FaboutList) and isEmptyProp(FEncounter) and isEmptyProp(FSent) and isEmptyProp(FReceived) and isEmptyProp(FrecipientList) and isEmptyProp(FSender) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FpayloadList) and isEmptyProp(FnoteList);
end;

procedure TFhirCommunication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('inResponseTo');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('priority');
  fields.add('medium');
  fields.add('subject');
  fields.add('topic');
  fields.add('about');
  fields.add('encounter');
  fields.add('sent');
  fields.add('received');
  fields.add('recipient');
  fields.add('sender');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('payload');
  fields.add('note');
end;

function TFhirCommunication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FInResponseToList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FMediumList.sizeInBytes(magic));
  inc(result, FAboutList.sizeInBytes(magic));
  inc(result, FRecipientList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FPayloadList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirCommunication.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCommunication.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCommunication.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirCommunication.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirCommunication.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirCommunication.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirCommunication.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirCommunication.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirCommunication.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirCommunication.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

function TFhirCommunication.GetInResponseToList : TFhirReferenceList;
begin
  if FInResponseToList = nil then
    FInResponseToList := TFhirReferenceList.Create;
  result := FInResponseToList;
end;

function TFhirCommunication.GetHasInResponseToList : boolean;
begin
  result := (FInResponseToList <> nil) and (FInResponseToList.count > 0);
end;

procedure TFhirCommunication.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCommunication.GetStatusST : TFhirEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEventStatusEnum(0)
  else
    result := TFhirEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEventStatusEnum, FStatus.value));
end;

procedure TFhirCommunication.SetStatusST(value : TFhirEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[value], CODES_TFhirEventStatusEnum[value]);
end;

procedure TFhirCommunication.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

function TFhirCommunication.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCommunication.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCommunication.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirCommunication.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirCommunication.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

function TFhirCommunication.GetMediumList : TFhirCodeableConceptList;
begin
  if FMediumList = nil then
    FMediumList := TFhirCodeableConceptList.Create;
  result := FMediumList;
end;

function TFhirCommunication.GetHasMediumList : boolean;
begin
  result := (FMediumList <> nil) and (FMediumList.count > 0);
end;

procedure TFhirCommunication.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirCommunication.SetTopic(value : TFhirCodeableConcept);
begin
  FTopic.free;
  FTopic := value;
end;

function TFhirCommunication.GetAboutList : TFhirReferenceList;
begin
  if FAboutList = nil then
    FAboutList := TFhirReferenceList.Create;
  result := FAboutList;
end;

function TFhirCommunication.GetHasAboutList : boolean;
begin
  result := (FAboutList <> nil) and (FAboutList.count > 0);
end;

procedure TFhirCommunication.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirCommunication.SetSent(value : TFhirDateTime);
begin
  FSent.free;
  FSent := value;
end;

function TFhirCommunication.GetSentST : TFslDateTime;
begin
  if FSent = nil then
    result := TFslDateTime.makeNull
  else
    result := FSent.value;
end;

procedure TFhirCommunication.SetSentST(value : TFslDateTime);
begin
  if FSent = nil then
    FSent := TFhirDateTime.create;
  FSent.value := value
end;

procedure TFhirCommunication.SetReceived(value : TFhirDateTime);
begin
  FReceived.free;
  FReceived := value;
end;

function TFhirCommunication.GetReceivedST : TFslDateTime;
begin
  if FReceived = nil then
    result := TFslDateTime.makeNull
  else
    result := FReceived.value;
end;

procedure TFhirCommunication.SetReceivedST(value : TFslDateTime);
begin
  if FReceived = nil then
    FReceived := TFhirDateTime.create;
  FReceived.value := value
end;

function TFhirCommunication.GetRecipientList : TFhirReferenceList;
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList.Create;
  result := FRecipientList;
end;

function TFhirCommunication.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

procedure TFhirCommunication.SetSender(value : TFhirReference);
begin
  FSender.free;
  FSender := value;
end;

function TFhirCommunication.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirCommunication.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirCommunication.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirCommunication.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirCommunication.GetPayloadList : TFhirCommunicationPayloadList;
begin
  if FPayloadList = nil then
    FPayloadList := TFhirCommunicationPayloadList.Create;
  result := FPayloadList;
end;

function TFhirCommunication.GetHasPayloadList : boolean;
begin
  result := (FPayloadList <> nil) and (FPayloadList.count > 0);
end;

function TFhirCommunication.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCommunication.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirCommunicationListEnumerator }

constructor TFhirCommunicationListEnumerator.Create(list : TFhirCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationListEnumerator.GetCurrent : TFhirCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCommunicationList }

function TFhirCommunicationList.AddItem(value: TFhirCommunication): TFhirCommunication;
begin
  assert(value.ClassName = 'TFhirCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunication');
  add(value);
  result := value;
end;

function TFhirCommunicationList.Append: TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationList.GetEnumerator : TFhirCommunicationListEnumerator;
begin
  result := TFhirCommunicationListEnumerator.Create(self.link);
end;

function TFhirCommunicationList.Clone: TFhirCommunicationList;
begin
  result := TFhirCommunicationList(inherited Clone);
end;

function TFhirCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationList.GetItemN(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication(ObjectByIndex[index]);
end;

function TFhirCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunication;
end;
function TFhirCommunicationList.IndexOf(value: TFhirCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationList.Insert(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationList.InsertItem(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  Inherited Insert(index, value);
end;

function TFhirCommunicationList.Item(index: Integer): TFhirCommunication;
begin
  result := TFhirCommunication(ObjectByIndex[index]);
end;

function TFhirCommunicationList.Link: TFhirCommunicationList;
begin
  result := TFhirCommunicationList(inherited Link);
end;

procedure TFhirCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationList.SetItemByIndex(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  FhirCommunications[index] := value;
end;

procedure TFhirCommunicationList.SetItemN(index: Integer; value: TFhirCommunication);
begin
  assert(value is TFhirCommunication);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMMUNICATION}
{$IFDEF FHIR_COMMUNICATIONREQUEST}
{ TFhirCommunicationRequestPayload }

constructor TFhirCommunicationRequestPayload.Create;
begin
  inherited;
end;

destructor TFhirCommunicationRequestPayload.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirCommunicationRequestPayload.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirCommunicationRequestPayload(oSource).content.Clone;
end;

procedure TFhirCommunicationRequestPayload.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirCommunicationRequestPayload.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'string|Attachment|Reference', false, TFhirDataType, FContent.Link));
end;

function TFhirCommunicationRequestPayload.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationRequestPayload.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCommunicationRequestPayload.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content')
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationRequestPayload.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'string|Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationRequestPayload.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationRequestPayload.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['String', 'Attachment', 'Reference'])) then ContentElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationRequestPayload.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationRequestPayload.fhirType : string;
begin
  result := 'CommunicationRequest.payload';
end;

function TFhirCommunicationRequestPayload.Link : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(inherited Link);
end;

function TFhirCommunicationRequestPayload.Clone : TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(inherited Clone);
end;

function TFhirCommunicationRequestPayload.equals(other : TObject) : boolean; 
var
  o : TFhirCommunicationRequestPayload;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationRequestPayload)) then
    result := false
  else
  begin
    o := TFhirCommunicationRequestPayload(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirCommunicationRequestPayload.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirCommunicationRequestPayload.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirCommunicationRequestPayload.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCommunicationRequestPayload.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value;
end;

{ TFhirCommunicationRequestPayloadListEnumerator }

constructor TFhirCommunicationRequestPayloadListEnumerator.Create(list : TFhirCommunicationRequestPayloadList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationRequestPayloadListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationRequestPayloadListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationRequestPayloadListEnumerator.GetCurrent : TFhirCommunicationRequestPayload;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationRequestPayloadListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCommunicationRequestPayloadList }

function TFhirCommunicationRequestPayloadList.AddItem(value: TFhirCommunicationRequestPayload): TFhirCommunicationRequestPayload;
begin
  assert(value.ClassName = 'TFhirCommunicationRequestPayload', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationRequestPayload');
  add(value);
  result := value;
end;

function TFhirCommunicationRequestPayloadList.Append: TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestPayloadList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationRequestPayloadList.GetEnumerator : TFhirCommunicationRequestPayloadListEnumerator;
begin
  result := TFhirCommunicationRequestPayloadListEnumerator.Create(self.link);
end;

function TFhirCommunicationRequestPayloadList.Clone: TFhirCommunicationRequestPayloadList;
begin
  result := TFhirCommunicationRequestPayloadList(inherited Clone);
end;

function TFhirCommunicationRequestPayloadList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationRequestPayloadList.GetItemN(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestPayloadList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationRequestPayload;
end;
function TFhirCommunicationRequestPayloadList.IndexOf(value: TFhirCommunicationRequestPayload): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationRequestPayloadList.Insert(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestPayloadList.InsertItem(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  Inherited Insert(index, value);
end;

function TFhirCommunicationRequestPayloadList.Item(index: Integer): TFhirCommunicationRequestPayload;
begin
  result := TFhirCommunicationRequestPayload(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestPayloadList.Link: TFhirCommunicationRequestPayloadList;
begin
  result := TFhirCommunicationRequestPayloadList(inherited Link);
end;

procedure TFhirCommunicationRequestPayloadList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationRequestPayloadList.SetItemByIndex(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  FhirCommunicationRequestPayloads[index] := value;
end;

procedure TFhirCommunicationRequestPayloadList.SetItemN(index: Integer; value: TFhirCommunicationRequestPayload);
begin
  assert(value is TFhirCommunicationRequestPayload);
  ObjectByIndex[index] := value;
end;

{ TFhirCommunicationRequest }

constructor TFhirCommunicationRequest.Create;
begin
  inherited;
end;

destructor TFhirCommunicationRequest.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FStatusReason.free;
  FCategoryList.Free;
  FPriority.free;
  FDoNotPerform.free;
  FMediumList.Free;
  FSubject.free;
  FAboutList.Free;
  FEncounter.free;
  FPayloadList.Free;
  FOccurrence.free;
  FAuthoredOn.free;
  FRequester.free;
  FRecipientList.Free;
  FSender.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCommunicationRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCommunicationRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCommunicationRequest(oSource).FIdentifierList);
  end;
  if (TFhirCommunicationRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirCommunicationRequest(oSource).FBasedOnList);
  end;
  if (TFhirCommunicationRequest(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList.Create;
    FReplacesList.Assign(TFhirCommunicationRequest(oSource).FReplacesList);
  end;
  groupIdentifier := TFhirCommunicationRequest(oSource).groupIdentifier.Clone;
  statusElement := TFhirCommunicationRequest(oSource).statusElement.Clone;
  statusReason := TFhirCommunicationRequest(oSource).statusReason.Clone;
  if (TFhirCommunicationRequest(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCommunicationRequest(oSource).FCategoryList);
  end;
  priorityElement := TFhirCommunicationRequest(oSource).priorityElement.Clone;
  doNotPerformElement := TFhirCommunicationRequest(oSource).doNotPerformElement.Clone;
  if (TFhirCommunicationRequest(oSource).FMediumList = nil) then
  begin
    FMediumList.free;
    FMediumList := nil;
  end
  else
  begin
    if FMediumList = nil then
      FMediumList := TFhirCodeableConceptList.Create;
    FMediumList.Assign(TFhirCommunicationRequest(oSource).FMediumList);
  end;
  subject := TFhirCommunicationRequest(oSource).subject.Clone;
  if (TFhirCommunicationRequest(oSource).FAboutList = nil) then
  begin
    FAboutList.free;
    FAboutList := nil;
  end
  else
  begin
    if FAboutList = nil then
      FAboutList := TFhirReferenceList.Create;
    FAboutList.Assign(TFhirCommunicationRequest(oSource).FAboutList);
  end;
  encounter := TFhirCommunicationRequest(oSource).encounter.Clone;
  if (TFhirCommunicationRequest(oSource).FPayloadList = nil) then
  begin
    FPayloadList.free;
    FPayloadList := nil;
  end
  else
  begin
    if FPayloadList = nil then
      FPayloadList := TFhirCommunicationRequestPayloadList.Create;
    FPayloadList.Assign(TFhirCommunicationRequest(oSource).FPayloadList);
  end;
  occurrence := TFhirCommunicationRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirCommunicationRequest(oSource).authoredOnElement.Clone;
  requester := TFhirCommunicationRequest(oSource).requester.Clone;
  if (TFhirCommunicationRequest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList.Create;
    FRecipientList.Assign(TFhirCommunicationRequest(oSource).FRecipientList);
  end;
  sender := TFhirCommunicationRequest(oSource).sender.Clone;
  if (TFhirCommunicationRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirCommunicationRequest(oSource).FReasonCodeList);
  end;
  if (TFhirCommunicationRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirCommunicationRequest(oSource).FReasonReferenceList);
  end;
  if (TFhirCommunicationRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCommunicationRequest(oSource).FNoteList);
  end;
end;

function TFhirCommunicationRequest.GetResourceType : TFhirResourceType;
begin
  result := frtCommunicationRequest;
end;

procedure TFhirCommunicationRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'medium') Then
    list.addAll(self, 'medium', FMediumList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'about') Then
    list.addAll(self, 'about', FAboutList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'payload') Then
    list.addAll(self, 'payload', FPayloadList);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCommunicationRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference', true, TFhirReference, FReplacesList.Link));
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));
  oList.add(TFHIRProperty.create(self, 'medium', 'CodeableConcept', true, TFhirCodeableConcept, FMediumList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'about', 'Reference', true, TFhirReference, FAboutList.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'payload', 'BackboneElement', true, TFhirCommunicationRequestPayload, FPayloadList.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link));
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', true, TFhirReference, FRecipientList.Link));
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference', false, TFhirReference, FSender.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirCommunicationRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'medium') then
  begin
    MediumList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'about') then
  begin
    AboutList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadList.add(propValue as TFhirCommunicationRequestPayload);
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCommunicationRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'medium') then MediumList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'about') then AboutList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'payload') then PayloadList.insertItem(index, propValue as TFhirCommunicationRequestPayload)
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirCommunicationRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'replaces') then result := ReplacesList.new()
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull]) 
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create()
  else if (propName = 'medium') then result := MediumList.new()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'about') then result := AboutList.new()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'payload') then result := PayloadList.new()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'requester') then result := TFhirReference.create()
  else if (propName = 'recipient') then result := RecipientList.new()
  else if (propName = 'sender') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCommunicationRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'medium') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'about') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'payload') then result := 'BackboneElement'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCommunicationRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'medium') then deletePropertyValue('medium', MediumList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'about') then deletePropertyValue('about', AboutList, value)
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'payload') then deletePropertyValue('payload', PayloadList, value)
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value)
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCommunicationRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new)
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new)
  else if (propName = 'medium') then replacePropertyValue('medium', MediumList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'about') then replacePropertyValue('about', AboutList, existing, new)
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'payload') then replacePropertyValue('payload', PayloadList, existing, new)
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := new as TFhirDataType
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'requester') then RequesterElement := new as TFhirReference
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new)
  else if (propName = 'sender') then SenderElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCommunicationRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'replaces') then ReplacesList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'medium') then MediumList.move(source, destination)
  else if (propName = 'about') then AboutList.move(source, destination)
  else if (propName = 'payload') then PayloadList.move(source, destination)
  else if (propName = 'recipient') then RecipientList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCommunicationRequest.fhirType : string;
begin
  result := 'CommunicationRequest';
end;

function TFhirCommunicationRequest.Link : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(inherited Link);
end;

function TFhirCommunicationRequest.Clone : TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(inherited Clone);
end;

function TFhirCommunicationRequest.equals(other : TObject) : boolean; 
var
  o : TFhirCommunicationRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCommunicationRequest)) then
    result := false
  else
  begin
    o := TFhirCommunicationRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(doNotPerformElement, o.doNotPerformElement, true) and compareDeep(mediumList, o.mediumList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(aboutList, o.aboutList, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(payloadList, o.payloadList, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(authoredOnElement, o.authoredOnElement, true) and 
      compareDeep(requesterElement, o.requesterElement, true) and compareDeep(recipientList, o.recipientList, true) and 
      compareDeep(senderElement, o.senderElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCommunicationRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform) and isEmptyProp(FmediumList) and isEmptyProp(FSubject) and isEmptyProp(FaboutList) and isEmptyProp(FEncounter) and isEmptyProp(FpayloadList) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FrecipientList) and isEmptyProp(FSender) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList);
end;

procedure TFhirCommunicationRequest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('medium');
  fields.add('subject');
  fields.add('about');
  fields.add('encounter');
  fields.add('payload');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('recipient');
  fields.add('sender');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
end;

function TFhirCommunicationRequest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FReplacesList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FMediumList.sizeInBytes(magic));
  inc(result, FAboutList.sizeInBytes(magic));
  inc(result, FPayloadList.sizeInBytes(magic));
  inc(result, FRecipientList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirCommunicationRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCommunicationRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirCommunicationRequest.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirCommunicationRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirCommunicationRequest.GetReplacesList : TFhirReferenceList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList.Create;
  result := FReplacesList;
end;

function TFhirCommunicationRequest.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirCommunicationRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

procedure TFhirCommunicationRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCommunicationRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirCommunicationRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirCommunicationRequest.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

function TFhirCommunicationRequest.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCommunicationRequest.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCommunicationRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirCommunicationRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirCommunicationRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirCommunicationRequest.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

function TFhirCommunicationRequest.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirCommunicationRequest.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

function TFhirCommunicationRequest.GetMediumList : TFhirCodeableConceptList;
begin
  if FMediumList = nil then
    FMediumList := TFhirCodeableConceptList.Create;
  result := FMediumList;
end;

function TFhirCommunicationRequest.GetHasMediumList : boolean;
begin
  result := (FMediumList <> nil) and (FMediumList.count > 0);
end;

procedure TFhirCommunicationRequest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

function TFhirCommunicationRequest.GetAboutList : TFhirReferenceList;
begin
  if FAboutList = nil then
    FAboutList := TFhirReferenceList.Create;
  result := FAboutList;
end;

function TFhirCommunicationRequest.GetHasAboutList : boolean;
begin
  result := (FAboutList <> nil) and (FAboutList.count > 0);
end;

procedure TFhirCommunicationRequest.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

function TFhirCommunicationRequest.GetPayloadList : TFhirCommunicationRequestPayloadList;
begin
  if FPayloadList = nil then
    FPayloadList := TFhirCommunicationRequestPayloadList.Create;
  result := FPayloadList;
end;

function TFhirCommunicationRequest.GetHasPayloadList : boolean;
begin
  result := (FPayloadList <> nil) and (FPayloadList.count > 0);
end;

procedure TFhirCommunicationRequest.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

procedure TFhirCommunicationRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirCommunicationRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirCommunicationRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirCommunicationRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value;
end;

function TFhirCommunicationRequest.GetRecipientList : TFhirReferenceList;
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList.Create;
  result := FRecipientList;
end;

function TFhirCommunicationRequest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

procedure TFhirCommunicationRequest.SetSender(value : TFhirReference);
begin
  FSender.free;
  FSender := value;
end;

function TFhirCommunicationRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirCommunicationRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirCommunicationRequest.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirCommunicationRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirCommunicationRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCommunicationRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirCommunicationRequestListEnumerator }

constructor TFhirCommunicationRequestListEnumerator.Create(list : TFhirCommunicationRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCommunicationRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCommunicationRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCommunicationRequestListEnumerator.GetCurrent : TFhirCommunicationRequest;
begin
  Result := FList[FIndex];
end;

function TFhirCommunicationRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCommunicationRequestList }

function TFhirCommunicationRequestList.AddItem(value: TFhirCommunicationRequest): TFhirCommunicationRequest;
begin
  assert(value.ClassName = 'TFhirCommunicationRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCommunicationRequest');
  add(value);
  result := value;
end;

function TFhirCommunicationRequestList.Append: TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestList.ClearItems;
begin
  Clear;
end;

function TFhirCommunicationRequestList.GetEnumerator : TFhirCommunicationRequestListEnumerator;
begin
  result := TFhirCommunicationRequestListEnumerator.Create(self.link);
end;

function TFhirCommunicationRequestList.Clone: TFhirCommunicationRequestList;
begin
  result := TFhirCommunicationRequestList(inherited Clone);
end;

function TFhirCommunicationRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCommunicationRequestList.GetItemN(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirCommunicationRequest;
end;
function TFhirCommunicationRequestList.IndexOf(value: TFhirCommunicationRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCommunicationRequestList.Insert(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCommunicationRequestList.InsertItem(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  Inherited Insert(index, value);
end;

function TFhirCommunicationRequestList.Item(index: Integer): TFhirCommunicationRequest;
begin
  result := TFhirCommunicationRequest(ObjectByIndex[index]);
end;

function TFhirCommunicationRequestList.Link: TFhirCommunicationRequestList;
begin
  result := TFhirCommunicationRequestList(inherited Link);
end;

procedure TFhirCommunicationRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCommunicationRequestList.SetItemByIndex(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  FhirCommunicationRequests[index] := value;
end;

procedure TFhirCommunicationRequestList.SetItemN(index: Integer; value: TFhirCommunicationRequest);
begin
  assert(value is TFhirCommunicationRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMMUNICATIONREQUEST}
{$IFDEF FHIR_COMPOSITION}
{ TFhirCompositionAttester }

constructor TFhirCompositionAttester.Create;
begin
  inherited;
end;

destructor TFhirCompositionAttester.Destroy;
begin
  FMode.free;
  FTime.free;
  FParty.free;
  inherited;
end;

procedure TFhirCompositionAttester.Assign(oSource : TFslObject);
begin
  inherited;
  modeElement := TFhirCompositionAttester(oSource).modeElement.Clone;
  timeElement := TFhirCompositionAttester(oSource).timeElement.Clone;
  party := TFhirCompositionAttester(oSource).party.Clone;
end;

procedure TFhirCompositionAttester.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
end;

procedure TFhirCompositionAttester.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'time', 'dateTime', false, TFhirDateTime, FTime.Link));
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link));
end;

function TFhirCompositionAttester.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionAttester.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCompositionAttester.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirCompositionAttestationModeEnum[CompositionAttestationModeNull], CODES_TFhirCompositionAttestationModeEnum[CompositionAttestationModeNull]) 
  else if (propName = 'time') then result := TFhirDateTime.create()
  else if (propName = 'party') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionAttester.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'time') then result := 'dateTime'
  else if (propName = 'party') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionAttester.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'time') then TimeElement := nil
  else if (propName = 'party') then PartyElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionAttester.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirCompositionAttestationModeEnum, CODES_TFhirCompositionAttestationModeEnum, new)
  else if (propName = 'time') then TimeElement := asDateTime(new)
  else if (propName = 'party') then PartyElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionAttester.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionAttester.fhirType : string;
begin
  result := 'Composition.attester';
end;

function TFhirCompositionAttester.Link : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Link);
end;

function TFhirCompositionAttester.Clone : TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(inherited Clone);
end;

function TFhirCompositionAttester.equals(other : TObject) : boolean; 
var
  o : TFhirCompositionAttester;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionAttester)) then
    result := false
  else
  begin
    o := TFhirCompositionAttester(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(timeElement, o.timeElement, true) and 
      compareDeep(partyElement, o.partyElement, true);
  end;
end;

function TFhirCompositionAttester.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FTime) and isEmptyProp(FParty);
end;

procedure TFhirCompositionAttester.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('mode');
  fields.add('time');
  fields.add('party');
end;

function TFhirCompositionAttester.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCompositionAttester.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirCompositionAttester.GetModeST : TFhirCompositionAttestationModeEnum;
begin
  if FMode = nil then
    result := TFhirCompositionAttestationModeEnum(0)
  else
    result := TFhirCompositionAttestationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionAttestationModeEnum, FMode.value));
end;

procedure TFhirCompositionAttester.SetModeST(value : TFhirCompositionAttestationModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirCompositionAttestationModeEnum[value], CODES_TFhirCompositionAttestationModeEnum[value]);
end;

procedure TFhirCompositionAttester.SetTime(value : TFhirDateTime);
begin
  FTime.free;
  FTime := value;
end;

function TFhirCompositionAttester.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

procedure TFhirCompositionAttester.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirDateTime.create;
  FTime.value := value
end;

procedure TFhirCompositionAttester.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value;
end;

{ TFhirCompositionAttesterListEnumerator }

constructor TFhirCompositionAttesterListEnumerator.Create(list : TFhirCompositionAttesterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionAttesterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionAttesterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionAttesterListEnumerator.GetCurrent : TFhirCompositionAttester;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionAttesterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCompositionAttesterList }

function TFhirCompositionAttesterList.AddItem(value: TFhirCompositionAttester): TFhirCompositionAttester;
begin
  assert(value.ClassName = 'TFhirCompositionAttester', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionAttester');
  add(value);
  result := value;
end;

function TFhirCompositionAttesterList.Append: TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionAttesterList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionAttesterList.GetEnumerator : TFhirCompositionAttesterListEnumerator;
begin
  result := TFhirCompositionAttesterListEnumerator.Create(self.link);
end;

function TFhirCompositionAttesterList.Clone: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Clone);
end;

function TFhirCompositionAttesterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionAttesterList.GetItemN(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionAttester;
end;
function TFhirCompositionAttesterList.IndexOf(value: TFhirCompositionAttester): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionAttesterList.Insert(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionAttesterList.InsertItem(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  Inherited Insert(index, value);
end;

function TFhirCompositionAttesterList.Item(index: Integer): TFhirCompositionAttester;
begin
  result := TFhirCompositionAttester(ObjectByIndex[index]);
end;

function TFhirCompositionAttesterList.Link: TFhirCompositionAttesterList;
begin
  result := TFhirCompositionAttesterList(inherited Link);
end;

procedure TFhirCompositionAttesterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionAttesterList.SetItemByIndex(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  FhirCompositionAttesters[index] := value;
end;

procedure TFhirCompositionAttesterList.SetItemN(index: Integer; value: TFhirCompositionAttester);
begin
  assert(value is TFhirCompositionAttester);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionRelatesTo }

constructor TFhirCompositionRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirCompositionRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirCompositionRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirCompositionRelatesTo(oSource).codeElement.Clone;
  target := TFhirCompositionRelatesTo(oSource).target.Clone;
end;

procedure TFhirCompositionRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
end;

procedure TFhirCompositionRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'target[x]', 'Identifier|Reference', false, TFhirDataType, FTarget.Link));
end;

function TFhirCompositionRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then
  begin
    Target := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCompositionRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[DocumentRelationshipTypeNull], CODES_TFhirDocumentRelationshipTypeEnum[DocumentRelationshipTypeNull]) 
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then raise EFHIRException.create('Cannot make property Target')
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'target[x]') then result := 'Identifier|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, new)
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then TargetElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionRelatesTo.fhirType : string;
begin
  result := 'Composition.relatesTo';
end;

function TFhirCompositionRelatesTo.Link : TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(inherited Link);
end;

function TFhirCompositionRelatesTo.Clone : TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(inherited Clone);
end;

function TFhirCompositionRelatesTo.equals(other : TObject) : boolean; 
var
  o : TFhirCompositionRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionRelatesTo)) then
    result := false
  else
  begin
    o := TFhirCompositionRelatesTo(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirCompositionRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FTarget);
end;

procedure TFhirCompositionRelatesTo.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('target[x]');
end;

function TFhirCompositionRelatesTo.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCompositionRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCompositionRelatesTo.GetCodeST : TFhirDocumentRelationshipTypeEnum;
begin
  if FCode = nil then
    result := TFhirDocumentRelationshipTypeEnum(0)
  else
    result := TFhirDocumentRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentRelationshipTypeEnum, FCode.value));
end;

procedure TFhirCompositionRelatesTo.SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[value], CODES_TFhirDocumentRelationshipTypeEnum[value]);
end;

procedure TFhirCompositionRelatesTo.SetTarget(value : TFhirDataType);
begin
  FTarget.free;
  FTarget := value;
end;

{ TFhirCompositionRelatesToListEnumerator }

constructor TFhirCompositionRelatesToListEnumerator.Create(list : TFhirCompositionRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionRelatesToListEnumerator.GetCurrent : TFhirCompositionRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionRelatesToListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCompositionRelatesToList }

function TFhirCompositionRelatesToList.AddItem(value: TFhirCompositionRelatesTo): TFhirCompositionRelatesTo;
begin
  assert(value.ClassName = 'TFhirCompositionRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionRelatesTo');
  add(value);
  result := value;
end;

function TFhirCompositionRelatesToList.Append: TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionRelatesToList.GetEnumerator : TFhirCompositionRelatesToListEnumerator;
begin
  result := TFhirCompositionRelatesToListEnumerator.Create(self.link);
end;

function TFhirCompositionRelatesToList.Clone: TFhirCompositionRelatesToList;
begin
  result := TFhirCompositionRelatesToList(inherited Clone);
end;

function TFhirCompositionRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionRelatesToList.GetItemN(index: Integer): TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(ObjectByIndex[index]);
end;

function TFhirCompositionRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionRelatesTo;
end;
function TFhirCompositionRelatesToList.IndexOf(value: TFhirCompositionRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionRelatesToList.Insert(index: Integer): TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionRelatesToList.InsertItem(index: Integer; value: TFhirCompositionRelatesTo);
begin
  assert(value is TFhirCompositionRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirCompositionRelatesToList.Item(index: Integer): TFhirCompositionRelatesTo;
begin
  result := TFhirCompositionRelatesTo(ObjectByIndex[index]);
end;

function TFhirCompositionRelatesToList.Link: TFhirCompositionRelatesToList;
begin
  result := TFhirCompositionRelatesToList(inherited Link);
end;

procedure TFhirCompositionRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionRelatesToList.SetItemByIndex(index: Integer; value: TFhirCompositionRelatesTo);
begin
  assert(value is TFhirCompositionRelatesTo);
  FhirCompositionRelatesTos[index] := value;
end;

procedure TFhirCompositionRelatesToList.SetItemN(index: Integer; value: TFhirCompositionRelatesTo);
begin
  assert(value is TFhirCompositionRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionEvent }

constructor TFhirCompositionEvent.Create;
begin
  inherited;
end;

destructor TFhirCompositionEvent.Destroy;
begin
  FCodeList.Free;
  FPeriod.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirCompositionEvent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCompositionEvent(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirCompositionEvent(oSource).FCodeList);
  end;
  period := TFhirCompositionEvent(oSource).period.Clone;
  if (TFhirCompositionEvent(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList.Create;
    FDetailList.Assign(TFhirCompositionEvent(oSource).FDetailList);
  end;
end;

procedure TFhirCompositionEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirCompositionEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', true, TFhirReference, FDetailList.Link));
end;

function TFhirCompositionEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirCompositionEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionEvent.fhirType : string;
begin
  result := 'Composition.event';
end;

function TFhirCompositionEvent.Link : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Link);
end;

function TFhirCompositionEvent.Clone : TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(inherited Clone);
end;

function TFhirCompositionEvent.equals(other : TObject) : boolean; 
var
  o : TFhirCompositionEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionEvent)) then
    result := false
  else
  begin
    o := TFhirCompositionEvent(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirCompositionEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FPeriod) and isEmptyProp(FdetailList);
end;

procedure TFhirCompositionEvent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('period');
  fields.add('detail');
end;

function TFhirCompositionEvent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

function TFhirCompositionEvent.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirCompositionEvent.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

procedure TFhirCompositionEvent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirCompositionEvent.GetDetailList : TFhirReferenceList;
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList.Create;
  result := FDetailList;
end;

function TFhirCompositionEvent.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirCompositionEventListEnumerator }

constructor TFhirCompositionEventListEnumerator.Create(list : TFhirCompositionEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionEventListEnumerator.GetCurrent : TFhirCompositionEvent;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionEventListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCompositionEventList }

function TFhirCompositionEventList.AddItem(value: TFhirCompositionEvent): TFhirCompositionEvent;
begin
  assert(value.ClassName = 'TFhirCompositionEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionEvent');
  add(value);
  result := value;
end;

function TFhirCompositionEventList.Append: TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionEventList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionEventList.GetEnumerator : TFhirCompositionEventListEnumerator;
begin
  result := TFhirCompositionEventListEnumerator.Create(self.link);
end;

function TFhirCompositionEventList.Clone: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Clone);
end;

function TFhirCompositionEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionEventList.GetItemN(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionEvent;
end;
function TFhirCompositionEventList.IndexOf(value: TFhirCompositionEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionEventList.Insert(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionEventList.InsertItem(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  Inherited Insert(index, value);
end;

function TFhirCompositionEventList.Item(index: Integer): TFhirCompositionEvent;
begin
  result := TFhirCompositionEvent(ObjectByIndex[index]);
end;

function TFhirCompositionEventList.Link: TFhirCompositionEventList;
begin
  result := TFhirCompositionEventList(inherited Link);
end;

procedure TFhirCompositionEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionEventList.SetItemByIndex(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  FhirCompositionEvents[index] := value;
end;

procedure TFhirCompositionEventList.SetItemN(index: Integer; value: TFhirCompositionEvent);
begin
  assert(value is TFhirCompositionEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirCompositionSection }

constructor TFhirCompositionSection.Create;
begin
  inherited;
end;

destructor TFhirCompositionSection.Destroy;
begin
  FTitle.free;
  FCode.free;
  FAuthorList.Free;
  FFocus.free;
  FText.free;
  FMode.free;
  FOrderedBy.free;
  FEntryList.Free;
  FEmptyReason.free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirCompositionSection.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirCompositionSection(oSource).titleElement.Clone;
  code := TFhirCompositionSection(oSource).code.Clone;
  if (TFhirCompositionSection(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirCompositionSection(oSource).FAuthorList);
  end;
  focus := TFhirCompositionSection(oSource).focus.Clone;
  text := TFhirCompositionSection(oSource).text.Clone;
  modeElement := TFhirCompositionSection(oSource).modeElement.Clone;
  orderedBy := TFhirCompositionSection(oSource).orderedBy.Clone;
  if (TFhirCompositionSection(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirReferenceList.Create;
    FEntryList.Assign(TFhirCompositionSection(oSource).FEntryList);
  end;
  emptyReason := TFhirCompositionSection(oSource).emptyReason.Clone;
  if (TFhirCompositionSection(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirCompositionSectionList.Create;
    FSectionList.Assign(TFhirCompositionSection(oSource).FSectionList);
  end;
end;

procedure TFhirCompositionSection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirCompositionSection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', false, TFhirReference, FFocus.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'Narrative', false, TFhirNarrative, FText.Link));
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));
  oList.add(TFHIRProperty.create(self, 'entry', 'Reference', true, TFhirReference, FEntryList.Link));
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));
  oList.add(TFHIRProperty.create(self, 'section', '', true, TFhirCompositionSection, FSectionList.Link));
end;

function TFhirCompositionSection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    Text := propValue as TFhirNarrative;
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirCompositionSection);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCompositionSection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirCompositionSection)
  else inherited;
end;

function TFhirCompositionSection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'focus') then result := TFhirReference.create()
  else if (propName = 'text') then result := TFhirNarrative.create()
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[ListModeNull], CODES_TFhirListModeEnum[ListModeNull]) 
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create()
  else if (propName = 'entry') then result := EntryList.new()
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'section') then result := SectionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCompositionSection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'text') then result := 'Narrative'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'entry') then result := 'Reference'
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else if (propName = 'section') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCompositionSection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value)
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCompositionSection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'focus') then FocusElement := new as TFhirReference
  else if (propName = 'text') then TextElement := new as TFhirNarrative
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new)
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new)
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCompositionSection.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'entry') then EntryList.move(source, destination)
  else if (propName = 'section') then SectionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCompositionSection.fhirType : string;
begin
  result := 'Composition.section';
end;

function TFhirCompositionSection.Link : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Link);
end;

function TFhirCompositionSection.Clone : TFhirCompositionSection;
begin
  result := TFhirCompositionSection(inherited Clone);
end;

function TFhirCompositionSection.equals(other : TObject) : boolean; 
var
  o : TFhirCompositionSection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCompositionSection)) then
    result := false
  else
  begin
    o := TFhirCompositionSection(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(focusElement, o.focusElement, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(modeElement, o.modeElement, true) and 
      compareDeep(orderedByElement, o.orderedByElement, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(emptyReasonElement, o.emptyReasonElement, true) and compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirCompositionSection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FCode) and isEmptyProp(FauthorList) and isEmptyProp(FFocus) and isEmptyProp(FText) and isEmptyProp(FMode) and isEmptyProp(FOrderedBy) and isEmptyProp(FentryList) and isEmptyProp(FEmptyReason) and isEmptyProp(FsectionList);
end;

procedure TFhirCompositionSection.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('code');
  fields.add('author');
  fields.add('focus');
  fields.add('text');
  fields.add('mode');
  fields.add('orderedBy');
  fields.add('entry');
  fields.add('emptyReason');
  fields.add('section');
end;

function TFhirCompositionSection.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEntryList.sizeInBytes(magic));
  inc(result, FSectionList.sizeInBytes(magic));
end;

procedure TFhirCompositionSection.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirCompositionSection.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirCompositionSection.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirCompositionSection.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCompositionSection.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirCompositionSection.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

procedure TFhirCompositionSection.SetFocus(value : TFhirReference);
begin
  FFocus.free;
  FFocus := value;
end;

procedure TFhirCompositionSection.SetText(value : TFhirNarrative);
begin
  FText.free;
  FText := value;
end;

procedure TFhirCompositionSection.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirCompositionSection.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

procedure TFhirCompositionSection.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

procedure TFhirCompositionSection.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

function TFhirCompositionSection.GetEntryList : TFhirReferenceList;
begin
  if FEntryList = nil then
    FEntryList := TFhirReferenceList.Create;
  result := FEntryList;
end;

function TFhirCompositionSection.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

procedure TFhirCompositionSection.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

function TFhirCompositionSection.GetSectionList : TFhirCompositionSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirCompositionSectionList.Create;
  result := FSectionList;
end;

function TFhirCompositionSection.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

{ TFhirCompositionSectionListEnumerator }

constructor TFhirCompositionSectionListEnumerator.Create(list : TFhirCompositionSectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionSectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionSectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionSectionListEnumerator.GetCurrent : TFhirCompositionSection;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionSectionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCompositionSectionList }

function TFhirCompositionSectionList.AddItem(value: TFhirCompositionSection): TFhirCompositionSection;
begin
  assert(value.ClassName = 'TFhirCompositionSection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCompositionSection');
  add(value);
  result := value;
end;

function TFhirCompositionSectionList.Append: TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionSectionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionSectionList.GetEnumerator : TFhirCompositionSectionListEnumerator;
begin
  result := TFhirCompositionSectionListEnumerator.Create(self.link);
end;

function TFhirCompositionSectionList.Clone: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Clone);
end;

function TFhirCompositionSectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionSectionList.GetItemN(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCompositionSection;
end;
function TFhirCompositionSectionList.IndexOf(value: TFhirCompositionSection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionSectionList.Insert(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionSectionList.InsertItem(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  Inherited Insert(index, value);
end;

function TFhirCompositionSectionList.Item(index: Integer): TFhirCompositionSection;
begin
  result := TFhirCompositionSection(ObjectByIndex[index]);
end;

function TFhirCompositionSectionList.Link: TFhirCompositionSectionList;
begin
  result := TFhirCompositionSectionList(inherited Link);
end;

procedure TFhirCompositionSectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionSectionList.SetItemByIndex(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  FhirCompositionSections[index] := value;
end;

procedure TFhirCompositionSectionList.SetItemN(index: Integer; value: TFhirCompositionSection);
begin
  assert(value is TFhirCompositionSection);
  ObjectByIndex[index] := value;
end;

{ TFhirComposition }

constructor TFhirComposition.Create;
begin
  inherited;
end;

destructor TFhirComposition.Destroy;
begin
  FIdentifier.free;
  FStatus.free;
  FType_.free;
  FCategoryList.Free;
  FSubject.free;
  FEncounter.free;
  FDate.free;
  FAuthorList.Free;
  FTitle.free;
  FConfidentiality.free;
  FAttesterList.Free;
  FCustodian.free;
  FRelatesToList.Free;
  FEventList.Free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirComposition.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirComposition(oSource).identifier.Clone;
  statusElement := TFhirComposition(oSource).statusElement.Clone;
  type_ := TFhirComposition(oSource).type_.Clone;
  if (TFhirComposition(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirComposition(oSource).FCategoryList);
  end;
  subject := TFhirComposition(oSource).subject.Clone;
  encounter := TFhirComposition(oSource).encounter.Clone;
  dateElement := TFhirComposition(oSource).dateElement.Clone;
  if (TFhirComposition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirComposition(oSource).FAuthorList);
  end;
  titleElement := TFhirComposition(oSource).titleElement.Clone;
  confidentialityElement := TFhirComposition(oSource).confidentialityElement.Clone;
  if (TFhirComposition(oSource).FAttesterList = nil) then
  begin
    FAttesterList.free;
    FAttesterList := nil;
  end
  else
  begin
    if FAttesterList = nil then
      FAttesterList := TFhirCompositionAttesterList.Create;
    FAttesterList.Assign(TFhirComposition(oSource).FAttesterList);
  end;
  custodian := TFhirComposition(oSource).custodian.Clone;
  if (TFhirComposition(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirCompositionRelatesToList.Create;
    FRelatesToList.Assign(TFhirComposition(oSource).FRelatesToList);
  end;
  if (TFhirComposition(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirCompositionEventList.Create;
    FEventList.Assign(TFhirComposition(oSource).FEventList);
  end;
  if (TFhirComposition(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirCompositionSectionList.Create;
    FSectionList.Assign(TFhirComposition(oSource).FSectionList);
  end;
end;

function TFhirComposition.GetResourceType : TFhirResourceType;
begin
  result := frtComposition;
end;

procedure TFhirComposition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'confidentiality') Then
     list.add(self.link, 'confidentiality', FConfidentiality.Link);
  if (child_name = 'attester') Then
    list.addAll(self, 'attester', FAttesterList);
  if (child_name = 'custodian') Then
     list.add(self.link, 'custodian', FCustodian.Link);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirComposition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'confidentiality', 'code', false, TFhirCode, FConfidentiality.Link));
  oList.add(TFHIRProperty.create(self, 'attester', 'BackboneElement', true, TFhirCompositionAttester, FAttesterList.Link));
  oList.add(TFHIRProperty.create(self, 'custodian', 'Reference', false, TFhirReference, FCustodian.Link));
  oList.add(TFHIRProperty.create(self, 'relatesTo', 'BackboneElement', true, TFhirCompositionRelatesTo, FRelatesToList.Link));
  oList.add(TFHIRProperty.create(self, 'event', 'BackboneElement', true, TFhirCompositionEvent, FEventList.Link));
  oList.add(TFHIRProperty.create(self, 'section', 'BackboneElement', true, TFhirCompositionSection, FSectionList.Link));
end;

function TFhirComposition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'confidentiality') then
  begin
    ConfidentialityElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'attester') then
  begin
    AttesterList.add(propValue as TFhirCompositionAttester);
    result := propValue;
  end
  else if (propName = 'custodian') then
  begin
    Custodian := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirCompositionRelatesTo);
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirCompositionEvent);
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirCompositionSection);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirComposition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'attester') then AttesterList.insertItem(index, propValue as TFhirCompositionAttester)
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirCompositionRelatesTo)
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirCompositionEvent)
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirCompositionSection)
  else inherited;
end;

function TFhirComposition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[CompositionStatusNull], CODES_TFhirCompositionStatusEnum[CompositionStatusNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'confidentiality') then result := TFhirCode.create()
  else if (propName = 'attester') then result := AttesterList.new()
  else if (propName = 'custodian') then result := TFhirReference.create()
  else if (propName = 'relatesTo') then result := RelatesToList.new()
  else if (propName = 'event') then result := EventList.new()
  else if (propName = 'section') then result := SectionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirComposition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'confidentiality') then result := 'code'
  else if (propName = 'attester') then result := 'BackboneElement'
  else if (propName = 'custodian') then result := 'Reference'
  else if (propName = 'relatesTo') then result := 'BackboneElement'
  else if (propName = 'event') then result := 'BackboneElement'
  else if (propName = 'section') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirComposition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'confidentiality') then ConfidentialityElement := nil
  else if (propName = 'attester') then deletePropertyValue('attester', AttesterList, value)
  else if (propName = 'custodian') then CustodianElement := nil
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value)
  else if (propName = 'event') then deletePropertyValue('event', EventList, value)
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirComposition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'confidentiality') then ConfidentialityElement := asCode(new)
  else if (propName = 'attester') then replacePropertyValue('attester', AttesterList, existing, new)
  else if (propName = 'custodian') then CustodianElement := new as TFhirReference
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new)
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new)
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirComposition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'attester') then AttesterList.move(source, destination)
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination)
  else if (propName = 'event') then EventList.move(source, destination)
  else if (propName = 'section') then SectionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirComposition.fhirType : string;
begin
  result := 'Composition';
end;

function TFhirComposition.Link : TFhirComposition;
begin
  result := TFhirComposition(inherited Link);
end;

function TFhirComposition.Clone : TFhirComposition;
begin
  result := TFhirComposition(inherited Clone);
end;

function TFhirComposition.equals(other : TObject) : boolean; 
var
  o : TFhirComposition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirComposition)) then
    result := false
  else
  begin
    o := TFhirComposition(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(confidentialityElement, o.confidentialityElement, true) and 
      compareDeep(attesterList, o.attesterList, true) and compareDeep(custodianElement, o.custodianElement, true) and 
      compareDeep(relatesToList, o.relatesToList, true) and compareDeep(eventList, o.eventList, true) and 
      compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirComposition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FcategoryList) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FDate) and isEmptyProp(FauthorList) and isEmptyProp(FTitle) and isEmptyProp(FConfidentiality) and isEmptyProp(FattesterList) and isEmptyProp(FCustodian) and isEmptyProp(FrelatesToList) and isEmptyProp(FeventList) and isEmptyProp(FsectionList);
end;

procedure TFhirComposition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('category');
  fields.add('subject');
  fields.add('encounter');
  fields.add('date');
  fields.add('author');
  fields.add('title');
  fields.add('confidentiality');
  fields.add('attester');
  fields.add('custodian');
  fields.add('relatesTo');
  fields.add('event');
  fields.add('section');
end;

function TFhirComposition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FAttesterList.sizeInBytes(magic));
  inc(result, FRelatesToList.sizeInBytes(magic));
  inc(result, FEventList.sizeInBytes(magic));
  inc(result, FSectionList.sizeInBytes(magic));
end;

procedure TFhirComposition.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirComposition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirComposition.GetStatusST : TFhirCompositionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirCompositionStatusEnum(0)
  else
    result := TFhirCompositionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionStatusEnum, FStatus.value));
end;

procedure TFhirComposition.SetStatusST(value : TFhirCompositionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[value], CODES_TFhirCompositionStatusEnum[value]);
end;

procedure TFhirComposition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirComposition.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirComposition.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirComposition.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirComposition.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirComposition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirComposition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirComposition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

function TFhirComposition.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirComposition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

procedure TFhirComposition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirComposition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirComposition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirComposition.SetConfidentiality(value : TFhirCode);
begin
  FConfidentiality.free;
  FConfidentiality := value;
end;

function TFhirComposition.GetConfidentialityST : String;
begin
  if FConfidentiality = nil then
    result := ''
  else
    result := FConfidentiality.value;
end;

procedure TFhirComposition.SetConfidentialityST(value : String);
begin
  if value <> '' then
  begin
    if FConfidentiality = nil then
      FConfidentiality := TFhirCode.create;
    FConfidentiality.value := value
  end
  else if FConfidentiality <> nil then
    FConfidentiality.value := '';
end;

function TFhirComposition.GetAttesterList : TFhirCompositionAttesterList;
begin
  if FAttesterList = nil then
    FAttesterList := TFhirCompositionAttesterList.Create;
  result := FAttesterList;
end;

function TFhirComposition.GetHasAttesterList : boolean;
begin
  result := (FAttesterList <> nil) and (FAttesterList.count > 0);
end;

procedure TFhirComposition.SetCustodian(value : TFhirReference);
begin
  FCustodian.free;
  FCustodian := value;
end;

function TFhirComposition.GetRelatesToList : TFhirCompositionRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirCompositionRelatesToList.Create;
  result := FRelatesToList;
end;

function TFhirComposition.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

function TFhirComposition.GetEventList : TFhirCompositionEventList;
begin
  if FEventList = nil then
    FEventList := TFhirCompositionEventList.Create;
  result := FEventList;
end;

function TFhirComposition.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

function TFhirComposition.GetSectionList : TFhirCompositionSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirCompositionSectionList.Create;
  result := FSectionList;
end;

function TFhirComposition.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

{ TFhirCompositionListEnumerator }

constructor TFhirCompositionListEnumerator.Create(list : TFhirCompositionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCompositionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirCompositionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCompositionListEnumerator.GetCurrent : TFhirComposition;
begin
  Result := FList[FIndex];
end;

function TFhirCompositionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCompositionList }

function TFhirCompositionList.AddItem(value: TFhirComposition): TFhirComposition;
begin
  assert(value.ClassName = 'TFhirComposition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirComposition');
  add(value);
  result := value;
end;

function TFhirCompositionList.Append: TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionList.ClearItems;
begin
  Clear;
end;

function TFhirCompositionList.GetEnumerator : TFhirCompositionListEnumerator;
begin
  result := TFhirCompositionListEnumerator.Create(self.link);
end;

function TFhirCompositionList.Clone: TFhirCompositionList;
begin
  result := TFhirCompositionList(inherited Clone);
end;

function TFhirCompositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCompositionList.GetItemN(index: Integer): TFhirComposition;
begin
  result := TFhirComposition(ObjectByIndex[index]);
end;

function TFhirCompositionList.ItemClass: TFslObjectClass;
begin
  result := TFhirComposition;
end;
function TFhirCompositionList.IndexOf(value: TFhirComposition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCompositionList.Insert(index: Integer): TFhirComposition;
begin
  result := TFhirComposition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCompositionList.InsertItem(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  Inherited Insert(index, value);
end;

function TFhirCompositionList.Item(index: Integer): TFhirComposition;
begin
  result := TFhirComposition(ObjectByIndex[index]);
end;

function TFhirCompositionList.Link: TFhirCompositionList;
begin
  result := TFhirCompositionList(inherited Link);
end;

procedure TFhirCompositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCompositionList.SetItemByIndex(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  FhirCompositions[index] := value;
end;

procedure TFhirCompositionList.SetItemN(index: Integer; value: TFhirComposition);
begin
  assert(value is TFhirComposition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_COMPOSITION}
{$IFDEF FHIR_CONDITION}
{ TFhirConditionStage }

constructor TFhirConditionStage.Create;
begin
  inherited;
end;

destructor TFhirConditionStage.Destroy;
begin
  FSummary.free;
  FAssessmentList.Free;
  FType_.free;
  inherited;
end;

procedure TFhirConditionStage.Assign(oSource : TFslObject);
begin
  inherited;
  summary := TFhirConditionStage(oSource).summary.Clone;
  if (TFhirConditionStage(oSource).FAssessmentList = nil) then
  begin
    FAssessmentList.free;
    FAssessmentList := nil;
  end
  else
  begin
    if FAssessmentList = nil then
      FAssessmentList := TFhirReferenceList.Create;
    FAssessmentList.Assign(TFhirConditionStage(oSource).FAssessmentList);
  end;
  type_ := TFhirConditionStage(oSource).type_.Clone;
end;

procedure TFhirConditionStage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'summary') Then
     list.add(self.link, 'summary', FSummary.Link);
  if (child_name = 'assessment') Then
    list.addAll(self, 'assessment', FAssessmentList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirConditionStage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'summary', 'CodeableConcept', false, TFhirCodeableConcept, FSummary.Link));
  oList.add(TFHIRProperty.create(self, 'assessment', 'Reference', true, TFhirReference, FAssessmentList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
end;

function TFhirConditionStage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'summary') then
  begin
    Summary := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'assessment') then
  begin
    AssessmentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConditionStage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'assessment') then AssessmentList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirConditionStage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'summary') then result := TFhirCodeableConcept.create()
  else if (propName = 'assessment') then result := AssessmentList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConditionStage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'summary') then result := 'CodeableConcept'
  else if (propName = 'assessment') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConditionStage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'summary') then SummaryElement := nil
  else if (propName = 'assessment') then deletePropertyValue('assessment', AssessmentList, value)
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConditionStage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'summary') then SummaryElement := new as TFhirCodeableConcept
  else if (propName = 'assessment') then replacePropertyValue('assessment', AssessmentList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConditionStage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'assessment') then AssessmentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConditionStage.fhirType : string;
begin
  result := 'Condition.stage';
end;

function TFhirConditionStage.Link : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Link);
end;

function TFhirConditionStage.Clone : TFhirConditionStage;
begin
  result := TFhirConditionStage(inherited Clone);
end;

function TFhirConditionStage.equals(other : TObject) : boolean; 
var
  o : TFhirConditionStage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConditionStage)) then
    result := false
  else
  begin
    o := TFhirConditionStage(other);
    result := compareDeep(summaryElement, o.summaryElement, true) and compareDeep(assessmentList, o.assessmentList, true) and 
      compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirConditionStage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSummary) and isEmptyProp(FassessmentList) and isEmptyProp(FType_);
end;

procedure TFhirConditionStage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('summary');
  fields.add('assessment');
  fields.add('type');
end;

function TFhirConditionStage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAssessmentList.sizeInBytes(magic));
end;

procedure TFhirConditionStage.SetSummary(value : TFhirCodeableConcept);
begin
  FSummary.free;
  FSummary := value;
end;

function TFhirConditionStage.GetAssessmentList : TFhirReferenceList;
begin
  if FAssessmentList = nil then
    FAssessmentList := TFhirReferenceList.Create;
  result := FAssessmentList;
end;

function TFhirConditionStage.GetHasAssessmentList : boolean;
begin
  result := (FAssessmentList <> nil) and (FAssessmentList.count > 0);
end;

procedure TFhirConditionStage.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

{ TFhirConditionStageListEnumerator }

constructor TFhirConditionStageListEnumerator.Create(list : TFhirConditionStageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionStageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionStageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionStageListEnumerator.GetCurrent : TFhirConditionStage;
begin
  Result := FList[FIndex];
end;

function TFhirConditionStageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConditionStageList }

function TFhirConditionStageList.AddItem(value: TFhirConditionStage): TFhirConditionStage;
begin
  assert(value.ClassName = 'TFhirConditionStage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionStage');
  add(value);
  result := value;
end;

function TFhirConditionStageList.Append: TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionStageList.ClearItems;
begin
  Clear;
end;

function TFhirConditionStageList.GetEnumerator : TFhirConditionStageListEnumerator;
begin
  result := TFhirConditionStageListEnumerator.Create(self.link);
end;

function TFhirConditionStageList.Clone: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Clone);
end;

function TFhirConditionStageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionStageList.GetItemN(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.ItemClass: TFslObjectClass;
begin
  result := TFhirConditionStage;
end;
function TFhirConditionStageList.IndexOf(value: TFhirConditionStage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionStageList.Insert(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionStageList.InsertItem(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  Inherited Insert(index, value);
end;

function TFhirConditionStageList.Item(index: Integer): TFhirConditionStage;
begin
  result := TFhirConditionStage(ObjectByIndex[index]);
end;

function TFhirConditionStageList.Link: TFhirConditionStageList;
begin
  result := TFhirConditionStageList(inherited Link);
end;

procedure TFhirConditionStageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionStageList.SetItemByIndex(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  FhirConditionStages[index] := value;
end;

procedure TFhirConditionStageList.SetItemN(index: Integer; value: TFhirConditionStage);
begin
  assert(value is TFhirConditionStage);
  ObjectByIndex[index] := value;
end;

{ TFhirConditionEvidence }

constructor TFhirConditionEvidence.Create;
begin
  inherited;
end;

destructor TFhirConditionEvidence.Destroy;
begin
  FCodeList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirConditionEvidence.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirConditionEvidence(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirConditionEvidence(oSource).FCodeList);
  end;
  if (TFhirConditionEvidence(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList.Create;
    FDetailList.Assign(TFhirConditionEvidence(oSource).FDetailList);
  end;
end;

procedure TFhirConditionEvidence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirConditionEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', true, TFhirReference, FDetailList.Link));
end;

function TFhirConditionEvidence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConditionEvidence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirConditionEvidence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConditionEvidence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConditionEvidence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConditionEvidence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConditionEvidence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConditionEvidence.fhirType : string;
begin
  result := 'Condition.evidence';
end;

function TFhirConditionEvidence.Link : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Link);
end;

function TFhirConditionEvidence.Clone : TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(inherited Clone);
end;

function TFhirConditionEvidence.equals(other : TObject) : boolean; 
var
  o : TFhirConditionEvidence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConditionEvidence)) then
    result := false
  else
  begin
    o := TFhirConditionEvidence(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirConditionEvidence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FdetailList);
end;

procedure TFhirConditionEvidence.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('detail');
end;

function TFhirConditionEvidence.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

function TFhirConditionEvidence.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirConditionEvidence.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirConditionEvidence.GetDetailList : TFhirReferenceList;
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList.Create;
  result := FDetailList;
end;

function TFhirConditionEvidence.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirConditionEvidenceListEnumerator }

constructor TFhirConditionEvidenceListEnumerator.Create(list : TFhirConditionEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionEvidenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionEvidenceListEnumerator.GetCurrent : TFhirConditionEvidence;
begin
  Result := FList[FIndex];
end;

function TFhirConditionEvidenceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConditionEvidenceList }

function TFhirConditionEvidenceList.AddItem(value: TFhirConditionEvidence): TFhirConditionEvidence;
begin
  assert(value.ClassName = 'TFhirConditionEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConditionEvidence');
  add(value);
  result := value;
end;

function TFhirConditionEvidenceList.Append: TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirConditionEvidenceList.GetEnumerator : TFhirConditionEvidenceListEnumerator;
begin
  result := TFhirConditionEvidenceListEnumerator.Create(self.link);
end;

function TFhirConditionEvidenceList.Clone: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Clone);
end;

function TFhirConditionEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionEvidenceList.GetItemN(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirConditionEvidence;
end;
function TFhirConditionEvidenceList.IndexOf(value: TFhirConditionEvidence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionEvidenceList.Insert(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionEvidenceList.InsertItem(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  Inherited Insert(index, value);
end;

function TFhirConditionEvidenceList.Item(index: Integer): TFhirConditionEvidence;
begin
  result := TFhirConditionEvidence(ObjectByIndex[index]);
end;

function TFhirConditionEvidenceList.Link: TFhirConditionEvidenceList;
begin
  result := TFhirConditionEvidenceList(inherited Link);
end;

procedure TFhirConditionEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionEvidenceList.SetItemByIndex(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  FhirConditionEvidences[index] := value;
end;

procedure TFhirConditionEvidenceList.SetItemN(index: Integer; value: TFhirConditionEvidence);
begin
  assert(value is TFhirConditionEvidence);
  ObjectByIndex[index] := value;
end;

{ TFhirCondition }

constructor TFhirCondition.Create;
begin
  inherited;
end;

destructor TFhirCondition.Destroy;
begin
  FIdentifierList.Free;
  FClinicalStatus.free;
  FVerificationStatus.free;
  FCategoryList.Free;
  FSeverity.free;
  FCode.free;
  FBodySiteList.Free;
  FSubject.free;
  FEncounter.free;
  FOnset.free;
  FAbatement.free;
  FRecordedDate.free;
  FRecorder.free;
  FAsserter.free;
  FStageList.Free;
  FEvidenceList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirCondition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCondition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCondition(oSource).FIdentifierList);
  end;
  clinicalStatus := TFhirCondition(oSource).clinicalStatus.Clone;
  verificationStatus := TFhirCondition(oSource).verificationStatus.Clone;
  if (TFhirCondition(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirCondition(oSource).FCategoryList);
  end;
  severity := TFhirCondition(oSource).severity.Clone;
  code := TFhirCondition(oSource).code.Clone;
  if (TFhirCondition(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirCondition(oSource).FBodySiteList);
  end;
  subject := TFhirCondition(oSource).subject.Clone;
  encounter := TFhirCondition(oSource).encounter.Clone;
  onset := TFhirCondition(oSource).onset.Clone;
  abatement := TFhirCondition(oSource).abatement.Clone;
  recordedDateElement := TFhirCondition(oSource).recordedDateElement.Clone;
  recorder := TFhirCondition(oSource).recorder.Clone;
  asserter := TFhirCondition(oSource).asserter.Clone;
  if (TFhirCondition(oSource).FStageList = nil) then
  begin
    FStageList.free;
    FStageList := nil;
  end
  else
  begin
    if FStageList = nil then
      FStageList := TFhirConditionStageList.Create;
    FStageList.Assign(TFhirCondition(oSource).FStageList);
  end;
  if (TFhirCondition(oSource).FEvidenceList = nil) then
  begin
    FEvidenceList.free;
    FEvidenceList := nil;
  end
  else
  begin
    if FEvidenceList = nil then
      FEvidenceList := TFhirConditionEvidenceList.Create;
    FEvidenceList.Assign(TFhirCondition(oSource).FEvidenceList);
  end;
  if (TFhirCondition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirCondition(oSource).FNoteList);
  end;
end;

function TFhirCondition.GetResourceType : TFhirResourceType;
begin
  result := frtCondition;
end;

procedure TFhirCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'clinicalStatus') Then
     list.add(self.link, 'clinicalStatus', FClinicalStatus.Link);
  if (child_name = 'verificationStatus') Then
     list.add(self.link, 'verificationStatus', FVerificationStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'abatement[x]') or (child_name = 'abatement') Then
     list.add(self.link, 'abatement[x]', FAbatement.Link);
  if (child_name = 'recordedDate') Then
     list.add(self.link, 'recordedDate', FRecordedDate.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'asserter') Then
     list.add(self.link, 'asserter', FAsserter.Link);
  if (child_name = 'stage') Then
    list.addAll(self, 'stage', FStageList);
  if (child_name = 'evidence') Then
    list.addAll(self, 'evidence', FEvidenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'clinicalStatus', 'CodeableConcept', false, TFhirCodeableConcept, FClinicalStatus.Link));
  oList.add(TFHIRProperty.create(self, 'verificationStatus', 'CodeableConcept', false, TFhirCodeableConcept, FVerificationStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'severity', 'CodeableConcept', false, TFhirCodeableConcept, FSeverity.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'dateTime|Age|Period|Range|string', false, TFhirDataType, FOnset.Link));
  oList.add(TFHIRProperty.create(self, 'abatement[x]', 'dateTime|Age|Period|Range|string', false, TFhirDataType, FAbatement.Link));
  oList.add(TFHIRProperty.create(self, 'recordedDate', 'dateTime', false, TFhirDateTime, FRecordedDate.Link));
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link));
  oList.add(TFHIRProperty.create(self, 'asserter', 'Reference', false, TFhirReference, FAsserter.Link));
  oList.add(TFHIRProperty.create(self, 'stage', 'BackboneElement', true, TFhirConditionStage, FStageList.Link));
  oList.add(TFHIRProperty.create(self, 'evidence', 'BackboneElement', true, TFhirConditionEvidence, FEvidenceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'clinicalStatus') then
  begin
    ClinicalStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'verificationStatus') then
  begin
    VerificationStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    Severity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then
  begin
    Onset := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then
  begin
    Abatement := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'recordedDate') then
  begin
    RecordedDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'asserter') then
  begin
    Asserter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'stage') then
  begin
    StageList.add(propValue as TFhirConditionStage);
    result := propValue;
  end
  else if (propName = 'evidence') then
  begin
    EvidenceList.add(propValue as TFhirConditionEvidence);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'stage') then StageList.insertItem(index, propValue as TFhirConditionStage)
  else if (propName = 'evidence') then EvidenceList.insertItem(index, propValue as TFhirConditionEvidence)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'clinicalStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'verificationStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'severity') then result := TFhirCodeableConcept.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'bodySite') then result := BodySiteList.new()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Onset')
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Abatement')
  else if (propName = 'recordedDate') then result := TFhirDateTime.create()
  else if (propName = 'recorder') then result := TFhirReference.create()
  else if (propName = 'asserter') then result := TFhirReference.create()
  else if (propName = 'stage') then result := StageList.new()
  else if (propName = 'evidence') then result := EvidenceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'clinicalStatus') then result := 'CodeableConcept'
  else if (propName = 'verificationStatus') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'severity') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'onset[x]') then result := 'dateTime|Age|Period|Range|string'
  else if (propName = 'abatement[x]') then result := 'dateTime|Age|Period|Range|string'
  else if (propName = 'recordedDate') then result := 'dateTime'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'asserter') then result := 'Reference'
  else if (propName = 'stage') then result := 'BackboneElement'
  else if (propName = 'evidence') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := nil
  else if (propName = 'verificationStatus') then VerificationStatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := nil
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then AbatementElement := nil
  else if (propName = 'recordedDate') then RecordedDateElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'asserter') then AsserterElement := nil
  else if (propName = 'stage') then deletePropertyValue('stage', StageList, value)
  else if (propName = 'evidence') then deletePropertyValue('evidence', EvidenceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'clinicalStatus') then ClinicalStatusElement := new as TFhirCodeableConcept
  else if (propName = 'verificationStatus') then VerificationStatusElement := new as TFhirCodeableConcept
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'severity') then SeverityElement := new as TFhirCodeableConcept
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'onset', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then OnsetElement := new as TFhirDataType
  else if (isMatchingName(propName, 'abatement', ['DateTime', 'Age', 'Period', 'Range', 'String'])) then AbatementElement := new as TFhirDataType
  else if (propName = 'recordedDate') then RecordedDateElement := asDateTime(new)
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference
  else if (propName = 'asserter') then AsserterElement := new as TFhirReference
  else if (propName = 'stage') then replacePropertyValue('stage', StageList, existing, new)
  else if (propName = 'evidence') then replacePropertyValue('evidence', EvidenceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCondition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'bodySite') then BodySiteList.move(source, destination)
  else if (propName = 'stage') then StageList.move(source, destination)
  else if (propName = 'evidence') then EvidenceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCondition.fhirType : string;
begin
  result := 'Condition';
end;

function TFhirCondition.Link : TFhirCondition;
begin
  result := TFhirCondition(inherited Link);
end;

function TFhirCondition.Clone : TFhirCondition;
begin
  result := TFhirCondition(inherited Clone);
end;

function TFhirCondition.equals(other : TObject) : boolean; 
var
  o : TFhirCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCondition)) then
    result := false
  else
  begin
    o := TFhirCondition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(clinicalStatusElement, o.clinicalStatusElement, true) and 
      compareDeep(verificationStatusElement, o.verificationStatusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(severityElement, o.severityElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(bodySiteList, o.bodySiteList, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(abatementElement, o.abatementElement, true) and 
      compareDeep(recordedDateElement, o.recordedDateElement, true) and compareDeep(recorderElement, o.recorderElement, true) and 
      compareDeep(asserterElement, o.asserterElement, true) and compareDeep(stageList, o.stageList, true) and 
      compareDeep(evidenceList, o.evidenceList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FClinicalStatus) and isEmptyProp(FVerificationStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FSeverity) and isEmptyProp(FCode) and isEmptyProp(FbodySiteList) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOnset) and isEmptyProp(FAbatement) and isEmptyProp(FRecordedDate) and isEmptyProp(FRecorder) and isEmptyProp(FAsserter) and isEmptyProp(FstageList) and isEmptyProp(FevidenceList) and isEmptyProp(FnoteList);
end;

procedure TFhirCondition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('clinicalStatus');
  fields.add('verificationStatus');
  fields.add('category');
  fields.add('severity');
  fields.add('code');
  fields.add('bodySite');
  fields.add('subject');
  fields.add('encounter');
  fields.add('onset[x]');
  fields.add('abatement[x]');
  fields.add('recordedDate');
  fields.add('recorder');
  fields.add('asserter');
  fields.add('stage');
  fields.add('evidence');
  fields.add('note');
end;

function TFhirCondition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FBodySiteList.sizeInBytes(magic));
  inc(result, FStageList.sizeInBytes(magic));
  inc(result, FEvidenceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirCondition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCondition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCondition.SetClinicalStatus(value : TFhirCodeableConcept);
begin
  FClinicalStatus.free;
  FClinicalStatus := value;
end;

procedure TFhirCondition.SetVerificationStatus(value : TFhirCodeableConcept);
begin
  FVerificationStatus.free;
  FVerificationStatus := value;
end;

function TFhirCondition.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirCondition.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirCondition.SetSeverity(value : TFhirCodeableConcept);
begin
  FSeverity.free;
  FSeverity := value;
end;

procedure TFhirCondition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirCondition.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

function TFhirCondition.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

procedure TFhirCondition.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirCondition.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirCondition.SetOnset(value : TFhirDataType);
begin
  FOnset.free;
  FOnset := value;
end;

procedure TFhirCondition.SetAbatement(value : TFhirDataType);
begin
  FAbatement.free;
  FAbatement := value;
end;

procedure TFhirCondition.SetRecordedDate(value : TFhirDateTime);
begin
  FRecordedDate.free;
  FRecordedDate := value;
end;

function TFhirCondition.GetRecordedDateST : TFslDateTime;
begin
  if FRecordedDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedDate.value;
end;

procedure TFhirCondition.SetRecordedDateST(value : TFslDateTime);
begin
  if FRecordedDate = nil then
    FRecordedDate := TFhirDateTime.create;
  FRecordedDate.value := value
end;

procedure TFhirCondition.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value;
end;

procedure TFhirCondition.SetAsserter(value : TFhirReference);
begin
  FAsserter.free;
  FAsserter := value;
end;

function TFhirCondition.GetStageList : TFhirConditionStageList;
begin
  if FStageList = nil then
    FStageList := TFhirConditionStageList.Create;
  result := FStageList;
end;

function TFhirCondition.GetHasStageList : boolean;
begin
  result := (FStageList <> nil) and (FStageList.count > 0);
end;

function TFhirCondition.GetEvidenceList : TFhirConditionEvidenceList;
begin
  if FEvidenceList = nil then
    FEvidenceList := TFhirConditionEvidenceList.Create;
  result := FEvidenceList;
end;

function TFhirCondition.GetHasEvidenceList : boolean;
begin
  result := (FEvidenceList <> nil) and (FEvidenceList.count > 0);
end;

function TFhirCondition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirCondition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirConditionListEnumerator }

constructor TFhirConditionListEnumerator.Create(list : TFhirConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConditionListEnumerator.GetCurrent : TFhirCondition;
begin
  Result := FList[FIndex];
end;

function TFhirConditionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConditionList }

function TFhirConditionList.AddItem(value: TFhirCondition): TFhirCondition;
begin
  assert(value.ClassName = 'TFhirCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCondition');
  add(value);
  result := value;
end;

function TFhirConditionList.Append: TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionList.ClearItems;
begin
  Clear;
end;

function TFhirConditionList.GetEnumerator : TFhirConditionListEnumerator;
begin
  result := TFhirConditionListEnumerator.Create(self.link);
end;

function TFhirConditionList.Clone: TFhirConditionList;
begin
  result := TFhirConditionList(inherited Clone);
end;

function TFhirConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConditionList.GetItemN(index: Integer): TFhirCondition;
begin
  result := TFhirCondition(ObjectByIndex[index]);
end;

function TFhirConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirCondition;
end;
function TFhirConditionList.IndexOf(value: TFhirCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConditionList.Insert(index: Integer): TFhirCondition;
begin
  result := TFhirCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConditionList.InsertItem(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  Inherited Insert(index, value);
end;

function TFhirConditionList.Item(index: Integer): TFhirCondition;
begin
  result := TFhirCondition(ObjectByIndex[index]);
end;

function TFhirConditionList.Link: TFhirConditionList;
begin
  result := TFhirConditionList(inherited Link);
end;

procedure TFhirConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConditionList.SetItemByIndex(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  FhirConditions[index] := value;
end;

procedure TFhirConditionList.SetItemN(index: Integer; value: TFhirCondition);
begin
  assert(value is TFhirCondition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONDITION}
{$IFDEF FHIR_DETECTEDISSUE}
{ TFhirDetectedIssueEvidence }

constructor TFhirDetectedIssueEvidence.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssueEvidence.Destroy;
begin
  FCodeList.Free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirDetectedIssueEvidence.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDetectedIssueEvidence(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirDetectedIssueEvidence(oSource).FCodeList);
  end;
  if (TFhirDetectedIssueEvidence(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirReferenceList.Create;
    FDetailList.Assign(TFhirDetectedIssueEvidence(oSource).FDetailList);
  end;
end;

procedure TFhirDetectedIssueEvidence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirDetectedIssueEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', true, TFhirReference, FDetailList.Link));
end;

function TFhirDetectedIssueEvidence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDetectedIssueEvidence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirDetectedIssueEvidence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssueEvidence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'detail') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssueEvidence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssueEvidence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssueEvidence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssueEvidence.fhirType : string;
begin
  result := 'DetectedIssue.evidence';
end;

function TFhirDetectedIssueEvidence.Link : TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence(inherited Link);
end;

function TFhirDetectedIssueEvidence.Clone : TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence(inherited Clone);
end;

function TFhirDetectedIssueEvidence.equals(other : TObject) : boolean; 
var
  o : TFhirDetectedIssueEvidence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssueEvidence)) then
    result := false
  else
  begin
    o := TFhirDetectedIssueEvidence(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirDetectedIssueEvidence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FdetailList);
end;

procedure TFhirDetectedIssueEvidence.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('detail');
end;

function TFhirDetectedIssueEvidence.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

function TFhirDetectedIssueEvidence.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirDetectedIssueEvidence.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirDetectedIssueEvidence.GetDetailList : TFhirReferenceList;
begin
  if FDetailList = nil then
    FDetailList := TFhirReferenceList.Create;
  result := FDetailList;
end;

function TFhirDetectedIssueEvidence.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirDetectedIssueEvidenceListEnumerator }

constructor TFhirDetectedIssueEvidenceListEnumerator.Create(list : TFhirDetectedIssueEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueEvidenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueEvidenceListEnumerator.GetCurrent : TFhirDetectedIssueEvidence;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueEvidenceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDetectedIssueEvidenceList }

function TFhirDetectedIssueEvidenceList.AddItem(value: TFhirDetectedIssueEvidence): TFhirDetectedIssueEvidence;
begin
  assert(value.ClassName = 'TFhirDetectedIssueEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssueEvidence');
  add(value);
  result := value;
end;

function TFhirDetectedIssueEvidenceList.Append: TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueEvidenceList.GetEnumerator : TFhirDetectedIssueEvidenceListEnumerator;
begin
  result := TFhirDetectedIssueEvidenceListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueEvidenceList.Clone: TFhirDetectedIssueEvidenceList;
begin
  result := TFhirDetectedIssueEvidenceList(inherited Clone);
end;

function TFhirDetectedIssueEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueEvidenceList.GetItemN(index: Integer): TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence(ObjectByIndex[index]);
end;

function TFhirDetectedIssueEvidenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssueEvidence;
end;
function TFhirDetectedIssueEvidenceList.IndexOf(value: TFhirDetectedIssueEvidence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueEvidenceList.Insert(index: Integer): TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueEvidenceList.InsertItem(index: Integer; value: TFhirDetectedIssueEvidence);
begin
  assert(value is TFhirDetectedIssueEvidence);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueEvidenceList.Item(index: Integer): TFhirDetectedIssueEvidence;
begin
  result := TFhirDetectedIssueEvidence(ObjectByIndex[index]);
end;

function TFhirDetectedIssueEvidenceList.Link: TFhirDetectedIssueEvidenceList;
begin
  result := TFhirDetectedIssueEvidenceList(inherited Link);
end;

procedure TFhirDetectedIssueEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueEvidenceList.SetItemByIndex(index: Integer; value: TFhirDetectedIssueEvidence);
begin
  assert(value is TFhirDetectedIssueEvidence);
  FhirDetectedIssueEvidences[index] := value;
end;

procedure TFhirDetectedIssueEvidenceList.SetItemN(index: Integer; value: TFhirDetectedIssueEvidence);
begin
  assert(value is TFhirDetectedIssueEvidence);
  ObjectByIndex[index] := value;
end;

{ TFhirDetectedIssueMitigation }

constructor TFhirDetectedIssueMitigation.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssueMitigation.Destroy;
begin
  FAction.free;
  FDate.free;
  FAuthor.free;
  inherited;
end;

procedure TFhirDetectedIssueMitigation.Assign(oSource : TFslObject);
begin
  inherited;
  action := TFhirDetectedIssueMitigation(oSource).action.Clone;
  dateElement := TFhirDetectedIssueMitigation(oSource).dateElement.Clone;
  author := TFhirDetectedIssueMitigation(oSource).author.Clone;
end;

procedure TFhirDetectedIssueMitigation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirDetectedIssueMitigation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', false, TFhirCodeableConcept, FAction.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
end;

function TFhirDetectedIssueMitigation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    Action := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDetectedIssueMitigation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDetectedIssueMitigation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := TFhirCodeableConcept.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssueMitigation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssueMitigation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssueMitigation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := new as TFhirCodeableConcept
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssueMitigation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssueMitigation.fhirType : string;
begin
  result := 'DetectedIssue.mitigation';
end;

function TFhirDetectedIssueMitigation.Link : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(inherited Link);
end;

function TFhirDetectedIssueMitigation.Clone : TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(inherited Clone);
end;

function TFhirDetectedIssueMitigation.equals(other : TObject) : boolean; 
var
  o : TFhirDetectedIssueMitigation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssueMitigation)) then
    result := false
  else
  begin
    o := TFhirDetectedIssueMitigation(other);
    result := compareDeep(actionElement, o.actionElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirDetectedIssueMitigation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAction) and isEmptyProp(FDate) and isEmptyProp(FAuthor);
end;

procedure TFhirDetectedIssueMitigation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('action');
  fields.add('date');
  fields.add('author');
end;

function TFhirDetectedIssueMitigation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDetectedIssueMitigation.SetAction(value : TFhirCodeableConcept);
begin
  FAction.free;
  FAction := value;
end;

procedure TFhirDetectedIssueMitigation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirDetectedIssueMitigation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirDetectedIssueMitigation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirDetectedIssueMitigation.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

{ TFhirDetectedIssueMitigationListEnumerator }

constructor TFhirDetectedIssueMitigationListEnumerator.Create(list : TFhirDetectedIssueMitigationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueMitigationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueMitigationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueMitigationListEnumerator.GetCurrent : TFhirDetectedIssueMitigation;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueMitigationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDetectedIssueMitigationList }

function TFhirDetectedIssueMitigationList.AddItem(value: TFhirDetectedIssueMitigation): TFhirDetectedIssueMitigation;
begin
  assert(value.ClassName = 'TFhirDetectedIssueMitigation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssueMitigation');
  add(value);
  result := value;
end;

function TFhirDetectedIssueMitigationList.Append: TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueMitigationList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueMitigationList.GetEnumerator : TFhirDetectedIssueMitigationListEnumerator;
begin
  result := TFhirDetectedIssueMitigationListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueMitigationList.Clone: TFhirDetectedIssueMitigationList;
begin
  result := TFhirDetectedIssueMitigationList(inherited Clone);
end;

function TFhirDetectedIssueMitigationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueMitigationList.GetItemN(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(ObjectByIndex[index]);
end;

function TFhirDetectedIssueMitigationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssueMitigation;
end;
function TFhirDetectedIssueMitigationList.IndexOf(value: TFhirDetectedIssueMitigation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueMitigationList.Insert(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueMitigationList.InsertItem(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueMitigationList.Item(index: Integer): TFhirDetectedIssueMitigation;
begin
  result := TFhirDetectedIssueMitigation(ObjectByIndex[index]);
end;

function TFhirDetectedIssueMitigationList.Link: TFhirDetectedIssueMitigationList;
begin
  result := TFhirDetectedIssueMitigationList(inherited Link);
end;

procedure TFhirDetectedIssueMitigationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueMitigationList.SetItemByIndex(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  FhirDetectedIssueMitigations[index] := value;
end;

procedure TFhirDetectedIssueMitigationList.SetItemN(index: Integer; value: TFhirDetectedIssueMitigation);
begin
  assert(value is TFhirDetectedIssueMitigation);
  ObjectByIndex[index] := value;
end;

{ TFhirDetectedIssue }

constructor TFhirDetectedIssue.Create;
begin
  inherited;
end;

destructor TFhirDetectedIssue.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCode.free;
  FSeverity.free;
  FPatient.free;
  FIdentified.free;
  FAuthor.free;
  FImplicatedList.Free;
  FEvidenceList.Free;
  FDetail.free;
  FReference.free;
  FMitigationList.Free;
  inherited;
end;

procedure TFhirDetectedIssue.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDetectedIssue(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDetectedIssue(oSource).FIdentifierList);
  end;
  statusElement := TFhirDetectedIssue(oSource).statusElement.Clone;
  code := TFhirDetectedIssue(oSource).code.Clone;
  severityElement := TFhirDetectedIssue(oSource).severityElement.Clone;
  patient := TFhirDetectedIssue(oSource).patient.Clone;
  identified := TFhirDetectedIssue(oSource).identified.Clone;
  author := TFhirDetectedIssue(oSource).author.Clone;
  if (TFhirDetectedIssue(oSource).FImplicatedList = nil) then
  begin
    FImplicatedList.free;
    FImplicatedList := nil;
  end
  else
  begin
    if FImplicatedList = nil then
      FImplicatedList := TFhirReferenceList.Create;
    FImplicatedList.Assign(TFhirDetectedIssue(oSource).FImplicatedList);
  end;
  if (TFhirDetectedIssue(oSource).FEvidenceList = nil) then
  begin
    FEvidenceList.free;
    FEvidenceList := nil;
  end
  else
  begin
    if FEvidenceList = nil then
      FEvidenceList := TFhirDetectedIssueEvidenceList.Create;
    FEvidenceList.Assign(TFhirDetectedIssue(oSource).FEvidenceList);
  end;
  detailElement := TFhirDetectedIssue(oSource).detailElement.Clone;
  referenceElement := TFhirDetectedIssue(oSource).referenceElement.Clone;
  if (TFhirDetectedIssue(oSource).FMitigationList = nil) then
  begin
    FMitigationList.free;
    FMitigationList := nil;
  end
  else
  begin
    if FMitigationList = nil then
      FMitigationList := TFhirDetectedIssueMitigationList.Create;
    FMitigationList.Assign(TFhirDetectedIssue(oSource).FMitigationList);
  end;
end;

function TFhirDetectedIssue.GetResourceType : TFhirResourceType;
begin
  result := frtDetectedIssue;
end;

procedure TFhirDetectedIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'identified[x]') or (child_name = 'identified') Then
     list.add(self.link, 'identified[x]', FIdentified.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'implicated') Then
    list.addAll(self, 'implicated', FImplicatedList);
  if (child_name = 'evidence') Then
    list.addAll(self, 'evidence', FEvidenceList);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'mitigation') Then
    list.addAll(self, 'mitigation', FMitigationList);
end;

procedure TFhirDetectedIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFhirEnum, FSeverity.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'identified[x]', 'dateTime|Period', false, TFhirDataType, FIdentified.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'implicated', 'Reference', true, TFhirReference, FImplicatedList.Link));
  oList.add(TFHIRProperty.create(self, 'evidence', 'BackboneElement', true, TFhirDetectedIssueEvidence, FEvidenceList.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'string', false, TFhirString, FDetail.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', false, TFhirUri, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'mitigation', 'BackboneElement', true, TFhirDetectedIssueMitigation, FMitigationList.Link));
end;

function TFhirDetectedIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirDetectedIssueSeverityEnum, CODES_TFhirDetectedIssueSeverityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'identified', ['DateTime', 'Period'])) then
  begin
    Identified := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'implicated') then
  begin
    ImplicatedList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'evidence') then
  begin
    EvidenceList.add(propValue as TFhirDetectedIssueEvidence);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'mitigation') then
  begin
    MitigationList.add(propValue as TFhirDetectedIssueMitigation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDetectedIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'implicated') then ImplicatedList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'evidence') then EvidenceList.insertItem(index, propValue as TFhirDetectedIssueEvidence)
  else if (propName = 'mitigation') then MitigationList.insertItem(index, propValue as TFhirDetectedIssueMitigation)
  else inherited;
end;

function TFhirDetectedIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[ObservationStatusNull], CODES_TFhirObservationStatusEnum[ObservationStatusNull]) 
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'severity') then result := TFhirEnum.create(SYSTEMS_TFhirDetectedIssueSeverityEnum[DetectedIssueSeverityNull], CODES_TFhirDetectedIssueSeverityEnum[DetectedIssueSeverityNull]) 
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'identified', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Identified')
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'implicated') then result := ImplicatedList.new()
  else if (propName = 'evidence') then result := EvidenceList.new()
  else if (propName = 'detail') then result := TFhirString.create()
  else if (propName = 'reference') then result := TFhirUri.create()
  else if (propName = 'mitigation') then result := MitigationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDetectedIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'severity') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'identified[x]') then result := 'dateTime|Period'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'implicated') then result := 'Reference'
  else if (propName = 'evidence') then result := 'BackboneElement'
  else if (propName = 'detail') then result := 'string'
  else if (propName = 'reference') then result := 'uri'
  else if (propName = 'mitigation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDetectedIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (isMatchingName(propName, 'identified', ['DateTime', 'Period'])) then IdentifiedElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'implicated') then deletePropertyValue('implicated', ImplicatedList, value)
  else if (propName = 'evidence') then deletePropertyValue('evidence', EvidenceList, value)
  else if (propName = 'detail') then DetailElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'mitigation') then deletePropertyValue('mitigation', MitigationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDetectedIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirDetectedIssueSeverityEnum, CODES_TFhirDetectedIssueSeverityEnum, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (isMatchingName(propName, 'identified', ['DateTime', 'Period'])) then IdentifiedElement := new as TFhirDataType
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'implicated') then replacePropertyValue('implicated', ImplicatedList, existing, new)
  else if (propName = 'evidence') then replacePropertyValue('evidence', EvidenceList, existing, new)
  else if (propName = 'detail') then DetailElement := asString(new)
  else if (propName = 'reference') then ReferenceElement := asUri(new)
  else if (propName = 'mitigation') then replacePropertyValue('mitigation', MitigationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDetectedIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'implicated') then ImplicatedList.move(source, destination)
  else if (propName = 'evidence') then EvidenceList.move(source, destination)
  else if (propName = 'mitigation') then MitigationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDetectedIssue.fhirType : string;
begin
  result := 'DetectedIssue';
end;

function TFhirDetectedIssue.Link : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(inherited Link);
end;

function TFhirDetectedIssue.Clone : TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(inherited Clone);
end;

function TFhirDetectedIssue.equals(other : TObject) : boolean; 
var
  o : TFhirDetectedIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDetectedIssue)) then
    result := false
  else
  begin
    o := TFhirDetectedIssue(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(severityElement, o.severityElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(identifiedElement, o.identifiedElement, true) and 
      compareDeep(authorElement, o.authorElement, true) and compareDeep(implicatedList, o.implicatedList, true) and 
      compareDeep(evidenceList, o.evidenceList, true) and compareDeep(detailElement, o.detailElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(mitigationList, o.mitigationList, true);
  end;
end;

function TFhirDetectedIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCode) and isEmptyProp(FSeverity) and isEmptyProp(FPatient) and isEmptyProp(FIdentified) and isEmptyProp(FAuthor) and isEmptyProp(FimplicatedList) and isEmptyProp(FevidenceList) and isEmptyProp(FDetail) and isEmptyProp(FReference) and isEmptyProp(FmitigationList);
end;

procedure TFhirDetectedIssue.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('code');
  fields.add('severity');
  fields.add('patient');
  fields.add('identified[x]');
  fields.add('author');
  fields.add('implicated');
  fields.add('evidence');
  fields.add('detail');
  fields.add('reference');
  fields.add('mitigation');
end;

function TFhirDetectedIssue.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FImplicatedList.sizeInBytes(magic));
  inc(result, FEvidenceList.sizeInBytes(magic));
  inc(result, FMitigationList.sizeInBytes(magic));
end;

function TFhirDetectedIssue.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDetectedIssue.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDetectedIssue.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDetectedIssue.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

procedure TFhirDetectedIssue.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

procedure TFhirDetectedIssue.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirDetectedIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

function TFhirDetectedIssue.GetSeverityST : TFhirDetectedIssueSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirDetectedIssueSeverityEnum(0)
  else
    result := TFhirDetectedIssueSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirDetectedIssueSeverityEnum, FSeverity.value));
end;

procedure TFhirDetectedIssue.SetSeverityST(value : TFhirDetectedIssueSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirDetectedIssueSeverityEnum[value], CODES_TFhirDetectedIssueSeverityEnum[value]);
end;

procedure TFhirDetectedIssue.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirDetectedIssue.SetIdentified(value : TFhirDataType);
begin
  FIdentified.free;
  FIdentified := value;
end;

procedure TFhirDetectedIssue.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirDetectedIssue.GetImplicatedList : TFhirReferenceList;
begin
  if FImplicatedList = nil then
    FImplicatedList := TFhirReferenceList.Create;
  result := FImplicatedList;
end;

function TFhirDetectedIssue.GetHasImplicatedList : boolean;
begin
  result := (FImplicatedList <> nil) and (FImplicatedList.count > 0);
end;

function TFhirDetectedIssue.GetEvidenceList : TFhirDetectedIssueEvidenceList;
begin
  if FEvidenceList = nil then
    FEvidenceList := TFhirDetectedIssueEvidenceList.Create;
  result := FEvidenceList;
end;

function TFhirDetectedIssue.GetHasEvidenceList : boolean;
begin
  result := (FEvidenceList <> nil) and (FEvidenceList.count > 0);
end;

procedure TFhirDetectedIssue.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

function TFhirDetectedIssue.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

procedure TFhirDetectedIssue.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

procedure TFhirDetectedIssue.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

function TFhirDetectedIssue.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

procedure TFhirDetectedIssue.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

function TFhirDetectedIssue.GetMitigationList : TFhirDetectedIssueMitigationList;
begin
  if FMitigationList = nil then
    FMitigationList := TFhirDetectedIssueMitigationList.Create;
  result := FMitigationList;
end;

function TFhirDetectedIssue.GetHasMitigationList : boolean;
begin
  result := (FMitigationList <> nil) and (FMitigationList.count > 0);
end;

{ TFhirDetectedIssueListEnumerator }

constructor TFhirDetectedIssueListEnumerator.Create(list : TFhirDetectedIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDetectedIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDetectedIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDetectedIssueListEnumerator.GetCurrent : TFhirDetectedIssue;
begin
  Result := FList[FIndex];
end;

function TFhirDetectedIssueListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDetectedIssueList }

function TFhirDetectedIssueList.AddItem(value: TFhirDetectedIssue): TFhirDetectedIssue;
begin
  assert(value.ClassName = 'TFhirDetectedIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDetectedIssue');
  add(value);
  result := value;
end;

function TFhirDetectedIssueList.Append: TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueList.ClearItems;
begin
  Clear;
end;

function TFhirDetectedIssueList.GetEnumerator : TFhirDetectedIssueListEnumerator;
begin
  result := TFhirDetectedIssueListEnumerator.Create(self.link);
end;

function TFhirDetectedIssueList.Clone: TFhirDetectedIssueList;
begin
  result := TFhirDetectedIssueList(inherited Clone);
end;

function TFhirDetectedIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDetectedIssueList.GetItemN(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(ObjectByIndex[index]);
end;

function TFhirDetectedIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirDetectedIssue;
end;
function TFhirDetectedIssueList.IndexOf(value: TFhirDetectedIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDetectedIssueList.Insert(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDetectedIssueList.InsertItem(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  Inherited Insert(index, value);
end;

function TFhirDetectedIssueList.Item(index: Integer): TFhirDetectedIssue;
begin
  result := TFhirDetectedIssue(ObjectByIndex[index]);
end;

function TFhirDetectedIssueList.Link: TFhirDetectedIssueList;
begin
  result := TFhirDetectedIssueList(inherited Link);
end;

procedure TFhirDetectedIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDetectedIssueList.SetItemByIndex(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  FhirDetectedIssues[index] := value;
end;

procedure TFhirDetectedIssueList.SetItemN(index: Integer; value: TFhirDetectedIssue);
begin
  assert(value is TFhirDetectedIssue);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DETECTEDISSUE}
{$IFDEF FHIR_DEVICEREQUEST}
{ TFhirDeviceRequestParameter }

constructor TFhirDeviceRequestParameter.Create;
begin
  inherited;
end;

destructor TFhirDeviceRequestParameter.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirDeviceRequestParameter.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirDeviceRequestParameter(oSource).code.Clone;
  value := TFhirDeviceRequestParameter(oSource).value.Clone;
end;

procedure TFhirDeviceRequestParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirDeviceRequestParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|Range|boolean', false, TFhirDataType, FValue.Link));
end;

function TFhirDeviceRequestParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceRequestParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceRequestParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceRequestParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|Range|boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceRequestParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceRequestParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceRequestParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceRequestParameter.fhirType : string;
begin
  result := 'DeviceRequest.parameter';
end;

function TFhirDeviceRequestParameter.Link : TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter(inherited Link);
end;

function TFhirDeviceRequestParameter.Clone : TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter(inherited Clone);
end;

function TFhirDeviceRequestParameter.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceRequestParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceRequestParameter)) then
    result := false
  else
  begin
    o := TFhirDeviceRequestParameter(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDeviceRequestParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirDeviceRequestParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
end;

function TFhirDeviceRequestParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceRequestParameter.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirDeviceRequestParameter.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirDeviceRequestParameterListEnumerator }

constructor TFhirDeviceRequestParameterListEnumerator.Create(list : TFhirDeviceRequestParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceRequestParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceRequestParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceRequestParameterListEnumerator.GetCurrent : TFhirDeviceRequestParameter;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceRequestParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceRequestParameterList }

function TFhirDeviceRequestParameterList.AddItem(value: TFhirDeviceRequestParameter): TFhirDeviceRequestParameter;
begin
  assert(value.ClassName = 'TFhirDeviceRequestParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceRequestParameter');
  add(value);
  result := value;
end;

function TFhirDeviceRequestParameterList.Append: TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestParameterList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceRequestParameterList.GetEnumerator : TFhirDeviceRequestParameterListEnumerator;
begin
  result := TFhirDeviceRequestParameterListEnumerator.Create(self.link);
end;

function TFhirDeviceRequestParameterList.Clone: TFhirDeviceRequestParameterList;
begin
  result := TFhirDeviceRequestParameterList(inherited Clone);
end;

function TFhirDeviceRequestParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceRequestParameterList.GetItemN(index: Integer): TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter(ObjectByIndex[index]);
end;

function TFhirDeviceRequestParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceRequestParameter;
end;
function TFhirDeviceRequestParameterList.IndexOf(value: TFhirDeviceRequestParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceRequestParameterList.Insert(index: Integer): TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestParameterList.InsertItem(index: Integer; value: TFhirDeviceRequestParameter);
begin
  assert(value is TFhirDeviceRequestParameter);
  Inherited Insert(index, value);
end;

function TFhirDeviceRequestParameterList.Item(index: Integer): TFhirDeviceRequestParameter;
begin
  result := TFhirDeviceRequestParameter(ObjectByIndex[index]);
end;

function TFhirDeviceRequestParameterList.Link: TFhirDeviceRequestParameterList;
begin
  result := TFhirDeviceRequestParameterList(inherited Link);
end;

procedure TFhirDeviceRequestParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceRequestParameterList.SetItemByIndex(index: Integer; value: TFhirDeviceRequestParameter);
begin
  assert(value is TFhirDeviceRequestParameter);
  FhirDeviceRequestParameters[index] := value;
end;

procedure TFhirDeviceRequestParameterList.SetItemN(index: Integer; value: TFhirDeviceRequestParameter);
begin
  assert(value is TFhirDeviceRequestParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceRequest }

constructor TFhirDeviceRequest.Create;
begin
  inherited;
end;

destructor TFhirDeviceRequest.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FPriorRequestList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FParameterList.Free;
  FSubject.free;
  FEncounter.free;
  FOccurrence.free;
  FAuthoredOn.free;
  FRequester.free;
  FPerformerType.free;
  FPerformer.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FInsuranceList.Free;
  FSupportingInfoList.Free;
  FNoteList.Free;
  FRelevantHistoryList.Free;
  inherited;
end;

procedure TFhirDeviceRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceRequest(oSource).FIdentifierList);
  end;
  if (TFhirDeviceRequest(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirDeviceRequest(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirDeviceRequest(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirDeviceRequest(oSource).FInstantiatesUriList);
  end;
  if (TFhirDeviceRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirDeviceRequest(oSource).FBasedOnList);
  end;
  if (TFhirDeviceRequest(oSource).FPriorRequestList = nil) then
  begin
    FPriorRequestList.free;
    FPriorRequestList := nil;
  end
  else
  begin
    if FPriorRequestList = nil then
      FPriorRequestList := TFhirReferenceList.Create;
    FPriorRequestList.Assign(TFhirDeviceRequest(oSource).FPriorRequestList);
  end;
  groupIdentifier := TFhirDeviceRequest(oSource).groupIdentifier.Clone;
  statusElement := TFhirDeviceRequest(oSource).statusElement.Clone;
  intentElement := TFhirDeviceRequest(oSource).intentElement.Clone;
  priorityElement := TFhirDeviceRequest(oSource).priorityElement.Clone;
  code := TFhirDeviceRequest(oSource).code.Clone;
  if (TFhirDeviceRequest(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirDeviceRequestParameterList.Create;
    FParameterList.Assign(TFhirDeviceRequest(oSource).FParameterList);
  end;
  subject := TFhirDeviceRequest(oSource).subject.Clone;
  encounter := TFhirDeviceRequest(oSource).encounter.Clone;
  occurrence := TFhirDeviceRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirDeviceRequest(oSource).authoredOnElement.Clone;
  requester := TFhirDeviceRequest(oSource).requester.Clone;
  performerType := TFhirDeviceRequest(oSource).performerType.Clone;
  performer := TFhirDeviceRequest(oSource).performer.Clone;
  if (TFhirDeviceRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirDeviceRequest(oSource).FReasonCodeList);
  end;
  if (TFhirDeviceRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirDeviceRequest(oSource).FReasonReferenceList);
  end;
  if (TFhirDeviceRequest(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirReferenceList.Create;
    FInsuranceList.Assign(TFhirDeviceRequest(oSource).FInsuranceList);
  end;
  if (TFhirDeviceRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirDeviceRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirDeviceRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDeviceRequest(oSource).FNoteList);
  end;
  if (TFhirDeviceRequest(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList.Create;
    FRelevantHistoryList.Assign(TFhirDeviceRequest(oSource).FRelevantHistoryList);
  end;
end;

function TFhirDeviceRequest.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceRequest;
end;

procedure TFhirDeviceRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'priorRequest') Then
    list.addAll(self, 'priorRequest', FPriorRequestList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code[x]') or (child_name = 'code') Then
     list.add(self.link, 'code[x]', FCode.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performerType') Then
     list.add(self.link, 'performerType', FPerformerType.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
end;

procedure TFhirDeviceRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'priorRequest', 'Reference', true, TFhirReference, FPriorRequestList.Link));
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code[x]', 'Reference|CodeableConcept', false, TFhirDataType, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirDeviceRequestParameter, FParameterList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link));
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerType.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'Reference', true, TFhirReference, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference', true, TFhirReference, FRelevantHistoryList.Link));
end;

function TFhirDeviceRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'priorRequest') then
  begin
    PriorRequestList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'code', ['Reference', 'CodeableConcept'])) then
  begin
    Code := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirDeviceRequestParameter);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'priorRequest') then PriorRequestList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirDeviceRequestParameter)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirDeviceRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'priorRequest') then result := PriorRequestList.new()
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull]) 
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull]) 
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (isMatchingName(propName, 'code', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Code')
  else if (propName = 'parameter') then result := ParameterList.new()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'requester') then result := TFhirReference.create()
  else if (propName = 'performerType') then result := TFhirCodeableConcept.create()
  else if (propName = 'performer') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'priorRequest') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'parameter') then result := 'BackboneElement'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'insurance') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'priorRequest') then deletePropertyValue('priorRequest', PriorRequestList, value)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (isMatchingName(propName, 'code', ['Reference', 'CodeableConcept'])) then CodeElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performerType') then PerformerTypeElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'priorRequest') then replacePropertyValue('priorRequest', PriorRequestList, existing, new)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new)
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (isMatchingName(propName, 'code', ['Reference', 'CodeableConcept'])) then CodeElement := new as TFhirDataType
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'requester') then RequesterElement := new as TFhirReference
  else if (propName = 'performerType') then PerformerTypeElement := new as TFhirCodeableConcept
  else if (propName = 'performer') then PerformerElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'priorRequest') then PriorRequestList.move(source, destination)
  else if (propName = 'parameter') then ParameterList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceRequest.fhirType : string;
begin
  result := 'DeviceRequest';
end;

function TFhirDeviceRequest.Link : TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(inherited Link);
end;

function TFhirDeviceRequest.Clone : TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(inherited Clone);
end;

function TFhirDeviceRequest.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceRequest)) then
    result := false
  else
  begin
    o := TFhirDeviceRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(priorRequestList, o.priorRequestList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(parameterList, o.parameterList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(performerTypeElement, o.performerTypeElement, true) and compareDeep(performerElement, o.performerElement, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(relevantHistoryList, o.relevantHistoryList, true);
  end;
end;

function TFhirDeviceRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpriorRequestList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FparameterList) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FPerformerType) and isEmptyProp(FPerformer) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FinsuranceList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FnoteList) and isEmptyProp(FrelevantHistoryList);
end;

procedure TFhirDeviceRequest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('priorRequest');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('priority');
  fields.add('code[x]');
  fields.add('parameter');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('performerType');
  fields.add('performer');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('insurance');
  fields.add('supportingInfo');
  fields.add('note');
  fields.add('relevantHistory');
end;

function TFhirDeviceRequest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPriorRequestList.sizeInBytes(magic));
  inc(result, FParameterList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FSupportingInfoList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FRelevantHistoryList.sizeInBytes(magic));
end;

function TFhirDeviceRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDeviceRequest.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirDeviceRequest.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirDeviceRequest.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirDeviceRequest.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirDeviceRequest.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirDeviceRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirDeviceRequest.GetPriorRequestList : TFhirReferenceList;
begin
  if FPriorRequestList = nil then
    FPriorRequestList := TFhirReferenceList.Create;
  result := FPriorRequestList;
end;

function TFhirDeviceRequest.GetHasPriorRequestList : boolean;
begin
  result := (FPriorRequestList <> nil) and (FPriorRequestList.count > 0);
end;

procedure TFhirDeviceRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

procedure TFhirDeviceRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDeviceRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirDeviceRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirDeviceRequest.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirDeviceRequest.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirDeviceRequest.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

procedure TFhirDeviceRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirDeviceRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirDeviceRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirDeviceRequest.SetCode(value : TFhirDataType);
begin
  FCode.free;
  FCode := value;
end;

function TFhirDeviceRequest.GetParameterList : TFhirDeviceRequestParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirDeviceRequestParameterList.Create;
  result := FParameterList;
end;

function TFhirDeviceRequest.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

procedure TFhirDeviceRequest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirDeviceRequest.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirDeviceRequest.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

procedure TFhirDeviceRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirDeviceRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirDeviceRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirDeviceRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value;
end;

procedure TFhirDeviceRequest.SetPerformerType(value : TFhirCodeableConcept);
begin
  FPerformerType.free;
  FPerformerType := value;
end;

procedure TFhirDeviceRequest.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value;
end;

function TFhirDeviceRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirDeviceRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirDeviceRequest.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirDeviceRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirDeviceRequest.GetInsuranceList : TFhirReferenceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirReferenceList.Create;
  result := FInsuranceList;
end;

function TFhirDeviceRequest.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirDeviceRequest.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirDeviceRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirDeviceRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDeviceRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirDeviceRequest.GetRelevantHistoryList : TFhirReferenceList;
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList.Create;
  result := FRelevantHistoryList;
end;

function TFhirDeviceRequest.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

{ TFhirDeviceRequestListEnumerator }

constructor TFhirDeviceRequestListEnumerator.Create(list : TFhirDeviceRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceRequestListEnumerator.GetCurrent : TFhirDeviceRequest;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceRequestList }

function TFhirDeviceRequestList.AddItem(value: TFhirDeviceRequest): TFhirDeviceRequest;
begin
  assert(value.ClassName = 'TFhirDeviceRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceRequest');
  add(value);
  result := value;
end;

function TFhirDeviceRequestList.Append: TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceRequestList.GetEnumerator : TFhirDeviceRequestListEnumerator;
begin
  result := TFhirDeviceRequestListEnumerator.Create(self.link);
end;

function TFhirDeviceRequestList.Clone: TFhirDeviceRequestList;
begin
  result := TFhirDeviceRequestList(inherited Clone);
end;

function TFhirDeviceRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceRequestList.GetItemN(index: Integer): TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(ObjectByIndex[index]);
end;

function TFhirDeviceRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceRequest;
end;
function TFhirDeviceRequestList.IndexOf(value: TFhirDeviceRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceRequestList.Insert(index: Integer): TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceRequestList.InsertItem(index: Integer; value: TFhirDeviceRequest);
begin
  assert(value is TFhirDeviceRequest);
  Inherited Insert(index, value);
end;

function TFhirDeviceRequestList.Item(index: Integer): TFhirDeviceRequest;
begin
  result := TFhirDeviceRequest(ObjectByIndex[index]);
end;

function TFhirDeviceRequestList.Link: TFhirDeviceRequestList;
begin
  result := TFhirDeviceRequestList(inherited Link);
end;

procedure TFhirDeviceRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceRequestList.SetItemByIndex(index: Integer; value: TFhirDeviceRequest);
begin
  assert(value is TFhirDeviceRequest);
  FhirDeviceRequests[index] := value;
end;

procedure TFhirDeviceRequestList.SetItemN(index: Integer; value: TFhirDeviceRequest);
begin
  assert(value is TFhirDeviceRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEREQUEST}
{$IFDEF FHIR_DEVICEUSESTATEMENT}
{ TFhirDeviceUseStatement }

constructor TFhirDeviceUseStatement.Create;
begin
  inherited;
end;

destructor TFhirDeviceUseStatement.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FStatus.free;
  FSubject.free;
  FDerivedFromList.Free;
  FTiming.free;
  FRecordedOn.free;
  FSource.free;
  FDevice.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FBodySite.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirDeviceUseStatement.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceUseStatement(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceUseStatement(oSource).FIdentifierList);
  end;
  if (TFhirDeviceUseStatement(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirDeviceUseStatement(oSource).FBasedOnList);
  end;
  statusElement := TFhirDeviceUseStatement(oSource).statusElement.Clone;
  subject := TFhirDeviceUseStatement(oSource).subject.Clone;
  if (TFhirDeviceUseStatement(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirReferenceList.Create;
    FDerivedFromList.Assign(TFhirDeviceUseStatement(oSource).FDerivedFromList);
  end;
  timing := TFhirDeviceUseStatement(oSource).timing.Clone;
  recordedOnElement := TFhirDeviceUseStatement(oSource).recordedOnElement.Clone;
  source := TFhirDeviceUseStatement(oSource).source.Clone;
  device := TFhirDeviceUseStatement(oSource).device.Clone;
  if (TFhirDeviceUseStatement(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirDeviceUseStatement(oSource).FReasonCodeList);
  end;
  if (TFhirDeviceUseStatement(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirDeviceUseStatement(oSource).FReasonReferenceList);
  end;
  bodySite := TFhirDeviceUseStatement(oSource).bodySite.Clone;
  if (TFhirDeviceUseStatement(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDeviceUseStatement(oSource).FNoteList);
  end;
end;

function TFhirDeviceUseStatement.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceUseStatement;
end;

procedure TFhirDeviceUseStatement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'recordedOn') Then
     list.add(self.link, 'recordedOn', FRecordedOn.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirDeviceUseStatement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'Reference', true, TFhirReference, FDerivedFromList.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Timing|Period|dateTime', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'recordedOn', 'dateTime', false, TFhirDateTime, FRecordedOn.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirDeviceUseStatement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDeviceUseStatementStatusEnum, CODES_TFhirDeviceUseStatementStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'recordedOn') then
  begin
    RecordedOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceUseStatement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirDeviceUseStatement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirDeviceUseStatementStatusEnum[DeviceUseStatementStatusNull], CODES_TFhirDeviceUseStatementStatusEnum[DeviceUseStatementStatusNull]) 
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'derivedFrom') then result := DerivedFromList.new()
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (propName = 'recordedOn') then result := TFhirDateTime.create()
  else if (propName = 'source') then result := TFhirReference.create()
  else if (propName = 'device') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceUseStatement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'derivedFrom') then result := 'Reference'
  else if (propName = 'timing[x]') then result := 'Timing|Period|dateTime'
  else if (propName = 'recordedOn') then result := 'dateTime'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceUseStatement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value)
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := nil
  else if (propName = 'recordedOn') then RecordedOnElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceUseStatement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDeviceUseStatementStatusEnum, CODES_TFhirDeviceUseStatementStatusEnum, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new)
  else if (isMatchingName(propName, 'timing', ['Timing', 'Period', 'DateTime'])) then TimingElement := new as TFhirDataType
  else if (propName = 'recordedOn') then RecordedOnElement := asDateTime(new)
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else if (propName = 'device') then DeviceElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceUseStatement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceUseStatement.fhirType : string;
begin
  result := 'DeviceUseStatement';
end;

function TFhirDeviceUseStatement.Link : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(inherited Link);
end;

function TFhirDeviceUseStatement.Clone : TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(inherited Clone);
end;

function TFhirDeviceUseStatement.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceUseStatement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceUseStatement)) then
    result := false
  else
  begin
    o := TFhirDeviceUseStatement(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(derivedFromList, o.derivedFromList, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(recordedOnElement, o.recordedOnElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(deviceElement, o.deviceElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirDeviceUseStatement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FderivedFromList) and isEmptyProp(FTiming) and isEmptyProp(FRecordedOn) and isEmptyProp(FSource) and isEmptyProp(FDevice) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FBodySite) and isEmptyProp(FnoteList);
end;

procedure TFhirDeviceUseStatement.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('status');
  fields.add('subject');
  fields.add('derivedFrom');
  fields.add('timing[x]');
  fields.add('recordedOn');
  fields.add('source');
  fields.add('device');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('bodySite');
  fields.add('note');
end;

function TFhirDeviceUseStatement.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FDerivedFromList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirDeviceUseStatement.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceUseStatement.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDeviceUseStatement.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirDeviceUseStatement.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirDeviceUseStatement.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDeviceUseStatement.GetStatusST : TFhirDeviceUseStatementStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDeviceUseStatementStatusEnum(0)
  else
    result := TFhirDeviceUseStatementStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceUseStatementStatusEnum, FStatus.value));
end;

procedure TFhirDeviceUseStatement.SetStatusST(value : TFhirDeviceUseStatementStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDeviceUseStatementStatusEnum[value], CODES_TFhirDeviceUseStatementStatusEnum[value]);
end;

procedure TFhirDeviceUseStatement.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

function TFhirDeviceUseStatement.GetDerivedFromList : TFhirReferenceList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirReferenceList.Create;
  result := FDerivedFromList;
end;

function TFhirDeviceUseStatement.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

procedure TFhirDeviceUseStatement.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

procedure TFhirDeviceUseStatement.SetRecordedOn(value : TFhirDateTime);
begin
  FRecordedOn.free;
  FRecordedOn := value;
end;

function TFhirDeviceUseStatement.GetRecordedOnST : TFslDateTime;
begin
  if FRecordedOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecordedOn.value;
end;

procedure TFhirDeviceUseStatement.SetRecordedOnST(value : TFslDateTime);
begin
  if FRecordedOn = nil then
    FRecordedOn := TFhirDateTime.create;
  FRecordedOn.value := value
end;

procedure TFhirDeviceUseStatement.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirDeviceUseStatement.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value;
end;

function TFhirDeviceUseStatement.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirDeviceUseStatement.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirDeviceUseStatement.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirDeviceUseStatement.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

procedure TFhirDeviceUseStatement.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

function TFhirDeviceUseStatement.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDeviceUseStatement.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirDeviceUseStatementListEnumerator }

constructor TFhirDeviceUseStatementListEnumerator.Create(list : TFhirDeviceUseStatementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceUseStatementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDeviceUseStatementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceUseStatementListEnumerator.GetCurrent : TFhirDeviceUseStatement;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceUseStatementListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceUseStatementList }

function TFhirDeviceUseStatementList.AddItem(value: TFhirDeviceUseStatement): TFhirDeviceUseStatement;
begin
  assert(value.ClassName = 'TFhirDeviceUseStatement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceUseStatement');
  add(value);
  result := value;
end;

function TFhirDeviceUseStatementList.Append: TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseStatementList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceUseStatementList.GetEnumerator : TFhirDeviceUseStatementListEnumerator;
begin
  result := TFhirDeviceUseStatementListEnumerator.Create(self.link);
end;

function TFhirDeviceUseStatementList.Clone: TFhirDeviceUseStatementList;
begin
  result := TFhirDeviceUseStatementList(inherited Clone);
end;

function TFhirDeviceUseStatementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceUseStatementList.GetItemN(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(ObjectByIndex[index]);
end;

function TFhirDeviceUseStatementList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceUseStatement;
end;
function TFhirDeviceUseStatementList.IndexOf(value: TFhirDeviceUseStatement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceUseStatementList.Insert(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUseStatementList.InsertItem(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  Inherited Insert(index, value);
end;

function TFhirDeviceUseStatementList.Item(index: Integer): TFhirDeviceUseStatement;
begin
  result := TFhirDeviceUseStatement(ObjectByIndex[index]);
end;

function TFhirDeviceUseStatementList.Link: TFhirDeviceUseStatementList;
begin
  result := TFhirDeviceUseStatementList(inherited Link);
end;

procedure TFhirDeviceUseStatementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceUseStatementList.SetItemByIndex(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  FhirDeviceUseStatements[index] := value;
end;

procedure TFhirDeviceUseStatementList.SetItemN(index: Integer; value: TFhirDeviceUseStatement);
begin
  assert(value is TFhirDeviceUseStatement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEUSESTATEMENT}
{$IFDEF FHIR_DIAGNOSTICREPORT}
{ TFhirDiagnosticReportMedia }

constructor TFhirDiagnosticReportMedia.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReportMedia.Destroy;
begin
  FComment.free;
  FLink_.free;
  inherited;
end;

procedure TFhirDiagnosticReportMedia.Assign(oSource : TFslObject);
begin
  inherited;
  commentElement := TFhirDiagnosticReportMedia(oSource).commentElement.Clone;
  link_ := TFhirDiagnosticReportMedia(oSource).link_.Clone;
end;

procedure TFhirDiagnosticReportMedia.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'link') Then
     list.add(self.link, 'link', FLink_.Link);
end;

procedure TFhirDiagnosticReportMedia.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'comment', 'string', false, TFhirString, FComment.Link));
  oList.add(TFHIRProperty.create(self, 'link', 'Reference', false, TFhirReference, FLink_.Link));
end;

function TFhirDiagnosticReportMedia.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_ := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDiagnosticReportMedia.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDiagnosticReportMedia.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'comment') then result := TFhirString.create()
  else if (propName = 'link') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticReportMedia.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'comment') then result := 'string'
  else if (propName = 'link') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticReportMedia.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := nil
  else if (propName = 'link') then Link_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticReportMedia.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'comment') then CommentElement := asString(new)
  else if (propName = 'link') then Link_Element := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticReportMedia.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticReportMedia.fhirType : string;
begin
  result := 'DiagnosticReport.media';
end;

function TFhirDiagnosticReportMedia.Link : TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia(inherited Link);
end;

function TFhirDiagnosticReportMedia.Clone : TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia(inherited Clone);
end;

function TFhirDiagnosticReportMedia.equals(other : TObject) : boolean; 
var
  o : TFhirDiagnosticReportMedia;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticReportMedia)) then
    result := false
  else
  begin
    o := TFhirDiagnosticReportMedia(other);
    result := compareDeep(commentElement, o.commentElement, true) and compareDeep(link_Element, o.link_Element, true);
  end;
end;

function TFhirDiagnosticReportMedia.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FComment) and isEmptyProp(FLink_);
end;

procedure TFhirDiagnosticReportMedia.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('comment');
  fields.add('link');
end;

function TFhirDiagnosticReportMedia.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDiagnosticReportMedia.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirDiagnosticReportMedia.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirDiagnosticReportMedia.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirDiagnosticReportMedia.SetLink_(value : TFhirReference);
begin
  FLink_.free;
  FLink_ := value;
end;

{ TFhirDiagnosticReportMediaListEnumerator }

constructor TFhirDiagnosticReportMediaListEnumerator.Create(list : TFhirDiagnosticReportMediaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticReportMediaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportMediaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticReportMediaListEnumerator.GetCurrent : TFhirDiagnosticReportMedia;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticReportMediaListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDiagnosticReportMediaList }

function TFhirDiagnosticReportMediaList.AddItem(value: TFhirDiagnosticReportMedia): TFhirDiagnosticReportMedia;
begin
  assert(value.ClassName = 'TFhirDiagnosticReportMedia', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReportMedia');
  add(value);
  result := value;
end;

function TFhirDiagnosticReportMediaList.Append: TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportMediaList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportMediaList.GetEnumerator : TFhirDiagnosticReportMediaListEnumerator;
begin
  result := TFhirDiagnosticReportMediaListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportMediaList.Clone: TFhirDiagnosticReportMediaList;
begin
  result := TFhirDiagnosticReportMediaList(inherited Clone);
end;

function TFhirDiagnosticReportMediaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportMediaList.GetItemN(index: Integer): TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportMediaList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticReportMedia;
end;
function TFhirDiagnosticReportMediaList.IndexOf(value: TFhirDiagnosticReportMedia): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticReportMediaList.Insert(index: Integer): TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportMediaList.InsertItem(index: Integer; value: TFhirDiagnosticReportMedia);
begin
  assert(value is TFhirDiagnosticReportMedia);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportMediaList.Item(index: Integer): TFhirDiagnosticReportMedia;
begin
  result := TFhirDiagnosticReportMedia(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportMediaList.Link: TFhirDiagnosticReportMediaList;
begin
  result := TFhirDiagnosticReportMediaList(inherited Link);
end;

procedure TFhirDiagnosticReportMediaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportMediaList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReportMedia);
begin
  assert(value is TFhirDiagnosticReportMedia);
  FhirDiagnosticReportMedia[index] := value;
end;

procedure TFhirDiagnosticReportMediaList.SetItemN(index: Integer; value: TFhirDiagnosticReportMedia);
begin
  assert(value is TFhirDiagnosticReportMedia);
  ObjectByIndex[index] := value;
end;

{ TFhirDiagnosticReport }

constructor TFhirDiagnosticReport.Create;
begin
  inherited;
end;

destructor TFhirDiagnosticReport.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FEffective.free;
  FIssued.free;
  FPerformerList.Free;
  FResultsInterpreterList.Free;
  FSpecimenList.Free;
  FResultList.Free;
  FImagingStudyList.Free;
  FMediaList.Free;
  FConclusion.free;
  FConclusionCodeList.Free;
  FPresentedFormList.Free;
  inherited;
end;

procedure TFhirDiagnosticReport.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDiagnosticReport(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDiagnosticReport(oSource).FIdentifierList);
  end;
  if (TFhirDiagnosticReport(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirDiagnosticReport(oSource).FBasedOnList);
  end;
  statusElement := TFhirDiagnosticReport(oSource).statusElement.Clone;
  if (TFhirDiagnosticReport(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirDiagnosticReport(oSource).FCategoryList);
  end;
  code := TFhirDiagnosticReport(oSource).code.Clone;
  subject := TFhirDiagnosticReport(oSource).subject.Clone;
  encounter := TFhirDiagnosticReport(oSource).encounter.Clone;
  effective := TFhirDiagnosticReport(oSource).effective.Clone;
  issuedElement := TFhirDiagnosticReport(oSource).issuedElement.Clone;
  if (TFhirDiagnosticReport(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList.Create;
    FPerformerList.Assign(TFhirDiagnosticReport(oSource).FPerformerList);
  end;
  if (TFhirDiagnosticReport(oSource).FResultsInterpreterList = nil) then
  begin
    FResultsInterpreterList.free;
    FResultsInterpreterList := nil;
  end
  else
  begin
    if FResultsInterpreterList = nil then
      FResultsInterpreterList := TFhirReferenceList.Create;
    FResultsInterpreterList.Assign(TFhirDiagnosticReport(oSource).FResultsInterpreterList);
  end;
  if (TFhirDiagnosticReport(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList.Create;
    FSpecimenList.Assign(TFhirDiagnosticReport(oSource).FSpecimenList);
  end;
  if (TFhirDiagnosticReport(oSource).FResultList = nil) then
  begin
    FResultList.free;
    FResultList := nil;
  end
  else
  begin
    if FResultList = nil then
      FResultList := TFhirReferenceList.Create;
    FResultList.Assign(TFhirDiagnosticReport(oSource).FResultList);
  end;
  if (TFhirDiagnosticReport(oSource).FImagingStudyList = nil) then
  begin
    FImagingStudyList.free;
    FImagingStudyList := nil;
  end
  else
  begin
    if FImagingStudyList = nil then
      FImagingStudyList := TFhirReferenceList.Create;
    FImagingStudyList.Assign(TFhirDiagnosticReport(oSource).FImagingStudyList);
  end;
  if (TFhirDiagnosticReport(oSource).FMediaList = nil) then
  begin
    FMediaList.free;
    FMediaList := nil;
  end
  else
  begin
    if FMediaList = nil then
      FMediaList := TFhirDiagnosticReportMediaList.Create;
    FMediaList.Assign(TFhirDiagnosticReport(oSource).FMediaList);
  end;
  conclusionElement := TFhirDiagnosticReport(oSource).conclusionElement.Clone;
  if (TFhirDiagnosticReport(oSource).FConclusionCodeList = nil) then
  begin
    FConclusionCodeList.free;
    FConclusionCodeList := nil;
  end
  else
  begin
    if FConclusionCodeList = nil then
      FConclusionCodeList := TFhirCodeableConceptList.Create;
    FConclusionCodeList.Assign(TFhirDiagnosticReport(oSource).FConclusionCodeList);
  end;
  if (TFhirDiagnosticReport(oSource).FPresentedFormList = nil) then
  begin
    FPresentedFormList.free;
    FPresentedFormList := nil;
  end
  else
  begin
    if FPresentedFormList = nil then
      FPresentedFormList := TFhirAttachmentList.Create;
    FPresentedFormList.Assign(TFhirDiagnosticReport(oSource).FPresentedFormList);
  end;
end;

function TFhirDiagnosticReport.GetResourceType : TFhirResourceType;
begin
  result := frtDiagnosticReport;
end;

procedure TFhirDiagnosticReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'resultsInterpreter') Then
    list.addAll(self, 'resultsInterpreter', FResultsInterpreterList);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'result') Then
    list.addAll(self, 'result', FResultList);
  if (child_name = 'imagingStudy') Then
    list.addAll(self, 'imagingStudy', FImagingStudyList);
  if (child_name = 'media') Then
    list.addAll(self, 'media', FMediaList);
  if (child_name = 'conclusion') Then
     list.add(self.link, 'conclusion', FConclusion.Link);
  if (child_name = 'conclusionCode') Then
    list.addAll(self, 'conclusionCode', FConclusionCodeList);
  if (child_name = 'presentedForm') Then
    list.addAll(self, 'presentedForm', FPresentedFormList);
end;

procedure TFhirDiagnosticReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirDataType, FEffective.Link));
  oList.add(TFHIRProperty.create(self, 'issued', 'instant', false, TFhirInstant, FIssued.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', true, TFhirReference, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'resultsInterpreter', 'Reference', true, TFhirReference, FResultsInterpreterList.Link));
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', true, TFhirReference, FSpecimenList.Link));
  oList.add(TFHIRProperty.create(self, 'result', 'Reference', true, TFhirReference, FResultList.Link));
  oList.add(TFHIRProperty.create(self, 'imagingStudy', 'Reference', true, TFhirReference, FImagingStudyList.Link));
  oList.add(TFHIRProperty.create(self, 'media', 'BackboneElement', true, TFhirDiagnosticReportMedia, FMediaList.Link));
  oList.add(TFHIRProperty.create(self, 'conclusion', 'string', false, TFhirString, FConclusion.Link));
  oList.add(TFHIRProperty.create(self, 'conclusionCode', 'CodeableConcept', true, TFhirCodeableConcept, FConclusionCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'presentedForm', 'Attachment', true, TFhirAttachment, FPresentedFormList.Link));
end;

function TFhirDiagnosticReport.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDiagnosticReportStatusEnum, CODES_TFhirDiagnosticReportStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'resultsInterpreter') then
  begin
    ResultsInterpreterList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    ResultList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'imagingStudy') then
  begin
    ImagingStudyList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'media') then
  begin
    MediaList.add(propValue as TFhirDiagnosticReportMedia);
    result := propValue;
  end
  else if (propName = 'conclusion') then
  begin
    ConclusionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'conclusionCode') then
  begin
    ConclusionCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'presentedForm') then
  begin
    PresentedFormList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDiagnosticReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'resultsInterpreter') then ResultsInterpreterList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'result') then ResultList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'imagingStudy') then ImagingStudyList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'media') then MediaList.insertItem(index, propValue as TFhirDiagnosticReportMedia)
  else if (propName = 'conclusionCode') then ConclusionCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'presentedForm') then PresentedFormList.insertItem(index, propValue as TFhirAttachment)
  else inherited;
end;

function TFhirDiagnosticReport.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirDiagnosticReportStatusEnum[DiagnosticReportStatusNull], CODES_TFhirDiagnosticReportStatusEnum[DiagnosticReportStatusNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective')
  else if (propName = 'issued') then result := TFhirInstant.create()
  else if (propName = 'performer') then result := PerformerList.new()
  else if (propName = 'resultsInterpreter') then result := ResultsInterpreterList.new()
  else if (propName = 'specimen') then result := SpecimenList.new()
  else if (propName = 'result') then result := ResultList.new()
  else if (propName = 'imagingStudy') then result := ImagingStudyList.new()
  else if (propName = 'media') then result := MediaList.new()
  else if (propName = 'conclusion') then result := TFhirString.create()
  else if (propName = 'conclusionCode') then result := ConclusionCodeList.new()
  else if (propName = 'presentedForm') then result := PresentedFormList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDiagnosticReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'issued') then result := 'instant'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'resultsInterpreter') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'result') then result := 'Reference'
  else if (propName = 'imagingStudy') then result := 'Reference'
  else if (propName = 'media') then result := 'BackboneElement'
  else if (propName = 'conclusion') then result := 'string'
  else if (propName = 'conclusionCode') then result := 'CodeableConcept'
  else if (propName = 'presentedForm') then result := 'Attachment'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDiagnosticReport.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (propName = 'resultsInterpreter') then deletePropertyValue('resultsInterpreter', ResultsInterpreterList, value)
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value)
  else if (propName = 'result') then deletePropertyValue('result', ResultList, value)
  else if (propName = 'imagingStudy') then deletePropertyValue('imagingStudy', ImagingStudyList, value)
  else if (propName = 'media') then deletePropertyValue('media', MediaList, value)
  else if (propName = 'conclusion') then ConclusionElement := nil
  else if (propName = 'conclusionCode') then deletePropertyValue('conclusionCode', ConclusionCodeList, value)
  else if (propName = 'presentedForm') then deletePropertyValue('presentedForm', PresentedFormList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDiagnosticReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDiagnosticReportStatusEnum, CODES_TFhirDiagnosticReportStatusEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirDataType
  else if (propName = 'issued') then IssuedElement := asInstant(new)
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (propName = 'resultsInterpreter') then replacePropertyValue('resultsInterpreter', ResultsInterpreterList, existing, new)
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new)
  else if (propName = 'result') then replacePropertyValue('result', ResultList, existing, new)
  else if (propName = 'imagingStudy') then replacePropertyValue('imagingStudy', ImagingStudyList, existing, new)
  else if (propName = 'media') then replacePropertyValue('media', MediaList, existing, new)
  else if (propName = 'conclusion') then ConclusionElement := asString(new)
  else if (propName = 'conclusionCode') then replacePropertyValue('conclusionCode', ConclusionCodeList, existing, new)
  else if (propName = 'presentedForm') then replacePropertyValue('presentedForm', PresentedFormList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDiagnosticReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'resultsInterpreter') then ResultsInterpreterList.move(source, destination)
  else if (propName = 'specimen') then SpecimenList.move(source, destination)
  else if (propName = 'result') then ResultList.move(source, destination)
  else if (propName = 'imagingStudy') then ImagingStudyList.move(source, destination)
  else if (propName = 'media') then MediaList.move(source, destination)
  else if (propName = 'conclusionCode') then ConclusionCodeList.move(source, destination)
  else if (propName = 'presentedForm') then PresentedFormList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDiagnosticReport.fhirType : string;
begin
  result := 'DiagnosticReport';
end;

function TFhirDiagnosticReport.Link : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(inherited Link);
end;

function TFhirDiagnosticReport.Clone : TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(inherited Clone);
end;

function TFhirDiagnosticReport.equals(other : TObject) : boolean; 
var
  o : TFhirDiagnosticReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDiagnosticReport)) then
    result := false
  else
  begin
    o := TFhirDiagnosticReport(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and 
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(resultsInterpreterList, o.resultsInterpreterList, true) and compareDeep(specimenList, o.specimenList, true) and 
      compareDeep(resultList, o.resultList, true) and compareDeep(imagingStudyList, o.imagingStudyList, true) and 
      compareDeep(mediaList, o.mediaList, true) and compareDeep(conclusionElement, o.conclusionElement, true) and 
      compareDeep(conclusionCodeList, o.conclusionCodeList, true) and compareDeep(presentedFormList, o.presentedFormList, true);
  end;
end;

function TFhirDiagnosticReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FEffective) and isEmptyProp(FIssued) and isEmptyProp(FperformerList) and isEmptyProp(FresultsInterpreterList) and isEmptyProp(FspecimenList) and isEmptyProp(FresultList) and isEmptyProp(FimagingStudyList) and isEmptyProp(FmediaList) and isEmptyProp(FConclusion) and isEmptyProp(FconclusionCodeList) and isEmptyProp(FpresentedFormList);
end;

procedure TFhirDiagnosticReport.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('effective[x]');
  fields.add('issued');
  fields.add('performer');
  fields.add('resultsInterpreter');
  fields.add('specimen');
  fields.add('result');
  fields.add('imagingStudy');
  fields.add('media');
  fields.add('conclusion');
  fields.add('conclusionCode');
  fields.add('presentedForm');
end;

function TFhirDiagnosticReport.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FResultsInterpreterList.sizeInBytes(magic));
  inc(result, FSpecimenList.sizeInBytes(magic));
  inc(result, FResultList.sizeInBytes(magic));
  inc(result, FImagingStudyList.sizeInBytes(magic));
  inc(result, FMediaList.sizeInBytes(magic));
  inc(result, FConclusionCodeList.sizeInBytes(magic));
  inc(result, FPresentedFormList.sizeInBytes(magic));
end;

function TFhirDiagnosticReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDiagnosticReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDiagnosticReport.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirDiagnosticReport.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirDiagnosticReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDiagnosticReport.GetStatusST : TFhirDiagnosticReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDiagnosticReportStatusEnum(0)
  else
    result := TFhirDiagnosticReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDiagnosticReportStatusEnum, FStatus.value));
end;

procedure TFhirDiagnosticReport.SetStatusST(value : TFhirDiagnosticReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDiagnosticReportStatusEnum[value], CODES_TFhirDiagnosticReportStatusEnum[value]);
end;

function TFhirDiagnosticReport.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirDiagnosticReport.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirDiagnosticReport.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirDiagnosticReport.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirDiagnosticReport.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirDiagnosticReport.SetEffective(value : TFhirDataType);
begin
  FEffective.free;
  FEffective := value;
end;

procedure TFhirDiagnosticReport.SetIssued(value : TFhirInstant);
begin
  FIssued.free;
  FIssued := value;
end;

function TFhirDiagnosticReport.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirDiagnosticReport.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirInstant.create;
  FIssued.value := value
end;

function TFhirDiagnosticReport.GetPerformerList : TFhirReferenceList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList.Create;
  result := FPerformerList;
end;

function TFhirDiagnosticReport.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirDiagnosticReport.GetResultsInterpreterList : TFhirReferenceList;
begin
  if FResultsInterpreterList = nil then
    FResultsInterpreterList := TFhirReferenceList.Create;
  result := FResultsInterpreterList;
end;

function TFhirDiagnosticReport.GetHasResultsInterpreterList : boolean;
begin
  result := (FResultsInterpreterList <> nil) and (FResultsInterpreterList.count > 0);
end;

function TFhirDiagnosticReport.GetSpecimenList : TFhirReferenceList;
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList.Create;
  result := FSpecimenList;
end;

function TFhirDiagnosticReport.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

function TFhirDiagnosticReport.GetResultList : TFhirReferenceList;
begin
  if FResultList = nil then
    FResultList := TFhirReferenceList.Create;
  result := FResultList;
end;

function TFhirDiagnosticReport.GetHasResultList : boolean;
begin
  result := (FResultList <> nil) and (FResultList.count > 0);
end;

function TFhirDiagnosticReport.GetImagingStudyList : TFhirReferenceList;
begin
  if FImagingStudyList = nil then
    FImagingStudyList := TFhirReferenceList.Create;
  result := FImagingStudyList;
end;

function TFhirDiagnosticReport.GetHasImagingStudyList : boolean;
begin
  result := (FImagingStudyList <> nil) and (FImagingStudyList.count > 0);
end;

function TFhirDiagnosticReport.GetMediaList : TFhirDiagnosticReportMediaList;
begin
  if FMediaList = nil then
    FMediaList := TFhirDiagnosticReportMediaList.Create;
  result := FMediaList;
end;

function TFhirDiagnosticReport.GetHasMediaList : boolean;
begin
  result := (FMediaList <> nil) and (FMediaList.count > 0);
end;

procedure TFhirDiagnosticReport.SetConclusion(value : TFhirString);
begin
  FConclusion.free;
  FConclusion := value;
end;

function TFhirDiagnosticReport.GetConclusionST : String;
begin
  if FConclusion = nil then
    result := ''
  else
    result := FConclusion.value;
end;

procedure TFhirDiagnosticReport.SetConclusionST(value : String);
begin
  if value <> '' then
  begin
    if FConclusion = nil then
      FConclusion := TFhirString.create;
    FConclusion.value := value
  end
  else if FConclusion <> nil then
    FConclusion.value := '';
end;

function TFhirDiagnosticReport.GetConclusionCodeList : TFhirCodeableConceptList;
begin
  if FConclusionCodeList = nil then
    FConclusionCodeList := TFhirCodeableConceptList.Create;
  result := FConclusionCodeList;
end;

function TFhirDiagnosticReport.GetHasConclusionCodeList : boolean;
begin
  result := (FConclusionCodeList <> nil) and (FConclusionCodeList.count > 0);
end;

function TFhirDiagnosticReport.GetPresentedFormList : TFhirAttachmentList;
begin
  if FPresentedFormList = nil then
    FPresentedFormList := TFhirAttachmentList.Create;
  result := FPresentedFormList;
end;

function TFhirDiagnosticReport.GetHasPresentedFormList : boolean;
begin
  result := (FPresentedFormList <> nil) and (FPresentedFormList.count > 0);
end;

{ TFhirDiagnosticReportListEnumerator }

constructor TFhirDiagnosticReportListEnumerator.Create(list : TFhirDiagnosticReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDiagnosticReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDiagnosticReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDiagnosticReportListEnumerator.GetCurrent : TFhirDiagnosticReport;
begin
  Result := FList[FIndex];
end;

function TFhirDiagnosticReportListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDiagnosticReportList }

function TFhirDiagnosticReportList.AddItem(value: TFhirDiagnosticReport): TFhirDiagnosticReport;
begin
  assert(value.ClassName = 'TFhirDiagnosticReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDiagnosticReport');
  add(value);
  result := value;
end;

function TFhirDiagnosticReportList.Append: TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportList.ClearItems;
begin
  Clear;
end;

function TFhirDiagnosticReportList.GetEnumerator : TFhirDiagnosticReportListEnumerator;
begin
  result := TFhirDiagnosticReportListEnumerator.Create(self.link);
end;

function TFhirDiagnosticReportList.Clone: TFhirDiagnosticReportList;
begin
  result := TFhirDiagnosticReportList(inherited Clone);
end;

function TFhirDiagnosticReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDiagnosticReportList.GetItemN(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirDiagnosticReport;
end;
function TFhirDiagnosticReportList.IndexOf(value: TFhirDiagnosticReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDiagnosticReportList.Insert(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDiagnosticReportList.InsertItem(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  Inherited Insert(index, value);
end;

function TFhirDiagnosticReportList.Item(index: Integer): TFhirDiagnosticReport;
begin
  result := TFhirDiagnosticReport(ObjectByIndex[index]);
end;

function TFhirDiagnosticReportList.Link: TFhirDiagnosticReportList;
begin
  result := TFhirDiagnosticReportList(inherited Link);
end;

procedure TFhirDiagnosticReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDiagnosticReportList.SetItemByIndex(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  FhirDiagnosticReports[index] := value;
end;

procedure TFhirDiagnosticReportList.SetItemN(index: Integer; value: TFhirDiagnosticReport);
begin
  assert(value is TFhirDiagnosticReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DIAGNOSTICREPORT}
{$IFDEF FHIR_DOCUMENTMANIFEST}
{ TFhirDocumentManifestRelated }

constructor TFhirDocumentManifestRelated.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifestRelated.Destroy;
begin
  FIdentifier.free;
  FRef.free;
  inherited;
end;

procedure TFhirDocumentManifestRelated.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirDocumentManifestRelated(oSource).identifier.Clone;
  ref := TFhirDocumentManifestRelated(oSource).ref.Clone;
end;

procedure TFhirDocumentManifestRelated.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'ref') Then
     list.add(self.link, 'ref', FRef.Link);
end;

procedure TFhirDocumentManifestRelated.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'ref', 'Reference', false, TFhirReference, FRef.Link));
end;

function TFhirDocumentManifestRelated.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'ref') then
  begin
    Ref := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentManifestRelated.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentManifestRelated.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'ref') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifestRelated.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'ref') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifestRelated.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'ref') then RefElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifestRelated.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'ref') then RefElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifestRelated.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifestRelated.fhirType : string;
begin
  result := 'DocumentManifest.related';
end;

function TFhirDocumentManifestRelated.Link : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(inherited Link);
end;

function TFhirDocumentManifestRelated.Clone : TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(inherited Clone);
end;

function TFhirDocumentManifestRelated.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentManifestRelated;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifestRelated)) then
    result := false
  else
  begin
    o := TFhirDocumentManifestRelated(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(refElement, o.refElement, true);
  end;
end;

function TFhirDocumentManifestRelated.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FRef);
end;

procedure TFhirDocumentManifestRelated.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('ref');
end;

function TFhirDocumentManifestRelated.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDocumentManifestRelated.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirDocumentManifestRelated.SetRef(value : TFhirReference);
begin
  FRef.free;
  FRef := value;
end;

{ TFhirDocumentManifestRelatedListEnumerator }

constructor TFhirDocumentManifestRelatedListEnumerator.Create(list : TFhirDocumentManifestRelatedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestRelatedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestRelatedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestRelatedListEnumerator.GetCurrent : TFhirDocumentManifestRelated;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestRelatedListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDocumentManifestRelatedList }

function TFhirDocumentManifestRelatedList.AddItem(value: TFhirDocumentManifestRelated): TFhirDocumentManifestRelated;
begin
  assert(value.ClassName = 'TFhirDocumentManifestRelated', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifestRelated');
  add(value);
  result := value;
end;

function TFhirDocumentManifestRelatedList.Append: TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestRelatedList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestRelatedList.GetEnumerator : TFhirDocumentManifestRelatedListEnumerator;
begin
  result := TFhirDocumentManifestRelatedListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestRelatedList.Clone: TFhirDocumentManifestRelatedList;
begin
  result := TFhirDocumentManifestRelatedList(inherited Clone);
end;

function TFhirDocumentManifestRelatedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestRelatedList.GetItemN(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(ObjectByIndex[index]);
end;

function TFhirDocumentManifestRelatedList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifestRelated;
end;
function TFhirDocumentManifestRelatedList.IndexOf(value: TFhirDocumentManifestRelated): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestRelatedList.Insert(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestRelatedList.InsertItem(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestRelatedList.Item(index: Integer): TFhirDocumentManifestRelated;
begin
  result := TFhirDocumentManifestRelated(ObjectByIndex[index]);
end;

function TFhirDocumentManifestRelatedList.Link: TFhirDocumentManifestRelatedList;
begin
  result := TFhirDocumentManifestRelatedList(inherited Link);
end;

procedure TFhirDocumentManifestRelatedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestRelatedList.SetItemByIndex(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  FhirDocumentManifestRelateds[index] := value;
end;

procedure TFhirDocumentManifestRelatedList.SetItemN(index: Integer; value: TFhirDocumentManifestRelated);
begin
  assert(value is TFhirDocumentManifestRelated);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentManifest }

constructor TFhirDocumentManifest.Create;
begin
  inherited;
end;

destructor TFhirDocumentManifest.Destroy;
begin
  FMasterIdentifier.free;
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FSubject.free;
  FCreated.free;
  FAuthorList.Free;
  FRecipientList.Free;
  FSource.free;
  FDescription.free;
  FContentList.Free;
  FRelatedList.Free;
  inherited;
end;

procedure TFhirDocumentManifest.Assign(oSource : TFslObject);
begin
  inherited;
  masterIdentifier := TFhirDocumentManifest(oSource).masterIdentifier.Clone;
  if (TFhirDocumentManifest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDocumentManifest(oSource).FIdentifierList);
  end;
  statusElement := TFhirDocumentManifest(oSource).statusElement.Clone;
  type_ := TFhirDocumentManifest(oSource).type_.Clone;
  subject := TFhirDocumentManifest(oSource).subject.Clone;
  createdElement := TFhirDocumentManifest(oSource).createdElement.Clone;
  if (TFhirDocumentManifest(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirDocumentManifest(oSource).FAuthorList);
  end;
  if (TFhirDocumentManifest(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList.Create;
    FRecipientList.Assign(TFhirDocumentManifest(oSource).FRecipientList);
  end;
  sourceElement := TFhirDocumentManifest(oSource).sourceElement.Clone;
  descriptionElement := TFhirDocumentManifest(oSource).descriptionElement.Clone;
  if (TFhirDocumentManifest(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirReferenceList.Create;
    FContentList.Assign(TFhirDocumentManifest(oSource).FContentList);
  end;
  if (TFhirDocumentManifest(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirDocumentManifestRelatedList.Create;
    FRelatedList.Assign(TFhirDocumentManifest(oSource).FRelatedList);
  end;
end;

function TFhirDocumentManifest.GetResourceType : TFhirResourceType;
begin
  result := frtDocumentManifest;
end;

procedure TFhirDocumentManifest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'masterIdentifier') Then
     list.add(self.link, 'masterIdentifier', FMasterIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
end;

procedure TFhirDocumentManifest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'masterIdentifier', 'Identifier', false, TFhirIdentifier, FMasterIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', true, TFhirReference, FRecipientList.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'uri', false, TFhirUri, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'content', 'Reference', true, TFhirReference, FContentList.Link));
  oList.add(TFHIRProperty.create(self, 'related', 'BackboneElement', true, TFhirDocumentManifestRelated, FRelatedList.Link));
end;

function TFhirDocumentManifest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then
  begin
    MasterIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    SourceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirDocumentManifestRelated);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentManifest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirDocumentManifestRelated)
  else inherited;
end;

function TFhirDocumentManifest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[DocumentReferenceStatusNull], CODES_TFhirDocumentReferenceStatusEnum[DocumentReferenceStatusNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'recipient') then result := RecipientList.new()
  else if (propName = 'source') then result := TFhirUri.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'content') then result := ContentList.new()
  else if (propName = 'related') then result := RelatedList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentManifest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'masterIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'source') then result := 'uri'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'content') then result := 'Reference'
  else if (propName = 'related') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentManifest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value)
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value)
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentManifest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := new as TFhirIdentifier
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new)
  else if (propName = 'source') then SourceElement := asUri(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new)
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentManifest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'recipient') then RecipientList.move(source, destination)
  else if (propName = 'content') then ContentList.move(source, destination)
  else if (propName = 'related') then RelatedList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentManifest.fhirType : string;
begin
  result := 'DocumentManifest';
end;

function TFhirDocumentManifest.Link : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(inherited Link);
end;

function TFhirDocumentManifest.Clone : TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(inherited Clone);
end;

function TFhirDocumentManifest.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentManifest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentManifest)) then
    result := false
  else
  begin
    o := TFhirDocumentManifest(other);
    result := compareDeep(masterIdentifierElement, o.masterIdentifierElement, true) and 
      compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(recipientList, o.recipientList, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(contentList, o.contentList, true) and 
      compareDeep(relatedList, o.relatedList, true);
  end;
end;

function TFhirDocumentManifest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMasterIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FCreated) and isEmptyProp(FauthorList) and isEmptyProp(FrecipientList) and isEmptyProp(FSource) and isEmptyProp(FDescription) and isEmptyProp(FcontentList) and isEmptyProp(FrelatedList);
end;

procedure TFhirDocumentManifest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('masterIdentifier');
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('subject');
  fields.add('created');
  fields.add('author');
  fields.add('recipient');
  fields.add('source');
  fields.add('description');
  fields.add('content');
  fields.add('related');
end;

function TFhirDocumentManifest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FRecipientList.sizeInBytes(magic));
  inc(result, FContentList.sizeInBytes(magic));
  inc(result, FRelatedList.sizeInBytes(magic));
end;

procedure TFhirDocumentManifest.SetMasterIdentifier(value : TFhirIdentifier);
begin
  FMasterIdentifier.free;
  FMasterIdentifier := value;
end;

function TFhirDocumentManifest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDocumentManifest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDocumentManifest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDocumentManifest.GetStatusST : TFhirDocumentReferenceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDocumentReferenceStatusEnum(0)
  else
    result := TFhirDocumentReferenceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentReferenceStatusEnum, FStatus.value));
end;

procedure TFhirDocumentManifest.SetStatusST(value : TFhirDocumentReferenceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[value], CODES_TFhirDocumentReferenceStatusEnum[value]);
end;

procedure TFhirDocumentManifest.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirDocumentManifest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirDocumentManifest.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirDocumentManifest.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirDocumentManifest.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

function TFhirDocumentManifest.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirDocumentManifest.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirDocumentManifest.GetRecipientList : TFhirReferenceList;
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList.Create;
  result := FRecipientList;
end;

function TFhirDocumentManifest.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

procedure TFhirDocumentManifest.SetSource(value : TFhirUri);
begin
  FSource.free;
  FSource := value;
end;

function TFhirDocumentManifest.GetSourceST : String;
begin
  if FSource = nil then
    result := ''
  else
    result := FSource.value;
end;

procedure TFhirDocumentManifest.SetSourceST(value : String);
begin
  if value <> '' then
  begin
    if FSource = nil then
      FSource := TFhirUri.create;
    FSource.value := value
  end
  else if FSource <> nil then
    FSource.value := '';
end;

procedure TFhirDocumentManifest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirDocumentManifest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirDocumentManifest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirDocumentManifest.GetContentList : TFhirReferenceList;
begin
  if FContentList = nil then
    FContentList := TFhirReferenceList.Create;
  result := FContentList;
end;

function TFhirDocumentManifest.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

function TFhirDocumentManifest.GetRelatedList : TFhirDocumentManifestRelatedList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirDocumentManifestRelatedList.Create;
  result := FRelatedList;
end;

function TFhirDocumentManifest.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

{ TFhirDocumentManifestListEnumerator }

constructor TFhirDocumentManifestListEnumerator.Create(list : TFhirDocumentManifestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentManifestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentManifestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentManifestListEnumerator.GetCurrent : TFhirDocumentManifest;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentManifestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDocumentManifestList }

function TFhirDocumentManifestList.AddItem(value: TFhirDocumentManifest): TFhirDocumentManifest;
begin
  assert(value.ClassName = 'TFhirDocumentManifest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentManifest');
  add(value);
  result := value;
end;

function TFhirDocumentManifestList.Append: TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentManifestList.GetEnumerator : TFhirDocumentManifestListEnumerator;
begin
  result := TFhirDocumentManifestListEnumerator.Create(self.link);
end;

function TFhirDocumentManifestList.Clone: TFhirDocumentManifestList;
begin
  result := TFhirDocumentManifestList(inherited Clone);
end;

function TFhirDocumentManifestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentManifestList.GetItemN(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(ObjectByIndex[index]);
end;

function TFhirDocumentManifestList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentManifest;
end;
function TFhirDocumentManifestList.IndexOf(value: TFhirDocumentManifest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentManifestList.Insert(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentManifestList.InsertItem(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  Inherited Insert(index, value);
end;

function TFhirDocumentManifestList.Item(index: Integer): TFhirDocumentManifest;
begin
  result := TFhirDocumentManifest(ObjectByIndex[index]);
end;

function TFhirDocumentManifestList.Link: TFhirDocumentManifestList;
begin
  result := TFhirDocumentManifestList(inherited Link);
end;

procedure TFhirDocumentManifestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentManifestList.SetItemByIndex(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  FhirDocumentManifests[index] := value;
end;

procedure TFhirDocumentManifestList.SetItemN(index: Integer; value: TFhirDocumentManifest);
begin
  assert(value is TFhirDocumentManifest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DOCUMENTMANIFEST}
{$IFDEF FHIR_DOCUMENTREFERENCE}
{ TFhirDocumentReferenceRelatesTo }

constructor TFhirDocumentReferenceRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirDocumentReferenceRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirDocumentReferenceRelatesTo(oSource).codeElement.Clone;
  target := TFhirDocumentReferenceRelatesTo(oSource).target.Clone;
end;

procedure TFhirDocumentReferenceRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
end;

procedure TFhirDocumentReferenceRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', false, TFhirReference, FTarget.Link));
end;

function TFhirDocumentReferenceRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[DocumentRelationshipTypeNull], CODES_TFhirDocumentRelationshipTypeEnum[DocumentRelationshipTypeNull]) 
  else if (propName = 'target') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'target') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'target') then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirDocumentRelationshipTypeEnum, CODES_TFhirDocumentRelationshipTypeEnum, new)
  else if (propName = 'target') then TargetElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceRelatesTo.fhirType : string;
begin
  result := 'DocumentReference.relatesTo';
end;

function TFhirDocumentReferenceRelatesTo.Link : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Link);
end;

function TFhirDocumentReferenceRelatesTo.Clone : TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(inherited Clone);
end;

function TFhirDocumentReferenceRelatesTo.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentReferenceRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceRelatesTo)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceRelatesTo(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirDocumentReferenceRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FTarget);
end;

procedure TFhirDocumentReferenceRelatesTo.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('target');
end;

function TFhirDocumentReferenceRelatesTo.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDocumentReferenceRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirDocumentReferenceRelatesTo.GetCodeST : TFhirDocumentRelationshipTypeEnum;
begin
  if FCode = nil then
    result := TFhirDocumentRelationshipTypeEnum(0)
  else
    result := TFhirDocumentRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentRelationshipTypeEnum, FCode.value));
end;

procedure TFhirDocumentReferenceRelatesTo.SetCodeST(value : TFhirDocumentRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirDocumentRelationshipTypeEnum[value], CODES_TFhirDocumentRelationshipTypeEnum[value]);
end;

procedure TFhirDocumentReferenceRelatesTo.SetTarget(value : TFhirReference);
begin
  FTarget.free;
  FTarget := value;
end;

{ TFhirDocumentReferenceRelatesToListEnumerator }

constructor TFhirDocumentReferenceRelatesToListEnumerator.Create(list : TFhirDocumentReferenceRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceRelatesToListEnumerator.GetCurrent : TFhirDocumentReferenceRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceRelatesToListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDocumentReferenceRelatesToList }

function TFhirDocumentReferenceRelatesToList.AddItem(value: TFhirDocumentReferenceRelatesTo): TFhirDocumentReferenceRelatesTo;
begin
  assert(value.ClassName = 'TFhirDocumentReferenceRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceRelatesTo');
  add(value);
  result := value;
end;

function TFhirDocumentReferenceRelatesToList.Append: TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceRelatesToList.GetEnumerator : TFhirDocumentReferenceRelatesToListEnumerator;
begin
  result := TFhirDocumentReferenceRelatesToListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceRelatesToList.Clone: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Clone);
end;

function TFhirDocumentReferenceRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceRelatesToList.GetItemN(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceRelatesTo;
end;
function TFhirDocumentReferenceRelatesToList.IndexOf(value: TFhirDocumentReferenceRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceRelatesToList.Insert(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceRelatesToList.InsertItem(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceRelatesToList.Item(index: Integer): TFhirDocumentReferenceRelatesTo;
begin
  result := TFhirDocumentReferenceRelatesTo(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceRelatesToList.Link: TFhirDocumentReferenceRelatesToList;
begin
  result := TFhirDocumentReferenceRelatesToList(inherited Link);
end;

procedure TFhirDocumentReferenceRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  FhirDocumentReferenceRelatesTos[index] := value;
end;

procedure TFhirDocumentReferenceRelatesToList.SetItemN(index: Integer; value: TFhirDocumentReferenceRelatesTo);
begin
  assert(value is TFhirDocumentReferenceRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContent }

constructor TFhirDocumentReferenceContent.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceContent.Destroy;
begin
  FAttachment.free;
  FFormat.free;
  inherited;
end;

procedure TFhirDocumentReferenceContent.Assign(oSource : TFslObject);
begin
  inherited;
  attachment := TFhirDocumentReferenceContent(oSource).attachment.Clone;
  format := TFhirDocumentReferenceContent(oSource).format.Clone;
end;

procedure TFhirDocumentReferenceContent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'attachment') Then
     list.add(self.link, 'attachment', FAttachment.Link);
  if (child_name = 'format') Then
     list.add(self.link, 'format', FFormat.Link);
end;

procedure TFhirDocumentReferenceContent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'attachment', 'Attachment', false, TFhirAttachment, FAttachment.Link));
  oList.add(TFHIRProperty.create(self, 'format', 'Coding', false, TFhirCoding, FFormat.Link));
end;

function TFhirDocumentReferenceContent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'attachment') then
  begin
    Attachment := propValue as TFhirAttachment;
    result := propValue;
  end
  else if (propName = 'format') then
  begin
    Format := propValue as TFhirCoding;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceContent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDocumentReferenceContent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'attachment') then result := TFhirAttachment.create()
  else if (propName = 'format') then result := TFhirCoding.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceContent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'attachment') then result := 'Attachment'
  else if (propName = 'format') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceContent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'attachment') then AttachmentElement := nil
  else if (propName = 'format') then FormatElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceContent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'attachment') then AttachmentElement := new as TFhirAttachment
  else if (propName = 'format') then FormatElement := new as TFhirCoding
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceContent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceContent.fhirType : string;
begin
  result := 'DocumentReference.content';
end;

function TFhirDocumentReferenceContent.Link : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(inherited Link);
end;

function TFhirDocumentReferenceContent.Clone : TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(inherited Clone);
end;

function TFhirDocumentReferenceContent.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentReferenceContent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceContent)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceContent(other);
    result := compareDeep(attachmentElement, o.attachmentElement, true) and compareDeep(formatElement, o.formatElement, true);
  end;
end;

function TFhirDocumentReferenceContent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAttachment) and isEmptyProp(FFormat);
end;

procedure TFhirDocumentReferenceContent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('attachment');
  fields.add('format');
end;

function TFhirDocumentReferenceContent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDocumentReferenceContent.SetAttachment(value : TFhirAttachment);
begin
  FAttachment.free;
  FAttachment := value;
end;

procedure TFhirDocumentReferenceContent.SetFormat(value : TFhirCoding);
begin
  FFormat.free;
  FFormat := value;
end;

{ TFhirDocumentReferenceContentListEnumerator }

constructor TFhirDocumentReferenceContentListEnumerator.Create(list : TFhirDocumentReferenceContentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceContentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceContentListEnumerator.GetCurrent : TFhirDocumentReferenceContent;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceContentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDocumentReferenceContentList }

function TFhirDocumentReferenceContentList.AddItem(value: TFhirDocumentReferenceContent): TFhirDocumentReferenceContent;
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContent');
  add(value);
  result := value;
end;

function TFhirDocumentReferenceContentList.Append: TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContentList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContentList.GetEnumerator : TFhirDocumentReferenceContentListEnumerator;
begin
  result := TFhirDocumentReferenceContentListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContentList.Clone: TFhirDocumentReferenceContentList;
begin
  result := TFhirDocumentReferenceContentList(inherited Clone);
end;

function TFhirDocumentReferenceContentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContentList.GetItemN(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContentList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceContent;
end;
function TFhirDocumentReferenceContentList.IndexOf(value: TFhirDocumentReferenceContent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceContentList.Insert(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContentList.InsertItem(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContentList.Item(index: Integer): TFhirDocumentReferenceContent;
begin
  result := TFhirDocumentReferenceContent(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContentList.Link: TFhirDocumentReferenceContentList;
begin
  result := TFhirDocumentReferenceContentList(inherited Link);
end;

procedure TFhirDocumentReferenceContentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContentList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  FhirDocumentReferenceContents[index] := value;
end;

procedure TFhirDocumentReferenceContentList.SetItemN(index: Integer; value: TFhirDocumentReferenceContent);
begin
  assert(value is TFhirDocumentReferenceContent);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReferenceContext }

constructor TFhirDocumentReferenceContext.Create;
begin
  inherited;
end;

destructor TFhirDocumentReferenceContext.Destroy;
begin
  FEncounterList.Free;
  FEventList.Free;
  FPeriod.free;
  FFacilityType.free;
  FPracticeSetting.free;
  FSourcePatientInfo.free;
  FRelatedList.Free;
  inherited;
end;

procedure TFhirDocumentReferenceContext.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDocumentReferenceContext(oSource).FEncounterList = nil) then
  begin
    FEncounterList.free;
    FEncounterList := nil;
  end
  else
  begin
    if FEncounterList = nil then
      FEncounterList := TFhirReferenceList.Create;
    FEncounterList.Assign(TFhirDocumentReferenceContext(oSource).FEncounterList);
  end;
  if (TFhirDocumentReferenceContext(oSource).FEventList = nil) then
  begin
    FEventList.free;
    FEventList := nil;
  end
  else
  begin
    if FEventList = nil then
      FEventList := TFhirCodeableConceptList.Create;
    FEventList.Assign(TFhirDocumentReferenceContext(oSource).FEventList);
  end;
  period := TFhirDocumentReferenceContext(oSource).period.Clone;
  facilityType := TFhirDocumentReferenceContext(oSource).facilityType.Clone;
  practiceSetting := TFhirDocumentReferenceContext(oSource).practiceSetting.Clone;
  sourcePatientInfo := TFhirDocumentReferenceContext(oSource).sourcePatientInfo.Clone;
  if (TFhirDocumentReferenceContext(oSource).FRelatedList = nil) then
  begin
    FRelatedList.free;
    FRelatedList := nil;
  end
  else
  begin
    if FRelatedList = nil then
      FRelatedList := TFhirReferenceList.Create;
    FRelatedList.Assign(TFhirDocumentReferenceContext(oSource).FRelatedList);
  end;
end;

procedure TFhirDocumentReferenceContext.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'encounter') Then
    list.addAll(self, 'encounter', FEncounterList);
  if (child_name = 'event') Then
    list.addAll(self, 'event', FEventList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'facilityType') Then
     list.add(self.link, 'facilityType', FFacilityType.Link);
  if (child_name = 'practiceSetting') Then
     list.add(self.link, 'practiceSetting', FPracticeSetting.Link);
  if (child_name = 'sourcePatientInfo') Then
     list.add(self.link, 'sourcePatientInfo', FSourcePatientInfo.Link);
  if (child_name = 'related') Then
    list.addAll(self, 'related', FRelatedList);
end;

procedure TFhirDocumentReferenceContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', true, TFhirReference, FEncounterList.Link));
  oList.add(TFHIRProperty.create(self, 'event', 'CodeableConcept', true, TFhirCodeableConcept, FEventList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'facilityType', 'CodeableConcept', false, TFhirCodeableConcept, FFacilityType.Link));
  oList.add(TFHIRProperty.create(self, 'practiceSetting', 'CodeableConcept', false, TFhirCodeableConcept, FPracticeSetting.Link));
  oList.add(TFHIRProperty.create(self, 'sourcePatientInfo', 'Reference', false, TFhirReference, FSourcePatientInfo.Link));
  oList.add(TFHIRProperty.create(self, 'related', 'Reference', true, TFhirReference, FRelatedList.Link));
end;

function TFhirDocumentReferenceContext.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'encounter') then
  begin
    EncounterList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    EventList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'facilityType') then
  begin
    FacilityType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'practiceSetting') then
  begin
    PracticeSetting := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'sourcePatientInfo') then
  begin
    SourcePatientInfo := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'related') then
  begin
    RelatedList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReferenceContext.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'encounter') then EncounterList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'event') then EventList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'related') then RelatedList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirDocumentReferenceContext.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'encounter') then result := EncounterList.new()
  else if (propName = 'event') then result := EventList.new()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'facilityType') then result := TFhirCodeableConcept.create()
  else if (propName = 'practiceSetting') then result := TFhirCodeableConcept.create()
  else if (propName = 'sourcePatientInfo') then result := TFhirReference.create()
  else if (propName = 'related') then result := RelatedList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReferenceContext.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'event') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'facilityType') then result := 'CodeableConcept'
  else if (propName = 'practiceSetting') then result := 'CodeableConcept'
  else if (propName = 'sourcePatientInfo') then result := 'Reference'
  else if (propName = 'related') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReferenceContext.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'encounter') then deletePropertyValue('encounter', EncounterList, value)
  else if (propName = 'event') then deletePropertyValue('event', EventList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'facilityType') then FacilityTypeElement := nil
  else if (propName = 'practiceSetting') then PracticeSettingElement := nil
  else if (propName = 'sourcePatientInfo') then SourcePatientInfoElement := nil
  else if (propName = 'related') then deletePropertyValue('related', RelatedList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReferenceContext.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'encounter') then replacePropertyValue('encounter', EncounterList, existing, new)
  else if (propName = 'event') then replacePropertyValue('event', EventList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'facilityType') then FacilityTypeElement := new as TFhirCodeableConcept
  else if (propName = 'practiceSetting') then PracticeSettingElement := new as TFhirCodeableConcept
  else if (propName = 'sourcePatientInfo') then SourcePatientInfoElement := new as TFhirReference
  else if (propName = 'related') then replacePropertyValue('related', RelatedList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReferenceContext.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'encounter') then EncounterList.move(source, destination)
  else if (propName = 'event') then EventList.move(source, destination)
  else if (propName = 'related') then RelatedList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReferenceContext.fhirType : string;
begin
  result := 'DocumentReference.context';
end;

function TFhirDocumentReferenceContext.Link : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Link);
end;

function TFhirDocumentReferenceContext.Clone : TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(inherited Clone);
end;

function TFhirDocumentReferenceContext.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentReferenceContext;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReferenceContext)) then
    result := false
  else
  begin
    o := TFhirDocumentReferenceContext(other);
    result := compareDeep(encounterList, o.encounterList, true) and compareDeep(eventList, o.eventList, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(facilityTypeElement, o.facilityTypeElement, true) and 
      compareDeep(practiceSettingElement, o.practiceSettingElement, true) and compareDeep(sourcePatientInfoElement, o.sourcePatientInfoElement, true) and 
      compareDeep(relatedList, o.relatedList, true);
  end;
end;

function TFhirDocumentReferenceContext.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FencounterList) and isEmptyProp(FeventList) and isEmptyProp(FPeriod) and isEmptyProp(FFacilityType) and isEmptyProp(FPracticeSetting) and isEmptyProp(FSourcePatientInfo) and isEmptyProp(FrelatedList);
end;

procedure TFhirDocumentReferenceContext.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('encounter');
  fields.add('event');
  fields.add('period');
  fields.add('facilityType');
  fields.add('practiceSetting');
  fields.add('sourcePatientInfo');
  fields.add('related');
end;

function TFhirDocumentReferenceContext.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FEncounterList.sizeInBytes(magic));
  inc(result, FEventList.sizeInBytes(magic));
  inc(result, FRelatedList.sizeInBytes(magic));
end;

function TFhirDocumentReferenceContext.GetEncounterList : TFhirReferenceList;
begin
  if FEncounterList = nil then
    FEncounterList := TFhirReferenceList.Create;
  result := FEncounterList;
end;

function TFhirDocumentReferenceContext.GetHasEncounterList : boolean;
begin
  result := (FEncounterList <> nil) and (FEncounterList.count > 0);
end;

function TFhirDocumentReferenceContext.GetEventList : TFhirCodeableConceptList;
begin
  if FEventList = nil then
    FEventList := TFhirCodeableConceptList.Create;
  result := FEventList;
end;

function TFhirDocumentReferenceContext.GetHasEventList : boolean;
begin
  result := (FEventList <> nil) and (FEventList.count > 0);
end;

procedure TFhirDocumentReferenceContext.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirDocumentReferenceContext.SetFacilityType(value : TFhirCodeableConcept);
begin
  FFacilityType.free;
  FFacilityType := value;
end;

procedure TFhirDocumentReferenceContext.SetPracticeSetting(value : TFhirCodeableConcept);
begin
  FPracticeSetting.free;
  FPracticeSetting := value;
end;

procedure TFhirDocumentReferenceContext.SetSourcePatientInfo(value : TFhirReference);
begin
  FSourcePatientInfo.free;
  FSourcePatientInfo := value;
end;

function TFhirDocumentReferenceContext.GetRelatedList : TFhirReferenceList;
begin
  if FRelatedList = nil then
    FRelatedList := TFhirReferenceList.Create;
  result := FRelatedList;
end;

function TFhirDocumentReferenceContext.GetHasRelatedList : boolean;
begin
  result := (FRelatedList <> nil) and (FRelatedList.count > 0);
end;

{ TFhirDocumentReferenceContextListEnumerator }

constructor TFhirDocumentReferenceContextListEnumerator.Create(list : TFhirDocumentReferenceContextList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceContextListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceContextListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceContextListEnumerator.GetCurrent : TFhirDocumentReferenceContext;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceContextListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDocumentReferenceContextList }

function TFhirDocumentReferenceContextList.AddItem(value: TFhirDocumentReferenceContext): TFhirDocumentReferenceContext;
begin
  assert(value.ClassName = 'TFhirDocumentReferenceContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReferenceContext');
  add(value);
  result := value;
end;

function TFhirDocumentReferenceContextList.Append: TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceContextList.GetEnumerator : TFhirDocumentReferenceContextListEnumerator;
begin
  result := TFhirDocumentReferenceContextListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceContextList.Clone: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Clone);
end;

function TFhirDocumentReferenceContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceContextList.GetItemN(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReferenceContext;
end;
function TFhirDocumentReferenceContextList.IndexOf(value: TFhirDocumentReferenceContext): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceContextList.Insert(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceContextList.InsertItem(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceContextList.Item(index: Integer): TFhirDocumentReferenceContext;
begin
  result := TFhirDocumentReferenceContext(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceContextList.Link: TFhirDocumentReferenceContextList;
begin
  result := TFhirDocumentReferenceContextList(inherited Link);
end;

procedure TFhirDocumentReferenceContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceContextList.SetItemByIndex(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  FhirDocumentReferenceContexts[index] := value;
end;

procedure TFhirDocumentReferenceContextList.SetItemN(index: Integer; value: TFhirDocumentReferenceContext);
begin
  assert(value is TFhirDocumentReferenceContext);
  ObjectByIndex[index] := value;
end;

{ TFhirDocumentReference }

constructor TFhirDocumentReference.Create;
begin
  inherited;
end;

destructor TFhirDocumentReference.Destroy;
begin
  FMasterIdentifier.free;
  FIdentifierList.Free;
  FStatus.free;
  FDocStatus.free;
  FType_.free;
  FCategoryList.Free;
  FSubject.free;
  FDate.free;
  FAuthorList.Free;
  FAuthenticator.free;
  FCustodian.free;
  FRelatesToList.Free;
  FDescription.free;
  FSecurityLabelList.Free;
  FContentList.Free;
  FContext.free;
  inherited;
end;

procedure TFhirDocumentReference.Assign(oSource : TFslObject);
begin
  inherited;
  masterIdentifier := TFhirDocumentReference(oSource).masterIdentifier.Clone;
  if (TFhirDocumentReference(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDocumentReference(oSource).FIdentifierList);
  end;
  statusElement := TFhirDocumentReference(oSource).statusElement.Clone;
  docStatusElement := TFhirDocumentReference(oSource).docStatusElement.Clone;
  type_ := TFhirDocumentReference(oSource).type_.Clone;
  if (TFhirDocumentReference(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirDocumentReference(oSource).FCategoryList);
  end;
  subject := TFhirDocumentReference(oSource).subject.Clone;
  dateElement := TFhirDocumentReference(oSource).dateElement.Clone;
  if (TFhirDocumentReference(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirDocumentReference(oSource).FAuthorList);
  end;
  authenticator := TFhirDocumentReference(oSource).authenticator.Clone;
  custodian := TFhirDocumentReference(oSource).custodian.Clone;
  if (TFhirDocumentReference(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirDocumentReferenceRelatesToList.Create;
    FRelatesToList.Assign(TFhirDocumentReference(oSource).FRelatesToList);
  end;
  descriptionElement := TFhirDocumentReference(oSource).descriptionElement.Clone;
  if (TFhirDocumentReference(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodeableConceptList.Create;
    FSecurityLabelList.Assign(TFhirDocumentReference(oSource).FSecurityLabelList);
  end;
  if (TFhirDocumentReference(oSource).FContentList = nil) then
  begin
    FContentList.free;
    FContentList := nil;
  end
  else
  begin
    if FContentList = nil then
      FContentList := TFhirDocumentReferenceContentList.Create;
    FContentList.Assign(TFhirDocumentReference(oSource).FContentList);
  end;
  context := TFhirDocumentReference(oSource).context.Clone;
end;

function TFhirDocumentReference.GetResourceType : TFhirResourceType;
begin
  result := frtDocumentReference;
end;

procedure TFhirDocumentReference.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'masterIdentifier') Then
     list.add(self.link, 'masterIdentifier', FMasterIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'docStatus') Then
     list.add(self.link, 'docStatus', FDocStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'authenticator') Then
     list.add(self.link, 'authenticator', FAuthenticator.Link);
  if (child_name = 'custodian') Then
     list.add(self.link, 'custodian', FCustodian.Link);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'content') Then
    list.addAll(self, 'content', FContentList);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
end;

procedure TFhirDocumentReference.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'masterIdentifier', 'Identifier', false, TFhirIdentifier, FMasterIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'docStatus', 'code', false, TFhirEnum, FDocStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'instant', false, TFhirInstant, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'authenticator', 'Reference', false, TFhirReference, FAuthenticator.Link));
  oList.add(TFHIRProperty.create(self, 'custodian', 'Reference', false, TFhirReference, FCustodian.Link));
  oList.add(TFHIRProperty.create(self, 'relatesTo', 'BackboneElement', true, TFhirDocumentReferenceRelatesTo, FRelatesToList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'CodeableConcept', true, TFhirCodeableConcept, FSecurityLabelList.Link));
  oList.add(TFHIRProperty.create(self, 'content', 'BackboneElement', true, TFhirDocumentReferenceContent, FContentList.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'BackboneElement', false, TFhirDocumentReferenceContext, FContext.Link));
end;

function TFhirDocumentReference.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then
  begin
    MasterIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'docStatus') then
  begin
    DocStatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'authenticator') then
  begin
    Authenticator := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'custodian') then
  begin
    Custodian := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirDocumentReferenceRelatesTo);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    ContentList.add(propValue as TFhirDocumentReferenceContent);
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirDocumentReferenceContext;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDocumentReference.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirDocumentReferenceRelatesTo)
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'content') then ContentList.insertItem(index, propValue as TFhirDocumentReferenceContent)
  else inherited;
end;

function TFhirDocumentReference.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'masterIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[DocumentReferenceStatusNull], CODES_TFhirDocumentReferenceStatusEnum[DocumentReferenceStatusNull]) 
  else if (propName = 'docStatus') then result := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[CompositionStatusNull], CODES_TFhirCompositionStatusEnum[CompositionStatusNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirInstant.create()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'authenticator') then result := TFhirReference.create()
  else if (propName = 'custodian') then result := TFhirReference.create()
  else if (propName = 'relatesTo') then result := RelatesToList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'securityLabel') then result := SecurityLabelList.new()
  else if (propName = 'content') then result := ContentList.new()
  else if (propName = 'context') then result := TFhirDocumentReferenceContext.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDocumentReference.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'masterIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'docStatus') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'date') then result := 'instant'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'authenticator') then result := 'Reference'
  else if (propName = 'custodian') then result := 'Reference'
  else if (propName = 'relatesTo') then result := 'BackboneElement'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'securityLabel') then result := 'CodeableConcept'
  else if (propName = 'content') then result := 'BackboneElement'
  else if (propName = 'context') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDocumentReference.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'docStatus') then DocStatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'authenticator') then AuthenticatorElement := nil
  else if (propName = 'custodian') then CustodianElement := nil
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value)
  else if (propName = 'content') then deletePropertyValue('content', ContentList, value)
  else if (propName = 'context') then ContextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDocumentReference.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'masterIdentifier') then MasterIdentifierElement := new as TFhirIdentifier
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirDocumentReferenceStatusEnum, CODES_TFhirDocumentReferenceStatusEnum, new)
  else if (propName = 'docStatus') then DocStatusElement := asEnum(SYSTEMS_TFhirCompositionStatusEnum, CODES_TFhirCompositionStatusEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asInstant(new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'authenticator') then AuthenticatorElement := new as TFhirReference
  else if (propName = 'custodian') then CustodianElement := new as TFhirReference
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new)
  else if (propName = 'content') then replacePropertyValue('content', ContentList, existing, new)
  else if (propName = 'context') then ContextElement := new as TFhirDocumentReferenceContext
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDocumentReference.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination)
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination)
  else if (propName = 'content') then ContentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDocumentReference.fhirType : string;
begin
  result := 'DocumentReference';
end;

function TFhirDocumentReference.Link : TFhirDocumentReference;
begin
  result := TFhirDocumentReference(inherited Link);
end;

function TFhirDocumentReference.Clone : TFhirDocumentReference;
begin
  result := TFhirDocumentReference(inherited Clone);
end;

function TFhirDocumentReference.equals(other : TObject) : boolean; 
var
  o : TFhirDocumentReference;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDocumentReference)) then
    result := false
  else
  begin
    o := TFhirDocumentReference(other);
    result := compareDeep(masterIdentifierElement, o.masterIdentifierElement, true) and 
      compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(docStatusElement, o.docStatusElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(authenticatorElement, o.authenticatorElement, true) and compareDeep(custodianElement, o.custodianElement, true) and 
      compareDeep(relatesToList, o.relatesToList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(contentList, o.contentList, true) and 
      compareDeep(contextElement, o.contextElement, true);
  end;
end;

function TFhirDocumentReference.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMasterIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FDocStatus) and isEmptyProp(FType_) and isEmptyProp(FcategoryList) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FauthorList) and isEmptyProp(FAuthenticator) and isEmptyProp(FCustodian) and isEmptyProp(FrelatesToList) and isEmptyProp(FDescription) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FcontentList) and isEmptyProp(FContext);
end;

procedure TFhirDocumentReference.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('masterIdentifier');
  fields.add('identifier');
  fields.add('status');
  fields.add('docStatus');
  fields.add('type');
  fields.add('category');
  fields.add('subject');
  fields.add('date');
  fields.add('author');
  fields.add('authenticator');
  fields.add('custodian');
  fields.add('relatesTo');
  fields.add('description');
  fields.add('securityLabel');
  fields.add('content');
  fields.add('context');
end;

function TFhirDocumentReference.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FRelatesToList.sizeInBytes(magic));
  inc(result, FSecurityLabelList.sizeInBytes(magic));
  inc(result, FContentList.sizeInBytes(magic));
end;

procedure TFhirDocumentReference.SetMasterIdentifier(value : TFhirIdentifier);
begin
  FMasterIdentifier.free;
  FMasterIdentifier := value;
end;

function TFhirDocumentReference.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDocumentReference.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDocumentReference.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDocumentReference.GetStatusST : TFhirDocumentReferenceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirDocumentReferenceStatusEnum(0)
  else
    result := TFhirDocumentReferenceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDocumentReferenceStatusEnum, FStatus.value));
end;

procedure TFhirDocumentReference.SetStatusST(value : TFhirDocumentReferenceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirDocumentReferenceStatusEnum[value], CODES_TFhirDocumentReferenceStatusEnum[value]);
end;

procedure TFhirDocumentReference.SetDocStatus(value : TFhirEnum);
begin
  FDocStatus.free;
  FDocStatus := value;
end;

function TFhirDocumentReference.GetDocStatusST : TFhirCompositionStatusEnum;
begin
  if FDocStatus = nil then
    result := TFhirCompositionStatusEnum(0)
  else
    result := TFhirCompositionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirCompositionStatusEnum, FDocStatus.value));
end;

procedure TFhirDocumentReference.SetDocStatusST(value : TFhirCompositionStatusEnum);
begin
  if ord(value) = 0 then
    DocStatusElement := nil
  else
    DocStatusElement := TFhirEnum.create(SYSTEMS_TFhirCompositionStatusEnum[value], CODES_TFhirCompositionStatusEnum[value]);
end;

procedure TFhirDocumentReference.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDocumentReference.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirDocumentReference.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirDocumentReference.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirDocumentReference.SetDate(value : TFhirInstant);
begin
  FDate.free;
  FDate := value;
end;

function TFhirDocumentReference.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirDocumentReference.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirInstant.create;
  FDate.value := value
end;

function TFhirDocumentReference.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirDocumentReference.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

procedure TFhirDocumentReference.SetAuthenticator(value : TFhirReference);
begin
  FAuthenticator.free;
  FAuthenticator := value;
end;

procedure TFhirDocumentReference.SetCustodian(value : TFhirReference);
begin
  FCustodian.free;
  FCustodian := value;
end;

function TFhirDocumentReference.GetRelatesToList : TFhirDocumentReferenceRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirDocumentReferenceRelatesToList.Create;
  result := FRelatesToList;
end;

function TFhirDocumentReference.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

procedure TFhirDocumentReference.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirDocumentReference.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirDocumentReference.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirDocumentReference.GetSecurityLabelList : TFhirCodeableConceptList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodeableConceptList.Create;
  result := FSecurityLabelList;
end;

function TFhirDocumentReference.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

function TFhirDocumentReference.GetContentList : TFhirDocumentReferenceContentList;
begin
  if FContentList = nil then
    FContentList := TFhirDocumentReferenceContentList.Create;
  result := FContentList;
end;

function TFhirDocumentReference.GetHasContentList : boolean;
begin
  result := (FContentList <> nil) and (FContentList.count > 0);
end;

procedure TFhirDocumentReference.SetContext(value : TFhirDocumentReferenceContext);
begin
  FContext.free;
  FContext := value;
end;

{ TFhirDocumentReferenceListEnumerator }

constructor TFhirDocumentReferenceListEnumerator.Create(list : TFhirDocumentReferenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDocumentReferenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirDocumentReferenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDocumentReferenceListEnumerator.GetCurrent : TFhirDocumentReference;
begin
  Result := FList[FIndex];
end;

function TFhirDocumentReferenceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDocumentReferenceList }

function TFhirDocumentReferenceList.AddItem(value: TFhirDocumentReference): TFhirDocumentReference;
begin
  assert(value.ClassName = 'TFhirDocumentReference', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDocumentReference');
  add(value);
  result := value;
end;

function TFhirDocumentReferenceList.Append: TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceList.ClearItems;
begin
  Clear;
end;

function TFhirDocumentReferenceList.GetEnumerator : TFhirDocumentReferenceListEnumerator;
begin
  result := TFhirDocumentReferenceListEnumerator.Create(self.link);
end;

function TFhirDocumentReferenceList.Clone: TFhirDocumentReferenceList;
begin
  result := TFhirDocumentReferenceList(inherited Clone);
end;

function TFhirDocumentReferenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDocumentReferenceList.GetItemN(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDocumentReference;
end;
function TFhirDocumentReferenceList.IndexOf(value: TFhirDocumentReference): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDocumentReferenceList.Insert(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDocumentReferenceList.InsertItem(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  Inherited Insert(index, value);
end;

function TFhirDocumentReferenceList.Item(index: Integer): TFhirDocumentReference;
begin
  result := TFhirDocumentReference(ObjectByIndex[index]);
end;

function TFhirDocumentReferenceList.Link: TFhirDocumentReferenceList;
begin
  result := TFhirDocumentReferenceList(inherited Link);
end;

procedure TFhirDocumentReferenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDocumentReferenceList.SetItemByIndex(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  FhirDocumentReferences[index] := value;
end;

procedure TFhirDocumentReferenceList.SetItemN(index: Integer; value: TFhirDocumentReference);
begin
  assert(value is TFhirDocumentReference);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DOCUMENTREFERENCE}
{$IFDEF FHIR_EPISODEOFCARE}
{ TFhirEpisodeOfCareStatusHistory }

constructor TFhirEpisodeOfCareStatusHistory.Create;
begin
  inherited;
end;

destructor TFhirEpisodeOfCareStatusHistory.Destroy;
begin
  FStatus.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEpisodeOfCareStatusHistory.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirEpisodeOfCareStatusHistory(oSource).statusElement.Clone;
  period := TFhirEpisodeOfCareStatusHistory(oSource).period.Clone;
end;

procedure TFhirEpisodeOfCareStatusHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEpisodeOfCareStatusHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirEpisodeOfCareStatusHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEpisodeOfCareStatusHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEpisodeOfCareStatusHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[EpisodeOfCareStatusNull], CODES_TFhirEpisodeOfCareStatusEnum[EpisodeOfCareStatusNull]) 
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEpisodeOfCareStatusHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEpisodeOfCareStatusHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEpisodeOfCareStatusHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEpisodeOfCareStatusHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEpisodeOfCareStatusHistory.fhirType : string;
begin
  result := 'EpisodeOfCare.statusHistory';
end;

function TFhirEpisodeOfCareStatusHistory.Link : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(inherited Link);
end;

function TFhirEpisodeOfCareStatusHistory.Clone : TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(inherited Clone);
end;

function TFhirEpisodeOfCareStatusHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEpisodeOfCareStatusHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEpisodeOfCareStatusHistory)) then
    result := false
  else
  begin
    o := TFhirEpisodeOfCareStatusHistory(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEpisodeOfCareStatusHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FPeriod);
end;

procedure TFhirEpisodeOfCareStatusHistory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('period');
end;

function TFhirEpisodeOfCareStatusHistory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEpisodeOfCareStatusHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEpisodeOfCareStatusHistory.GetStatusST : TFhirEpisodeOfCareStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEpisodeOfCareStatusEnum(0)
  else
    result := TFhirEpisodeOfCareStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEpisodeOfCareStatusEnum, FStatus.value));
end;

procedure TFhirEpisodeOfCareStatusHistory.SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[value], CODES_TFhirEpisodeOfCareStatusEnum[value]);
end;

procedure TFhirEpisodeOfCareStatusHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirEpisodeOfCareStatusHistoryListEnumerator }

constructor TFhirEpisodeOfCareStatusHistoryListEnumerator.Create(list : TFhirEpisodeOfCareStatusHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEpisodeOfCareStatusHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEpisodeOfCareStatusHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEpisodeOfCareStatusHistoryListEnumerator.GetCurrent : TFhirEpisodeOfCareStatusHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEpisodeOfCareStatusHistoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEpisodeOfCareStatusHistoryList }

function TFhirEpisodeOfCareStatusHistoryList.AddItem(value: TFhirEpisodeOfCareStatusHistory): TFhirEpisodeOfCareStatusHistory;
begin
  assert(value.ClassName = 'TFhirEpisodeOfCareStatusHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEpisodeOfCareStatusHistory');
  add(value);
  result := value;
end;

function TFhirEpisodeOfCareStatusHistoryList.Append: TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareStatusHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEpisodeOfCareStatusHistoryList.GetEnumerator : TFhirEpisodeOfCareStatusHistoryListEnumerator;
begin
  result := TFhirEpisodeOfCareStatusHistoryListEnumerator.Create(self.link);
end;

function TFhirEpisodeOfCareStatusHistoryList.Clone: TFhirEpisodeOfCareStatusHistoryList;
begin
  result := TFhirEpisodeOfCareStatusHistoryList(inherited Clone);
end;

function TFhirEpisodeOfCareStatusHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEpisodeOfCareStatusHistoryList.GetItemN(index: Integer): TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareStatusHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEpisodeOfCareStatusHistory;
end;
function TFhirEpisodeOfCareStatusHistoryList.IndexOf(value: TFhirEpisodeOfCareStatusHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEpisodeOfCareStatusHistoryList.Insert(index: Integer): TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareStatusHistoryList.InsertItem(index: Integer; value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value is TFhirEpisodeOfCareStatusHistory);
  Inherited Insert(index, value);
end;

function TFhirEpisodeOfCareStatusHistoryList.Item(index: Integer): TFhirEpisodeOfCareStatusHistory;
begin
  result := TFhirEpisodeOfCareStatusHistory(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareStatusHistoryList.Link: TFhirEpisodeOfCareStatusHistoryList;
begin
  result := TFhirEpisodeOfCareStatusHistoryList(inherited Link);
end;

procedure TFhirEpisodeOfCareStatusHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEpisodeOfCareStatusHistoryList.SetItemByIndex(index: Integer; value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value is TFhirEpisodeOfCareStatusHistory);
  FhirEpisodeOfCareStatusHistories[index] := value;
end;

procedure TFhirEpisodeOfCareStatusHistoryList.SetItemN(index: Integer; value: TFhirEpisodeOfCareStatusHistory);
begin
  assert(value is TFhirEpisodeOfCareStatusHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEpisodeOfCareDiagnosis }

constructor TFhirEpisodeOfCareDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirEpisodeOfCareDiagnosis.Destroy;
begin
  FCondition.free;
  FRole.free;
  FRank.free;
  inherited;
end;

procedure TFhirEpisodeOfCareDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  condition := TFhirEpisodeOfCareDiagnosis(oSource).condition.Clone;
  role := TFhirEpisodeOfCareDiagnosis(oSource).role.Clone;
  rankElement := TFhirEpisodeOfCareDiagnosis(oSource).rankElement.Clone;
end;

procedure TFhirEpisodeOfCareDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'rank') Then
     list.add(self.link, 'rank', FRank.Link);
end;

procedure TFhirEpisodeOfCareDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'condition', 'Reference', false, TFhirReference, FCondition.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'rank', 'positiveInt', false, TFhirPositiveInt, FRank.Link));
end;

function TFhirEpisodeOfCareDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'rank') then
  begin
    RankElement := asPositiveInt(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEpisodeOfCareDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEpisodeOfCareDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'condition') then result := TFhirReference.create()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'rank') then result := TFhirPositiveInt.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEpisodeOfCareDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'condition') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'rank') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEpisodeOfCareDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'rank') then RankElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEpisodeOfCareDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := new as TFhirReference
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'rank') then RankElement := asPositiveInt(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEpisodeOfCareDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEpisodeOfCareDiagnosis.fhirType : string;
begin
  result := 'EpisodeOfCare.diagnosis';
end;

function TFhirEpisodeOfCareDiagnosis.Link : TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(inherited Link);
end;

function TFhirEpisodeOfCareDiagnosis.Clone : TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(inherited Clone);
end;

function TFhirEpisodeOfCareDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirEpisodeOfCareDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEpisodeOfCareDiagnosis)) then
    result := false
  else
  begin
    o := TFhirEpisodeOfCareDiagnosis(other);
    result := compareDeep(conditionElement, o.conditionElement, true) and compareDeep(roleElement, o.roleElement, true) and 
      compareDeep(rankElement, o.rankElement, true);
  end;
end;

function TFhirEpisodeOfCareDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCondition) and isEmptyProp(FRole) and isEmptyProp(FRank);
end;

procedure TFhirEpisodeOfCareDiagnosis.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('condition');
  fields.add('role');
  fields.add('rank');
end;

function TFhirEpisodeOfCareDiagnosis.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEpisodeOfCareDiagnosis.SetCondition(value : TFhirReference);
begin
  FCondition.free;
  FCondition := value;
end;

procedure TFhirEpisodeOfCareDiagnosis.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirEpisodeOfCareDiagnosis.SetRank(value : TFhirPositiveInt);
begin
  FRank.free;
  FRank := value;
end;

function TFhirEpisodeOfCareDiagnosis.GetRankST : String;
begin
  if FRank = nil then
    result := ''
  else
    result := FRank.value;
end;

procedure TFhirEpisodeOfCareDiagnosis.SetRankST(value : String);
begin
  if value <> '' then
  begin
    if FRank = nil then
      FRank := TFhirPositiveInt.create;
    FRank.value := value
  end
  else if FRank <> nil then
    FRank.value := '';
end;

{ TFhirEpisodeOfCareDiagnosisListEnumerator }

constructor TFhirEpisodeOfCareDiagnosisListEnumerator.Create(list : TFhirEpisodeOfCareDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEpisodeOfCareDiagnosisListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEpisodeOfCareDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEpisodeOfCareDiagnosisListEnumerator.GetCurrent : TFhirEpisodeOfCareDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirEpisodeOfCareDiagnosisListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEpisodeOfCareDiagnosisList }

function TFhirEpisodeOfCareDiagnosisList.AddItem(value: TFhirEpisodeOfCareDiagnosis): TFhirEpisodeOfCareDiagnosis;
begin
  assert(value.ClassName = 'TFhirEpisodeOfCareDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEpisodeOfCareDiagnosis');
  add(value);
  result := value;
end;

function TFhirEpisodeOfCareDiagnosisList.Append: TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirEpisodeOfCareDiagnosisList.GetEnumerator : TFhirEpisodeOfCareDiagnosisListEnumerator;
begin
  result := TFhirEpisodeOfCareDiagnosisListEnumerator.Create(self.link);
end;

function TFhirEpisodeOfCareDiagnosisList.Clone: TFhirEpisodeOfCareDiagnosisList;
begin
  result := TFhirEpisodeOfCareDiagnosisList(inherited Clone);
end;

function TFhirEpisodeOfCareDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEpisodeOfCareDiagnosisList.GetItemN(index: Integer): TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirEpisodeOfCareDiagnosis;
end;
function TFhirEpisodeOfCareDiagnosisList.IndexOf(value: TFhirEpisodeOfCareDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEpisodeOfCareDiagnosisList.Insert(index: Integer): TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareDiagnosisList.InsertItem(index: Integer; value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value is TFhirEpisodeOfCareDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirEpisodeOfCareDiagnosisList.Item(index: Integer): TFhirEpisodeOfCareDiagnosis;
begin
  result := TFhirEpisodeOfCareDiagnosis(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareDiagnosisList.Link: TFhirEpisodeOfCareDiagnosisList;
begin
  result := TFhirEpisodeOfCareDiagnosisList(inherited Link);
end;

procedure TFhirEpisodeOfCareDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEpisodeOfCareDiagnosisList.SetItemByIndex(index: Integer; value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value is TFhirEpisodeOfCareDiagnosis);
  FhirEpisodeOfCareDiagnoses[index] := value;
end;

procedure TFhirEpisodeOfCareDiagnosisList.SetItemN(index: Integer; value: TFhirEpisodeOfCareDiagnosis);
begin
  assert(value is TFhirEpisodeOfCareDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirEpisodeOfCare }

constructor TFhirEpisodeOfCare.Create;
begin
  inherited;
end;

destructor TFhirEpisodeOfCare.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FStatusHistoryList.Free;
  FType_List.Free;
  FDiagnosisList.Free;
  FPatient.free;
  FManagingOrganization.free;
  FPeriod.free;
  FReferralRequestList.Free;
  FCareManager.free;
  FTeamList.Free;
  FAccountList.Free;
  inherited;
end;

procedure TFhirEpisodeOfCare.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEpisodeOfCare(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEpisodeOfCare(oSource).FIdentifierList);
  end;
  statusElement := TFhirEpisodeOfCare(oSource).statusElement.Clone;
  if (TFhirEpisodeOfCare(oSource).FStatusHistoryList = nil) then
  begin
    FStatusHistoryList.free;
    FStatusHistoryList := nil;
  end
  else
  begin
    if FStatusHistoryList = nil then
      FStatusHistoryList := TFhirEpisodeOfCareStatusHistoryList.Create;
    FStatusHistoryList.Assign(TFhirEpisodeOfCare(oSource).FStatusHistoryList);
  end;
  if (TFhirEpisodeOfCare(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEpisodeOfCare(oSource).FType_List);
  end;
  if (TFhirEpisodeOfCare(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirEpisodeOfCareDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirEpisodeOfCare(oSource).FDiagnosisList);
  end;
  patient := TFhirEpisodeOfCare(oSource).patient.Clone;
  managingOrganization := TFhirEpisodeOfCare(oSource).managingOrganization.Clone;
  period := TFhirEpisodeOfCare(oSource).period.Clone;
  if (TFhirEpisodeOfCare(oSource).FReferralRequestList = nil) then
  begin
    FReferralRequestList.free;
    FReferralRequestList := nil;
  end
  else
  begin
    if FReferralRequestList = nil then
      FReferralRequestList := TFhirReferenceList.Create;
    FReferralRequestList.Assign(TFhirEpisodeOfCare(oSource).FReferralRequestList);
  end;
  careManager := TFhirEpisodeOfCare(oSource).careManager.Clone;
  if (TFhirEpisodeOfCare(oSource).FTeamList = nil) then
  begin
    FTeamList.free;
    FTeamList := nil;
  end
  else
  begin
    if FTeamList = nil then
      FTeamList := TFhirReferenceList.Create;
    FTeamList.Assign(TFhirEpisodeOfCare(oSource).FTeamList);
  end;
  if (TFhirEpisodeOfCare(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList.Create;
    FAccountList.Assign(TFhirEpisodeOfCare(oSource).FAccountList);
  end;
end;

function TFhirEpisodeOfCare.GetResourceType : TFhirResourceType;
begin
  result := frtEpisodeOfCare;
end;

procedure TFhirEpisodeOfCare.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusHistory') Then
    list.addAll(self, 'statusHistory', FStatusHistoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'referralRequest') Then
    list.addAll(self, 'referralRequest', FReferralRequestList);
  if (child_name = 'careManager') Then
     list.add(self.link, 'careManager', FCareManager.Link);
  if (child_name = 'team') Then
    list.addAll(self, 'team', FTeamList);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
end;

procedure TFhirEpisodeOfCare.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusHistory', 'BackboneElement', true, TFhirEpisodeOfCareStatusHistory, FStatusHistoryList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'diagnosis', 'BackboneElement', true, TFhirEpisodeOfCareDiagnosis, FDiagnosisList.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'referralRequest', 'Reference', true, TFhirReference, FReferralRequestList.Link));
  oList.add(TFHIRProperty.create(self, 'careManager', 'Reference', false, TFhirReference, FCareManager.Link));
  oList.add(TFHIRProperty.create(self, 'team', 'Reference', true, TFhirReference, FTeamList.Link));
  oList.add(TFHIRProperty.create(self, 'account', 'Reference', true, TFhirReference, FAccountList.Link));
end;

function TFhirEpisodeOfCare.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusHistory') then
  begin
    StatusHistoryList.add(propValue as TFhirEpisodeOfCareStatusHistory);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirEpisodeOfCareDiagnosis);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'referralRequest') then
  begin
    ReferralRequestList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'careManager') then
  begin
    CareManager := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'team') then
  begin
    TeamList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEpisodeOfCare.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'statusHistory') then StatusHistoryList.insertItem(index, propValue as TFhirEpisodeOfCareStatusHistory)
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirEpisodeOfCareDiagnosis)
  else if (propName = 'referralRequest') then ReferralRequestList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'team') then TeamList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirEpisodeOfCare.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[EpisodeOfCareStatusNull], CODES_TFhirEpisodeOfCareStatusEnum[EpisodeOfCareStatusNull]) 
  else if (propName = 'statusHistory') then result := StatusHistoryList.new()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'diagnosis') then result := DiagnosisList.new()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'managingOrganization') then result := TFhirReference.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'referralRequest') then result := ReferralRequestList.new()
  else if (propName = 'careManager') then result := TFhirReference.create()
  else if (propName = 'team') then result := TeamList.new()
  else if (propName = 'account') then result := AccountList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEpisodeOfCare.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusHistory') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'referralRequest') then result := 'Reference'
  else if (propName = 'careManager') then result := 'Reference'
  else if (propName = 'team') then result := 'Reference'
  else if (propName = 'account') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEpisodeOfCare.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusHistory') then deletePropertyValue('statusHistory', StatusHistoryList, value)
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value)
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'referralRequest') then deletePropertyValue('referralRequest', ReferralRequestList, value)
  else if (propName = 'careManager') then CareManagerElement := nil
  else if (propName = 'team') then deletePropertyValue('team', TeamList, value)
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEpisodeOfCare.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEpisodeOfCareStatusEnum, CODES_TFhirEpisodeOfCareStatusEnum, new)
  else if (propName = 'statusHistory') then replacePropertyValue('statusHistory', StatusHistoryList, existing, new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'referralRequest') then replacePropertyValue('referralRequest', ReferralRequestList, existing, new)
  else if (propName = 'careManager') then CareManagerElement := new as TFhirReference
  else if (propName = 'team') then replacePropertyValue('team', TeamList, existing, new)
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEpisodeOfCare.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'statusHistory') then StatusHistoryList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination)
  else if (propName = 'referralRequest') then ReferralRequestList.move(source, destination)
  else if (propName = 'team') then TeamList.move(source, destination)
  else if (propName = 'account') then AccountList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEpisodeOfCare.fhirType : string;
begin
  result := 'EpisodeOfCare';
end;

function TFhirEpisodeOfCare.Link : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(inherited Link);
end;

function TFhirEpisodeOfCare.Clone : TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(inherited Clone);
end;

function TFhirEpisodeOfCare.equals(other : TObject) : boolean; 
var
  o : TFhirEpisodeOfCare;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEpisodeOfCare)) then
    result := false
  else
  begin
    o := TFhirEpisodeOfCare(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusHistoryList, o.statusHistoryList, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(diagnosisList, o.diagnosisList, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(referralRequestList, o.referralRequestList, true) and 
      compareDeep(careManagerElement, o.careManagerElement, true) and compareDeep(teamList, o.teamList, true) and 
      compareDeep(accountList, o.accountList, true);
  end;
end;

function TFhirEpisodeOfCare.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusHistoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FdiagnosisList) and isEmptyProp(FPatient) and isEmptyProp(FManagingOrganization) and isEmptyProp(FPeriod) and isEmptyProp(FreferralRequestList) and isEmptyProp(FCareManager) and isEmptyProp(FteamList) and isEmptyProp(FaccountList);
end;

procedure TFhirEpisodeOfCare.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusHistory');
  fields.add('type');
  fields.add('diagnosis');
  fields.add('patient');
  fields.add('managingOrganization');
  fields.add('period');
  fields.add('referralRequest');
  fields.add('careManager');
  fields.add('team');
  fields.add('account');
end;

function TFhirEpisodeOfCare.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FStatusHistoryList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FDiagnosisList.sizeInBytes(magic));
  inc(result, FReferralRequestList.sizeInBytes(magic));
  inc(result, FTeamList.sizeInBytes(magic));
  inc(result, FAccountList.sizeInBytes(magic));
end;

function TFhirEpisodeOfCare.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEpisodeOfCare.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEpisodeOfCare.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEpisodeOfCare.GetStatusST : TFhirEpisodeOfCareStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEpisodeOfCareStatusEnum(0)
  else
    result := TFhirEpisodeOfCareStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEpisodeOfCareStatusEnum, FStatus.value));
end;

procedure TFhirEpisodeOfCare.SetStatusST(value : TFhirEpisodeOfCareStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEpisodeOfCareStatusEnum[value], CODES_TFhirEpisodeOfCareStatusEnum[value]);
end;

function TFhirEpisodeOfCare.GetStatusHistoryList : TFhirEpisodeOfCareStatusHistoryList;
begin
  if FStatusHistoryList = nil then
    FStatusHistoryList := TFhirEpisodeOfCareStatusHistoryList.Create;
  result := FStatusHistoryList;
end;

function TFhirEpisodeOfCare.GetHasStatusHistoryList : boolean;
begin
  result := (FStatusHistoryList <> nil) and (FStatusHistoryList.count > 0);
end;

function TFhirEpisodeOfCare.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirEpisodeOfCare.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirEpisodeOfCare.GetDiagnosisList : TFhirEpisodeOfCareDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirEpisodeOfCareDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirEpisodeOfCare.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

procedure TFhirEpisodeOfCare.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirEpisodeOfCare.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

procedure TFhirEpisodeOfCare.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirEpisodeOfCare.GetReferralRequestList : TFhirReferenceList;
begin
  if FReferralRequestList = nil then
    FReferralRequestList := TFhirReferenceList.Create;
  result := FReferralRequestList;
end;

function TFhirEpisodeOfCare.GetHasReferralRequestList : boolean;
begin
  result := (FReferralRequestList <> nil) and (FReferralRequestList.count > 0);
end;

procedure TFhirEpisodeOfCare.SetCareManager(value : TFhirReference);
begin
  FCareManager.free;
  FCareManager := value;
end;

function TFhirEpisodeOfCare.GetTeamList : TFhirReferenceList;
begin
  if FTeamList = nil then
    FTeamList := TFhirReferenceList.Create;
  result := FTeamList;
end;

function TFhirEpisodeOfCare.GetHasTeamList : boolean;
begin
  result := (FTeamList <> nil) and (FTeamList.count > 0);
end;

function TFhirEpisodeOfCare.GetAccountList : TFhirReferenceList;
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList.Create;
  result := FAccountList;
end;

function TFhirEpisodeOfCare.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

{ TFhirEpisodeOfCareListEnumerator }

constructor TFhirEpisodeOfCareListEnumerator.Create(list : TFhirEpisodeOfCareList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEpisodeOfCareListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEpisodeOfCareListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEpisodeOfCareListEnumerator.GetCurrent : TFhirEpisodeOfCare;
begin
  Result := FList[FIndex];
end;

function TFhirEpisodeOfCareListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEpisodeOfCareList }

function TFhirEpisodeOfCareList.AddItem(value: TFhirEpisodeOfCare): TFhirEpisodeOfCare;
begin
  assert(value.ClassName = 'TFhirEpisodeOfCare', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEpisodeOfCare');
  add(value);
  result := value;
end;

function TFhirEpisodeOfCareList.Append: TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareList.ClearItems;
begin
  Clear;
end;

function TFhirEpisodeOfCareList.GetEnumerator : TFhirEpisodeOfCareListEnumerator;
begin
  result := TFhirEpisodeOfCareListEnumerator.Create(self.link);
end;

function TFhirEpisodeOfCareList.Clone: TFhirEpisodeOfCareList;
begin
  result := TFhirEpisodeOfCareList(inherited Clone);
end;

function TFhirEpisodeOfCareList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEpisodeOfCareList.GetItemN(index: Integer): TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareList.ItemClass: TFslObjectClass;
begin
  result := TFhirEpisodeOfCare;
end;
function TFhirEpisodeOfCareList.IndexOf(value: TFhirEpisodeOfCare): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEpisodeOfCareList.Insert(index: Integer): TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEpisodeOfCareList.InsertItem(index: Integer; value: TFhirEpisodeOfCare);
begin
  assert(value is TFhirEpisodeOfCare);
  Inherited Insert(index, value);
end;

function TFhirEpisodeOfCareList.Item(index: Integer): TFhirEpisodeOfCare;
begin
  result := TFhirEpisodeOfCare(ObjectByIndex[index]);
end;

function TFhirEpisodeOfCareList.Link: TFhirEpisodeOfCareList;
begin
  result := TFhirEpisodeOfCareList(inherited Link);
end;

procedure TFhirEpisodeOfCareList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEpisodeOfCareList.SetItemByIndex(index: Integer; value: TFhirEpisodeOfCare);
begin
  assert(value is TFhirEpisodeOfCare);
  FhirEpisodeOfCares[index] := value;
end;

procedure TFhirEpisodeOfCareList.SetItemN(index: Integer; value: TFhirEpisodeOfCare);
begin
  assert(value is TFhirEpisodeOfCare);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EPISODEOFCARE}
{$IFDEF FHIR_FAMILYMEMBERHISTORY}
{ TFhirFamilyMemberHistoryCondition }

constructor TFhirFamilyMemberHistoryCondition.Create;
begin
  inherited;
end;

destructor TFhirFamilyMemberHistoryCondition.Destroy;
begin
  FCode.free;
  FOutcome.free;
  FContributedToDeath.free;
  FOnset.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirFamilyMemberHistoryCondition.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirFamilyMemberHistoryCondition(oSource).code.Clone;
  outcome := TFhirFamilyMemberHistoryCondition(oSource).outcome.Clone;
  contributedToDeathElement := TFhirFamilyMemberHistoryCondition(oSource).contributedToDeathElement.Clone;
  onset := TFhirFamilyMemberHistoryCondition(oSource).onset.Clone;
  if (TFhirFamilyMemberHistoryCondition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirFamilyMemberHistoryCondition(oSource).FNoteList);
  end;
end;

procedure TFhirFamilyMemberHistoryCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'contributedToDeath') Then
     list.add(self.link, 'contributedToDeath', FContributedToDeath.Link);
  if (child_name = 'onset[x]') or (child_name = 'onset') Then
     list.add(self.link, 'onset[x]', FOnset.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirFamilyMemberHistoryCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'contributedToDeath', 'boolean', false, TFhirBoolean, FContributedToDeath.Link));
  oList.add(TFHIRProperty.create(self, 'onset[x]', 'Age|Range|Period|string', false, TFhirDataType, FOnset.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirFamilyMemberHistoryCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'contributedToDeath') then
  begin
    ContributedToDeathElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then
  begin
    Onset := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFamilyMemberHistoryCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirFamilyMemberHistoryCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create()
  else if (propName = 'contributedToDeath') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then raise EFHIRException.create('Cannot make property Onset')
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirFamilyMemberHistoryCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'contributedToDeath') then result := 'boolean'
  else if (propName = 'onset[x]') then result := 'Age|Range|Period|string'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFamilyMemberHistoryCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'contributedToDeath') then ContributedToDeathElement := nil
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then OnsetElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFamilyMemberHistoryCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept
  else if (propName = 'contributedToDeath') then ContributedToDeathElement := asBoolean(new)
  else if (isMatchingName(propName, 'onset', ['Age', 'Range', 'Period', 'String'])) then OnsetElement := new as TFhirDataType
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFamilyMemberHistoryCondition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFamilyMemberHistoryCondition.fhirType : string;
begin
  result := 'FamilyMemberHistory.condition';
end;

function TFhirFamilyMemberHistoryCondition.Link : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(inherited Link);
end;

function TFhirFamilyMemberHistoryCondition.Clone : TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(inherited Clone);
end;

function TFhirFamilyMemberHistoryCondition.equals(other : TObject) : boolean; 
var
  o : TFhirFamilyMemberHistoryCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFamilyMemberHistoryCondition)) then
    result := false
  else
  begin
    o := TFhirFamilyMemberHistoryCondition(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(contributedToDeathElement, o.contributedToDeathElement, true) and 
      compareDeep(onsetElement, o.onsetElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirFamilyMemberHistoryCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FOutcome) and isEmptyProp(FContributedToDeath) and isEmptyProp(FOnset) and isEmptyProp(FnoteList);
end;

procedure TFhirFamilyMemberHistoryCondition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('outcome');
  fields.add('contributedToDeath');
  fields.add('onset[x]');
  fields.add('note');
end;

function TFhirFamilyMemberHistoryCondition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirFamilyMemberHistoryCondition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirFamilyMemberHistoryCondition.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

procedure TFhirFamilyMemberHistoryCondition.SetContributedToDeath(value : TFhirBoolean);
begin
  FContributedToDeath.free;
  FContributedToDeath := value;
end;

function TFhirFamilyMemberHistoryCondition.GetContributedToDeathST : Boolean;
begin
  if FContributedToDeath = nil then
    result := false
  else
    result := FContributedToDeath.value;
end;

procedure TFhirFamilyMemberHistoryCondition.SetContributedToDeathST(value : Boolean);
begin
  if FContributedToDeath = nil then
    FContributedToDeath := TFhirBoolean.create;
  FContributedToDeath.value := value
end;

procedure TFhirFamilyMemberHistoryCondition.SetOnset(value : TFhirDataType);
begin
  FOnset.free;
  FOnset := value;
end;

function TFhirFamilyMemberHistoryCondition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirFamilyMemberHistoryCondition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirFamilyMemberHistoryConditionListEnumerator }

constructor TFhirFamilyMemberHistoryConditionListEnumerator.Create(list : TFhirFamilyMemberHistoryConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFamilyMemberHistoryConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.GetCurrent : TFhirFamilyMemberHistoryCondition;
begin
  Result := FList[FIndex];
end;

function TFhirFamilyMemberHistoryConditionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirFamilyMemberHistoryConditionList }

function TFhirFamilyMemberHistoryConditionList.AddItem(value: TFhirFamilyMemberHistoryCondition): TFhirFamilyMemberHistoryCondition;
begin
  assert(value.ClassName = 'TFhirFamilyMemberHistoryCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyMemberHistoryCondition');
  add(value);
  result := value;
end;

function TFhirFamilyMemberHistoryConditionList.Append: TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryConditionList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyMemberHistoryConditionList.GetEnumerator : TFhirFamilyMemberHistoryConditionListEnumerator;
begin
  result := TFhirFamilyMemberHistoryConditionListEnumerator.Create(self.link);
end;

function TFhirFamilyMemberHistoryConditionList.Clone: TFhirFamilyMemberHistoryConditionList;
begin
  result := TFhirFamilyMemberHistoryConditionList(inherited Clone);
end;

function TFhirFamilyMemberHistoryConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyMemberHistoryConditionList.GetItemN(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirFamilyMemberHistoryCondition;
end;
function TFhirFamilyMemberHistoryConditionList.IndexOf(value: TFhirFamilyMemberHistoryCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFamilyMemberHistoryConditionList.Insert(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryConditionList.InsertItem(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  Inherited Insert(index, value);
end;

function TFhirFamilyMemberHistoryConditionList.Item(index: Integer): TFhirFamilyMemberHistoryCondition;
begin
  result := TFhirFamilyMemberHistoryCondition(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryConditionList.Link: TFhirFamilyMemberHistoryConditionList;
begin
  result := TFhirFamilyMemberHistoryConditionList(inherited Link);
end;

procedure TFhirFamilyMemberHistoryConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyMemberHistoryConditionList.SetItemByIndex(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  FhirFamilyMemberHistoryConditions[index] := value;
end;

procedure TFhirFamilyMemberHistoryConditionList.SetItemN(index: Integer; value: TFhirFamilyMemberHistoryCondition);
begin
  assert(value is TFhirFamilyMemberHistoryCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirFamilyMemberHistory }

constructor TFhirFamilyMemberHistory.Create;
begin
  inherited;
end;

destructor TFhirFamilyMemberHistory.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FStatus.free;
  FDataAbsentReason.free;
  FPatient.free;
  FDate.free;
  FName.free;
  FRelationship.free;
  FSex.free;
  FBorn.free;
  FAge.free;
  FEstimatedAge.free;
  FDeceased.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FConditionList.Free;
  inherited;
end;

procedure TFhirFamilyMemberHistory.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirFamilyMemberHistory(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirFamilyMemberHistory(oSource).FIdentifierList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirFamilyMemberHistory(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirFamilyMemberHistory(oSource).FInstantiatesUriList);
  end;
  statusElement := TFhirFamilyMemberHistory(oSource).statusElement.Clone;
  dataAbsentReason := TFhirFamilyMemberHistory(oSource).dataAbsentReason.Clone;
  patient := TFhirFamilyMemberHistory(oSource).patient.Clone;
  dateElement := TFhirFamilyMemberHistory(oSource).dateElement.Clone;
  nameElement := TFhirFamilyMemberHistory(oSource).nameElement.Clone;
  relationship := TFhirFamilyMemberHistory(oSource).relationship.Clone;
  sex := TFhirFamilyMemberHistory(oSource).sex.Clone;
  born := TFhirFamilyMemberHistory(oSource).born.Clone;
  age := TFhirFamilyMemberHistory(oSource).age.Clone;
  estimatedAgeElement := TFhirFamilyMemberHistory(oSource).estimatedAgeElement.Clone;
  deceased := TFhirFamilyMemberHistory(oSource).deceased.Clone;
  if (TFhirFamilyMemberHistory(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirFamilyMemberHistory(oSource).FReasonCodeList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirFamilyMemberHistory(oSource).FReasonReferenceList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirFamilyMemberHistory(oSource).FNoteList);
  end;
  if (TFhirFamilyMemberHistory(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirFamilyMemberHistoryConditionList.Create;
    FConditionList.Assign(TFhirFamilyMemberHistory(oSource).FConditionList);
  end;
end;

function TFhirFamilyMemberHistory.GetResourceType : TFhirResourceType;
begin
  result := frtFamilyMemberHistory;
end;

procedure TFhirFamilyMemberHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'sex') Then
     list.add(self.link, 'sex', FSex.Link);
  if (child_name = 'born[x]') or (child_name = 'born') Then
     list.add(self.link, 'born[x]', FBorn.Link);
  if (child_name = 'age[x]') or (child_name = 'age') Then
     list.add(self.link, 'age[x]', FAge.Link);
  if (child_name = 'estimatedAge') Then
     list.add(self.link, 'estimatedAge', FEstimatedAge.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
end;

procedure TFhirFamilyMemberHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'CodeableConcept', false, TFhirCodeableConcept, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'sex', 'CodeableConcept', false, TFhirCodeableConcept, FSex.Link));
  oList.add(TFHIRProperty.create(self, 'born[x]', 'Period|date|string', false, TFhirDataType, FBorn.Link));
  oList.add(TFHIRProperty.create(self, 'age[x]', 'Age|Range|string', false, TFhirDataType, FAge.Link));
  oList.add(TFHIRProperty.create(self, 'estimatedAge', 'boolean', false, TFhirBoolean, FEstimatedAge.Link));
  oList.add(TFHIRProperty.create(self, 'deceased[x]', 'boolean|Age|Range|date|string', false, TFhirDataType, FDeceased.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'BackboneElement', true, TFhirFamilyMemberHistoryCondition, FConditionList.Link));
end;

function TFhirFamilyMemberHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFamilyHistoryStatusEnum, CODES_TFhirFamilyHistoryStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'sex') then
  begin
    Sex := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then
  begin
    Born := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then
  begin
    Age := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'estimatedAge') then
  begin
    EstimatedAgeElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then
  begin
    Deceased := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirFamilyMemberHistoryCondition);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFamilyMemberHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirFamilyMemberHistoryCondition)
  else inherited;
end;

function TFhirFamilyMemberHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFamilyHistoryStatusEnum[FamilyHistoryStatusNull], CODES_TFhirFamilyHistoryStatusEnum[FamilyHistoryStatusNull]) 
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'relationship') then result := TFhirCodeableConcept.create()
  else if (propName = 'sex') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then raise EFHIRException.create('Cannot make property Born')
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then raise EFHIRException.create('Cannot make property Age')
  else if (propName = 'estimatedAge') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then raise EFHIRException.create('Cannot make property Deceased')
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'condition') then result := ConditionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirFamilyMemberHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'sex') then result := 'CodeableConcept'
  else if (propName = 'born[x]') then result := 'Period|date|string'
  else if (propName = 'age[x]') then result := 'Age|Range|string'
  else if (propName = 'estimatedAge') then result := 'boolean'
  else if (propName = 'deceased[x]') then result := 'boolean|Age|Range|date|string'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'condition') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFamilyMemberHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'sex') then SexElement := nil
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then BornElement := nil
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then AgeElement := nil
  else if (propName = 'estimatedAge') then EstimatedAgeElement := nil
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then DeceasedElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFamilyMemberHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFamilyHistoryStatusEnum, CODES_TFhirFamilyHistoryStatusEnum, new)
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCodeableConcept
  else if (propName = 'sex') then SexElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'born', ['Period', 'Date', 'String'])) then BornElement := new as TFhirDataType
  else if (isMatchingName(propName, 'age', ['Age', 'Range', 'String'])) then AgeElement := new as TFhirDataType
  else if (propName = 'estimatedAge') then EstimatedAgeElement := asBoolean(new)
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'Age', 'Range', 'Date', 'String'])) then DeceasedElement := new as TFhirDataType
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFamilyMemberHistory.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'condition') then ConditionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFamilyMemberHistory.fhirType : string;
begin
  result := 'FamilyMemberHistory';
end;

function TFhirFamilyMemberHistory.Link : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(inherited Link);
end;

function TFhirFamilyMemberHistory.Clone : TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(inherited Clone);
end;

function TFhirFamilyMemberHistory.equals(other : TObject) : boolean; 
var
  o : TFhirFamilyMemberHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFamilyMemberHistory)) then
    result := false
  else
  begin
    o := TFhirFamilyMemberHistory(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(sexElement, o.sexElement, true) and 
      compareDeep(bornElement, o.bornElement, true) and compareDeep(ageElement, o.ageElement, true) and 
      compareDeep(estimatedAgeElement, o.estimatedAgeElement, true) and compareDeep(deceasedElement, o.deceasedElement, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(conditionList, o.conditionList, true);
  end;
end;

function TFhirFamilyMemberHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FStatus) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FName) and isEmptyProp(FRelationship) and isEmptyProp(FSex) and isEmptyProp(FBorn) and isEmptyProp(FAge) and isEmptyProp(FEstimatedAge) and isEmptyProp(FDeceased) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FconditionList);
end;

procedure TFhirFamilyMemberHistory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('status');
  fields.add('dataAbsentReason');
  fields.add('patient');
  fields.add('date');
  fields.add('name');
  fields.add('relationship');
  fields.add('sex');
  fields.add('born[x]');
  fields.add('age[x]');
  fields.add('estimatedAge');
  fields.add('deceased[x]');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('condition');
end;

function TFhirFamilyMemberHistory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FConditionList.sizeInBytes(magic));
end;

function TFhirFamilyMemberHistory.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirFamilyMemberHistory.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirFamilyMemberHistory.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirFamilyMemberHistory.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirFamilyMemberHistory.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirFamilyMemberHistory.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

procedure TFhirFamilyMemberHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirFamilyMemberHistory.GetStatusST : TFhirFamilyHistoryStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFamilyHistoryStatusEnum(0)
  else
    result := TFhirFamilyHistoryStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFamilyHistoryStatusEnum, FStatus.value));
end;

procedure TFhirFamilyMemberHistory.SetStatusST(value : TFhirFamilyHistoryStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFamilyHistoryStatusEnum[value], CODES_TFhirFamilyHistoryStatusEnum[value]);
end;

procedure TFhirFamilyMemberHistory.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value;
end;

procedure TFhirFamilyMemberHistory.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirFamilyMemberHistory.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirFamilyMemberHistory.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirFamilyMemberHistory.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirFamilyMemberHistory.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirFamilyMemberHistory.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirFamilyMemberHistory.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirFamilyMemberHistory.SetRelationship(value : TFhirCodeableConcept);
begin
  FRelationship.free;
  FRelationship := value;
end;

procedure TFhirFamilyMemberHistory.SetSex(value : TFhirCodeableConcept);
begin
  FSex.free;
  FSex := value;
end;

procedure TFhirFamilyMemberHistory.SetBorn(value : TFhirDataType);
begin
  FBorn.free;
  FBorn := value;
end;

procedure TFhirFamilyMemberHistory.SetAge(value : TFhirDataType);
begin
  FAge.free;
  FAge := value;
end;

procedure TFhirFamilyMemberHistory.SetEstimatedAge(value : TFhirBoolean);
begin
  FEstimatedAge.free;
  FEstimatedAge := value;
end;

function TFhirFamilyMemberHistory.GetEstimatedAgeST : Boolean;
begin
  if FEstimatedAge = nil then
    result := false
  else
    result := FEstimatedAge.value;
end;

procedure TFhirFamilyMemberHistory.SetEstimatedAgeST(value : Boolean);
begin
  if FEstimatedAge = nil then
    FEstimatedAge := TFhirBoolean.create;
  FEstimatedAge.value := value
end;

procedure TFhirFamilyMemberHistory.SetDeceased(value : TFhirDataType);
begin
  FDeceased.free;
  FDeceased := value;
end;

function TFhirFamilyMemberHistory.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirFamilyMemberHistory.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirFamilyMemberHistory.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirFamilyMemberHistory.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirFamilyMemberHistory.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirFamilyMemberHistory.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirFamilyMemberHistory.GetConditionList : TFhirFamilyMemberHistoryConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirFamilyMemberHistoryConditionList.Create;
  result := FConditionList;
end;

function TFhirFamilyMemberHistory.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

{ TFhirFamilyMemberHistoryListEnumerator }

constructor TFhirFamilyMemberHistoryListEnumerator.Create(list : TFhirFamilyMemberHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFamilyMemberHistoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFamilyMemberHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFamilyMemberHistoryListEnumerator.GetCurrent : TFhirFamilyMemberHistory;
begin
  Result := FList[FIndex];
end;

function TFhirFamilyMemberHistoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirFamilyMemberHistoryList }

function TFhirFamilyMemberHistoryList.AddItem(value: TFhirFamilyMemberHistory): TFhirFamilyMemberHistory;
begin
  assert(value.ClassName = 'TFhirFamilyMemberHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFamilyMemberHistory');
  add(value);
  result := value;
end;

function TFhirFamilyMemberHistoryList.Append: TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirFamilyMemberHistoryList.GetEnumerator : TFhirFamilyMemberHistoryListEnumerator;
begin
  result := TFhirFamilyMemberHistoryListEnumerator.Create(self.link);
end;

function TFhirFamilyMemberHistoryList.Clone: TFhirFamilyMemberHistoryList;
begin
  result := TFhirFamilyMemberHistoryList(inherited Clone);
end;

function TFhirFamilyMemberHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFamilyMemberHistoryList.GetItemN(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirFamilyMemberHistory;
end;
function TFhirFamilyMemberHistoryList.IndexOf(value: TFhirFamilyMemberHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFamilyMemberHistoryList.Insert(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFamilyMemberHistoryList.InsertItem(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  Inherited Insert(index, value);
end;

function TFhirFamilyMemberHistoryList.Item(index: Integer): TFhirFamilyMemberHistory;
begin
  result := TFhirFamilyMemberHistory(ObjectByIndex[index]);
end;

function TFhirFamilyMemberHistoryList.Link: TFhirFamilyMemberHistoryList;
begin
  result := TFhirFamilyMemberHistoryList(inherited Link);
end;

procedure TFhirFamilyMemberHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFamilyMemberHistoryList.SetItemByIndex(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  FhirFamilyMemberHistories[index] := value;
end;

procedure TFhirFamilyMemberHistoryList.SetItemN(index: Integer; value: TFhirFamilyMemberHistory);
begin
  assert(value is TFhirFamilyMemberHistory);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_FAMILYMEMBERHISTORY}
{$IFDEF FHIR_FLAG}
{ TFhirFlag }

constructor TFhirFlag.Create;
begin
  inherited;
end;

destructor TFhirFlag.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FPeriod.free;
  FEncounter.free;
  FAuthor.free;
  inherited;
end;

procedure TFhirFlag.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirFlag(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirFlag(oSource).FIdentifierList);
  end;
  statusElement := TFhirFlag(oSource).statusElement.Clone;
  if (TFhirFlag(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirFlag(oSource).FCategoryList);
  end;
  code := TFhirFlag(oSource).code.Clone;
  subject := TFhirFlag(oSource).subject.Clone;
  period := TFhirFlag(oSource).period.Clone;
  encounter := TFhirFlag(oSource).encounter.Clone;
  author := TFhirFlag(oSource).author.Clone;
end;

function TFhirFlag.GetResourceType : TFhirResourceType;
begin
  result := frtFlag;
end;

procedure TFhirFlag.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
end;

procedure TFhirFlag.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
end;

function TFhirFlag.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFlagStatusEnum, CODES_TFhirFlagStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirFlag.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirFlag.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFlagStatusEnum[FlagStatusNull], CODES_TFhirFlagStatusEnum[FlagStatusNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirFlag.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirFlag.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirFlag.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFlagStatusEnum, CODES_TFhirFlagStatusEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirFlag.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirFlag.fhirType : string;
begin
  result := 'Flag';
end;

function TFhirFlag.Link : TFhirFlag;
begin
  result := TFhirFlag(inherited Link);
end;

function TFhirFlag.Clone : TFhirFlag;
begin
  result := TFhirFlag(inherited Clone);
end;

function TFhirFlag.equals(other : TObject) : boolean; 
var
  o : TFhirFlag;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirFlag)) then
    result := false
  else
  begin
    o := TFhirFlag(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(authorElement, o.authorElement, true);
  end;
end;

function TFhirFlag.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FPeriod) and isEmptyProp(FEncounter) and isEmptyProp(FAuthor);
end;

procedure TFhirFlag.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('period');
  fields.add('encounter');
  fields.add('author');
end;

function TFhirFlag.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
end;

function TFhirFlag.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirFlag.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirFlag.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirFlag.GetStatusST : TFhirFlagStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFlagStatusEnum(0)
  else
    result := TFhirFlagStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFlagStatusEnum, FStatus.value));
end;

procedure TFhirFlag.SetStatusST(value : TFhirFlagStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFlagStatusEnum[value], CODES_TFhirFlagStatusEnum[value]);
end;

function TFhirFlag.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirFlag.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirFlag.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirFlag.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirFlag.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirFlag.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirFlag.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

{ TFhirFlagListEnumerator }

constructor TFhirFlagListEnumerator.Create(list : TFhirFlagList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirFlagListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirFlagListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirFlagListEnumerator.GetCurrent : TFhirFlag;
begin
  Result := FList[FIndex];
end;

function TFhirFlagListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirFlagList }

function TFhirFlagList.AddItem(value: TFhirFlag): TFhirFlag;
begin
  assert(value.ClassName = 'TFhirFlag', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirFlag');
  add(value);
  result := value;
end;

function TFhirFlagList.Append: TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFlagList.ClearItems;
begin
  Clear;
end;

function TFhirFlagList.GetEnumerator : TFhirFlagListEnumerator;
begin
  result := TFhirFlagListEnumerator.Create(self.link);
end;

function TFhirFlagList.Clone: TFhirFlagList;
begin
  result := TFhirFlagList(inherited Clone);
end;

function TFhirFlagList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirFlagList.GetItemN(index: Integer): TFhirFlag;
begin
  result := TFhirFlag(ObjectByIndex[index]);
end;

function TFhirFlagList.ItemClass: TFslObjectClass;
begin
  result := TFhirFlag;
end;
function TFhirFlagList.IndexOf(value: TFhirFlag): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirFlagList.Insert(index: Integer): TFhirFlag;
begin
  result := TFhirFlag.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirFlagList.InsertItem(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  Inherited Insert(index, value);
end;

function TFhirFlagList.Item(index: Integer): TFhirFlag;
begin
  result := TFhirFlag(ObjectByIndex[index]);
end;

function TFhirFlagList.Link: TFhirFlagList;
begin
  result := TFhirFlagList(inherited Link);
end;

procedure TFhirFlagList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirFlagList.SetItemByIndex(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  FhirFlags[index] := value;
end;

procedure TFhirFlagList.SetItemN(index: Integer; value: TFhirFlag);
begin
  assert(value is TFhirFlag);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_FLAG}
{$IFDEF FHIR_GOAL}
{ TFhirGoalTarget }

constructor TFhirGoalTarget.Create;
begin
  inherited;
end;

destructor TFhirGoalTarget.Destroy;
begin
  FMeasure.free;
  FDetail.free;
  FDue.free;
  inherited;
end;

procedure TFhirGoalTarget.Assign(oSource : TFslObject);
begin
  inherited;
  measure := TFhirGoalTarget(oSource).measure.Clone;
  detail := TFhirGoalTarget(oSource).detail.Clone;
  due := TFhirGoalTarget(oSource).due.Clone;
end;

procedure TFhirGoalTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'detail[x]') or (child_name = 'detail') Then
     list.add(self.link, 'detail[x]', FDetail.Link);
  if (child_name = 'due[x]') or (child_name = 'due') Then
     list.add(self.link, 'due[x]', FDue.Link);
end;

procedure TFhirGoalTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'measure', 'CodeableConcept', false, TFhirCodeableConcept, FMeasure.Link));
  oList.add(TFHIRProperty.create(self, 'detail[x]', 'Quantity|Range|CodeableConcept|string|boolean|integer|Ratio', false, TFhirDataType, FDetail.Link));
  oList.add(TFHIRProperty.create(self, 'due[x]', 'date|Duration', false, TFhirDataType, FDue.Link));
end;

function TFhirGoalTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'measure') then
  begin
    Measure := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then
  begin
    Detail := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then
  begin
    Due := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGoalTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGoalTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'measure') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then raise EFHIRException.create('Cannot make property Detail')
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then raise EFHIRException.create('Cannot make property Due')
  else result := inherited createPropertyValue(propName);
end;

function TFhirGoalTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'measure') then result := 'CodeableConcept'
  else if (propName = 'detail[x]') then result := 'Quantity|Range|CodeableConcept|string|boolean|integer|Ratio'
  else if (propName = 'due[x]') then result := 'date|Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGoalTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := nil
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then DetailElement := nil
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then DueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGoalTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Ratio'])) then DetailElement := new as TFhirDataType
  else if (isMatchingName(propName, 'due', ['Date', 'Duration'])) then DueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGoalTarget.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGoalTarget.fhirType : string;
begin
  result := 'Goal.target';
end;

function TFhirGoalTarget.Link : TFhirGoalTarget;
begin
  result := TFhirGoalTarget(inherited Link);
end;

function TFhirGoalTarget.Clone : TFhirGoalTarget;
begin
  result := TFhirGoalTarget(inherited Clone);
end;

function TFhirGoalTarget.equals(other : TObject) : boolean; 
var
  o : TFhirGoalTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGoalTarget)) then
    result := false
  else
  begin
    o := TFhirGoalTarget(other);
    result := compareDeep(measureElement, o.measureElement, true) and compareDeep(detailElement, o.detailElement, true) and 
      compareDeep(dueElement, o.dueElement, true);
  end;
end;

function TFhirGoalTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeasure) and isEmptyProp(FDetail) and isEmptyProp(FDue);
end;

procedure TFhirGoalTarget.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('measure');
  fields.add('detail[x]');
  fields.add('due[x]');
end;

function TFhirGoalTarget.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirGoalTarget.SetMeasure(value : TFhirCodeableConcept);
begin
  FMeasure.free;
  FMeasure := value;
end;

procedure TFhirGoalTarget.SetDetail(value : TFhirDataType);
begin
  FDetail.free;
  FDetail := value;
end;

procedure TFhirGoalTarget.SetDue(value : TFhirDataType);
begin
  FDue.free;
  FDue := value;
end;

{ TFhirGoalTargetListEnumerator }

constructor TFhirGoalTargetListEnumerator.Create(list : TFhirGoalTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGoalTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGoalTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGoalTargetListEnumerator.GetCurrent : TFhirGoalTarget;
begin
  Result := FList[FIndex];
end;

function TFhirGoalTargetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGoalTargetList }

function TFhirGoalTargetList.AddItem(value: TFhirGoalTarget): TFhirGoalTarget;
begin
  assert(value.ClassName = 'TFhirGoalTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGoalTarget');
  add(value);
  result := value;
end;

function TFhirGoalTargetList.Append: TFhirGoalTarget;
begin
  result := TFhirGoalTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalTargetList.ClearItems;
begin
  Clear;
end;

function TFhirGoalTargetList.GetEnumerator : TFhirGoalTargetListEnumerator;
begin
  result := TFhirGoalTargetListEnumerator.Create(self.link);
end;

function TFhirGoalTargetList.Clone: TFhirGoalTargetList;
begin
  result := TFhirGoalTargetList(inherited Clone);
end;

function TFhirGoalTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGoalTargetList.GetItemN(index: Integer): TFhirGoalTarget;
begin
  result := TFhirGoalTarget(ObjectByIndex[index]);
end;

function TFhirGoalTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirGoalTarget;
end;
function TFhirGoalTargetList.IndexOf(value: TFhirGoalTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGoalTargetList.Insert(index: Integer): TFhirGoalTarget;
begin
  result := TFhirGoalTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalTargetList.InsertItem(index: Integer; value: TFhirGoalTarget);
begin
  assert(value is TFhirGoalTarget);
  Inherited Insert(index, value);
end;

function TFhirGoalTargetList.Item(index: Integer): TFhirGoalTarget;
begin
  result := TFhirGoalTarget(ObjectByIndex[index]);
end;

function TFhirGoalTargetList.Link: TFhirGoalTargetList;
begin
  result := TFhirGoalTargetList(inherited Link);
end;

procedure TFhirGoalTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGoalTargetList.SetItemByIndex(index: Integer; value: TFhirGoalTarget);
begin
  assert(value is TFhirGoalTarget);
  FhirGoalTargets[index] := value;
end;

procedure TFhirGoalTargetList.SetItemN(index: Integer; value: TFhirGoalTarget);
begin
  assert(value is TFhirGoalTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirGoal }

constructor TFhirGoal.Create;
begin
  inherited;
end;

destructor TFhirGoal.Destroy;
begin
  FIdentifierList.Free;
  FLifecycleStatus.free;
  FAchievementStatus.free;
  FCategoryList.Free;
  FPriority.free;
  FDescription.free;
  FSubject.free;
  FStart.free;
  FTargetList.Free;
  FStatusDate.free;
  FStatusReason.free;
  FExpressedBy.free;
  FAddressesList.Free;
  FNoteList.Free;
  FOutcomeCodeList.Free;
  FOutcomeReferenceList.Free;
  inherited;
end;

procedure TFhirGoal.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirGoal(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGoal(oSource).FIdentifierList);
  end;
  lifecycleStatusElement := TFhirGoal(oSource).lifecycleStatusElement.Clone;
  achievementStatus := TFhirGoal(oSource).achievementStatus.Clone;
  if (TFhirGoal(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirGoal(oSource).FCategoryList);
  end;
  priority := TFhirGoal(oSource).priority.Clone;
  description := TFhirGoal(oSource).description.Clone;
  subject := TFhirGoal(oSource).subject.Clone;
  start := TFhirGoal(oSource).start.Clone;
  if (TFhirGoal(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirGoalTargetList.Create;
    FTargetList.Assign(TFhirGoal(oSource).FTargetList);
  end;
  statusDateElement := TFhirGoal(oSource).statusDateElement.Clone;
  statusReasonElement := TFhirGoal(oSource).statusReasonElement.Clone;
  expressedBy := TFhirGoal(oSource).expressedBy.Clone;
  if (TFhirGoal(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirReferenceList.Create;
    FAddressesList.Assign(TFhirGoal(oSource).FAddressesList);
  end;
  if (TFhirGoal(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirGoal(oSource).FNoteList);
  end;
  if (TFhirGoal(oSource).FOutcomeCodeList = nil) then
  begin
    FOutcomeCodeList.free;
    FOutcomeCodeList := nil;
  end
  else
  begin
    if FOutcomeCodeList = nil then
      FOutcomeCodeList := TFhirCodeableConceptList.Create;
    FOutcomeCodeList.Assign(TFhirGoal(oSource).FOutcomeCodeList);
  end;
  if (TFhirGoal(oSource).FOutcomeReferenceList = nil) then
  begin
    FOutcomeReferenceList.free;
    FOutcomeReferenceList := nil;
  end
  else
  begin
    if FOutcomeReferenceList = nil then
      FOutcomeReferenceList := TFhirReferenceList.Create;
    FOutcomeReferenceList.Assign(TFhirGoal(oSource).FOutcomeReferenceList);
  end;
end;

function TFhirGoal.GetResourceType : TFhirResourceType;
begin
  result := frtGoal;
end;

procedure TFhirGoal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'lifecycleStatus') Then
     list.add(self.link, 'lifecycleStatus', FLifecycleStatus.Link);
  if (child_name = 'achievementStatus') Then
     list.add(self.link, 'achievementStatus', FAchievementStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'start[x]') or (child_name = 'start') Then
     list.add(self.link, 'start[x]', FStart.Link);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'expressedBy') Then
     list.add(self.link, 'expressedBy', FExpressedBy.Link);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'outcomeCode') Then
    list.addAll(self, 'outcomeCode', FOutcomeCodeList);
  if (child_name = 'outcomeReference') Then
    list.addAll(self, 'outcomeReference', FOutcomeReferenceList);
end;

procedure TFhirGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'lifecycleStatus', 'code', false, TFhirEnum, FLifecycleStatus.Link));
  oList.add(TFHIRProperty.create(self, 'achievementStatus', 'CodeableConcept', false, TFhirCodeableConcept, FAchievementStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', false, TFhirCodeableConcept, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'start[x]', 'date|CodeableConcept', false, TFhirDataType, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', true, TFhirGoalTarget, FTargetList.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'date', false, TFhirDate, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'string', false, TFhirString, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'expressedBy', 'Reference', false, TFhirReference, FExpressedBy.Link));
  oList.add(TFHIRProperty.create(self, 'addresses', 'Reference', true, TFhirReference, FAddressesList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'outcomeCode', 'CodeableConcept', true, TFhirCodeableConcept, FOutcomeCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'outcomeReference', 'Reference', true, TFhirReference, FOutcomeReferenceList.Link));
end;

function TFhirGoal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'lifecycleStatus') then
  begin
    LifecycleStatusElement := asEnum(SYSTEMS_TFhirGoalLifecycleStatusEnum, CODES_TFhirGoalLifecycleStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'achievementStatus') then
  begin
    AchievementStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    Description := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then
  begin
    Start := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirGoalTarget);
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expressedBy') then
  begin
    ExpressedBy := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'outcomeCode') then
  begin
    OutcomeCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'outcomeReference') then
  begin
    OutcomeReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGoal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirGoalTarget)
  else if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'outcomeCode') then OutcomeCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'outcomeReference') then OutcomeReferenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirGoal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'lifecycleStatus') then result := TFhirEnum.create(SYSTEMS_TFhirGoalLifecycleStatusEnum[GoalLifecycleStatusNull], CODES_TFhirGoalLifecycleStatusEnum[GoalLifecycleStatusNull]) 
  else if (propName = 'achievementStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'priority') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Start')
  else if (propName = 'target') then result := TargetList.new()
  else if (propName = 'statusDate') then result := TFhirDate.create()
  else if (propName = 'statusReason') then result := TFhirString.create()
  else if (propName = 'expressedBy') then result := TFhirReference.create()
  else if (propName = 'addresses') then result := AddressesList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'outcomeCode') then result := OutcomeCodeList.new()
  else if (propName = 'outcomeReference') then result := OutcomeReferenceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGoal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'lifecycleStatus') then result := 'code'
  else if (propName = 'achievementStatus') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'start[x]') then result := 'date|CodeableConcept'
  else if (propName = 'target') then result := 'BackboneElement'
  else if (propName = 'statusDate') then result := 'date'
  else if (propName = 'statusReason') then result := 'string'
  else if (propName = 'expressedBy') then result := 'Reference'
  else if (propName = 'addresses') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'outcomeCode') then result := 'CodeableConcept'
  else if (propName = 'outcomeReference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGoal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'lifecycleStatus') then LifecycleStatusElement := nil
  else if (propName = 'achievementStatus') then AchievementStatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then StartElement := nil
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'expressedBy') then ExpressedByElement := nil
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'outcomeCode') then deletePropertyValue('outcomeCode', OutcomeCodeList, value)
  else if (propName = 'outcomeReference') then deletePropertyValue('outcomeReference', OutcomeReferenceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGoal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'lifecycleStatus') then LifecycleStatusElement := asEnum(SYSTEMS_TFhirGoalLifecycleStatusEnum, CODES_TFhirGoalLifecycleStatusEnum, new)
  else if (propName = 'achievementStatus') then AchievementStatusElement := new as TFhirCodeableConcept
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (isMatchingName(propName, 'start', ['Date', 'CodeableConcept'])) then StartElement := new as TFhirDataType
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else if (propName = 'statusDate') then StatusDateElement := asDate(new)
  else if (propName = 'statusReason') then StatusReasonElement := asString(new)
  else if (propName = 'expressedBy') then ExpressedByElement := new as TFhirReference
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'outcomeCode') then replacePropertyValue('outcomeCode', OutcomeCodeList, existing, new)
  else if (propName = 'outcomeReference') then replacePropertyValue('outcomeReference', OutcomeReferenceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGoal.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'target') then TargetList.move(source, destination)
  else if (propName = 'addresses') then AddressesList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'outcomeCode') then OutcomeCodeList.move(source, destination)
  else if (propName = 'outcomeReference') then OutcomeReferenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGoal.fhirType : string;
begin
  result := 'Goal';
end;

function TFhirGoal.Link : TFhirGoal;
begin
  result := TFhirGoal(inherited Link);
end;

function TFhirGoal.Clone : TFhirGoal;
begin
  result := TFhirGoal(inherited Clone);
end;

function TFhirGoal.equals(other : TObject) : boolean; 
var
  o : TFhirGoal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGoal)) then
    result := false
  else
  begin
    o := TFhirGoal(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(lifecycleStatusElement, o.lifecycleStatusElement, true) and 
      compareDeep(achievementStatusElement, o.achievementStatusElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(startElement, o.startElement, true) and 
      compareDeep(targetList, o.targetList, true) and compareDeep(statusDateElement, o.statusDateElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(expressedByElement, o.expressedByElement, true) and 
      compareDeep(addressesList, o.addressesList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(outcomeCodeList, o.outcomeCodeList, true) and compareDeep(outcomeReferenceList, o.outcomeReferenceList, true);
  end;
end;

function TFhirGoal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FLifecycleStatus) and isEmptyProp(FAchievementStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FDescription) and isEmptyProp(FSubject) and isEmptyProp(FStart) and isEmptyProp(FtargetList) and isEmptyProp(FStatusDate) and isEmptyProp(FStatusReason) and isEmptyProp(FExpressedBy) and isEmptyProp(FaddressesList) and isEmptyProp(FnoteList) and isEmptyProp(FoutcomeCodeList) and isEmptyProp(FoutcomeReferenceList);
end;

procedure TFhirGoal.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('lifecycleStatus');
  fields.add('achievementStatus');
  fields.add('category');
  fields.add('priority');
  fields.add('description');
  fields.add('subject');
  fields.add('start[x]');
  fields.add('target');
  fields.add('statusDate');
  fields.add('statusReason');
  fields.add('expressedBy');
  fields.add('addresses');
  fields.add('note');
  fields.add('outcomeCode');
  fields.add('outcomeReference');
end;

function TFhirGoal.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FTargetList.sizeInBytes(magic));
  inc(result, FAddressesList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FOutcomeCodeList.sizeInBytes(magic));
  inc(result, FOutcomeReferenceList.sizeInBytes(magic));
end;

function TFhirGoal.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirGoal.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirGoal.SetLifecycleStatus(value : TFhirEnum);
begin
  FLifecycleStatus.free;
  FLifecycleStatus := value;
end;

function TFhirGoal.GetLifecycleStatusST : TFhirGoalLifecycleStatusEnum;
begin
  if FLifecycleStatus = nil then
    result := TFhirGoalLifecycleStatusEnum(0)
  else
    result := TFhirGoalLifecycleStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirGoalLifecycleStatusEnum, FLifecycleStatus.value));
end;

procedure TFhirGoal.SetLifecycleStatusST(value : TFhirGoalLifecycleStatusEnum);
begin
  if ord(value) = 0 then
    LifecycleStatusElement := nil
  else
    LifecycleStatusElement := TFhirEnum.create(SYSTEMS_TFhirGoalLifecycleStatusEnum[value], CODES_TFhirGoalLifecycleStatusEnum[value]);
end;

procedure TFhirGoal.SetAchievementStatus(value : TFhirCodeableConcept);
begin
  FAchievementStatus.free;
  FAchievementStatus := value;
end;

function TFhirGoal.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirGoal.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirGoal.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

procedure TFhirGoal.SetDescription(value : TFhirCodeableConcept);
begin
  FDescription.free;
  FDescription := value;
end;

procedure TFhirGoal.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirGoal.SetStart(value : TFhirDataType);
begin
  FStart.free;
  FStart := value;
end;

function TFhirGoal.GetTargetList : TFhirGoalTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirGoalTargetList.Create;
  result := FTargetList;
end;

function TFhirGoal.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

procedure TFhirGoal.SetStatusDate(value : TFhirDate);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirGoal.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirGoal.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDate.create;
  FStatusDate.value := value
end;

procedure TFhirGoal.SetStatusReason(value : TFhirString);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

function TFhirGoal.GetStatusReasonST : String;
begin
  if FStatusReason = nil then
    result := ''
  else
    result := FStatusReason.value;
end;

procedure TFhirGoal.SetStatusReasonST(value : String);
begin
  if value <> '' then
  begin
    if FStatusReason = nil then
      FStatusReason := TFhirString.create;
    FStatusReason.value := value
  end
  else if FStatusReason <> nil then
    FStatusReason.value := '';
end;

procedure TFhirGoal.SetExpressedBy(value : TFhirReference);
begin
  FExpressedBy.free;
  FExpressedBy := value;
end;

function TFhirGoal.GetAddressesList : TFhirReferenceList;
begin
  if FAddressesList = nil then
    FAddressesList := TFhirReferenceList.Create;
  result := FAddressesList;
end;

function TFhirGoal.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

function TFhirGoal.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirGoal.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirGoal.GetOutcomeCodeList : TFhirCodeableConceptList;
begin
  if FOutcomeCodeList = nil then
    FOutcomeCodeList := TFhirCodeableConceptList.Create;
  result := FOutcomeCodeList;
end;

function TFhirGoal.GetHasOutcomeCodeList : boolean;
begin
  result := (FOutcomeCodeList <> nil) and (FOutcomeCodeList.count > 0);
end;

function TFhirGoal.GetOutcomeReferenceList : TFhirReferenceList;
begin
  if FOutcomeReferenceList = nil then
    FOutcomeReferenceList := TFhirReferenceList.Create;
  result := FOutcomeReferenceList;
end;

function TFhirGoal.GetHasOutcomeReferenceList : boolean;
begin
  result := (FOutcomeReferenceList <> nil) and (FOutcomeReferenceList.count > 0);
end;

{ TFhirGoalListEnumerator }

constructor TFhirGoalListEnumerator.Create(list : TFhirGoalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGoalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGoalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGoalListEnumerator.GetCurrent : TFhirGoal;
begin
  Result := FList[FIndex];
end;

function TFhirGoalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGoalList }

function TFhirGoalList.AddItem(value: TFhirGoal): TFhirGoal;
begin
  assert(value.ClassName = 'TFhirGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGoal');
  add(value);
  result := value;
end;

function TFhirGoalList.Append: TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalList.ClearItems;
begin
  Clear;
end;

function TFhirGoalList.GetEnumerator : TFhirGoalListEnumerator;
begin
  result := TFhirGoalListEnumerator.Create(self.link);
end;

function TFhirGoalList.Clone: TFhirGoalList;
begin
  result := TFhirGoalList(inherited Clone);
end;

function TFhirGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGoalList.GetItemN(index: Integer): TFhirGoal;
begin
  result := TFhirGoal(ObjectByIndex[index]);
end;

function TFhirGoalList.ItemClass: TFslObjectClass;
begin
  result := TFhirGoal;
end;
function TFhirGoalList.IndexOf(value: TFhirGoal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGoalList.Insert(index: Integer): TFhirGoal;
begin
  result := TFhirGoal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGoalList.InsertItem(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  Inherited Insert(index, value);
end;

function TFhirGoalList.Item(index: Integer): TFhirGoal;
begin
  result := TFhirGoal(ObjectByIndex[index]);
end;

function TFhirGoalList.Link: TFhirGoalList;
begin
  result := TFhirGoalList(inherited Link);
end;

procedure TFhirGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGoalList.SetItemByIndex(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  FhirGoals[index] := value;
end;

procedure TFhirGoalList.SetItemN(index: Integer; value: TFhirGoal);
begin
  assert(value is TFhirGoal);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GOAL}
{$IFDEF FHIR_IMAGINGSTUDY}
{ TFhirImagingStudySeries }

constructor TFhirImagingStudySeries.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeries.Destroy;
begin
  FUid.free;
  FNumber.free;
  FModality.free;
  FDescription.free;
  FNumberOfInstances.free;
  FEndpointList.Free;
  FBodySite.free;
  FLaterality.free;
  FSpecimenList.Free;
  FStarted.free;
  FPerformerList.Free;
  FInstanceList.Free;
  inherited;
end;

procedure TFhirImagingStudySeries.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingStudySeries(oSource).uidElement.Clone;
  numberElement := TFhirImagingStudySeries(oSource).numberElement.Clone;
  modality := TFhirImagingStudySeries(oSource).modality.Clone;
  descriptionElement := TFhirImagingStudySeries(oSource).descriptionElement.Clone;
  numberOfInstancesElement := TFhirImagingStudySeries(oSource).numberOfInstancesElement.Clone;
  if (TFhirImagingStudySeries(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirImagingStudySeries(oSource).FEndpointList);
  end;
  bodySite := TFhirImagingStudySeries(oSource).bodySite.Clone;
  laterality := TFhirImagingStudySeries(oSource).laterality.Clone;
  if (TFhirImagingStudySeries(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList.Create;
    FSpecimenList.Assign(TFhirImagingStudySeries(oSource).FSpecimenList);
  end;
  startedElement := TFhirImagingStudySeries(oSource).startedElement.Clone;
  if (TFhirImagingStudySeries(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirImagingStudySeriesPerformerList.Create;
    FPerformerList.Assign(TFhirImagingStudySeries(oSource).FPerformerList);
  end;
  if (TFhirImagingStudySeries(oSource).FInstanceList = nil) then
  begin
    FInstanceList.free;
    FInstanceList := nil;
  end
  else
  begin
    if FInstanceList = nil then
      FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
    FInstanceList.Assign(TFhirImagingStudySeries(oSource).FInstanceList);
  end;
end;

procedure TFhirImagingStudySeries.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'modality') Then
     list.add(self.link, 'modality', FModality.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(self.link, 'numberOfInstances', FNumberOfInstances.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'laterality') Then
     list.add(self.link, 'laterality', FLaterality.Link);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'started') Then
     list.add(self.link, 'started', FStarted.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'instance') Then
    list.addAll(self, 'instance', FInstanceList);
end;

procedure TFhirImagingStudySeries.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'id', false, TFhirId, FUid.Link));
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', false, TFhirUnsignedInt, FNumber.Link));
  oList.add(TFHIRProperty.create(self, 'modality', 'Coding', false, TFhirCoding, FModality.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfInstances.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'Coding', false, TFhirCoding, FBodySite.Link));
  oList.add(TFHIRProperty.create(self, 'laterality', 'Coding', false, TFhirCoding, FLaterality.Link));
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', true, TFhirReference, FSpecimenList.Link));
  oList.add(TFHIRProperty.create(self, 'started', 'dateTime', false, TFhirDateTime, FStarted.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirImagingStudySeriesPerformer, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'instance', 'BackboneElement', true, TFhirImagingStudySeriesInstance, FInstanceList.Link));
end;

function TFhirImagingStudySeries.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'number') then
  begin
    NumberElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'modality') then
  begin
    Modality := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'numberOfInstances') then
  begin
    NumberOfInstancesElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'laterality') then
  begin
    Laterality := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'started') then
  begin
    StartedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirImagingStudySeriesPerformer);
    result := propValue;
  end
  else if (propName = 'instance') then
  begin
    InstanceList.add(propValue as TFhirImagingStudySeriesInstance);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeries.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirImagingStudySeriesPerformer)
  else if (propName = 'instance') then InstanceList.insertItem(index, propValue as TFhirImagingStudySeriesInstance)
  else inherited;
end;

function TFhirImagingStudySeries.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirId.create()
  else if (propName = 'number') then result := TFhirUnsignedInt.create()
  else if (propName = 'modality') then result := TFhirCoding.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'numberOfInstances') then result := TFhirUnsignedInt.create()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else if (propName = 'bodySite') then result := TFhirCoding.create()
  else if (propName = 'laterality') then result := TFhirCoding.create()
  else if (propName = 'specimen') then result := SpecimenList.new()
  else if (propName = 'started') then result := TFhirDateTime.create()
  else if (propName = 'performer') then result := PerformerList.new()
  else if (propName = 'instance') then result := InstanceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeries.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'id'
  else if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'modality') then result := 'Coding'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'numberOfInstances') then result := 'unsignedInt'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'Coding'
  else if (propName = 'laterality') then result := 'Coding'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'started') then result := 'dateTime'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'instance') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeries.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'number') then NumberElement := nil
  else if (propName = 'modality') then ModalityElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'laterality') then LateralityElement := nil
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value)
  else if (propName = 'started') then StartedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (propName = 'instance') then deletePropertyValue('instance', InstanceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeries.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asId(new)
  else if (propName = 'number') then NumberElement := asUnsignedInt(new)
  else if (propName = 'modality') then ModalityElement := new as TFhirCoding
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := asUnsignedInt(new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCoding
  else if (propName = 'laterality') then LateralityElement := new as TFhirCoding
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new)
  else if (propName = 'started') then StartedElement := asDateTime(new)
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (propName = 'instance') then replacePropertyValue('instance', InstanceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeries.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'endpoint') then EndpointList.move(source, destination)
  else if (propName = 'specimen') then SpecimenList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'instance') then InstanceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeries.fhirType : string;
begin
  result := 'ImagingStudy.series';
end;

function TFhirImagingStudySeries.Link : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Link);
end;

function TFhirImagingStudySeries.Clone : TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(inherited Clone);
end;

function TFhirImagingStudySeries.equals(other : TObject) : boolean; 
var
  o : TFhirImagingStudySeries;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeries)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeries(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(numberElement, o.numberElement, true) and 
      compareDeep(modalityElement, o.modalityElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(numberOfInstancesElement, o.numberOfInstancesElement, true) and compareDeep(endpointList, o.endpointList, true) and 
      compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(lateralityElement, o.lateralityElement, true) and 
      compareDeep(specimenList, o.specimenList, true) and compareDeep(startedElement, o.startedElement, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(instanceList, o.instanceList, true);
  end;
end;

function TFhirImagingStudySeries.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FNumber) and isEmptyProp(FModality) and isEmptyProp(FDescription) and isEmptyProp(FNumberOfInstances) and isEmptyProp(FendpointList) and isEmptyProp(FBodySite) and isEmptyProp(FLaterality) and isEmptyProp(FspecimenList) and isEmptyProp(FStarted) and isEmptyProp(FperformerList) and isEmptyProp(FinstanceList);
end;

procedure TFhirImagingStudySeries.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('uid');
  fields.add('number');
  fields.add('modality');
  fields.add('description');
  fields.add('numberOfInstances');
  fields.add('endpoint');
  fields.add('bodySite');
  fields.add('laterality');
  fields.add('specimen');
  fields.add('started');
  fields.add('performer');
  fields.add('instance');
end;

function TFhirImagingStudySeries.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FEndpointList.sizeInBytes(magic));
  inc(result, FSpecimenList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FInstanceList.sizeInBytes(magic));
end;

procedure TFhirImagingStudySeries.SetUid(value : TFhirId);
begin
  FUid.free;
  FUid := value;
end;

function TFhirImagingStudySeries.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

procedure TFhirImagingStudySeries.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirId.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

procedure TFhirImagingStudySeries.SetNumber(value : TFhirUnsignedInt);
begin
  FNumber.free;
  FNumber := value;
end;

function TFhirImagingStudySeries.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

procedure TFhirImagingStudySeries.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirUnsignedInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

procedure TFhirImagingStudySeries.SetModality(value : TFhirCoding);
begin
  FModality.free;
  FModality := value;
end;

procedure TFhirImagingStudySeries.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirImagingStudySeries.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImagingStudySeries.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirImagingStudySeries.SetNumberOfInstances(value : TFhirUnsignedInt);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value;
end;

function TFhirImagingStudySeries.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := FNumberOfInstances.value;
end;

procedure TFhirImagingStudySeries.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirUnsignedInt.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

function TFhirImagingStudySeries.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirImagingStudySeries.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirImagingStudySeries.SetBodySite(value : TFhirCoding);
begin
  FBodySite.free;
  FBodySite := value;
end;

procedure TFhirImagingStudySeries.SetLaterality(value : TFhirCoding);
begin
  FLaterality.free;
  FLaterality := value;
end;

function TFhirImagingStudySeries.GetSpecimenList : TFhirReferenceList;
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList.Create;
  result := FSpecimenList;
end;

function TFhirImagingStudySeries.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

procedure TFhirImagingStudySeries.SetStarted(value : TFhirDateTime);
begin
  FStarted.free;
  FStarted := value;
end;

function TFhirImagingStudySeries.GetStartedST : TFslDateTime;
begin
  if FStarted = nil then
    result := TFslDateTime.makeNull
  else
    result := FStarted.value;
end;

procedure TFhirImagingStudySeries.SetStartedST(value : TFslDateTime);
begin
  if FStarted = nil then
    FStarted := TFhirDateTime.create;
  FStarted.value := value
end;

function TFhirImagingStudySeries.GetPerformerList : TFhirImagingStudySeriesPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirImagingStudySeriesPerformerList.Create;
  result := FPerformerList;
end;

function TFhirImagingStudySeries.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirImagingStudySeries.GetInstanceList : TFhirImagingStudySeriesInstanceList;
begin
  if FInstanceList = nil then
    FInstanceList := TFhirImagingStudySeriesInstanceList.Create;
  result := FInstanceList;
end;

function TFhirImagingStudySeries.GetHasInstanceList : boolean;
begin
  result := (FInstanceList <> nil) and (FInstanceList.count > 0);
end;

{ TFhirImagingStudySeriesListEnumerator }

constructor TFhirImagingStudySeriesListEnumerator.Create(list : TFhirImagingStudySeriesList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesListEnumerator.GetCurrent : TFhirImagingStudySeries;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImagingStudySeriesList }

function TFhirImagingStudySeriesList.AddItem(value: TFhirImagingStudySeries): TFhirImagingStudySeries;
begin
  assert(value.ClassName = 'TFhirImagingStudySeries', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeries');
  add(value);
  result := value;
end;

function TFhirImagingStudySeriesList.Append: TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesList.GetEnumerator : TFhirImagingStudySeriesListEnumerator;
begin
  result := TFhirImagingStudySeriesListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesList.Clone: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Clone);
end;

function TFhirImagingStudySeriesList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesList.GetItemN(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeries;
end;
function TFhirImagingStudySeriesList.IndexOf(value: TFhirImagingStudySeries): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesList.Insert(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesList.InsertItem(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesList.Item(index: Integer): TFhirImagingStudySeries;
begin
  result := TFhirImagingStudySeries(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesList.Link: TFhirImagingStudySeriesList;
begin
  result := TFhirImagingStudySeriesList(inherited Link);
end;

procedure TFhirImagingStudySeriesList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  FhirImagingStudySeries[index] := value;
end;

procedure TFhirImagingStudySeriesList.SetItemN(index: Integer; value: TFhirImagingStudySeries);
begin
  assert(value is TFhirImagingStudySeries);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeriesPerformer }

constructor TFhirImagingStudySeriesPerformer.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeriesPerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirImagingStudySeriesPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirImagingStudySeriesPerformer(oSource).function_.Clone;
  actor := TFhirImagingStudySeriesPerformer(oSource).actor.Clone;
end;

procedure TFhirImagingStudySeriesPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirImagingStudySeriesPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
end;

function TFhirImagingStudySeriesPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeriesPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImagingStudySeriesPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create()
  else if (propName = 'actor') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeriesPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeriesPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeriesPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeriesPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeriesPerformer.fhirType : string;
begin
  result := 'ImagingStudy.series.performer';
end;

function TFhirImagingStudySeriesPerformer.Link : TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer(inherited Link);
end;

function TFhirImagingStudySeriesPerformer.Clone : TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer(inherited Clone);
end;

function TFhirImagingStudySeriesPerformer.equals(other : TObject) : boolean; 
var
  o : TFhirImagingStudySeriesPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeriesPerformer)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeriesPerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirImagingStudySeriesPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirImagingStudySeriesPerformer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirImagingStudySeriesPerformer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImagingStudySeriesPerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

procedure TFhirImagingStudySeriesPerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

{ TFhirImagingStudySeriesPerformerListEnumerator }

constructor TFhirImagingStudySeriesPerformerListEnumerator.Create(list : TFhirImagingStudySeriesPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesPerformerListEnumerator.GetCurrent : TFhirImagingStudySeriesPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesPerformerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImagingStudySeriesPerformerList }

function TFhirImagingStudySeriesPerformerList.AddItem(value: TFhirImagingStudySeriesPerformer): TFhirImagingStudySeriesPerformer;
begin
  assert(value.ClassName = 'TFhirImagingStudySeriesPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeriesPerformer');
  add(value);
  result := value;
end;

function TFhirImagingStudySeriesPerformerList.Append: TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesPerformerList.GetEnumerator : TFhirImagingStudySeriesPerformerListEnumerator;
begin
  result := TFhirImagingStudySeriesPerformerListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesPerformerList.Clone: TFhirImagingStudySeriesPerformerList;
begin
  result := TFhirImagingStudySeriesPerformerList(inherited Clone);
end;

function TFhirImagingStudySeriesPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesPerformerList.GetItemN(index: Integer): TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeriesPerformer;
end;
function TFhirImagingStudySeriesPerformerList.IndexOf(value: TFhirImagingStudySeriesPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesPerformerList.Insert(index: Integer): TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesPerformerList.InsertItem(index: Integer; value: TFhirImagingStudySeriesPerformer);
begin
  assert(value is TFhirImagingStudySeriesPerformer);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesPerformerList.Item(index: Integer): TFhirImagingStudySeriesPerformer;
begin
  result := TFhirImagingStudySeriesPerformer(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesPerformerList.Link: TFhirImagingStudySeriesPerformerList;
begin
  result := TFhirImagingStudySeriesPerformerList(inherited Link);
end;

procedure TFhirImagingStudySeriesPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesPerformerList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeriesPerformer);
begin
  assert(value is TFhirImagingStudySeriesPerformer);
  FhirImagingStudySeriesPerformers[index] := value;
end;

procedure TFhirImagingStudySeriesPerformerList.SetItemN(index: Integer; value: TFhirImagingStudySeriesPerformer);
begin
  assert(value is TFhirImagingStudySeriesPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudySeriesInstance }

constructor TFhirImagingStudySeriesInstance.Create;
begin
  inherited;
end;

destructor TFhirImagingStudySeriesInstance.Destroy;
begin
  FUid.free;
  FSopClass.free;
  FNumber.free;
  FTitle.free;
  inherited;
end;

procedure TFhirImagingStudySeriesInstance.Assign(oSource : TFslObject);
begin
  inherited;
  uidElement := TFhirImagingStudySeriesInstance(oSource).uidElement.Clone;
  sopClass := TFhirImagingStudySeriesInstance(oSource).sopClass.Clone;
  numberElement := TFhirImagingStudySeriesInstance(oSource).numberElement.Clone;
  titleElement := TFhirImagingStudySeriesInstance(oSource).titleElement.Clone;
end;

procedure TFhirImagingStudySeriesInstance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'uid') Then
     list.add(self.link, 'uid', FUid.Link);
  if (child_name = 'sopClass') Then
     list.add(self.link, 'sopClass', FSopClass.Link);
  if (child_name = 'number') Then
     list.add(self.link, 'number', FNumber.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
end;

procedure TFhirImagingStudySeriesInstance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'uid', 'id', false, TFhirId, FUid.Link));
  oList.add(TFHIRProperty.create(self, 'sopClass', 'Coding', false, TFhirCoding, FSopClass.Link));
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', false, TFhirUnsignedInt, FNumber.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
end;

function TFhirImagingStudySeriesInstance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'uid') then
  begin
    UidElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'sopClass') then
  begin
    SopClass := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'number') then
  begin
    NumberElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudySeriesInstance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImagingStudySeriesInstance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'uid') then result := TFhirId.create()
  else if (propName = 'sopClass') then result := TFhirCoding.create()
  else if (propName = 'number') then result := TFhirUnsignedInt.create()
  else if (propName = 'title') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudySeriesInstance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'uid') then result := 'id'
  else if (propName = 'sopClass') then result := 'Coding'
  else if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'title') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudySeriesInstance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := nil
  else if (propName = 'sopClass') then SopClassElement := nil
  else if (propName = 'number') then NumberElement := nil
  else if (propName = 'title') then TitleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudySeriesInstance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'uid') then UidElement := asId(new)
  else if (propName = 'sopClass') then SopClassElement := new as TFhirCoding
  else if (propName = 'number') then NumberElement := asUnsignedInt(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudySeriesInstance.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudySeriesInstance.fhirType : string;
begin
  result := 'ImagingStudy.series.instance';
end;

function TFhirImagingStudySeriesInstance.Link : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Link);
end;

function TFhirImagingStudySeriesInstance.Clone : TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(inherited Clone);
end;

function TFhirImagingStudySeriesInstance.equals(other : TObject) : boolean; 
var
  o : TFhirImagingStudySeriesInstance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudySeriesInstance)) then
    result := false
  else
  begin
    o := TFhirImagingStudySeriesInstance(other);
    result := compareDeep(uidElement, o.uidElement, true) and compareDeep(sopClassElement, o.sopClassElement, true) and 
      compareDeep(numberElement, o.numberElement, true) and compareDeep(titleElement, o.titleElement, true);
  end;
end;

function TFhirImagingStudySeriesInstance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUid) and isEmptyProp(FSopClass) and isEmptyProp(FNumber) and isEmptyProp(FTitle);
end;

procedure TFhirImagingStudySeriesInstance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('uid');
  fields.add('sopClass');
  fields.add('number');
  fields.add('title');
end;

function TFhirImagingStudySeriesInstance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImagingStudySeriesInstance.SetUid(value : TFhirId);
begin
  FUid.free;
  FUid := value;
end;

function TFhirImagingStudySeriesInstance.GetUidST : String;
begin
  if FUid = nil then
    result := ''
  else
    result := FUid.value;
end;

procedure TFhirImagingStudySeriesInstance.SetUidST(value : String);
begin
  if value <> '' then
  begin
    if FUid = nil then
      FUid := TFhirId.create;
    FUid.value := value
  end
  else if FUid <> nil then
    FUid.value := '';
end;

procedure TFhirImagingStudySeriesInstance.SetSopClass(value : TFhirCoding);
begin
  FSopClass.free;
  FSopClass := value;
end;

procedure TFhirImagingStudySeriesInstance.SetNumber(value : TFhirUnsignedInt);
begin
  FNumber.free;
  FNumber := value;
end;

function TFhirImagingStudySeriesInstance.GetNumberST : String;
begin
  if FNumber = nil then
    result := ''
  else
    result := FNumber.value;
end;

procedure TFhirImagingStudySeriesInstance.SetNumberST(value : String);
begin
  if value <> '' then
  begin
    if FNumber = nil then
      FNumber := TFhirUnsignedInt.create;
    FNumber.value := value
  end
  else if FNumber <> nil then
    FNumber.value := '';
end;

procedure TFhirImagingStudySeriesInstance.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirImagingStudySeriesInstance.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirImagingStudySeriesInstance.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

{ TFhirImagingStudySeriesInstanceListEnumerator }

constructor TFhirImagingStudySeriesInstanceListEnumerator.Create(list : TFhirImagingStudySeriesInstanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudySeriesInstanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudySeriesInstanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudySeriesInstanceListEnumerator.GetCurrent : TFhirImagingStudySeriesInstance;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudySeriesInstanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImagingStudySeriesInstanceList }

function TFhirImagingStudySeriesInstanceList.AddItem(value: TFhirImagingStudySeriesInstance): TFhirImagingStudySeriesInstance;
begin
  assert(value.ClassName = 'TFhirImagingStudySeriesInstance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudySeriesInstance');
  add(value);
  result := value;
end;

function TFhirImagingStudySeriesInstanceList.Append: TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesInstanceList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudySeriesInstanceList.GetEnumerator : TFhirImagingStudySeriesInstanceListEnumerator;
begin
  result := TFhirImagingStudySeriesInstanceListEnumerator.Create(self.link);
end;

function TFhirImagingStudySeriesInstanceList.Clone: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Clone);
end;

function TFhirImagingStudySeriesInstanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudySeriesInstanceList.GetItemN(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudySeriesInstance;
end;
function TFhirImagingStudySeriesInstanceList.IndexOf(value: TFhirImagingStudySeriesInstance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudySeriesInstanceList.Insert(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudySeriesInstanceList.InsertItem(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  Inherited Insert(index, value);
end;

function TFhirImagingStudySeriesInstanceList.Item(index: Integer): TFhirImagingStudySeriesInstance;
begin
  result := TFhirImagingStudySeriesInstance(ObjectByIndex[index]);
end;

function TFhirImagingStudySeriesInstanceList.Link: TFhirImagingStudySeriesInstanceList;
begin
  result := TFhirImagingStudySeriesInstanceList(inherited Link);
end;

procedure TFhirImagingStudySeriesInstanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemByIndex(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  FhirImagingStudySeriesInstances[index] := value;
end;

procedure TFhirImagingStudySeriesInstanceList.SetItemN(index: Integer; value: TFhirImagingStudySeriesInstance);
begin
  assert(value is TFhirImagingStudySeriesInstance);
  ObjectByIndex[index] := value;
end;

{ TFhirImagingStudy }

constructor TFhirImagingStudy.Create;
begin
  inherited;
end;

destructor TFhirImagingStudy.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FModalityList.Free;
  FSubject.free;
  FEncounter.free;
  FStarted.free;
  FBasedOnList.Free;
  FReferrer.free;
  FInterpreterList.Free;
  FEndpointList.Free;
  FNumberOfSeries.free;
  FNumberOfInstances.free;
  FProcedureReference.free;
  FProcedureCodeList.Free;
  FLocation.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FDescription.free;
  FSeriesList.Free;
  inherited;
end;

procedure TFhirImagingStudy.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImagingStudy(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImagingStudy(oSource).FIdentifierList);
  end;
  statusElement := TFhirImagingStudy(oSource).statusElement.Clone;
  if (TFhirImagingStudy(oSource).FModalityList = nil) then
  begin
    FModalityList.free;
    FModalityList := nil;
  end
  else
  begin
    if FModalityList = nil then
      FModalityList := TFhirCodingList.Create;
    FModalityList.Assign(TFhirImagingStudy(oSource).FModalityList);
  end;
  subject := TFhirImagingStudy(oSource).subject.Clone;
  encounter := TFhirImagingStudy(oSource).encounter.Clone;
  startedElement := TFhirImagingStudy(oSource).startedElement.Clone;
  if (TFhirImagingStudy(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirImagingStudy(oSource).FBasedOnList);
  end;
  referrer := TFhirImagingStudy(oSource).referrer.Clone;
  if (TFhirImagingStudy(oSource).FInterpreterList = nil) then
  begin
    FInterpreterList.free;
    FInterpreterList := nil;
  end
  else
  begin
    if FInterpreterList = nil then
      FInterpreterList := TFhirReferenceList.Create;
    FInterpreterList.Assign(TFhirImagingStudy(oSource).FInterpreterList);
  end;
  if (TFhirImagingStudy(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirImagingStudy(oSource).FEndpointList);
  end;
  numberOfSeriesElement := TFhirImagingStudy(oSource).numberOfSeriesElement.Clone;
  numberOfInstancesElement := TFhirImagingStudy(oSource).numberOfInstancesElement.Clone;
  procedureReference := TFhirImagingStudy(oSource).procedureReference.Clone;
  if (TFhirImagingStudy(oSource).FProcedureCodeList = nil) then
  begin
    FProcedureCodeList.free;
    FProcedureCodeList := nil;
  end
  else
  begin
    if FProcedureCodeList = nil then
      FProcedureCodeList := TFhirCodeableConceptList.Create;
    FProcedureCodeList.Assign(TFhirImagingStudy(oSource).FProcedureCodeList);
  end;
  location := TFhirImagingStudy(oSource).location.Clone;
  if (TFhirImagingStudy(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirImagingStudy(oSource).FReasonCodeList);
  end;
  if (TFhirImagingStudy(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirImagingStudy(oSource).FReasonReferenceList);
  end;
  if (TFhirImagingStudy(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirImagingStudy(oSource).FNoteList);
  end;
  descriptionElement := TFhirImagingStudy(oSource).descriptionElement.Clone;
  if (TFhirImagingStudy(oSource).FSeriesList = nil) then
  begin
    FSeriesList.free;
    FSeriesList := nil;
  end
  else
  begin
    if FSeriesList = nil then
      FSeriesList := TFhirImagingStudySeriesList.Create;
    FSeriesList.Assign(TFhirImagingStudy(oSource).FSeriesList);
  end;
end;

function TFhirImagingStudy.GetResourceType : TFhirResourceType;
begin
  result := frtImagingStudy;
end;

procedure TFhirImagingStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'modality') Then
    list.addAll(self, 'modality', FModalityList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'started') Then
     list.add(self.link, 'started', FStarted.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'referrer') Then
     list.add(self.link, 'referrer', FReferrer.Link);
  if (child_name = 'interpreter') Then
    list.addAll(self, 'interpreter', FInterpreterList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
  if (child_name = 'numberOfSeries') Then
     list.add(self.link, 'numberOfSeries', FNumberOfSeries.Link);
  if (child_name = 'numberOfInstances') Then
     list.add(self.link, 'numberOfInstances', FNumberOfInstances.Link);
  if (child_name = 'procedureReference') Then
     list.add(self.link, 'procedureReference', FProcedureReference.Link);
  if (child_name = 'procedureCode') Then
    list.addAll(self, 'procedureCode', FProcedureCodeList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'series') Then
    list.addAll(self, 'series', FSeriesList);
end;

procedure TFhirImagingStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'modality', 'Coding', true, TFhirCoding, FModalityList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'started', 'dateTime', false, TFhirDateTime, FStarted.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'referrer', 'Reference', false, TFhirReference, FReferrer.Link));
  oList.add(TFHIRProperty.create(self, 'interpreter', 'Reference', true, TFhirReference, FInterpreterList.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfSeries', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfSeries.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfInstances', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfInstances.Link));
  oList.add(TFHIRProperty.create(self, 'procedureReference', 'Reference', false, TFhirReference, FProcedureReference.Link));
  oList.add(TFHIRProperty.create(self, 'procedureCode', 'CodeableConcept', true, TFhirCodeableConcept, FProcedureCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'series', 'BackboneElement', true, TFhirImagingStudySeries, FSeriesList.Link));
end;

function TFhirImagingStudy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirImagingStudyStatusEnum, CODES_TFhirImagingStudyStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'modality') then
  begin
    ModalityList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'started') then
  begin
    StartedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'referrer') then
  begin
    Referrer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'interpreter') then
  begin
    InterpreterList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'numberOfSeries') then
  begin
    NumberOfSeriesElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'numberOfInstances') then
  begin
    NumberOfInstancesElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'procedureReference') then
  begin
    ProcedureReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'procedureCode') then
  begin
    ProcedureCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesList.add(propValue as TFhirImagingStudySeries);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImagingStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'modality') then ModalityList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'interpreter') then InterpreterList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'procedureCode') then ProcedureCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'series') then SeriesList.insertItem(index, propValue as TFhirImagingStudySeries)
  else inherited;
end;

function TFhirImagingStudy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirImagingStudyStatusEnum[ImagingStudyStatusNull], CODES_TFhirImagingStudyStatusEnum[ImagingStudyStatusNull]) 
  else if (propName = 'modality') then result := ModalityList.new()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'started') then result := TFhirDateTime.create()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'referrer') then result := TFhirReference.create()
  else if (propName = 'interpreter') then result := InterpreterList.new()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else if (propName = 'numberOfSeries') then result := TFhirUnsignedInt.create()
  else if (propName = 'numberOfInstances') then result := TFhirUnsignedInt.create()
  else if (propName = 'procedureReference') then result := TFhirReference.create()
  else if (propName = 'procedureCode') then result := ProcedureCodeList.new()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'series') then result := SeriesList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImagingStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'modality') then result := 'Coding'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'started') then result := 'dateTime'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'referrer') then result := 'Reference'
  else if (propName = 'interpreter') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'Reference'
  else if (propName = 'numberOfSeries') then result := 'unsignedInt'
  else if (propName = 'numberOfInstances') then result := 'unsignedInt'
  else if (propName = 'procedureReference') then result := 'Reference'
  else if (propName = 'procedureCode') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'series') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImagingStudy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'modality') then deletePropertyValue('modality', ModalityList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'started') then StartedElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'referrer') then ReferrerElement := nil
  else if (propName = 'interpreter') then deletePropertyValue('interpreter', InterpreterList, value)
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else if (propName = 'numberOfSeries') then NumberOfSeriesElement := nil
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := nil
  else if (propName = 'procedureReference') then ProcedureReferenceElement := nil
  else if (propName = 'procedureCode') then deletePropertyValue('procedureCode', ProcedureCodeList, value)
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'series') then deletePropertyValue('series', SeriesList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImagingStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirImagingStudyStatusEnum, CODES_TFhirImagingStudyStatusEnum, new)
  else if (propName = 'modality') then replacePropertyValue('modality', ModalityList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'started') then StartedElement := asDateTime(new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'referrer') then ReferrerElement := new as TFhirReference
  else if (propName = 'interpreter') then replacePropertyValue('interpreter', InterpreterList, existing, new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else if (propName = 'numberOfSeries') then NumberOfSeriesElement := asUnsignedInt(new)
  else if (propName = 'numberOfInstances') then NumberOfInstancesElement := asUnsignedInt(new)
  else if (propName = 'procedureReference') then ProcedureReferenceElement := new as TFhirReference
  else if (propName = 'procedureCode') then replacePropertyValue('procedureCode', ProcedureCodeList, existing, new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'series') then replacePropertyValue('series', SeriesList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImagingStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'modality') then ModalityList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'interpreter') then InterpreterList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else if (propName = 'procedureCode') then ProcedureCodeList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'series') then SeriesList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImagingStudy.fhirType : string;
begin
  result := 'ImagingStudy';
end;

function TFhirImagingStudy.Link : TFhirImagingStudy;
begin
  result := TFhirImagingStudy(inherited Link);
end;

function TFhirImagingStudy.Clone : TFhirImagingStudy;
begin
  result := TFhirImagingStudy(inherited Clone);
end;

function TFhirImagingStudy.equals(other : TObject) : boolean; 
var
  o : TFhirImagingStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImagingStudy)) then
    result := false
  else
  begin
    o := TFhirImagingStudy(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(modalityList, o.modalityList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(startedElement, o.startedElement, true) and 
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(referrerElement, o.referrerElement, true) and 
      compareDeep(interpreterList, o.interpreterList, true) and compareDeep(endpointList, o.endpointList, true) and 
      compareDeep(numberOfSeriesElement, o.numberOfSeriesElement, true) and compareDeep(numberOfInstancesElement, o.numberOfInstancesElement, true) and 
      compareDeep(procedureReferenceElement, o.procedureReferenceElement, true) and 
      compareDeep(procedureCodeList, o.procedureCodeList, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(seriesList, o.seriesList, true);
  end;
end;

function TFhirImagingStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FmodalityList) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FStarted) and isEmptyProp(FbasedOnList) and isEmptyProp(FReferrer) and isEmptyProp(FinterpreterList) and isEmptyProp(FendpointList) and isEmptyProp(FNumberOfSeries) and isEmptyProp(FNumberOfInstances) and isEmptyProp(FProcedureReference) and isEmptyProp(FprocedureCodeList) and isEmptyProp(FLocation) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FDescription) and isEmptyProp(FseriesList);
end;

procedure TFhirImagingStudy.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('modality');
  fields.add('subject');
  fields.add('encounter');
  fields.add('started');
  fields.add('basedOn');
  fields.add('referrer');
  fields.add('interpreter');
  fields.add('endpoint');
  fields.add('numberOfSeries');
  fields.add('numberOfInstances');
  fields.add('procedureReference');
  fields.add('procedureCode');
  fields.add('location');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('description');
  fields.add('series');
end;

function TFhirImagingStudy.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FModalityList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FInterpreterList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
  inc(result, FProcedureCodeList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSeriesList.sizeInBytes(magic));
end;

function TFhirImagingStudy.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirImagingStudy.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirImagingStudy.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirImagingStudy.GetStatusST : TFhirImagingStudyStatusEnum;
begin
  if FStatus = nil then
    result := TFhirImagingStudyStatusEnum(0)
  else
    result := TFhirImagingStudyStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirImagingStudyStatusEnum, FStatus.value));
end;

procedure TFhirImagingStudy.SetStatusST(value : TFhirImagingStudyStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirImagingStudyStatusEnum[value], CODES_TFhirImagingStudyStatusEnum[value]);
end;

function TFhirImagingStudy.GetModalityList : TFhirCodingList;
begin
  if FModalityList = nil then
    FModalityList := TFhirCodingList.Create;
  result := FModalityList;
end;

function TFhirImagingStudy.GetHasModalityList : boolean;
begin
  result := (FModalityList <> nil) and (FModalityList.count > 0);
end;

procedure TFhirImagingStudy.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirImagingStudy.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirImagingStudy.SetStarted(value : TFhirDateTime);
begin
  FStarted.free;
  FStarted := value;
end;

function TFhirImagingStudy.GetStartedST : TFslDateTime;
begin
  if FStarted = nil then
    result := TFslDateTime.makeNull
  else
    result := FStarted.value;
end;

procedure TFhirImagingStudy.SetStartedST(value : TFslDateTime);
begin
  if FStarted = nil then
    FStarted := TFhirDateTime.create;
  FStarted.value := value
end;

function TFhirImagingStudy.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirImagingStudy.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirImagingStudy.SetReferrer(value : TFhirReference);
begin
  FReferrer.free;
  FReferrer := value;
end;

function TFhirImagingStudy.GetInterpreterList : TFhirReferenceList;
begin
  if FInterpreterList = nil then
    FInterpreterList := TFhirReferenceList.Create;
  result := FInterpreterList;
end;

function TFhirImagingStudy.GetHasInterpreterList : boolean;
begin
  result := (FInterpreterList <> nil) and (FInterpreterList.count > 0);
end;

function TFhirImagingStudy.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirImagingStudy.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

procedure TFhirImagingStudy.SetNumberOfSeries(value : TFhirUnsignedInt);
begin
  FNumberOfSeries.free;
  FNumberOfSeries := value;
end;

function TFhirImagingStudy.GetNumberOfSeriesST : String;
begin
  if FNumberOfSeries = nil then
    result := ''
  else
    result := FNumberOfSeries.value;
end;

procedure TFhirImagingStudy.SetNumberOfSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfSeries = nil then
      FNumberOfSeries := TFhirUnsignedInt.create;
    FNumberOfSeries.value := value
  end
  else if FNumberOfSeries <> nil then
    FNumberOfSeries.value := '';
end;

procedure TFhirImagingStudy.SetNumberOfInstances(value : TFhirUnsignedInt);
begin
  FNumberOfInstances.free;
  FNumberOfInstances := value;
end;

function TFhirImagingStudy.GetNumberOfInstancesST : String;
begin
  if FNumberOfInstances = nil then
    result := ''
  else
    result := FNumberOfInstances.value;
end;

procedure TFhirImagingStudy.SetNumberOfInstancesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfInstances = nil then
      FNumberOfInstances := TFhirUnsignedInt.create;
    FNumberOfInstances.value := value
  end
  else if FNumberOfInstances <> nil then
    FNumberOfInstances.value := '';
end;

procedure TFhirImagingStudy.SetProcedureReference(value : TFhirReference);
begin
  FProcedureReference.free;
  FProcedureReference := value;
end;

function TFhirImagingStudy.GetProcedureCodeList : TFhirCodeableConceptList;
begin
  if FProcedureCodeList = nil then
    FProcedureCodeList := TFhirCodeableConceptList.Create;
  result := FProcedureCodeList;
end;

function TFhirImagingStudy.GetHasProcedureCodeList : boolean;
begin
  result := (FProcedureCodeList <> nil) and (FProcedureCodeList.count > 0);
end;

procedure TFhirImagingStudy.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirImagingStudy.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirImagingStudy.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirImagingStudy.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirImagingStudy.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirImagingStudy.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirImagingStudy.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirImagingStudy.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirImagingStudy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImagingStudy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirImagingStudy.GetSeriesList : TFhirImagingStudySeriesList;
begin
  if FSeriesList = nil then
    FSeriesList := TFhirImagingStudySeriesList.Create;
  result := FSeriesList;
end;

function TFhirImagingStudy.GetHasSeriesList : boolean;
begin
  result := (FSeriesList <> nil) and (FSeriesList.count > 0);
end;

{ TFhirImagingStudyListEnumerator }

constructor TFhirImagingStudyListEnumerator.Create(list : TFhirImagingStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImagingStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImagingStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImagingStudyListEnumerator.GetCurrent : TFhirImagingStudy;
begin
  Result := FList[FIndex];
end;

function TFhirImagingStudyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImagingStudyList }

function TFhirImagingStudyList.AddItem(value: TFhirImagingStudy): TFhirImagingStudy;
begin
  assert(value.ClassName = 'TFhirImagingStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImagingStudy');
  add(value);
  result := value;
end;

function TFhirImagingStudyList.Append: TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyList.ClearItems;
begin
  Clear;
end;

function TFhirImagingStudyList.GetEnumerator : TFhirImagingStudyListEnumerator;
begin
  result := TFhirImagingStudyListEnumerator.Create(self.link);
end;

function TFhirImagingStudyList.Clone: TFhirImagingStudyList;
begin
  result := TFhirImagingStudyList(inherited Clone);
end;

function TFhirImagingStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImagingStudyList.GetItemN(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy(ObjectByIndex[index]);
end;

function TFhirImagingStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirImagingStudy;
end;
function TFhirImagingStudyList.IndexOf(value: TFhirImagingStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImagingStudyList.Insert(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImagingStudyList.InsertItem(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  Inherited Insert(index, value);
end;

function TFhirImagingStudyList.Item(index: Integer): TFhirImagingStudy;
begin
  result := TFhirImagingStudy(ObjectByIndex[index]);
end;

function TFhirImagingStudyList.Link: TFhirImagingStudyList;
begin
  result := TFhirImagingStudyList(inherited Link);
end;

procedure TFhirImagingStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImagingStudyList.SetItemByIndex(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  FhirImagingStudies[index] := value;
end;

procedure TFhirImagingStudyList.SetItemN(index: Integer; value: TFhirImagingStudy);
begin
  assert(value is TFhirImagingStudy);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMAGINGSTUDY}
{$IFDEF FHIR_IMMUNIZATION}
{ TFhirImmunizationPerformer }

constructor TFhirImmunizationPerformer.Create;
begin
  inherited;
end;

destructor TFhirImmunizationPerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirImmunizationPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirImmunizationPerformer(oSource).function_.Clone;
  actor := TFhirImmunizationPerformer(oSource).actor.Clone;
end;

procedure TFhirImmunizationPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirImmunizationPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
end;

function TFhirImmunizationPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create()
  else if (propName = 'actor') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationPerformer.fhirType : string;
begin
  result := 'Immunization.performer';
end;

function TFhirImmunizationPerformer.Link : TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer(inherited Link);
end;

function TFhirImmunizationPerformer.Clone : TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer(inherited Clone);
end;

function TFhirImmunizationPerformer.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationPerformer)) then
    result := false
  else
  begin
    o := TFhirImmunizationPerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirImmunizationPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirImmunizationPerformer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirImmunizationPerformer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImmunizationPerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

procedure TFhirImmunizationPerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

{ TFhirImmunizationPerformerListEnumerator }

constructor TFhirImmunizationPerformerListEnumerator.Create(list : TFhirImmunizationPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationPerformerListEnumerator.GetCurrent : TFhirImmunizationPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationPerformerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImmunizationPerformerList }

function TFhirImmunizationPerformerList.AddItem(value: TFhirImmunizationPerformer): TFhirImmunizationPerformer;
begin
  assert(value.ClassName = 'TFhirImmunizationPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationPerformer');
  add(value);
  result := value;
end;

function TFhirImmunizationPerformerList.Append: TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationPerformerList.GetEnumerator : TFhirImmunizationPerformerListEnumerator;
begin
  result := TFhirImmunizationPerformerListEnumerator.Create(self.link);
end;

function TFhirImmunizationPerformerList.Clone: TFhirImmunizationPerformerList;
begin
  result := TFhirImmunizationPerformerList(inherited Clone);
end;

function TFhirImmunizationPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationPerformerList.GetItemN(index: Integer): TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer(ObjectByIndex[index]);
end;

function TFhirImmunizationPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationPerformer;
end;
function TFhirImmunizationPerformerList.IndexOf(value: TFhirImmunizationPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationPerformerList.Insert(index: Integer): TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationPerformerList.InsertItem(index: Integer; value: TFhirImmunizationPerformer);
begin
  assert(value is TFhirImmunizationPerformer);
  Inherited Insert(index, value);
end;

function TFhirImmunizationPerformerList.Item(index: Integer): TFhirImmunizationPerformer;
begin
  result := TFhirImmunizationPerformer(ObjectByIndex[index]);
end;

function TFhirImmunizationPerformerList.Link: TFhirImmunizationPerformerList;
begin
  result := TFhirImmunizationPerformerList(inherited Link);
end;

procedure TFhirImmunizationPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationPerformerList.SetItemByIndex(index: Integer; value: TFhirImmunizationPerformer);
begin
  assert(value is TFhirImmunizationPerformer);
  FhirImmunizationPerformers[index] := value;
end;

procedure TFhirImmunizationPerformerList.SetItemN(index: Integer; value: TFhirImmunizationPerformer);
begin
  assert(value is TFhirImmunizationPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationEducation }

constructor TFhirImmunizationEducation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationEducation.Destroy;
begin
  FDocumentType.free;
  FReference.free;
  FPublicationDate.free;
  FPresentationDate.free;
  inherited;
end;

procedure TFhirImmunizationEducation.Assign(oSource : TFslObject);
begin
  inherited;
  documentTypeElement := TFhirImmunizationEducation(oSource).documentTypeElement.Clone;
  referenceElement := TFhirImmunizationEducation(oSource).referenceElement.Clone;
  publicationDateElement := TFhirImmunizationEducation(oSource).publicationDateElement.Clone;
  presentationDateElement := TFhirImmunizationEducation(oSource).presentationDateElement.Clone;
end;

procedure TFhirImmunizationEducation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'documentType') Then
     list.add(self.link, 'documentType', FDocumentType.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'publicationDate') Then
     list.add(self.link, 'publicationDate', FPublicationDate.Link);
  if (child_name = 'presentationDate') Then
     list.add(self.link, 'presentationDate', FPresentationDate.Link);
end;

procedure TFhirImmunizationEducation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'documentType', 'string', false, TFhirString, FDocumentType.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'uri', false, TFhirUri, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'publicationDate', 'dateTime', false, TFhirDateTime, FPublicationDate.Link));
  oList.add(TFHIRProperty.create(self, 'presentationDate', 'dateTime', false, TFhirDateTime, FPresentationDate.Link));
end;

function TFhirImmunizationEducation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'documentType') then
  begin
    DocumentTypeElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    ReferenceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'publicationDate') then
  begin
    PublicationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'presentationDate') then
  begin
    PresentationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationEducation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationEducation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'documentType') then result := TFhirString.create()
  else if (propName = 'reference') then result := TFhirUri.create()
  else if (propName = 'publicationDate') then result := TFhirDateTime.create()
  else if (propName = 'presentationDate') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationEducation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'documentType') then result := 'string'
  else if (propName = 'reference') then result := 'uri'
  else if (propName = 'publicationDate') then result := 'dateTime'
  else if (propName = 'presentationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationEducation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'documentType') then DocumentTypeElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'publicationDate') then PublicationDateElement := nil
  else if (propName = 'presentationDate') then PresentationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationEducation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'documentType') then DocumentTypeElement := asString(new)
  else if (propName = 'reference') then ReferenceElement := asUri(new)
  else if (propName = 'publicationDate') then PublicationDateElement := asDateTime(new)
  else if (propName = 'presentationDate') then PresentationDateElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationEducation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationEducation.fhirType : string;
begin
  result := 'Immunization.education';
end;

function TFhirImmunizationEducation.Link : TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation(inherited Link);
end;

function TFhirImmunizationEducation.Clone : TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation(inherited Clone);
end;

function TFhirImmunizationEducation.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationEducation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationEducation)) then
    result := false
  else
  begin
    o := TFhirImmunizationEducation(other);
    result := compareDeep(documentTypeElement, o.documentTypeElement, true) and 
      compareDeep(referenceElement, o.referenceElement, true) and compareDeep(publicationDateElement, o.publicationDateElement, true) and 
      compareDeep(presentationDateElement, o.presentationDateElement, true);
  end;
end;

function TFhirImmunizationEducation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDocumentType) and isEmptyProp(FReference) and isEmptyProp(FPublicationDate) and isEmptyProp(FPresentationDate);
end;

procedure TFhirImmunizationEducation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('documentType');
  fields.add('reference');
  fields.add('publicationDate');
  fields.add('presentationDate');
end;

function TFhirImmunizationEducation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImmunizationEducation.SetDocumentType(value : TFhirString);
begin
  FDocumentType.free;
  FDocumentType := value;
end;

function TFhirImmunizationEducation.GetDocumentTypeST : String;
begin
  if FDocumentType = nil then
    result := ''
  else
    result := FDocumentType.value;
end;

procedure TFhirImmunizationEducation.SetDocumentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FDocumentType = nil then
      FDocumentType := TFhirString.create;
    FDocumentType.value := value
  end
  else if FDocumentType <> nil then
    FDocumentType.value := '';
end;

procedure TFhirImmunizationEducation.SetReference(value : TFhirUri);
begin
  FReference.free;
  FReference := value;
end;

function TFhirImmunizationEducation.GetReferenceST : String;
begin
  if FReference = nil then
    result := ''
  else
    result := FReference.value;
end;

procedure TFhirImmunizationEducation.SetReferenceST(value : String);
begin
  if value <> '' then
  begin
    if FReference = nil then
      FReference := TFhirUri.create;
    FReference.value := value
  end
  else if FReference <> nil then
    FReference.value := '';
end;

procedure TFhirImmunizationEducation.SetPublicationDate(value : TFhirDateTime);
begin
  FPublicationDate.free;
  FPublicationDate := value;
end;

function TFhirImmunizationEducation.GetPublicationDateST : TFslDateTime;
begin
  if FPublicationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPublicationDate.value;
end;

procedure TFhirImmunizationEducation.SetPublicationDateST(value : TFslDateTime);
begin
  if FPublicationDate = nil then
    FPublicationDate := TFhirDateTime.create;
  FPublicationDate.value := value
end;

procedure TFhirImmunizationEducation.SetPresentationDate(value : TFhirDateTime);
begin
  FPresentationDate.free;
  FPresentationDate := value;
end;

function TFhirImmunizationEducation.GetPresentationDateST : TFslDateTime;
begin
  if FPresentationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPresentationDate.value;
end;

procedure TFhirImmunizationEducation.SetPresentationDateST(value : TFslDateTime);
begin
  if FPresentationDate = nil then
    FPresentationDate := TFhirDateTime.create;
  FPresentationDate.value := value
end;

{ TFhirImmunizationEducationListEnumerator }

constructor TFhirImmunizationEducationListEnumerator.Create(list : TFhirImmunizationEducationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationEducationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationEducationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationEducationListEnumerator.GetCurrent : TFhirImmunizationEducation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationEducationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImmunizationEducationList }

function TFhirImmunizationEducationList.AddItem(value: TFhirImmunizationEducation): TFhirImmunizationEducation;
begin
  assert(value.ClassName = 'TFhirImmunizationEducation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationEducation');
  add(value);
  result := value;
end;

function TFhirImmunizationEducationList.Append: TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationEducationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationEducationList.GetEnumerator : TFhirImmunizationEducationListEnumerator;
begin
  result := TFhirImmunizationEducationListEnumerator.Create(self.link);
end;

function TFhirImmunizationEducationList.Clone: TFhirImmunizationEducationList;
begin
  result := TFhirImmunizationEducationList(inherited Clone);
end;

function TFhirImmunizationEducationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationEducationList.GetItemN(index: Integer): TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation(ObjectByIndex[index]);
end;

function TFhirImmunizationEducationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationEducation;
end;
function TFhirImmunizationEducationList.IndexOf(value: TFhirImmunizationEducation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationEducationList.Insert(index: Integer): TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationEducationList.InsertItem(index: Integer; value: TFhirImmunizationEducation);
begin
  assert(value is TFhirImmunizationEducation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationEducationList.Item(index: Integer): TFhirImmunizationEducation;
begin
  result := TFhirImmunizationEducation(ObjectByIndex[index]);
end;

function TFhirImmunizationEducationList.Link: TFhirImmunizationEducationList;
begin
  result := TFhirImmunizationEducationList(inherited Link);
end;

procedure TFhirImmunizationEducationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationEducationList.SetItemByIndex(index: Integer; value: TFhirImmunizationEducation);
begin
  assert(value is TFhirImmunizationEducation);
  FhirImmunizationEducations[index] := value;
end;

procedure TFhirImmunizationEducationList.SetItemN(index: Integer; value: TFhirImmunizationEducation);
begin
  assert(value is TFhirImmunizationEducation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationReaction }

constructor TFhirImmunizationReaction.Create;
begin
  inherited;
end;

destructor TFhirImmunizationReaction.Destroy;
begin
  FDate.free;
  FDetail.free;
  FReported.free;
  inherited;
end;

procedure TFhirImmunizationReaction.Assign(oSource : TFslObject);
begin
  inherited;
  dateElement := TFhirImmunizationReaction(oSource).dateElement.Clone;
  detail := TFhirImmunizationReaction(oSource).detail.Clone;
  reportedElement := TFhirImmunizationReaction(oSource).reportedElement.Clone;
end;

procedure TFhirImmunizationReaction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
  if (child_name = 'reported') Then
     list.add(self.link, 'reported', FReported.Link);
end;

procedure TFhirImmunizationReaction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'Reference', false, TFhirReference, FDetail.Link));
  oList.add(TFHIRProperty.create(self, 'reported', 'boolean', false, TFhirBoolean, FReported.Link));
end;

function TFhirImmunizationReaction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    Detail := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reported') then
  begin
    ReportedElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationReaction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationReaction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'detail') then result := TFhirReference.create()
  else if (propName = 'reported') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationReaction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'date') then result := 'dateTime'
  else if (propName = 'detail') then result := 'Reference'
  else if (propName = 'reported') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationReaction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'date') then DateElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else if (propName = 'reported') then ReportedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationReaction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'detail') then DetailElement := new as TFhirReference
  else if (propName = 'reported') then ReportedElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationReaction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationReaction.fhirType : string;
begin
  result := 'Immunization.reaction';
end;

function TFhirImmunizationReaction.Link : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Link);
end;

function TFhirImmunizationReaction.Clone : TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(inherited Clone);
end;

function TFhirImmunizationReaction.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationReaction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationReaction)) then
    result := false
  else
  begin
    o := TFhirImmunizationReaction(other);
    result := compareDeep(dateElement, o.dateElement, true) and compareDeep(detailElement, o.detailElement, true) and 
      compareDeep(reportedElement, o.reportedElement, true);
  end;
end;

function TFhirImmunizationReaction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDate) and isEmptyProp(FDetail) and isEmptyProp(FReported);
end;

procedure TFhirImmunizationReaction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('date');
  fields.add('detail');
  fields.add('reported');
end;

function TFhirImmunizationReaction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImmunizationReaction.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirImmunizationReaction.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirImmunizationReaction.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirImmunizationReaction.SetDetail(value : TFhirReference);
begin
  FDetail.free;
  FDetail := value;
end;

procedure TFhirImmunizationReaction.SetReported(value : TFhirBoolean);
begin
  FReported.free;
  FReported := value;
end;

function TFhirImmunizationReaction.GetReportedST : Boolean;
begin
  if FReported = nil then
    result := false
  else
    result := FReported.value;
end;

procedure TFhirImmunizationReaction.SetReportedST(value : Boolean);
begin
  if FReported = nil then
    FReported := TFhirBoolean.create;
  FReported.value := value
end;

{ TFhirImmunizationReactionListEnumerator }

constructor TFhirImmunizationReactionListEnumerator.Create(list : TFhirImmunizationReactionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationReactionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationReactionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationReactionListEnumerator.GetCurrent : TFhirImmunizationReaction;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationReactionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImmunizationReactionList }

function TFhirImmunizationReactionList.AddItem(value: TFhirImmunizationReaction): TFhirImmunizationReaction;
begin
  assert(value.ClassName = 'TFhirImmunizationReaction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationReaction');
  add(value);
  result := value;
end;

function TFhirImmunizationReactionList.Append: TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationReactionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationReactionList.GetEnumerator : TFhirImmunizationReactionListEnumerator;
begin
  result := TFhirImmunizationReactionListEnumerator.Create(self.link);
end;

function TFhirImmunizationReactionList.Clone: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Clone);
end;

function TFhirImmunizationReactionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationReactionList.GetItemN(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationReaction;
end;
function TFhirImmunizationReactionList.IndexOf(value: TFhirImmunizationReaction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationReactionList.Insert(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationReactionList.InsertItem(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  Inherited Insert(index, value);
end;

function TFhirImmunizationReactionList.Item(index: Integer): TFhirImmunizationReaction;
begin
  result := TFhirImmunizationReaction(ObjectByIndex[index]);
end;

function TFhirImmunizationReactionList.Link: TFhirImmunizationReactionList;
begin
  result := TFhirImmunizationReactionList(inherited Link);
end;

procedure TFhirImmunizationReactionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationReactionList.SetItemByIndex(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  FhirImmunizationReactions[index] := value;
end;

procedure TFhirImmunizationReactionList.SetItemN(index: Integer; value: TFhirImmunizationReaction);
begin
  assert(value is TFhirImmunizationReaction);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationProtocolApplied }

constructor TFhirImmunizationProtocolApplied.Create;
begin
  inherited;
end;

destructor TFhirImmunizationProtocolApplied.Destroy;
begin
  FSeries.free;
  FAuthority.free;
  FTargetDiseaseList.Free;
  FDoseNumber.free;
  FSeriesDoses.free;
  inherited;
end;

procedure TFhirImmunizationProtocolApplied.Assign(oSource : TFslObject);
begin
  inherited;
  seriesElement := TFhirImmunizationProtocolApplied(oSource).seriesElement.Clone;
  authority := TFhirImmunizationProtocolApplied(oSource).authority.Clone;
  if (TFhirImmunizationProtocolApplied(oSource).FTargetDiseaseList = nil) then
  begin
    FTargetDiseaseList.free;
    FTargetDiseaseList := nil;
  end
  else
  begin
    if FTargetDiseaseList = nil then
      FTargetDiseaseList := TFhirCodeableConceptList.Create;
    FTargetDiseaseList.Assign(TFhirImmunizationProtocolApplied(oSource).FTargetDiseaseList);
  end;
  doseNumber := TFhirImmunizationProtocolApplied(oSource).doseNumber.Clone;
  seriesDoses := TFhirImmunizationProtocolApplied(oSource).seriesDoses.Clone;
end;

procedure TFhirImmunizationProtocolApplied.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'targetDisease') Then
    list.addAll(self, 'targetDisease', FTargetDiseaseList);
  if (child_name = 'doseNumber[x]') or (child_name = 'doseNumber') Then
     list.add(self.link, 'doseNumber[x]', FDoseNumber.Link);
  if (child_name = 'seriesDoses[x]') or (child_name = 'seriesDoses') Then
     list.add(self.link, 'seriesDoses[x]', FSeriesDoses.Link);
end;

procedure TFhirImmunizationProtocolApplied.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link));
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference', false, TFhirReference, FAuthority.Link));
  oList.add(TFHIRProperty.create(self, 'targetDisease', 'CodeableConcept', true, TFhirCodeableConcept, FTargetDiseaseList.Link));
  oList.add(TFHIRProperty.create(self, 'doseNumber[x]', 'positiveInt|string', false, TFhirDataType, FDoseNumber.Link));
  oList.add(TFHIRProperty.create(self, 'seriesDoses[x]', 'positiveInt|string', false, TFhirDataType, FSeriesDoses.Link));
end;

function TFhirImmunizationProtocolApplied.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'series') then
  begin
    SeriesElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'targetDisease') then
  begin
    TargetDiseaseList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then
  begin
    DoseNumber := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then
  begin
    SeriesDoses := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationProtocolApplied.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'targetDisease') then TargetDiseaseList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirImmunizationProtocolApplied.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'series') then result := TFhirString.create()
  else if (propName = 'authority') then result := TFhirReference.create()
  else if (propName = 'targetDisease') then result := TargetDiseaseList.new()
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then raise EFHIRException.create('Cannot make property DoseNumber')
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then raise EFHIRException.create('Cannot make property SeriesDoses')
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationProtocolApplied.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'series') then result := 'string'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'targetDisease') then result := 'CodeableConcept'
  else if (propName = 'doseNumber[x]') then result := 'positiveInt|string'
  else if (propName = 'seriesDoses[x]') then result := 'positiveInt|string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationProtocolApplied.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'series') then SeriesElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'targetDisease') then deletePropertyValue('targetDisease', TargetDiseaseList, value)
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then DoseNumberElement := nil
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then SeriesDosesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationProtocolApplied.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'series') then SeriesElement := asString(new)
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference
  else if (propName = 'targetDisease') then replacePropertyValue('targetDisease', TargetDiseaseList, existing, new)
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then DoseNumberElement := new as TFhirDataType
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then SeriesDosesElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationProtocolApplied.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'targetDisease') then TargetDiseaseList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationProtocolApplied.fhirType : string;
begin
  result := 'Immunization.protocolApplied';
end;

function TFhirImmunizationProtocolApplied.Link : TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied(inherited Link);
end;

function TFhirImmunizationProtocolApplied.Clone : TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied(inherited Clone);
end;

function TFhirImmunizationProtocolApplied.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationProtocolApplied;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationProtocolApplied)) then
    result := false
  else
  begin
    o := TFhirImmunizationProtocolApplied(other);
    result := compareDeep(seriesElement, o.seriesElement, true) and compareDeep(authorityElement, o.authorityElement, true) and 
      compareDeep(targetDiseaseList, o.targetDiseaseList, true) and compareDeep(doseNumberElement, o.doseNumberElement, true) and 
      compareDeep(seriesDosesElement, o.seriesDosesElement, true);
  end;
end;

function TFhirImmunizationProtocolApplied.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSeries) and isEmptyProp(FAuthority) and isEmptyProp(FtargetDiseaseList) and isEmptyProp(FDoseNumber) and isEmptyProp(FSeriesDoses);
end;

procedure TFhirImmunizationProtocolApplied.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('series');
  fields.add('authority');
  fields.add('targetDisease');
  fields.add('doseNumber[x]');
  fields.add('seriesDoses[x]');
end;

function TFhirImmunizationProtocolApplied.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetDiseaseList.sizeInBytes(magic));
end;

procedure TFhirImmunizationProtocolApplied.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

function TFhirImmunizationProtocolApplied.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

procedure TFhirImmunizationProtocolApplied.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

procedure TFhirImmunizationProtocolApplied.SetAuthority(value : TFhirReference);
begin
  FAuthority.free;
  FAuthority := value;
end;

function TFhirImmunizationProtocolApplied.GetTargetDiseaseList : TFhirCodeableConceptList;
begin
  if FTargetDiseaseList = nil then
    FTargetDiseaseList := TFhirCodeableConceptList.Create;
  result := FTargetDiseaseList;
end;

function TFhirImmunizationProtocolApplied.GetHasTargetDiseaseList : boolean;
begin
  result := (FTargetDiseaseList <> nil) and (FTargetDiseaseList.count > 0);
end;

procedure TFhirImmunizationProtocolApplied.SetDoseNumber(value : TFhirDataType);
begin
  FDoseNumber.free;
  FDoseNumber := value;
end;

procedure TFhirImmunizationProtocolApplied.SetSeriesDoses(value : TFhirDataType);
begin
  FSeriesDoses.free;
  FSeriesDoses := value;
end;

{ TFhirImmunizationProtocolAppliedListEnumerator }

constructor TFhirImmunizationProtocolAppliedListEnumerator.Create(list : TFhirImmunizationProtocolAppliedList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationProtocolAppliedListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationProtocolAppliedListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationProtocolAppliedListEnumerator.GetCurrent : TFhirImmunizationProtocolApplied;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationProtocolAppliedListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImmunizationProtocolAppliedList }

function TFhirImmunizationProtocolAppliedList.AddItem(value: TFhirImmunizationProtocolApplied): TFhirImmunizationProtocolApplied;
begin
  assert(value.ClassName = 'TFhirImmunizationProtocolApplied', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationProtocolApplied');
  add(value);
  result := value;
end;

function TFhirImmunizationProtocolAppliedList.Append: TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationProtocolAppliedList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationProtocolAppliedList.GetEnumerator : TFhirImmunizationProtocolAppliedListEnumerator;
begin
  result := TFhirImmunizationProtocolAppliedListEnumerator.Create(self.link);
end;

function TFhirImmunizationProtocolAppliedList.Clone: TFhirImmunizationProtocolAppliedList;
begin
  result := TFhirImmunizationProtocolAppliedList(inherited Clone);
end;

function TFhirImmunizationProtocolAppliedList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationProtocolAppliedList.GetItemN(index: Integer): TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied(ObjectByIndex[index]);
end;

function TFhirImmunizationProtocolAppliedList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationProtocolApplied;
end;
function TFhirImmunizationProtocolAppliedList.IndexOf(value: TFhirImmunizationProtocolApplied): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationProtocolAppliedList.Insert(index: Integer): TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationProtocolAppliedList.InsertItem(index: Integer; value: TFhirImmunizationProtocolApplied);
begin
  assert(value is TFhirImmunizationProtocolApplied);
  Inherited Insert(index, value);
end;

function TFhirImmunizationProtocolAppliedList.Item(index: Integer): TFhirImmunizationProtocolApplied;
begin
  result := TFhirImmunizationProtocolApplied(ObjectByIndex[index]);
end;

function TFhirImmunizationProtocolAppliedList.Link: TFhirImmunizationProtocolAppliedList;
begin
  result := TFhirImmunizationProtocolAppliedList(inherited Link);
end;

procedure TFhirImmunizationProtocolAppliedList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationProtocolAppliedList.SetItemByIndex(index: Integer; value: TFhirImmunizationProtocolApplied);
begin
  assert(value is TFhirImmunizationProtocolApplied);
  FhirImmunizationProtocolApplieds[index] := value;
end;

procedure TFhirImmunizationProtocolAppliedList.SetItemN(index: Integer; value: TFhirImmunizationProtocolApplied);
begin
  assert(value is TFhirImmunizationProtocolApplied);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunization }

constructor TFhirImmunization.Create;
begin
  inherited;
end;

destructor TFhirImmunization.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FStatusReason.free;
  FVaccineCode.free;
  FPatient.free;
  FEncounter.free;
  FOccurrence.free;
  FRecorded.free;
  FPrimarySource.free;
  FReportOrigin.free;
  FLocation.free;
  FManufacturer.free;
  FLotNumber.free;
  FExpirationDate.free;
  FSite.free;
  FRoute.free;
  FDoseQuantity.free;
  FPerformerList.Free;
  FNoteList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FIsSubpotent.free;
  FSubpotentReasonList.Free;
  FEducationList.Free;
  FProgramEligibilityList.Free;
  FFundingSource.free;
  FReactionList.Free;
  FProtocolAppliedList.Free;
  inherited;
end;

procedure TFhirImmunization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunization(oSource).FIdentifierList);
  end;
  statusElement := TFhirImmunization(oSource).statusElement.Clone;
  statusReason := TFhirImmunization(oSource).statusReason.Clone;
  vaccineCode := TFhirImmunization(oSource).vaccineCode.Clone;
  patient := TFhirImmunization(oSource).patient.Clone;
  encounter := TFhirImmunization(oSource).encounter.Clone;
  occurrence := TFhirImmunization(oSource).occurrence.Clone;
  recordedElement := TFhirImmunization(oSource).recordedElement.Clone;
  primarySourceElement := TFhirImmunization(oSource).primarySourceElement.Clone;
  reportOrigin := TFhirImmunization(oSource).reportOrigin.Clone;
  location := TFhirImmunization(oSource).location.Clone;
  manufacturer := TFhirImmunization(oSource).manufacturer.Clone;
  lotNumberElement := TFhirImmunization(oSource).lotNumberElement.Clone;
  expirationDateElement := TFhirImmunization(oSource).expirationDateElement.Clone;
  site := TFhirImmunization(oSource).site.Clone;
  route := TFhirImmunization(oSource).route.Clone;
  doseQuantity := TFhirImmunization(oSource).doseQuantity.Clone;
  if (TFhirImmunization(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirImmunizationPerformerList.Create;
    FPerformerList.Assign(TFhirImmunization(oSource).FPerformerList);
  end;
  if (TFhirImmunization(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirImmunization(oSource).FNoteList);
  end;
  if (TFhirImmunization(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirImmunization(oSource).FReasonCodeList);
  end;
  if (TFhirImmunization(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirImmunization(oSource).FReasonReferenceList);
  end;
  isSubpotentElement := TFhirImmunization(oSource).isSubpotentElement.Clone;
  if (TFhirImmunization(oSource).FSubpotentReasonList = nil) then
  begin
    FSubpotentReasonList.free;
    FSubpotentReasonList := nil;
  end
  else
  begin
    if FSubpotentReasonList = nil then
      FSubpotentReasonList := TFhirCodeableConceptList.Create;
    FSubpotentReasonList.Assign(TFhirImmunization(oSource).FSubpotentReasonList);
  end;
  if (TFhirImmunization(oSource).FEducationList = nil) then
  begin
    FEducationList.free;
    FEducationList := nil;
  end
  else
  begin
    if FEducationList = nil then
      FEducationList := TFhirImmunizationEducationList.Create;
    FEducationList.Assign(TFhirImmunization(oSource).FEducationList);
  end;
  if (TFhirImmunization(oSource).FProgramEligibilityList = nil) then
  begin
    FProgramEligibilityList.free;
    FProgramEligibilityList := nil;
  end
  else
  begin
    if FProgramEligibilityList = nil then
      FProgramEligibilityList := TFhirCodeableConceptList.Create;
    FProgramEligibilityList.Assign(TFhirImmunization(oSource).FProgramEligibilityList);
  end;
  fundingSource := TFhirImmunization(oSource).fundingSource.Clone;
  if (TFhirImmunization(oSource).FReactionList = nil) then
  begin
    FReactionList.free;
    FReactionList := nil;
  end
  else
  begin
    if FReactionList = nil then
      FReactionList := TFhirImmunizationReactionList.Create;
    FReactionList.Assign(TFhirImmunization(oSource).FReactionList);
  end;
  if (TFhirImmunization(oSource).FProtocolAppliedList = nil) then
  begin
    FProtocolAppliedList.free;
    FProtocolAppliedList := nil;
  end
  else
  begin
    if FProtocolAppliedList = nil then
      FProtocolAppliedList := TFhirImmunizationProtocolAppliedList.Create;
    FProtocolAppliedList.Assign(TFhirImmunization(oSource).FProtocolAppliedList);
  end;
end;

function TFhirImmunization.GetResourceType : TFhirResourceType;
begin
  result := frtImmunization;
end;

procedure TFhirImmunization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'vaccineCode') Then
     list.add(self.link, 'vaccineCode', FVaccineCode.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'primarySource') Then
     list.add(self.link, 'primarySource', FPrimarySource.Link);
  if (child_name = 'reportOrigin') Then
     list.add(self.link, 'reportOrigin', FReportOrigin.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'doseQuantity') Then
     list.add(self.link, 'doseQuantity', FDoseQuantity.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'isSubpotent') Then
     list.add(self.link, 'isSubpotent', FIsSubpotent.Link);
  if (child_name = 'subpotentReason') Then
    list.addAll(self, 'subpotentReason', FSubpotentReasonList);
  if (child_name = 'education') Then
    list.addAll(self, 'education', FEducationList);
  if (child_name = 'programEligibility') Then
    list.addAll(self, 'programEligibility', FProgramEligibilityList);
  if (child_name = 'fundingSource') Then
     list.add(self.link, 'fundingSource', FFundingSource.Link);
  if (child_name = 'reaction') Then
    list.addAll(self, 'reaction', FReactionList);
  if (child_name = 'protocolApplied') Then
    list.addAll(self, 'protocolApplied', FProtocolAppliedList);
end;

procedure TFhirImmunization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'vaccineCode', 'CodeableConcept', false, TFhirCodeableConcept, FVaccineCode.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|string', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'recorded', 'dateTime', false, TFhirDateTime, FRecorded.Link));
  oList.add(TFHIRProperty.create(self, 'primarySource', 'boolean', false, TFhirBoolean, FPrimarySource.Link));
  oList.add(TFHIRProperty.create(self, 'reportOrigin', 'CodeableConcept', false, TFhirCodeableConcept, FReportOrigin.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'manufacturer', 'Reference', false, TFhirReference, FManufacturer.Link));
  oList.add(TFHIRProperty.create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));
  oList.add(TFHIRProperty.create(self, 'expirationDate', 'date', false, TFhirDate, FExpirationDate.Link));
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', false, TFhirCodeableConcept, FSite.Link));
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));
  oList.add(TFHIRProperty.create(self, 'doseQuantity', 'Quantity', false, TFhirQuantity, FDoseQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirImmunizationPerformer, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'isSubpotent', 'boolean', false, TFhirBoolean, FIsSubpotent.Link));
  oList.add(TFHIRProperty.create(self, 'subpotentReason', 'CodeableConcept', true, TFhirCodeableConcept, FSubpotentReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'education', 'BackboneElement', true, TFhirImmunizationEducation, FEducationList.Link));
  oList.add(TFHIRProperty.create(self, 'programEligibility', 'CodeableConcept', true, TFhirCodeableConcept, FProgramEligibilityList.Link));
  oList.add(TFHIRProperty.create(self, 'fundingSource', 'CodeableConcept', false, TFhirCodeableConcept, FFundingSource.Link));
  oList.add(TFHIRProperty.create(self, 'reaction', 'BackboneElement', true, TFhirImmunizationReaction, FReactionList.Link));
  oList.add(TFHIRProperty.create(self, 'protocolApplied', 'BackboneElement', true, TFhirImmunizationProtocolApplied, FProtocolAppliedList.Link));
end;

function TFhirImmunization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirImmunizationStatusCodesEnum, CODES_TFhirImmunizationStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'vaccineCode') then
  begin
    VaccineCode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'String'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'primarySource') then
  begin
    PrimarySourceElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'reportOrigin') then
  begin
    ReportOrigin := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    Manufacturer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    Site := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'doseQuantity') then
  begin
    DoseQuantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirImmunizationPerformer);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'isSubpotent') then
  begin
    IsSubpotentElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'subpotentReason') then
  begin
    SubpotentReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'education') then
  begin
    EducationList.add(propValue as TFhirImmunizationEducation);
    result := propValue;
  end
  else if (propName = 'programEligibility') then
  begin
    ProgramEligibilityList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'fundingSource') then
  begin
    FundingSource := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reaction') then
  begin
    ReactionList.add(propValue as TFhirImmunizationReaction);
    result := propValue;
  end
  else if (propName = 'protocolApplied') then
  begin
    ProtocolAppliedList.add(propValue as TFhirImmunizationProtocolApplied);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirImmunizationPerformer)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'subpotentReason') then SubpotentReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'education') then EducationList.insertItem(index, propValue as TFhirImmunizationEducation)
  else if (propName = 'programEligibility') then ProgramEligibilityList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reaction') then ReactionList.insertItem(index, propValue as TFhirImmunizationReaction)
  else if (propName = 'protocolApplied') then ProtocolAppliedList.insertItem(index, propValue as TFhirImmunizationProtocolApplied)
  else inherited;
end;

function TFhirImmunization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirImmunizationStatusCodesEnum[ImmunizationStatusCodesNull], CODES_TFhirImmunizationStatusCodesEnum[ImmunizationStatusCodesNull]) 
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'vaccineCode') then result := TFhirCodeableConcept.create()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'String'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (propName = 'recorded') then result := TFhirDateTime.create()
  else if (propName = 'primarySource') then result := TFhirBoolean.create()
  else if (propName = 'reportOrigin') then result := TFhirCodeableConcept.create()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'manufacturer') then result := TFhirReference.create()
  else if (propName = 'lotNumber') then result := TFhirString.create()
  else if (propName = 'expirationDate') then result := TFhirDate.create()
  else if (propName = 'site') then result := TFhirCodeableConcept.create()
  else if (propName = 'route') then result := TFhirCodeableConcept.create()
  else if (propName = 'doseQuantity') then result := TFhirQuantity.create()
  else if (propName = 'performer') then result := PerformerList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'isSubpotent') then result := TFhirBoolean.create()
  else if (propName = 'subpotentReason') then result := SubpotentReasonList.new()
  else if (propName = 'education') then result := EducationList.new()
  else if (propName = 'programEligibility') then result := ProgramEligibilityList.new()
  else if (propName = 'fundingSource') then result := TFhirCodeableConcept.create()
  else if (propName = 'reaction') then result := ReactionList.new()
  else if (propName = 'protocolApplied') then result := ProtocolAppliedList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'vaccineCode') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|string'
  else if (propName = 'recorded') then result := 'dateTime'
  else if (propName = 'primarySource') then result := 'boolean'
  else if (propName = 'reportOrigin') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'manufacturer') then result := 'Reference'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'expirationDate') then result := 'date'
  else if (propName = 'site') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'doseQuantity') then result := 'Quantity'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'isSubpotent') then result := 'boolean'
  else if (propName = 'subpotentReason') then result := 'CodeableConcept'
  else if (propName = 'education') then result := 'BackboneElement'
  else if (propName = 'programEligibility') then result := 'CodeableConcept'
  else if (propName = 'fundingSource') then result := 'CodeableConcept'
  else if (propName = 'reaction') then result := 'BackboneElement'
  else if (propName = 'protocolApplied') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'vaccineCode') then VaccineCodeElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'String'])) then OccurrenceElement := nil
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'primarySource') then PrimarySourceElement := nil
  else if (propName = 'reportOrigin') then ReportOriginElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else if (propName = 'site') then SiteElement := nil
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'doseQuantity') then DoseQuantityElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'isSubpotent') then IsSubpotentElement := nil
  else if (propName = 'subpotentReason') then deletePropertyValue('subpotentReason', SubpotentReasonList, value)
  else if (propName = 'education') then deletePropertyValue('education', EducationList, value)
  else if (propName = 'programEligibility') then deletePropertyValue('programEligibility', ProgramEligibilityList, value)
  else if (propName = 'fundingSource') then FundingSourceElement := nil
  else if (propName = 'reaction') then deletePropertyValue('reaction', ReactionList, value)
  else if (propName = 'protocolApplied') then deletePropertyValue('protocolApplied', ProtocolAppliedList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirImmunizationStatusCodesEnum, CODES_TFhirImmunizationStatusCodesEnum, new)
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept
  else if (propName = 'vaccineCode') then VaccineCodeElement := new as TFhirCodeableConcept
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'String'])) then OccurrenceElement := new as TFhirDataType
  else if (propName = 'recorded') then RecordedElement := asDateTime(new)
  else if (propName = 'primarySource') then PrimarySourceElement := asBoolean(new)
  else if (propName = 'reportOrigin') then ReportOriginElement := new as TFhirCodeableConcept
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'manufacturer') then ManufacturerElement := new as TFhirReference
  else if (propName = 'lotNumber') then LotNumberElement := asString(new)
  else if (propName = 'expirationDate') then ExpirationDateElement := asDate(new)
  else if (propName = 'site') then SiteElement := new as TFhirCodeableConcept
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept
  else if (propName = 'doseQuantity') then DoseQuantityElement := new as TFhirQuantity
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'isSubpotent') then IsSubpotentElement := asBoolean(new)
  else if (propName = 'subpotentReason') then replacePropertyValue('subpotentReason', SubpotentReasonList, existing, new)
  else if (propName = 'education') then replacePropertyValue('education', EducationList, existing, new)
  else if (propName = 'programEligibility') then replacePropertyValue('programEligibility', ProgramEligibilityList, existing, new)
  else if (propName = 'fundingSource') then FundingSourceElement := new as TFhirCodeableConcept
  else if (propName = 'reaction') then replacePropertyValue('reaction', ReactionList, existing, new)
  else if (propName = 'protocolApplied') then replacePropertyValue('protocolApplied', ProtocolAppliedList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'subpotentReason') then SubpotentReasonList.move(source, destination)
  else if (propName = 'education') then EducationList.move(source, destination)
  else if (propName = 'programEligibility') then ProgramEligibilityList.move(source, destination)
  else if (propName = 'reaction') then ReactionList.move(source, destination)
  else if (propName = 'protocolApplied') then ProtocolAppliedList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunization.fhirType : string;
begin
  result := 'Immunization';
end;

function TFhirImmunization.Link : TFhirImmunization;
begin
  result := TFhirImmunization(inherited Link);
end;

function TFhirImmunization.Clone : TFhirImmunization;
begin
  result := TFhirImmunization(inherited Clone);
end;

function TFhirImmunization.equals(other : TObject) : boolean; 
var
  o : TFhirImmunization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunization)) then
    result := false
  else
  begin
    o := TFhirImmunization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(vaccineCodeElement, o.vaccineCodeElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(recordedElement, o.recordedElement, true) and 
      compareDeep(primarySourceElement, o.primarySourceElement, true) and compareDeep(reportOriginElement, o.reportOriginElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(manufacturerElement, o.manufacturerElement, true) and 
      compareDeep(lotNumberElement, o.lotNumberElement, true) and compareDeep(expirationDateElement, o.expirationDateElement, true) and 
      compareDeep(siteElement, o.siteElement, true) and compareDeep(routeElement, o.routeElement, true) and 
      compareDeep(doseQuantityElement, o.doseQuantityElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(isSubpotentElement, o.isSubpotentElement, true) and 
      compareDeep(subpotentReasonList, o.subpotentReasonList, true) and compareDeep(educationList, o.educationList, true) and 
      compareDeep(programEligibilityList, o.programEligibilityList, true) and compareDeep(fundingSourceElement, o.fundingSourceElement, true) and 
      compareDeep(reactionList, o.reactionList, true) and compareDeep(protocolAppliedList, o.protocolAppliedList, true);
  end;
end;

function TFhirImmunization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FVaccineCode) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FRecorded) and isEmptyProp(FPrimarySource) and isEmptyProp(FReportOrigin) and isEmptyProp(FLocation) and isEmptyProp(FManufacturer) and isEmptyProp(FLotNumber) and isEmptyProp(FExpirationDate) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FDoseQuantity) and isEmptyProp(FperformerList) and isEmptyProp(FnoteList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FIsSubpotent) and isEmptyProp(FsubpotentReasonList) and isEmptyProp(FeducationList) and isEmptyProp(FprogramEligibilityList) and isEmptyProp(FFundingSource) and isEmptyProp(FreactionList) and isEmptyProp(FprotocolAppliedList);
end;

procedure TFhirImmunization.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('vaccineCode');
  fields.add('patient');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('recorded');
  fields.add('primarySource');
  fields.add('reportOrigin');
  fields.add('location');
  fields.add('manufacturer');
  fields.add('lotNumber');
  fields.add('expirationDate');
  fields.add('site');
  fields.add('route');
  fields.add('doseQuantity');
  fields.add('performer');
  fields.add('note');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('isSubpotent');
  fields.add('subpotentReason');
  fields.add('education');
  fields.add('programEligibility');
  fields.add('fundingSource');
  fields.add('reaction');
  fields.add('protocolApplied');
end;

function TFhirImmunization.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FSubpotentReasonList.sizeInBytes(magic));
  inc(result, FEducationList.sizeInBytes(magic));
  inc(result, FProgramEligibilityList.sizeInBytes(magic));
  inc(result, FReactionList.sizeInBytes(magic));
  inc(result, FProtocolAppliedList.sizeInBytes(magic));
end;

function TFhirImmunization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirImmunization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirImmunization.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirImmunization.GetStatusST : TFhirImmunizationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirImmunizationStatusCodesEnum(0)
  else
    result := TFhirImmunizationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirImmunizationStatusCodesEnum, FStatus.value));
end;

procedure TFhirImmunization.SetStatusST(value : TFhirImmunizationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirImmunizationStatusCodesEnum[value], CODES_TFhirImmunizationStatusCodesEnum[value]);
end;

procedure TFhirImmunization.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

procedure TFhirImmunization.SetVaccineCode(value : TFhirCodeableConcept);
begin
  FVaccineCode.free;
  FVaccineCode := value;
end;

procedure TFhirImmunization.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirImmunization.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirImmunization.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

procedure TFhirImmunization.SetRecorded(value : TFhirDateTime);
begin
  FRecorded.free;
  FRecorded := value;
end;

function TFhirImmunization.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

procedure TFhirImmunization.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirDateTime.create;
  FRecorded.value := value
end;

procedure TFhirImmunization.SetPrimarySource(value : TFhirBoolean);
begin
  FPrimarySource.free;
  FPrimarySource := value;
end;

function TFhirImmunization.GetPrimarySourceST : Boolean;
begin
  if FPrimarySource = nil then
    result := false
  else
    result := FPrimarySource.value;
end;

procedure TFhirImmunization.SetPrimarySourceST(value : Boolean);
begin
  if FPrimarySource = nil then
    FPrimarySource := TFhirBoolean.create;
  FPrimarySource.value := value
end;

procedure TFhirImmunization.SetReportOrigin(value : TFhirCodeableConcept);
begin
  FReportOrigin.free;
  FReportOrigin := value;
end;

procedure TFhirImmunization.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirImmunization.SetManufacturer(value : TFhirReference);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

procedure TFhirImmunization.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

function TFhirImmunization.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirImmunization.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirImmunization.SetExpirationDate(value : TFhirDate);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

function TFhirImmunization.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

procedure TFhirImmunization.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDate.create;
  FExpirationDate.value := value
end;

procedure TFhirImmunization.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

procedure TFhirImmunization.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

procedure TFhirImmunization.SetDoseQuantity(value : TFhirQuantity);
begin
  FDoseQuantity.free;
  FDoseQuantity := value;
end;

function TFhirImmunization.GetPerformerList : TFhirImmunizationPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirImmunizationPerformerList.Create;
  result := FPerformerList;
end;

function TFhirImmunization.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirImmunization.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirImmunization.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirImmunization.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirImmunization.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirImmunization.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirImmunization.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

procedure TFhirImmunization.SetIsSubpotent(value : TFhirBoolean);
begin
  FIsSubpotent.free;
  FIsSubpotent := value;
end;

function TFhirImmunization.GetIsSubpotentST : Boolean;
begin
  if FIsSubpotent = nil then
    result := false
  else
    result := FIsSubpotent.value;
end;

procedure TFhirImmunization.SetIsSubpotentST(value : Boolean);
begin
  if FIsSubpotent = nil then
    FIsSubpotent := TFhirBoolean.create;
  FIsSubpotent.value := value
end;

function TFhirImmunization.GetSubpotentReasonList : TFhirCodeableConceptList;
begin
  if FSubpotentReasonList = nil then
    FSubpotentReasonList := TFhirCodeableConceptList.Create;
  result := FSubpotentReasonList;
end;

function TFhirImmunization.GetHasSubpotentReasonList : boolean;
begin
  result := (FSubpotentReasonList <> nil) and (FSubpotentReasonList.count > 0);
end;

function TFhirImmunization.GetEducationList : TFhirImmunizationEducationList;
begin
  if FEducationList = nil then
    FEducationList := TFhirImmunizationEducationList.Create;
  result := FEducationList;
end;

function TFhirImmunization.GetHasEducationList : boolean;
begin
  result := (FEducationList <> nil) and (FEducationList.count > 0);
end;

function TFhirImmunization.GetProgramEligibilityList : TFhirCodeableConceptList;
begin
  if FProgramEligibilityList = nil then
    FProgramEligibilityList := TFhirCodeableConceptList.Create;
  result := FProgramEligibilityList;
end;

function TFhirImmunization.GetHasProgramEligibilityList : boolean;
begin
  result := (FProgramEligibilityList <> nil) and (FProgramEligibilityList.count > 0);
end;

procedure TFhirImmunization.SetFundingSource(value : TFhirCodeableConcept);
begin
  FFundingSource.free;
  FFundingSource := value;
end;

function TFhirImmunization.GetReactionList : TFhirImmunizationReactionList;
begin
  if FReactionList = nil then
    FReactionList := TFhirImmunizationReactionList.Create;
  result := FReactionList;
end;

function TFhirImmunization.GetHasReactionList : boolean;
begin
  result := (FReactionList <> nil) and (FReactionList.count > 0);
end;

function TFhirImmunization.GetProtocolAppliedList : TFhirImmunizationProtocolAppliedList;
begin
  if FProtocolAppliedList = nil then
    FProtocolAppliedList := TFhirImmunizationProtocolAppliedList.Create;
  result := FProtocolAppliedList;
end;

function TFhirImmunization.GetHasProtocolAppliedList : boolean;
begin
  result := (FProtocolAppliedList <> nil) and (FProtocolAppliedList.count > 0);
end;

{ TFhirImmunizationListEnumerator }

constructor TFhirImmunizationListEnumerator.Create(list : TFhirImmunizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationListEnumerator.GetCurrent : TFhirImmunization;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImmunizationList }

function TFhirImmunizationList.AddItem(value: TFhirImmunization): TFhirImmunization;
begin
  assert(value.ClassName = 'TFhirImmunization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunization');
  add(value);
  result := value;
end;

function TFhirImmunizationList.Append: TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationList.GetEnumerator : TFhirImmunizationListEnumerator;
begin
  result := TFhirImmunizationListEnumerator.Create(self.link);
end;

function TFhirImmunizationList.Clone: TFhirImmunizationList;
begin
  result := TFhirImmunizationList(inherited Clone);
end;

function TFhirImmunizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationList.GetItemN(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization(ObjectByIndex[index]);
end;

function TFhirImmunizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunization;
end;
function TFhirImmunizationList.IndexOf(value: TFhirImmunization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationList.Insert(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationList.InsertItem(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  Inherited Insert(index, value);
end;

function TFhirImmunizationList.Item(index: Integer): TFhirImmunization;
begin
  result := TFhirImmunization(ObjectByIndex[index]);
end;

function TFhirImmunizationList.Link: TFhirImmunizationList;
begin
  result := TFhirImmunizationList(inherited Link);
end;

procedure TFhirImmunizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationList.SetItemByIndex(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  FhirImmunizations[index] := value;
end;

procedure TFhirImmunizationList.SetItemN(index: Integer; value: TFhirImmunization);
begin
  assert(value is TFhirImmunization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATION}
{$IFDEF FHIR_IMMUNIZATIONEVALUATION}
{ TFhirImmunizationEvaluation }

constructor TFhirImmunizationEvaluation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationEvaluation.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPatient.free;
  FDate.free;
  FAuthority.free;
  FTargetDisease.free;
  FImmunizationEvent.free;
  FDoseStatus.free;
  FDoseStatusReasonList.Free;
  FDescription.free;
  FSeries.free;
  FDoseNumber.free;
  FSeriesDoses.free;
  inherited;
end;

procedure TFhirImmunizationEvaluation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationEvaluation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunizationEvaluation(oSource).FIdentifierList);
  end;
  statusElement := TFhirImmunizationEvaluation(oSource).statusElement.Clone;
  patient := TFhirImmunizationEvaluation(oSource).patient.Clone;
  dateElement := TFhirImmunizationEvaluation(oSource).dateElement.Clone;
  authority := TFhirImmunizationEvaluation(oSource).authority.Clone;
  targetDisease := TFhirImmunizationEvaluation(oSource).targetDisease.Clone;
  immunizationEvent := TFhirImmunizationEvaluation(oSource).immunizationEvent.Clone;
  doseStatus := TFhirImmunizationEvaluation(oSource).doseStatus.Clone;
  if (TFhirImmunizationEvaluation(oSource).FDoseStatusReasonList = nil) then
  begin
    FDoseStatusReasonList.free;
    FDoseStatusReasonList := nil;
  end
  else
  begin
    if FDoseStatusReasonList = nil then
      FDoseStatusReasonList := TFhirCodeableConceptList.Create;
    FDoseStatusReasonList.Assign(TFhirImmunizationEvaluation(oSource).FDoseStatusReasonList);
  end;
  descriptionElement := TFhirImmunizationEvaluation(oSource).descriptionElement.Clone;
  seriesElement := TFhirImmunizationEvaluation(oSource).seriesElement.Clone;
  doseNumber := TFhirImmunizationEvaluation(oSource).doseNumber.Clone;
  seriesDoses := TFhirImmunizationEvaluation(oSource).seriesDoses.Clone;
end;

function TFhirImmunizationEvaluation.GetResourceType : TFhirResourceType;
begin
  result := frtImmunizationEvaluation;
end;

procedure TFhirImmunizationEvaluation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'targetDisease') Then
     list.add(self.link, 'targetDisease', FTargetDisease.Link);
  if (child_name = 'immunizationEvent') Then
     list.add(self.link, 'immunizationEvent', FImmunizationEvent.Link);
  if (child_name = 'doseStatus') Then
     list.add(self.link, 'doseStatus', FDoseStatus.Link);
  if (child_name = 'doseStatusReason') Then
    list.addAll(self, 'doseStatusReason', FDoseStatusReasonList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
  if (child_name = 'doseNumber[x]') or (child_name = 'doseNumber') Then
     list.add(self.link, 'doseNumber[x]', FDoseNumber.Link);
  if (child_name = 'seriesDoses[x]') or (child_name = 'seriesDoses') Then
     list.add(self.link, 'seriesDoses[x]', FSeriesDoses.Link);
end;

procedure TFhirImmunizationEvaluation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference', false, TFhirReference, FAuthority.Link));
  oList.add(TFHIRProperty.create(self, 'targetDisease', 'CodeableConcept', false, TFhirCodeableConcept, FTargetDisease.Link));
  oList.add(TFHIRProperty.create(self, 'immunizationEvent', 'Reference', false, TFhirReference, FImmunizationEvent.Link));
  oList.add(TFHIRProperty.create(self, 'doseStatus', 'CodeableConcept', false, TFhirCodeableConcept, FDoseStatus.Link));
  oList.add(TFHIRProperty.create(self, 'doseStatusReason', 'CodeableConcept', true, TFhirCodeableConcept, FDoseStatusReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link));
  oList.add(TFHIRProperty.create(self, 'doseNumber[x]', 'positiveInt|string', false, TFhirDataType, FDoseNumber.Link));
  oList.add(TFHIRProperty.create(self, 'seriesDoses[x]', 'positiveInt|string', false, TFhirDataType, FSeriesDoses.Link));
end;

function TFhirImmunizationEvaluation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum, CODES_TFhirImmunizationEvaluationStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'targetDisease') then
  begin
    TargetDisease := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'immunizationEvent') then
  begin
    ImmunizationEvent := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'doseStatus') then
  begin
    DoseStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'doseStatusReason') then
  begin
    DoseStatusReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then
  begin
    DoseNumber := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then
  begin
    SeriesDoses := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationEvaluation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'doseStatusReason') then DoseStatusReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirImmunizationEvaluation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum[ImmunizationEvaluationStatusCodesNull], CODES_TFhirImmunizationEvaluationStatusCodesEnum[ImmunizationEvaluationStatusCodesNull]) 
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'authority') then result := TFhirReference.create()
  else if (propName = 'targetDisease') then result := TFhirCodeableConcept.create()
  else if (propName = 'immunizationEvent') then result := TFhirReference.create()
  else if (propName = 'doseStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'doseStatusReason') then result := DoseStatusReasonList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'series') then result := TFhirString.create()
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then raise EFHIRException.create('Cannot make property DoseNumber')
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then raise EFHIRException.create('Cannot make property SeriesDoses')
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationEvaluation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'targetDisease') then result := 'CodeableConcept'
  else if (propName = 'immunizationEvent') then result := 'Reference'
  else if (propName = 'doseStatus') then result := 'CodeableConcept'
  else if (propName = 'doseStatusReason') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'series') then result := 'string'
  else if (propName = 'doseNumber[x]') then result := 'positiveInt|string'
  else if (propName = 'seriesDoses[x]') then result := 'positiveInt|string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationEvaluation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'targetDisease') then TargetDiseaseElement := nil
  else if (propName = 'immunizationEvent') then ImmunizationEventElement := nil
  else if (propName = 'doseStatus') then DoseStatusElement := nil
  else if (propName = 'doseStatusReason') then deletePropertyValue('doseStatusReason', DoseStatusReasonList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'series') then SeriesElement := nil
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then DoseNumberElement := nil
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then SeriesDosesElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationEvaluation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum, CODES_TFhirImmunizationEvaluationStatusCodesEnum, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference
  else if (propName = 'targetDisease') then TargetDiseaseElement := new as TFhirCodeableConcept
  else if (propName = 'immunizationEvent') then ImmunizationEventElement := new as TFhirReference
  else if (propName = 'doseStatus') then DoseStatusElement := new as TFhirCodeableConcept
  else if (propName = 'doseStatusReason') then replacePropertyValue('doseStatusReason', DoseStatusReasonList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'series') then SeriesElement := asString(new)
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then DoseNumberElement := new as TFhirDataType
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then SeriesDosesElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationEvaluation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'doseStatusReason') then DoseStatusReasonList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationEvaluation.fhirType : string;
begin
  result := 'ImmunizationEvaluation';
end;

function TFhirImmunizationEvaluation.Link : TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation(inherited Link);
end;

function TFhirImmunizationEvaluation.Clone : TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation(inherited Clone);
end;

function TFhirImmunizationEvaluation.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationEvaluation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationEvaluation)) then
    result := false
  else
  begin
    o := TFhirImmunizationEvaluation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(authorityElement, o.authorityElement, true) and compareDeep(targetDiseaseElement, o.targetDiseaseElement, true) and 
      compareDeep(immunizationEventElement, o.immunizationEventElement, true) and compareDeep(doseStatusElement, o.doseStatusElement, true) and 
      compareDeep(doseStatusReasonList, o.doseStatusReasonList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(seriesElement, o.seriesElement, true) and compareDeep(doseNumberElement, o.doseNumberElement, true) and 
      compareDeep(seriesDosesElement, o.seriesDosesElement, true);
  end;
end;

function TFhirImmunizationEvaluation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FAuthority) and isEmptyProp(FTargetDisease) and isEmptyProp(FImmunizationEvent) and isEmptyProp(FDoseStatus) and isEmptyProp(FdoseStatusReasonList) and isEmptyProp(FDescription) and isEmptyProp(FSeries) and isEmptyProp(FDoseNumber) and isEmptyProp(FSeriesDoses);
end;

procedure TFhirImmunizationEvaluation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('patient');
  fields.add('date');
  fields.add('authority');
  fields.add('targetDisease');
  fields.add('immunizationEvent');
  fields.add('doseStatus');
  fields.add('doseStatusReason');
  fields.add('description');
  fields.add('series');
  fields.add('doseNumber[x]');
  fields.add('seriesDoses[x]');
end;

function TFhirImmunizationEvaluation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FDoseStatusReasonList.sizeInBytes(magic));
end;

function TFhirImmunizationEvaluation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirImmunizationEvaluation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirImmunizationEvaluation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirImmunizationEvaluation.GetStatusST : TFhirImmunizationEvaluationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirImmunizationEvaluationStatusCodesEnum(0)
  else
    result := TFhirImmunizationEvaluationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirImmunizationEvaluationStatusCodesEnum, FStatus.value));
end;

procedure TFhirImmunizationEvaluation.SetStatusST(value : TFhirImmunizationEvaluationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirImmunizationEvaluationStatusCodesEnum[value], CODES_TFhirImmunizationEvaluationStatusCodesEnum[value]);
end;

procedure TFhirImmunizationEvaluation.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirImmunizationEvaluation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirImmunizationEvaluation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirImmunizationEvaluation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirImmunizationEvaluation.SetAuthority(value : TFhirReference);
begin
  FAuthority.free;
  FAuthority := value;
end;

procedure TFhirImmunizationEvaluation.SetTargetDisease(value : TFhirCodeableConcept);
begin
  FTargetDisease.free;
  FTargetDisease := value;
end;

procedure TFhirImmunizationEvaluation.SetImmunizationEvent(value : TFhirReference);
begin
  FImmunizationEvent.free;
  FImmunizationEvent := value;
end;

procedure TFhirImmunizationEvaluation.SetDoseStatus(value : TFhirCodeableConcept);
begin
  FDoseStatus.free;
  FDoseStatus := value;
end;

function TFhirImmunizationEvaluation.GetDoseStatusReasonList : TFhirCodeableConceptList;
begin
  if FDoseStatusReasonList = nil then
    FDoseStatusReasonList := TFhirCodeableConceptList.Create;
  result := FDoseStatusReasonList;
end;

function TFhirImmunizationEvaluation.GetHasDoseStatusReasonList : boolean;
begin
  result := (FDoseStatusReasonList <> nil) and (FDoseStatusReasonList.count > 0);
end;

procedure TFhirImmunizationEvaluation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirImmunizationEvaluation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImmunizationEvaluation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirImmunizationEvaluation.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

function TFhirImmunizationEvaluation.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

procedure TFhirImmunizationEvaluation.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

procedure TFhirImmunizationEvaluation.SetDoseNumber(value : TFhirDataType);
begin
  FDoseNumber.free;
  FDoseNumber := value;
end;

procedure TFhirImmunizationEvaluation.SetSeriesDoses(value : TFhirDataType);
begin
  FSeriesDoses.free;
  FSeriesDoses := value;
end;

{ TFhirImmunizationEvaluationListEnumerator }

constructor TFhirImmunizationEvaluationListEnumerator.Create(list : TFhirImmunizationEvaluationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationEvaluationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationEvaluationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationEvaluationListEnumerator.GetCurrent : TFhirImmunizationEvaluation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationEvaluationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImmunizationEvaluationList }

function TFhirImmunizationEvaluationList.AddItem(value: TFhirImmunizationEvaluation): TFhirImmunizationEvaluation;
begin
  assert(value.ClassName = 'TFhirImmunizationEvaluation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationEvaluation');
  add(value);
  result := value;
end;

function TFhirImmunizationEvaluationList.Append: TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationEvaluationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationEvaluationList.GetEnumerator : TFhirImmunizationEvaluationListEnumerator;
begin
  result := TFhirImmunizationEvaluationListEnumerator.Create(self.link);
end;

function TFhirImmunizationEvaluationList.Clone: TFhirImmunizationEvaluationList;
begin
  result := TFhirImmunizationEvaluationList(inherited Clone);
end;

function TFhirImmunizationEvaluationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationEvaluationList.GetItemN(index: Integer): TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation(ObjectByIndex[index]);
end;

function TFhirImmunizationEvaluationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationEvaluation;
end;
function TFhirImmunizationEvaluationList.IndexOf(value: TFhirImmunizationEvaluation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationEvaluationList.Insert(index: Integer): TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationEvaluationList.InsertItem(index: Integer; value: TFhirImmunizationEvaluation);
begin
  assert(value is TFhirImmunizationEvaluation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationEvaluationList.Item(index: Integer): TFhirImmunizationEvaluation;
begin
  result := TFhirImmunizationEvaluation(ObjectByIndex[index]);
end;

function TFhirImmunizationEvaluationList.Link: TFhirImmunizationEvaluationList;
begin
  result := TFhirImmunizationEvaluationList(inherited Link);
end;

procedure TFhirImmunizationEvaluationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationEvaluationList.SetItemByIndex(index: Integer; value: TFhirImmunizationEvaluation);
begin
  assert(value is TFhirImmunizationEvaluation);
  FhirImmunizationEvaluations[index] := value;
end;

procedure TFhirImmunizationEvaluationList.SetItemN(index: Integer; value: TFhirImmunizationEvaluation);
begin
  assert(value is TFhirImmunizationEvaluation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATIONEVALUATION}
{$IFDEF FHIR_IMMUNIZATIONRECOMMENDATION}
{ TFhirImmunizationRecommendationRecommendation }

constructor TFhirImmunizationRecommendationRecommendation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendation.Destroy;
begin
  FVaccineCodeList.Free;
  FTargetDisease.free;
  FContraindicatedVaccineCodeList.Free;
  FForecastStatus.free;
  FForecastReasonList.Free;
  FDateCriterionList.Free;
  FDescription.free;
  FSeries.free;
  FDoseNumber.free;
  FSeriesDoses.free;
  FSupportingImmunizationList.Free;
  FSupportingPatientInformationList.Free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FVaccineCodeList = nil) then
  begin
    FVaccineCodeList.free;
    FVaccineCodeList := nil;
  end
  else
  begin
    if FVaccineCodeList = nil then
      FVaccineCodeList := TFhirCodeableConceptList.Create;
    FVaccineCodeList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FVaccineCodeList);
  end;
  targetDisease := TFhirImmunizationRecommendationRecommendation(oSource).targetDisease.Clone;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FContraindicatedVaccineCodeList = nil) then
  begin
    FContraindicatedVaccineCodeList.free;
    FContraindicatedVaccineCodeList := nil;
  end
  else
  begin
    if FContraindicatedVaccineCodeList = nil then
      FContraindicatedVaccineCodeList := TFhirCodeableConceptList.Create;
    FContraindicatedVaccineCodeList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FContraindicatedVaccineCodeList);
  end;
  forecastStatus := TFhirImmunizationRecommendationRecommendation(oSource).forecastStatus.Clone;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FForecastReasonList = nil) then
  begin
    FForecastReasonList.free;
    FForecastReasonList := nil;
  end
  else
  begin
    if FForecastReasonList = nil then
      FForecastReasonList := TFhirCodeableConceptList.Create;
    FForecastReasonList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FForecastReasonList);
  end;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList = nil) then
  begin
    FDateCriterionList.free;
    FDateCriterionList := nil;
  end
  else
  begin
    if FDateCriterionList = nil then
      FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
    FDateCriterionList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FDateCriterionList);
  end;
  descriptionElement := TFhirImmunizationRecommendationRecommendation(oSource).descriptionElement.Clone;
  seriesElement := TFhirImmunizationRecommendationRecommendation(oSource).seriesElement.Clone;
  doseNumber := TFhirImmunizationRecommendationRecommendation(oSource).doseNumber.Clone;
  seriesDoses := TFhirImmunizationRecommendationRecommendation(oSource).seriesDoses.Clone;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList = nil) then
  begin
    FSupportingImmunizationList.free;
    FSupportingImmunizationList := nil;
  end
  else
  begin
    if FSupportingImmunizationList = nil then
      FSupportingImmunizationList := TFhirReferenceList.Create;
    FSupportingImmunizationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingImmunizationList);
  end;
  if (TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList = nil) then
  begin
    FSupportingPatientInformationList.free;
    FSupportingPatientInformationList := nil;
  end
  else
  begin
    if FSupportingPatientInformationList = nil then
      FSupportingPatientInformationList := TFhirReferenceList.Create;
    FSupportingPatientInformationList.Assign(TFhirImmunizationRecommendationRecommendation(oSource).FSupportingPatientInformationList);
  end;
end;

procedure TFhirImmunizationRecommendationRecommendation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'vaccineCode') Then
    list.addAll(self, 'vaccineCode', FVaccineCodeList);
  if (child_name = 'targetDisease') Then
     list.add(self.link, 'targetDisease', FTargetDisease.Link);
  if (child_name = 'contraindicatedVaccineCode') Then
    list.addAll(self, 'contraindicatedVaccineCode', FContraindicatedVaccineCodeList);
  if (child_name = 'forecastStatus') Then
     list.add(self.link, 'forecastStatus', FForecastStatus.Link);
  if (child_name = 'forecastReason') Then
    list.addAll(self, 'forecastReason', FForecastReasonList);
  if (child_name = 'dateCriterion') Then
    list.addAll(self, 'dateCriterion', FDateCriterionList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'series') Then
     list.add(self.link, 'series', FSeries.Link);
  if (child_name = 'doseNumber[x]') or (child_name = 'doseNumber') Then
     list.add(self.link, 'doseNumber[x]', FDoseNumber.Link);
  if (child_name = 'seriesDoses[x]') or (child_name = 'seriesDoses') Then
     list.add(self.link, 'seriesDoses[x]', FSeriesDoses.Link);
  if (child_name = 'supportingImmunization') Then
    list.addAll(self, 'supportingImmunization', FSupportingImmunizationList);
  if (child_name = 'supportingPatientInformation') Then
    list.addAll(self, 'supportingPatientInformation', FSupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'vaccineCode', 'CodeableConcept', true, TFhirCodeableConcept, FVaccineCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'targetDisease', 'CodeableConcept', false, TFhirCodeableConcept, FTargetDisease.Link));
  oList.add(TFHIRProperty.create(self, 'contraindicatedVaccineCode', 'CodeableConcept', true, TFhirCodeableConcept, FContraindicatedVaccineCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'forecastStatus', 'CodeableConcept', false, TFhirCodeableConcept, FForecastStatus.Link));
  oList.add(TFHIRProperty.create(self, 'forecastReason', 'CodeableConcept', true, TFhirCodeableConcept, FForecastReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'dateCriterion', 'BackboneElement', true, TFhirImmunizationRecommendationRecommendationDateCriterion, FDateCriterionList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'series', 'string', false, TFhirString, FSeries.Link));
  oList.add(TFHIRProperty.create(self, 'doseNumber[x]', 'positiveInt|string', false, TFhirDataType, FDoseNumber.Link));
  oList.add(TFHIRProperty.create(self, 'seriesDoses[x]', 'positiveInt|string', false, TFhirDataType, FSeriesDoses.Link));
  oList.add(TFHIRProperty.create(self, 'supportingImmunization', 'Reference', true, TFhirReference, FSupportingImmunizationList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingPatientInformation', 'Reference', true, TFhirReference, FSupportingPatientInformationList.Link));
end;

function TFhirImmunizationRecommendationRecommendation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'vaccineCode') then
  begin
    VaccineCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'targetDisease') then
  begin
    TargetDisease := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'contraindicatedVaccineCode') then
  begin
    ContraindicatedVaccineCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'forecastStatus') then
  begin
    ForecastStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'forecastReason') then
  begin
    ForecastReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'dateCriterion') then
  begin
    DateCriterionList.add(propValue as TFhirImmunizationRecommendationRecommendationDateCriterion);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'series') then
  begin
    SeriesElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then
  begin
    DoseNumber := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then
  begin
    SeriesDoses := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'supportingImmunization') then
  begin
    SupportingImmunizationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'supportingPatientInformation') then
  begin
    SupportingPatientInformationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'vaccineCode') then VaccineCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'contraindicatedVaccineCode') then ContraindicatedVaccineCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'forecastReason') then ForecastReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'dateCriterion') then DateCriterionList.insertItem(index, propValue as TFhirImmunizationRecommendationRecommendationDateCriterion)
  else if (propName = 'supportingImmunization') then SupportingImmunizationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'supportingPatientInformation') then SupportingPatientInformationList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirImmunizationRecommendationRecommendation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'vaccineCode') then result := VaccineCodeList.new()
  else if (propName = 'targetDisease') then result := TFhirCodeableConcept.create()
  else if (propName = 'contraindicatedVaccineCode') then result := ContraindicatedVaccineCodeList.new()
  else if (propName = 'forecastStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'forecastReason') then result := ForecastReasonList.new()
  else if (propName = 'dateCriterion') then result := DateCriterionList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'series') then result := TFhirString.create()
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then raise EFHIRException.create('Cannot make property DoseNumber')
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then raise EFHIRException.create('Cannot make property SeriesDoses')
  else if (propName = 'supportingImmunization') then result := SupportingImmunizationList.new()
  else if (propName = 'supportingPatientInformation') then result := SupportingPatientInformationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'vaccineCode') then result := 'CodeableConcept'
  else if (propName = 'targetDisease') then result := 'CodeableConcept'
  else if (propName = 'contraindicatedVaccineCode') then result := 'CodeableConcept'
  else if (propName = 'forecastStatus') then result := 'CodeableConcept'
  else if (propName = 'forecastReason') then result := 'CodeableConcept'
  else if (propName = 'dateCriterion') then result := 'BackboneElement'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'series') then result := 'string'
  else if (propName = 'doseNumber[x]') then result := 'positiveInt|string'
  else if (propName = 'seriesDoses[x]') then result := 'positiveInt|string'
  else if (propName = 'supportingImmunization') then result := 'Reference'
  else if (propName = 'supportingPatientInformation') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'vaccineCode') then deletePropertyValue('vaccineCode', VaccineCodeList, value)
  else if (propName = 'targetDisease') then TargetDiseaseElement := nil
  else if (propName = 'contraindicatedVaccineCode') then deletePropertyValue('contraindicatedVaccineCode', ContraindicatedVaccineCodeList, value)
  else if (propName = 'forecastStatus') then ForecastStatusElement := nil
  else if (propName = 'forecastReason') then deletePropertyValue('forecastReason', ForecastReasonList, value)
  else if (propName = 'dateCriterion') then deletePropertyValue('dateCriterion', DateCriterionList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'series') then SeriesElement := nil
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then DoseNumberElement := nil
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then SeriesDosesElement := nil
  else if (propName = 'supportingImmunization') then deletePropertyValue('supportingImmunization', SupportingImmunizationList, value)
  else if (propName = 'supportingPatientInformation') then deletePropertyValue('supportingPatientInformation', SupportingPatientInformationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'vaccineCode') then replacePropertyValue('vaccineCode', VaccineCodeList, existing, new)
  else if (propName = 'targetDisease') then TargetDiseaseElement := new as TFhirCodeableConcept
  else if (propName = 'contraindicatedVaccineCode') then replacePropertyValue('contraindicatedVaccineCode', ContraindicatedVaccineCodeList, existing, new)
  else if (propName = 'forecastStatus') then ForecastStatusElement := new as TFhirCodeableConcept
  else if (propName = 'forecastReason') then replacePropertyValue('forecastReason', ForecastReasonList, existing, new)
  else if (propName = 'dateCriterion') then replacePropertyValue('dateCriterion', DateCriterionList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'series') then SeriesElement := asString(new)
  else if (isMatchingName(propName, 'doseNumber', ['PositiveInt', 'String'])) then DoseNumberElement := new as TFhirDataType
  else if (isMatchingName(propName, 'seriesDoses', ['PositiveInt', 'String'])) then SeriesDosesElement := new as TFhirDataType
  else if (propName = 'supportingImmunization') then replacePropertyValue('supportingImmunization', SupportingImmunizationList, existing, new)
  else if (propName = 'supportingPatientInformation') then replacePropertyValue('supportingPatientInformation', SupportingPatientInformationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'vaccineCode') then VaccineCodeList.move(source, destination)
  else if (propName = 'contraindicatedVaccineCode') then ContraindicatedVaccineCodeList.move(source, destination)
  else if (propName = 'forecastReason') then ForecastReasonList.move(source, destination)
  else if (propName = 'dateCriterion') then DateCriterionList.move(source, destination)
  else if (propName = 'supportingImmunization') then SupportingImmunizationList.move(source, destination)
  else if (propName = 'supportingPatientInformation') then SupportingPatientInformationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendation.fhirType : string;
begin
  result := 'ImmunizationRecommendation.recommendation';
end;

function TFhirImmunizationRecommendationRecommendation.Link : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendation.Clone : TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendation.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationRecommendationRecommendation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendation)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendation(other);
    result := compareDeep(vaccineCodeList, o.vaccineCodeList, true) and compareDeep(targetDiseaseElement, o.targetDiseaseElement, true) and 
      compareDeep(contraindicatedVaccineCodeList, o.contraindicatedVaccineCodeList, true) and 
      compareDeep(forecastStatusElement, o.forecastStatusElement, true) and compareDeep(forecastReasonList, o.forecastReasonList, true) and 
      compareDeep(dateCriterionList, o.dateCriterionList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(seriesElement, o.seriesElement, true) and compareDeep(doseNumberElement, o.doseNumberElement, true) and 
      compareDeep(seriesDosesElement, o.seriesDosesElement, true) and compareDeep(supportingImmunizationList, o.supportingImmunizationList, true) and 
      compareDeep(supportingPatientInformationList, o.supportingPatientInformationList, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FvaccineCodeList) and isEmptyProp(FTargetDisease) and isEmptyProp(FcontraindicatedVaccineCodeList) and isEmptyProp(FForecastStatus) and isEmptyProp(FforecastReasonList) and isEmptyProp(FdateCriterionList) and isEmptyProp(FDescription) and isEmptyProp(FSeries) and isEmptyProp(FDoseNumber) and isEmptyProp(FSeriesDoses) and isEmptyProp(FsupportingImmunizationList) and isEmptyProp(FsupportingPatientInformationList);
end;

procedure TFhirImmunizationRecommendationRecommendation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('vaccineCode');
  fields.add('targetDisease');
  fields.add('contraindicatedVaccineCode');
  fields.add('forecastStatus');
  fields.add('forecastReason');
  fields.add('dateCriterion');
  fields.add('description');
  fields.add('series');
  fields.add('doseNumber[x]');
  fields.add('seriesDoses[x]');
  fields.add('supportingImmunization');
  fields.add('supportingPatientInformation');
end;

function TFhirImmunizationRecommendationRecommendation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FVaccineCodeList.sizeInBytes(magic));
  inc(result, FContraindicatedVaccineCodeList.sizeInBytes(magic));
  inc(result, FForecastReasonList.sizeInBytes(magic));
  inc(result, FDateCriterionList.sizeInBytes(magic));
  inc(result, FSupportingImmunizationList.sizeInBytes(magic));
  inc(result, FSupportingPatientInformationList.sizeInBytes(magic));
end;

function TFhirImmunizationRecommendationRecommendation.GetVaccineCodeList : TFhirCodeableConceptList;
begin
  if FVaccineCodeList = nil then
    FVaccineCodeList := TFhirCodeableConceptList.Create;
  result := FVaccineCodeList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasVaccineCodeList : boolean;
begin
  result := (FVaccineCodeList <> nil) and (FVaccineCodeList.count > 0);
end;

procedure TFhirImmunizationRecommendationRecommendation.SetTargetDisease(value : TFhirCodeableConcept);
begin
  FTargetDisease.free;
  FTargetDisease := value;
end;

function TFhirImmunizationRecommendationRecommendation.GetContraindicatedVaccineCodeList : TFhirCodeableConceptList;
begin
  if FContraindicatedVaccineCodeList = nil then
    FContraindicatedVaccineCodeList := TFhirCodeableConceptList.Create;
  result := FContraindicatedVaccineCodeList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasContraindicatedVaccineCodeList : boolean;
begin
  result := (FContraindicatedVaccineCodeList <> nil) and (FContraindicatedVaccineCodeList.count > 0);
end;

procedure TFhirImmunizationRecommendationRecommendation.SetForecastStatus(value : TFhirCodeableConcept);
begin
  FForecastStatus.free;
  FForecastStatus := value;
end;

function TFhirImmunizationRecommendationRecommendation.GetForecastReasonList : TFhirCodeableConceptList;
begin
  if FForecastReasonList = nil then
    FForecastReasonList := TFhirCodeableConceptList.Create;
  result := FForecastReasonList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasForecastReasonList : boolean;
begin
  result := (FForecastReasonList <> nil) and (FForecastReasonList.count > 0);
end;

function TFhirImmunizationRecommendationRecommendation.GetDateCriterionList : TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  if FDateCriterionList = nil then
    FDateCriterionList := TFhirImmunizationRecommendationRecommendationDateCriterionList.Create;
  result := FDateCriterionList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasDateCriterionList : boolean;
begin
  result := (FDateCriterionList <> nil) and (FDateCriterionList.count > 0);
end;

procedure TFhirImmunizationRecommendationRecommendation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirImmunizationRecommendationRecommendation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirImmunizationRecommendationRecommendation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirImmunizationRecommendationRecommendation.SetSeries(value : TFhirString);
begin
  FSeries.free;
  FSeries := value;
end;

function TFhirImmunizationRecommendationRecommendation.GetSeriesST : String;
begin
  if FSeries = nil then
    result := ''
  else
    result := FSeries.value;
end;

procedure TFhirImmunizationRecommendationRecommendation.SetSeriesST(value : String);
begin
  if value <> '' then
  begin
    if FSeries = nil then
      FSeries := TFhirString.create;
    FSeries.value := value
  end
  else if FSeries <> nil then
    FSeries.value := '';
end;

procedure TFhirImmunizationRecommendationRecommendation.SetDoseNumber(value : TFhirDataType);
begin
  FDoseNumber.free;
  FDoseNumber := value;
end;

procedure TFhirImmunizationRecommendationRecommendation.SetSeriesDoses(value : TFhirDataType);
begin
  FSeriesDoses.free;
  FSeriesDoses := value;
end;

function TFhirImmunizationRecommendationRecommendation.GetSupportingImmunizationList : TFhirReferenceList;
begin
  if FSupportingImmunizationList = nil then
    FSupportingImmunizationList := TFhirReferenceList.Create;
  result := FSupportingImmunizationList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasSupportingImmunizationList : boolean;
begin
  result := (FSupportingImmunizationList <> nil) and (FSupportingImmunizationList.count > 0);
end;

function TFhirImmunizationRecommendationRecommendation.GetSupportingPatientInformationList : TFhirReferenceList;
begin
  if FSupportingPatientInformationList = nil then
    FSupportingPatientInformationList := TFhirReferenceList.Create;
  result := FSupportingPatientInformationList;
end;

function TFhirImmunizationRecommendationRecommendation.GetHasSupportingPatientInformationList : boolean;
begin
  result := (FSupportingPatientInformationList <> nil) and (FSupportingPatientInformationList.count > 0);
end;

{ TFhirImmunizationRecommendationRecommendationListEnumerator }

constructor TFhirImmunizationRecommendationRecommendationListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImmunizationRecommendationRecommendationList }

function TFhirImmunizationRecommendationRecommendationList.AddItem(value: TFhirImmunizationRecommendationRecommendation): TFhirImmunizationRecommendationRecommendation;
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendation');
  add(value);
  result := value;
end;

function TFhirImmunizationRecommendationRecommendationList.Append: TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationList.GetEnumerator : TFhirImmunizationRecommendationRecommendationListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationList.Clone: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendation;
end;
function TFhirImmunizationRecommendationRecommendationList.IndexOf(value: TFhirImmunizationRecommendationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendationRecommendation;
begin
  result := TFhirImmunizationRecommendationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationList.Link: TFhirImmunizationRecommendationRecommendationList;
begin
  result := TFhirImmunizationRecommendationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  FhirImmunizationRecommendationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendationRecommendation);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterion }

constructor TFhirImmunizationRecommendationRecommendationDateCriterion.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterion.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).code.Clone;
  valueElement := TFhirImmunizationRecommendationRecommendationDateCriterion(oSource).valueElement.Clone;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'dateTime', false, TFhirDateTime, FValue.Link));
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.fhirType : string;
begin
  result := 'ImmunizationRecommendation.recommendation.dateCriterion';
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Link : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.Clone : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendationRecommendationDateCriterion)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendationRecommendationDateCriterion(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value');
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValue(value : TFhirDateTime);
begin
  FValue.free;
  FValue := value;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterion.GetValueST : TFslDateTime;
begin
  if FValue = nil then
    result := TFslDateTime.makeNull
  else
    result := FValue.value;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterion.SetValueST(value : TFslDateTime);
begin
  if FValue = nil then
    FValue := TFhirDateTime.create;
  FValue.value := value
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator }

constructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(list : TFhirImmunizationRecommendationRecommendationDateCriterionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.GetCurrent : TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImmunizationRecommendationRecommendationDateCriterionList }

function TFhirImmunizationRecommendationRecommendationDateCriterionList.AddItem(value: TFhirImmunizationRecommendationRecommendationDateCriterion): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendationRecommendationDateCriterion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendationRecommendationDateCriterion');
  add(value);
  result := value;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Append: TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetEnumerator : TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Clone: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Clone);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.GetItemN(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion;
end;
function TFhirImmunizationRecommendationRecommendationDateCriterionList.IndexOf(value: TFhirImmunizationRecommendationRecommendationDateCriterion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Insert(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.InsertItem(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Item(index: Integer): TFhirImmunizationRecommendationRecommendationDateCriterion;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterion(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationRecommendationDateCriterionList.Link: TFhirImmunizationRecommendationRecommendationDateCriterionList;
begin
  result := TFhirImmunizationRecommendationRecommendationDateCriterionList(inherited Link);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  FhirImmunizationRecommendationRecommendationDateCriterions[index] := value;
end;

procedure TFhirImmunizationRecommendationRecommendationDateCriterionList.SetItemN(index: Integer; value: TFhirImmunizationRecommendationRecommendationDateCriterion);
begin
  assert(value is TFhirImmunizationRecommendationRecommendationDateCriterion);
  ObjectByIndex[index] := value;
end;

{ TFhirImmunizationRecommendation }

constructor TFhirImmunizationRecommendation.Create;
begin
  inherited;
end;

destructor TFhirImmunizationRecommendation.Destroy;
begin
  FIdentifierList.Free;
  FPatient.free;
  FDate.free;
  FAuthority.free;
  FRecommendationList.Free;
  inherited;
end;

procedure TFhirImmunizationRecommendation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirImmunizationRecommendation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirImmunizationRecommendation(oSource).FIdentifierList);
  end;
  patient := TFhirImmunizationRecommendation(oSource).patient.Clone;
  dateElement := TFhirImmunizationRecommendation(oSource).dateElement.Clone;
  authority := TFhirImmunizationRecommendation(oSource).authority.Clone;
  if (TFhirImmunizationRecommendation(oSource).FRecommendationList = nil) then
  begin
    FRecommendationList.free;
    FRecommendationList := nil;
  end
  else
  begin
    if FRecommendationList = nil then
      FRecommendationList := TFhirImmunizationRecommendationRecommendationList.Create;
    FRecommendationList.Assign(TFhirImmunizationRecommendation(oSource).FRecommendationList);
  end;
end;

function TFhirImmunizationRecommendation.GetResourceType : TFhirResourceType;
begin
  result := frtImmunizationRecommendation;
end;

procedure TFhirImmunizationRecommendation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'recommendation') Then
    list.addAll(self, 'recommendation', FRecommendationList);
end;

procedure TFhirImmunizationRecommendation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference', false, TFhirReference, FAuthority.Link));
  oList.add(TFHIRProperty.create(self, 'recommendation', 'BackboneElement', true, TFhirImmunizationRecommendationRecommendation, FRecommendationList.Link));
end;

function TFhirImmunizationRecommendation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    Authority := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'recommendation') then
  begin
    RecommendationList.add(propValue as TFhirImmunizationRecommendationRecommendation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirImmunizationRecommendation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'recommendation') then RecommendationList.insertItem(index, propValue as TFhirImmunizationRecommendationRecommendation)
  else inherited;
end;

function TFhirImmunizationRecommendation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'authority') then result := TFhirReference.create()
  else if (propName = 'recommendation') then result := RecommendationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirImmunizationRecommendation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'recommendation') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirImmunizationRecommendation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'recommendation') then deletePropertyValue('recommendation', RecommendationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirImmunizationRecommendation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'authority') then AuthorityElement := new as TFhirReference
  else if (propName = 'recommendation') then replacePropertyValue('recommendation', RecommendationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirImmunizationRecommendation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'recommendation') then RecommendationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirImmunizationRecommendation.fhirType : string;
begin
  result := 'ImmunizationRecommendation';
end;

function TFhirImmunizationRecommendation.Link : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(inherited Link);
end;

function TFhirImmunizationRecommendation.Clone : TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(inherited Clone);
end;

function TFhirImmunizationRecommendation.equals(other : TObject) : boolean; 
var
  o : TFhirImmunizationRecommendation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirImmunizationRecommendation)) then
    result := false
  else
  begin
    o := TFhirImmunizationRecommendation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(authorityElement, o.authorityElement, true) and 
      compareDeep(recommendationList, o.recommendationList, true);
  end;
end;

function TFhirImmunizationRecommendation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FPatient) and isEmptyProp(FDate) and isEmptyProp(FAuthority) and isEmptyProp(FrecommendationList);
end;

procedure TFhirImmunizationRecommendation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('patient');
  fields.add('date');
  fields.add('authority');
  fields.add('recommendation');
end;

function TFhirImmunizationRecommendation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRecommendationList.sizeInBytes(magic));
end;

function TFhirImmunizationRecommendation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirImmunizationRecommendation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirImmunizationRecommendation.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirImmunizationRecommendation.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirImmunizationRecommendation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirImmunizationRecommendation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirImmunizationRecommendation.SetAuthority(value : TFhirReference);
begin
  FAuthority.free;
  FAuthority := value;
end;

function TFhirImmunizationRecommendation.GetRecommendationList : TFhirImmunizationRecommendationRecommendationList;
begin
  if FRecommendationList = nil then
    FRecommendationList := TFhirImmunizationRecommendationRecommendationList.Create;
  result := FRecommendationList;
end;

function TFhirImmunizationRecommendation.GetHasRecommendationList : boolean;
begin
  result := (FRecommendationList <> nil) and (FRecommendationList.count > 0);
end;

{ TFhirImmunizationRecommendationListEnumerator }

constructor TFhirImmunizationRecommendationListEnumerator.Create(list : TFhirImmunizationRecommendationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirImmunizationRecommendationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirImmunizationRecommendationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirImmunizationRecommendationListEnumerator.GetCurrent : TFhirImmunizationRecommendation;
begin
  Result := FList[FIndex];
end;

function TFhirImmunizationRecommendationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirImmunizationRecommendationList }

function TFhirImmunizationRecommendationList.AddItem(value: TFhirImmunizationRecommendation): TFhirImmunizationRecommendation;
begin
  assert(value.ClassName = 'TFhirImmunizationRecommendation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirImmunizationRecommendation');
  add(value);
  result := value;
end;

function TFhirImmunizationRecommendationList.Append: TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationList.ClearItems;
begin
  Clear;
end;

function TFhirImmunizationRecommendationList.GetEnumerator : TFhirImmunizationRecommendationListEnumerator;
begin
  result := TFhirImmunizationRecommendationListEnumerator.Create(self.link);
end;

function TFhirImmunizationRecommendationList.Clone: TFhirImmunizationRecommendationList;
begin
  result := TFhirImmunizationRecommendationList(inherited Clone);
end;

function TFhirImmunizationRecommendationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirImmunizationRecommendationList.GetItemN(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationList.ItemClass: TFslObjectClass;
begin
  result := TFhirImmunizationRecommendation;
end;
function TFhirImmunizationRecommendationList.IndexOf(value: TFhirImmunizationRecommendation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirImmunizationRecommendationList.Insert(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirImmunizationRecommendationList.InsertItem(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  Inherited Insert(index, value);
end;

function TFhirImmunizationRecommendationList.Item(index: Integer): TFhirImmunizationRecommendation;
begin
  result := TFhirImmunizationRecommendation(ObjectByIndex[index]);
end;

function TFhirImmunizationRecommendationList.Link: TFhirImmunizationRecommendationList;
begin
  result := TFhirImmunizationRecommendationList(inherited Link);
end;

procedure TFhirImmunizationRecommendationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirImmunizationRecommendationList.SetItemByIndex(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  FhirImmunizationRecommendations[index] := value;
end;

procedure TFhirImmunizationRecommendationList.SetItemN(index: Integer; value: TFhirImmunizationRecommendation);
begin
  assert(value is TFhirImmunizationRecommendation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_IMMUNIZATIONRECOMMENDATION}
{$IFDEF FHIR_MEDICATIONADMINISTRATION}
{ TFhirMedicationAdministrationPerformer }

constructor TFhirMedicationAdministrationPerformer.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationPerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirMedicationAdministrationPerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirMedicationAdministrationPerformer(oSource).function_.Clone;
  actor := TFhirMedicationAdministrationPerformer(oSource).actor.Clone;
end;

procedure TFhirMedicationAdministrationPerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirMedicationAdministrationPerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
end;

function TFhirMedicationAdministrationPerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationAdministrationPerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationAdministrationPerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create()
  else if (propName = 'actor') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministrationPerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministrationPerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministrationPerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministrationPerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministrationPerformer.fhirType : string;
begin
  result := 'MedicationAdministration.performer';
end;

function TFhirMedicationAdministrationPerformer.Link : TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(inherited Link);
end;

function TFhirMedicationAdministrationPerformer.Clone : TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(inherited Clone);
end;

function TFhirMedicationAdministrationPerformer.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationAdministrationPerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministrationPerformer)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministrationPerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirMedicationAdministrationPerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirMedicationAdministrationPerformer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirMedicationAdministrationPerformer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationAdministrationPerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

procedure TFhirMedicationAdministrationPerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

{ TFhirMedicationAdministrationPerformerListEnumerator }

constructor TFhirMedicationAdministrationPerformerListEnumerator.Create(list : TFhirMedicationAdministrationPerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationPerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationPerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationPerformerListEnumerator.GetCurrent : TFhirMedicationAdministrationPerformer;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationPerformerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationAdministrationPerformerList }

function TFhirMedicationAdministrationPerformerList.AddItem(value: TFhirMedicationAdministrationPerformer): TFhirMedicationAdministrationPerformer;
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationPerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationPerformer');
  add(value);
  result := value;
end;

function TFhirMedicationAdministrationPerformerList.Append: TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationPerformerList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationPerformerList.GetEnumerator : TFhirMedicationAdministrationPerformerListEnumerator;
begin
  result := TFhirMedicationAdministrationPerformerListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationPerformerList.Clone: TFhirMedicationAdministrationPerformerList;
begin
  result := TFhirMedicationAdministrationPerformerList(inherited Clone);
end;

function TFhirMedicationAdministrationPerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationPerformerList.GetItemN(index: Integer): TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationPerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministrationPerformer;
end;
function TFhirMedicationAdministrationPerformerList.IndexOf(value: TFhirMedicationAdministrationPerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationPerformerList.Insert(index: Integer): TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationPerformerList.InsertItem(index: Integer; value: TFhirMedicationAdministrationPerformer);
begin
  assert(value is TFhirMedicationAdministrationPerformer);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationPerformerList.Item(index: Integer): TFhirMedicationAdministrationPerformer;
begin
  result := TFhirMedicationAdministrationPerformer(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationPerformerList.Link: TFhirMedicationAdministrationPerformerList;
begin
  result := TFhirMedicationAdministrationPerformerList(inherited Link);
end;

procedure TFhirMedicationAdministrationPerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationPerformerList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationPerformer);
begin
  assert(value is TFhirMedicationAdministrationPerformer);
  FhirMedicationAdministrationPerformers[index] := value;
end;

procedure TFhirMedicationAdministrationPerformerList.SetItemN(index: Integer; value: TFhirMedicationAdministrationPerformer);
begin
  assert(value is TFhirMedicationAdministrationPerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministrationDosage }

constructor TFhirMedicationAdministrationDosage.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministrationDosage.Destroy;
begin
  FText.free;
  FSite.free;
  FRoute.free;
  FMethod.free;
  FDose.free;
  FRate.free;
  inherited;
end;

procedure TFhirMedicationAdministrationDosage.Assign(oSource : TFslObject);
begin
  inherited;
  textElement := TFhirMedicationAdministrationDosage(oSource).textElement.Clone;
  site := TFhirMedicationAdministrationDosage(oSource).site.Clone;
  route := TFhirMedicationAdministrationDosage(oSource).route.Clone;
  method := TFhirMedicationAdministrationDosage(oSource).method.Clone;
  dose := TFhirMedicationAdministrationDosage(oSource).dose.Clone;
  rate := TFhirMedicationAdministrationDosage(oSource).rate.Clone;
end;

procedure TFhirMedicationAdministrationDosage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'route') Then
     list.add(self.link, 'route', FRoute.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'dose') Then
     list.add(self.link, 'dose', FDose.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
end;

procedure TFhirMedicationAdministrationDosage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'site', 'CodeableConcept', false, TFhirCodeableConcept, FSite.Link));
  oList.add(TFHIRProperty.create(self, 'route', 'CodeableConcept', false, TFhirCodeableConcept, FRoute.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'dose', 'Quantity', false, TFhirQuantity, FDose.Link));
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Ratio|Quantity', false, TFhirDataType, FRate.Link));
end;

function TFhirMedicationAdministrationDosage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    Site := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'route') then
  begin
    Route := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'dose') then
  begin
    Dose := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then
  begin
    Rate := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationAdministrationDosage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationAdministrationDosage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'site') then result := TFhirCodeableConcept.create()
  else if (propName = 'route') then result := TFhirCodeableConcept.create()
  else if (propName = 'method') then result := TFhirCodeableConcept.create()
  else if (propName = 'dose') then result := TFhirQuantity.create()
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then raise EFHIRException.create('Cannot make property Rate')
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministrationDosage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'text') then result := 'string'
  else if (propName = 'site') then result := 'CodeableConcept'
  else if (propName = 'route') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'dose') then result := 'Quantity'
  else if (propName = 'rate[x]') then result := 'Ratio|Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministrationDosage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'text') then TextElement := nil
  else if (propName = 'site') then SiteElement := nil
  else if (propName = 'route') then RouteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'dose') then DoseElement := nil
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then RateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministrationDosage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'site') then SiteElement := new as TFhirCodeableConcept
  else if (propName = 'route') then RouteElement := new as TFhirCodeableConcept
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else if (propName = 'dose') then DoseElement := new as TFhirQuantity
  else if (isMatchingName(propName, 'rate', ['Ratio', 'Quantity'])) then RateElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministrationDosage.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministrationDosage.fhirType : string;
begin
  result := 'MedicationAdministration.dosage';
end;

function TFhirMedicationAdministrationDosage.Link : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Link);
end;

function TFhirMedicationAdministrationDosage.Clone : TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(inherited Clone);
end;

function TFhirMedicationAdministrationDosage.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationAdministrationDosage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministrationDosage)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministrationDosage(other);
    result := compareDeep(textElement, o.textElement, true) and compareDeep(siteElement, o.siteElement, true) and 
      compareDeep(routeElement, o.routeElement, true) and compareDeep(methodElement, o.methodElement, true) and 
      compareDeep(doseElement, o.doseElement, true) and compareDeep(rateElement, o.rateElement, true);
  end;
end;

function TFhirMedicationAdministrationDosage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FText) and isEmptyProp(FSite) and isEmptyProp(FRoute) and isEmptyProp(FMethod) and isEmptyProp(FDose) and isEmptyProp(FRate);
end;

procedure TFhirMedicationAdministrationDosage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('text');
  fields.add('site');
  fields.add('route');
  fields.add('method');
  fields.add('dose');
  fields.add('rate[x]');
end;

function TFhirMedicationAdministrationDosage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationAdministrationDosage.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirMedicationAdministrationDosage.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirMedicationAdministrationDosage.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

procedure TFhirMedicationAdministrationDosage.SetSite(value : TFhirCodeableConcept);
begin
  FSite.free;
  FSite := value;
end;

procedure TFhirMedicationAdministrationDosage.SetRoute(value : TFhirCodeableConcept);
begin
  FRoute.free;
  FRoute := value;
end;

procedure TFhirMedicationAdministrationDosage.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

procedure TFhirMedicationAdministrationDosage.SetDose(value : TFhirQuantity);
begin
  FDose.free;
  FDose := value;
end;

procedure TFhirMedicationAdministrationDosage.SetRate(value : TFhirDataType);
begin
  FRate.free;
  FRate := value;
end;

{ TFhirMedicationAdministrationDosageListEnumerator }

constructor TFhirMedicationAdministrationDosageListEnumerator.Create(list : TFhirMedicationAdministrationDosageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationDosageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationDosageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationDosageListEnumerator.GetCurrent : TFhirMedicationAdministrationDosage;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationDosageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationAdministrationDosageList }

function TFhirMedicationAdministrationDosageList.AddItem(value: TFhirMedicationAdministrationDosage): TFhirMedicationAdministrationDosage;
begin
  assert(value.ClassName = 'TFhirMedicationAdministrationDosage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministrationDosage');
  add(value);
  result := value;
end;

function TFhirMedicationAdministrationDosageList.Append: TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationDosageList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationDosageList.GetEnumerator : TFhirMedicationAdministrationDosageListEnumerator;
begin
  result := TFhirMedicationAdministrationDosageListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationDosageList.Clone: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Clone);
end;

function TFhirMedicationAdministrationDosageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationDosageList.GetItemN(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministrationDosage;
end;
function TFhirMedicationAdministrationDosageList.IndexOf(value: TFhirMedicationAdministrationDosage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationDosageList.Insert(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationDosageList.InsertItem(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationDosageList.Item(index: Integer): TFhirMedicationAdministrationDosage;
begin
  result := TFhirMedicationAdministrationDosage(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationDosageList.Link: TFhirMedicationAdministrationDosageList;
begin
  result := TFhirMedicationAdministrationDosageList(inherited Link);
end;

procedure TFhirMedicationAdministrationDosageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationDosageList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  FhirMedicationAdministrationDosages[index] := value;
end;

procedure TFhirMedicationAdministrationDosageList.SetItemN(index: Integer; value: TFhirMedicationAdministrationDosage);
begin
  assert(value is TFhirMedicationAdministrationDosage);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationAdministration }

constructor TFhirMedicationAdministration.Create;
begin
  inherited;
end;

destructor TFhirMedicationAdministration.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesList.Free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReasonList.Free;
  FCategory.free;
  FMedication.free;
  FSubject.free;
  FContext.free;
  FSupportingInformationList.Free;
  FEffective.free;
  FPerformerList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FRequest.free;
  FDeviceList.Free;
  FNoteList.Free;
  FDosage.free;
  FEventHistoryList.Free;
  inherited;
end;

procedure TFhirMedicationAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationAdministration(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationAdministration(oSource).FIdentifierList);
  end;
  if (TFhirMedicationAdministration(oSource).FInstantiatesList = nil) then
  begin
    FInstantiatesList.free;
    FInstantiatesList := nil;
  end
  else
  begin
    if FInstantiatesList = nil then
      FInstantiatesList := TFhirUriList.Create;
    FInstantiatesList.Assign(TFhirMedicationAdministration(oSource).FInstantiatesList);
  end;
  if (TFhirMedicationAdministration(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirMedicationAdministration(oSource).FPartOfList);
  end;
  statusElement := TFhirMedicationAdministration(oSource).statusElement.Clone;
  if (TFhirMedicationAdministration(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirMedicationAdministration(oSource).FStatusReasonList);
  end;
  category := TFhirMedicationAdministration(oSource).category.Clone;
  medication := TFhirMedicationAdministration(oSource).medication.Clone;
  subject := TFhirMedicationAdministration(oSource).subject.Clone;
  context := TFhirMedicationAdministration(oSource).context.Clone;
  if (TFhirMedicationAdministration(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirMedicationAdministration(oSource).FSupportingInformationList);
  end;
  effective := TFhirMedicationAdministration(oSource).effective.Clone;
  if (TFhirMedicationAdministration(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirMedicationAdministrationPerformerList.Create;
    FPerformerList.Assign(TFhirMedicationAdministration(oSource).FPerformerList);
  end;
  if (TFhirMedicationAdministration(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirMedicationAdministration(oSource).FReasonCodeList);
  end;
  if (TFhirMedicationAdministration(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirMedicationAdministration(oSource).FReasonReferenceList);
  end;
  request := TFhirMedicationAdministration(oSource).request.Clone;
  if (TFhirMedicationAdministration(oSource).FDeviceList = nil) then
  begin
    FDeviceList.free;
    FDeviceList := nil;
  end
  else
  begin
    if FDeviceList = nil then
      FDeviceList := TFhirReferenceList.Create;
    FDeviceList.Assign(TFhirMedicationAdministration(oSource).FDeviceList);
  end;
  if (TFhirMedicationAdministration(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationAdministration(oSource).FNoteList);
  end;
  dosage := TFhirMedicationAdministration(oSource).dosage.Clone;
  if (TFhirMedicationAdministration(oSource).FEventHistoryList = nil) then
  begin
    FEventHistoryList.free;
    FEventHistoryList := nil;
  end
  else
  begin
    if FEventHistoryList = nil then
      FEventHistoryList := TFhirReferenceList.Create;
    FEventHistoryList.Assign(TFhirMedicationAdministration(oSource).FEventHistoryList);
  end;
end;

function TFhirMedicationAdministration.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationAdministration;
end;

procedure TFhirMedicationAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiates') Then
    list.addAll(self, 'instantiates', FInstantiatesList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'device') Then
    list.addAll(self, 'device', FDeviceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'dosage') Then
     list.add(self.link, 'dosage', FDosage.Link);
  if (child_name = 'eventHistory') Then
    list.addAll(self, 'eventHistory', FEventHistoryList);
end;

procedure TFhirMedicationAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiates', 'uri', true, TFhirUri, FInstantiatesList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference', false, TFhirDataType, FMedication.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'Reference', false, TFhirReference, FContext.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link));
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirDataType, FEffective.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirMedicationAdministrationPerformer, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', false, TFhirReference, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', true, TFhirReference, FDeviceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'dosage', 'BackboneElement', false, TFhirMedicationAdministrationDosage, FDosage.Link));
  oList.add(TFHIRProperty.create(self, 'eventHistory', 'Reference', true, TFhirReference, FEventHistoryList.Link));
end;

function TFhirMedicationAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiates') then
  begin
    InstantiatesList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum, CODES_TFhirMedicationAdministrationStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirMedicationAdministrationPerformer);
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    DeviceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    Dosage := propValue as TFhirMedicationAdministrationDosage;
    result := propValue;
  end
  else if (propName = 'eventHistory') then
  begin
    EventHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiates') then InstantiatesList.insertItem(index, asUri(propValue))
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirMedicationAdministrationPerformer)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'device') then DeviceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'eventHistory') then EventHistoryList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMedicationAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiates') then result := InstantiatesList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum[MedicationAdministrationStatusCodesNull], CODES_TFhirMedicationAdministrationStatusCodesEnum[MedicationAdministrationStatusCodesNull]) 
  else if (propName = 'statusReason') then result := StatusReasonList.new()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication')
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'context') then result := TFhirReference.create()
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new()
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective')
  else if (propName = 'performer') then result := PerformerList.new()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'request') then result := TFhirReference.create()
  else if (propName = 'device') then result := DeviceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'dosage') then result := TFhirMedicationAdministrationDosage.create()
  else if (propName = 'eventHistory') then result := EventHistoryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiates') then result := 'uri'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'dosage') then result := 'BackboneElement'
  else if (propName = 'eventHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiates') then deletePropertyValue('instantiates', InstantiatesList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value)
  else if (propName = 'category') then CategoryElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value)
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'device') then deletePropertyValue('device', DeviceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'dosage') then DosageElement := nil
  else if (propName = 'eventHistory') then deletePropertyValue('eventHistory', EventHistoryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiates') then replacePropertyValue('instantiates', InstantiatesList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum, CODES_TFhirMedicationAdministrationStatusCodesEnum, new)
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new)
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirDataType
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'context') then ContextElement := new as TFhirReference
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new)
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirDataType
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'request') then RequestElement := new as TFhirReference
  else if (propName = 'device') then replacePropertyValue('device', DeviceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'dosage') then DosageElement := new as TFhirMedicationAdministrationDosage
  else if (propName = 'eventHistory') then replacePropertyValue('eventHistory', EventHistoryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiates') then InstantiatesList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'statusReason') then StatusReasonList.move(source, destination)
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'device') then DeviceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'eventHistory') then EventHistoryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationAdministration.fhirType : string;
begin
  result := 'MedicationAdministration';
end;

function TFhirMedicationAdministration.Link : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(inherited Link);
end;

function TFhirMedicationAdministration.Clone : TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(inherited Clone);
end;

function TFhirMedicationAdministration.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationAdministration)) then
    result := false
  else
  begin
    o := TFhirMedicationAdministration(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesList, o.instantiatesList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonList, o.statusReasonList, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(contextElement, o.contextElement, true) and compareDeep(supportingInformationList, o.supportingInformationList, true) and 
      compareDeep(effectiveElement, o.effectiveElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(deviceList, o.deviceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(dosageElement, o.dosageElement, true) and 
      compareDeep(eventHistoryList, o.eventHistoryList, true);
  end;
end;

function TFhirMedicationAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FCategory) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FEffective) and isEmptyProp(FperformerList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FRequest) and isEmptyProp(FdeviceList) and isEmptyProp(FnoteList) and isEmptyProp(FDosage) and isEmptyProp(FeventHistoryList);
end;

procedure TFhirMedicationAdministration.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiates');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('medication[x]');
  fields.add('subject');
  fields.add('context');
  fields.add('supportingInformation');
  fields.add('effective[x]');
  fields.add('performer');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('request');
  fields.add('device');
  fields.add('note');
  fields.add('dosage');
  fields.add('eventHistory');
end;

function TFhirMedicationAdministration.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FStatusReasonList.sizeInBytes(magic));
  inc(result, FSupportingInformationList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FDeviceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FEventHistoryList.sizeInBytes(magic));
end;

function TFhirMedicationAdministration.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationAdministration.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirMedicationAdministration.GetInstantiatesList : TFhirUriList;
begin
  if FInstantiatesList = nil then
    FInstantiatesList := TFhirUriList.Create;
  result := FInstantiatesList;
end;

function TFhirMedicationAdministration.GetHasInstantiatesList : boolean;
begin
  result := (FInstantiatesList <> nil) and (FInstantiatesList.count > 0);
end;

function TFhirMedicationAdministration.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirMedicationAdministration.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirMedicationAdministration.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationAdministration.GetStatusST : TFhirMedicationAdministrationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationAdministrationStatusCodesEnum(0)
  else
    result := TFhirMedicationAdministrationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationAdministrationStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedicationAdministration.SetStatusST(value : TFhirMedicationAdministrationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationAdministrationStatusCodesEnum[value], CODES_TFhirMedicationAdministrationStatusCodesEnum[value]);
end;

function TFhirMedicationAdministration.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

function TFhirMedicationAdministration.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

procedure TFhirMedicationAdministration.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirMedicationAdministration.SetMedication(value : TFhirDataType);
begin
  FMedication.free;
  FMedication := value;
end;

procedure TFhirMedicationAdministration.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirMedicationAdministration.SetContext(value : TFhirReference);
begin
  FContext.free;
  FContext := value;
end;

function TFhirMedicationAdministration.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirMedicationAdministration.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

procedure TFhirMedicationAdministration.SetEffective(value : TFhirDataType);
begin
  FEffective.free;
  FEffective := value;
end;

function TFhirMedicationAdministration.GetPerformerList : TFhirMedicationAdministrationPerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirMedicationAdministrationPerformerList.Create;
  result := FPerformerList;
end;

function TFhirMedicationAdministration.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirMedicationAdministration.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirMedicationAdministration.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirMedicationAdministration.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirMedicationAdministration.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

procedure TFhirMedicationAdministration.SetRequest(value : TFhirReference);
begin
  FRequest.free;
  FRequest := value;
end;

function TFhirMedicationAdministration.GetDeviceList : TFhirReferenceList;
begin
  if FDeviceList = nil then
    FDeviceList := TFhirReferenceList.Create;
  result := FDeviceList;
end;

function TFhirMedicationAdministration.GetHasDeviceList : boolean;
begin
  result := (FDeviceList <> nil) and (FDeviceList.count > 0);
end;

function TFhirMedicationAdministration.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedicationAdministration.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirMedicationAdministration.SetDosage(value : TFhirMedicationAdministrationDosage);
begin
  FDosage.free;
  FDosage := value;
end;

function TFhirMedicationAdministration.GetEventHistoryList : TFhirReferenceList;
begin
  if FEventHistoryList = nil then
    FEventHistoryList := TFhirReferenceList.Create;
  result := FEventHistoryList;
end;

function TFhirMedicationAdministration.GetHasEventHistoryList : boolean;
begin
  result := (FEventHistoryList <> nil) and (FEventHistoryList.count > 0);
end;

{ TFhirMedicationAdministrationListEnumerator }

constructor TFhirMedicationAdministrationListEnumerator.Create(list : TFhirMedicationAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationAdministrationListEnumerator.GetCurrent : TFhirMedicationAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationAdministrationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationAdministrationList }

function TFhirMedicationAdministrationList.AddItem(value: TFhirMedicationAdministration): TFhirMedicationAdministration;
begin
  assert(value.ClassName = 'TFhirMedicationAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationAdministration');
  add(value);
  result := value;
end;

function TFhirMedicationAdministrationList.Append: TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationAdministrationList.GetEnumerator : TFhirMedicationAdministrationListEnumerator;
begin
  result := TFhirMedicationAdministrationListEnumerator.Create(self.link);
end;

function TFhirMedicationAdministrationList.Clone: TFhirMedicationAdministrationList;
begin
  result := TFhirMedicationAdministrationList(inherited Clone);
end;

function TFhirMedicationAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationAdministrationList.GetItemN(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationAdministration;
end;
function TFhirMedicationAdministrationList.IndexOf(value: TFhirMedicationAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationAdministrationList.Insert(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationAdministrationList.InsertItem(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  Inherited Insert(index, value);
end;

function TFhirMedicationAdministrationList.Item(index: Integer): TFhirMedicationAdministration;
begin
  result := TFhirMedicationAdministration(ObjectByIndex[index]);
end;

function TFhirMedicationAdministrationList.Link: TFhirMedicationAdministrationList;
begin
  result := TFhirMedicationAdministrationList(inherited Link);
end;

procedure TFhirMedicationAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationAdministrationList.SetItemByIndex(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  FhirMedicationAdministrations[index] := value;
end;

procedure TFhirMedicationAdministrationList.SetItemN(index: Integer; value: TFhirMedicationAdministration);
begin
  assert(value is TFhirMedicationAdministration);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONADMINISTRATION}
{$IFDEF FHIR_MEDICATIONDISPENSE}
{ TFhirMedicationDispensePerformer }

constructor TFhirMedicationDispensePerformer.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispensePerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  inherited;
end;

procedure TFhirMedicationDispensePerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirMedicationDispensePerformer(oSource).function_.Clone;
  actor := TFhirMedicationDispensePerformer(oSource).actor.Clone;
end;

procedure TFhirMedicationDispensePerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
end;

procedure TFhirMedicationDispensePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
end;

function TFhirMedicationDispensePerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispensePerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationDispensePerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create()
  else if (propName = 'actor') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispensePerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispensePerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispensePerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispensePerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispensePerformer.fhirType : string;
begin
  result := 'MedicationDispense.performer';
end;

function TFhirMedicationDispensePerformer.Link : TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(inherited Link);
end;

function TFhirMedicationDispensePerformer.Clone : TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(inherited Clone);
end;

function TFhirMedicationDispensePerformer.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationDispensePerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispensePerformer)) then
    result := false
  else
  begin
    o := TFhirMedicationDispensePerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true);
  end;
end;

function TFhirMedicationDispensePerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor);
end;

procedure TFhirMedicationDispensePerformer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
end;

function TFhirMedicationDispensePerformer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationDispensePerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

procedure TFhirMedicationDispensePerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

{ TFhirMedicationDispensePerformerListEnumerator }

constructor TFhirMedicationDispensePerformerListEnumerator.Create(list : TFhirMedicationDispensePerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispensePerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispensePerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispensePerformerListEnumerator.GetCurrent : TFhirMedicationDispensePerformer;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispensePerformerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationDispensePerformerList }

function TFhirMedicationDispensePerformerList.AddItem(value: TFhirMedicationDispensePerformer): TFhirMedicationDispensePerformer;
begin
  assert(value.ClassName = 'TFhirMedicationDispensePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispensePerformer');
  add(value);
  result := value;
end;

function TFhirMedicationDispensePerformerList.Append: TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispensePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispensePerformerList.GetEnumerator : TFhirMedicationDispensePerformerListEnumerator;
begin
  result := TFhirMedicationDispensePerformerListEnumerator.Create(self.link);
end;

function TFhirMedicationDispensePerformerList.Clone: TFhirMedicationDispensePerformerList;
begin
  result := TFhirMedicationDispensePerformerList(inherited Clone);
end;

function TFhirMedicationDispensePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispensePerformerList.GetItemN(index: Integer): TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(ObjectByIndex[index]);
end;

function TFhirMedicationDispensePerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispensePerformer;
end;
function TFhirMedicationDispensePerformerList.IndexOf(value: TFhirMedicationDispensePerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispensePerformerList.Insert(index: Integer): TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispensePerformerList.InsertItem(index: Integer; value: TFhirMedicationDispensePerformer);
begin
  assert(value is TFhirMedicationDispensePerformer);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispensePerformerList.Item(index: Integer): TFhirMedicationDispensePerformer;
begin
  result := TFhirMedicationDispensePerformer(ObjectByIndex[index]);
end;

function TFhirMedicationDispensePerformerList.Link: TFhirMedicationDispensePerformerList;
begin
  result := TFhirMedicationDispensePerformerList(inherited Link);
end;

procedure TFhirMedicationDispensePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispensePerformerList.SetItemByIndex(index: Integer; value: TFhirMedicationDispensePerformer);
begin
  assert(value is TFhirMedicationDispensePerformer);
  FhirMedicationDispensePerformers[index] := value;
end;

procedure TFhirMedicationDispensePerformerList.SetItemN(index: Integer; value: TFhirMedicationDispensePerformer);
begin
  assert(value is TFhirMedicationDispensePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispenseSubstitution }

constructor TFhirMedicationDispenseSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispenseSubstitution.Destroy;
begin
  FWasSubstituted.free;
  FType_.free;
  FReasonList.Free;
  FResponsiblePartyList.Free;
  inherited;
end;

procedure TFhirMedicationDispenseSubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  wasSubstitutedElement := TFhirMedicationDispenseSubstitution(oSource).wasSubstitutedElement.Clone;
  type_ := TFhirMedicationDispenseSubstitution(oSource).type_.Clone;
  if (TFhirMedicationDispenseSubstitution(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirMedicationDispenseSubstitution(oSource).FReasonList);
  end;
  if (TFhirMedicationDispenseSubstitution(oSource).FResponsiblePartyList = nil) then
  begin
    FResponsiblePartyList.free;
    FResponsiblePartyList := nil;
  end
  else
  begin
    if FResponsiblePartyList = nil then
      FResponsiblePartyList := TFhirReferenceList.Create;
    FResponsiblePartyList.Assign(TFhirMedicationDispenseSubstitution(oSource).FResponsiblePartyList);
  end;
end;

procedure TFhirMedicationDispenseSubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'wasSubstituted') Then
     list.add(self.link, 'wasSubstituted', FWasSubstituted.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'responsibleParty') Then
    list.addAll(self, 'responsibleParty', FResponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'wasSubstituted', 'boolean', false, TFhirBoolean, FWasSubstituted.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'responsibleParty', 'Reference', true, TFhirReference, FResponsiblePartyList.Link));
end;

function TFhirMedicationDispenseSubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'wasSubstituted') then
  begin
    WasSubstitutedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'responsibleParty') then
  begin
    ResponsiblePartyList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispenseSubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'responsibleParty') then ResponsiblePartyList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMedicationDispenseSubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'wasSubstituted') then result := TFhirBoolean.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'responsibleParty') then result := ResponsiblePartyList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispenseSubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'wasSubstituted') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'responsibleParty') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispenseSubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'wasSubstituted') then WasSubstitutedElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'responsibleParty') then deletePropertyValue('responsibleParty', ResponsiblePartyList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispenseSubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'wasSubstituted') then WasSubstitutedElement := asBoolean(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'responsibleParty') then replacePropertyValue('responsibleParty', ResponsiblePartyList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispenseSubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'responsibleParty') then ResponsiblePartyList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispenseSubstitution.fhirType : string;
begin
  result := 'MedicationDispense.substitution';
end;

function TFhirMedicationDispenseSubstitution.Link : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Link);
end;

function TFhirMedicationDispenseSubstitution.Clone : TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(inherited Clone);
end;

function TFhirMedicationDispenseSubstitution.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationDispenseSubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispenseSubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationDispenseSubstitution(other);
    result := compareDeep(wasSubstitutedElement, o.wasSubstitutedElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(responsiblePartyList, o.responsiblePartyList, true);
  end;
end;

function TFhirMedicationDispenseSubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWasSubstituted) and isEmptyProp(FType_) and isEmptyProp(FreasonList) and isEmptyProp(FresponsiblePartyList);
end;

procedure TFhirMedicationDispenseSubstitution.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('wasSubstituted');
  fields.add('type');
  fields.add('reason');
  fields.add('responsibleParty');
end;

function TFhirMedicationDispenseSubstitution.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FResponsiblePartyList.sizeInBytes(magic));
end;

procedure TFhirMedicationDispenseSubstitution.SetWasSubstituted(value : TFhirBoolean);
begin
  FWasSubstituted.free;
  FWasSubstituted := value;
end;

function TFhirMedicationDispenseSubstitution.GetWasSubstitutedST : Boolean;
begin
  if FWasSubstituted = nil then
    result := false
  else
    result := FWasSubstituted.value;
end;

procedure TFhirMedicationDispenseSubstitution.SetWasSubstitutedST(value : Boolean);
begin
  if FWasSubstituted = nil then
    FWasSubstituted := TFhirBoolean.create;
  FWasSubstituted.value := value
end;

procedure TFhirMedicationDispenseSubstitution.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMedicationDispenseSubstitution.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

function TFhirMedicationDispenseSubstitution.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirMedicationDispenseSubstitution.GetResponsiblePartyList : TFhirReferenceList;
begin
  if FResponsiblePartyList = nil then
    FResponsiblePartyList := TFhirReferenceList.Create;
  result := FResponsiblePartyList;
end;

function TFhirMedicationDispenseSubstitution.GetHasResponsiblePartyList : boolean;
begin
  result := (FResponsiblePartyList <> nil) and (FResponsiblePartyList.count > 0);
end;

{ TFhirMedicationDispenseSubstitutionListEnumerator }

constructor TFhirMedicationDispenseSubstitutionListEnumerator.Create(list : TFhirMedicationDispenseSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispenseSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.GetCurrent : TFhirMedicationDispenseSubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispenseSubstitutionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationDispenseSubstitutionList }

function TFhirMedicationDispenseSubstitutionList.AddItem(value: TFhirMedicationDispenseSubstitution): TFhirMedicationDispenseSubstitution;
begin
  assert(value.ClassName = 'TFhirMedicationDispenseSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispenseSubstitution');
  add(value);
  result := value;
end;

function TFhirMedicationDispenseSubstitutionList.Append: TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseSubstitutionList.GetEnumerator : TFhirMedicationDispenseSubstitutionListEnumerator;
begin
  result := TFhirMedicationDispenseSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseSubstitutionList.Clone: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Clone);
end;

function TFhirMedicationDispenseSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseSubstitutionList.GetItemN(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispenseSubstitution;
end;
function TFhirMedicationDispenseSubstitutionList.IndexOf(value: TFhirMedicationDispenseSubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispenseSubstitutionList.Insert(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseSubstitutionList.Item(index: Integer): TFhirMedicationDispenseSubstitution;
begin
  result := TFhirMedicationDispenseSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseSubstitutionList.Link: TFhirMedicationDispenseSubstitutionList;
begin
  result := TFhirMedicationDispenseSubstitutionList(inherited Link);
end;

procedure TFhirMedicationDispenseSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  FhirMedicationDispenseSubstitutions[index] := value;
end;

procedure TFhirMedicationDispenseSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationDispenseSubstitution);
begin
  assert(value is TFhirMedicationDispenseSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationDispense }

constructor TFhirMedicationDispense.Create;
begin
  inherited;
end;

destructor TFhirMedicationDispense.Destroy;
begin
  FIdentifierList.Free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReason.free;
  FCategory.free;
  FMedication.free;
  FSubject.free;
  FContext.free;
  FSupportingInformationList.Free;
  FPerformerList.Free;
  FLocation.free;
  FAuthorizingPrescriptionList.Free;
  FType_.free;
  FQuantity.free;
  FDaysSupply.free;
  FWhenPrepared.free;
  FWhenHandedOver.free;
  FDestination.free;
  FReceiverList.Free;
  FNoteList.Free;
  FDosageInstructionList.Free;
  FSubstitution.free;
  FDetectedIssueList.Free;
  FEventHistoryList.Free;
  inherited;
end;

procedure TFhirMedicationDispense.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationDispense(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationDispense(oSource).FIdentifierList);
  end;
  if (TFhirMedicationDispense(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirMedicationDispense(oSource).FPartOfList);
  end;
  statusElement := TFhirMedicationDispense(oSource).statusElement.Clone;
  statusReason := TFhirMedicationDispense(oSource).statusReason.Clone;
  category := TFhirMedicationDispense(oSource).category.Clone;
  medication := TFhirMedicationDispense(oSource).medication.Clone;
  subject := TFhirMedicationDispense(oSource).subject.Clone;
  context := TFhirMedicationDispense(oSource).context.Clone;
  if (TFhirMedicationDispense(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirMedicationDispense(oSource).FSupportingInformationList);
  end;
  if (TFhirMedicationDispense(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirMedicationDispensePerformerList.Create;
    FPerformerList.Assign(TFhirMedicationDispense(oSource).FPerformerList);
  end;
  location := TFhirMedicationDispense(oSource).location.Clone;
  if (TFhirMedicationDispense(oSource).FAuthorizingPrescriptionList = nil) then
  begin
    FAuthorizingPrescriptionList.free;
    FAuthorizingPrescriptionList := nil;
  end
  else
  begin
    if FAuthorizingPrescriptionList = nil then
      FAuthorizingPrescriptionList := TFhirReferenceList.Create;
    FAuthorizingPrescriptionList.Assign(TFhirMedicationDispense(oSource).FAuthorizingPrescriptionList);
  end;
  type_ := TFhirMedicationDispense(oSource).type_.Clone;
  quantity := TFhirMedicationDispense(oSource).quantity.Clone;
  daysSupply := TFhirMedicationDispense(oSource).daysSupply.Clone;
  whenPreparedElement := TFhirMedicationDispense(oSource).whenPreparedElement.Clone;
  whenHandedOverElement := TFhirMedicationDispense(oSource).whenHandedOverElement.Clone;
  destination := TFhirMedicationDispense(oSource).destination.Clone;
  if (TFhirMedicationDispense(oSource).FReceiverList = nil) then
  begin
    FReceiverList.free;
    FReceiverList := nil;
  end
  else
  begin
    if FReceiverList = nil then
      FReceiverList := TFhirReferenceList.Create;
    FReceiverList.Assign(TFhirMedicationDispense(oSource).FReceiverList);
  end;
  if (TFhirMedicationDispense(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationDispense(oSource).FNoteList);
  end;
  if (TFhirMedicationDispense(oSource).FDosageInstructionList = nil) then
  begin
    FDosageInstructionList.free;
    FDosageInstructionList := nil;
  end
  else
  begin
    if FDosageInstructionList = nil then
      FDosageInstructionList := TFhirDosageList.Create;
    FDosageInstructionList.Assign(TFhirMedicationDispense(oSource).FDosageInstructionList);
  end;
  substitution := TFhirMedicationDispense(oSource).substitution.Clone;
  if (TFhirMedicationDispense(oSource).FDetectedIssueList = nil) then
  begin
    FDetectedIssueList.free;
    FDetectedIssueList := nil;
  end
  else
  begin
    if FDetectedIssueList = nil then
      FDetectedIssueList := TFhirReferenceList.Create;
    FDetectedIssueList.Assign(TFhirMedicationDispense(oSource).FDetectedIssueList);
  end;
  if (TFhirMedicationDispense(oSource).FEventHistoryList = nil) then
  begin
    FEventHistoryList.free;
    FEventHistoryList := nil;
  end
  else
  begin
    if FEventHistoryList = nil then
      FEventHistoryList := TFhirReferenceList.Create;
    FEventHistoryList.Assign(TFhirMedicationDispense(oSource).FEventHistoryList);
  end;
end;

function TFhirMedicationDispense.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationDispense;
end;

procedure TFhirMedicationDispense.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason[x]') or (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason[x]', FStatusReason.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'authorizingPrescription') Then
    list.addAll(self, 'authorizingPrescription', FAuthorizingPrescriptionList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'daysSupply') Then
     list.add(self.link, 'daysSupply', FDaysSupply.Link);
  if (child_name = 'whenPrepared') Then
     list.add(self.link, 'whenPrepared', FWhenPrepared.Link);
  if (child_name = 'whenHandedOver') Then
     list.add(self.link, 'whenHandedOver', FWhenHandedOver.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'receiver') Then
    list.addAll(self, 'receiver', FReceiverList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'dosageInstruction') Then
    list.addAll(self, 'dosageInstruction', FDosageInstructionList);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
  if (child_name = 'detectedIssue') Then
    list.addAll(self, 'detectedIssue', FDetectedIssueList);
  if (child_name = 'eventHistory') Then
    list.addAll(self, 'eventHistory', FEventHistoryList);
end;

procedure TFhirMedicationDispense.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason[x]', 'CodeableConcept|Reference', false, TFhirDataType, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference', false, TFhirDataType, FMedication.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'Reference', false, TFhirReference, FContext.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirMedicationDispensePerformer, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'authorizingPrescription', 'Reference', true, TFhirReference, FAuthorizingPrescriptionList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'daysSupply', 'Quantity', false, TFhirQuantity, FDaysSupply.Link));
  oList.add(TFHIRProperty.create(self, 'whenPrepared', 'dateTime', false, TFhirDateTime, FWhenPrepared.Link));
  oList.add(TFHIRProperty.create(self, 'whenHandedOver', 'dateTime', false, TFhirDateTime, FWhenHandedOver.Link));
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference', false, TFhirReference, FDestination.Link));
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference', true, TFhirReference, FReceiverList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'dosageInstruction', 'Dosage', true, TFhirDosage, FDosageInstructionList.Link));
  oList.add(TFHIRProperty.create(self, 'substitution', 'BackboneElement', false, TFhirMedicationDispenseSubstitution, FSubstitution.Link));
  oList.add(TFHIRProperty.create(self, 'detectedIssue', 'Reference', true, TFhirReference, FDetectedIssueList.Link));
  oList.add(TFHIRProperty.create(self, 'eventHistory', 'Reference', true, TFhirReference, FEventHistoryList.Link));
end;

function TFhirMedicationDispense.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationDispenseStatusCodesEnum, CODES_TFhirMedicationDispenseStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'statusReason', ['CodeableConcept', 'Reference'])) then
  begin
    StatusReason := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirMedicationDispensePerformer);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'authorizingPrescription') then
  begin
    AuthorizingPrescriptionList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'daysSupply') then
  begin
    DaysSupply := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'whenPrepared') then
  begin
    WhenPreparedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'whenHandedOver') then
  begin
    WhenHandedOverElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    ReceiverList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'dosageInstruction') then
  begin
    DosageInstructionList.add(propValue as TFhirDosage);
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirMedicationDispenseSubstitution;
    result := propValue;
  end
  else if (propName = 'detectedIssue') then
  begin
    DetectedIssueList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'eventHistory') then
  begin
    EventHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationDispense.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirMedicationDispensePerformer)
  else if (propName = 'authorizingPrescription') then AuthorizingPrescriptionList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'receiver') then ReceiverList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'dosageInstruction') then DosageInstructionList.insertItem(index, propValue as TFhirDosage)
  else if (propName = 'detectedIssue') then DetectedIssueList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'eventHistory') then EventHistoryList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMedicationDispense.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationDispenseStatusCodesEnum[MedicationDispenseStatusCodesNull], CODES_TFhirMedicationDispenseStatusCodesEnum[MedicationDispenseStatusCodesNull]) 
  else if (isMatchingName(propName, 'statusReason', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property StatusReason')
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication')
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'context') then result := TFhirReference.create()
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new()
  else if (propName = 'performer') then result := PerformerList.new()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'authorizingPrescription') then result := AuthorizingPrescriptionList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'daysSupply') then result := TFhirQuantity.create()
  else if (propName = 'whenPrepared') then result := TFhirDateTime.create()
  else if (propName = 'whenHandedOver') then result := TFhirDateTime.create()
  else if (propName = 'destination') then result := TFhirReference.create()
  else if (propName = 'receiver') then result := ReceiverList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'dosageInstruction') then result := DosageInstructionList.new()
  else if (propName = 'substitution') then result := TFhirMedicationDispenseSubstitution.create()
  else if (propName = 'detectedIssue') then result := DetectedIssueList.new()
  else if (propName = 'eventHistory') then result := EventHistoryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationDispense.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'authorizingPrescription') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'daysSupply') then result := 'Quantity'
  else if (propName = 'whenPrepared') then result := 'dateTime'
  else if (propName = 'whenHandedOver') then result := 'dateTime'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'receiver') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'dosageInstruction') then result := 'Dosage'
  else if (propName = 'substitution') then result := 'BackboneElement'
  else if (propName = 'detectedIssue') then result := 'Reference'
  else if (propName = 'eventHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationDispense.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (isMatchingName(propName, 'statusReason', ['CodeableConcept', 'Reference'])) then StatusReasonElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value)
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'authorizingPrescription') then deletePropertyValue('authorizingPrescription', AuthorizingPrescriptionList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'daysSupply') then DaysSupplyElement := nil
  else if (propName = 'whenPrepared') then WhenPreparedElement := nil
  else if (propName = 'whenHandedOver') then WhenHandedOverElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'receiver') then deletePropertyValue('receiver', ReceiverList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'dosageInstruction') then deletePropertyValue('dosageInstruction', DosageInstructionList, value)
  else if (propName = 'substitution') then SubstitutionElement := nil
  else if (propName = 'detectedIssue') then deletePropertyValue('detectedIssue', DetectedIssueList, value)
  else if (propName = 'eventHistory') then deletePropertyValue('eventHistory', EventHistoryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationDispense.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationDispenseStatusCodesEnum, CODES_TFhirMedicationDispenseStatusCodesEnum, new)
  else if (isMatchingName(propName, 'statusReason', ['CodeableConcept', 'Reference'])) then StatusReasonElement := new as TFhirDataType
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirDataType
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'context') then ContextElement := new as TFhirReference
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new)
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'authorizingPrescription') then replacePropertyValue('authorizingPrescription', AuthorizingPrescriptionList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'daysSupply') then DaysSupplyElement := new as TFhirQuantity
  else if (propName = 'whenPrepared') then WhenPreparedElement := asDateTime(new)
  else if (propName = 'whenHandedOver') then WhenHandedOverElement := asDateTime(new)
  else if (propName = 'destination') then DestinationElement := new as TFhirReference
  else if (propName = 'receiver') then replacePropertyValue('receiver', ReceiverList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'dosageInstruction') then replacePropertyValue('dosageInstruction', DosageInstructionList, existing, new)
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirMedicationDispenseSubstitution
  else if (propName = 'detectedIssue') then replacePropertyValue('detectedIssue', DetectedIssueList, existing, new)
  else if (propName = 'eventHistory') then replacePropertyValue('eventHistory', EventHistoryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationDispense.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'authorizingPrescription') then AuthorizingPrescriptionList.move(source, destination)
  else if (propName = 'receiver') then ReceiverList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'dosageInstruction') then DosageInstructionList.move(source, destination)
  else if (propName = 'detectedIssue') then DetectedIssueList.move(source, destination)
  else if (propName = 'eventHistory') then EventHistoryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationDispense.fhirType : string;
begin
  result := 'MedicationDispense';
end;

function TFhirMedicationDispense.Link : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(inherited Link);
end;

function TFhirMedicationDispense.Clone : TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(inherited Clone);
end;

function TFhirMedicationDispense.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationDispense;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationDispense)) then
    result := false
  else
  begin
    o := TFhirMedicationDispense(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(medicationElement, o.medicationElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(contextElement, o.contextElement, true) and 
      compareDeep(supportingInformationList, o.supportingInformationList, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(authorizingPrescriptionList, o.authorizingPrescriptionList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(daysSupplyElement, o.daysSupplyElement, true) and compareDeep(whenPreparedElement, o.whenPreparedElement, true) and 
      compareDeep(whenHandedOverElement, o.whenHandedOverElement, true) and compareDeep(destinationElement, o.destinationElement, true) and 
      compareDeep(receiverList, o.receiverList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(dosageInstructionList, o.dosageInstructionList, true) and compareDeep(substitutionElement, o.substitutionElement, true) and 
      compareDeep(detectedIssueList, o.detectedIssueList, true) and compareDeep(eventHistoryList, o.eventHistoryList, true);
  end;
end;

function TFhirMedicationDispense.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FCategory) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FperformerList) and isEmptyProp(FLocation) and isEmptyProp(FauthorizingPrescriptionList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FDaysSupply) and isEmptyProp(FWhenPrepared) and isEmptyProp(FWhenHandedOver) and isEmptyProp(FDestination) and isEmptyProp(FreceiverList) and isEmptyProp(FnoteList) and isEmptyProp(FdosageInstructionList) and isEmptyProp(FSubstitution) and isEmptyProp(FdetectedIssueList) and isEmptyProp(FeventHistoryList);
end;

procedure TFhirMedicationDispense.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason[x]');
  fields.add('category');
  fields.add('medication[x]');
  fields.add('subject');
  fields.add('context');
  fields.add('supportingInformation');
  fields.add('performer');
  fields.add('location');
  fields.add('authorizingPrescription');
  fields.add('type');
  fields.add('quantity');
  fields.add('daysSupply');
  fields.add('whenPrepared');
  fields.add('whenHandedOver');
  fields.add('destination');
  fields.add('receiver');
  fields.add('note');
  fields.add('dosageInstruction');
  fields.add('substitution');
  fields.add('detectedIssue');
  fields.add('eventHistory');
end;

function TFhirMedicationDispense.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FSupportingInformationList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FAuthorizingPrescriptionList.sizeInBytes(magic));
  inc(result, FReceiverList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FDosageInstructionList.sizeInBytes(magic));
  inc(result, FDetectedIssueList.sizeInBytes(magic));
  inc(result, FEventHistoryList.sizeInBytes(magic));
end;

function TFhirMedicationDispense.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationDispense.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirMedicationDispense.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirMedicationDispense.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirMedicationDispense.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationDispense.GetStatusST : TFhirMedicationDispenseStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationDispenseStatusCodesEnum(0)
  else
    result := TFhirMedicationDispenseStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationDispenseStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedicationDispense.SetStatusST(value : TFhirMedicationDispenseStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationDispenseStatusCodesEnum[value], CODES_TFhirMedicationDispenseStatusCodesEnum[value]);
end;

procedure TFhirMedicationDispense.SetStatusReason(value : TFhirDataType);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

procedure TFhirMedicationDispense.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirMedicationDispense.SetMedication(value : TFhirDataType);
begin
  FMedication.free;
  FMedication := value;
end;

procedure TFhirMedicationDispense.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirMedicationDispense.SetContext(value : TFhirReference);
begin
  FContext.free;
  FContext := value;
end;

function TFhirMedicationDispense.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirMedicationDispense.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

function TFhirMedicationDispense.GetPerformerList : TFhirMedicationDispensePerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirMedicationDispensePerformerList.Create;
  result := FPerformerList;
end;

function TFhirMedicationDispense.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirMedicationDispense.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirMedicationDispense.GetAuthorizingPrescriptionList : TFhirReferenceList;
begin
  if FAuthorizingPrescriptionList = nil then
    FAuthorizingPrescriptionList := TFhirReferenceList.Create;
  result := FAuthorizingPrescriptionList;
end;

function TFhirMedicationDispense.GetHasAuthorizingPrescriptionList : boolean;
begin
  result := (FAuthorizingPrescriptionList <> nil) and (FAuthorizingPrescriptionList.count > 0);
end;

procedure TFhirMedicationDispense.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedicationDispense.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirMedicationDispense.SetDaysSupply(value : TFhirQuantity);
begin
  FDaysSupply.free;
  FDaysSupply := value;
end;

procedure TFhirMedicationDispense.SetWhenPrepared(value : TFhirDateTime);
begin
  FWhenPrepared.free;
  FWhenPrepared := value;
end;

function TFhirMedicationDispense.GetWhenPreparedST : TFslDateTime;
begin
  if FWhenPrepared = nil then
    result := TFslDateTime.makeNull
  else
    result := FWhenPrepared.value;
end;

procedure TFhirMedicationDispense.SetWhenPreparedST(value : TFslDateTime);
begin
  if FWhenPrepared = nil then
    FWhenPrepared := TFhirDateTime.create;
  FWhenPrepared.value := value
end;

procedure TFhirMedicationDispense.SetWhenHandedOver(value : TFhirDateTime);
begin
  FWhenHandedOver.free;
  FWhenHandedOver := value;
end;

function TFhirMedicationDispense.GetWhenHandedOverST : TFslDateTime;
begin
  if FWhenHandedOver = nil then
    result := TFslDateTime.makeNull
  else
    result := FWhenHandedOver.value;
end;

procedure TFhirMedicationDispense.SetWhenHandedOverST(value : TFslDateTime);
begin
  if FWhenHandedOver = nil then
    FWhenHandedOver := TFhirDateTime.create;
  FWhenHandedOver.value := value
end;

procedure TFhirMedicationDispense.SetDestination(value : TFhirReference);
begin
  FDestination.free;
  FDestination := value;
end;

function TFhirMedicationDispense.GetReceiverList : TFhirReferenceList;
begin
  if FReceiverList = nil then
    FReceiverList := TFhirReferenceList.Create;
  result := FReceiverList;
end;

function TFhirMedicationDispense.GetHasReceiverList : boolean;
begin
  result := (FReceiverList <> nil) and (FReceiverList.count > 0);
end;

function TFhirMedicationDispense.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedicationDispense.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirMedicationDispense.GetDosageInstructionList : TFhirDosageList;
begin
  if FDosageInstructionList = nil then
    FDosageInstructionList := TFhirDosageList.Create;
  result := FDosageInstructionList;
end;

function TFhirMedicationDispense.GetHasDosageInstructionList : boolean;
begin
  result := (FDosageInstructionList <> nil) and (FDosageInstructionList.count > 0);
end;

procedure TFhirMedicationDispense.SetSubstitution(value : TFhirMedicationDispenseSubstitution);
begin
  FSubstitution.free;
  FSubstitution := value;
end;

function TFhirMedicationDispense.GetDetectedIssueList : TFhirReferenceList;
begin
  if FDetectedIssueList = nil then
    FDetectedIssueList := TFhirReferenceList.Create;
  result := FDetectedIssueList;
end;

function TFhirMedicationDispense.GetHasDetectedIssueList : boolean;
begin
  result := (FDetectedIssueList <> nil) and (FDetectedIssueList.count > 0);
end;

function TFhirMedicationDispense.GetEventHistoryList : TFhirReferenceList;
begin
  if FEventHistoryList = nil then
    FEventHistoryList := TFhirReferenceList.Create;
  result := FEventHistoryList;
end;

function TFhirMedicationDispense.GetHasEventHistoryList : boolean;
begin
  result := (FEventHistoryList <> nil) and (FEventHistoryList.count > 0);
end;

{ TFhirMedicationDispenseListEnumerator }

constructor TFhirMedicationDispenseListEnumerator.Create(list : TFhirMedicationDispenseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationDispenseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationDispenseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationDispenseListEnumerator.GetCurrent : TFhirMedicationDispense;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationDispenseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationDispenseList }

function TFhirMedicationDispenseList.AddItem(value: TFhirMedicationDispense): TFhirMedicationDispense;
begin
  assert(value.ClassName = 'TFhirMedicationDispense', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationDispense');
  add(value);
  result := value;
end;

function TFhirMedicationDispenseList.Append: TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationDispenseList.GetEnumerator : TFhirMedicationDispenseListEnumerator;
begin
  result := TFhirMedicationDispenseListEnumerator.Create(self.link);
end;

function TFhirMedicationDispenseList.Clone: TFhirMedicationDispenseList;
begin
  result := TFhirMedicationDispenseList(inherited Clone);
end;

function TFhirMedicationDispenseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationDispenseList.GetItemN(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationDispense;
end;
function TFhirMedicationDispenseList.IndexOf(value: TFhirMedicationDispense): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationDispenseList.Insert(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationDispenseList.InsertItem(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  Inherited Insert(index, value);
end;

function TFhirMedicationDispenseList.Item(index: Integer): TFhirMedicationDispense;
begin
  result := TFhirMedicationDispense(ObjectByIndex[index]);
end;

function TFhirMedicationDispenseList.Link: TFhirMedicationDispenseList;
begin
  result := TFhirMedicationDispenseList(inherited Link);
end;

procedure TFhirMedicationDispenseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationDispenseList.SetItemByIndex(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  FhirMedicationDispenses[index] := value;
end;

procedure TFhirMedicationDispenseList.SetItemN(index: Integer; value: TFhirMedicationDispense);
begin
  assert(value is TFhirMedicationDispense);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONDISPENSE}
{$IFDEF FHIR_MEDICATIONREQUEST}
{ TFhirMedicationRequestDispenseRequest }

constructor TFhirMedicationRequestDispenseRequest.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequestDispenseRequest.Destroy;
begin
  FInitialFill.free;
  FDispenseInterval.free;
  FValidityPeriod.free;
  FNumberOfRepeatsAllowed.free;
  FQuantity.free;
  FExpectedSupplyDuration.free;
  FPerformer.free;
  inherited;
end;

procedure TFhirMedicationRequestDispenseRequest.Assign(oSource : TFslObject);
begin
  inherited;
  initialFill := TFhirMedicationRequestDispenseRequest(oSource).initialFill.Clone;
  dispenseInterval := TFhirMedicationRequestDispenseRequest(oSource).dispenseInterval.Clone;
  validityPeriod := TFhirMedicationRequestDispenseRequest(oSource).validityPeriod.Clone;
  numberOfRepeatsAllowedElement := TFhirMedicationRequestDispenseRequest(oSource).numberOfRepeatsAllowedElement.Clone;
  quantity := TFhirMedicationRequestDispenseRequest(oSource).quantity.Clone;
  expectedSupplyDuration := TFhirMedicationRequestDispenseRequest(oSource).expectedSupplyDuration.Clone;
  performer := TFhirMedicationRequestDispenseRequest(oSource).performer.Clone;
end;

procedure TFhirMedicationRequestDispenseRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'initialFill') Then
     list.add(self.link, 'initialFill', FInitialFill.Link);
  if (child_name = 'dispenseInterval') Then
     list.add(self.link, 'dispenseInterval', FDispenseInterval.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'numberOfRepeatsAllowed') Then
     list.add(self.link, 'numberOfRepeatsAllowed', FNumberOfRepeatsAllowed.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'expectedSupplyDuration') Then
     list.add(self.link, 'expectedSupplyDuration', FExpectedSupplyDuration.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
end;

procedure TFhirMedicationRequestDispenseRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'initialFill', 'BackboneElement', false, TFhirMedicationRequestDispenseRequestInitialFill, FInitialFill.Link));
  oList.add(TFHIRProperty.create(self, 'dispenseInterval', 'Duration', false, TFhirDuration, FDispenseInterval.Link));
  oList.add(TFHIRProperty.create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfRepeatsAllowed', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfRepeatsAllowed.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'expectedSupplyDuration', 'Duration', false, TFhirDuration, FExpectedSupplyDuration.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link));
end;

function TFhirMedicationRequestDispenseRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'initialFill') then
  begin
    InitialFill := propValue as TFhirMedicationRequestDispenseRequestInitialFill;
    result := propValue;
  end
  else if (propName = 'dispenseInterval') then
  begin
    DispenseInterval := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'numberOfRepeatsAllowed') then
  begin
    NumberOfRepeatsAllowedElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'expectedSupplyDuration') then
  begin
    ExpectedSupplyDuration := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequestDispenseRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationRequestDispenseRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'initialFill') then result := TFhirMedicationRequestDispenseRequestInitialFill.create()
  else if (propName = 'dispenseInterval') then result := TFhirDuration.create()
  else if (propName = 'validityPeriod') then result := TFhirPeriod.create()
  else if (propName = 'numberOfRepeatsAllowed') then result := TFhirUnsignedInt.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'expectedSupplyDuration') then result := TFhirDuration.create()
  else if (propName = 'performer') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequestDispenseRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'initialFill') then result := 'BackboneElement'
  else if (propName = 'dispenseInterval') then result := 'Duration'
  else if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'numberOfRepeatsAllowed') then result := 'unsignedInt'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'expectedSupplyDuration') then result := 'Duration'
  else if (propName = 'performer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequestDispenseRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'initialFill') then InitialFillElement := nil
  else if (propName = 'dispenseInterval') then DispenseIntervalElement := nil
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (propName = 'numberOfRepeatsAllowed') then NumberOfRepeatsAllowedElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'expectedSupplyDuration') then ExpectedSupplyDurationElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequestDispenseRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'initialFill') then InitialFillElement := new as TFhirMedicationRequestDispenseRequestInitialFill
  else if (propName = 'dispenseInterval') then DispenseIntervalElement := new as TFhirDuration
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod
  else if (propName = 'numberOfRepeatsAllowed') then NumberOfRepeatsAllowedElement := asUnsignedInt(new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'expectedSupplyDuration') then ExpectedSupplyDurationElement := new as TFhirDuration
  else if (propName = 'performer') then PerformerElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequestDispenseRequest.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequestDispenseRequest.fhirType : string;
begin
  result := 'MedicationRequest.dispenseRequest';
end;

function TFhirMedicationRequestDispenseRequest.Link : TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(inherited Link);
end;

function TFhirMedicationRequestDispenseRequest.Clone : TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequest.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationRequestDispenseRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequestDispenseRequest)) then
    result := false
  else
  begin
    o := TFhirMedicationRequestDispenseRequest(other);
    result := compareDeep(initialFillElement, o.initialFillElement, true) and compareDeep(dispenseIntervalElement, o.dispenseIntervalElement, true) and 
      compareDeep(validityPeriodElement, o.validityPeriodElement, true) and compareDeep(numberOfRepeatsAllowedElement, o.numberOfRepeatsAllowedElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(expectedSupplyDurationElement, o.expectedSupplyDurationElement, true) and 
      compareDeep(performerElement, o.performerElement, true);
  end;
end;

function TFhirMedicationRequestDispenseRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FInitialFill) and isEmptyProp(FDispenseInterval) and isEmptyProp(FValidityPeriod) and isEmptyProp(FNumberOfRepeatsAllowed) and isEmptyProp(FQuantity) and isEmptyProp(FExpectedSupplyDuration) and isEmptyProp(FPerformer);
end;

procedure TFhirMedicationRequestDispenseRequest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('initialFill');
  fields.add('dispenseInterval');
  fields.add('validityPeriod');
  fields.add('numberOfRepeatsAllowed');
  fields.add('quantity');
  fields.add('expectedSupplyDuration');
  fields.add('performer');
end;

function TFhirMedicationRequestDispenseRequest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationRequestDispenseRequest.SetInitialFill(value : TFhirMedicationRequestDispenseRequestInitialFill);
begin
  FInitialFill.free;
  FInitialFill := value;
end;

procedure TFhirMedicationRequestDispenseRequest.SetDispenseInterval(value : TFhirDuration);
begin
  FDispenseInterval.free;
  FDispenseInterval := value;
end;

procedure TFhirMedicationRequestDispenseRequest.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

procedure TFhirMedicationRequestDispenseRequest.SetNumberOfRepeatsAllowed(value : TFhirUnsignedInt);
begin
  FNumberOfRepeatsAllowed.free;
  FNumberOfRepeatsAllowed := value;
end;

function TFhirMedicationRequestDispenseRequest.GetNumberOfRepeatsAllowedST : String;
begin
  if FNumberOfRepeatsAllowed = nil then
    result := ''
  else
    result := FNumberOfRepeatsAllowed.value;
end;

procedure TFhirMedicationRequestDispenseRequest.SetNumberOfRepeatsAllowedST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfRepeatsAllowed = nil then
      FNumberOfRepeatsAllowed := TFhirUnsignedInt.create;
    FNumberOfRepeatsAllowed.value := value
  end
  else if FNumberOfRepeatsAllowed <> nil then
    FNumberOfRepeatsAllowed.value := '';
end;

procedure TFhirMedicationRequestDispenseRequest.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirMedicationRequestDispenseRequest.SetExpectedSupplyDuration(value : TFhirDuration);
begin
  FExpectedSupplyDuration.free;
  FExpectedSupplyDuration := value;
end;

procedure TFhirMedicationRequestDispenseRequest.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value;
end;

{ TFhirMedicationRequestDispenseRequestListEnumerator }

constructor TFhirMedicationRequestDispenseRequestListEnumerator.Create(list : TFhirMedicationRequestDispenseRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestDispenseRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestDispenseRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestDispenseRequestListEnumerator.GetCurrent : TFhirMedicationRequestDispenseRequest;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestDispenseRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationRequestDispenseRequestList }

function TFhirMedicationRequestDispenseRequestList.AddItem(value: TFhirMedicationRequestDispenseRequest): TFhirMedicationRequestDispenseRequest;
begin
  assert(value.ClassName = 'TFhirMedicationRequestDispenseRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequestDispenseRequest');
  add(value);
  result := value;
end;

function TFhirMedicationRequestDispenseRequestList.Append: TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestDispenseRequestList.GetEnumerator : TFhirMedicationRequestDispenseRequestListEnumerator;
begin
  result := TFhirMedicationRequestDispenseRequestListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestDispenseRequestList.Clone: TFhirMedicationRequestDispenseRequestList;
begin
  result := TFhirMedicationRequestDispenseRequestList(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestDispenseRequestList.GetItemN(index: Integer): TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequestDispenseRequest;
end;
function TFhirMedicationRequestDispenseRequestList.IndexOf(value: TFhirMedicationRequestDispenseRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestDispenseRequestList.Insert(index: Integer): TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestList.InsertItem(index: Integer; value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value is TFhirMedicationRequestDispenseRequest);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestDispenseRequestList.Item(index: Integer): TFhirMedicationRequestDispenseRequest;
begin
  result := TFhirMedicationRequestDispenseRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestList.Link: TFhirMedicationRequestDispenseRequestList;
begin
  result := TFhirMedicationRequestDispenseRequestList(inherited Link);
end;

procedure TFhirMedicationRequestDispenseRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestDispenseRequestList.SetItemByIndex(index: Integer; value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value is TFhirMedicationRequestDispenseRequest);
  FhirMedicationRequestDispenseRequests[index] := value;
end;

procedure TFhirMedicationRequestDispenseRequestList.SetItemN(index: Integer; value: TFhirMedicationRequestDispenseRequest);
begin
  assert(value is TFhirMedicationRequestDispenseRequest);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationRequestDispenseRequestInitialFill }

constructor TFhirMedicationRequestDispenseRequestInitialFill.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequestDispenseRequestInitialFill.Destroy;
begin
  FQuantity.free;
  FDuration.free;
  inherited;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirMedicationRequestDispenseRequestInitialFill(oSource).quantity.Clone;
  duration := TFhirMedicationRequestDispenseRequestInitialFill(oSource).duration.Clone;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'duration', 'Duration', false, TFhirDuration, FDuration.Link));
end;

function TFhirMedicationRequestDispenseRequestInitialFill.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirDuration;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationRequestDispenseRequestInitialFill.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'duration') then result := TFhirDuration.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequestDispenseRequestInitialFill.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'duration') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'duration') then DurationElement := new as TFhirDuration
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequestDispenseRequestInitialFill.fhirType : string;
begin
  result := 'MedicationRequest.dispenseRequest.initialFill';
end;

function TFhirMedicationRequestDispenseRequestInitialFill.Link : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill(inherited Link);
end;

function TFhirMedicationRequestDispenseRequestInitialFill.Clone : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequestInitialFill.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequestDispenseRequestInitialFill)) then
    result := false
  else
  begin
    o := TFhirMedicationRequestDispenseRequestInitialFill(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(durationElement, o.durationElement, true);
  end;
end;

function TFhirMedicationRequestDispenseRequestInitialFill.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FDuration);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('duration');
end;

function TFhirMedicationRequestDispenseRequestInitialFill.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFill.SetDuration(value : TFhirDuration);
begin
  FDuration.free;
  FDuration := value;
end;

{ TFhirMedicationRequestDispenseRequestInitialFillListEnumerator }

constructor TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.Create(list : TFhirMedicationRequestDispenseRequestInitialFillList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.GetCurrent : TFhirMedicationRequestDispenseRequestInitialFill;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationRequestDispenseRequestInitialFillList }

function TFhirMedicationRequestDispenseRequestInitialFillList.AddItem(value: TFhirMedicationRequestDispenseRequestInitialFill): TFhirMedicationRequestDispenseRequestInitialFill;
begin
  assert(value.ClassName = 'TFhirMedicationRequestDispenseRequestInitialFill', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequestDispenseRequestInitialFill');
  add(value);
  result := value;
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Append: TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.GetEnumerator : TFhirMedicationRequestDispenseRequestInitialFillListEnumerator;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFillListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Clone: TFhirMedicationRequestDispenseRequestInitialFillList;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFillList(inherited Clone);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.GetItemN(index: Integer): TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill;
end;
function TFhirMedicationRequestDispenseRequestInitialFillList.IndexOf(value: TFhirMedicationRequestDispenseRequestInitialFill): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Insert(index: Integer): TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.InsertItem(index: Integer; value: TFhirMedicationRequestDispenseRequestInitialFill);
begin
  assert(value is TFhirMedicationRequestDispenseRequestInitialFill);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Item(index: Integer): TFhirMedicationRequestDispenseRequestInitialFill;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFill(ObjectByIndex[index]);
end;

function TFhirMedicationRequestDispenseRequestInitialFillList.Link: TFhirMedicationRequestDispenseRequestInitialFillList;
begin
  result := TFhirMedicationRequestDispenseRequestInitialFillList(inherited Link);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.SetItemByIndex(index: Integer; value: TFhirMedicationRequestDispenseRequestInitialFill);
begin
  assert(value is TFhirMedicationRequestDispenseRequestInitialFill);
  FhirMedicationRequestDispenseRequestInitialFills[index] := value;
end;

procedure TFhirMedicationRequestDispenseRequestInitialFillList.SetItemN(index: Integer; value: TFhirMedicationRequestDispenseRequestInitialFill);
begin
  assert(value is TFhirMedicationRequestDispenseRequestInitialFill);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationRequestSubstitution }

constructor TFhirMedicationRequestSubstitution.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequestSubstitution.Destroy;
begin
  FAllowed.free;
  FReason.free;
  inherited;
end;

procedure TFhirMedicationRequestSubstitution.Assign(oSource : TFslObject);
begin
  inherited;
  allowed := TFhirMedicationRequestSubstitution(oSource).allowed.Clone;
  reason := TFhirMedicationRequestSubstitution(oSource).reason.Clone;
end;

procedure TFhirMedicationRequestSubstitution.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'allowed[x]') or (child_name = 'allowed') Then
     list.add(self.link, 'allowed[x]', FAllowed.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
end;

procedure TFhirMedicationRequestSubstitution.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'allowed[x]', 'boolean|CodeableConcept', false, TFhirDataType, FAllowed.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));
end;

function TFhirMedicationRequestSubstitution.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'allowed', ['Boolean', 'CodeableConcept'])) then
  begin
    Allowed := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequestSubstitution.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMedicationRequestSubstitution.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'allowed', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Allowed')
  else if (propName = 'reason') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequestSubstitution.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'allowed[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequestSubstitution.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'allowed', ['Boolean', 'CodeableConcept'])) then AllowedElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequestSubstitution.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'allowed', ['Boolean', 'CodeableConcept'])) then AllowedElement := new as TFhirDataType
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequestSubstitution.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequestSubstitution.fhirType : string;
begin
  result := 'MedicationRequest.substitution';
end;

function TFhirMedicationRequestSubstitution.Link : TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(inherited Link);
end;

function TFhirMedicationRequestSubstitution.Clone : TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(inherited Clone);
end;

function TFhirMedicationRequestSubstitution.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationRequestSubstitution;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequestSubstitution)) then
    result := false
  else
  begin
    o := TFhirMedicationRequestSubstitution(other);
    result := compareDeep(allowedElement, o.allowedElement, true) and compareDeep(reasonElement, o.reasonElement, true);
  end;
end;

function TFhirMedicationRequestSubstitution.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAllowed) and isEmptyProp(FReason);
end;

procedure TFhirMedicationRequestSubstitution.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('allowed[x]');
  fields.add('reason');
end;

function TFhirMedicationRequestSubstitution.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMedicationRequestSubstitution.SetAllowed(value : TFhirDataType);
begin
  FAllowed.free;
  FAllowed := value;
end;

procedure TFhirMedicationRequestSubstitution.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

{ TFhirMedicationRequestSubstitutionListEnumerator }

constructor TFhirMedicationRequestSubstitutionListEnumerator.Create(list : TFhirMedicationRequestSubstitutionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestSubstitutionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestSubstitutionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestSubstitutionListEnumerator.GetCurrent : TFhirMedicationRequestSubstitution;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestSubstitutionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationRequestSubstitutionList }

function TFhirMedicationRequestSubstitutionList.AddItem(value: TFhirMedicationRequestSubstitution): TFhirMedicationRequestSubstitution;
begin
  assert(value.ClassName = 'TFhirMedicationRequestSubstitution', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequestSubstitution');
  add(value);
  result := value;
end;

function TFhirMedicationRequestSubstitutionList.Append: TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestSubstitutionList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestSubstitutionList.GetEnumerator : TFhirMedicationRequestSubstitutionListEnumerator;
begin
  result := TFhirMedicationRequestSubstitutionListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestSubstitutionList.Clone: TFhirMedicationRequestSubstitutionList;
begin
  result := TFhirMedicationRequestSubstitutionList(inherited Clone);
end;

function TFhirMedicationRequestSubstitutionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestSubstitutionList.GetItemN(index: Integer): TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationRequestSubstitutionList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequestSubstitution;
end;
function TFhirMedicationRequestSubstitutionList.IndexOf(value: TFhirMedicationRequestSubstitution): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestSubstitutionList.Insert(index: Integer): TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestSubstitutionList.InsertItem(index: Integer; value: TFhirMedicationRequestSubstitution);
begin
  assert(value is TFhirMedicationRequestSubstitution);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestSubstitutionList.Item(index: Integer): TFhirMedicationRequestSubstitution;
begin
  result := TFhirMedicationRequestSubstitution(ObjectByIndex[index]);
end;

function TFhirMedicationRequestSubstitutionList.Link: TFhirMedicationRequestSubstitutionList;
begin
  result := TFhirMedicationRequestSubstitutionList(inherited Link);
end;

procedure TFhirMedicationRequestSubstitutionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestSubstitutionList.SetItemByIndex(index: Integer; value: TFhirMedicationRequestSubstitution);
begin
  assert(value is TFhirMedicationRequestSubstitution);
  FhirMedicationRequestSubstitutions[index] := value;
end;

procedure TFhirMedicationRequestSubstitutionList.SetItemN(index: Integer; value: TFhirMedicationRequestSubstitution);
begin
  assert(value is TFhirMedicationRequestSubstitution);
  ObjectByIndex[index] := value;
end;

{ TFhirMedicationRequest }

constructor TFhirMedicationRequest.Create;
begin
  inherited;
end;

destructor TFhirMedicationRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FStatusReason.free;
  FIntent.free;
  FCategoryList.Free;
  FPriority.free;
  FDoNotPerform.free;
  FReported.free;
  FMedication.free;
  FSubject.free;
  FEncounter.free;
  FSupportingInformationList.Free;
  FAuthoredOn.free;
  FRequester.free;
  FPerformer.free;
  FPerformerType.free;
  FRecorder.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FGroupIdentifier.free;
  FCourseOfTherapyType.free;
  FInsuranceList.Free;
  FNoteList.Free;
  FDosageInstructionList.Free;
  FDispenseRequest.free;
  FSubstitution.free;
  FPriorPrescription.free;
  FDetectedIssueList.Free;
  FEventHistoryList.Free;
  inherited;
end;

procedure TFhirMedicationRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationRequest(oSource).FIdentifierList);
  end;
  statusElement := TFhirMedicationRequest(oSource).statusElement.Clone;
  statusReason := TFhirMedicationRequest(oSource).statusReason.Clone;
  intentElement := TFhirMedicationRequest(oSource).intentElement.Clone;
  if (TFhirMedicationRequest(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirMedicationRequest(oSource).FCategoryList);
  end;
  priorityElement := TFhirMedicationRequest(oSource).priorityElement.Clone;
  doNotPerformElement := TFhirMedicationRequest(oSource).doNotPerformElement.Clone;
  reported := TFhirMedicationRequest(oSource).reported.Clone;
  medication := TFhirMedicationRequest(oSource).medication.Clone;
  subject := TFhirMedicationRequest(oSource).subject.Clone;
  encounter := TFhirMedicationRequest(oSource).encounter.Clone;
  if (TFhirMedicationRequest(oSource).FSupportingInformationList = nil) then
  begin
    FSupportingInformationList.free;
    FSupportingInformationList := nil;
  end
  else
  begin
    if FSupportingInformationList = nil then
      FSupportingInformationList := TFhirReferenceList.Create;
    FSupportingInformationList.Assign(TFhirMedicationRequest(oSource).FSupportingInformationList);
  end;
  authoredOnElement := TFhirMedicationRequest(oSource).authoredOnElement.Clone;
  requester := TFhirMedicationRequest(oSource).requester.Clone;
  performer := TFhirMedicationRequest(oSource).performer.Clone;
  performerType := TFhirMedicationRequest(oSource).performerType.Clone;
  recorder := TFhirMedicationRequest(oSource).recorder.Clone;
  if (TFhirMedicationRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirMedicationRequest(oSource).FReasonCodeList);
  end;
  if (TFhirMedicationRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirMedicationRequest(oSource).FReasonReferenceList);
  end;
  if (TFhirMedicationRequest(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirMedicationRequest(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirMedicationRequest(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirMedicationRequest(oSource).FInstantiatesUriList);
  end;
  if (TFhirMedicationRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirMedicationRequest(oSource).FBasedOnList);
  end;
  groupIdentifier := TFhirMedicationRequest(oSource).groupIdentifier.Clone;
  courseOfTherapyType := TFhirMedicationRequest(oSource).courseOfTherapyType.Clone;
  if (TFhirMedicationRequest(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirReferenceList.Create;
    FInsuranceList.Assign(TFhirMedicationRequest(oSource).FInsuranceList);
  end;
  if (TFhirMedicationRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationRequest(oSource).FNoteList);
  end;
  if (TFhirMedicationRequest(oSource).FDosageInstructionList = nil) then
  begin
    FDosageInstructionList.free;
    FDosageInstructionList := nil;
  end
  else
  begin
    if FDosageInstructionList = nil then
      FDosageInstructionList := TFhirDosageList.Create;
    FDosageInstructionList.Assign(TFhirMedicationRequest(oSource).FDosageInstructionList);
  end;
  dispenseRequest := TFhirMedicationRequest(oSource).dispenseRequest.Clone;
  substitution := TFhirMedicationRequest(oSource).substitution.Clone;
  priorPrescription := TFhirMedicationRequest(oSource).priorPrescription.Clone;
  if (TFhirMedicationRequest(oSource).FDetectedIssueList = nil) then
  begin
    FDetectedIssueList.free;
    FDetectedIssueList := nil;
  end
  else
  begin
    if FDetectedIssueList = nil then
      FDetectedIssueList := TFhirReferenceList.Create;
    FDetectedIssueList.Assign(TFhirMedicationRequest(oSource).FDetectedIssueList);
  end;
  if (TFhirMedicationRequest(oSource).FEventHistoryList = nil) then
  begin
    FEventHistoryList.free;
    FEventHistoryList := nil;
  end
  else
  begin
    if FEventHistoryList = nil then
      FEventHistoryList := TFhirReferenceList.Create;
    FEventHistoryList.Assign(TFhirMedicationRequest(oSource).FEventHistoryList);
  end;
end;

function TFhirMedicationRequest.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationRequest;
end;

procedure TFhirMedicationRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'reported[x]') or (child_name = 'reported') Then
     list.add(self.link, 'reported[x]', FReported.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'supportingInformation') Then
    list.addAll(self, 'supportingInformation', FSupportingInformationList);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'performerType') Then
     list.add(self.link, 'performerType', FPerformerType.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'courseOfTherapyType') Then
     list.add(self.link, 'courseOfTherapyType', FCourseOfTherapyType.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'dosageInstruction') Then
    list.addAll(self, 'dosageInstruction', FDosageInstructionList);
  if (child_name = 'dispenseRequest') Then
     list.add(self.link, 'dispenseRequest', FDispenseRequest.Link);
  if (child_name = 'substitution') Then
     list.add(self.link, 'substitution', FSubstitution.Link);
  if (child_name = 'priorPrescription') Then
     list.add(self.link, 'priorPrescription', FPriorPrescription.Link);
  if (child_name = 'detectedIssue') Then
    list.addAll(self, 'detectedIssue', FDetectedIssueList);
  if (child_name = 'eventHistory') Then
    list.addAll(self, 'eventHistory', FEventHistoryList);
end;

procedure TFhirMedicationRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));
  oList.add(TFHIRProperty.create(self, 'reported[x]', 'boolean|Reference', false, TFhirDataType, FReported.Link));
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference', false, TFhirDataType, FMedication.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInformation', 'Reference', true, TFhirReference, FSupportingInformationList.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link));
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerType.Link));
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'courseOfTherapyType', 'CodeableConcept', false, TFhirCodeableConcept, FCourseOfTherapyType.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'Reference', true, TFhirReference, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'dosageInstruction', 'Dosage', true, TFhirDosage, FDosageInstructionList.Link));
  oList.add(TFHIRProperty.create(self, 'dispenseRequest', 'BackboneElement', false, TFhirMedicationRequestDispenseRequest, FDispenseRequest.Link));
  oList.add(TFHIRProperty.create(self, 'substitution', 'BackboneElement', false, TFhirMedicationRequestSubstitution, FSubstitution.Link));
  oList.add(TFHIRProperty.create(self, 'priorPrescription', 'Reference', false, TFhirReference, FPriorPrescription.Link));
  oList.add(TFHIRProperty.create(self, 'detectedIssue', 'Reference', true, TFhirReference, FDetectedIssueList.Link));
  oList.add(TFHIRProperty.create(self, 'eventHistory', 'Reference', true, TFhirReference, FEventHistoryList.Link));
end;

function TFhirMedicationRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationrequestStatusEnum, CODES_TFhirMedicationrequestStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirMedicationRequestIntentEnum, CODES_TFhirMedicationRequestIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then
  begin
    Reported := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'supportingInformation') then
  begin
    SupportingInformationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'courseOfTherapyType') then
  begin
    CourseOfTherapyType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'dosageInstruction') then
  begin
    DosageInstructionList.add(propValue as TFhirDosage);
    result := propValue;
  end
  else if (propName = 'dispenseRequest') then
  begin
    DispenseRequest := propValue as TFhirMedicationRequestDispenseRequest;
    result := propValue;
  end
  else if (propName = 'substitution') then
  begin
    Substitution := propValue as TFhirMedicationRequestSubstitution;
    result := propValue;
  end
  else if (propName = 'priorPrescription') then
  begin
    PriorPrescription := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'detectedIssue') then
  begin
    DetectedIssueList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'eventHistory') then
  begin
    EventHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'supportingInformation') then SupportingInformationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'dosageInstruction') then DosageInstructionList.insertItem(index, propValue as TFhirDosage)
  else if (propName = 'detectedIssue') then DetectedIssueList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'eventHistory') then EventHistoryList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMedicationRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationrequestStatusEnum[MedicationrequestStatusNull], CODES_TFhirMedicationrequestStatusEnum[MedicationrequestStatusNull]) 
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationRequestIntentEnum[MedicationRequestIntentNull], CODES_TFhirMedicationRequestIntentEnum[MedicationRequestIntentNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then raise EFHIRException.create('Cannot make property Reported')
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication')
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'supportingInformation') then result := SupportingInformationList.new()
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'requester') then result := TFhirReference.create()
  else if (propName = 'performer') then result := TFhirReference.create()
  else if (propName = 'performerType') then result := TFhirCodeableConcept.create()
  else if (propName = 'recorder') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'courseOfTherapyType') then result := TFhirCodeableConcept.create()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'dosageInstruction') then result := DosageInstructionList.new()
  else if (propName = 'dispenseRequest') then result := TFhirMedicationRequestDispenseRequest.create()
  else if (propName = 'substitution') then result := TFhirMedicationRequestSubstitution.create()
  else if (propName = 'priorPrescription') then result := TFhirReference.create()
  else if (propName = 'detectedIssue') then result := DetectedIssueList.new()
  else if (propName = 'eventHistory') then result := EventHistoryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'reported[x]') then result := 'boolean|Reference'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'supportingInformation') then result := 'Reference'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'courseOfTherapyType') then result := 'CodeableConcept'
  else if (propName = 'insurance') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'dosageInstruction') then result := 'Dosage'
  else if (propName = 'dispenseRequest') then result := 'BackboneElement'
  else if (propName = 'substitution') then result := 'BackboneElement'
  else if (propName = 'priorPrescription') then result := 'Reference'
  else if (propName = 'detectedIssue') then result := 'Reference'
  else if (propName = 'eventHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then ReportedElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'supportingInformation') then deletePropertyValue('supportingInformation', SupportingInformationList, value)
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'performerType') then PerformerTypeElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'courseOfTherapyType') then CourseOfTherapyTypeElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'dosageInstruction') then deletePropertyValue('dosageInstruction', DosageInstructionList, value)
  else if (propName = 'dispenseRequest') then DispenseRequestElement := nil
  else if (propName = 'substitution') then SubstitutionElement := nil
  else if (propName = 'priorPrescription') then PriorPrescriptionElement := nil
  else if (propName = 'detectedIssue') then deletePropertyValue('detectedIssue', DetectedIssueList, value)
  else if (propName = 'eventHistory') then deletePropertyValue('eventHistory', EventHistoryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationrequestStatusEnum, CODES_TFhirMedicationrequestStatusEnum, new)
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirMedicationRequestIntentEnum, CODES_TFhirMedicationRequestIntentEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new)
  else if (isMatchingName(propName, 'reported', ['Boolean', 'Reference'])) then ReportedElement := new as TFhirDataType
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirDataType
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'supportingInformation') then replacePropertyValue('supportingInformation', SupportingInformationList, existing, new)
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'requester') then RequesterElement := new as TFhirReference
  else if (propName = 'performer') then PerformerElement := new as TFhirReference
  else if (propName = 'performerType') then PerformerTypeElement := new as TFhirCodeableConcept
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier
  else if (propName = 'courseOfTherapyType') then CourseOfTherapyTypeElement := new as TFhirCodeableConcept
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'dosageInstruction') then replacePropertyValue('dosageInstruction', DosageInstructionList, existing, new)
  else if (propName = 'dispenseRequest') then DispenseRequestElement := new as TFhirMedicationRequestDispenseRequest
  else if (propName = 'substitution') then SubstitutionElement := new as TFhirMedicationRequestSubstitution
  else if (propName = 'priorPrescription') then PriorPrescriptionElement := new as TFhirReference
  else if (propName = 'detectedIssue') then replacePropertyValue('detectedIssue', DetectedIssueList, existing, new)
  else if (propName = 'eventHistory') then replacePropertyValue('eventHistory', EventHistoryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'supportingInformation') then SupportingInformationList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'dosageInstruction') then DosageInstructionList.move(source, destination)
  else if (propName = 'detectedIssue') then DetectedIssueList.move(source, destination)
  else if (propName = 'eventHistory') then EventHistoryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationRequest.fhirType : string;
begin
  result := 'MedicationRequest';
end;

function TFhirMedicationRequest.Link : TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(inherited Link);
end;

function TFhirMedicationRequest.Clone : TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(inherited Clone);
end;

function TFhirMedicationRequest.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationRequest)) then
    result := false
  else
  begin
    o := TFhirMedicationRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(doNotPerformElement, o.doNotPerformElement, true) and compareDeep(reportedElement, o.reportedElement, true) and 
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(supportingInformationList, o.supportingInformationList, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(performerTypeElement, o.performerTypeElement, true) and 
      compareDeep(recorderElement, o.recorderElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and compareDeep(courseOfTherapyTypeElement, o.courseOfTherapyTypeElement, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(dosageInstructionList, o.dosageInstructionList, true) and compareDeep(dispenseRequestElement, o.dispenseRequestElement, true) and 
      compareDeep(substitutionElement, o.substitutionElement, true) and compareDeep(priorPrescriptionElement, o.priorPrescriptionElement, true) and 
      compareDeep(detectedIssueList, o.detectedIssueList, true) and compareDeep(eventHistoryList, o.eventHistoryList, true);
  end;
end;

function TFhirMedicationRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FIntent) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform) and isEmptyProp(FReported) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FsupportingInformationList) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FPerformer) and isEmptyProp(FPerformerType) and isEmptyProp(FRecorder) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FCourseOfTherapyType) and isEmptyProp(FinsuranceList) and isEmptyProp(FnoteList) and isEmptyProp(FdosageInstructionList) and isEmptyProp(FDispenseRequest) and isEmptyProp(FSubstitution) and isEmptyProp(FPriorPrescription)
       and isEmptyProp(FdetectedIssueList) and isEmptyProp(FeventHistoryList);
end;

procedure TFhirMedicationRequest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('intent');
  fields.add('category');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('reported[x]');
  fields.add('medication[x]');
  fields.add('subject');
  fields.add('encounter');
  fields.add('supportingInformation');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('performer');
  fields.add('performerType');
  fields.add('recorder');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('groupIdentifier');
  fields.add('courseOfTherapyType');
  fields.add('insurance');
  fields.add('note');
  fields.add('dosageInstruction');
  fields.add('dispenseRequest');
  fields.add('substitution');
  fields.add('priorPrescription');
  fields.add('detectedIssue');
  fields.add('eventHistory');
end;

function TFhirMedicationRequest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FSupportingInformationList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FDosageInstructionList.sizeInBytes(magic));
  inc(result, FDetectedIssueList.sizeInBytes(magic));
  inc(result, FEventHistoryList.sizeInBytes(magic));
end;

function TFhirMedicationRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMedicationRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationRequest.GetStatusST : TFhirMedicationrequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationrequestStatusEnum(0)
  else
    result := TFhirMedicationrequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationrequestStatusEnum, FStatus.value));
end;

procedure TFhirMedicationRequest.SetStatusST(value : TFhirMedicationrequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationrequestStatusEnum[value], CODES_TFhirMedicationrequestStatusEnum[value]);
end;

procedure TFhirMedicationRequest.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

procedure TFhirMedicationRequest.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirMedicationRequest.GetIntentST : TFhirMedicationRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirMedicationRequestIntentEnum(0)
  else
    result := TFhirMedicationRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationRequestIntentEnum, FIntent.value));
end;

procedure TFhirMedicationRequest.SetIntentST(value : TFhirMedicationRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirMedicationRequestIntentEnum[value], CODES_TFhirMedicationRequestIntentEnum[value]);
end;

function TFhirMedicationRequest.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirMedicationRequest.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirMedicationRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirMedicationRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirMedicationRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirMedicationRequest.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

function TFhirMedicationRequest.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirMedicationRequest.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirMedicationRequest.SetReported(value : TFhirDataType);
begin
  FReported.free;
  FReported := value;
end;

procedure TFhirMedicationRequest.SetMedication(value : TFhirDataType);
begin
  FMedication.free;
  FMedication := value;
end;

procedure TFhirMedicationRequest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirMedicationRequest.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

function TFhirMedicationRequest.GetSupportingInformationList : TFhirReferenceList;
begin
  if FSupportingInformationList = nil then
    FSupportingInformationList := TFhirReferenceList.Create;
  result := FSupportingInformationList;
end;

function TFhirMedicationRequest.GetHasSupportingInformationList : boolean;
begin
  result := (FSupportingInformationList <> nil) and (FSupportingInformationList.count > 0);
end;

procedure TFhirMedicationRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirMedicationRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirMedicationRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirMedicationRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value;
end;

procedure TFhirMedicationRequest.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value;
end;

procedure TFhirMedicationRequest.SetPerformerType(value : TFhirCodeableConcept);
begin
  FPerformerType.free;
  FPerformerType := value;
end;

procedure TFhirMedicationRequest.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value;
end;

function TFhirMedicationRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirMedicationRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirMedicationRequest.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirMedicationRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirMedicationRequest.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirMedicationRequest.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirMedicationRequest.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirMedicationRequest.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirMedicationRequest.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirMedicationRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirMedicationRequest.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

procedure TFhirMedicationRequest.SetCourseOfTherapyType(value : TFhirCodeableConcept);
begin
  FCourseOfTherapyType.free;
  FCourseOfTherapyType := value;
end;

function TFhirMedicationRequest.GetInsuranceList : TFhirReferenceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirReferenceList.Create;
  result := FInsuranceList;
end;

function TFhirMedicationRequest.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirMedicationRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedicationRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirMedicationRequest.GetDosageInstructionList : TFhirDosageList;
begin
  if FDosageInstructionList = nil then
    FDosageInstructionList := TFhirDosageList.Create;
  result := FDosageInstructionList;
end;

function TFhirMedicationRequest.GetHasDosageInstructionList : boolean;
begin
  result := (FDosageInstructionList <> nil) and (FDosageInstructionList.count > 0);
end;

procedure TFhirMedicationRequest.SetDispenseRequest(value : TFhirMedicationRequestDispenseRequest);
begin
  FDispenseRequest.free;
  FDispenseRequest := value;
end;

procedure TFhirMedicationRequest.SetSubstitution(value : TFhirMedicationRequestSubstitution);
begin
  FSubstitution.free;
  FSubstitution := value;
end;

procedure TFhirMedicationRequest.SetPriorPrescription(value : TFhirReference);
begin
  FPriorPrescription.free;
  FPriorPrescription := value;
end;

function TFhirMedicationRequest.GetDetectedIssueList : TFhirReferenceList;
begin
  if FDetectedIssueList = nil then
    FDetectedIssueList := TFhirReferenceList.Create;
  result := FDetectedIssueList;
end;

function TFhirMedicationRequest.GetHasDetectedIssueList : boolean;
begin
  result := (FDetectedIssueList <> nil) and (FDetectedIssueList.count > 0);
end;

function TFhirMedicationRequest.GetEventHistoryList : TFhirReferenceList;
begin
  if FEventHistoryList = nil then
    FEventHistoryList := TFhirReferenceList.Create;
  result := FEventHistoryList;
end;

function TFhirMedicationRequest.GetHasEventHistoryList : boolean;
begin
  result := (FEventHistoryList <> nil) and (FEventHistoryList.count > 0);
end;

{ TFhirMedicationRequestListEnumerator }

constructor TFhirMedicationRequestListEnumerator.Create(list : TFhirMedicationRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationRequestListEnumerator.GetCurrent : TFhirMedicationRequest;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationRequestList }

function TFhirMedicationRequestList.AddItem(value: TFhirMedicationRequest): TFhirMedicationRequest;
begin
  assert(value.ClassName = 'TFhirMedicationRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationRequest');
  add(value);
  result := value;
end;

function TFhirMedicationRequestList.Append: TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationRequestList.GetEnumerator : TFhirMedicationRequestListEnumerator;
begin
  result := TFhirMedicationRequestListEnumerator.Create(self.link);
end;

function TFhirMedicationRequestList.Clone: TFhirMedicationRequestList;
begin
  result := TFhirMedicationRequestList(inherited Clone);
end;

function TFhirMedicationRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationRequestList.GetItemN(index: Integer): TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationRequest;
end;
function TFhirMedicationRequestList.IndexOf(value: TFhirMedicationRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationRequestList.Insert(index: Integer): TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationRequestList.InsertItem(index: Integer; value: TFhirMedicationRequest);
begin
  assert(value is TFhirMedicationRequest);
  Inherited Insert(index, value);
end;

function TFhirMedicationRequestList.Item(index: Integer): TFhirMedicationRequest;
begin
  result := TFhirMedicationRequest(ObjectByIndex[index]);
end;

function TFhirMedicationRequestList.Link: TFhirMedicationRequestList;
begin
  result := TFhirMedicationRequestList(inherited Link);
end;

procedure TFhirMedicationRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationRequestList.SetItemByIndex(index: Integer; value: TFhirMedicationRequest);
begin
  assert(value is TFhirMedicationRequest);
  FhirMedicationRequests[index] := value;
end;

procedure TFhirMedicationRequestList.SetItemN(index: Integer; value: TFhirMedicationRequest);
begin
  assert(value is TFhirMedicationRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONREQUEST}
{$IFDEF FHIR_MEDICATIONSTATEMENT}
{ TFhirMedicationStatement }

constructor TFhirMedicationStatement.Create;
begin
  inherited;
end;

destructor TFhirMedicationStatement.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReasonList.Free;
  FCategory.free;
  FMedication.free;
  FSubject.free;
  FContext.free;
  FEffective.free;
  FDateAsserted.free;
  FInformationSource.free;
  FDerivedFromList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FDosageList.Free;
  inherited;
end;

procedure TFhirMedicationStatement.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedicationStatement(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedicationStatement(oSource).FIdentifierList);
  end;
  if (TFhirMedicationStatement(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirMedicationStatement(oSource).FBasedOnList);
  end;
  if (TFhirMedicationStatement(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirMedicationStatement(oSource).FPartOfList);
  end;
  statusElement := TFhirMedicationStatement(oSource).statusElement.Clone;
  if (TFhirMedicationStatement(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirMedicationStatement(oSource).FStatusReasonList);
  end;
  category := TFhirMedicationStatement(oSource).category.Clone;
  medication := TFhirMedicationStatement(oSource).medication.Clone;
  subject := TFhirMedicationStatement(oSource).subject.Clone;
  context := TFhirMedicationStatement(oSource).context.Clone;
  effective := TFhirMedicationStatement(oSource).effective.Clone;
  dateAssertedElement := TFhirMedicationStatement(oSource).dateAssertedElement.Clone;
  informationSource := TFhirMedicationStatement(oSource).informationSource.Clone;
  if (TFhirMedicationStatement(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirReferenceList.Create;
    FDerivedFromList.Assign(TFhirMedicationStatement(oSource).FDerivedFromList);
  end;
  if (TFhirMedicationStatement(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirMedicationStatement(oSource).FReasonCodeList);
  end;
  if (TFhirMedicationStatement(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirMedicationStatement(oSource).FReasonReferenceList);
  end;
  if (TFhirMedicationStatement(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedicationStatement(oSource).FNoteList);
  end;
  if (TFhirMedicationStatement(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirMedicationStatement(oSource).FDosageList);
  end;
end;

function TFhirMedicationStatement.GetResourceType : TFhirResourceType;
begin
  result := frtMedicationStatement;
end;

procedure TFhirMedicationStatement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'medication[x]') or (child_name = 'medication') Then
     list.add(self.link, 'medication[x]', FMedication.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'dateAsserted') Then
     list.add(self.link, 'dateAsserted', FDateAsserted.Link);
  if (child_name = 'informationSource') Then
     list.add(self.link, 'informationSource', FInformationSource.Link);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
end;

procedure TFhirMedicationStatement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'medication[x]', 'CodeableConcept|Reference', false, TFhirDataType, FMedication.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'Reference', false, TFhirReference, FContext.Link));
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period', false, TFhirDataType, FEffective.Link));
  oList.add(TFHIRProperty.create(self, 'dateAsserted', 'dateTime', false, TFhirDateTime, FDateAsserted.Link));
  oList.add(TFHIRProperty.create(self, 'informationSource', 'Reference', false, TFhirReference, FInformationSource.Link));
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'Reference', true, TFhirReference, FDerivedFromList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link));
end;

function TFhirMedicationStatement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusCodesEnum, CODES_TFhirMedicationStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then
  begin
    Medication := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then
  begin
    Effective := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'dateAsserted') then
  begin
    DateAssertedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'informationSource') then
  begin
    InformationSource := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedicationStatement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage)
  else inherited;
end;

function TFhirMedicationStatement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusCodesEnum[MedicationStatusCodesNull], CODES_TFhirMedicationStatusCodesEnum[MedicationStatusCodesNull]) 
  else if (propName = 'statusReason') then result := StatusReasonList.new()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Medication')
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'context') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Effective')
  else if (propName = 'dateAsserted') then result := TFhirDateTime.create()
  else if (propName = 'informationSource') then result := TFhirReference.create()
  else if (propName = 'derivedFrom') then result := DerivedFromList.new()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'dosage') then result := DosageList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedicationStatement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'medication[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period'
  else if (propName = 'dateAsserted') then result := 'dateTime'
  else if (propName = 'informationSource') then result := 'Reference'
  else if (propName = 'derivedFrom') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'dosage') then result := 'Dosage'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedicationStatement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value)
  else if (propName = 'category') then CategoryElement := nil
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := nil
  else if (propName = 'dateAsserted') then DateAssertedElement := nil
  else if (propName = 'informationSource') then InformationSourceElement := nil
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value)
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedicationStatement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMedicationStatusCodesEnum, CODES_TFhirMedicationStatusCodesEnum, new)
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new)
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'medication', ['CodeableConcept', 'Reference'])) then MedicationElement := new as TFhirDataType
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'context') then ContextElement := new as TFhirReference
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period'])) then EffectiveElement := new as TFhirDataType
  else if (propName = 'dateAsserted') then DateAssertedElement := asDateTime(new)
  else if (propName = 'informationSource') then InformationSourceElement := new as TFhirReference
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new)
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedicationStatement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'statusReason') then StatusReasonList.move(source, destination)
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'dosage') then DosageList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedicationStatement.fhirType : string;
begin
  result := 'MedicationStatement';
end;

function TFhirMedicationStatement.Link : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(inherited Link);
end;

function TFhirMedicationStatement.Clone : TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(inherited Clone);
end;

function TFhirMedicationStatement.equals(other : TObject) : boolean; 
var
  o : TFhirMedicationStatement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedicationStatement)) then
    result := false
  else
  begin
    o := TFhirMedicationStatement(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonList, o.statusReasonList, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(medicationElement, o.medicationElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(contextElement, o.contextElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and 
      compareDeep(dateAssertedElement, o.dateAssertedElement, true) and compareDeep(informationSourceElement, o.informationSourceElement, true) and 
      compareDeep(derivedFromList, o.derivedFromList, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(dosageList, o.dosageList, true);
  end;
end;

function TFhirMedicationStatement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FCategory) and isEmptyProp(FMedication) and isEmptyProp(FSubject) and isEmptyProp(FContext) and isEmptyProp(FEffective) and isEmptyProp(FDateAsserted) and isEmptyProp(FInformationSource) and isEmptyProp(FderivedFromList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FdosageList);
end;

procedure TFhirMedicationStatement.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('medication[x]');
  fields.add('subject');
  fields.add('context');
  fields.add('effective[x]');
  fields.add('dateAsserted');
  fields.add('informationSource');
  fields.add('derivedFrom');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('dosage');
end;

function TFhirMedicationStatement.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FStatusReasonList.sizeInBytes(magic));
  inc(result, FDerivedFromList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FDosageList.sizeInBytes(magic));
end;

function TFhirMedicationStatement.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedicationStatement.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirMedicationStatement.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirMedicationStatement.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirMedicationStatement.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirMedicationStatement.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirMedicationStatement.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedicationStatement.GetStatusST : TFhirMedicationStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirMedicationStatusCodesEnum(0)
  else
    result := TFhirMedicationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirMedicationStatusCodesEnum, FStatus.value));
end;

procedure TFhirMedicationStatement.SetStatusST(value : TFhirMedicationStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMedicationStatusCodesEnum[value], CODES_TFhirMedicationStatusCodesEnum[value]);
end;

function TFhirMedicationStatement.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

function TFhirMedicationStatement.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

procedure TFhirMedicationStatement.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirMedicationStatement.SetMedication(value : TFhirDataType);
begin
  FMedication.free;
  FMedication := value;
end;

procedure TFhirMedicationStatement.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirMedicationStatement.SetContext(value : TFhirReference);
begin
  FContext.free;
  FContext := value;
end;

procedure TFhirMedicationStatement.SetEffective(value : TFhirDataType);
begin
  FEffective.free;
  FEffective := value;
end;

procedure TFhirMedicationStatement.SetDateAsserted(value : TFhirDateTime);
begin
  FDateAsserted.free;
  FDateAsserted := value;
end;

function TFhirMedicationStatement.GetDateAssertedST : TFslDateTime;
begin
  if FDateAsserted = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateAsserted.value;
end;

procedure TFhirMedicationStatement.SetDateAssertedST(value : TFslDateTime);
begin
  if FDateAsserted = nil then
    FDateAsserted := TFhirDateTime.create;
  FDateAsserted.value := value
end;

procedure TFhirMedicationStatement.SetInformationSource(value : TFhirReference);
begin
  FInformationSource.free;
  FInformationSource := value;
end;

function TFhirMedicationStatement.GetDerivedFromList : TFhirReferenceList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirReferenceList.Create;
  result := FDerivedFromList;
end;

function TFhirMedicationStatement.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

function TFhirMedicationStatement.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirMedicationStatement.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirMedicationStatement.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirMedicationStatement.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirMedicationStatement.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedicationStatement.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirMedicationStatement.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

function TFhirMedicationStatement.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

{ TFhirMedicationStatementListEnumerator }

constructor TFhirMedicationStatementListEnumerator.Create(list : TFhirMedicationStatementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMedicationStatementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMedicationStatementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMedicationStatementListEnumerator.GetCurrent : TFhirMedicationStatement;
begin
  Result := FList[FIndex];
end;

function TFhirMedicationStatementListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMedicationStatementList }

function TFhirMedicationStatementList.AddItem(value: TFhirMedicationStatement): TFhirMedicationStatement;
begin
  assert(value.ClassName = 'TFhirMedicationStatement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedicationStatement');
  add(value);
  result := value;
end;

function TFhirMedicationStatementList.Append: TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationStatementList.ClearItems;
begin
  Clear;
end;

function TFhirMedicationStatementList.GetEnumerator : TFhirMedicationStatementListEnumerator;
begin
  result := TFhirMedicationStatementListEnumerator.Create(self.link);
end;

function TFhirMedicationStatementList.Clone: TFhirMedicationStatementList;
begin
  result := TFhirMedicationStatementList(inherited Clone);
end;

function TFhirMedicationStatementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMedicationStatementList.GetItemN(index: Integer): TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(ObjectByIndex[index]);
end;

function TFhirMedicationStatementList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedicationStatement;
end;
function TFhirMedicationStatementList.IndexOf(value: TFhirMedicationStatement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMedicationStatementList.Insert(index: Integer): TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMedicationStatementList.InsertItem(index: Integer; value: TFhirMedicationStatement);
begin
  assert(value is TFhirMedicationStatement);
  Inherited Insert(index, value);
end;

function TFhirMedicationStatementList.Item(index: Integer): TFhirMedicationStatement;
begin
  result := TFhirMedicationStatement(ObjectByIndex[index]);
end;

function TFhirMedicationStatementList.Link: TFhirMedicationStatementList;
begin
  result := TFhirMedicationStatementList(inherited Link);
end;

procedure TFhirMedicationStatementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMedicationStatementList.SetItemByIndex(index: Integer; value: TFhirMedicationStatement);
begin
  assert(value is TFhirMedicationStatement);
  FhirMedicationStatements[index] := value;
end;

procedure TFhirMedicationStatementList.SetItemN(index: Integer; value: TFhirMedicationStatement);
begin
  assert(value is TFhirMedicationStatement);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDICATIONSTATEMENT}
{$IFDEF FHIR_MOLECULARSEQUENCE}
{ TFhirMolecularSequenceReferenceSeq }

constructor TFhirMolecularSequenceReferenceSeq.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceReferenceSeq.Destroy;
begin
  FChromosome.free;
  FGenomeBuild.free;
  FOrientation.free;
  FReferenceSeqId.free;
  FReferenceSeqPointer.free;
  FReferenceSeqString.free;
  FStrand.free;
  FWindowStart.free;
  FWindowEnd.free;
  inherited;
end;

procedure TFhirMolecularSequenceReferenceSeq.Assign(oSource : TFslObject);
begin
  inherited;
  chromosome := TFhirMolecularSequenceReferenceSeq(oSource).chromosome.Clone;
  genomeBuildElement := TFhirMolecularSequenceReferenceSeq(oSource).genomeBuildElement.Clone;
  orientationElement := TFhirMolecularSequenceReferenceSeq(oSource).orientationElement.Clone;
  referenceSeqId := TFhirMolecularSequenceReferenceSeq(oSource).referenceSeqId.Clone;
  referenceSeqPointer := TFhirMolecularSequenceReferenceSeq(oSource).referenceSeqPointer.Clone;
  referenceSeqStringElement := TFhirMolecularSequenceReferenceSeq(oSource).referenceSeqStringElement.Clone;
  strandElement := TFhirMolecularSequenceReferenceSeq(oSource).strandElement.Clone;
  windowStartElement := TFhirMolecularSequenceReferenceSeq(oSource).windowStartElement.Clone;
  windowEndElement := TFhirMolecularSequenceReferenceSeq(oSource).windowEndElement.Clone;
end;

procedure TFhirMolecularSequenceReferenceSeq.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'chromosome') Then
     list.add(self.link, 'chromosome', FChromosome.Link);
  if (child_name = 'genomeBuild') Then
     list.add(self.link, 'genomeBuild', FGenomeBuild.Link);
  if (child_name = 'orientation') Then
     list.add(self.link, 'orientation', FOrientation.Link);
  if (child_name = 'referenceSeqId') Then
     list.add(self.link, 'referenceSeqId', FReferenceSeqId.Link);
  if (child_name = 'referenceSeqPointer') Then
     list.add(self.link, 'referenceSeqPointer', FReferenceSeqPointer.Link);
  if (child_name = 'referenceSeqString') Then
     list.add(self.link, 'referenceSeqString', FReferenceSeqString.Link);
  if (child_name = 'strand') Then
     list.add(self.link, 'strand', FStrand.Link);
  if (child_name = 'windowStart') Then
     list.add(self.link, 'windowStart', FWindowStart.Link);
  if (child_name = 'windowEnd') Then
     list.add(self.link, 'windowEnd', FWindowEnd.Link);
end;

procedure TFhirMolecularSequenceReferenceSeq.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'chromosome', 'CodeableConcept', false, TFhirCodeableConcept, FChromosome.Link));
  oList.add(TFHIRProperty.create(self, 'genomeBuild', 'string', false, TFhirString, FGenomeBuild.Link));
  oList.add(TFHIRProperty.create(self, 'orientation', 'code', false, TFhirEnum, FOrientation.Link));
  oList.add(TFHIRProperty.create(self, 'referenceSeqId', 'CodeableConcept', false, TFhirCodeableConcept, FReferenceSeqId.Link));
  oList.add(TFHIRProperty.create(self, 'referenceSeqPointer', 'Reference', false, TFhirReference, FReferenceSeqPointer.Link));
  oList.add(TFHIRProperty.create(self, 'referenceSeqString', 'string', false, TFhirString, FReferenceSeqString.Link));
  oList.add(TFHIRProperty.create(self, 'strand', 'code', false, TFhirEnum, FStrand.Link));
  oList.add(TFHIRProperty.create(self, 'windowStart', 'integer', false, TFhirInteger, FWindowStart.Link));
  oList.add(TFHIRProperty.create(self, 'windowEnd', 'integer', false, TFhirInteger, FWindowEnd.Link));
end;

function TFhirMolecularSequenceReferenceSeq.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'chromosome') then
  begin
    Chromosome := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'genomeBuild') then
  begin
    GenomeBuildElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'orientation') then
  begin
    OrientationElement := asEnum(SYSTEMS_TFhirOrientationTypeEnum, CODES_TFhirOrientationTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'referenceSeqId') then
  begin
    ReferenceSeqId := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'referenceSeqPointer') then
  begin
    ReferenceSeqPointer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'referenceSeqString') then
  begin
    ReferenceSeqStringElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'strand') then
  begin
    StrandElement := asEnum(SYSTEMS_TFhirStrandTypeEnum, CODES_TFhirStrandTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'windowStart') then
  begin
    WindowStartElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'windowEnd') then
  begin
    WindowEndElement := asInteger(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceReferenceSeq.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceReferenceSeq.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'chromosome') then result := TFhirCodeableConcept.create()
  else if (propName = 'genomeBuild') then result := TFhirString.create()
  else if (propName = 'orientation') then result := TFhirEnum.create(SYSTEMS_TFhirOrientationTypeEnum[OrientationTypeNull], CODES_TFhirOrientationTypeEnum[OrientationTypeNull]) 
  else if (propName = 'referenceSeqId') then result := TFhirCodeableConcept.create()
  else if (propName = 'referenceSeqPointer') then result := TFhirReference.create()
  else if (propName = 'referenceSeqString') then result := TFhirString.create()
  else if (propName = 'strand') then result := TFhirEnum.create(SYSTEMS_TFhirStrandTypeEnum[StrandTypeNull], CODES_TFhirStrandTypeEnum[StrandTypeNull]) 
  else if (propName = 'windowStart') then result := TFhirInteger.create()
  else if (propName = 'windowEnd') then result := TFhirInteger.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceReferenceSeq.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'chromosome') then result := 'CodeableConcept'
  else if (propName = 'genomeBuild') then result := 'string'
  else if (propName = 'orientation') then result := 'code'
  else if (propName = 'referenceSeqId') then result := 'CodeableConcept'
  else if (propName = 'referenceSeqPointer') then result := 'Reference'
  else if (propName = 'referenceSeqString') then result := 'string'
  else if (propName = 'strand') then result := 'code'
  else if (propName = 'windowStart') then result := 'integer'
  else if (propName = 'windowEnd') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceReferenceSeq.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'chromosome') then ChromosomeElement := nil
  else if (propName = 'genomeBuild') then GenomeBuildElement := nil
  else if (propName = 'orientation') then OrientationElement := nil
  else if (propName = 'referenceSeqId') then ReferenceSeqIdElement := nil
  else if (propName = 'referenceSeqPointer') then ReferenceSeqPointerElement := nil
  else if (propName = 'referenceSeqString') then ReferenceSeqStringElement := nil
  else if (propName = 'strand') then StrandElement := nil
  else if (propName = 'windowStart') then WindowStartElement := nil
  else if (propName = 'windowEnd') then WindowEndElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceReferenceSeq.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'chromosome') then ChromosomeElement := new as TFhirCodeableConcept
  else if (propName = 'genomeBuild') then GenomeBuildElement := asString(new)
  else if (propName = 'orientation') then OrientationElement := asEnum(SYSTEMS_TFhirOrientationTypeEnum, CODES_TFhirOrientationTypeEnum, new)
  else if (propName = 'referenceSeqId') then ReferenceSeqIdElement := new as TFhirCodeableConcept
  else if (propName = 'referenceSeqPointer') then ReferenceSeqPointerElement := new as TFhirReference
  else if (propName = 'referenceSeqString') then ReferenceSeqStringElement := asString(new)
  else if (propName = 'strand') then StrandElement := asEnum(SYSTEMS_TFhirStrandTypeEnum, CODES_TFhirStrandTypeEnum, new)
  else if (propName = 'windowStart') then WindowStartElement := asInteger(new)
  else if (propName = 'windowEnd') then WindowEndElement := asInteger(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceReferenceSeq.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceReferenceSeq.fhirType : string;
begin
  result := 'MolecularSequence.referenceSeq';
end;

function TFhirMolecularSequenceReferenceSeq.Link : TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq(inherited Link);
end;

function TFhirMolecularSequenceReferenceSeq.Clone : TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq(inherited Clone);
end;

function TFhirMolecularSequenceReferenceSeq.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceReferenceSeq;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceReferenceSeq)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceReferenceSeq(other);
    result := compareDeep(chromosomeElement, o.chromosomeElement, true) and compareDeep(genomeBuildElement, o.genomeBuildElement, true) and 
      compareDeep(orientationElement, o.orientationElement, true) and compareDeep(referenceSeqIdElement, o.referenceSeqIdElement, true) and 
      compareDeep(referenceSeqPointerElement, o.referenceSeqPointerElement, true) and 
      compareDeep(referenceSeqStringElement, o.referenceSeqStringElement, true) and 
      compareDeep(strandElement, o.strandElement, true) and compareDeep(windowStartElement, o.windowStartElement, true) and 
      compareDeep(windowEndElement, o.windowEndElement, true);
  end;
end;

function TFhirMolecularSequenceReferenceSeq.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FChromosome) and isEmptyProp(FGenomeBuild) and isEmptyProp(FOrientation) and isEmptyProp(FReferenceSeqId) and isEmptyProp(FReferenceSeqPointer) and isEmptyProp(FReferenceSeqString) and isEmptyProp(FStrand) and isEmptyProp(FWindowStart) and isEmptyProp(FWindowEnd);
end;

procedure TFhirMolecularSequenceReferenceSeq.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('chromosome');
  fields.add('genomeBuild');
  fields.add('orientation');
  fields.add('referenceSeqId');
  fields.add('referenceSeqPointer');
  fields.add('referenceSeqString');
  fields.add('strand');
  fields.add('windowStart');
  fields.add('windowEnd');
end;

function TFhirMolecularSequenceReferenceSeq.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMolecularSequenceReferenceSeq.SetChromosome(value : TFhirCodeableConcept);
begin
  FChromosome.free;
  FChromosome := value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetGenomeBuild(value : TFhirString);
begin
  FGenomeBuild.free;
  FGenomeBuild := value;
end;

function TFhirMolecularSequenceReferenceSeq.GetGenomeBuildST : String;
begin
  if FGenomeBuild = nil then
    result := ''
  else
    result := FGenomeBuild.value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetGenomeBuildST(value : String);
begin
  if value <> '' then
  begin
    if FGenomeBuild = nil then
      FGenomeBuild := TFhirString.create;
    FGenomeBuild.value := value
  end
  else if FGenomeBuild <> nil then
    FGenomeBuild.value := '';
end;

procedure TFhirMolecularSequenceReferenceSeq.SetOrientation(value : TFhirEnum);
begin
  FOrientation.free;
  FOrientation := value;
end;

function TFhirMolecularSequenceReferenceSeq.GetOrientationST : TFhirOrientationTypeEnum;
begin
  if FOrientation = nil then
    result := TFhirOrientationTypeEnum(0)
  else
    result := TFhirOrientationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirOrientationTypeEnum, FOrientation.value));
end;

procedure TFhirMolecularSequenceReferenceSeq.SetOrientationST(value : TFhirOrientationTypeEnum);
begin
  if ord(value) = 0 then
    OrientationElement := nil
  else
    OrientationElement := TFhirEnum.create(SYSTEMS_TFhirOrientationTypeEnum[value], CODES_TFhirOrientationTypeEnum[value]);
end;

procedure TFhirMolecularSequenceReferenceSeq.SetReferenceSeqId(value : TFhirCodeableConcept);
begin
  FReferenceSeqId.free;
  FReferenceSeqId := value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetReferenceSeqPointer(value : TFhirReference);
begin
  FReferenceSeqPointer.free;
  FReferenceSeqPointer := value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetReferenceSeqString(value : TFhirString);
begin
  FReferenceSeqString.free;
  FReferenceSeqString := value;
end;

function TFhirMolecularSequenceReferenceSeq.GetReferenceSeqStringST : String;
begin
  if FReferenceSeqString = nil then
    result := ''
  else
    result := FReferenceSeqString.value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetReferenceSeqStringST(value : String);
begin
  if value <> '' then
  begin
    if FReferenceSeqString = nil then
      FReferenceSeqString := TFhirString.create;
    FReferenceSeqString.value := value
  end
  else if FReferenceSeqString <> nil then
    FReferenceSeqString.value := '';
end;

procedure TFhirMolecularSequenceReferenceSeq.SetStrand(value : TFhirEnum);
begin
  FStrand.free;
  FStrand := value;
end;

function TFhirMolecularSequenceReferenceSeq.GetStrandST : TFhirStrandTypeEnum;
begin
  if FStrand = nil then
    result := TFhirStrandTypeEnum(0)
  else
    result := TFhirStrandTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirStrandTypeEnum, FStrand.value));
end;

procedure TFhirMolecularSequenceReferenceSeq.SetStrandST(value : TFhirStrandTypeEnum);
begin
  if ord(value) = 0 then
    StrandElement := nil
  else
    StrandElement := TFhirEnum.create(SYSTEMS_TFhirStrandTypeEnum[value], CODES_TFhirStrandTypeEnum[value]);
end;

procedure TFhirMolecularSequenceReferenceSeq.SetWindowStart(value : TFhirInteger);
begin
  FWindowStart.free;
  FWindowStart := value;
end;

function TFhirMolecularSequenceReferenceSeq.GetWindowStartST : String;
begin
  if FWindowStart = nil then
    result := ''
  else
    result := FWindowStart.value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetWindowStartST(value : String);
begin
  if value <> '' then
  begin
    if FWindowStart = nil then
      FWindowStart := TFhirInteger.create;
    FWindowStart.value := value
  end
  else if FWindowStart <> nil then
    FWindowStart.value := '';
end;

procedure TFhirMolecularSequenceReferenceSeq.SetWindowEnd(value : TFhirInteger);
begin
  FWindowEnd.free;
  FWindowEnd := value;
end;

function TFhirMolecularSequenceReferenceSeq.GetWindowEndST : String;
begin
  if FWindowEnd = nil then
    result := ''
  else
    result := FWindowEnd.value;
end;

procedure TFhirMolecularSequenceReferenceSeq.SetWindowEndST(value : String);
begin
  if value <> '' then
  begin
    if FWindowEnd = nil then
      FWindowEnd := TFhirInteger.create;
    FWindowEnd.value := value
  end
  else if FWindowEnd <> nil then
    FWindowEnd.value := '';
end;

{ TFhirMolecularSequenceReferenceSeqListEnumerator }

constructor TFhirMolecularSequenceReferenceSeqListEnumerator.Create(list : TFhirMolecularSequenceReferenceSeqList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceReferenceSeqListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceReferenceSeqListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceReferenceSeqListEnumerator.GetCurrent : TFhirMolecularSequenceReferenceSeq;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceReferenceSeqListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMolecularSequenceReferenceSeqList }

function TFhirMolecularSequenceReferenceSeqList.AddItem(value: TFhirMolecularSequenceReferenceSeq): TFhirMolecularSequenceReferenceSeq;
begin
  assert(value.ClassName = 'TFhirMolecularSequenceReferenceSeq', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceReferenceSeq');
  add(value);
  result := value;
end;

function TFhirMolecularSequenceReferenceSeqList.Append: TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceReferenceSeqList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceReferenceSeqList.GetEnumerator : TFhirMolecularSequenceReferenceSeqListEnumerator;
begin
  result := TFhirMolecularSequenceReferenceSeqListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceReferenceSeqList.Clone: TFhirMolecularSequenceReferenceSeqList;
begin
  result := TFhirMolecularSequenceReferenceSeqList(inherited Clone);
end;

function TFhirMolecularSequenceReferenceSeqList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceReferenceSeqList.GetItemN(index: Integer): TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceReferenceSeqList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceReferenceSeq;
end;
function TFhirMolecularSequenceReferenceSeqList.IndexOf(value: TFhirMolecularSequenceReferenceSeq): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceReferenceSeqList.Insert(index: Integer): TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceReferenceSeqList.InsertItem(index: Integer; value: TFhirMolecularSequenceReferenceSeq);
begin
  assert(value is TFhirMolecularSequenceReferenceSeq);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceReferenceSeqList.Item(index: Integer): TFhirMolecularSequenceReferenceSeq;
begin
  result := TFhirMolecularSequenceReferenceSeq(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceReferenceSeqList.Link: TFhirMolecularSequenceReferenceSeqList;
begin
  result := TFhirMolecularSequenceReferenceSeqList(inherited Link);
end;

procedure TFhirMolecularSequenceReferenceSeqList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceReferenceSeqList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceReferenceSeq);
begin
  assert(value is TFhirMolecularSequenceReferenceSeq);
  FhirMolecularSequenceReferenceSeqs[index] := value;
end;

procedure TFhirMolecularSequenceReferenceSeqList.SetItemN(index: Integer; value: TFhirMolecularSequenceReferenceSeq);
begin
  assert(value is TFhirMolecularSequenceReferenceSeq);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceVariant }

constructor TFhirMolecularSequenceVariant.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceVariant.Destroy;
begin
  FStart.free;
  FEnd_.free;
  FObservedAllele.free;
  FReferenceAllele.free;
  FCigar.free;
  FVariantPointer.free;
  inherited;
end;

procedure TFhirMolecularSequenceVariant.Assign(oSource : TFslObject);
begin
  inherited;
  startElement := TFhirMolecularSequenceVariant(oSource).startElement.Clone;
  end_Element := TFhirMolecularSequenceVariant(oSource).end_Element.Clone;
  observedAlleleElement := TFhirMolecularSequenceVariant(oSource).observedAlleleElement.Clone;
  referenceAlleleElement := TFhirMolecularSequenceVariant(oSource).referenceAlleleElement.Clone;
  cigarElement := TFhirMolecularSequenceVariant(oSource).cigarElement.Clone;
  variantPointer := TFhirMolecularSequenceVariant(oSource).variantPointer.Clone;
end;

procedure TFhirMolecularSequenceVariant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'observedAllele') Then
     list.add(self.link, 'observedAllele', FObservedAllele.Link);
  if (child_name = 'referenceAllele') Then
     list.add(self.link, 'referenceAllele', FReferenceAllele.Link);
  if (child_name = 'cigar') Then
     list.add(self.link, 'cigar', FCigar.Link);
  if (child_name = 'variantPointer') Then
     list.add(self.link, 'variantPointer', FVariantPointer.Link);
end;

procedure TFhirMolecularSequenceVariant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link));
  oList.add(TFHIRProperty.create(self, 'observedAllele', 'string', false, TFhirString, FObservedAllele.Link));
  oList.add(TFHIRProperty.create(self, 'referenceAllele', 'string', false, TFhirString, FReferenceAllele.Link));
  oList.add(TFHIRProperty.create(self, 'cigar', 'string', false, TFhirString, FCigar.Link));
  oList.add(TFHIRProperty.create(self, 'variantPointer', 'Reference', false, TFhirReference, FVariantPointer.Link));
end;

function TFhirMolecularSequenceVariant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'start') then
  begin
    StartElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'observedAllele') then
  begin
    ObservedAlleleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'referenceAllele') then
  begin
    ReferenceAlleleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'cigar') then
  begin
    CigarElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'variantPointer') then
  begin
    VariantPointer := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceVariant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceVariant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'start') then result := TFhirInteger.create()
  else if (propName = 'end') then result := TFhirInteger.create()
  else if (propName = 'observedAllele') then result := TFhirString.create()
  else if (propName = 'referenceAllele') then result := TFhirString.create()
  else if (propName = 'cigar') then result := TFhirString.create()
  else if (propName = 'variantPointer') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceVariant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else if (propName = 'observedAllele') then result := 'string'
  else if (propName = 'referenceAllele') then result := 'string'
  else if (propName = 'cigar') then result := 'string'
  else if (propName = 'variantPointer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceVariant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'observedAllele') then ObservedAlleleElement := nil
  else if (propName = 'referenceAllele') then ReferenceAlleleElement := nil
  else if (propName = 'cigar') then CigarElement := nil
  else if (propName = 'variantPointer') then VariantPointerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceVariant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'start') then StartElement := asInteger(new)
  else if (propName = 'end') then End_Element := asInteger(new)
  else if (propName = 'observedAllele') then ObservedAlleleElement := asString(new)
  else if (propName = 'referenceAllele') then ReferenceAlleleElement := asString(new)
  else if (propName = 'cigar') then CigarElement := asString(new)
  else if (propName = 'variantPointer') then VariantPointerElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceVariant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceVariant.fhirType : string;
begin
  result := 'MolecularSequence.variant';
end;

function TFhirMolecularSequenceVariant.Link : TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant(inherited Link);
end;

function TFhirMolecularSequenceVariant.Clone : TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant(inherited Clone);
end;

function TFhirMolecularSequenceVariant.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceVariant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceVariant)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceVariant(other);
    result := compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and 
      compareDeep(observedAlleleElement, o.observedAlleleElement, true) and compareDeep(referenceAlleleElement, o.referenceAlleleElement, true) and 
      compareDeep(cigarElement, o.cigarElement, true) and compareDeep(variantPointerElement, o.variantPointerElement, true);
  end;
end;

function TFhirMolecularSequenceVariant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FObservedAllele) and isEmptyProp(FReferenceAllele) and isEmptyProp(FCigar) and isEmptyProp(FVariantPointer);
end;

procedure TFhirMolecularSequenceVariant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('start');
  fields.add('end');
  fields.add('observedAllele');
  fields.add('referenceAllele');
  fields.add('cigar');
  fields.add('variantPointer');
end;

function TFhirMolecularSequenceVariant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMolecularSequenceVariant.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value;
end;

function TFhirMolecularSequenceVariant.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

procedure TFhirMolecularSequenceVariant.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirMolecularSequenceVariant.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

procedure TFhirMolecularSequenceVariant.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetObservedAllele(value : TFhirString);
begin
  FObservedAllele.free;
  FObservedAllele := value;
end;

function TFhirMolecularSequenceVariant.GetObservedAlleleST : String;
begin
  if FObservedAllele = nil then
    result := ''
  else
    result := FObservedAllele.value;
end;

procedure TFhirMolecularSequenceVariant.SetObservedAlleleST(value : String);
begin
  if value <> '' then
  begin
    if FObservedAllele = nil then
      FObservedAllele := TFhirString.create;
    FObservedAllele.value := value
  end
  else if FObservedAllele <> nil then
    FObservedAllele.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetReferenceAllele(value : TFhirString);
begin
  FReferenceAllele.free;
  FReferenceAllele := value;
end;

function TFhirMolecularSequenceVariant.GetReferenceAlleleST : String;
begin
  if FReferenceAllele = nil then
    result := ''
  else
    result := FReferenceAllele.value;
end;

procedure TFhirMolecularSequenceVariant.SetReferenceAlleleST(value : String);
begin
  if value <> '' then
  begin
    if FReferenceAllele = nil then
      FReferenceAllele := TFhirString.create;
    FReferenceAllele.value := value
  end
  else if FReferenceAllele <> nil then
    FReferenceAllele.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetCigar(value : TFhirString);
begin
  FCigar.free;
  FCigar := value;
end;

function TFhirMolecularSequenceVariant.GetCigarST : String;
begin
  if FCigar = nil then
    result := ''
  else
    result := FCigar.value;
end;

procedure TFhirMolecularSequenceVariant.SetCigarST(value : String);
begin
  if value <> '' then
  begin
    if FCigar = nil then
      FCigar := TFhirString.create;
    FCigar.value := value
  end
  else if FCigar <> nil then
    FCigar.value := '';
end;

procedure TFhirMolecularSequenceVariant.SetVariantPointer(value : TFhirReference);
begin
  FVariantPointer.free;
  FVariantPointer := value;
end;

{ TFhirMolecularSequenceVariantListEnumerator }

constructor TFhirMolecularSequenceVariantListEnumerator.Create(list : TFhirMolecularSequenceVariantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceVariantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceVariantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceVariantListEnumerator.GetCurrent : TFhirMolecularSequenceVariant;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceVariantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMolecularSequenceVariantList }

function TFhirMolecularSequenceVariantList.AddItem(value: TFhirMolecularSequenceVariant): TFhirMolecularSequenceVariant;
begin
  assert(value.ClassName = 'TFhirMolecularSequenceVariant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceVariant');
  add(value);
  result := value;
end;

function TFhirMolecularSequenceVariantList.Append: TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceVariantList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceVariantList.GetEnumerator : TFhirMolecularSequenceVariantListEnumerator;
begin
  result := TFhirMolecularSequenceVariantListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceVariantList.Clone: TFhirMolecularSequenceVariantList;
begin
  result := TFhirMolecularSequenceVariantList(inherited Clone);
end;

function TFhirMolecularSequenceVariantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceVariantList.GetItemN(index: Integer): TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceVariantList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceVariant;
end;
function TFhirMolecularSequenceVariantList.IndexOf(value: TFhirMolecularSequenceVariant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceVariantList.Insert(index: Integer): TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceVariantList.InsertItem(index: Integer; value: TFhirMolecularSequenceVariant);
begin
  assert(value is TFhirMolecularSequenceVariant);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceVariantList.Item(index: Integer): TFhirMolecularSequenceVariant;
begin
  result := TFhirMolecularSequenceVariant(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceVariantList.Link: TFhirMolecularSequenceVariantList;
begin
  result := TFhirMolecularSequenceVariantList(inherited Link);
end;

procedure TFhirMolecularSequenceVariantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceVariantList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceVariant);
begin
  assert(value is TFhirMolecularSequenceVariant);
  FhirMolecularSequenceVariants[index] := value;
end;

procedure TFhirMolecularSequenceVariantList.SetItemN(index: Integer; value: TFhirMolecularSequenceVariant);
begin
  assert(value is TFhirMolecularSequenceVariant);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceQuality }

constructor TFhirMolecularSequenceQuality.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceQuality.Destroy;
begin
  FType_.free;
  FStandardSequence.free;
  FStart.free;
  FEnd_.free;
  FScore.free;
  FMethod.free;
  FTruthTP.free;
  FQueryTP.free;
  FTruthFN.free;
  FQueryFP.free;
  FGtFP.free;
  FPrecision.free;
  FRecall.free;
  FFScore_.free;
  FRoc.free;
  inherited;
end;

procedure TFhirMolecularSequenceQuality.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirMolecularSequenceQuality(oSource).type_Element.Clone;
  standardSequence := TFhirMolecularSequenceQuality(oSource).standardSequence.Clone;
  startElement := TFhirMolecularSequenceQuality(oSource).startElement.Clone;
  end_Element := TFhirMolecularSequenceQuality(oSource).end_Element.Clone;
  score := TFhirMolecularSequenceQuality(oSource).score.Clone;
  method := TFhirMolecularSequenceQuality(oSource).method.Clone;
  truthTPElement := TFhirMolecularSequenceQuality(oSource).truthTPElement.Clone;
  queryTPElement := TFhirMolecularSequenceQuality(oSource).queryTPElement.Clone;
  truthFNElement := TFhirMolecularSequenceQuality(oSource).truthFNElement.Clone;
  queryFPElement := TFhirMolecularSequenceQuality(oSource).queryFPElement.Clone;
  gtFPElement := TFhirMolecularSequenceQuality(oSource).gtFPElement.Clone;
  precisionElement := TFhirMolecularSequenceQuality(oSource).precisionElement.Clone;
  recallElement := TFhirMolecularSequenceQuality(oSource).recallElement.Clone;
  fScore_Element := TFhirMolecularSequenceQuality(oSource).fScore_Element.Clone;
  roc := TFhirMolecularSequenceQuality(oSource).roc.Clone;
end;

procedure TFhirMolecularSequenceQuality.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'standardSequence') Then
     list.add(self.link, 'standardSequence', FStandardSequence.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'truthTP') Then
     list.add(self.link, 'truthTP', FTruthTP.Link);
  if (child_name = 'queryTP') Then
     list.add(self.link, 'queryTP', FQueryTP.Link);
  if (child_name = 'truthFN') Then
     list.add(self.link, 'truthFN', FTruthFN.Link);
  if (child_name = 'queryFP') Then
     list.add(self.link, 'queryFP', FQueryFP.Link);
  if (child_name = 'gtFP') Then
     list.add(self.link, 'gtFP', FGtFP.Link);
  if (child_name = 'precision') Then
     list.add(self.link, 'precision', FPrecision.Link);
  if (child_name = 'recall') Then
     list.add(self.link, 'recall', FRecall.Link);
  if (child_name = 'fScore') Then
     list.add(self.link, 'fScore', FFScore_.Link);
  if (child_name = 'roc') Then
     list.add(self.link, 'roc', FRoc.Link);
end;

procedure TFhirMolecularSequenceQuality.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'standardSequence', 'CodeableConcept', false, TFhirCodeableConcept, FStandardSequence.Link));
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link));
  oList.add(TFHIRProperty.create(self, 'score', 'Quantity', false, TFhirQuantity, FScore.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'truthTP', 'decimal', false, TFhirDecimal, FTruthTP.Link));
  oList.add(TFHIRProperty.create(self, 'queryTP', 'decimal', false, TFhirDecimal, FQueryTP.Link));
  oList.add(TFHIRProperty.create(self, 'truthFN', 'decimal', false, TFhirDecimal, FTruthFN.Link));
  oList.add(TFHIRProperty.create(self, 'queryFP', 'decimal', false, TFhirDecimal, FQueryFP.Link));
  oList.add(TFHIRProperty.create(self, 'gtFP', 'decimal', false, TFhirDecimal, FGtFP.Link));
  oList.add(TFHIRProperty.create(self, 'precision', 'decimal', false, TFhirDecimal, FPrecision.Link));
  oList.add(TFHIRProperty.create(self, 'recall', 'decimal', false, TFhirDecimal, FRecall.Link));
  oList.add(TFHIRProperty.create(self, 'fScore', 'decimal', false, TFhirDecimal, FFScore_.Link));
  oList.add(TFHIRProperty.create(self, 'roc', 'BackboneElement', false, TFhirMolecularSequenceQualityRoc, FRoc.Link));
end;

function TFhirMolecularSequenceQuality.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirQualityTypeEnum, CODES_TFhirQualityTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'standardSequence') then
  begin
    StandardSequence := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'score') then
  begin
    Score := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'truthTP') then
  begin
    TruthTPElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'queryTP') then
  begin
    QueryTPElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'truthFN') then
  begin
    TruthFNElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'queryFP') then
  begin
    QueryFPElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'gtFP') then
  begin
    GtFPElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'precision') then
  begin
    PrecisionElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'recall') then
  begin
    RecallElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'fScore') then
  begin
    FScore_Element := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'roc') then
  begin
    Roc := propValue as TFhirMolecularSequenceQualityRoc;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceQuality.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceQuality.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirQualityTypeEnum[QualityTypeNull], CODES_TFhirQualityTypeEnum[QualityTypeNull]) 
  else if (propName = 'standardSequence') then result := TFhirCodeableConcept.create()
  else if (propName = 'start') then result := TFhirInteger.create()
  else if (propName = 'end') then result := TFhirInteger.create()
  else if (propName = 'score') then result := TFhirQuantity.create()
  else if (propName = 'method') then result := TFhirCodeableConcept.create()
  else if (propName = 'truthTP') then result := TFhirDecimal.create()
  else if (propName = 'queryTP') then result := TFhirDecimal.create()
  else if (propName = 'truthFN') then result := TFhirDecimal.create()
  else if (propName = 'queryFP') then result := TFhirDecimal.create()
  else if (propName = 'gtFP') then result := TFhirDecimal.create()
  else if (propName = 'precision') then result := TFhirDecimal.create()
  else if (propName = 'recall') then result := TFhirDecimal.create()
  else if (propName = 'fScore') then result := TFhirDecimal.create()
  else if (propName = 'roc') then result := TFhirMolecularSequenceQualityRoc.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceQuality.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'standardSequence') then result := 'CodeableConcept'
  else if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else if (propName = 'score') then result := 'Quantity'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'truthTP') then result := 'decimal'
  else if (propName = 'queryTP') then result := 'decimal'
  else if (propName = 'truthFN') then result := 'decimal'
  else if (propName = 'queryFP') then result := 'decimal'
  else if (propName = 'gtFP') then result := 'decimal'
  else if (propName = 'precision') then result := 'decimal'
  else if (propName = 'recall') then result := 'decimal'
  else if (propName = 'fScore') then result := 'decimal'
  else if (propName = 'roc') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceQuality.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'standardSequence') then StandardSequenceElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'score') then ScoreElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'truthTP') then TruthTPElement := nil
  else if (propName = 'queryTP') then QueryTPElement := nil
  else if (propName = 'truthFN') then TruthFNElement := nil
  else if (propName = 'queryFP') then QueryFPElement := nil
  else if (propName = 'gtFP') then GtFPElement := nil
  else if (propName = 'precision') then PrecisionElement := nil
  else if (propName = 'recall') then RecallElement := nil
  else if (propName = 'fScore') then FScore_Element := nil
  else if (propName = 'roc') then RocElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceQuality.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirQualityTypeEnum, CODES_TFhirQualityTypeEnum, new)
  else if (propName = 'standardSequence') then StandardSequenceElement := new as TFhirCodeableConcept
  else if (propName = 'start') then StartElement := asInteger(new)
  else if (propName = 'end') then End_Element := asInteger(new)
  else if (propName = 'score') then ScoreElement := new as TFhirQuantity
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else if (propName = 'truthTP') then TruthTPElement := asDecimal(new)
  else if (propName = 'queryTP') then QueryTPElement := asDecimal(new)
  else if (propName = 'truthFN') then TruthFNElement := asDecimal(new)
  else if (propName = 'queryFP') then QueryFPElement := asDecimal(new)
  else if (propName = 'gtFP') then GtFPElement := asDecimal(new)
  else if (propName = 'precision') then PrecisionElement := asDecimal(new)
  else if (propName = 'recall') then RecallElement := asDecimal(new)
  else if (propName = 'fScore') then FScore_Element := asDecimal(new)
  else if (propName = 'roc') then RocElement := new as TFhirMolecularSequenceQualityRoc
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceQuality.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceQuality.fhirType : string;
begin
  result := 'MolecularSequence.quality';
end;

function TFhirMolecularSequenceQuality.Link : TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality(inherited Link);
end;

function TFhirMolecularSequenceQuality.Clone : TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality(inherited Clone);
end;

function TFhirMolecularSequenceQuality.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceQuality;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceQuality)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceQuality(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(standardSequenceElement, o.standardSequenceElement, true) and 
      compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true) and 
      compareDeep(scoreElement, o.scoreElement, true) and compareDeep(methodElement, o.methodElement, true) and 
      compareDeep(truthTPElement, o.truthTPElement, true) and compareDeep(queryTPElement, o.queryTPElement, true) and 
      compareDeep(truthFNElement, o.truthFNElement, true) and compareDeep(queryFPElement, o.queryFPElement, true) and 
      compareDeep(gtFPElement, o.gtFPElement, true) and compareDeep(precisionElement, o.precisionElement, true) and 
      compareDeep(recallElement, o.recallElement, true) and compareDeep(fScore_Element, o.fScore_Element, true) and 
      compareDeep(rocElement, o.rocElement, true);
  end;
end;

function TFhirMolecularSequenceQuality.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FStandardSequence) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FScore) and isEmptyProp(FMethod) and isEmptyProp(FTruthTP) and isEmptyProp(FQueryTP) and isEmptyProp(FTruthFN) and isEmptyProp(FQueryFP) and isEmptyProp(FGtFP) and isEmptyProp(FPrecision) and isEmptyProp(FRecall) and isEmptyProp(FFScore_) and isEmptyProp(FRoc);
end;

procedure TFhirMolecularSequenceQuality.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('standardSequence');
  fields.add('start');
  fields.add('end');
  fields.add('score');
  fields.add('method');
  fields.add('truthTP');
  fields.add('queryTP');
  fields.add('truthFN');
  fields.add('queryFP');
  fields.add('gtFP');
  fields.add('precision');
  fields.add('recall');
  fields.add('fScore');
  fields.add('roc');
end;

function TFhirMolecularSequenceQuality.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMolecularSequenceQuality.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMolecularSequenceQuality.GetType_ST : TFhirQualityTypeEnum;
begin
  if FType_ = nil then
    result := TFhirQualityTypeEnum(0)
  else
    result := TFhirQualityTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirQualityTypeEnum, FType_.value));
end;

procedure TFhirMolecularSequenceQuality.SetType_ST(value : TFhirQualityTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirQualityTypeEnum[value], CODES_TFhirQualityTypeEnum[value]);
end;

procedure TFhirMolecularSequenceQuality.SetStandardSequence(value : TFhirCodeableConcept);
begin
  FStandardSequence.free;
  FStandardSequence := value;
end;

procedure TFhirMolecularSequenceQuality.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value;
end;

function TFhirMolecularSequenceQuality.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

procedure TFhirMolecularSequenceQuality.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirMolecularSequenceQuality.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

procedure TFhirMolecularSequenceQuality.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetScore(value : TFhirQuantity);
begin
  FScore.free;
  FScore := value;
end;

procedure TFhirMolecularSequenceQuality.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

procedure TFhirMolecularSequenceQuality.SetTruthTP(value : TFhirDecimal);
begin
  FTruthTP.free;
  FTruthTP := value;
end;

function TFhirMolecularSequenceQuality.GetTruthTPST : String;
begin
  if FTruthTP = nil then
    result := ''
  else
    result := FTruthTP.value;
end;

procedure TFhirMolecularSequenceQuality.SetTruthTPST(value : String);
begin
  if value <> '' then
  begin
    if FTruthTP = nil then
      FTruthTP := TFhirDecimal.create;
    FTruthTP.value := value
  end
  else if FTruthTP <> nil then
    FTruthTP.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetQueryTP(value : TFhirDecimal);
begin
  FQueryTP.free;
  FQueryTP := value;
end;

function TFhirMolecularSequenceQuality.GetQueryTPST : String;
begin
  if FQueryTP = nil then
    result := ''
  else
    result := FQueryTP.value;
end;

procedure TFhirMolecularSequenceQuality.SetQueryTPST(value : String);
begin
  if value <> '' then
  begin
    if FQueryTP = nil then
      FQueryTP := TFhirDecimal.create;
    FQueryTP.value := value
  end
  else if FQueryTP <> nil then
    FQueryTP.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetTruthFN(value : TFhirDecimal);
begin
  FTruthFN.free;
  FTruthFN := value;
end;

function TFhirMolecularSequenceQuality.GetTruthFNST : String;
begin
  if FTruthFN = nil then
    result := ''
  else
    result := FTruthFN.value;
end;

procedure TFhirMolecularSequenceQuality.SetTruthFNST(value : String);
begin
  if value <> '' then
  begin
    if FTruthFN = nil then
      FTruthFN := TFhirDecimal.create;
    FTruthFN.value := value
  end
  else if FTruthFN <> nil then
    FTruthFN.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetQueryFP(value : TFhirDecimal);
begin
  FQueryFP.free;
  FQueryFP := value;
end;

function TFhirMolecularSequenceQuality.GetQueryFPST : String;
begin
  if FQueryFP = nil then
    result := ''
  else
    result := FQueryFP.value;
end;

procedure TFhirMolecularSequenceQuality.SetQueryFPST(value : String);
begin
  if value <> '' then
  begin
    if FQueryFP = nil then
      FQueryFP := TFhirDecimal.create;
    FQueryFP.value := value
  end
  else if FQueryFP <> nil then
    FQueryFP.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetGtFP(value : TFhirDecimal);
begin
  FGtFP.free;
  FGtFP := value;
end;

function TFhirMolecularSequenceQuality.GetGtFPST : String;
begin
  if FGtFP = nil then
    result := ''
  else
    result := FGtFP.value;
end;

procedure TFhirMolecularSequenceQuality.SetGtFPST(value : String);
begin
  if value <> '' then
  begin
    if FGtFP = nil then
      FGtFP := TFhirDecimal.create;
    FGtFP.value := value
  end
  else if FGtFP <> nil then
    FGtFP.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetPrecision(value : TFhirDecimal);
begin
  FPrecision.free;
  FPrecision := value;
end;

function TFhirMolecularSequenceQuality.GetPrecisionST : String;
begin
  if FPrecision = nil then
    result := ''
  else
    result := FPrecision.value;
end;

procedure TFhirMolecularSequenceQuality.SetPrecisionST(value : String);
begin
  if value <> '' then
  begin
    if FPrecision = nil then
      FPrecision := TFhirDecimal.create;
    FPrecision.value := value
  end
  else if FPrecision <> nil then
    FPrecision.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetRecall(value : TFhirDecimal);
begin
  FRecall.free;
  FRecall := value;
end;

function TFhirMolecularSequenceQuality.GetRecallST : String;
begin
  if FRecall = nil then
    result := ''
  else
    result := FRecall.value;
end;

procedure TFhirMolecularSequenceQuality.SetRecallST(value : String);
begin
  if value <> '' then
  begin
    if FRecall = nil then
      FRecall := TFhirDecimal.create;
    FRecall.value := value
  end
  else if FRecall <> nil then
    FRecall.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetFScore_(value : TFhirDecimal);
begin
  FFScore_.free;
  FFScore_ := value;
end;

function TFhirMolecularSequenceQuality.GetFScore_ST : String;
begin
  if FFScore_ = nil then
    result := ''
  else
    result := FFScore_.value;
end;

procedure TFhirMolecularSequenceQuality.SetFScore_ST(value : String);
begin
  if value <> '' then
  begin
    if FFScore_ = nil then
      FFScore_ := TFhirDecimal.create;
    FFScore_.value := value
  end
  else if FFScore_ <> nil then
    FFScore_.value := '';
end;

procedure TFhirMolecularSequenceQuality.SetRoc(value : TFhirMolecularSequenceQualityRoc);
begin
  FRoc.free;
  FRoc := value;
end;

{ TFhirMolecularSequenceQualityListEnumerator }

constructor TFhirMolecularSequenceQualityListEnumerator.Create(list : TFhirMolecularSequenceQualityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceQualityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceQualityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceQualityListEnumerator.GetCurrent : TFhirMolecularSequenceQuality;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceQualityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMolecularSequenceQualityList }

function TFhirMolecularSequenceQualityList.AddItem(value: TFhirMolecularSequenceQuality): TFhirMolecularSequenceQuality;
begin
  assert(value.ClassName = 'TFhirMolecularSequenceQuality', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceQuality');
  add(value);
  result := value;
end;

function TFhirMolecularSequenceQualityList.Append: TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceQualityList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceQualityList.GetEnumerator : TFhirMolecularSequenceQualityListEnumerator;
begin
  result := TFhirMolecularSequenceQualityListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceQualityList.Clone: TFhirMolecularSequenceQualityList;
begin
  result := TFhirMolecularSequenceQualityList(inherited Clone);
end;

function TFhirMolecularSequenceQualityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceQualityList.GetItemN(index: Integer): TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceQualityList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceQuality;
end;
function TFhirMolecularSequenceQualityList.IndexOf(value: TFhirMolecularSequenceQuality): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceQualityList.Insert(index: Integer): TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceQualityList.InsertItem(index: Integer; value: TFhirMolecularSequenceQuality);
begin
  assert(value is TFhirMolecularSequenceQuality);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceQualityList.Item(index: Integer): TFhirMolecularSequenceQuality;
begin
  result := TFhirMolecularSequenceQuality(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceQualityList.Link: TFhirMolecularSequenceQualityList;
begin
  result := TFhirMolecularSequenceQualityList(inherited Link);
end;

procedure TFhirMolecularSequenceQualityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceQualityList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceQuality);
begin
  assert(value is TFhirMolecularSequenceQuality);
  FhirMolecularSequenceQualities[index] := value;
end;

procedure TFhirMolecularSequenceQualityList.SetItemN(index: Integer; value: TFhirMolecularSequenceQuality);
begin
  assert(value is TFhirMolecularSequenceQuality);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceQualityRoc }

constructor TFhirMolecularSequenceQualityRoc.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceQualityRoc.Destroy;
begin
  FScoreList.Free;
  FNumTPList.Free;
  FNumFPList.Free;
  FNumFNList.Free;
  FPrecisionList.Free;
  FSensitivityList.Free;
  FFMeasureList.Free;
  inherited;
end;

procedure TFhirMolecularSequenceQualityRoc.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMolecularSequenceQualityRoc(oSource).FScoreList = nil) then
  begin
    FScoreList.free;
    FScoreList := nil;
  end
  else
  begin
    if FScoreList = nil then
      FScoreList := TFhirIntegerList.Create;
    FScoreList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FScoreList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FNumTPList = nil) then
  begin
    FNumTPList.free;
    FNumTPList := nil;
  end
  else
  begin
    if FNumTPList = nil then
      FNumTPList := TFhirIntegerList.Create;
    FNumTPList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FNumTPList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FNumFPList = nil) then
  begin
    FNumFPList.free;
    FNumFPList := nil;
  end
  else
  begin
    if FNumFPList = nil then
      FNumFPList := TFhirIntegerList.Create;
    FNumFPList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FNumFPList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FNumFNList = nil) then
  begin
    FNumFNList.free;
    FNumFNList := nil;
  end
  else
  begin
    if FNumFNList = nil then
      FNumFNList := TFhirIntegerList.Create;
    FNumFNList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FNumFNList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FPrecisionList = nil) then
  begin
    FPrecisionList.free;
    FPrecisionList := nil;
  end
  else
  begin
    if FPrecisionList = nil then
      FPrecisionList := TFhirDecimalList.Create;
    FPrecisionList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FPrecisionList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FSensitivityList = nil) then
  begin
    FSensitivityList.free;
    FSensitivityList := nil;
  end
  else
  begin
    if FSensitivityList = nil then
      FSensitivityList := TFhirDecimalList.Create;
    FSensitivityList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FSensitivityList);
  end;
  if (TFhirMolecularSequenceQualityRoc(oSource).FFMeasureList = nil) then
  begin
    FFMeasureList.free;
    FFMeasureList := nil;
  end
  else
  begin
    if FFMeasureList = nil then
      FFMeasureList := TFhirDecimalList.Create;
    FFMeasureList.Assign(TFhirMolecularSequenceQualityRoc(oSource).FFMeasureList);
  end;
end;

procedure TFhirMolecularSequenceQualityRoc.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'score') Then
    list.addAll(self, 'score', FScoreList);
  if (child_name = 'numTP') Then
    list.addAll(self, 'numTP', FNumTPList);
  if (child_name = 'numFP') Then
    list.addAll(self, 'numFP', FNumFPList);
  if (child_name = 'numFN') Then
    list.addAll(self, 'numFN', FNumFNList);
  if (child_name = 'precision') Then
    list.addAll(self, 'precision', FPrecisionList);
  if (child_name = 'sensitivity') Then
    list.addAll(self, 'sensitivity', FSensitivityList);
  if (child_name = 'fMeasure') Then
    list.addAll(self, 'fMeasure', FFMeasureList);
end;

procedure TFhirMolecularSequenceQualityRoc.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'score', 'integer', true, TFhirInteger, FScoreList.Link));
  oList.add(TFHIRProperty.create(self, 'numTP', 'integer', true, TFhirInteger, FNumTPList.Link));
  oList.add(TFHIRProperty.create(self, 'numFP', 'integer', true, TFhirInteger, FNumFPList.Link));
  oList.add(TFHIRProperty.create(self, 'numFN', 'integer', true, TFhirInteger, FNumFNList.Link));
  oList.add(TFHIRProperty.create(self, 'precision', 'decimal', true, TFhirDecimal, FPrecisionList.Link));
  oList.add(TFHIRProperty.create(self, 'sensitivity', 'decimal', true, TFhirDecimal, FSensitivityList.Link));
  oList.add(TFHIRProperty.create(self, 'fMeasure', 'decimal', true, TFhirDecimal, FFMeasureList.Link));
end;

function TFhirMolecularSequenceQualityRoc.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'score') then
  begin
    ScoreList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'numTP') then
  begin
    NumTPList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'numFP') then
  begin
    NumFPList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'numFN') then
  begin
    NumFNList.add(asInteger(propValue)){2};     result := propValue;

  end
  else if (propName = 'precision') then
  begin
    PrecisionList.add(asDecimal(propValue)){2};     result := propValue;

  end
  else if (propName = 'sensitivity') then
  begin
    SensitivityList.add(asDecimal(propValue)){2};     result := propValue;

  end
  else if (propName = 'fMeasure') then
  begin
    FMeasureList.add(asDecimal(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceQualityRoc.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'score') then ScoreList.insertItem(index, asInteger(propValue))
  else if (propName = 'numTP') then NumTPList.insertItem(index, asInteger(propValue))
  else if (propName = 'numFP') then NumFPList.insertItem(index, asInteger(propValue))
  else if (propName = 'numFN') then NumFNList.insertItem(index, asInteger(propValue))
  else if (propName = 'precision') then PrecisionList.insertItem(index, asDecimal(propValue))
  else if (propName = 'sensitivity') then SensitivityList.insertItem(index, asDecimal(propValue))
  else if (propName = 'fMeasure') then FMeasureList.insertItem(index, asDecimal(propValue))
  else inherited;
end;

function TFhirMolecularSequenceQualityRoc.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'score') then result := ScoreList.new()
  else if (propName = 'numTP') then result := NumTPList.new()
  else if (propName = 'numFP') then result := NumFPList.new()
  else if (propName = 'numFN') then result := NumFNList.new()
  else if (propName = 'precision') then result := PrecisionList.new()
  else if (propName = 'sensitivity') then result := SensitivityList.new()
  else if (propName = 'fMeasure') then result := FMeasureList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceQualityRoc.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'score') then result := 'integer'
  else if (propName = 'numTP') then result := 'integer'
  else if (propName = 'numFP') then result := 'integer'
  else if (propName = 'numFN') then result := 'integer'
  else if (propName = 'precision') then result := 'decimal'
  else if (propName = 'sensitivity') then result := 'decimal'
  else if (propName = 'fMeasure') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceQualityRoc.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'score') then deletePropertyValue('score', ScoreList, value)
  else if (propName = 'numTP') then deletePropertyValue('numTP', NumTPList, value)
  else if (propName = 'numFP') then deletePropertyValue('numFP', NumFPList, value)
  else if (propName = 'numFN') then deletePropertyValue('numFN', NumFNList, value)
  else if (propName = 'precision') then deletePropertyValue('precision', PrecisionList, value)
  else if (propName = 'sensitivity') then deletePropertyValue('sensitivity', SensitivityList, value)
  else if (propName = 'fMeasure') then deletePropertyValue('fMeasure', FMeasureList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceQualityRoc.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'score') then replacePropertyValue('score', ScoreList, existing, new)
  else if (propName = 'numTP') then replacePropertyValue('numTP', NumTPList, existing, new)
  else if (propName = 'numFP') then replacePropertyValue('numFP', NumFPList, existing, new)
  else if (propName = 'numFN') then replacePropertyValue('numFN', NumFNList, existing, new)
  else if (propName = 'precision') then replacePropertyValue('precision', PrecisionList, existing, new)
  else if (propName = 'sensitivity') then replacePropertyValue('sensitivity', SensitivityList, existing, new)
  else if (propName = 'fMeasure') then replacePropertyValue('fMeasure', FMeasureList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceQualityRoc.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'score') then ScoreList.move(source, destination)
  else if (propName = 'numTP') then NumTPList.move(source, destination)
  else if (propName = 'numFP') then NumFPList.move(source, destination)
  else if (propName = 'numFN') then NumFNList.move(source, destination)
  else if (propName = 'precision') then PrecisionList.move(source, destination)
  else if (propName = 'sensitivity') then SensitivityList.move(source, destination)
  else if (propName = 'fMeasure') then FMeasureList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceQualityRoc.fhirType : string;
begin
  result := 'MolecularSequence.quality.roc';
end;

function TFhirMolecularSequenceQualityRoc.Link : TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc(inherited Link);
end;

function TFhirMolecularSequenceQualityRoc.Clone : TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc(inherited Clone);
end;

function TFhirMolecularSequenceQualityRoc.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceQualityRoc;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceQualityRoc)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceQualityRoc(other);
    result := compareDeep(scoreList, o.scoreList, true) and compareDeep(numTPList, o.numTPList, true) and 
      compareDeep(numFPList, o.numFPList, true) and compareDeep(numFNList, o.numFNList, true) and 
      compareDeep(precisionList, o.precisionList, true) and compareDeep(sensitivityList, o.sensitivityList, true) and 
      compareDeep(fMeasureList, o.fMeasureList, true);
  end;
end;

function TFhirMolecularSequenceQualityRoc.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FscoreList) and isEmptyProp(FnumTPList) and isEmptyProp(FnumFPList) and isEmptyProp(FnumFNList) and isEmptyProp(FprecisionList) and isEmptyProp(FsensitivityList) and isEmptyProp(FfMeasureList);
end;

procedure TFhirMolecularSequenceQualityRoc.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('score');
  fields.add('numTP');
  fields.add('numFP');
  fields.add('numFN');
  fields.add('precision');
  fields.add('sensitivity');
  fields.add('fMeasure');
end;

function TFhirMolecularSequenceQualityRoc.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FScoreList.sizeInBytes(magic));
  inc(result, FNumTPList.sizeInBytes(magic));
  inc(result, FNumFPList.sizeInBytes(magic));
  inc(result, FNumFNList.sizeInBytes(magic));
  inc(result, FPrecisionList.sizeInBytes(magic));
  inc(result, FSensitivityList.sizeInBytes(magic));
  inc(result, FFMeasureList.sizeInBytes(magic));
end;

function TFhirMolecularSequenceQualityRoc.GetScoreList : TFhirIntegerList;
begin
  if FScoreList = nil then
    FScoreList := TFhirIntegerList.Create;
  result := FScoreList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasScoreList : boolean;
begin
  result := (FScoreList <> nil) and (FScoreList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetNumTPList : TFhirIntegerList;
begin
  if FNumTPList = nil then
    FNumTPList := TFhirIntegerList.Create;
  result := FNumTPList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasNumTPList : boolean;
begin
  result := (FNumTPList <> nil) and (FNumTPList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetNumFPList : TFhirIntegerList;
begin
  if FNumFPList = nil then
    FNumFPList := TFhirIntegerList.Create;
  result := FNumFPList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasNumFPList : boolean;
begin
  result := (FNumFPList <> nil) and (FNumFPList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetNumFNList : TFhirIntegerList;
begin
  if FNumFNList = nil then
    FNumFNList := TFhirIntegerList.Create;
  result := FNumFNList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasNumFNList : boolean;
begin
  result := (FNumFNList <> nil) and (FNumFNList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetPrecisionList : TFhirDecimalList;
begin
  if FPrecisionList = nil then
    FPrecisionList := TFhirDecimalList.Create;
  result := FPrecisionList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasPrecisionList : boolean;
begin
  result := (FPrecisionList <> nil) and (FPrecisionList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetSensitivityList : TFhirDecimalList;
begin
  if FSensitivityList = nil then
    FSensitivityList := TFhirDecimalList.Create;
  result := FSensitivityList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasSensitivityList : boolean;
begin
  result := (FSensitivityList <> nil) and (FSensitivityList.count > 0);
end;

function TFhirMolecularSequenceQualityRoc.GetFMeasureList : TFhirDecimalList;
begin
  if FFMeasureList = nil then
    FFMeasureList := TFhirDecimalList.Create;
  result := FFMeasureList;
end;

function TFhirMolecularSequenceQualityRoc.GetHasFMeasureList : boolean;
begin
  result := (FFMeasureList <> nil) and (FFMeasureList.count > 0);
end;

{ TFhirMolecularSequenceQualityRocListEnumerator }

constructor TFhirMolecularSequenceQualityRocListEnumerator.Create(list : TFhirMolecularSequenceQualityRocList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceQualityRocListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceQualityRocListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceQualityRocListEnumerator.GetCurrent : TFhirMolecularSequenceQualityRoc;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceQualityRocListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMolecularSequenceQualityRocList }

function TFhirMolecularSequenceQualityRocList.AddItem(value: TFhirMolecularSequenceQualityRoc): TFhirMolecularSequenceQualityRoc;
begin
  assert(value.ClassName = 'TFhirMolecularSequenceQualityRoc', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceQualityRoc');
  add(value);
  result := value;
end;

function TFhirMolecularSequenceQualityRocList.Append: TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceQualityRocList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceQualityRocList.GetEnumerator : TFhirMolecularSequenceQualityRocListEnumerator;
begin
  result := TFhirMolecularSequenceQualityRocListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceQualityRocList.Clone: TFhirMolecularSequenceQualityRocList;
begin
  result := TFhirMolecularSequenceQualityRocList(inherited Clone);
end;

function TFhirMolecularSequenceQualityRocList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceQualityRocList.GetItemN(index: Integer): TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceQualityRocList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceQualityRoc;
end;
function TFhirMolecularSequenceQualityRocList.IndexOf(value: TFhirMolecularSequenceQualityRoc): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceQualityRocList.Insert(index: Integer): TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceQualityRocList.InsertItem(index: Integer; value: TFhirMolecularSequenceQualityRoc);
begin
  assert(value is TFhirMolecularSequenceQualityRoc);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceQualityRocList.Item(index: Integer): TFhirMolecularSequenceQualityRoc;
begin
  result := TFhirMolecularSequenceQualityRoc(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceQualityRocList.Link: TFhirMolecularSequenceQualityRocList;
begin
  result := TFhirMolecularSequenceQualityRocList(inherited Link);
end;

procedure TFhirMolecularSequenceQualityRocList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceQualityRocList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceQualityRoc);
begin
  assert(value is TFhirMolecularSequenceQualityRoc);
  FhirMolecularSequenceQualityRocs[index] := value;
end;

procedure TFhirMolecularSequenceQualityRocList.SetItemN(index: Integer; value: TFhirMolecularSequenceQualityRoc);
begin
  assert(value is TFhirMolecularSequenceQualityRoc);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceRepository }

constructor TFhirMolecularSequenceRepository.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceRepository.Destroy;
begin
  FType_.free;
  FUrl.free;
  FName.free;
  FDatasetId.free;
  FVariantsetId.free;
  FReadsetId.free;
  inherited;
end;

procedure TFhirMolecularSequenceRepository.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirMolecularSequenceRepository(oSource).type_Element.Clone;
  urlElement := TFhirMolecularSequenceRepository(oSource).urlElement.Clone;
  nameElement := TFhirMolecularSequenceRepository(oSource).nameElement.Clone;
  datasetIdElement := TFhirMolecularSequenceRepository(oSource).datasetIdElement.Clone;
  variantsetIdElement := TFhirMolecularSequenceRepository(oSource).variantsetIdElement.Clone;
  readsetIdElement := TFhirMolecularSequenceRepository(oSource).readsetIdElement.Clone;
end;

procedure TFhirMolecularSequenceRepository.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'datasetId') Then
     list.add(self.link, 'datasetId', FDatasetId.Link);
  if (child_name = 'variantsetId') Then
     list.add(self.link, 'variantsetId', FVariantsetId.Link);
  if (child_name = 'readsetId') Then
     list.add(self.link, 'readsetId', FReadsetId.Link);
end;

procedure TFhirMolecularSequenceRepository.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'datasetId', 'string', false, TFhirString, FDatasetId.Link));
  oList.add(TFHIRProperty.create(self, 'variantsetId', 'string', false, TFhirString, FVariantsetId.Link));
  oList.add(TFHIRProperty.create(self, 'readsetId', 'string', false, TFhirString, FReadsetId.Link));
end;

function TFhirMolecularSequenceRepository.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirRepositoryTypeEnum, CODES_TFhirRepositoryTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'datasetId') then
  begin
    DatasetIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'variantsetId') then
  begin
    VariantsetIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'readsetId') then
  begin
    ReadsetIdElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceRepository.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceRepository.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirRepositoryTypeEnum[RepositoryTypeNull], CODES_TFhirRepositoryTypeEnum[RepositoryTypeNull]) 
  else if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'datasetId') then result := TFhirString.create()
  else if (propName = 'variantsetId') then result := TFhirString.create()
  else if (propName = 'readsetId') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceRepository.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'datasetId') then result := 'string'
  else if (propName = 'variantsetId') then result := 'string'
  else if (propName = 'readsetId') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceRepository.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'datasetId') then DatasetIdElement := nil
  else if (propName = 'variantsetId') then VariantsetIdElement := nil
  else if (propName = 'readsetId') then ReadsetIdElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceRepository.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirRepositoryTypeEnum, CODES_TFhirRepositoryTypeEnum, new)
  else if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'datasetId') then DatasetIdElement := asString(new)
  else if (propName = 'variantsetId') then VariantsetIdElement := asString(new)
  else if (propName = 'readsetId') then ReadsetIdElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceRepository.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceRepository.fhirType : string;
begin
  result := 'MolecularSequence.repository';
end;

function TFhirMolecularSequenceRepository.Link : TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository(inherited Link);
end;

function TFhirMolecularSequenceRepository.Clone : TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository(inherited Clone);
end;

function TFhirMolecularSequenceRepository.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceRepository;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceRepository)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceRepository(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(datasetIdElement, o.datasetIdElement, true) and 
      compareDeep(variantsetIdElement, o.variantsetIdElement, true) and compareDeep(readsetIdElement, o.readsetIdElement, true);
  end;
end;

function TFhirMolecularSequenceRepository.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUrl) and isEmptyProp(FName) and isEmptyProp(FDatasetId) and isEmptyProp(FVariantsetId) and isEmptyProp(FReadsetId);
end;

procedure TFhirMolecularSequenceRepository.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('url');
  fields.add('name');
  fields.add('datasetId');
  fields.add('variantsetId');
  fields.add('readsetId');
end;

function TFhirMolecularSequenceRepository.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMolecularSequenceRepository.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMolecularSequenceRepository.GetType_ST : TFhirRepositoryTypeEnum;
begin
  if FType_ = nil then
    result := TFhirRepositoryTypeEnum(0)
  else
    result := TFhirRepositoryTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirRepositoryTypeEnum, FType_.value));
end;

procedure TFhirMolecularSequenceRepository.SetType_ST(value : TFhirRepositoryTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirRepositoryTypeEnum[value], CODES_TFhirRepositoryTypeEnum[value]);
end;

procedure TFhirMolecularSequenceRepository.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirMolecularSequenceRepository.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirMolecularSequenceRepository.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirMolecularSequenceRepository.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirMolecularSequenceRepository.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMolecularSequenceRepository.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirMolecularSequenceRepository.SetDatasetId(value : TFhirString);
begin
  FDatasetId.free;
  FDatasetId := value;
end;

function TFhirMolecularSequenceRepository.GetDatasetIdST : String;
begin
  if FDatasetId = nil then
    result := ''
  else
    result := FDatasetId.value;
end;

procedure TFhirMolecularSequenceRepository.SetDatasetIdST(value : String);
begin
  if value <> '' then
  begin
    if FDatasetId = nil then
      FDatasetId := TFhirString.create;
    FDatasetId.value := value
  end
  else if FDatasetId <> nil then
    FDatasetId.value := '';
end;

procedure TFhirMolecularSequenceRepository.SetVariantsetId(value : TFhirString);
begin
  FVariantsetId.free;
  FVariantsetId := value;
end;

function TFhirMolecularSequenceRepository.GetVariantsetIdST : String;
begin
  if FVariantsetId = nil then
    result := ''
  else
    result := FVariantsetId.value;
end;

procedure TFhirMolecularSequenceRepository.SetVariantsetIdST(value : String);
begin
  if value <> '' then
  begin
    if FVariantsetId = nil then
      FVariantsetId := TFhirString.create;
    FVariantsetId.value := value
  end
  else if FVariantsetId <> nil then
    FVariantsetId.value := '';
end;

procedure TFhirMolecularSequenceRepository.SetReadsetId(value : TFhirString);
begin
  FReadsetId.free;
  FReadsetId := value;
end;

function TFhirMolecularSequenceRepository.GetReadsetIdST : String;
begin
  if FReadsetId = nil then
    result := ''
  else
    result := FReadsetId.value;
end;

procedure TFhirMolecularSequenceRepository.SetReadsetIdST(value : String);
begin
  if value <> '' then
  begin
    if FReadsetId = nil then
      FReadsetId := TFhirString.create;
    FReadsetId.value := value
  end
  else if FReadsetId <> nil then
    FReadsetId.value := '';
end;

{ TFhirMolecularSequenceRepositoryListEnumerator }

constructor TFhirMolecularSequenceRepositoryListEnumerator.Create(list : TFhirMolecularSequenceRepositoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceRepositoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceRepositoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceRepositoryListEnumerator.GetCurrent : TFhirMolecularSequenceRepository;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceRepositoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMolecularSequenceRepositoryList }

function TFhirMolecularSequenceRepositoryList.AddItem(value: TFhirMolecularSequenceRepository): TFhirMolecularSequenceRepository;
begin
  assert(value.ClassName = 'TFhirMolecularSequenceRepository', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceRepository');
  add(value);
  result := value;
end;

function TFhirMolecularSequenceRepositoryList.Append: TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceRepositoryList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceRepositoryList.GetEnumerator : TFhirMolecularSequenceRepositoryListEnumerator;
begin
  result := TFhirMolecularSequenceRepositoryListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceRepositoryList.Clone: TFhirMolecularSequenceRepositoryList;
begin
  result := TFhirMolecularSequenceRepositoryList(inherited Clone);
end;

function TFhirMolecularSequenceRepositoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceRepositoryList.GetItemN(index: Integer): TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceRepositoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceRepository;
end;
function TFhirMolecularSequenceRepositoryList.IndexOf(value: TFhirMolecularSequenceRepository): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceRepositoryList.Insert(index: Integer): TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceRepositoryList.InsertItem(index: Integer; value: TFhirMolecularSequenceRepository);
begin
  assert(value is TFhirMolecularSequenceRepository);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceRepositoryList.Item(index: Integer): TFhirMolecularSequenceRepository;
begin
  result := TFhirMolecularSequenceRepository(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceRepositoryList.Link: TFhirMolecularSequenceRepositoryList;
begin
  result := TFhirMolecularSequenceRepositoryList(inherited Link);
end;

procedure TFhirMolecularSequenceRepositoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceRepositoryList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceRepository);
begin
  assert(value is TFhirMolecularSequenceRepository);
  FhirMolecularSequenceRepositories[index] := value;
end;

procedure TFhirMolecularSequenceRepositoryList.SetItemN(index: Integer; value: TFhirMolecularSequenceRepository);
begin
  assert(value is TFhirMolecularSequenceRepository);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceStructureVariant }

constructor TFhirMolecularSequenceStructureVariant.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceStructureVariant.Destroy;
begin
  FVariantType.free;
  FExact.free;
  FLength.free;
  FOuter.free;
  FInner.free;
  inherited;
end;

procedure TFhirMolecularSequenceStructureVariant.Assign(oSource : TFslObject);
begin
  inherited;
  variantType := TFhirMolecularSequenceStructureVariant(oSource).variantType.Clone;
  exactElement := TFhirMolecularSequenceStructureVariant(oSource).exactElement.Clone;
  lengthElement := TFhirMolecularSequenceStructureVariant(oSource).lengthElement.Clone;
  outer := TFhirMolecularSequenceStructureVariant(oSource).outer.Clone;
  inner := TFhirMolecularSequenceStructureVariant(oSource).inner.Clone;
end;

procedure TFhirMolecularSequenceStructureVariant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'variantType') Then
     list.add(self.link, 'variantType', FVariantType.Link);
  if (child_name = 'exact') Then
     list.add(self.link, 'exact', FExact.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'outer') Then
     list.add(self.link, 'outer', FOuter.Link);
  if (child_name = 'inner') Then
     list.add(self.link, 'inner', FInner.Link);
end;

procedure TFhirMolecularSequenceStructureVariant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'variantType', 'CodeableConcept', false, TFhirCodeableConcept, FVariantType.Link));
  oList.add(TFHIRProperty.create(self, 'exact', 'boolean', false, TFhirBoolean, FExact.Link));
  oList.add(TFHIRProperty.create(self, 'length', 'integer', false, TFhirInteger, FLength.Link));
  oList.add(TFHIRProperty.create(self, 'outer', 'BackboneElement', false, TFhirMolecularSequenceStructureVariantOuter, FOuter.Link));
  oList.add(TFHIRProperty.create(self, 'inner', 'BackboneElement', false, TFhirMolecularSequenceStructureVariantInner, FInner.Link));
end;

function TFhirMolecularSequenceStructureVariant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'variantType') then
  begin
    VariantType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'exact') then
  begin
    ExactElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    LengthElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'outer') then
  begin
    Outer := propValue as TFhirMolecularSequenceStructureVariantOuter;
    result := propValue;
  end
  else if (propName = 'inner') then
  begin
    Inner := propValue as TFhirMolecularSequenceStructureVariantInner;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceStructureVariant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceStructureVariant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'variantType') then result := TFhirCodeableConcept.create()
  else if (propName = 'exact') then result := TFhirBoolean.create()
  else if (propName = 'length') then result := TFhirInteger.create()
  else if (propName = 'outer') then result := TFhirMolecularSequenceStructureVariantOuter.create()
  else if (propName = 'inner') then result := TFhirMolecularSequenceStructureVariantInner.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceStructureVariant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'variantType') then result := 'CodeableConcept'
  else if (propName = 'exact') then result := 'boolean'
  else if (propName = 'length') then result := 'integer'
  else if (propName = 'outer') then result := 'BackboneElement'
  else if (propName = 'inner') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceStructureVariant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'variantType') then VariantTypeElement := nil
  else if (propName = 'exact') then ExactElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'outer') then OuterElement := nil
  else if (propName = 'inner') then InnerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceStructureVariant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'variantType') then VariantTypeElement := new as TFhirCodeableConcept
  else if (propName = 'exact') then ExactElement := asBoolean(new)
  else if (propName = 'length') then LengthElement := asInteger(new)
  else if (propName = 'outer') then OuterElement := new as TFhirMolecularSequenceStructureVariantOuter
  else if (propName = 'inner') then InnerElement := new as TFhirMolecularSequenceStructureVariantInner
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceStructureVariant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceStructureVariant.fhirType : string;
begin
  result := 'MolecularSequence.structureVariant';
end;

function TFhirMolecularSequenceStructureVariant.Link : TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant(inherited Link);
end;

function TFhirMolecularSequenceStructureVariant.Clone : TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariant.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceStructureVariant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceStructureVariant)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceStructureVariant(other);
    result := compareDeep(variantTypeElement, o.variantTypeElement, true) and compareDeep(exactElement, o.exactElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(outerElement, o.outerElement, true) and 
      compareDeep(innerElement, o.innerElement, true);
  end;
end;

function TFhirMolecularSequenceStructureVariant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FVariantType) and isEmptyProp(FExact) and isEmptyProp(FLength) and isEmptyProp(FOuter) and isEmptyProp(FInner);
end;

procedure TFhirMolecularSequenceStructureVariant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('variantType');
  fields.add('exact');
  fields.add('length');
  fields.add('outer');
  fields.add('inner');
end;

function TFhirMolecularSequenceStructureVariant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMolecularSequenceStructureVariant.SetVariantType(value : TFhirCodeableConcept);
begin
  FVariantType.free;
  FVariantType := value;
end;

procedure TFhirMolecularSequenceStructureVariant.SetExact(value : TFhirBoolean);
begin
  FExact.free;
  FExact := value;
end;

function TFhirMolecularSequenceStructureVariant.GetExactST : Boolean;
begin
  if FExact = nil then
    result := false
  else
    result := FExact.value;
end;

procedure TFhirMolecularSequenceStructureVariant.SetExactST(value : Boolean);
begin
  if FExact = nil then
    FExact := TFhirBoolean.create;
  FExact.value := value
end;

procedure TFhirMolecularSequenceStructureVariant.SetLength(value : TFhirInteger);
begin
  FLength.free;
  FLength := value;
end;

function TFhirMolecularSequenceStructureVariant.GetLengthST : String;
begin
  if FLength = nil then
    result := ''
  else
    result := FLength.value;
end;

procedure TFhirMolecularSequenceStructureVariant.SetLengthST(value : String);
begin
  if value <> '' then
  begin
    if FLength = nil then
      FLength := TFhirInteger.create;
    FLength.value := value
  end
  else if FLength <> nil then
    FLength.value := '';
end;

procedure TFhirMolecularSequenceStructureVariant.SetOuter(value : TFhirMolecularSequenceStructureVariantOuter);
begin
  FOuter.free;
  FOuter := value;
end;

procedure TFhirMolecularSequenceStructureVariant.SetInner(value : TFhirMolecularSequenceStructureVariantInner);
begin
  FInner.free;
  FInner := value;
end;

{ TFhirMolecularSequenceStructureVariantListEnumerator }

constructor TFhirMolecularSequenceStructureVariantListEnumerator.Create(list : TFhirMolecularSequenceStructureVariantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceStructureVariantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceStructureVariantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceStructureVariantListEnumerator.GetCurrent : TFhirMolecularSequenceStructureVariant;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceStructureVariantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMolecularSequenceStructureVariantList }

function TFhirMolecularSequenceStructureVariantList.AddItem(value: TFhirMolecularSequenceStructureVariant): TFhirMolecularSequenceStructureVariant;
begin
  assert(value.ClassName = 'TFhirMolecularSequenceStructureVariant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceStructureVariant');
  add(value);
  result := value;
end;

function TFhirMolecularSequenceStructureVariantList.Append: TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceStructureVariantList.GetEnumerator : TFhirMolecularSequenceStructureVariantListEnumerator;
begin
  result := TFhirMolecularSequenceStructureVariantListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceStructureVariantList.Clone: TFhirMolecularSequenceStructureVariantList;
begin
  result := TFhirMolecularSequenceStructureVariantList(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceStructureVariantList.GetItemN(index: Integer): TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceStructureVariant;
end;
function TFhirMolecularSequenceStructureVariantList.IndexOf(value: TFhirMolecularSequenceStructureVariant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceStructureVariantList.Insert(index: Integer): TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantList.InsertItem(index: Integer; value: TFhirMolecularSequenceStructureVariant);
begin
  assert(value is TFhirMolecularSequenceStructureVariant);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceStructureVariantList.Item(index: Integer): TFhirMolecularSequenceStructureVariant;
begin
  result := TFhirMolecularSequenceStructureVariant(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantList.Link: TFhirMolecularSequenceStructureVariantList;
begin
  result := TFhirMolecularSequenceStructureVariantList(inherited Link);
end;

procedure TFhirMolecularSequenceStructureVariantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceStructureVariantList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceStructureVariant);
begin
  assert(value is TFhirMolecularSequenceStructureVariant);
  FhirMolecularSequenceStructureVariants[index] := value;
end;

procedure TFhirMolecularSequenceStructureVariantList.SetItemN(index: Integer; value: TFhirMolecularSequenceStructureVariant);
begin
  assert(value is TFhirMolecularSequenceStructureVariant);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceStructureVariantOuter }

constructor TFhirMolecularSequenceStructureVariantOuter.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceStructureVariantOuter.Destroy;
begin
  FStart.free;
  FEnd_.free;
  inherited;
end;

procedure TFhirMolecularSequenceStructureVariantOuter.Assign(oSource : TFslObject);
begin
  inherited;
  startElement := TFhirMolecularSequenceStructureVariantOuter(oSource).startElement.Clone;
  end_Element := TFhirMolecularSequenceStructureVariantOuter(oSource).end_Element.Clone;
end;

procedure TFhirMolecularSequenceStructureVariantOuter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link));
end;

function TFhirMolecularSequenceStructureVariantOuter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'start') then
  begin
    StartElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceStructureVariantOuter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'start') then result := TFhirInteger.create()
  else if (propName = 'end') then result := TFhirInteger.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceStructureVariantOuter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'start') then StartElement := asInteger(new)
  else if (propName = 'end') then End_Element := asInteger(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceStructureVariantOuter.fhirType : string;
begin
  result := 'MolecularSequence.structureVariant.outer';
end;

function TFhirMolecularSequenceStructureVariantOuter.Link : TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter(inherited Link);
end;

function TFhirMolecularSequenceStructureVariantOuter.Clone : TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantOuter.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceStructureVariantOuter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceStructureVariantOuter)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceStructureVariantOuter(other);
    result := compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true);
  end;
end;

function TFhirMolecularSequenceStructureVariantOuter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStart) and isEmptyProp(FEnd_);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('start');
  fields.add('end');
end;

function TFhirMolecularSequenceStructureVariantOuter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMolecularSequenceStructureVariantOuter.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value;
end;

function TFhirMolecularSequenceStructureVariantOuter.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

procedure TFhirMolecularSequenceStructureVariantOuter.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

procedure TFhirMolecularSequenceStructureVariantOuter.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirMolecularSequenceStructureVariantOuter.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

procedure TFhirMolecularSequenceStructureVariantOuter.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

{ TFhirMolecularSequenceStructureVariantOuterListEnumerator }

constructor TFhirMolecularSequenceStructureVariantOuterListEnumerator.Create(list : TFhirMolecularSequenceStructureVariantOuterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceStructureVariantOuterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceStructureVariantOuterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceStructureVariantOuterListEnumerator.GetCurrent : TFhirMolecularSequenceStructureVariantOuter;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceStructureVariantOuterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMolecularSequenceStructureVariantOuterList }

function TFhirMolecularSequenceStructureVariantOuterList.AddItem(value: TFhirMolecularSequenceStructureVariantOuter): TFhirMolecularSequenceStructureVariantOuter;
begin
  assert(value.ClassName = 'TFhirMolecularSequenceStructureVariantOuter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceStructureVariantOuter');
  add(value);
  result := value;
end;

function TFhirMolecularSequenceStructureVariantOuterList.Append: TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceStructureVariantOuterList.GetEnumerator : TFhirMolecularSequenceStructureVariantOuterListEnumerator;
begin
  result := TFhirMolecularSequenceStructureVariantOuterListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Clone: TFhirMolecularSequenceStructureVariantOuterList;
begin
  result := TFhirMolecularSequenceStructureVariantOuterList(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceStructureVariantOuterList.GetItemN(index: Integer): TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantOuterList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceStructureVariantOuter;
end;
function TFhirMolecularSequenceStructureVariantOuterList.IndexOf(value: TFhirMolecularSequenceStructureVariantOuter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Insert(index: Integer): TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.InsertItem(index: Integer; value: TFhirMolecularSequenceStructureVariantOuter);
begin
  assert(value is TFhirMolecularSequenceStructureVariantOuter);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Item(index: Integer): TFhirMolecularSequenceStructureVariantOuter;
begin
  result := TFhirMolecularSequenceStructureVariantOuter(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantOuterList.Link: TFhirMolecularSequenceStructureVariantOuterList;
begin
  result := TFhirMolecularSequenceStructureVariantOuterList(inherited Link);
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceStructureVariantOuter);
begin
  assert(value is TFhirMolecularSequenceStructureVariantOuter);
  FhirMolecularSequenceStructureVariantOuters[index] := value;
end;

procedure TFhirMolecularSequenceStructureVariantOuterList.SetItemN(index: Integer; value: TFhirMolecularSequenceStructureVariantOuter);
begin
  assert(value is TFhirMolecularSequenceStructureVariantOuter);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequenceStructureVariantInner }

constructor TFhirMolecularSequenceStructureVariantInner.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequenceStructureVariantInner.Destroy;
begin
  FStart.free;
  FEnd_.free;
  inherited;
end;

procedure TFhirMolecularSequenceStructureVariantInner.Assign(oSource : TFslObject);
begin
  inherited;
  startElement := TFhirMolecularSequenceStructureVariantInner(oSource).startElement.Clone;
  end_Element := TFhirMolecularSequenceStructureVariantInner(oSource).end_Element.Clone;
end;

procedure TFhirMolecularSequenceStructureVariantInner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
end;

procedure TFhirMolecularSequenceStructureVariantInner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'start', 'integer', false, TFhirInteger, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'end', 'integer', false, TFhirInteger, FEnd_.Link));
end;

function TFhirMolecularSequenceStructureVariantInner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'start') then
  begin
    StartElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInteger(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequenceStructureVariantInner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMolecularSequenceStructureVariantInner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'start') then result := TFhirInteger.create()
  else if (propName = 'end') then result := TFhirInteger.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequenceStructureVariantInner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'start') then result := 'integer'
  else if (propName = 'end') then result := 'integer'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequenceStructureVariantInner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequenceStructureVariantInner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'start') then StartElement := asInteger(new)
  else if (propName = 'end') then End_Element := asInteger(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequenceStructureVariantInner.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequenceStructureVariantInner.fhirType : string;
begin
  result := 'MolecularSequence.structureVariant.inner';
end;

function TFhirMolecularSequenceStructureVariantInner.Link : TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner(inherited Link);
end;

function TFhirMolecularSequenceStructureVariantInner.Clone : TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantInner.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequenceStructureVariantInner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequenceStructureVariantInner)) then
    result := false
  else
  begin
    o := TFhirMolecularSequenceStructureVariantInner(other);
    result := compareDeep(startElement, o.startElement, true) and compareDeep(end_Element, o.end_Element, true);
  end;
end;

function TFhirMolecularSequenceStructureVariantInner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStart) and isEmptyProp(FEnd_);
end;

procedure TFhirMolecularSequenceStructureVariantInner.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('start');
  fields.add('end');
end;

function TFhirMolecularSequenceStructureVariantInner.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMolecularSequenceStructureVariantInner.SetStart(value : TFhirInteger);
begin
  FStart.free;
  FStart := value;
end;

function TFhirMolecularSequenceStructureVariantInner.GetStartST : String;
begin
  if FStart = nil then
    result := ''
  else
    result := FStart.value;
end;

procedure TFhirMolecularSequenceStructureVariantInner.SetStartST(value : String);
begin
  if value <> '' then
  begin
    if FStart = nil then
      FStart := TFhirInteger.create;
    FStart.value := value
  end
  else if FStart <> nil then
    FStart.value := '';
end;

procedure TFhirMolecularSequenceStructureVariantInner.SetEnd_(value : TFhirInteger);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirMolecularSequenceStructureVariantInner.GetEnd_ST : String;
begin
  if FEnd_ = nil then
    result := ''
  else
    result := FEnd_.value;
end;

procedure TFhirMolecularSequenceStructureVariantInner.SetEnd_ST(value : String);
begin
  if value <> '' then
  begin
    if FEnd_ = nil then
      FEnd_ := TFhirInteger.create;
    FEnd_.value := value
  end
  else if FEnd_ <> nil then
    FEnd_.value := '';
end;

{ TFhirMolecularSequenceStructureVariantInnerListEnumerator }

constructor TFhirMolecularSequenceStructureVariantInnerListEnumerator.Create(list : TFhirMolecularSequenceStructureVariantInnerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceStructureVariantInnerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceStructureVariantInnerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceStructureVariantInnerListEnumerator.GetCurrent : TFhirMolecularSequenceStructureVariantInner;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceStructureVariantInnerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMolecularSequenceStructureVariantInnerList }

function TFhirMolecularSequenceStructureVariantInnerList.AddItem(value: TFhirMolecularSequenceStructureVariantInner): TFhirMolecularSequenceStructureVariantInner;
begin
  assert(value.ClassName = 'TFhirMolecularSequenceStructureVariantInner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequenceStructureVariantInner');
  add(value);
  result := value;
end;

function TFhirMolecularSequenceStructureVariantInnerList.Append: TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceStructureVariantInnerList.GetEnumerator : TFhirMolecularSequenceStructureVariantInnerListEnumerator;
begin
  result := TFhirMolecularSequenceStructureVariantInnerListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Clone: TFhirMolecularSequenceStructureVariantInnerList;
begin
  result := TFhirMolecularSequenceStructureVariantInnerList(inherited Clone);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceStructureVariantInnerList.GetItemN(index: Integer): TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantInnerList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequenceStructureVariantInner;
end;
function TFhirMolecularSequenceStructureVariantInnerList.IndexOf(value: TFhirMolecularSequenceStructureVariantInner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Insert(index: Integer): TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.InsertItem(index: Integer; value: TFhirMolecularSequenceStructureVariantInner);
begin
  assert(value is TFhirMolecularSequenceStructureVariantInner);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Item(index: Integer): TFhirMolecularSequenceStructureVariantInner;
begin
  result := TFhirMolecularSequenceStructureVariantInner(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceStructureVariantInnerList.Link: TFhirMolecularSequenceStructureVariantInnerList;
begin
  result := TFhirMolecularSequenceStructureVariantInnerList(inherited Link);
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.SetItemByIndex(index: Integer; value: TFhirMolecularSequenceStructureVariantInner);
begin
  assert(value is TFhirMolecularSequenceStructureVariantInner);
  FhirMolecularSequenceStructureVariantInners[index] := value;
end;

procedure TFhirMolecularSequenceStructureVariantInnerList.SetItemN(index: Integer; value: TFhirMolecularSequenceStructureVariantInner);
begin
  assert(value is TFhirMolecularSequenceStructureVariantInner);
  ObjectByIndex[index] := value;
end;

{ TFhirMolecularSequence }

constructor TFhirMolecularSequence.Create;
begin
  inherited;
end;

destructor TFhirMolecularSequence.Destroy;
begin
  FIdentifierList.Free;
  FType_.free;
  FCoordinateSystem.free;
  FPatient.free;
  FSpecimen.free;
  FDevice.free;
  FPerformer.free;
  FQuantity.free;
  FReferenceSeq.free;
  FVariantList.Free;
  FObservedSeq.free;
  FQualityList.Free;
  FReadCoverage.free;
  FRepositoryList.Free;
  FPointerList.Free;
  FStructureVariantList.Free;
  inherited;
end;

procedure TFhirMolecularSequence.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMolecularSequence(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMolecularSequence(oSource).FIdentifierList);
  end;
  type_Element := TFhirMolecularSequence(oSource).type_Element.Clone;
  coordinateSystemElement := TFhirMolecularSequence(oSource).coordinateSystemElement.Clone;
  patient := TFhirMolecularSequence(oSource).patient.Clone;
  specimen := TFhirMolecularSequence(oSource).specimen.Clone;
  device := TFhirMolecularSequence(oSource).device.Clone;
  performer := TFhirMolecularSequence(oSource).performer.Clone;
  quantity := TFhirMolecularSequence(oSource).quantity.Clone;
  referenceSeq := TFhirMolecularSequence(oSource).referenceSeq.Clone;
  if (TFhirMolecularSequence(oSource).FVariantList = nil) then
  begin
    FVariantList.free;
    FVariantList := nil;
  end
  else
  begin
    if FVariantList = nil then
      FVariantList := TFhirMolecularSequenceVariantList.Create;
    FVariantList.Assign(TFhirMolecularSequence(oSource).FVariantList);
  end;
  observedSeqElement := TFhirMolecularSequence(oSource).observedSeqElement.Clone;
  if (TFhirMolecularSequence(oSource).FQualityList = nil) then
  begin
    FQualityList.free;
    FQualityList := nil;
  end
  else
  begin
    if FQualityList = nil then
      FQualityList := TFhirMolecularSequenceQualityList.Create;
    FQualityList.Assign(TFhirMolecularSequence(oSource).FQualityList);
  end;
  readCoverageElement := TFhirMolecularSequence(oSource).readCoverageElement.Clone;
  if (TFhirMolecularSequence(oSource).FRepositoryList = nil) then
  begin
    FRepositoryList.free;
    FRepositoryList := nil;
  end
  else
  begin
    if FRepositoryList = nil then
      FRepositoryList := TFhirMolecularSequenceRepositoryList.Create;
    FRepositoryList.Assign(TFhirMolecularSequence(oSource).FRepositoryList);
  end;
  if (TFhirMolecularSequence(oSource).FPointerList = nil) then
  begin
    FPointerList.free;
    FPointerList := nil;
  end
  else
  begin
    if FPointerList = nil then
      FPointerList := TFhirReferenceList.Create;
    FPointerList.Assign(TFhirMolecularSequence(oSource).FPointerList);
  end;
  if (TFhirMolecularSequence(oSource).FStructureVariantList = nil) then
  begin
    FStructureVariantList.free;
    FStructureVariantList := nil;
  end
  else
  begin
    if FStructureVariantList = nil then
      FStructureVariantList := TFhirMolecularSequenceStructureVariantList.Create;
    FStructureVariantList.Assign(TFhirMolecularSequence(oSource).FStructureVariantList);
  end;
end;

function TFhirMolecularSequence.GetResourceType : TFhirResourceType;
begin
  result := frtMolecularSequence;
end;

procedure TFhirMolecularSequence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'coordinateSystem') Then
     list.add(self.link, 'coordinateSystem', FCoordinateSystem.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'specimen') Then
     list.add(self.link, 'specimen', FSpecimen.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'referenceSeq') Then
     list.add(self.link, 'referenceSeq', FReferenceSeq.Link);
  if (child_name = 'variant') Then
    list.addAll(self, 'variant', FVariantList);
  if (child_name = 'observedSeq') Then
     list.add(self.link, 'observedSeq', FObservedSeq.Link);
  if (child_name = 'quality') Then
    list.addAll(self, 'quality', FQualityList);
  if (child_name = 'readCoverage') Then
     list.add(self.link, 'readCoverage', FReadCoverage.Link);
  if (child_name = 'repository') Then
    list.addAll(self, 'repository', FRepositoryList);
  if (child_name = 'pointer') Then
    list.addAll(self, 'pointer', FPointerList);
  if (child_name = 'structureVariant') Then
    list.addAll(self, 'structureVariant', FStructureVariantList);
end;

procedure TFhirMolecularSequence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'coordinateSystem', 'integer', false, TFhirInteger, FCoordinateSystem.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', false, TFhirReference, FSpecimen.Link));
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'referenceSeq', 'BackboneElement', false, TFhirMolecularSequenceReferenceSeq, FReferenceSeq.Link));
  oList.add(TFHIRProperty.create(self, 'variant', 'BackboneElement', true, TFhirMolecularSequenceVariant, FVariantList.Link));
  oList.add(TFHIRProperty.create(self, 'observedSeq', 'string', false, TFhirString, FObservedSeq.Link));
  oList.add(TFHIRProperty.create(self, 'quality', 'BackboneElement', true, TFhirMolecularSequenceQuality, FQualityList.Link));
  oList.add(TFHIRProperty.create(self, 'readCoverage', 'integer', false, TFhirInteger, FReadCoverage.Link));
  oList.add(TFHIRProperty.create(self, 'repository', 'BackboneElement', true, TFhirMolecularSequenceRepository, FRepositoryList.Link));
  oList.add(TFHIRProperty.create(self, 'pointer', 'Reference', true, TFhirReference, FPointerList.Link));
  oList.add(TFHIRProperty.create(self, 'structureVariant', 'BackboneElement', true, TFhirMolecularSequenceStructureVariant, FStructureVariantList.Link));
end;

function TFhirMolecularSequence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSequenceTypeEnum, CODES_TFhirSequenceTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'coordinateSystem') then
  begin
    CoordinateSystemElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    Specimen := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'referenceSeq') then
  begin
    ReferenceSeq := propValue as TFhirMolecularSequenceReferenceSeq;
    result := propValue;
  end
  else if (propName = 'variant') then
  begin
    VariantList.add(propValue as TFhirMolecularSequenceVariant);
    result := propValue;
  end
  else if (propName = 'observedSeq') then
  begin
    ObservedSeqElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'quality') then
  begin
    QualityList.add(propValue as TFhirMolecularSequenceQuality);
    result := propValue;
  end
  else if (propName = 'readCoverage') then
  begin
    ReadCoverageElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'repository') then
  begin
    RepositoryList.add(propValue as TFhirMolecularSequenceRepository);
    result := propValue;
  end
  else if (propName = 'pointer') then
  begin
    PointerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'structureVariant') then
  begin
    StructureVariantList.add(propValue as TFhirMolecularSequenceStructureVariant);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMolecularSequence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'variant') then VariantList.insertItem(index, propValue as TFhirMolecularSequenceVariant)
  else if (propName = 'quality') then QualityList.insertItem(index, propValue as TFhirMolecularSequenceQuality)
  else if (propName = 'repository') then RepositoryList.insertItem(index, propValue as TFhirMolecularSequenceRepository)
  else if (propName = 'pointer') then PointerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'structureVariant') then StructureVariantList.insertItem(index, propValue as TFhirMolecularSequenceStructureVariant)
  else inherited;
end;

function TFhirMolecularSequence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirSequenceTypeEnum[SequenceTypeNull], CODES_TFhirSequenceTypeEnum[SequenceTypeNull]) 
  else if (propName = 'coordinateSystem') then result := TFhirInteger.create()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'specimen') then result := TFhirReference.create()
  else if (propName = 'device') then result := TFhirReference.create()
  else if (propName = 'performer') then result := TFhirReference.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'referenceSeq') then result := TFhirMolecularSequenceReferenceSeq.create()
  else if (propName = 'variant') then result := VariantList.new()
  else if (propName = 'observedSeq') then result := TFhirString.create()
  else if (propName = 'quality') then result := QualityList.new()
  else if (propName = 'readCoverage') then result := TFhirInteger.create()
  else if (propName = 'repository') then result := RepositoryList.new()
  else if (propName = 'pointer') then result := PointerList.new()
  else if (propName = 'structureVariant') then result := StructureVariantList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMolecularSequence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'coordinateSystem') then result := 'integer'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'referenceSeq') then result := 'BackboneElement'
  else if (propName = 'variant') then result := 'BackboneElement'
  else if (propName = 'observedSeq') then result := 'string'
  else if (propName = 'quality') then result := 'BackboneElement'
  else if (propName = 'readCoverage') then result := 'integer'
  else if (propName = 'repository') then result := 'BackboneElement'
  else if (propName = 'pointer') then result := 'Reference'
  else if (propName = 'structureVariant') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMolecularSequence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'coordinateSystem') then CoordinateSystemElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'specimen') then SpecimenElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'referenceSeq') then ReferenceSeqElement := nil
  else if (propName = 'variant') then deletePropertyValue('variant', VariantList, value)
  else if (propName = 'observedSeq') then ObservedSeqElement := nil
  else if (propName = 'quality') then deletePropertyValue('quality', QualityList, value)
  else if (propName = 'readCoverage') then ReadCoverageElement := nil
  else if (propName = 'repository') then deletePropertyValue('repository', RepositoryList, value)
  else if (propName = 'pointer') then deletePropertyValue('pointer', PointerList, value)
  else if (propName = 'structureVariant') then deletePropertyValue('structureVariant', StructureVariantList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMolecularSequence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSequenceTypeEnum, CODES_TFhirSequenceTypeEnum, new)
  else if (propName = 'coordinateSystem') then CoordinateSystemElement := asInteger(new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'specimen') then SpecimenElement := new as TFhirReference
  else if (propName = 'device') then DeviceElement := new as TFhirReference
  else if (propName = 'performer') then PerformerElement := new as TFhirReference
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'referenceSeq') then ReferenceSeqElement := new as TFhirMolecularSequenceReferenceSeq
  else if (propName = 'variant') then replacePropertyValue('variant', VariantList, existing, new)
  else if (propName = 'observedSeq') then ObservedSeqElement := asString(new)
  else if (propName = 'quality') then replacePropertyValue('quality', QualityList, existing, new)
  else if (propName = 'readCoverage') then ReadCoverageElement := asInteger(new)
  else if (propName = 'repository') then replacePropertyValue('repository', RepositoryList, existing, new)
  else if (propName = 'pointer') then replacePropertyValue('pointer', PointerList, existing, new)
  else if (propName = 'structureVariant') then replacePropertyValue('structureVariant', StructureVariantList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMolecularSequence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'variant') then VariantList.move(source, destination)
  else if (propName = 'quality') then QualityList.move(source, destination)
  else if (propName = 'repository') then RepositoryList.move(source, destination)
  else if (propName = 'pointer') then PointerList.move(source, destination)
  else if (propName = 'structureVariant') then StructureVariantList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMolecularSequence.fhirType : string;
begin
  result := 'MolecularSequence';
end;

function TFhirMolecularSequence.Link : TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence(inherited Link);
end;

function TFhirMolecularSequence.Clone : TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence(inherited Clone);
end;

function TFhirMolecularSequence.equals(other : TObject) : boolean; 
var
  o : TFhirMolecularSequence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMolecularSequence)) then
    result := false
  else
  begin
    o := TFhirMolecularSequence(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(coordinateSystemElement, o.coordinateSystemElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(specimenElement, o.specimenElement, true) and compareDeep(deviceElement, o.deviceElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(referenceSeqElement, o.referenceSeqElement, true) and compareDeep(variantList, o.variantList, true) and 
      compareDeep(observedSeqElement, o.observedSeqElement, true) and compareDeep(qualityList, o.qualityList, true) and 
      compareDeep(readCoverageElement, o.readCoverageElement, true) and compareDeep(repositoryList, o.repositoryList, true) and 
      compareDeep(pointerList, o.pointerList, true) and compareDeep(structureVariantList, o.structureVariantList, true);
  end;
end;

function TFhirMolecularSequence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FCoordinateSystem) and isEmptyProp(FPatient) and isEmptyProp(FSpecimen) and isEmptyProp(FDevice) and isEmptyProp(FPerformer) and isEmptyProp(FQuantity) and isEmptyProp(FReferenceSeq) and isEmptyProp(FvariantList) and isEmptyProp(FObservedSeq) and isEmptyProp(FqualityList) and isEmptyProp(FReadCoverage) and isEmptyProp(FrepositoryList) and isEmptyProp(FpointerList) and isEmptyProp(FstructureVariantList);
end;

procedure TFhirMolecularSequence.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('coordinateSystem');
  fields.add('patient');
  fields.add('specimen');
  fields.add('device');
  fields.add('performer');
  fields.add('quantity');
  fields.add('referenceSeq');
  fields.add('variant');
  fields.add('observedSeq');
  fields.add('quality');
  fields.add('readCoverage');
  fields.add('repository');
  fields.add('pointer');
  fields.add('structureVariant');
end;

function TFhirMolecularSequence.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FVariantList.sizeInBytes(magic));
  inc(result, FQualityList.sizeInBytes(magic));
  inc(result, FRepositoryList.sizeInBytes(magic));
  inc(result, FPointerList.sizeInBytes(magic));
  inc(result, FStructureVariantList.sizeInBytes(magic));
end;

function TFhirMolecularSequence.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMolecularSequence.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMolecularSequence.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMolecularSequence.GetType_ST : TFhirSequenceTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSequenceTypeEnum(0)
  else
    result := TFhirSequenceTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSequenceTypeEnum, FType_.value));
end;

procedure TFhirMolecularSequence.SetType_ST(value : TFhirSequenceTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSequenceTypeEnum[value], CODES_TFhirSequenceTypeEnum[value]);
end;

procedure TFhirMolecularSequence.SetCoordinateSystem(value : TFhirInteger);
begin
  FCoordinateSystem.free;
  FCoordinateSystem := value;
end;

function TFhirMolecularSequence.GetCoordinateSystemST : String;
begin
  if FCoordinateSystem = nil then
    result := ''
  else
    result := FCoordinateSystem.value;
end;

procedure TFhirMolecularSequence.SetCoordinateSystemST(value : String);
begin
  if value <> '' then
  begin
    if FCoordinateSystem = nil then
      FCoordinateSystem := TFhirInteger.create;
    FCoordinateSystem.value := value
  end
  else if FCoordinateSystem <> nil then
    FCoordinateSystem.value := '';
end;

procedure TFhirMolecularSequence.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirMolecularSequence.SetSpecimen(value : TFhirReference);
begin
  FSpecimen.free;
  FSpecimen := value;
end;

procedure TFhirMolecularSequence.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value;
end;

procedure TFhirMolecularSequence.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value;
end;

procedure TFhirMolecularSequence.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirMolecularSequence.SetReferenceSeq(value : TFhirMolecularSequenceReferenceSeq);
begin
  FReferenceSeq.free;
  FReferenceSeq := value;
end;

function TFhirMolecularSequence.GetVariantList : TFhirMolecularSequenceVariantList;
begin
  if FVariantList = nil then
    FVariantList := TFhirMolecularSequenceVariantList.Create;
  result := FVariantList;
end;

function TFhirMolecularSequence.GetHasVariantList : boolean;
begin
  result := (FVariantList <> nil) and (FVariantList.count > 0);
end;

procedure TFhirMolecularSequence.SetObservedSeq(value : TFhirString);
begin
  FObservedSeq.free;
  FObservedSeq := value;
end;

function TFhirMolecularSequence.GetObservedSeqST : String;
begin
  if FObservedSeq = nil then
    result := ''
  else
    result := FObservedSeq.value;
end;

procedure TFhirMolecularSequence.SetObservedSeqST(value : String);
begin
  if value <> '' then
  begin
    if FObservedSeq = nil then
      FObservedSeq := TFhirString.create;
    FObservedSeq.value := value
  end
  else if FObservedSeq <> nil then
    FObservedSeq.value := '';
end;

function TFhirMolecularSequence.GetQualityList : TFhirMolecularSequenceQualityList;
begin
  if FQualityList = nil then
    FQualityList := TFhirMolecularSequenceQualityList.Create;
  result := FQualityList;
end;

function TFhirMolecularSequence.GetHasQualityList : boolean;
begin
  result := (FQualityList <> nil) and (FQualityList.count > 0);
end;

procedure TFhirMolecularSequence.SetReadCoverage(value : TFhirInteger);
begin
  FReadCoverage.free;
  FReadCoverage := value;
end;

function TFhirMolecularSequence.GetReadCoverageST : String;
begin
  if FReadCoverage = nil then
    result := ''
  else
    result := FReadCoverage.value;
end;

procedure TFhirMolecularSequence.SetReadCoverageST(value : String);
begin
  if value <> '' then
  begin
    if FReadCoverage = nil then
      FReadCoverage := TFhirInteger.create;
    FReadCoverage.value := value
  end
  else if FReadCoverage <> nil then
    FReadCoverage.value := '';
end;

function TFhirMolecularSequence.GetRepositoryList : TFhirMolecularSequenceRepositoryList;
begin
  if FRepositoryList = nil then
    FRepositoryList := TFhirMolecularSequenceRepositoryList.Create;
  result := FRepositoryList;
end;

function TFhirMolecularSequence.GetHasRepositoryList : boolean;
begin
  result := (FRepositoryList <> nil) and (FRepositoryList.count > 0);
end;

function TFhirMolecularSequence.GetPointerList : TFhirReferenceList;
begin
  if FPointerList = nil then
    FPointerList := TFhirReferenceList.Create;
  result := FPointerList;
end;

function TFhirMolecularSequence.GetHasPointerList : boolean;
begin
  result := (FPointerList <> nil) and (FPointerList.count > 0);
end;

function TFhirMolecularSequence.GetStructureVariantList : TFhirMolecularSequenceStructureVariantList;
begin
  if FStructureVariantList = nil then
    FStructureVariantList := TFhirMolecularSequenceStructureVariantList.Create;
  result := FStructureVariantList;
end;

function TFhirMolecularSequence.GetHasStructureVariantList : boolean;
begin
  result := (FStructureVariantList <> nil) and (FStructureVariantList.count > 0);
end;

{ TFhirMolecularSequenceListEnumerator }

constructor TFhirMolecularSequenceListEnumerator.Create(list : TFhirMolecularSequenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMolecularSequenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMolecularSequenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMolecularSequenceListEnumerator.GetCurrent : TFhirMolecularSequence;
begin
  Result := FList[FIndex];
end;

function TFhirMolecularSequenceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMolecularSequenceList }

function TFhirMolecularSequenceList.AddItem(value: TFhirMolecularSequence): TFhirMolecularSequence;
begin
  assert(value.ClassName = 'TFhirMolecularSequence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMolecularSequence');
  add(value);
  result := value;
end;

function TFhirMolecularSequenceList.Append: TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceList.ClearItems;
begin
  Clear;
end;

function TFhirMolecularSequenceList.GetEnumerator : TFhirMolecularSequenceListEnumerator;
begin
  result := TFhirMolecularSequenceListEnumerator.Create(self.link);
end;

function TFhirMolecularSequenceList.Clone: TFhirMolecularSequenceList;
begin
  result := TFhirMolecularSequenceList(inherited Clone);
end;

function TFhirMolecularSequenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMolecularSequenceList.GetItemN(index: Integer): TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMolecularSequence;
end;
function TFhirMolecularSequenceList.IndexOf(value: TFhirMolecularSequence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMolecularSequenceList.Insert(index: Integer): TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMolecularSequenceList.InsertItem(index: Integer; value: TFhirMolecularSequence);
begin
  assert(value is TFhirMolecularSequence);
  Inherited Insert(index, value);
end;

function TFhirMolecularSequenceList.Item(index: Integer): TFhirMolecularSequence;
begin
  result := TFhirMolecularSequence(ObjectByIndex[index]);
end;

function TFhirMolecularSequenceList.Link: TFhirMolecularSequenceList;
begin
  result := TFhirMolecularSequenceList(inherited Link);
end;

procedure TFhirMolecularSequenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMolecularSequenceList.SetItemByIndex(index: Integer; value: TFhirMolecularSequence);
begin
  assert(value is TFhirMolecularSequence);
  FhirMolecularSequences[index] := value;
end;

procedure TFhirMolecularSequenceList.SetItemN(index: Integer; value: TFhirMolecularSequence);
begin
  assert(value is TFhirMolecularSequence);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MOLECULARSEQUENCE}
{$IFDEF FHIR_NUTRITIONORDER}
{ TFhirNutritionOrderOralDiet }

constructor TFhirNutritionOrderOralDiet.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDiet.Destroy;
begin
  FType_List.Free;
  FScheduleList.Free;
  FNutrientList.Free;
  FTextureList.Free;
  FFluidConsistencyTypeList.Free;
  FInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDiet.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirNutritionOrderOralDiet(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirNutritionOrderOralDiet(oSource).FType_List);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirTimingList.Create;
    FScheduleList.Assign(TFhirNutritionOrderOralDiet(oSource).FScheduleList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FNutrientList = nil) then
  begin
    FNutrientList.free;
    FNutrientList := nil;
  end
  else
  begin
    if FNutrientList = nil then
      FNutrientList := TFhirNutritionOrderOralDietNutrientList.Create;
    FNutrientList.Assign(TFhirNutritionOrderOralDiet(oSource).FNutrientList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FTextureList = nil) then
  begin
    FTextureList.free;
    FTextureList := nil;
  end
  else
  begin
    if FTextureList = nil then
      FTextureList := TFhirNutritionOrderOralDietTextureList.Create;
    FTextureList.Assign(TFhirNutritionOrderOralDiet(oSource).FTextureList);
  end;
  if (TFhirNutritionOrderOralDiet(oSource).FFluidConsistencyTypeList = nil) then
  begin
    FFluidConsistencyTypeList.free;
    FFluidConsistencyTypeList := nil;
  end
  else
  begin
    if FFluidConsistencyTypeList = nil then
      FFluidConsistencyTypeList := TFhirCodeableConceptList.Create;
    FFluidConsistencyTypeList.Assign(TFhirNutritionOrderOralDiet(oSource).FFluidConsistencyTypeList);
  end;
  instructionElement := TFhirNutritionOrderOralDiet(oSource).instructionElement.Clone;
end;

procedure TFhirNutritionOrderOralDiet.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'nutrient') Then
    list.addAll(self, 'nutrient', FNutrientList);
  if (child_name = 'texture') Then
    list.addAll(self, 'texture', FTextureList);
  if (child_name = 'fluidConsistencyType') Then
    list.addAll(self, 'fluidConsistencyType', FFluidConsistencyTypeList);
  if (child_name = 'instruction') Then
     list.add(self.link, 'instruction', FInstruction.Link);
end;

procedure TFhirNutritionOrderOralDiet.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', true, TFhirTiming, FScheduleList.Link));
  oList.add(TFHIRProperty.create(self, 'nutrient', 'BackboneElement', true, TFhirNutritionOrderOralDietNutrient, FNutrientList.Link));
  oList.add(TFHIRProperty.create(self, 'texture', 'BackboneElement', true, TFhirNutritionOrderOralDietTexture, FTextureList.Link));
  oList.add(TFHIRProperty.create(self, 'fluidConsistencyType', 'CodeableConcept', true, TFhirCodeableConcept, FFluidConsistencyTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'instruction', 'string', false, TFhirString, FInstruction.Link));
end;

function TFhirNutritionOrderOralDiet.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirTiming);
    result := propValue;
  end
  else if (propName = 'nutrient') then
  begin
    NutrientList.add(propValue as TFhirNutritionOrderOralDietNutrient);
    result := propValue;
  end
  else if (propName = 'texture') then
  begin
    TextureList.add(propValue as TFhirNutritionOrderOralDietTexture);
    result := propValue;
  end
  else if (propName = 'fluidConsistencyType') then
  begin
    FluidConsistencyTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'instruction') then
  begin
    InstructionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDiet.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirTiming)
  else if (propName = 'nutrient') then NutrientList.insertItem(index, propValue as TFhirNutritionOrderOralDietNutrient)
  else if (propName = 'texture') then TextureList.insertItem(index, propValue as TFhirNutritionOrderOralDietTexture)
  else if (propName = 'fluidConsistencyType') then FluidConsistencyTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirNutritionOrderOralDiet.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new()
  else if (propName = 'schedule') then result := ScheduleList.new()
  else if (propName = 'nutrient') then result := NutrientList.new()
  else if (propName = 'texture') then result := TextureList.new()
  else if (propName = 'fluidConsistencyType') then result := FluidConsistencyTypeList.new()
  else if (propName = 'instruction') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDiet.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'nutrient') then result := 'BackboneElement'
  else if (propName = 'texture') then result := 'BackboneElement'
  else if (propName = 'fluidConsistencyType') then result := 'CodeableConcept'
  else if (propName = 'instruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDiet.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value)
  else if (propName = 'nutrient') then deletePropertyValue('nutrient', NutrientList, value)
  else if (propName = 'texture') then deletePropertyValue('texture', TextureList, value)
  else if (propName = 'fluidConsistencyType') then deletePropertyValue('fluidConsistencyType', FluidConsistencyTypeList, value)
  else if (propName = 'instruction') then InstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDiet.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new)
  else if (propName = 'nutrient') then replacePropertyValue('nutrient', NutrientList, existing, new)
  else if (propName = 'texture') then replacePropertyValue('texture', TextureList, existing, new)
  else if (propName = 'fluidConsistencyType') then replacePropertyValue('fluidConsistencyType', FluidConsistencyTypeList, existing, new)
  else if (propName = 'instruction') then InstructionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDiet.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'schedule') then ScheduleList.move(source, destination)
  else if (propName = 'nutrient') then NutrientList.move(source, destination)
  else if (propName = 'texture') then TextureList.move(source, destination)
  else if (propName = 'fluidConsistencyType') then FluidConsistencyTypeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDiet.fhirType : string;
begin
  result := 'NutritionOrder.oralDiet';
end;

function TFhirNutritionOrderOralDiet.Link : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(inherited Link);
end;

function TFhirNutritionOrderOralDiet.Clone : TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(inherited Clone);
end;

function TFhirNutritionOrderOralDiet.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderOralDiet;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDiet)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDiet(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(scheduleList, o.scheduleList, true) and 
      compareDeep(nutrientList, o.nutrientList, true) and compareDeep(textureList, o.textureList, true) and 
      compareDeep(fluidConsistencyTypeList, o.fluidConsistencyTypeList, true) and compareDeep(instructionElement, o.instructionElement, true);
  end;
end;

function TFhirNutritionOrderOralDiet.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FscheduleList) and isEmptyProp(FnutrientList) and isEmptyProp(FtextureList) and isEmptyProp(FfluidConsistencyTypeList) and isEmptyProp(FInstruction);
end;

procedure TFhirNutritionOrderOralDiet.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('schedule');
  fields.add('nutrient');
  fields.add('texture');
  fields.add('fluidConsistencyType');
  fields.add('instruction');
end;

function TFhirNutritionOrderOralDiet.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FScheduleList.sizeInBytes(magic));
  inc(result, FNutrientList.sizeInBytes(magic));
  inc(result, FTextureList.sizeInBytes(magic));
  inc(result, FFluidConsistencyTypeList.sizeInBytes(magic));
end;

function TFhirNutritionOrderOralDiet.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirNutritionOrderOralDiet.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirNutritionOrderOralDiet.GetScheduleList : TFhirTimingList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirTimingList.Create;
  result := FScheduleList;
end;

function TFhirNutritionOrderOralDiet.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

function TFhirNutritionOrderOralDiet.GetNutrientList : TFhirNutritionOrderOralDietNutrientList;
begin
  if FNutrientList = nil then
    FNutrientList := TFhirNutritionOrderOralDietNutrientList.Create;
  result := FNutrientList;
end;

function TFhirNutritionOrderOralDiet.GetHasNutrientList : boolean;
begin
  result := (FNutrientList <> nil) and (FNutrientList.count > 0);
end;

function TFhirNutritionOrderOralDiet.GetTextureList : TFhirNutritionOrderOralDietTextureList;
begin
  if FTextureList = nil then
    FTextureList := TFhirNutritionOrderOralDietTextureList.Create;
  result := FTextureList;
end;

function TFhirNutritionOrderOralDiet.GetHasTextureList : boolean;
begin
  result := (FTextureList <> nil) and (FTextureList.count > 0);
end;

function TFhirNutritionOrderOralDiet.GetFluidConsistencyTypeList : TFhirCodeableConceptList;
begin
  if FFluidConsistencyTypeList = nil then
    FFluidConsistencyTypeList := TFhirCodeableConceptList.Create;
  result := FFluidConsistencyTypeList;
end;

function TFhirNutritionOrderOralDiet.GetHasFluidConsistencyTypeList : boolean;
begin
  result := (FFluidConsistencyTypeList <> nil) and (FFluidConsistencyTypeList.count > 0);
end;

procedure TFhirNutritionOrderOralDiet.SetInstruction(value : TFhirString);
begin
  FInstruction.free;
  FInstruction := value;
end;

function TFhirNutritionOrderOralDiet.GetInstructionST : String;
begin
  if FInstruction = nil then
    result := ''
  else
    result := FInstruction.value;
end;

procedure TFhirNutritionOrderOralDiet.SetInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FInstruction = nil then
      FInstruction := TFhirString.create;
    FInstruction.value := value
  end
  else if FInstruction <> nil then
    FInstruction.value := '';
end;

{ TFhirNutritionOrderOralDietListEnumerator }

constructor TFhirNutritionOrderOralDietListEnumerator.Create(list : TFhirNutritionOrderOralDietList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietListEnumerator.GetCurrent : TFhirNutritionOrderOralDiet;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionOrderOralDietList }

function TFhirNutritionOrderOralDietList.AddItem(value: TFhirNutritionOrderOralDiet): TFhirNutritionOrderOralDiet;
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDiet', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDiet');
  add(value);
  result := value;
end;

function TFhirNutritionOrderOralDietList.Append: TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietList.GetEnumerator : TFhirNutritionOrderOralDietListEnumerator;
begin
  result := TFhirNutritionOrderOralDietListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietList.Clone: TFhirNutritionOrderOralDietList;
begin
  result := TFhirNutritionOrderOralDietList(inherited Clone);
end;

function TFhirNutritionOrderOralDietList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietList.GetItemN(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDiet;
end;
function TFhirNutritionOrderOralDietList.IndexOf(value: TFhirNutritionOrderOralDiet): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietList.Insert(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietList.Item(index: Integer): TFhirNutritionOrderOralDiet;
begin
  result := TFhirNutritionOrderOralDiet(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietList.Link: TFhirNutritionOrderOralDietList;
begin
  result := TFhirNutritionOrderOralDietList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  FhirNutritionOrderOralDiets[index] := value;
end;

procedure TFhirNutritionOrderOralDietList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDiet);
begin
  assert(value is TFhirNutritionOrderOralDiet);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderOralDietNutrient }

constructor TFhirNutritionOrderOralDietNutrient.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDietNutrient.Destroy;
begin
  FModifier.free;
  FAmount.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDietNutrient.Assign(oSource : TFslObject);
begin
  inherited;
  modifier := TFhirNutritionOrderOralDietNutrient(oSource).modifier.Clone;
  amount := TFhirNutritionOrderOralDietNutrient(oSource).amount.Clone;
end;

procedure TFhirNutritionOrderOralDietNutrient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifier') Then
     list.add(self.link, 'modifier', FModifier.Link);
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
end;

procedure TFhirNutritionOrderOralDietNutrient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', false, TFhirCodeableConcept, FModifier.Link));
  oList.add(TFHIRProperty.create(self, 'amount', 'Quantity', false, TFhirQuantity, FAmount.Link));
end;

function TFhirNutritionOrderOralDietNutrient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifier') then
  begin
    Modifier := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'amount') then
  begin
    Amount := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDietNutrient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderOralDietNutrient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'modifier') then result := TFhirCodeableConcept.create()
  else if (propName = 'amount') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDietNutrient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'amount') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDietNutrient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := nil
  else if (propName = 'amount') then AmountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDietNutrient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := new as TFhirCodeableConcept
  else if (propName = 'amount') then AmountElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDietNutrient.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDietNutrient.fhirType : string;
begin
  result := 'NutritionOrder.oralDiet.nutrient';
end;

function TFhirNutritionOrderOralDietNutrient.Link : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(inherited Link);
end;

function TFhirNutritionOrderOralDietNutrient.Clone : TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(inherited Clone);
end;

function TFhirNutritionOrderOralDietNutrient.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderOralDietNutrient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDietNutrient)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDietNutrient(other);
    result := compareDeep(modifierElement, o.modifierElement, true) and compareDeep(amountElement, o.amountElement, true);
  end;
end;

function TFhirNutritionOrderOralDietNutrient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FModifier) and isEmptyProp(FAmount);
end;

procedure TFhirNutritionOrderOralDietNutrient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('modifier');
  fields.add('amount');
end;

function TFhirNutritionOrderOralDietNutrient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirNutritionOrderOralDietNutrient.SetModifier(value : TFhirCodeableConcept);
begin
  FModifier.free;
  FModifier := value;
end;

procedure TFhirNutritionOrderOralDietNutrient.SetAmount(value : TFhirQuantity);
begin
  FAmount.free;
  FAmount := value;
end;

{ TFhirNutritionOrderOralDietNutrientListEnumerator }

constructor TFhirNutritionOrderOralDietNutrientListEnumerator.Create(list : TFhirNutritionOrderOralDietNutrientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietNutrientListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.GetCurrent : TFhirNutritionOrderOralDietNutrient;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietNutrientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionOrderOralDietNutrientList }

function TFhirNutritionOrderOralDietNutrientList.AddItem(value: TFhirNutritionOrderOralDietNutrient): TFhirNutritionOrderOralDietNutrient;
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDietNutrient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDietNutrient');
  add(value);
  result := value;
end;

function TFhirNutritionOrderOralDietNutrientList.Append: TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietNutrientList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietNutrientList.GetEnumerator : TFhirNutritionOrderOralDietNutrientListEnumerator;
begin
  result := TFhirNutritionOrderOralDietNutrientListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietNutrientList.Clone: TFhirNutritionOrderOralDietNutrientList;
begin
  result := TFhirNutritionOrderOralDietNutrientList(inherited Clone);
end;

function TFhirNutritionOrderOralDietNutrientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietNutrientList.GetItemN(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietNutrientList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDietNutrient;
end;
function TFhirNutritionOrderOralDietNutrientList.IndexOf(value: TFhirNutritionOrderOralDietNutrient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietNutrientList.Insert(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietNutrientList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietNutrientList.Item(index: Integer): TFhirNutritionOrderOralDietNutrient;
begin
  result := TFhirNutritionOrderOralDietNutrient(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietNutrientList.Link: TFhirNutritionOrderOralDietNutrientList;
begin
  result := TFhirNutritionOrderOralDietNutrientList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietNutrientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietNutrientList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  FhirNutritionOrderOralDietNutrients[index] := value;
end;

procedure TFhirNutritionOrderOralDietNutrientList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDietNutrient);
begin
  assert(value is TFhirNutritionOrderOralDietNutrient);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderOralDietTexture }

constructor TFhirNutritionOrderOralDietTexture.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderOralDietTexture.Destroy;
begin
  FModifier.free;
  FFoodType.free;
  inherited;
end;

procedure TFhirNutritionOrderOralDietTexture.Assign(oSource : TFslObject);
begin
  inherited;
  modifier := TFhirNutritionOrderOralDietTexture(oSource).modifier.Clone;
  foodType := TFhirNutritionOrderOralDietTexture(oSource).foodType.Clone;
end;

procedure TFhirNutritionOrderOralDietTexture.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'modifier') Then
     list.add(self.link, 'modifier', FModifier.Link);
  if (child_name = 'foodType') Then
     list.add(self.link, 'foodType', FFoodType.Link);
end;

procedure TFhirNutritionOrderOralDietTexture.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'modifier', 'CodeableConcept', false, TFhirCodeableConcept, FModifier.Link));
  oList.add(TFHIRProperty.create(self, 'foodType', 'CodeableConcept', false, TFhirCodeableConcept, FFoodType.Link));
end;

function TFhirNutritionOrderOralDietTexture.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'modifier') then
  begin
    Modifier := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'foodType') then
  begin
    FoodType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderOralDietTexture.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderOralDietTexture.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'modifier') then result := TFhirCodeableConcept.create()
  else if (propName = 'foodType') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderOralDietTexture.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'modifier') then result := 'CodeableConcept'
  else if (propName = 'foodType') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderOralDietTexture.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := nil
  else if (propName = 'foodType') then FoodTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderOralDietTexture.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'modifier') then ModifierElement := new as TFhirCodeableConcept
  else if (propName = 'foodType') then FoodTypeElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderOralDietTexture.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderOralDietTexture.fhirType : string;
begin
  result := 'NutritionOrder.oralDiet.texture';
end;

function TFhirNutritionOrderOralDietTexture.Link : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(inherited Link);
end;

function TFhirNutritionOrderOralDietTexture.Clone : TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(inherited Clone);
end;

function TFhirNutritionOrderOralDietTexture.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderOralDietTexture;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderOralDietTexture)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderOralDietTexture(other);
    result := compareDeep(modifierElement, o.modifierElement, true) and compareDeep(foodTypeElement, o.foodTypeElement, true);
  end;
end;

function TFhirNutritionOrderOralDietTexture.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FModifier) and isEmptyProp(FFoodType);
end;

procedure TFhirNutritionOrderOralDietTexture.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('modifier');
  fields.add('foodType');
end;

function TFhirNutritionOrderOralDietTexture.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirNutritionOrderOralDietTexture.SetModifier(value : TFhirCodeableConcept);
begin
  FModifier.free;
  FModifier := value;
end;

procedure TFhirNutritionOrderOralDietTexture.SetFoodType(value : TFhirCodeableConcept);
begin
  FFoodType.free;
  FFoodType := value;
end;

{ TFhirNutritionOrderOralDietTextureListEnumerator }

constructor TFhirNutritionOrderOralDietTextureListEnumerator.Create(list : TFhirNutritionOrderOralDietTextureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderOralDietTextureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.GetCurrent : TFhirNutritionOrderOralDietTexture;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderOralDietTextureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionOrderOralDietTextureList }

function TFhirNutritionOrderOralDietTextureList.AddItem(value: TFhirNutritionOrderOralDietTexture): TFhirNutritionOrderOralDietTexture;
begin
  assert(value.ClassName = 'TFhirNutritionOrderOralDietTexture', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderOralDietTexture');
  add(value);
  result := value;
end;

function TFhirNutritionOrderOralDietTextureList.Append: TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietTextureList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderOralDietTextureList.GetEnumerator : TFhirNutritionOrderOralDietTextureListEnumerator;
begin
  result := TFhirNutritionOrderOralDietTextureListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderOralDietTextureList.Clone: TFhirNutritionOrderOralDietTextureList;
begin
  result := TFhirNutritionOrderOralDietTextureList(inherited Clone);
end;

function TFhirNutritionOrderOralDietTextureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderOralDietTextureList.GetItemN(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietTextureList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderOralDietTexture;
end;
function TFhirNutritionOrderOralDietTextureList.IndexOf(value: TFhirNutritionOrderOralDietTexture): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderOralDietTextureList.Insert(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderOralDietTextureList.InsertItem(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderOralDietTextureList.Item(index: Integer): TFhirNutritionOrderOralDietTexture;
begin
  result := TFhirNutritionOrderOralDietTexture(ObjectByIndex[index]);
end;

function TFhirNutritionOrderOralDietTextureList.Link: TFhirNutritionOrderOralDietTextureList;
begin
  result := TFhirNutritionOrderOralDietTextureList(inherited Link);
end;

procedure TFhirNutritionOrderOralDietTextureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderOralDietTextureList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  FhirNutritionOrderOralDietTextures[index] := value;
end;

procedure TFhirNutritionOrderOralDietTextureList.SetItemN(index: Integer; value: TFhirNutritionOrderOralDietTexture);
begin
  assert(value is TFhirNutritionOrderOralDietTexture);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderSupplement }

constructor TFhirNutritionOrderSupplement.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderSupplement.Destroy;
begin
  FType_.free;
  FProductName.free;
  FScheduleList.Free;
  FQuantity.free;
  FInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderSupplement.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirNutritionOrderSupplement(oSource).type_.Clone;
  productNameElement := TFhirNutritionOrderSupplement(oSource).productNameElement.Clone;
  if (TFhirNutritionOrderSupplement(oSource).FScheduleList = nil) then
  begin
    FScheduleList.free;
    FScheduleList := nil;
  end
  else
  begin
    if FScheduleList = nil then
      FScheduleList := TFhirTimingList.Create;
    FScheduleList.Assign(TFhirNutritionOrderSupplement(oSource).FScheduleList);
  end;
  quantity := TFhirNutritionOrderSupplement(oSource).quantity.Clone;
  instructionElement := TFhirNutritionOrderSupplement(oSource).instructionElement.Clone;
end;

procedure TFhirNutritionOrderSupplement.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'productName') Then
     list.add(self.link, 'productName', FProductName.Link);
  if (child_name = 'schedule') Then
    list.addAll(self, 'schedule', FScheduleList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'instruction') Then
     list.add(self.link, 'instruction', FInstruction.Link);
end;

procedure TFhirNutritionOrderSupplement.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'productName', 'string', false, TFhirString, FProductName.Link));
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', true, TFhirTiming, FScheduleList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'instruction', 'string', false, TFhirString, FInstruction.Link));
end;

function TFhirNutritionOrderSupplement.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'productName') then
  begin
    ProductNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    ScheduleList.add(propValue as TFhirTiming);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'instruction') then
  begin
    InstructionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderSupplement.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'schedule') then ScheduleList.insertItem(index, propValue as TFhirTiming)
  else inherited;
end;

function TFhirNutritionOrderSupplement.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'productName') then result := TFhirString.create()
  else if (propName = 'schedule') then result := ScheduleList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'instruction') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderSupplement.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'productName') then result := 'string'
  else if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'instruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderSupplement.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'productName') then ProductNameElement := nil
  else if (propName = 'schedule') then deletePropertyValue('schedule', ScheduleList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'instruction') then InstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderSupplement.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'productName') then ProductNameElement := asString(new)
  else if (propName = 'schedule') then replacePropertyValue('schedule', ScheduleList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'instruction') then InstructionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderSupplement.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'schedule') then ScheduleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderSupplement.fhirType : string;
begin
  result := 'NutritionOrder.supplement';
end;

function TFhirNutritionOrderSupplement.Link : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(inherited Link);
end;

function TFhirNutritionOrderSupplement.Clone : TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(inherited Clone);
end;

function TFhirNutritionOrderSupplement.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderSupplement;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderSupplement)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderSupplement(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(productNameElement, o.productNameElement, true) and 
      compareDeep(scheduleList, o.scheduleList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(instructionElement, o.instructionElement, true);
  end;
end;

function TFhirNutritionOrderSupplement.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FProductName) and isEmptyProp(FscheduleList) and isEmptyProp(FQuantity) and isEmptyProp(FInstruction);
end;

procedure TFhirNutritionOrderSupplement.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('productName');
  fields.add('schedule');
  fields.add('quantity');
  fields.add('instruction');
end;

function TFhirNutritionOrderSupplement.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FScheduleList.sizeInBytes(magic));
end;

procedure TFhirNutritionOrderSupplement.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirNutritionOrderSupplement.SetProductName(value : TFhirString);
begin
  FProductName.free;
  FProductName := value;
end;

function TFhirNutritionOrderSupplement.GetProductNameST : String;
begin
  if FProductName = nil then
    result := ''
  else
    result := FProductName.value;
end;

procedure TFhirNutritionOrderSupplement.SetProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FProductName = nil then
      FProductName := TFhirString.create;
    FProductName.value := value
  end
  else if FProductName <> nil then
    FProductName.value := '';
end;

function TFhirNutritionOrderSupplement.GetScheduleList : TFhirTimingList;
begin
  if FScheduleList = nil then
    FScheduleList := TFhirTimingList.Create;
  result := FScheduleList;
end;

function TFhirNutritionOrderSupplement.GetHasScheduleList : boolean;
begin
  result := (FScheduleList <> nil) and (FScheduleList.count > 0);
end;

procedure TFhirNutritionOrderSupplement.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirNutritionOrderSupplement.SetInstruction(value : TFhirString);
begin
  FInstruction.free;
  FInstruction := value;
end;

function TFhirNutritionOrderSupplement.GetInstructionST : String;
begin
  if FInstruction = nil then
    result := ''
  else
    result := FInstruction.value;
end;

procedure TFhirNutritionOrderSupplement.SetInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FInstruction = nil then
      FInstruction := TFhirString.create;
    FInstruction.value := value
  end
  else if FInstruction <> nil then
    FInstruction.value := '';
end;

{ TFhirNutritionOrderSupplementListEnumerator }

constructor TFhirNutritionOrderSupplementListEnumerator.Create(list : TFhirNutritionOrderSupplementList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderSupplementListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderSupplementListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderSupplementListEnumerator.GetCurrent : TFhirNutritionOrderSupplement;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderSupplementListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionOrderSupplementList }

function TFhirNutritionOrderSupplementList.AddItem(value: TFhirNutritionOrderSupplement): TFhirNutritionOrderSupplement;
begin
  assert(value.ClassName = 'TFhirNutritionOrderSupplement', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderSupplement');
  add(value);
  result := value;
end;

function TFhirNutritionOrderSupplementList.Append: TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderSupplementList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderSupplementList.GetEnumerator : TFhirNutritionOrderSupplementListEnumerator;
begin
  result := TFhirNutritionOrderSupplementListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderSupplementList.Clone: TFhirNutritionOrderSupplementList;
begin
  result := TFhirNutritionOrderSupplementList(inherited Clone);
end;

function TFhirNutritionOrderSupplementList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderSupplementList.GetItemN(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(ObjectByIndex[index]);
end;

function TFhirNutritionOrderSupplementList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderSupplement;
end;
function TFhirNutritionOrderSupplementList.IndexOf(value: TFhirNutritionOrderSupplement): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderSupplementList.Insert(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderSupplementList.InsertItem(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderSupplementList.Item(index: Integer): TFhirNutritionOrderSupplement;
begin
  result := TFhirNutritionOrderSupplement(ObjectByIndex[index]);
end;

function TFhirNutritionOrderSupplementList.Link: TFhirNutritionOrderSupplementList;
begin
  result := TFhirNutritionOrderSupplementList(inherited Link);
end;

procedure TFhirNutritionOrderSupplementList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderSupplementList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  FhirNutritionOrderSupplements[index] := value;
end;

procedure TFhirNutritionOrderSupplementList.SetItemN(index: Integer; value: TFhirNutritionOrderSupplement);
begin
  assert(value is TFhirNutritionOrderSupplement);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderEnteralFormula }

constructor TFhirNutritionOrderEnteralFormula.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderEnteralFormula.Destroy;
begin
  FBaseFormulaType.free;
  FBaseFormulaProductName.free;
  FAdditiveType.free;
  FAdditiveProductName.free;
  FCaloricDensity.free;
  FRouteofAdministration.free;
  FAdministrationList.Free;
  FMaxVolumeToDeliver.free;
  FAdministrationInstruction.free;
  inherited;
end;

procedure TFhirNutritionOrderEnteralFormula.Assign(oSource : TFslObject);
begin
  inherited;
  baseFormulaType := TFhirNutritionOrderEnteralFormula(oSource).baseFormulaType.Clone;
  baseFormulaProductNameElement := TFhirNutritionOrderEnteralFormula(oSource).baseFormulaProductNameElement.Clone;
  additiveType := TFhirNutritionOrderEnteralFormula(oSource).additiveType.Clone;
  additiveProductNameElement := TFhirNutritionOrderEnteralFormula(oSource).additiveProductNameElement.Clone;
  caloricDensity := TFhirNutritionOrderEnteralFormula(oSource).caloricDensity.Clone;
  routeofAdministration := TFhirNutritionOrderEnteralFormula(oSource).routeofAdministration.Clone;
  if (TFhirNutritionOrderEnteralFormula(oSource).FAdministrationList = nil) then
  begin
    FAdministrationList.free;
    FAdministrationList := nil;
  end
  else
  begin
    if FAdministrationList = nil then
      FAdministrationList := TFhirNutritionOrderEnteralFormulaAdministrationList.Create;
    FAdministrationList.Assign(TFhirNutritionOrderEnteralFormula(oSource).FAdministrationList);
  end;
  maxVolumeToDeliver := TFhirNutritionOrderEnteralFormula(oSource).maxVolumeToDeliver.Clone;
  administrationInstructionElement := TFhirNutritionOrderEnteralFormula(oSource).administrationInstructionElement.Clone;
end;

procedure TFhirNutritionOrderEnteralFormula.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'baseFormulaType') Then
     list.add(self.link, 'baseFormulaType', FBaseFormulaType.Link);
  if (child_name = 'baseFormulaProductName') Then
     list.add(self.link, 'baseFormulaProductName', FBaseFormulaProductName.Link);
  if (child_name = 'additiveType') Then
     list.add(self.link, 'additiveType', FAdditiveType.Link);
  if (child_name = 'additiveProductName') Then
     list.add(self.link, 'additiveProductName', FAdditiveProductName.Link);
  if (child_name = 'caloricDensity') Then
     list.add(self.link, 'caloricDensity', FCaloricDensity.Link);
  if (child_name = 'routeofAdministration') Then
     list.add(self.link, 'routeofAdministration', FRouteofAdministration.Link);
  if (child_name = 'administration') Then
    list.addAll(self, 'administration', FAdministrationList);
  if (child_name = 'maxVolumeToDeliver') Then
     list.add(self.link, 'maxVolumeToDeliver', FMaxVolumeToDeliver.Link);
  if (child_name = 'administrationInstruction') Then
     list.add(self.link, 'administrationInstruction', FAdministrationInstruction.Link);
end;

procedure TFhirNutritionOrderEnteralFormula.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'baseFormulaType', 'CodeableConcept', false, TFhirCodeableConcept, FBaseFormulaType.Link));
  oList.add(TFHIRProperty.create(self, 'baseFormulaProductName', 'string', false, TFhirString, FBaseFormulaProductName.Link));
  oList.add(TFHIRProperty.create(self, 'additiveType', 'CodeableConcept', false, TFhirCodeableConcept, FAdditiveType.Link));
  oList.add(TFHIRProperty.create(self, 'additiveProductName', 'string', false, TFhirString, FAdditiveProductName.Link));
  oList.add(TFHIRProperty.create(self, 'caloricDensity', 'Quantity', false, TFhirQuantity, FCaloricDensity.Link));
  oList.add(TFHIRProperty.create(self, 'routeofAdministration', 'CodeableConcept', false, TFhirCodeableConcept, FRouteofAdministration.Link));
  oList.add(TFHIRProperty.create(self, 'administration', 'BackboneElement', true, TFhirNutritionOrderEnteralFormulaAdministration, FAdministrationList.Link));
  oList.add(TFHIRProperty.create(self, 'maxVolumeToDeliver', 'Quantity', false, TFhirQuantity, FMaxVolumeToDeliver.Link));
  oList.add(TFHIRProperty.create(self, 'administrationInstruction', 'string', false, TFhirString, FAdministrationInstruction.Link));
end;

function TFhirNutritionOrderEnteralFormula.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'baseFormulaType') then
  begin
    BaseFormulaType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'baseFormulaProductName') then
  begin
    BaseFormulaProductNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'additiveType') then
  begin
    AdditiveType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'additiveProductName') then
  begin
    AdditiveProductNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'caloricDensity') then
  begin
    CaloricDensity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'routeofAdministration') then
  begin
    RouteofAdministration := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'administration') then
  begin
    AdministrationList.add(propValue as TFhirNutritionOrderEnteralFormulaAdministration);
    result := propValue;
  end
  else if (propName = 'maxVolumeToDeliver') then
  begin
    MaxVolumeToDeliver := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'administrationInstruction') then
  begin
    AdministrationInstructionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderEnteralFormula.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'administration') then AdministrationList.insertItem(index, propValue as TFhirNutritionOrderEnteralFormulaAdministration)
  else inherited;
end;

function TFhirNutritionOrderEnteralFormula.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'baseFormulaType') then result := TFhirCodeableConcept.create()
  else if (propName = 'baseFormulaProductName') then result := TFhirString.create()
  else if (propName = 'additiveType') then result := TFhirCodeableConcept.create()
  else if (propName = 'additiveProductName') then result := TFhirString.create()
  else if (propName = 'caloricDensity') then result := TFhirQuantity.create()
  else if (propName = 'routeofAdministration') then result := TFhirCodeableConcept.create()
  else if (propName = 'administration') then result := AdministrationList.new()
  else if (propName = 'maxVolumeToDeliver') then result := TFhirQuantity.create()
  else if (propName = 'administrationInstruction') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderEnteralFormula.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'baseFormulaType') then result := 'CodeableConcept'
  else if (propName = 'baseFormulaProductName') then result := 'string'
  else if (propName = 'additiveType') then result := 'CodeableConcept'
  else if (propName = 'additiveProductName') then result := 'string'
  else if (propName = 'caloricDensity') then result := 'Quantity'
  else if (propName = 'routeofAdministration') then result := 'CodeableConcept'
  else if (propName = 'administration') then result := 'BackboneElement'
  else if (propName = 'maxVolumeToDeliver') then result := 'Quantity'
  else if (propName = 'administrationInstruction') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderEnteralFormula.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'baseFormulaType') then BaseFormulaTypeElement := nil
  else if (propName = 'baseFormulaProductName') then BaseFormulaProductNameElement := nil
  else if (propName = 'additiveType') then AdditiveTypeElement := nil
  else if (propName = 'additiveProductName') then AdditiveProductNameElement := nil
  else if (propName = 'caloricDensity') then CaloricDensityElement := nil
  else if (propName = 'routeofAdministration') then RouteofAdministrationElement := nil
  else if (propName = 'administration') then deletePropertyValue('administration', AdministrationList, value)
  else if (propName = 'maxVolumeToDeliver') then MaxVolumeToDeliverElement := nil
  else if (propName = 'administrationInstruction') then AdministrationInstructionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderEnteralFormula.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'baseFormulaType') then BaseFormulaTypeElement := new as TFhirCodeableConcept
  else if (propName = 'baseFormulaProductName') then BaseFormulaProductNameElement := asString(new)
  else if (propName = 'additiveType') then AdditiveTypeElement := new as TFhirCodeableConcept
  else if (propName = 'additiveProductName') then AdditiveProductNameElement := asString(new)
  else if (propName = 'caloricDensity') then CaloricDensityElement := new as TFhirQuantity
  else if (propName = 'routeofAdministration') then RouteofAdministrationElement := new as TFhirCodeableConcept
  else if (propName = 'administration') then replacePropertyValue('administration', AdministrationList, existing, new)
  else if (propName = 'maxVolumeToDeliver') then MaxVolumeToDeliverElement := new as TFhirQuantity
  else if (propName = 'administrationInstruction') then AdministrationInstructionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderEnteralFormula.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'administration') then AdministrationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderEnteralFormula.fhirType : string;
begin
  result := 'NutritionOrder.enteralFormula';
end;

function TFhirNutritionOrderEnteralFormula.Link : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(inherited Link);
end;

function TFhirNutritionOrderEnteralFormula.Clone : TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormula.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderEnteralFormula;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderEnteralFormula)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderEnteralFormula(other);
    result := compareDeep(baseFormulaTypeElement, o.baseFormulaTypeElement, true) and 
      compareDeep(baseFormulaProductNameElement, o.baseFormulaProductNameElement, true) and 
      compareDeep(additiveTypeElement, o.additiveTypeElement, true) and compareDeep(additiveProductNameElement, o.additiveProductNameElement, true) and 
      compareDeep(caloricDensityElement, o.caloricDensityElement, true) and compareDeep(routeofAdministrationElement, o.routeofAdministrationElement, true) and 
      compareDeep(administrationList, o.administrationList, true) and compareDeep(maxVolumeToDeliverElement, o.maxVolumeToDeliverElement, true) and 
      compareDeep(administrationInstructionElement, o.administrationInstructionElement, true);
  end;
end;

function TFhirNutritionOrderEnteralFormula.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FBaseFormulaType) and isEmptyProp(FBaseFormulaProductName) and isEmptyProp(FAdditiveType) and isEmptyProp(FAdditiveProductName) and isEmptyProp(FCaloricDensity) and isEmptyProp(FRouteofAdministration) and isEmptyProp(FadministrationList) and isEmptyProp(FMaxVolumeToDeliver) and isEmptyProp(FAdministrationInstruction);
end;

procedure TFhirNutritionOrderEnteralFormula.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('baseFormulaType');
  fields.add('baseFormulaProductName');
  fields.add('additiveType');
  fields.add('additiveProductName');
  fields.add('caloricDensity');
  fields.add('routeofAdministration');
  fields.add('administration');
  fields.add('maxVolumeToDeliver');
  fields.add('administrationInstruction');
end;

function TFhirNutritionOrderEnteralFormula.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAdministrationList.sizeInBytes(magic));
end;

procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaType(value : TFhirCodeableConcept);
begin
  FBaseFormulaType.free;
  FBaseFormulaType := value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaProductName(value : TFhirString);
begin
  FBaseFormulaProductName.free;
  FBaseFormulaProductName := value;
end;

function TFhirNutritionOrderEnteralFormula.GetBaseFormulaProductNameST : String;
begin
  if FBaseFormulaProductName = nil then
    result := ''
  else
    result := FBaseFormulaProductName.value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetBaseFormulaProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FBaseFormulaProductName = nil then
      FBaseFormulaProductName := TFhirString.create;
    FBaseFormulaProductName.value := value
  end
  else if FBaseFormulaProductName <> nil then
    FBaseFormulaProductName.value := '';
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdditiveType(value : TFhirCodeableConcept);
begin
  FAdditiveType.free;
  FAdditiveType := value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdditiveProductName(value : TFhirString);
begin
  FAdditiveProductName.free;
  FAdditiveProductName := value;
end;

function TFhirNutritionOrderEnteralFormula.GetAdditiveProductNameST : String;
begin
  if FAdditiveProductName = nil then
    result := ''
  else
    result := FAdditiveProductName.value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdditiveProductNameST(value : String);
begin
  if value <> '' then
  begin
    if FAdditiveProductName = nil then
      FAdditiveProductName := TFhirString.create;
    FAdditiveProductName.value := value
  end
  else if FAdditiveProductName <> nil then
    FAdditiveProductName.value := '';
end;

procedure TFhirNutritionOrderEnteralFormula.SetCaloricDensity(value : TFhirQuantity);
begin
  FCaloricDensity.free;
  FCaloricDensity := value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetRouteofAdministration(value : TFhirCodeableConcept);
begin
  FRouteofAdministration.free;
  FRouteofAdministration := value;
end;

function TFhirNutritionOrderEnteralFormula.GetAdministrationList : TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  if FAdministrationList = nil then
    FAdministrationList := TFhirNutritionOrderEnteralFormulaAdministrationList.Create;
  result := FAdministrationList;
end;

function TFhirNutritionOrderEnteralFormula.GetHasAdministrationList : boolean;
begin
  result := (FAdministrationList <> nil) and (FAdministrationList.count > 0);
end;

procedure TFhirNutritionOrderEnteralFormula.SetMaxVolumeToDeliver(value : TFhirQuantity);
begin
  FMaxVolumeToDeliver.free;
  FMaxVolumeToDeliver := value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdministrationInstruction(value : TFhirString);
begin
  FAdministrationInstruction.free;
  FAdministrationInstruction := value;
end;

function TFhirNutritionOrderEnteralFormula.GetAdministrationInstructionST : String;
begin
  if FAdministrationInstruction = nil then
    result := ''
  else
    result := FAdministrationInstruction.value;
end;

procedure TFhirNutritionOrderEnteralFormula.SetAdministrationInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FAdministrationInstruction = nil then
      FAdministrationInstruction := TFhirString.create;
    FAdministrationInstruction.value := value
  end
  else if FAdministrationInstruction <> nil then
    FAdministrationInstruction.value := '';
end;

{ TFhirNutritionOrderEnteralFormulaListEnumerator }

constructor TFhirNutritionOrderEnteralFormulaListEnumerator.Create(list : TFhirNutritionOrderEnteralFormulaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderEnteralFormulaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.GetCurrent : TFhirNutritionOrderEnteralFormula;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderEnteralFormulaListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionOrderEnteralFormulaList }

function TFhirNutritionOrderEnteralFormulaList.AddItem(value: TFhirNutritionOrderEnteralFormula): TFhirNutritionOrderEnteralFormula;
begin
  assert(value.ClassName = 'TFhirNutritionOrderEnteralFormula', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderEnteralFormula');
  add(value);
  result := value;
end;

function TFhirNutritionOrderEnteralFormulaList.Append: TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderEnteralFormulaList.GetEnumerator : TFhirNutritionOrderEnteralFormulaListEnumerator;
begin
  result := TFhirNutritionOrderEnteralFormulaListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderEnteralFormulaList.Clone: TFhirNutritionOrderEnteralFormulaList;
begin
  result := TFhirNutritionOrderEnteralFormulaList(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderEnteralFormulaList.GetItemN(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderEnteralFormula;
end;
function TFhirNutritionOrderEnteralFormulaList.IndexOf(value: TFhirNutritionOrderEnteralFormula): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderEnteralFormulaList.Insert(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaList.InsertItem(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderEnteralFormulaList.Item(index: Integer): TFhirNutritionOrderEnteralFormula;
begin
  result := TFhirNutritionOrderEnteralFormula(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaList.Link: TFhirNutritionOrderEnteralFormulaList;
begin
  result := TFhirNutritionOrderEnteralFormulaList(inherited Link);
end;

procedure TFhirNutritionOrderEnteralFormulaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderEnteralFormulaList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  FhirNutritionOrderEnteralFormulas[index] := value;
end;

procedure TFhirNutritionOrderEnteralFormulaList.SetItemN(index: Integer; value: TFhirNutritionOrderEnteralFormula);
begin
  assert(value is TFhirNutritionOrderEnteralFormula);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrderEnteralFormulaAdministration }

constructor TFhirNutritionOrderEnteralFormulaAdministration.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrderEnteralFormulaAdministration.Destroy;
begin
  FSchedule.free;
  FQuantity.free;
  FRate.free;
  inherited;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.Assign(oSource : TFslObject);
begin
  inherited;
  schedule := TFhirNutritionOrderEnteralFormulaAdministration(oSource).schedule.Clone;
  quantity := TFhirNutritionOrderEnteralFormulaAdministration(oSource).quantity.Clone;
  rate := TFhirNutritionOrderEnteralFormulaAdministration(oSource).rate.Clone;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'rate[x]') or (child_name = 'rate') Then
     list.add(self.link, 'rate[x]', FRate.Link);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'schedule', 'Timing', false, TFhirTiming, FSchedule.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'rate[x]', 'Quantity|Ratio', false, TFhirDataType, FRate.Link));
end;

function TFhirNutritionOrderEnteralFormulaAdministration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirTiming;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then
  begin
    Rate := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'schedule') then result := TFhirTiming.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then raise EFHIRException.create('Cannot make property Rate')
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'schedule') then result := 'Timing'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'rate[x]') then result := 'Quantity|Ratio'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then RateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'schedule') then ScheduleElement := new as TFhirTiming
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (isMatchingName(propName, 'rate', ['Quantity', 'Ratio'])) then RateElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.fhirType : string;
begin
  result := 'NutritionOrder.enteralFormula.administration';
end;

function TFhirNutritionOrderEnteralFormulaAdministration.Link : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(inherited Link);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.Clone : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaAdministration.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrderEnteralFormulaAdministration)) then
    result := false
  else
  begin
    o := TFhirNutritionOrderEnteralFormulaAdministration(other);
    result := compareDeep(scheduleElement, o.scheduleElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(rateElement, o.rateElement, true);
  end;
end;

function TFhirNutritionOrderEnteralFormulaAdministration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSchedule) and isEmptyProp(FQuantity) and isEmptyProp(FRate);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('schedule');
  fields.add('quantity');
  fields.add('rate[x]');
end;

function TFhirNutritionOrderEnteralFormulaAdministration.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.SetSchedule(value : TFhirTiming);
begin
  FSchedule.free;
  FSchedule := value;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministration.SetRate(value : TFhirDataType);
begin
  FRate.free;
  FRate := value;
end;

{ TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator }

constructor TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Create(list : TFhirNutritionOrderEnteralFormulaAdministrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.GetCurrent : TFhirNutritionOrderEnteralFormulaAdministration;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionOrderEnteralFormulaAdministrationList }

function TFhirNutritionOrderEnteralFormulaAdministrationList.AddItem(value: TFhirNutritionOrderEnteralFormulaAdministration): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  assert(value.ClassName = 'TFhirNutritionOrderEnteralFormulaAdministration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrderEnteralFormulaAdministration');
  add(value);
  result := value;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Append: TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.GetEnumerator : TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Clone: TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationList(inherited Clone);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.GetItemN(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration;
end;
function TFhirNutritionOrderEnteralFormulaAdministrationList.IndexOf(value: TFhirNutritionOrderEnteralFormulaAdministration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Insert(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.InsertItem(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Item(index: Integer): TFhirNutritionOrderEnteralFormulaAdministration;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministration(ObjectByIndex[index]);
end;

function TFhirNutritionOrderEnteralFormulaAdministrationList.Link: TFhirNutritionOrderEnteralFormulaAdministrationList;
begin
  result := TFhirNutritionOrderEnteralFormulaAdministrationList(inherited Link);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.SetItemByIndex(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  FhirNutritionOrderEnteralFormulaAdministrations[index] := value;
end;

procedure TFhirNutritionOrderEnteralFormulaAdministrationList.SetItemN(index: Integer; value: TFhirNutritionOrderEnteralFormulaAdministration);
begin
  assert(value is TFhirNutritionOrderEnteralFormulaAdministration);
  ObjectByIndex[index] := value;
end;

{ TFhirNutritionOrder }

constructor TFhirNutritionOrder.Create;
begin
  inherited;
end;

destructor TFhirNutritionOrder.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FInstantiatesList.Free;
  FStatus.free;
  FIntent.free;
  FPatient.free;
  FEncounter.free;
  FDateTime.free;
  FOrderer.free;
  FAllergyIntoleranceList.Free;
  FFoodPreferenceModifierList.Free;
  FExcludeFoodModifierList.Free;
  FOralDiet.free;
  FSupplementList.Free;
  FEnteralFormula.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirNutritionOrder.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirNutritionOrder(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirNutritionOrder(oSource).FIdentifierList);
  end;
  if (TFhirNutritionOrder(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirNutritionOrder(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirNutritionOrder(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirNutritionOrder(oSource).FInstantiatesUriList);
  end;
  if (TFhirNutritionOrder(oSource).FInstantiatesList = nil) then
  begin
    FInstantiatesList.free;
    FInstantiatesList := nil;
  end
  else
  begin
    if FInstantiatesList = nil then
      FInstantiatesList := TFhirUriList.Create;
    FInstantiatesList.Assign(TFhirNutritionOrder(oSource).FInstantiatesList);
  end;
  statusElement := TFhirNutritionOrder(oSource).statusElement.Clone;
  intentElement := TFhirNutritionOrder(oSource).intentElement.Clone;
  patient := TFhirNutritionOrder(oSource).patient.Clone;
  encounter := TFhirNutritionOrder(oSource).encounter.Clone;
  dateTimeElement := TFhirNutritionOrder(oSource).dateTimeElement.Clone;
  orderer := TFhirNutritionOrder(oSource).orderer.Clone;
  if (TFhirNutritionOrder(oSource).FAllergyIntoleranceList = nil) then
  begin
    FAllergyIntoleranceList.free;
    FAllergyIntoleranceList := nil;
  end
  else
  begin
    if FAllergyIntoleranceList = nil then
      FAllergyIntoleranceList := TFhirReferenceList.Create;
    FAllergyIntoleranceList.Assign(TFhirNutritionOrder(oSource).FAllergyIntoleranceList);
  end;
  if (TFhirNutritionOrder(oSource).FFoodPreferenceModifierList = nil) then
  begin
    FFoodPreferenceModifierList.free;
    FFoodPreferenceModifierList := nil;
  end
  else
  begin
    if FFoodPreferenceModifierList = nil then
      FFoodPreferenceModifierList := TFhirCodeableConceptList.Create;
    FFoodPreferenceModifierList.Assign(TFhirNutritionOrder(oSource).FFoodPreferenceModifierList);
  end;
  if (TFhirNutritionOrder(oSource).FExcludeFoodModifierList = nil) then
  begin
    FExcludeFoodModifierList.free;
    FExcludeFoodModifierList := nil;
  end
  else
  begin
    if FExcludeFoodModifierList = nil then
      FExcludeFoodModifierList := TFhirCodeableConceptList.Create;
    FExcludeFoodModifierList.Assign(TFhirNutritionOrder(oSource).FExcludeFoodModifierList);
  end;
  oralDiet := TFhirNutritionOrder(oSource).oralDiet.Clone;
  if (TFhirNutritionOrder(oSource).FSupplementList = nil) then
  begin
    FSupplementList.free;
    FSupplementList := nil;
  end
  else
  begin
    if FSupplementList = nil then
      FSupplementList := TFhirNutritionOrderSupplementList.Create;
    FSupplementList.Assign(TFhirNutritionOrder(oSource).FSupplementList);
  end;
  enteralFormula := TFhirNutritionOrder(oSource).enteralFormula.Clone;
  if (TFhirNutritionOrder(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirNutritionOrder(oSource).FNoteList);
  end;
end;

function TFhirNutritionOrder.GetResourceType : TFhirResourceType;
begin
  result := frtNutritionOrder;
end;

procedure TFhirNutritionOrder.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'instantiates') Then
    list.addAll(self, 'instantiates', FInstantiatesList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'orderer') Then
     list.add(self.link, 'orderer', FOrderer.Link);
  if (child_name = 'allergyIntolerance') Then
    list.addAll(self, 'allergyIntolerance', FAllergyIntoleranceList);
  if (child_name = 'foodPreferenceModifier') Then
    list.addAll(self, 'foodPreferenceModifier', FFoodPreferenceModifierList);
  if (child_name = 'excludeFoodModifier') Then
    list.addAll(self, 'excludeFoodModifier', FExcludeFoodModifierList);
  if (child_name = 'oralDiet') Then
     list.add(self.link, 'oralDiet', FOralDiet.Link);
  if (child_name = 'supplement') Then
    list.addAll(self, 'supplement', FSupplementList);
  if (child_name = 'enteralFormula') Then
     list.add(self.link, 'enteralFormula', FEnteralFormula.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirNutritionOrder.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiates', 'uri', true, TFhirUri, FInstantiatesList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', false, TFhirDateTime, FDateTime.Link));
  oList.add(TFHIRProperty.create(self, 'orderer', 'Reference', false, TFhirReference, FOrderer.Link));
  oList.add(TFHIRProperty.create(self, 'allergyIntolerance', 'Reference', true, TFhirReference, FAllergyIntoleranceList.Link));
  oList.add(TFHIRProperty.create(self, 'foodPreferenceModifier', 'CodeableConcept', true, TFhirCodeableConcept, FFoodPreferenceModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'excludeFoodModifier', 'CodeableConcept', true, TFhirCodeableConcept, FExcludeFoodModifierList.Link));
  oList.add(TFHIRProperty.create(self, 'oralDiet', 'BackboneElement', false, TFhirNutritionOrderOralDiet, FOralDiet.Link));
  oList.add(TFHIRProperty.create(self, 'supplement', 'BackboneElement', true, TFhirNutritionOrderSupplement, FSupplementList.Link));
  oList.add(TFHIRProperty.create(self, 'enteralFormula', 'BackboneElement', false, TFhirNutritionOrderEnteralFormula, FEnteralFormula.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirNutritionOrder.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiates') then
  begin
    InstantiatesList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'orderer') then
  begin
    Orderer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'allergyIntolerance') then
  begin
    AllergyIntoleranceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'foodPreferenceModifier') then
  begin
    FoodPreferenceModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'excludeFoodModifier') then
  begin
    ExcludeFoodModifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'oralDiet') then
  begin
    OralDiet := propValue as TFhirNutritionOrderOralDiet;
    result := propValue;
  end
  else if (propName = 'supplement') then
  begin
    SupplementList.add(propValue as TFhirNutritionOrderSupplement);
    result := propValue;
  end
  else if (propName = 'enteralFormula') then
  begin
    EnteralFormula := propValue as TFhirNutritionOrderEnteralFormula;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirNutritionOrder.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'instantiates') then InstantiatesList.insertItem(index, asUri(propValue))
  else if (propName = 'allergyIntolerance') then AllergyIntoleranceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'foodPreferenceModifier') then FoodPreferenceModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'excludeFoodModifier') then ExcludeFoodModifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'supplement') then SupplementList.insertItem(index, propValue as TFhirNutritionOrderSupplement)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirNutritionOrder.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'instantiates') then result := InstantiatesList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull]) 
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull]) 
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'dateTime') then result := TFhirDateTime.create()
  else if (propName = 'orderer') then result := TFhirReference.create()
  else if (propName = 'allergyIntolerance') then result := AllergyIntoleranceList.new()
  else if (propName = 'foodPreferenceModifier') then result := FoodPreferenceModifierList.new()
  else if (propName = 'excludeFoodModifier') then result := ExcludeFoodModifierList.new()
  else if (propName = 'oralDiet') then result := TFhirNutritionOrderOralDiet.create()
  else if (propName = 'supplement') then result := SupplementList.new()
  else if (propName = 'enteralFormula') then result := TFhirNutritionOrderEnteralFormula.create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirNutritionOrder.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'instantiates') then result := 'uri'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'dateTime') then result := 'dateTime'
  else if (propName = 'orderer') then result := 'Reference'
  else if (propName = 'allergyIntolerance') then result := 'Reference'
  else if (propName = 'foodPreferenceModifier') then result := 'CodeableConcept'
  else if (propName = 'excludeFoodModifier') then result := 'CodeableConcept'
  else if (propName = 'oralDiet') then result := 'BackboneElement'
  else if (propName = 'supplement') then result := 'BackboneElement'
  else if (propName = 'enteralFormula') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirNutritionOrder.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'instantiates') then deletePropertyValue('instantiates', InstantiatesList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'orderer') then OrdererElement := nil
  else if (propName = 'allergyIntolerance') then deletePropertyValue('allergyIntolerance', AllergyIntoleranceList, value)
  else if (propName = 'foodPreferenceModifier') then deletePropertyValue('foodPreferenceModifier', FoodPreferenceModifierList, value)
  else if (propName = 'excludeFoodModifier') then deletePropertyValue('excludeFoodModifier', ExcludeFoodModifierList, value)
  else if (propName = 'oralDiet') then OralDietElement := nil
  else if (propName = 'supplement') then deletePropertyValue('supplement', SupplementList, value)
  else if (propName = 'enteralFormula') then EnteralFormulaElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirNutritionOrder.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'instantiates') then replacePropertyValue('instantiates', InstantiatesList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new)
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'dateTime') then DateTimeElement := asDateTime(new)
  else if (propName = 'orderer') then OrdererElement := new as TFhirReference
  else if (propName = 'allergyIntolerance') then replacePropertyValue('allergyIntolerance', AllergyIntoleranceList, existing, new)
  else if (propName = 'foodPreferenceModifier') then replacePropertyValue('foodPreferenceModifier', FoodPreferenceModifierList, existing, new)
  else if (propName = 'excludeFoodModifier') then replacePropertyValue('excludeFoodModifier', ExcludeFoodModifierList, existing, new)
  else if (propName = 'oralDiet') then OralDietElement := new as TFhirNutritionOrderOralDiet
  else if (propName = 'supplement') then replacePropertyValue('supplement', SupplementList, existing, new)
  else if (propName = 'enteralFormula') then EnteralFormulaElement := new as TFhirNutritionOrderEnteralFormula
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirNutritionOrder.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'instantiates') then InstantiatesList.move(source, destination)
  else if (propName = 'allergyIntolerance') then AllergyIntoleranceList.move(source, destination)
  else if (propName = 'foodPreferenceModifier') then FoodPreferenceModifierList.move(source, destination)
  else if (propName = 'excludeFoodModifier') then ExcludeFoodModifierList.move(source, destination)
  else if (propName = 'supplement') then SupplementList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirNutritionOrder.fhirType : string;
begin
  result := 'NutritionOrder';
end;

function TFhirNutritionOrder.Link : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(inherited Link);
end;

function TFhirNutritionOrder.Clone : TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(inherited Clone);
end;

function TFhirNutritionOrder.equals(other : TObject) : boolean; 
var
  o : TFhirNutritionOrder;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirNutritionOrder)) then
    result := false
  else
  begin
    o := TFhirNutritionOrder(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(instantiatesList, o.instantiatesList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(dateTimeElement, o.dateTimeElement, true) and compareDeep(ordererElement, o.ordererElement, true) and 
      compareDeep(allergyIntoleranceList, o.allergyIntoleranceList, true) and compareDeep(foodPreferenceModifierList, o.foodPreferenceModifierList, true) and 
      compareDeep(excludeFoodModifierList, o.excludeFoodModifierList, true) and compareDeep(oralDietElement, o.oralDietElement, true) and 
      compareDeep(supplementList, o.supplementList, true) and compareDeep(enteralFormulaElement, o.enteralFormulaElement, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirNutritionOrder.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FinstantiatesList) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FDateTime) and isEmptyProp(FOrderer) and isEmptyProp(FallergyIntoleranceList) and isEmptyProp(FfoodPreferenceModifierList) and isEmptyProp(FexcludeFoodModifierList) and isEmptyProp(FOralDiet) and isEmptyProp(FsupplementList) and isEmptyProp(FEnteralFormula) and isEmptyProp(FnoteList);
end;

procedure TFhirNutritionOrder.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('instantiates');
  fields.add('status');
  fields.add('intent');
  fields.add('patient');
  fields.add('encounter');
  fields.add('dateTime');
  fields.add('orderer');
  fields.add('allergyIntolerance');
  fields.add('foodPreferenceModifier');
  fields.add('excludeFoodModifier');
  fields.add('oralDiet');
  fields.add('supplement');
  fields.add('enteralFormula');
  fields.add('note');
end;

function TFhirNutritionOrder.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FInstantiatesList.sizeInBytes(magic));
  inc(result, FAllergyIntoleranceList.sizeInBytes(magic));
  inc(result, FFoodPreferenceModifierList.sizeInBytes(magic));
  inc(result, FExcludeFoodModifierList.sizeInBytes(magic));
  inc(result, FSupplementList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirNutritionOrder.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirNutritionOrder.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirNutritionOrder.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirNutritionOrder.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirNutritionOrder.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirNutritionOrder.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirNutritionOrder.GetInstantiatesList : TFhirUriList;
begin
  if FInstantiatesList = nil then
    FInstantiatesList := TFhirUriList.Create;
  result := FInstantiatesList;
end;

function TFhirNutritionOrder.GetHasInstantiatesList : boolean;
begin
  result := (FInstantiatesList <> nil) and (FInstantiatesList.count > 0);
end;

procedure TFhirNutritionOrder.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirNutritionOrder.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirNutritionOrder.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirNutritionOrder.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirNutritionOrder.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirNutritionOrder.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

procedure TFhirNutritionOrder.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirNutritionOrder.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirNutritionOrder.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

function TFhirNutritionOrder.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

procedure TFhirNutritionOrder.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirDateTime.create;
  FDateTime.value := value
end;

procedure TFhirNutritionOrder.SetOrderer(value : TFhirReference);
begin
  FOrderer.free;
  FOrderer := value;
end;

function TFhirNutritionOrder.GetAllergyIntoleranceList : TFhirReferenceList;
begin
  if FAllergyIntoleranceList = nil then
    FAllergyIntoleranceList := TFhirReferenceList.Create;
  result := FAllergyIntoleranceList;
end;

function TFhirNutritionOrder.GetHasAllergyIntoleranceList : boolean;
begin
  result := (FAllergyIntoleranceList <> nil) and (FAllergyIntoleranceList.count > 0);
end;

function TFhirNutritionOrder.GetFoodPreferenceModifierList : TFhirCodeableConceptList;
begin
  if FFoodPreferenceModifierList = nil then
    FFoodPreferenceModifierList := TFhirCodeableConceptList.Create;
  result := FFoodPreferenceModifierList;
end;

function TFhirNutritionOrder.GetHasFoodPreferenceModifierList : boolean;
begin
  result := (FFoodPreferenceModifierList <> nil) and (FFoodPreferenceModifierList.count > 0);
end;

function TFhirNutritionOrder.GetExcludeFoodModifierList : TFhirCodeableConceptList;
begin
  if FExcludeFoodModifierList = nil then
    FExcludeFoodModifierList := TFhirCodeableConceptList.Create;
  result := FExcludeFoodModifierList;
end;

function TFhirNutritionOrder.GetHasExcludeFoodModifierList : boolean;
begin
  result := (FExcludeFoodModifierList <> nil) and (FExcludeFoodModifierList.count > 0);
end;

procedure TFhirNutritionOrder.SetOralDiet(value : TFhirNutritionOrderOralDiet);
begin
  FOralDiet.free;
  FOralDiet := value;
end;

function TFhirNutritionOrder.GetSupplementList : TFhirNutritionOrderSupplementList;
begin
  if FSupplementList = nil then
    FSupplementList := TFhirNutritionOrderSupplementList.Create;
  result := FSupplementList;
end;

function TFhirNutritionOrder.GetHasSupplementList : boolean;
begin
  result := (FSupplementList <> nil) and (FSupplementList.count > 0);
end;

procedure TFhirNutritionOrder.SetEnteralFormula(value : TFhirNutritionOrderEnteralFormula);
begin
  FEnteralFormula.free;
  FEnteralFormula := value;
end;

function TFhirNutritionOrder.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirNutritionOrder.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirNutritionOrderListEnumerator }

constructor TFhirNutritionOrderListEnumerator.Create(list : TFhirNutritionOrderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirNutritionOrderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirNutritionOrderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirNutritionOrderListEnumerator.GetCurrent : TFhirNutritionOrder;
begin
  Result := FList[FIndex];
end;

function TFhirNutritionOrderListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirNutritionOrderList }

function TFhirNutritionOrderList.AddItem(value: TFhirNutritionOrder): TFhirNutritionOrder;
begin
  assert(value.ClassName = 'TFhirNutritionOrder', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirNutritionOrder');
  add(value);
  result := value;
end;

function TFhirNutritionOrderList.Append: TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderList.ClearItems;
begin
  Clear;
end;

function TFhirNutritionOrderList.GetEnumerator : TFhirNutritionOrderListEnumerator;
begin
  result := TFhirNutritionOrderListEnumerator.Create(self.link);
end;

function TFhirNutritionOrderList.Clone: TFhirNutritionOrderList;
begin
  result := TFhirNutritionOrderList(inherited Clone);
end;

function TFhirNutritionOrderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirNutritionOrderList.GetItemN(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(ObjectByIndex[index]);
end;

function TFhirNutritionOrderList.ItemClass: TFslObjectClass;
begin
  result := TFhirNutritionOrder;
end;
function TFhirNutritionOrderList.IndexOf(value: TFhirNutritionOrder): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirNutritionOrderList.Insert(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirNutritionOrderList.InsertItem(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  Inherited Insert(index, value);
end;

function TFhirNutritionOrderList.Item(index: Integer): TFhirNutritionOrder;
begin
  result := TFhirNutritionOrder(ObjectByIndex[index]);
end;

function TFhirNutritionOrderList.Link: TFhirNutritionOrderList;
begin
  result := TFhirNutritionOrderList(inherited Link);
end;

procedure TFhirNutritionOrderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirNutritionOrderList.SetItemByIndex(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  FhirNutritionOrders[index] := value;
end;

procedure TFhirNutritionOrderList.SetItemN(index: Integer; value: TFhirNutritionOrder);
begin
  assert(value is TFhirNutritionOrder);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_NUTRITIONORDER}
{$IFDEF FHIR_OBSERVATION}
{ TFhirObservationReferenceRange }

constructor TFhirObservationReferenceRange.Create;
begin
  inherited;
end;

destructor TFhirObservationReferenceRange.Destroy;
begin
  FLow.free;
  FHigh.free;
  FType_.free;
  FAppliesToList.Free;
  FAge.free;
  FText.free;
  inherited;
end;

procedure TFhirObservationReferenceRange.Assign(oSource : TFslObject);
begin
  inherited;
  low := TFhirObservationReferenceRange(oSource).low.Clone;
  high := TFhirObservationReferenceRange(oSource).high.Clone;
  type_ := TFhirObservationReferenceRange(oSource).type_.Clone;
  if (TFhirObservationReferenceRange(oSource).FAppliesToList = nil) then
  begin
    FAppliesToList.free;
    FAppliesToList := nil;
  end
  else
  begin
    if FAppliesToList = nil then
      FAppliesToList := TFhirCodeableConceptList.Create;
    FAppliesToList.Assign(TFhirObservationReferenceRange(oSource).FAppliesToList);
  end;
  age := TFhirObservationReferenceRange(oSource).age.Clone;
  textElement := TFhirObservationReferenceRange(oSource).textElement.Clone;
end;

procedure TFhirObservationReferenceRange.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'low') Then
     list.add(self.link, 'low', FLow.Link);
  if (child_name = 'high') Then
     list.add(self.link, 'high', FHigh.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'appliesTo') Then
    list.addAll(self, 'appliesTo', FAppliesToList);
  if (child_name = 'age') Then
     list.add(self.link, 'age', FAge.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirObservationReferenceRange.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'low', 'Quantity', false, TFhirQuantity, FLow.Link));
  oList.add(TFHIRProperty.create(self, 'high', 'Quantity', false, TFhirQuantity, FHigh.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'appliesTo', 'CodeableConcept', true, TFhirCodeableConcept, FAppliesToList.Link));
  oList.add(TFHIRProperty.create(self, 'age', 'Range', false, TFhirRange, FAge.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
end;

function TFhirObservationReferenceRange.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'low') then
  begin
    Low := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'high') then
  begin
    High := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'appliesTo') then
  begin
    AppliesToList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'age') then
  begin
    Age := propValue as TFhirRange;
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationReferenceRange.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'appliesTo') then AppliesToList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirObservationReferenceRange.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'low') then result := TFhirQuantity.create()
  else if (propName = 'high') then result := TFhirQuantity.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'appliesTo') then result := AppliesToList.new()
  else if (propName = 'age') then result := TFhirRange.create()
  else if (propName = 'text') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationReferenceRange.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'low') then result := 'Quantity'
  else if (propName = 'high') then result := 'Quantity'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'appliesTo') then result := 'CodeableConcept'
  else if (propName = 'age') then result := 'Range'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationReferenceRange.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'low') then LowElement := nil
  else if (propName = 'high') then HighElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'appliesTo') then deletePropertyValue('appliesTo', AppliesToList, value)
  else if (propName = 'age') then AgeElement := nil
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationReferenceRange.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'low') then LowElement := new as TFhirQuantity
  else if (propName = 'high') then HighElement := new as TFhirQuantity
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'appliesTo') then replacePropertyValue('appliesTo', AppliesToList, existing, new)
  else if (propName = 'age') then AgeElement := new as TFhirRange
  else if (propName = 'text') then TextElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationReferenceRange.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'appliesTo') then AppliesToList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationReferenceRange.fhirType : string;
begin
  result := 'Observation.referenceRange';
end;

function TFhirObservationReferenceRange.Link : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Link);
end;

function TFhirObservationReferenceRange.Clone : TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(inherited Clone);
end;

function TFhirObservationReferenceRange.equals(other : TObject) : boolean; 
var
  o : TFhirObservationReferenceRange;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationReferenceRange)) then
    result := false
  else
  begin
    o := TFhirObservationReferenceRange(other);
    result := compareDeep(lowElement, o.lowElement, true) and compareDeep(highElement, o.highElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(appliesToList, o.appliesToList, true) and 
      compareDeep(ageElement, o.ageElement, true) and compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirObservationReferenceRange.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLow) and isEmptyProp(FHigh) and isEmptyProp(FType_) and isEmptyProp(FappliesToList) and isEmptyProp(FAge) and isEmptyProp(FText);
end;

procedure TFhirObservationReferenceRange.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('low');
  fields.add('high');
  fields.add('type');
  fields.add('appliesTo');
  fields.add('age');
  fields.add('text');
end;

function TFhirObservationReferenceRange.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAppliesToList.sizeInBytes(magic));
end;

procedure TFhirObservationReferenceRange.SetLow(value : TFhirQuantity);
begin
  FLow.free;
  FLow := value;
end;

procedure TFhirObservationReferenceRange.SetHigh(value : TFhirQuantity);
begin
  FHigh.free;
  FHigh := value;
end;

procedure TFhirObservationReferenceRange.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirObservationReferenceRange.GetAppliesToList : TFhirCodeableConceptList;
begin
  if FAppliesToList = nil then
    FAppliesToList := TFhirCodeableConceptList.Create;
  result := FAppliesToList;
end;

function TFhirObservationReferenceRange.GetHasAppliesToList : boolean;
begin
  result := (FAppliesToList <> nil) and (FAppliesToList.count > 0);
end;

procedure TFhirObservationReferenceRange.SetAge(value : TFhirRange);
begin
  FAge.free;
  FAge := value;
end;

procedure TFhirObservationReferenceRange.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirObservationReferenceRange.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirObservationReferenceRange.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

{ TFhirObservationReferenceRangeListEnumerator }

constructor TFhirObservationReferenceRangeListEnumerator.Create(list : TFhirObservationReferenceRangeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationReferenceRangeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationReferenceRangeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationReferenceRangeListEnumerator.GetCurrent : TFhirObservationReferenceRange;
begin
  Result := FList[FIndex];
end;

function TFhirObservationReferenceRangeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirObservationReferenceRangeList }

function TFhirObservationReferenceRangeList.AddItem(value: TFhirObservationReferenceRange): TFhirObservationReferenceRange;
begin
  assert(value.ClassName = 'TFhirObservationReferenceRange', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationReferenceRange');
  add(value);
  result := value;
end;

function TFhirObservationReferenceRangeList.Append: TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationReferenceRangeList.ClearItems;
begin
  Clear;
end;

function TFhirObservationReferenceRangeList.GetEnumerator : TFhirObservationReferenceRangeListEnumerator;
begin
  result := TFhirObservationReferenceRangeListEnumerator.Create(self.link);
end;

function TFhirObservationReferenceRangeList.Clone: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Clone);
end;

function TFhirObservationReferenceRangeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationReferenceRangeList.GetItemN(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationReferenceRange;
end;
function TFhirObservationReferenceRangeList.IndexOf(value: TFhirObservationReferenceRange): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationReferenceRangeList.Insert(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationReferenceRangeList.InsertItem(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  Inherited Insert(index, value);
end;

function TFhirObservationReferenceRangeList.Item(index: Integer): TFhirObservationReferenceRange;
begin
  result := TFhirObservationReferenceRange(ObjectByIndex[index]);
end;

function TFhirObservationReferenceRangeList.Link: TFhirObservationReferenceRangeList;
begin
  result := TFhirObservationReferenceRangeList(inherited Link);
end;

procedure TFhirObservationReferenceRangeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationReferenceRangeList.SetItemByIndex(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  FhirObservationReferenceRanges[index] := value;
end;

procedure TFhirObservationReferenceRangeList.SetItemN(index: Integer; value: TFhirObservationReferenceRange);
begin
  assert(value is TFhirObservationReferenceRange);
  ObjectByIndex[index] := value;
end;

{ TFhirObservationComponent }

constructor TFhirObservationComponent.Create;
begin
  inherited;
end;

destructor TFhirObservationComponent.Destroy;
begin
  FCode.free;
  FValue.free;
  FDataAbsentReason.free;
  FInterpretationList.Free;
  FReferenceRangeList.Free;
  inherited;
end;

procedure TFhirObservationComponent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirObservationComponent(oSource).code.Clone;
  value := TFhirObservationComponent(oSource).value.Clone;
  dataAbsentReason := TFhirObservationComponent(oSource).dataAbsentReason.Clone;
  if (TFhirObservationComponent(oSource).FInterpretationList = nil) then
  begin
    FInterpretationList.free;
    FInterpretationList := nil;
  end
  else
  begin
    if FInterpretationList = nil then
      FInterpretationList := TFhirCodeableConceptList.Create;
    FInterpretationList.Assign(TFhirObservationComponent(oSource).FInterpretationList);
  end;
  if (TFhirObservationComponent(oSource).FReferenceRangeList = nil) then
  begin
    FReferenceRangeList.free;
    FReferenceRangeList := nil;
  end
  else
  begin
    if FReferenceRangeList = nil then
      FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
    FReferenceRangeList.Assign(TFhirObservationComponent(oSource).FReferenceRangeList);
  end;
end;

procedure TFhirObservationComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'interpretation') Then
    list.addAll(self, 'interpretation', FInterpretationList);
  if (child_name = 'referenceRange') Then
    list.addAll(self, 'referenceRange', FReferenceRangeList);
end;

procedure TFhirObservationComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|SampledData|time|dateTime|Period', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link));
  oList.add(TFHIRProperty.create(self, 'interpretation', 'CodeableConcept', true, TFhirCodeableConcept, FInterpretationList.Link));
  oList.add(TFHIRProperty.create(self, 'referenceRange', '', true, TFhirObservationReferenceRange, FReferenceRangeList.Link));
end;

function TFhirObservationComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'interpretation') then
  begin
    InterpretationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRangeList.add(propValue as TFhirObservationReferenceRange);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservationComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'interpretation') then InterpretationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'referenceRange') then ReferenceRangeList.insertItem(index, propValue as TFhirObservationReferenceRange)
  else inherited;
end;

function TFhirObservationComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'interpretation') then result := InterpretationList.new()
  else if (propName = 'referenceRange') then result := ReferenceRangeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservationComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|SampledData|time|dateTime|Period'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'interpretation') then result := 'CodeableConcept'
  else if (propName = 'referenceRange') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservationComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period'])) then ValueElement := nil
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'interpretation') then deletePropertyValue('interpretation', InterpretationList, value)
  else if (propName = 'referenceRange') then deletePropertyValue('referenceRange', ReferenceRangeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservationComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period'])) then ValueElement := new as TFhirDataType
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept
  else if (propName = 'interpretation') then replacePropertyValue('interpretation', InterpretationList, existing, new)
  else if (propName = 'referenceRange') then replacePropertyValue('referenceRange', ReferenceRangeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservationComponent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'interpretation') then InterpretationList.move(source, destination)
  else if (propName = 'referenceRange') then ReferenceRangeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservationComponent.fhirType : string;
begin
  result := 'Observation.component';
end;

function TFhirObservationComponent.Link : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Link);
end;

function TFhirObservationComponent.Clone : TFhirObservationComponent;
begin
  result := TFhirObservationComponent(inherited Clone);
end;

function TFhirObservationComponent.equals(other : TObject) : boolean; 
var
  o : TFhirObservationComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservationComponent)) then
    result := false
  else
  begin
    o := TFhirObservationComponent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and compareDeep(interpretationList, o.interpretationList, true) and 
      compareDeep(referenceRangeList, o.referenceRangeList, true);
  end;
end;

function TFhirObservationComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FinterpretationList) and isEmptyProp(FreferenceRangeList);
end;

procedure TFhirObservationComponent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('dataAbsentReason');
  fields.add('interpretation');
  fields.add('referenceRange');
end;

function TFhirObservationComponent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FInterpretationList.sizeInBytes(magic));
  inc(result, FReferenceRangeList.sizeInBytes(magic));
end;

procedure TFhirObservationComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirObservationComponent.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirObservationComponent.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value;
end;

function TFhirObservationComponent.GetInterpretationList : TFhirCodeableConceptList;
begin
  if FInterpretationList = nil then
    FInterpretationList := TFhirCodeableConceptList.Create;
  result := FInterpretationList;
end;

function TFhirObservationComponent.GetHasInterpretationList : boolean;
begin
  result := (FInterpretationList <> nil) and (FInterpretationList.count > 0);
end;

function TFhirObservationComponent.GetReferenceRangeList : TFhirObservationReferenceRangeList;
begin
  if FReferenceRangeList = nil then
    FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
  result := FReferenceRangeList;
end;

function TFhirObservationComponent.GetHasReferenceRangeList : boolean;
begin
  result := (FReferenceRangeList <> nil) and (FReferenceRangeList.count > 0);
end;

{ TFhirObservationComponentListEnumerator }

constructor TFhirObservationComponentListEnumerator.Create(list : TFhirObservationComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationComponentListEnumerator.GetCurrent : TFhirObservationComponent;
begin
  Result := FList[FIndex];
end;

function TFhirObservationComponentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirObservationComponentList }

function TFhirObservationComponentList.AddItem(value: TFhirObservationComponent): TFhirObservationComponent;
begin
  assert(value.ClassName = 'TFhirObservationComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservationComponent');
  add(value);
  result := value;
end;

function TFhirObservationComponentList.Append: TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationComponentList.ClearItems;
begin
  Clear;
end;

function TFhirObservationComponentList.GetEnumerator : TFhirObservationComponentListEnumerator;
begin
  result := TFhirObservationComponentListEnumerator.Create(self.link);
end;

function TFhirObservationComponentList.Clone: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Clone);
end;

function TFhirObservationComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationComponentList.GetItemN(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservationComponent;
end;
function TFhirObservationComponentList.IndexOf(value: TFhirObservationComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationComponentList.Insert(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationComponentList.InsertItem(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  Inherited Insert(index, value);
end;

function TFhirObservationComponentList.Item(index: Integer): TFhirObservationComponent;
begin
  result := TFhirObservationComponent(ObjectByIndex[index]);
end;

function TFhirObservationComponentList.Link: TFhirObservationComponentList;
begin
  result := TFhirObservationComponentList(inherited Link);
end;

procedure TFhirObservationComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationComponentList.SetItemByIndex(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  FhirObservationComponents[index] := value;
end;

procedure TFhirObservationComponentList.SetItemN(index: Integer; value: TFhirObservationComponent);
begin
  assert(value is TFhirObservationComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirObservation }

constructor TFhirObservation.Create;
begin
  inherited;
end;

destructor TFhirObservation.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FCategoryList.Free;
  FCode.free;
  FSubject.free;
  FFocusList.Free;
  FEncounter.free;
  FEffective.free;
  FIssued.free;
  FPerformerList.Free;
  FValue.free;
  FDataAbsentReason.free;
  FInterpretationList.Free;
  FNoteList.Free;
  FBodySite.free;
  FMethod.free;
  FSpecimen.free;
  FDevice.free;
  FReferenceRangeList.Free;
  FHasMemberList.Free;
  FDerivedFromList.Free;
  FComponentList.Free;
  inherited;
end;

procedure TFhirObservation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirObservation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirObservation(oSource).FIdentifierList);
  end;
  if (TFhirObservation(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirObservation(oSource).FBasedOnList);
  end;
  if (TFhirObservation(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirObservation(oSource).FPartOfList);
  end;
  statusElement := TFhirObservation(oSource).statusElement.Clone;
  if (TFhirObservation(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirObservation(oSource).FCategoryList);
  end;
  code := TFhirObservation(oSource).code.Clone;
  subject := TFhirObservation(oSource).subject.Clone;
  if (TFhirObservation(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirReferenceList.Create;
    FFocusList.Assign(TFhirObservation(oSource).FFocusList);
  end;
  encounter := TFhirObservation(oSource).encounter.Clone;
  effective := TFhirObservation(oSource).effective.Clone;
  issuedElement := TFhirObservation(oSource).issuedElement.Clone;
  if (TFhirObservation(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList.Create;
    FPerformerList.Assign(TFhirObservation(oSource).FPerformerList);
  end;
  value := TFhirObservation(oSource).value.Clone;
  dataAbsentReason := TFhirObservation(oSource).dataAbsentReason.Clone;
  if (TFhirObservation(oSource).FInterpretationList = nil) then
  begin
    FInterpretationList.free;
    FInterpretationList := nil;
  end
  else
  begin
    if FInterpretationList = nil then
      FInterpretationList := TFhirCodeableConceptList.Create;
    FInterpretationList.Assign(TFhirObservation(oSource).FInterpretationList);
  end;
  if (TFhirObservation(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirObservation(oSource).FNoteList);
  end;
  bodySite := TFhirObservation(oSource).bodySite.Clone;
  method := TFhirObservation(oSource).method.Clone;
  specimen := TFhirObservation(oSource).specimen.Clone;
  device := TFhirObservation(oSource).device.Clone;
  if (TFhirObservation(oSource).FReferenceRangeList = nil) then
  begin
    FReferenceRangeList.free;
    FReferenceRangeList := nil;
  end
  else
  begin
    if FReferenceRangeList = nil then
      FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
    FReferenceRangeList.Assign(TFhirObservation(oSource).FReferenceRangeList);
  end;
  if (TFhirObservation(oSource).FHasMemberList = nil) then
  begin
    FHasMemberList.free;
    FHasMemberList := nil;
  end
  else
  begin
    if FHasMemberList = nil then
      FHasMemberList := TFhirReferenceList.Create;
    FHasMemberList.Assign(TFhirObservation(oSource).FHasMemberList);
  end;
  if (TFhirObservation(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirReferenceList.Create;
    FDerivedFromList.Assign(TFhirObservation(oSource).FDerivedFromList);
  end;
  if (TFhirObservation(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirObservationComponentList.Create;
    FComponentList.Assign(TFhirObservation(oSource).FComponentList);
  end;
end;

function TFhirObservation.GetResourceType : TFhirResourceType;
begin
  result := frtObservation;
end;

procedure TFhirObservation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'effective[x]') or (child_name = 'effective') Then
     list.add(self.link, 'effective[x]', FEffective.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'dataAbsentReason') Then
     list.add(self.link, 'dataAbsentReason', FDataAbsentReason.Link);
  if (child_name = 'interpretation') Then
    list.addAll(self, 'interpretation', FInterpretationList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'specimen') Then
     list.add(self.link, 'specimen', FSpecimen.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'referenceRange') Then
    list.addAll(self, 'referenceRange', FReferenceRangeList);
  if (child_name = 'hasMember') Then
    list.addAll(self, 'hasMember', FHasMemberList);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
end;

procedure TFhirObservation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', true, TFhirReference, FFocusList.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'effective[x]', 'dateTime|Period|Timing|instant', false, TFhirDataType, FEffective.Link));
  oList.add(TFHIRProperty.create(self, 'issued', 'instant', false, TFhirInstant, FIssued.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', true, TFhirReference, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|SampledData|time|dateTime|Period', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'dataAbsentReason', 'CodeableConcept', false, TFhirCodeableConcept, FDataAbsentReason.Link));
  oList.add(TFHIRProperty.create(self, 'interpretation', 'CodeableConcept', true, TFhirCodeableConcept, FInterpretationList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', false, TFhirReference, FSpecimen.Link));
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link));
  oList.add(TFHIRProperty.create(self, 'referenceRange', 'BackboneElement', true, TFhirObservationReferenceRange, FReferenceRangeList.Link));
  oList.add(TFHIRProperty.create(self, 'hasMember', 'Reference', true, TFhirReference, FHasMemberList.Link));
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'Reference', true, TFhirReference, FDerivedFromList.Link));
  oList.add(TFHIRProperty.create(self, 'component', 'BackboneElement', true, TFhirObservationComponent, FComponentList.Link));
end;

function TFhirObservation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period', 'Timing', 'Instant'])) then
  begin
    Effective := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'dataAbsentReason') then
  begin
    DataAbsentReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'interpretation') then
  begin
    InterpretationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    Specimen := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'referenceRange') then
  begin
    ReferenceRangeList.add(propValue as TFhirObservationReferenceRange);
    result := propValue;
  end
  else if (propName = 'hasMember') then
  begin
    HasMemberList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirObservationComponent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirObservation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'interpretation') then InterpretationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'referenceRange') then ReferenceRangeList.insertItem(index, propValue as TFhirObservationReferenceRange)
  else if (propName = 'hasMember') then HasMemberList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirObservationComponent)
  else inherited;
end;

function TFhirObservation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[ObservationStatusNull], CODES_TFhirObservationStatusEnum[ObservationStatusNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'focus') then result := FocusList.new()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period', 'Timing', 'Instant'])) then raise EFHIRException.create('Cannot make property Effective')
  else if (propName = 'issued') then result := TFhirInstant.create()
  else if (propName = 'performer') then result := PerformerList.new()
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'dataAbsentReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'interpretation') then result := InterpretationList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create()
  else if (propName = 'method') then result := TFhirCodeableConcept.create()
  else if (propName = 'specimen') then result := TFhirReference.create()
  else if (propName = 'device') then result := TFhirReference.create()
  else if (propName = 'referenceRange') then result := ReferenceRangeList.new()
  else if (propName = 'hasMember') then result := HasMemberList.new()
  else if (propName = 'derivedFrom') then result := DerivedFromList.new()
  else if (propName = 'component') then result := ComponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirObservation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'effective[x]') then result := 'dateTime|Period|Timing|instant'
  else if (propName = 'issued') then result := 'instant'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'value[x]') then result := 'Quantity|CodeableConcept|string|boolean|integer|Range|Ratio|SampledData|time|dateTime|Period'
  else if (propName = 'dataAbsentReason') then result := 'CodeableConcept'
  else if (propName = 'interpretation') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'referenceRange') then result := 'BackboneElement'
  else if (propName = 'hasMember') then result := 'Reference'
  else if (propName = 'derivedFrom') then result := 'Reference'
  else if (propName = 'component') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirObservation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value)
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period', 'Timing', 'Instant'])) then EffectiveElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period'])) then ValueElement := nil
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := nil
  else if (propName = 'interpretation') then deletePropertyValue('interpretation', InterpretationList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'specimen') then SpecimenElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'referenceRange') then deletePropertyValue('referenceRange', ReferenceRangeList, value)
  else if (propName = 'hasMember') then deletePropertyValue('hasMember', HasMemberList, value)
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value)
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirObservation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new)
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'effective', ['DateTime', 'Period', 'Timing', 'Instant'])) then EffectiveElement := new as TFhirDataType
  else if (propName = 'issued') then IssuedElement := asInstant(new)
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (isMatchingName(propName, 'value', ['Quantity', 'CodeableConcept', 'String', 'Boolean', 'Integer', 'Range', 'Ratio', 'SampledData', 'Time', 'DateTime', 'Period'])) then ValueElement := new as TFhirDataType
  else if (propName = 'dataAbsentReason') then DataAbsentReasonElement := new as TFhirCodeableConcept
  else if (propName = 'interpretation') then replacePropertyValue('interpretation', InterpretationList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else if (propName = 'specimen') then SpecimenElement := new as TFhirReference
  else if (propName = 'device') then DeviceElement := new as TFhirReference
  else if (propName = 'referenceRange') then replacePropertyValue('referenceRange', ReferenceRangeList, existing, new)
  else if (propName = 'hasMember') then replacePropertyValue('hasMember', HasMemberList, existing, new)
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new)
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirObservation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'focus') then FocusList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'interpretation') then InterpretationList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'referenceRange') then ReferenceRangeList.move(source, destination)
  else if (propName = 'hasMember') then HasMemberList.move(source, destination)
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination)
  else if (propName = 'component') then ComponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirObservation.fhirType : string;
begin
  result := 'Observation';
end;

function TFhirObservation.Link : TFhirObservation;
begin
  result := TFhirObservation(inherited Link);
end;

function TFhirObservation.Clone : TFhirObservation;
begin
  result := TFhirObservation(inherited Clone);
end;

function TFhirObservation.equals(other : TObject) : boolean; 
var
  o : TFhirObservation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirObservation)) then
    result := false
  else
  begin
    o := TFhirObservation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(focusList, o.focusList, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(effectiveElement, o.effectiveElement, true) and 
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(valueElement, o.valueElement, true) and compareDeep(dataAbsentReasonElement, o.dataAbsentReasonElement, true) and 
      compareDeep(interpretationList, o.interpretationList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(bodySiteElement, o.bodySiteElement, true) and compareDeep(methodElement, o.methodElement, true) and 
      compareDeep(specimenElement, o.specimenElement, true) and compareDeep(deviceElement, o.deviceElement, true) and 
      compareDeep(referenceRangeList, o.referenceRangeList, true) and compareDeep(hasMemberList, o.hasMemberList, true) and 
      compareDeep(derivedFromList, o.derivedFromList, true) and compareDeep(componentList, o.componentList, true);
  end;
end;

function TFhirObservation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FcategoryList) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FfocusList) and isEmptyProp(FEncounter) and isEmptyProp(FEffective) and isEmptyProp(FIssued) and isEmptyProp(FperformerList) and isEmptyProp(FValue) and isEmptyProp(FDataAbsentReason) and isEmptyProp(FinterpretationList) and isEmptyProp(FnoteList) and isEmptyProp(FBodySite) and isEmptyProp(FMethod) and isEmptyProp(FSpecimen) and isEmptyProp(FDevice) and isEmptyProp(FreferenceRangeList) and isEmptyProp(FhasMemberList) and isEmptyProp(FderivedFromList) and isEmptyProp(FcomponentList);
end;

procedure TFhirObservation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('focus');
  fields.add('encounter');
  fields.add('effective[x]');
  fields.add('issued');
  fields.add('performer');
  fields.add('value[x]');
  fields.add('dataAbsentReason');
  fields.add('interpretation');
  fields.add('note');
  fields.add('bodySite');
  fields.add('method');
  fields.add('specimen');
  fields.add('device');
  fields.add('referenceRange');
  fields.add('hasMember');
  fields.add('derivedFrom');
  fields.add('component');
end;

function TFhirObservation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FFocusList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FInterpretationList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FReferenceRangeList.sizeInBytes(magic));
  inc(result, FHasMemberList.sizeInBytes(magic));
  inc(result, FDerivedFromList.sizeInBytes(magic));
  inc(result, FComponentList.sizeInBytes(magic));
end;

function TFhirObservation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirObservation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirObservation.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirObservation.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirObservation.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirObservation.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirObservation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirObservation.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

procedure TFhirObservation.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

function TFhirObservation.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirObservation.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirObservation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirObservation.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

function TFhirObservation.GetFocusList : TFhirReferenceList;
begin
  if FFocusList = nil then
    FFocusList := TFhirReferenceList.Create;
  result := FFocusList;
end;

function TFhirObservation.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

procedure TFhirObservation.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirObservation.SetEffective(value : TFhirDataType);
begin
  FEffective.free;
  FEffective := value;
end;

procedure TFhirObservation.SetIssued(value : TFhirInstant);
begin
  FIssued.free;
  FIssued := value;
end;

function TFhirObservation.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirObservation.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirInstant.create;
  FIssued.value := value
end;

function TFhirObservation.GetPerformerList : TFhirReferenceList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList.Create;
  result := FPerformerList;
end;

function TFhirObservation.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirObservation.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirObservation.SetDataAbsentReason(value : TFhirCodeableConcept);
begin
  FDataAbsentReason.free;
  FDataAbsentReason := value;
end;

function TFhirObservation.GetInterpretationList : TFhirCodeableConceptList;
begin
  if FInterpretationList = nil then
    FInterpretationList := TFhirCodeableConceptList.Create;
  result := FInterpretationList;
end;

function TFhirObservation.GetHasInterpretationList : boolean;
begin
  result := (FInterpretationList <> nil) and (FInterpretationList.count > 0);
end;

function TFhirObservation.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirObservation.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirObservation.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

procedure TFhirObservation.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

procedure TFhirObservation.SetSpecimen(value : TFhirReference);
begin
  FSpecimen.free;
  FSpecimen := value;
end;

procedure TFhirObservation.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value;
end;

function TFhirObservation.GetReferenceRangeList : TFhirObservationReferenceRangeList;
begin
  if FReferenceRangeList = nil then
    FReferenceRangeList := TFhirObservationReferenceRangeList.Create;
  result := FReferenceRangeList;
end;

function TFhirObservation.GetHasReferenceRangeList : boolean;
begin
  result := (FReferenceRangeList <> nil) and (FReferenceRangeList.count > 0);
end;

function TFhirObservation.GetHasMemberList : TFhirReferenceList;
begin
  if FHasMemberList = nil then
    FHasMemberList := TFhirReferenceList.Create;
  result := FHasMemberList;
end;

function TFhirObservation.GetHasHasMemberList : boolean;
begin
  result := (FHasMemberList <> nil) and (FHasMemberList.count > 0);
end;

function TFhirObservation.GetDerivedFromList : TFhirReferenceList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirReferenceList.Create;
  result := FDerivedFromList;
end;

function TFhirObservation.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

function TFhirObservation.GetComponentList : TFhirObservationComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirObservationComponentList.Create;
  result := FComponentList;
end;

function TFhirObservation.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

{ TFhirObservationListEnumerator }

constructor TFhirObservationListEnumerator.Create(list : TFhirObservationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirObservationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirObservationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirObservationListEnumerator.GetCurrent : TFhirObservation;
begin
  Result := FList[FIndex];
end;

function TFhirObservationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirObservationList }

function TFhirObservationList.AddItem(value: TFhirObservation): TFhirObservation;
begin
  assert(value.ClassName = 'TFhirObservation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirObservation');
  add(value);
  result := value;
end;

function TFhirObservationList.Append: TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationList.ClearItems;
begin
  Clear;
end;

function TFhirObservationList.GetEnumerator : TFhirObservationListEnumerator;
begin
  result := TFhirObservationListEnumerator.Create(self.link);
end;

function TFhirObservationList.Clone: TFhirObservationList;
begin
  result := TFhirObservationList(inherited Clone);
end;

function TFhirObservationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirObservationList.GetItemN(index: Integer): TFhirObservation;
begin
  result := TFhirObservation(ObjectByIndex[index]);
end;

function TFhirObservationList.ItemClass: TFslObjectClass;
begin
  result := TFhirObservation;
end;
function TFhirObservationList.IndexOf(value: TFhirObservation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirObservationList.Insert(index: Integer): TFhirObservation;
begin
  result := TFhirObservation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirObservationList.InsertItem(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  Inherited Insert(index, value);
end;

function TFhirObservationList.Item(index: Integer): TFhirObservation;
begin
  result := TFhirObservation(ObjectByIndex[index]);
end;

function TFhirObservationList.Link: TFhirObservationList;
begin
  result := TFhirObservationList(inherited Link);
end;

procedure TFhirObservationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirObservationList.SetItemByIndex(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  FhirObservations[index] := value;
end;

procedure TFhirObservationList.SetItemN(index: Integer; value: TFhirObservation);
begin
  assert(value is TFhirObservation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OBSERVATION}
{$IFDEF FHIR_PROCEDURE}
{ TFhirProcedurePerformer }

constructor TFhirProcedurePerformer.Create;
begin
  inherited;
end;

destructor TFhirProcedurePerformer.Destroy;
begin
  FFunction_.free;
  FActor.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirProcedurePerformer.Assign(oSource : TFslObject);
begin
  inherited;
  function_ := TFhirProcedurePerformer(oSource).function_.Clone;
  actor := TFhirProcedurePerformer(oSource).actor.Clone;
  onBehalfOf := TFhirProcedurePerformer(oSource).onBehalfOf.Clone;
end;

procedure TFhirProcedurePerformer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'function') Then
     list.add(self.link, 'function', FFunction_.Link);
  if (child_name = 'actor') Then
     list.add(self.link, 'actor', FActor.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirProcedurePerformer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'function', 'CodeableConcept', false, TFhirCodeableConcept, FFunction_.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'Reference', false, TFhirReference, FActor.Link));
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference', false, TFhirReference, FOnBehalfOf.Link));
end;

function TFhirProcedurePerformer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'function') then
  begin
    Function_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    Actor := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedurePerformer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcedurePerformer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'function') then result := TFhirCodeableConcept.create()
  else if (propName = 'actor') then result := TFhirReference.create()
  else if (propName = 'onBehalfOf') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedurePerformer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'function') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedurePerformer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := nil
  else if (propName = 'actor') then ActorElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedurePerformer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'function') then Function_Element := new as TFhirCodeableConcept
  else if (propName = 'actor') then ActorElement := new as TFhirReference
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedurePerformer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedurePerformer.fhirType : string;
begin
  result := 'Procedure.performer';
end;

function TFhirProcedurePerformer.Link : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Link);
end;

function TFhirProcedurePerformer.Clone : TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(inherited Clone);
end;

function TFhirProcedurePerformer.equals(other : TObject) : boolean; 
var
  o : TFhirProcedurePerformer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedurePerformer)) then
    result := false
  else
  begin
    o := TFhirProcedurePerformer(other);
    result := compareDeep(function_Element, o.function_Element, true) and compareDeep(actorElement, o.actorElement, true) and 
      compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirProcedurePerformer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFunction_) and isEmptyProp(FActor) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirProcedurePerformer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('function');
  fields.add('actor');
  fields.add('onBehalfOf');
end;

function TFhirProcedurePerformer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirProcedurePerformer.SetFunction_(value : TFhirCodeableConcept);
begin
  FFunction_.free;
  FFunction_ := value;
end;

procedure TFhirProcedurePerformer.SetActor(value : TFhirReference);
begin
  FActor.free;
  FActor := value;
end;

procedure TFhirProcedurePerformer.SetOnBehalfOf(value : TFhirReference);
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

{ TFhirProcedurePerformerListEnumerator }

constructor TFhirProcedurePerformerListEnumerator.Create(list : TFhirProcedurePerformerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedurePerformerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedurePerformerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedurePerformerListEnumerator.GetCurrent : TFhirProcedurePerformer;
begin
  Result := FList[FIndex];
end;

function TFhirProcedurePerformerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirProcedurePerformerList }

function TFhirProcedurePerformerList.AddItem(value: TFhirProcedurePerformer): TFhirProcedurePerformer;
begin
  assert(value.ClassName = 'TFhirProcedurePerformer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedurePerformer');
  add(value);
  result := value;
end;

function TFhirProcedurePerformerList.Append: TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedurePerformerList.ClearItems;
begin
  Clear;
end;

function TFhirProcedurePerformerList.GetEnumerator : TFhirProcedurePerformerListEnumerator;
begin
  result := TFhirProcedurePerformerListEnumerator.Create(self.link);
end;

function TFhirProcedurePerformerList.Clone: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Clone);
end;

function TFhirProcedurePerformerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedurePerformerList.GetItemN(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedurePerformer;
end;
function TFhirProcedurePerformerList.IndexOf(value: TFhirProcedurePerformer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedurePerformerList.Insert(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedurePerformerList.InsertItem(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  Inherited Insert(index, value);
end;

function TFhirProcedurePerformerList.Item(index: Integer): TFhirProcedurePerformer;
begin
  result := TFhirProcedurePerformer(ObjectByIndex[index]);
end;

function TFhirProcedurePerformerList.Link: TFhirProcedurePerformerList;
begin
  result := TFhirProcedurePerformerList(inherited Link);
end;

procedure TFhirProcedurePerformerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedurePerformerList.SetItemByIndex(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  FhirProcedurePerformers[index] := value;
end;

procedure TFhirProcedurePerformerList.SetItemN(index: Integer; value: TFhirProcedurePerformer);
begin
  assert(value is TFhirProcedurePerformer);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedureFocalDevice }

constructor TFhirProcedureFocalDevice.Create;
begin
  inherited;
end;

destructor TFhirProcedureFocalDevice.Destroy;
begin
  FAction.free;
  FManipulated.free;
  inherited;
end;

procedure TFhirProcedureFocalDevice.Assign(oSource : TFslObject);
begin
  inherited;
  action := TFhirProcedureFocalDevice(oSource).action.Clone;
  manipulated := TFhirProcedureFocalDevice(oSource).manipulated.Clone;
end;

procedure TFhirProcedureFocalDevice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'manipulated') Then
     list.add(self.link, 'manipulated', FManipulated.Link);
end;

procedure TFhirProcedureFocalDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', false, TFhirCodeableConcept, FAction.Link));
  oList.add(TFHIRProperty.create(self, 'manipulated', 'Reference', false, TFhirReference, FManipulated.Link));
end;

function TFhirProcedureFocalDevice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    Action := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'manipulated') then
  begin
    Manipulated := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedureFocalDevice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirProcedureFocalDevice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := TFhirCodeableConcept.create()
  else if (propName = 'manipulated') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedureFocalDevice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'manipulated') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedureFocalDevice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := nil
  else if (propName = 'manipulated') then ManipulatedElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedureFocalDevice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then ActionElement := new as TFhirCodeableConcept
  else if (propName = 'manipulated') then ManipulatedElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedureFocalDevice.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedureFocalDevice.fhirType : string;
begin
  result := 'Procedure.focalDevice';
end;

function TFhirProcedureFocalDevice.Link : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(inherited Link);
end;

function TFhirProcedureFocalDevice.Clone : TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(inherited Clone);
end;

function TFhirProcedureFocalDevice.equals(other : TObject) : boolean; 
var
  o : TFhirProcedureFocalDevice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedureFocalDevice)) then
    result := false
  else
  begin
    o := TFhirProcedureFocalDevice(other);
    result := compareDeep(actionElement, o.actionElement, true) and compareDeep(manipulatedElement, o.manipulatedElement, true);
  end;
end;

function TFhirProcedureFocalDevice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAction) and isEmptyProp(FManipulated);
end;

procedure TFhirProcedureFocalDevice.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('action');
  fields.add('manipulated');
end;

function TFhirProcedureFocalDevice.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirProcedureFocalDevice.SetAction(value : TFhirCodeableConcept);
begin
  FAction.free;
  FAction := value;
end;

procedure TFhirProcedureFocalDevice.SetManipulated(value : TFhirReference);
begin
  FManipulated.free;
  FManipulated := value;
end;

{ TFhirProcedureFocalDeviceListEnumerator }

constructor TFhirProcedureFocalDeviceListEnumerator.Create(list : TFhirProcedureFocalDeviceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureFocalDeviceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureFocalDeviceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureFocalDeviceListEnumerator.GetCurrent : TFhirProcedureFocalDevice;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureFocalDeviceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirProcedureFocalDeviceList }

function TFhirProcedureFocalDeviceList.AddItem(value: TFhirProcedureFocalDevice): TFhirProcedureFocalDevice;
begin
  assert(value.ClassName = 'TFhirProcedureFocalDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedureFocalDevice');
  add(value);
  result := value;
end;

function TFhirProcedureFocalDeviceList.Append: TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureFocalDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureFocalDeviceList.GetEnumerator : TFhirProcedureFocalDeviceListEnumerator;
begin
  result := TFhirProcedureFocalDeviceListEnumerator.Create(self.link);
end;

function TFhirProcedureFocalDeviceList.Clone: TFhirProcedureFocalDeviceList;
begin
  result := TFhirProcedureFocalDeviceList(inherited Clone);
end;

function TFhirProcedureFocalDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureFocalDeviceList.GetItemN(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(ObjectByIndex[index]);
end;

function TFhirProcedureFocalDeviceList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedureFocalDevice;
end;
function TFhirProcedureFocalDeviceList.IndexOf(value: TFhirProcedureFocalDevice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureFocalDeviceList.Insert(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureFocalDeviceList.InsertItem(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  Inherited Insert(index, value);
end;

function TFhirProcedureFocalDeviceList.Item(index: Integer): TFhirProcedureFocalDevice;
begin
  result := TFhirProcedureFocalDevice(ObjectByIndex[index]);
end;

function TFhirProcedureFocalDeviceList.Link: TFhirProcedureFocalDeviceList;
begin
  result := TFhirProcedureFocalDeviceList(inherited Link);
end;

procedure TFhirProcedureFocalDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureFocalDeviceList.SetItemByIndex(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  FhirProcedureFocalDevices[index] := value;
end;

procedure TFhirProcedureFocalDeviceList.SetItemN(index: Integer; value: TFhirProcedureFocalDevice);
begin
  assert(value is TFhirProcedureFocalDevice);
  ObjectByIndex[index] := value;
end;

{ TFhirProcedure }

constructor TFhirProcedure.Create;
begin
  inherited;
end;

destructor TFhirProcedure.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReason.free;
  FCategory.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FPerformed.free;
  FRecorder.free;
  FAsserter.free;
  FPerformerList.Free;
  FLocation.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FBodySiteList.Free;
  FOutcome.free;
  FReportList.Free;
  FComplicationList.Free;
  FComplicationDetailList.Free;
  FFollowUpList.Free;
  FNoteList.Free;
  FFocalDeviceList.Free;
  FUsedReferenceList.Free;
  FUsedCodeList.Free;
  inherited;
end;

procedure TFhirProcedure.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProcedure(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirProcedure(oSource).FIdentifierList);
  end;
  if (TFhirProcedure(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirProcedure(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirProcedure(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirProcedure(oSource).FInstantiatesUriList);
  end;
  if (TFhirProcedure(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirProcedure(oSource).FBasedOnList);
  end;
  if (TFhirProcedure(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirProcedure(oSource).FPartOfList);
  end;
  statusElement := TFhirProcedure(oSource).statusElement.Clone;
  statusReason := TFhirProcedure(oSource).statusReason.Clone;
  category := TFhirProcedure(oSource).category.Clone;
  code := TFhirProcedure(oSource).code.Clone;
  subject := TFhirProcedure(oSource).subject.Clone;
  encounter := TFhirProcedure(oSource).encounter.Clone;
  performed := TFhirProcedure(oSource).performed.Clone;
  recorder := TFhirProcedure(oSource).recorder.Clone;
  asserter := TFhirProcedure(oSource).asserter.Clone;
  if (TFhirProcedure(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirProcedurePerformerList.Create;
    FPerformerList.Assign(TFhirProcedure(oSource).FPerformerList);
  end;
  location := TFhirProcedure(oSource).location.Clone;
  if (TFhirProcedure(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirProcedure(oSource).FReasonCodeList);
  end;
  if (TFhirProcedure(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirProcedure(oSource).FReasonReferenceList);
  end;
  if (TFhirProcedure(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirProcedure(oSource).FBodySiteList);
  end;
  outcome := TFhirProcedure(oSource).outcome.Clone;
  if (TFhirProcedure(oSource).FReportList = nil) then
  begin
    FReportList.free;
    FReportList := nil;
  end
  else
  begin
    if FReportList = nil then
      FReportList := TFhirReferenceList.Create;
    FReportList.Assign(TFhirProcedure(oSource).FReportList);
  end;
  if (TFhirProcedure(oSource).FComplicationList = nil) then
  begin
    FComplicationList.free;
    FComplicationList := nil;
  end
  else
  begin
    if FComplicationList = nil then
      FComplicationList := TFhirCodeableConceptList.Create;
    FComplicationList.Assign(TFhirProcedure(oSource).FComplicationList);
  end;
  if (TFhirProcedure(oSource).FComplicationDetailList = nil) then
  begin
    FComplicationDetailList.free;
    FComplicationDetailList := nil;
  end
  else
  begin
    if FComplicationDetailList = nil then
      FComplicationDetailList := TFhirReferenceList.Create;
    FComplicationDetailList.Assign(TFhirProcedure(oSource).FComplicationDetailList);
  end;
  if (TFhirProcedure(oSource).FFollowUpList = nil) then
  begin
    FFollowUpList.free;
    FFollowUpList := nil;
  end
  else
  begin
    if FFollowUpList = nil then
      FFollowUpList := TFhirCodeableConceptList.Create;
    FFollowUpList.Assign(TFhirProcedure(oSource).FFollowUpList);
  end;
  if (TFhirProcedure(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirProcedure(oSource).FNoteList);
  end;
  if (TFhirProcedure(oSource).FFocalDeviceList = nil) then
  begin
    FFocalDeviceList.free;
    FFocalDeviceList := nil;
  end
  else
  begin
    if FFocalDeviceList = nil then
      FFocalDeviceList := TFhirProcedureFocalDeviceList.Create;
    FFocalDeviceList.Assign(TFhirProcedure(oSource).FFocalDeviceList);
  end;
  if (TFhirProcedure(oSource).FUsedReferenceList = nil) then
  begin
    FUsedReferenceList.free;
    FUsedReferenceList := nil;
  end
  else
  begin
    if FUsedReferenceList = nil then
      FUsedReferenceList := TFhirReferenceList.Create;
    FUsedReferenceList.Assign(TFhirProcedure(oSource).FUsedReferenceList);
  end;
  if (TFhirProcedure(oSource).FUsedCodeList = nil) then
  begin
    FUsedCodeList.free;
    FUsedCodeList := nil;
  end
  else
  begin
    if FUsedCodeList = nil then
      FUsedCodeList := TFhirCodeableConceptList.Create;
    FUsedCodeList.Assign(TFhirProcedure(oSource).FUsedCodeList);
  end;
end;

function TFhirProcedure.GetResourceType : TFhirResourceType;
begin
  result := frtProcedure;
end;

procedure TFhirProcedure.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'performed[x]') or (child_name = 'performed') Then
     list.add(self.link, 'performed[x]', FPerformed.Link);
  if (child_name = 'recorder') Then
     list.add(self.link, 'recorder', FRecorder.Link);
  if (child_name = 'asserter') Then
     list.add(self.link, 'asserter', FAsserter.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'report') Then
    list.addAll(self, 'report', FReportList);
  if (child_name = 'complication') Then
    list.addAll(self, 'complication', FComplicationList);
  if (child_name = 'complicationDetail') Then
    list.addAll(self, 'complicationDetail', FComplicationDetailList);
  if (child_name = 'followUp') Then
    list.addAll(self, 'followUp', FFollowUpList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'focalDevice') Then
    list.addAll(self, 'focalDevice', FFocalDeviceList);
  if (child_name = 'usedReference') Then
    list.addAll(self, 'usedReference', FUsedReferenceList);
  if (child_name = 'usedCode') Then
    list.addAll(self, 'usedCode', FUsedCodeList);
end;

procedure TFhirProcedure.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'performed[x]', 'dateTime|Period|string|Age|Range', false, TFhirDataType, FPerformed.Link));
  oList.add(TFHIRProperty.create(self, 'recorder', 'Reference', false, TFhirReference, FRecorder.Link));
  oList.add(TFHIRProperty.create(self, 'asserter', 'Reference', false, TFhirReference, FAsserter.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'BackboneElement', true, TFhirProcedurePerformer, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'report', 'Reference', true, TFhirReference, FReportList.Link));
  oList.add(TFHIRProperty.create(self, 'complication', 'CodeableConcept', true, TFhirCodeableConcept, FComplicationList.Link));
  oList.add(TFHIRProperty.create(self, 'complicationDetail', 'Reference', true, TFhirReference, FComplicationDetailList.Link));
  oList.add(TFHIRProperty.create(self, 'followUp', 'CodeableConcept', true, TFhirCodeableConcept, FFollowUpList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'focalDevice', 'BackboneElement', true, TFhirProcedureFocalDevice, FFocalDeviceList.Link));
  oList.add(TFHIRProperty.create(self, 'usedReference', 'Reference', true, TFhirReference, FUsedReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'usedCode', 'CodeableConcept', true, TFhirCodeableConcept, FUsedCodeList.Link));
end;

function TFhirProcedure.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period', 'String', 'Age', 'Range'])) then
  begin
    Performed := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'recorder') then
  begin
    Recorder := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'asserter') then
  begin
    Asserter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirProcedurePerformer);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'report') then
  begin
    ReportList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'complication') then
  begin
    ComplicationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'complicationDetail') then
  begin
    ComplicationDetailList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'followUp') then
  begin
    FollowUpList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'focalDevice') then
  begin
    FocalDeviceList.add(propValue as TFhirProcedureFocalDevice);
    result := propValue;
  end
  else if (propName = 'usedReference') then
  begin
    UsedReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'usedCode') then
  begin
    UsedCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProcedure.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirProcedurePerformer)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'report') then ReportList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'complication') then ComplicationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'complicationDetail') then ComplicationDetailList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'followUp') then FollowUpList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'focalDevice') then FocalDeviceList.insertItem(index, propValue as TFhirProcedureFocalDevice)
  else if (propName = 'usedReference') then UsedReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'usedCode') then UsedCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirProcedure.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[EventStatusNull], CODES_TFhirEventStatusEnum[EventStatusNull]) 
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period', 'String', 'Age', 'Range'])) then raise EFHIRException.create('Cannot make property Performed')
  else if (propName = 'recorder') then result := TFhirReference.create()
  else if (propName = 'asserter') then result := TFhirReference.create()
  else if (propName = 'performer') then result := PerformerList.new()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'bodySite') then result := BodySiteList.new()
  else if (propName = 'outcome') then result := TFhirCodeableConcept.create()
  else if (propName = 'report') then result := ReportList.new()
  else if (propName = 'complication') then result := ComplicationList.new()
  else if (propName = 'complicationDetail') then result := ComplicationDetailList.new()
  else if (propName = 'followUp') then result := FollowUpList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'focalDevice') then result := FocalDeviceList.new()
  else if (propName = 'usedReference') then result := UsedReferenceList.new()
  else if (propName = 'usedCode') then result := UsedCodeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirProcedure.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'performed[x]') then result := 'dateTime|Period|string|Age|Range'
  else if (propName = 'recorder') then result := 'Reference'
  else if (propName = 'asserter') then result := 'Reference'
  else if (propName = 'performer') then result := 'BackboneElement'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'report') then result := 'Reference'
  else if (propName = 'complication') then result := 'CodeableConcept'
  else if (propName = 'complicationDetail') then result := 'Reference'
  else if (propName = 'followUp') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'focalDevice') then result := 'BackboneElement'
  else if (propName = 'usedReference') then result := 'Reference'
  else if (propName = 'usedCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProcedure.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period', 'String', 'Age', 'Range'])) then PerformedElement := nil
  else if (propName = 'recorder') then RecorderElement := nil
  else if (propName = 'asserter') then AsserterElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value)
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'report') then deletePropertyValue('report', ReportList, value)
  else if (propName = 'complication') then deletePropertyValue('complication', ComplicationList, value)
  else if (propName = 'complicationDetail') then deletePropertyValue('complicationDetail', ComplicationDetailList, value)
  else if (propName = 'followUp') then deletePropertyValue('followUp', FollowUpList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'focalDevice') then deletePropertyValue('focalDevice', FocalDeviceList, value)
  else if (propName = 'usedReference') then deletePropertyValue('usedReference', UsedReferenceList, value)
  else if (propName = 'usedCode') then deletePropertyValue('usedCode', UsedCodeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProcedure.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, new)
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'performed', ['DateTime', 'Period', 'String', 'Age', 'Range'])) then PerformedElement := new as TFhirDataType
  else if (propName = 'recorder') then RecorderElement := new as TFhirReference
  else if (propName = 'asserter') then AsserterElement := new as TFhirReference
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new)
  else if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept
  else if (propName = 'report') then replacePropertyValue('report', ReportList, existing, new)
  else if (propName = 'complication') then replacePropertyValue('complication', ComplicationList, existing, new)
  else if (propName = 'complicationDetail') then replacePropertyValue('complicationDetail', ComplicationDetailList, existing, new)
  else if (propName = 'followUp') then replacePropertyValue('followUp', FollowUpList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'focalDevice') then replacePropertyValue('focalDevice', FocalDeviceList, existing, new)
  else if (propName = 'usedReference') then replacePropertyValue('usedReference', UsedReferenceList, existing, new)
  else if (propName = 'usedCode') then replacePropertyValue('usedCode', UsedCodeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProcedure.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'bodySite') then BodySiteList.move(source, destination)
  else if (propName = 'report') then ReportList.move(source, destination)
  else if (propName = 'complication') then ComplicationList.move(source, destination)
  else if (propName = 'complicationDetail') then ComplicationDetailList.move(source, destination)
  else if (propName = 'followUp') then FollowUpList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'focalDevice') then FocalDeviceList.move(source, destination)
  else if (propName = 'usedReference') then UsedReferenceList.move(source, destination)
  else if (propName = 'usedCode') then UsedCodeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProcedure.fhirType : string;
begin
  result := 'Procedure';
end;

function TFhirProcedure.Link : TFhirProcedure;
begin
  result := TFhirProcedure(inherited Link);
end;

function TFhirProcedure.Clone : TFhirProcedure;
begin
  result := TFhirProcedure(inherited Clone);
end;

function TFhirProcedure.equals(other : TObject) : boolean; 
var
  o : TFhirProcedure;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProcedure)) then
    result := false
  else
  begin
    o := TFhirProcedure(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonElement, o.statusReasonElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(performedElement, o.performedElement, true) and 
      compareDeep(recorderElement, o.recorderElement, true) and compareDeep(asserterElement, o.asserterElement, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(bodySiteList, o.bodySiteList, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(reportList, o.reportList, true) and compareDeep(complicationList, o.complicationList, true) and 
      compareDeep(complicationDetailList, o.complicationDetailList, true) and compareDeep(followUpList, o.followUpList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(focalDeviceList, o.focalDeviceList, true) and 
      compareDeep(usedReferenceList, o.usedReferenceList, true) and compareDeep(usedCodeList, o.usedCodeList, true);
  end;
end;

function TFhirProcedure.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FCategory) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FPerformed) and isEmptyProp(FRecorder) and isEmptyProp(FAsserter) and isEmptyProp(FperformerList) and isEmptyProp(FLocation) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FbodySiteList) and isEmptyProp(FOutcome) and isEmptyProp(FreportList) and isEmptyProp(FcomplicationList) and isEmptyProp(FcomplicationDetailList) and isEmptyProp(FfollowUpList) and isEmptyProp(FnoteList) and isEmptyProp(FfocalDeviceList) and isEmptyProp(FusedReferenceList) and isEmptyProp(FusedCodeList);
end;

procedure TFhirProcedure.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('category');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('performed[x]');
  fields.add('recorder');
  fields.add('asserter');
  fields.add('performer');
  fields.add('location');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('bodySite');
  fields.add('outcome');
  fields.add('report');
  fields.add('complication');
  fields.add('complicationDetail');
  fields.add('followUp');
  fields.add('note');
  fields.add('focalDevice');
  fields.add('usedReference');
  fields.add('usedCode');
end;

function TFhirProcedure.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FBodySiteList.sizeInBytes(magic));
  inc(result, FReportList.sizeInBytes(magic));
  inc(result, FComplicationList.sizeInBytes(magic));
  inc(result, FComplicationDetailList.sizeInBytes(magic));
  inc(result, FFollowUpList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FFocalDeviceList.sizeInBytes(magic));
  inc(result, FUsedReferenceList.sizeInBytes(magic));
  inc(result, FUsedCodeList.sizeInBytes(magic));
end;

function TFhirProcedure.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirProcedure.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirProcedure.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirProcedure.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirProcedure.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirProcedure.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirProcedure.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirProcedure.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirProcedure.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirProcedure.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirProcedure.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirProcedure.GetStatusST : TFhirEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEventStatusEnum(0)
  else
    result := TFhirEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEventStatusEnum, FStatus.value));
end;

procedure TFhirProcedure.SetStatusST(value : TFhirEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirEventStatusEnum[value], CODES_TFhirEventStatusEnum[value]);
end;

procedure TFhirProcedure.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

procedure TFhirProcedure.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirProcedure.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirProcedure.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirProcedure.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirProcedure.SetPerformed(value : TFhirDataType);
begin
  FPerformed.free;
  FPerformed := value;
end;

procedure TFhirProcedure.SetRecorder(value : TFhirReference);
begin
  FRecorder.free;
  FRecorder := value;
end;

procedure TFhirProcedure.SetAsserter(value : TFhirReference);
begin
  FAsserter.free;
  FAsserter := value;
end;

function TFhirProcedure.GetPerformerList : TFhirProcedurePerformerList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirProcedurePerformerList.Create;
  result := FPerformerList;
end;

function TFhirProcedure.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

procedure TFhirProcedure.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirProcedure.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirProcedure.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirProcedure.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirProcedure.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirProcedure.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

function TFhirProcedure.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

procedure TFhirProcedure.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirProcedure.GetReportList : TFhirReferenceList;
begin
  if FReportList = nil then
    FReportList := TFhirReferenceList.Create;
  result := FReportList;
end;

function TFhirProcedure.GetHasReportList : boolean;
begin
  result := (FReportList <> nil) and (FReportList.count > 0);
end;

function TFhirProcedure.GetComplicationList : TFhirCodeableConceptList;
begin
  if FComplicationList = nil then
    FComplicationList := TFhirCodeableConceptList.Create;
  result := FComplicationList;
end;

function TFhirProcedure.GetHasComplicationList : boolean;
begin
  result := (FComplicationList <> nil) and (FComplicationList.count > 0);
end;

function TFhirProcedure.GetComplicationDetailList : TFhirReferenceList;
begin
  if FComplicationDetailList = nil then
    FComplicationDetailList := TFhirReferenceList.Create;
  result := FComplicationDetailList;
end;

function TFhirProcedure.GetHasComplicationDetailList : boolean;
begin
  result := (FComplicationDetailList <> nil) and (FComplicationDetailList.count > 0);
end;

function TFhirProcedure.GetFollowUpList : TFhirCodeableConceptList;
begin
  if FFollowUpList = nil then
    FFollowUpList := TFhirCodeableConceptList.Create;
  result := FFollowUpList;
end;

function TFhirProcedure.GetHasFollowUpList : boolean;
begin
  result := (FFollowUpList <> nil) and (FFollowUpList.count > 0);
end;

function TFhirProcedure.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirProcedure.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirProcedure.GetFocalDeviceList : TFhirProcedureFocalDeviceList;
begin
  if FFocalDeviceList = nil then
    FFocalDeviceList := TFhirProcedureFocalDeviceList.Create;
  result := FFocalDeviceList;
end;

function TFhirProcedure.GetHasFocalDeviceList : boolean;
begin
  result := (FFocalDeviceList <> nil) and (FFocalDeviceList.count > 0);
end;

function TFhirProcedure.GetUsedReferenceList : TFhirReferenceList;
begin
  if FUsedReferenceList = nil then
    FUsedReferenceList := TFhirReferenceList.Create;
  result := FUsedReferenceList;
end;

function TFhirProcedure.GetHasUsedReferenceList : boolean;
begin
  result := (FUsedReferenceList <> nil) and (FUsedReferenceList.count > 0);
end;

function TFhirProcedure.GetUsedCodeList : TFhirCodeableConceptList;
begin
  if FUsedCodeList = nil then
    FUsedCodeList := TFhirCodeableConceptList.Create;
  result := FUsedCodeList;
end;

function TFhirProcedure.GetHasUsedCodeList : boolean;
begin
  result := (FUsedCodeList <> nil) and (FUsedCodeList.count > 0);
end;

{ TFhirProcedureListEnumerator }

constructor TFhirProcedureListEnumerator.Create(list : TFhirProcedureList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProcedureListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProcedureListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProcedureListEnumerator.GetCurrent : TFhirProcedure;
begin
  Result := FList[FIndex];
end;

function TFhirProcedureListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirProcedureList }

function TFhirProcedureList.AddItem(value: TFhirProcedure): TFhirProcedure;
begin
  assert(value.ClassName = 'TFhirProcedure', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProcedure');
  add(value);
  result := value;
end;

function TFhirProcedureList.Append: TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureList.ClearItems;
begin
  Clear;
end;

function TFhirProcedureList.GetEnumerator : TFhirProcedureListEnumerator;
begin
  result := TFhirProcedureListEnumerator.Create(self.link);
end;

function TFhirProcedureList.Clone: TFhirProcedureList;
begin
  result := TFhirProcedureList(inherited Clone);
end;

function TFhirProcedureList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProcedureList.GetItemN(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure(ObjectByIndex[index]);
end;

function TFhirProcedureList.ItemClass: TFslObjectClass;
begin
  result := TFhirProcedure;
end;
function TFhirProcedureList.IndexOf(value: TFhirProcedure): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProcedureList.Insert(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProcedureList.InsertItem(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  Inherited Insert(index, value);
end;

function TFhirProcedureList.Item(index: Integer): TFhirProcedure;
begin
  result := TFhirProcedure(ObjectByIndex[index]);
end;

function TFhirProcedureList.Link: TFhirProcedureList;
begin
  result := TFhirProcedureList(inherited Link);
end;

procedure TFhirProcedureList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProcedureList.SetItemByIndex(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  FhirProcedures[index] := value;
end;

procedure TFhirProcedureList.SetItemN(index: Integer; value: TFhirProcedure);
begin
  assert(value is TFhirProcedure);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROCEDURE}
{$IFDEF FHIR_RISKASSESSMENT}
{ TFhirRiskAssessmentPrediction }

constructor TFhirRiskAssessmentPrediction.Create;
begin
  inherited;
end;

destructor TFhirRiskAssessmentPrediction.Destroy;
begin
  FOutcome.free;
  FProbability.free;
  FQualitativeRisk.free;
  FRelativeRisk.free;
  FWhen.free;
  FRationale.free;
  inherited;
end;

procedure TFhirRiskAssessmentPrediction.Assign(oSource : TFslObject);
begin
  inherited;
  outcome := TFhirRiskAssessmentPrediction(oSource).outcome.Clone;
  probability := TFhirRiskAssessmentPrediction(oSource).probability.Clone;
  qualitativeRisk := TFhirRiskAssessmentPrediction(oSource).qualitativeRisk.Clone;
  relativeRiskElement := TFhirRiskAssessmentPrediction(oSource).relativeRiskElement.Clone;
  when := TFhirRiskAssessmentPrediction(oSource).when.Clone;
  rationaleElement := TFhirRiskAssessmentPrediction(oSource).rationaleElement.Clone;
end;

procedure TFhirRiskAssessmentPrediction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'probability[x]') or (child_name = 'probability') Then
     list.add(self.link, 'probability[x]', FProbability.Link);
  if (child_name = 'qualitativeRisk') Then
     list.add(self.link, 'qualitativeRisk', FQualitativeRisk.Link);
  if (child_name = 'relativeRisk') Then
     list.add(self.link, 'relativeRisk', FRelativeRisk.Link);
  if (child_name = 'when[x]') or (child_name = 'when') Then
     list.add(self.link, 'when[x]', FWhen.Link);
  if (child_name = 'rationale') Then
     list.add(self.link, 'rationale', FRationale.Link);
end;

procedure TFhirRiskAssessmentPrediction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'outcome', 'CodeableConcept', false, TFhirCodeableConcept, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'probability[x]', 'decimal|Range', false, TFhirDataType, FProbability.Link));
  oList.add(TFHIRProperty.create(self, 'qualitativeRisk', 'CodeableConcept', false, TFhirCodeableConcept, FQualitativeRisk.Link));
  oList.add(TFHIRProperty.create(self, 'relativeRisk', 'decimal', false, TFhirDecimal, FRelativeRisk.Link));
  oList.add(TFHIRProperty.create(self, 'when[x]', 'Period|Range', false, TFhirDataType, FWhen.Link));
  oList.add(TFHIRProperty.create(self, 'rationale', 'string', false, TFhirString, FRationale.Link));
end;

function TFhirRiskAssessmentPrediction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then
  begin
    Probability := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'qualitativeRisk') then
  begin
    QualitativeRisk := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'relativeRisk') then
  begin
    RelativeRiskElement := asDecimal(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then
  begin
    When := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'rationale') then
  begin
    RationaleElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskAssessmentPrediction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRiskAssessmentPrediction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'outcome') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then raise EFHIRException.create('Cannot make property Probability')
  else if (propName = 'qualitativeRisk') then result := TFhirCodeableConcept.create()
  else if (propName = 'relativeRisk') then result := TFhirDecimal.create()
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then raise EFHIRException.create('Cannot make property When')
  else if (propName = 'rationale') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskAssessmentPrediction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'outcome') then result := 'CodeableConcept'
  else if (propName = 'probability[x]') then result := 'decimal|Range'
  else if (propName = 'qualitativeRisk') then result := 'CodeableConcept'
  else if (propName = 'relativeRisk') then result := 'decimal'
  else if (propName = 'when[x]') then result := 'Period|Range'
  else if (propName = 'rationale') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskAssessmentPrediction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'outcome') then OutcomeElement := nil
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then ProbabilityElement := nil
  else if (propName = 'qualitativeRisk') then QualitativeRiskElement := nil
  else if (propName = 'relativeRisk') then RelativeRiskElement := nil
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then WhenElement := nil
  else if (propName = 'rationale') then RationaleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskAssessmentPrediction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'outcome') then OutcomeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'probability', ['Decimal', 'Range'])) then ProbabilityElement := new as TFhirDataType
  else if (propName = 'qualitativeRisk') then QualitativeRiskElement := new as TFhirCodeableConcept
  else if (propName = 'relativeRisk') then RelativeRiskElement := asDecimal(new)
  else if (isMatchingName(propName, 'when', ['Period', 'Range'])) then WhenElement := new as TFhirDataType
  else if (propName = 'rationale') then RationaleElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskAssessmentPrediction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskAssessmentPrediction.fhirType : string;
begin
  result := 'RiskAssessment.prediction';
end;

function TFhirRiskAssessmentPrediction.Link : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(inherited Link);
end;

function TFhirRiskAssessmentPrediction.Clone : TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(inherited Clone);
end;

function TFhirRiskAssessmentPrediction.equals(other : TObject) : boolean; 
var
  o : TFhirRiskAssessmentPrediction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskAssessmentPrediction)) then
    result := false
  else
  begin
    o := TFhirRiskAssessmentPrediction(other);
    result := compareDeep(outcomeElement, o.outcomeElement, true) and compareDeep(probabilityElement, o.probabilityElement, true) and 
      compareDeep(qualitativeRiskElement, o.qualitativeRiskElement, true) and compareDeep(relativeRiskElement, o.relativeRiskElement, true) and 
      compareDeep(whenElement, o.whenElement, true) and compareDeep(rationaleElement, o.rationaleElement, true);
  end;
end;

function TFhirRiskAssessmentPrediction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOutcome) and isEmptyProp(FProbability) and isEmptyProp(FQualitativeRisk) and isEmptyProp(FRelativeRisk) and isEmptyProp(FWhen) and isEmptyProp(FRationale);
end;

procedure TFhirRiskAssessmentPrediction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('outcome');
  fields.add('probability[x]');
  fields.add('qualitativeRisk');
  fields.add('relativeRisk');
  fields.add('when[x]');
  fields.add('rationale');
end;

function TFhirRiskAssessmentPrediction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRiskAssessmentPrediction.SetOutcome(value : TFhirCodeableConcept);
begin
  FOutcome.free;
  FOutcome := value;
end;

procedure TFhirRiskAssessmentPrediction.SetProbability(value : TFhirDataType);
begin
  FProbability.free;
  FProbability := value;
end;

procedure TFhirRiskAssessmentPrediction.SetQualitativeRisk(value : TFhirCodeableConcept);
begin
  FQualitativeRisk.free;
  FQualitativeRisk := value;
end;

procedure TFhirRiskAssessmentPrediction.SetRelativeRisk(value : TFhirDecimal);
begin
  FRelativeRisk.free;
  FRelativeRisk := value;
end;

function TFhirRiskAssessmentPrediction.GetRelativeRiskST : String;
begin
  if FRelativeRisk = nil then
    result := ''
  else
    result := FRelativeRisk.value;
end;

procedure TFhirRiskAssessmentPrediction.SetRelativeRiskST(value : String);
begin
  if value <> '' then
  begin
    if FRelativeRisk = nil then
      FRelativeRisk := TFhirDecimal.create;
    FRelativeRisk.value := value
  end
  else if FRelativeRisk <> nil then
    FRelativeRisk.value := '';
end;

procedure TFhirRiskAssessmentPrediction.SetWhen(value : TFhirDataType);
begin
  FWhen.free;
  FWhen := value;
end;

procedure TFhirRiskAssessmentPrediction.SetRationale(value : TFhirString);
begin
  FRationale.free;
  FRationale := value;
end;

function TFhirRiskAssessmentPrediction.GetRationaleST : String;
begin
  if FRationale = nil then
    result := ''
  else
    result := FRationale.value;
end;

procedure TFhirRiskAssessmentPrediction.SetRationaleST(value : String);
begin
  if value <> '' then
  begin
    if FRationale = nil then
      FRationale := TFhirString.create;
    FRationale.value := value
  end
  else if FRationale <> nil then
    FRationale.value := '';
end;

{ TFhirRiskAssessmentPredictionListEnumerator }

constructor TFhirRiskAssessmentPredictionListEnumerator.Create(list : TFhirRiskAssessmentPredictionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskAssessmentPredictionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskAssessmentPredictionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskAssessmentPredictionListEnumerator.GetCurrent : TFhirRiskAssessmentPrediction;
begin
  Result := FList[FIndex];
end;

function TFhirRiskAssessmentPredictionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRiskAssessmentPredictionList }

function TFhirRiskAssessmentPredictionList.AddItem(value: TFhirRiskAssessmentPrediction): TFhirRiskAssessmentPrediction;
begin
  assert(value.ClassName = 'TFhirRiskAssessmentPrediction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskAssessmentPrediction');
  add(value);
  result := value;
end;

function TFhirRiskAssessmentPredictionList.Append: TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentPredictionList.ClearItems;
begin
  Clear;
end;

function TFhirRiskAssessmentPredictionList.GetEnumerator : TFhirRiskAssessmentPredictionListEnumerator;
begin
  result := TFhirRiskAssessmentPredictionListEnumerator.Create(self.link);
end;

function TFhirRiskAssessmentPredictionList.Clone: TFhirRiskAssessmentPredictionList;
begin
  result := TFhirRiskAssessmentPredictionList(inherited Clone);
end;

function TFhirRiskAssessmentPredictionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskAssessmentPredictionList.GetItemN(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentPredictionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskAssessmentPrediction;
end;
function TFhirRiskAssessmentPredictionList.IndexOf(value: TFhirRiskAssessmentPrediction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskAssessmentPredictionList.Insert(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentPredictionList.InsertItem(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  Inherited Insert(index, value);
end;

function TFhirRiskAssessmentPredictionList.Item(index: Integer): TFhirRiskAssessmentPrediction;
begin
  result := TFhirRiskAssessmentPrediction(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentPredictionList.Link: TFhirRiskAssessmentPredictionList;
begin
  result := TFhirRiskAssessmentPredictionList(inherited Link);
end;

procedure TFhirRiskAssessmentPredictionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskAssessmentPredictionList.SetItemByIndex(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  FhirRiskAssessmentPredictions[index] := value;
end;

procedure TFhirRiskAssessmentPredictionList.SetItemN(index: Integer; value: TFhirRiskAssessmentPrediction);
begin
  assert(value is TFhirRiskAssessmentPrediction);
  ObjectByIndex[index] := value;
end;

{ TFhirRiskAssessment }

constructor TFhirRiskAssessment.Create;
begin
  inherited;
end;

destructor TFhirRiskAssessment.Destroy;
begin
  FIdentifierList.Free;
  FBasedOn.free;
  FParent.free;
  FStatus.free;
  FMethod.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FOccurrence.free;
  FCondition.free;
  FPerformer.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FBasisList.Free;
  FPredictionList.Free;
  FMitigation.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirRiskAssessment.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRiskAssessment(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRiskAssessment(oSource).FIdentifierList);
  end;
  basedOn := TFhirRiskAssessment(oSource).basedOn.Clone;
  parent := TFhirRiskAssessment(oSource).parent.Clone;
  statusElement := TFhirRiskAssessment(oSource).statusElement.Clone;
  method := TFhirRiskAssessment(oSource).method.Clone;
  code := TFhirRiskAssessment(oSource).code.Clone;
  subject := TFhirRiskAssessment(oSource).subject.Clone;
  encounter := TFhirRiskAssessment(oSource).encounter.Clone;
  occurrence := TFhirRiskAssessment(oSource).occurrence.Clone;
  condition := TFhirRiskAssessment(oSource).condition.Clone;
  performer := TFhirRiskAssessment(oSource).performer.Clone;
  if (TFhirRiskAssessment(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirRiskAssessment(oSource).FReasonCodeList);
  end;
  if (TFhirRiskAssessment(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirRiskAssessment(oSource).FReasonReferenceList);
  end;
  if (TFhirRiskAssessment(oSource).FBasisList = nil) then
  begin
    FBasisList.free;
    FBasisList := nil;
  end
  else
  begin
    if FBasisList = nil then
      FBasisList := TFhirReferenceList.Create;
    FBasisList.Assign(TFhirRiskAssessment(oSource).FBasisList);
  end;
  if (TFhirRiskAssessment(oSource).FPredictionList = nil) then
  begin
    FPredictionList.free;
    FPredictionList := nil;
  end
  else
  begin
    if FPredictionList = nil then
      FPredictionList := TFhirRiskAssessmentPredictionList.Create;
    FPredictionList.Assign(TFhirRiskAssessment(oSource).FPredictionList);
  end;
  mitigationElement := TFhirRiskAssessment(oSource).mitigationElement.Clone;
  if (TFhirRiskAssessment(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRiskAssessment(oSource).FNoteList);
  end;
end;

function TFhirRiskAssessment.GetResourceType : TFhirResourceType;
begin
  result := frtRiskAssessment;
end;

procedure TFhirRiskAssessment.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
     list.add(self.link, 'basedOn', FBasedOn.Link);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'basis') Then
    list.addAll(self, 'basis', FBasisList);
  if (child_name = 'prediction') Then
    list.addAll(self, 'prediction', FPredictionList);
  if (child_name = 'mitigation') Then
     list.add(self.link, 'mitigation', FMitigation.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirRiskAssessment.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', false, TFhirReference, FBasedOn.Link));
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', false, TFhirReference, FParent.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'Reference', false, TFhirReference, FCondition.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'basis', 'Reference', true, TFhirReference, FBasisList.Link));
  oList.add(TFHIRProperty.create(self, 'prediction', 'BackboneElement', true, TFhirRiskAssessmentPrediction, FPredictionList.Link));
  oList.add(TFHIRProperty.create(self, 'mitigation', 'string', false, TFhirString, FMitigation.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirRiskAssessment.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOn := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'basis') then
  begin
    BasisList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'prediction') then
  begin
    PredictionList.add(propValue as TFhirRiskAssessmentPrediction);
    result := propValue;
  end
  else if (propName = 'mitigation') then
  begin
    MitigationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRiskAssessment.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'basis') then BasisList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'prediction') then PredictionList.insertItem(index, propValue as TFhirRiskAssessmentPrediction)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirRiskAssessment.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'basedOn') then result := TFhirReference.create()
  else if (propName = 'parent') then result := TFhirReference.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[ObservationStatusNull], CODES_TFhirObservationStatusEnum[ObservationStatusNull]) 
  else if (propName = 'method') then result := TFhirCodeableConcept.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (propName = 'condition') then result := TFhirReference.create()
  else if (propName = 'performer') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'basis') then result := BasisList.new()
  else if (propName = 'prediction') then result := PredictionList.new()
  else if (propName = 'mitigation') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRiskAssessment.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period'
  else if (propName = 'condition') then result := 'Reference'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'basis') then result := 'Reference'
  else if (propName = 'prediction') then result := 'BackboneElement'
  else if (propName = 'mitigation') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRiskAssessment.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'basedOn') then BasedOnElement := nil
  else if (propName = 'parent') then ParentElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := nil
  else if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'basis') then deletePropertyValue('basis', BasisList, value)
  else if (propName = 'prediction') then deletePropertyValue('prediction', PredictionList, value)
  else if (propName = 'mitigation') then MitigationElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRiskAssessment.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'basedOn') then BasedOnElement := new as TFhirReference
  else if (propName = 'parent') then ParentElement := new as TFhirReference
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirObservationStatusEnum, CODES_TFhirObservationStatusEnum, new)
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period'])) then OccurrenceElement := new as TFhirDataType
  else if (propName = 'condition') then ConditionElement := new as TFhirReference
  else if (propName = 'performer') then PerformerElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'basis') then replacePropertyValue('basis', BasisList, existing, new)
  else if (propName = 'prediction') then replacePropertyValue('prediction', PredictionList, existing, new)
  else if (propName = 'mitigation') then MitigationElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRiskAssessment.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'basis') then BasisList.move(source, destination)
  else if (propName = 'prediction') then PredictionList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRiskAssessment.fhirType : string;
begin
  result := 'RiskAssessment';
end;

function TFhirRiskAssessment.Link : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(inherited Link);
end;

function TFhirRiskAssessment.Clone : TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(inherited Clone);
end;

function TFhirRiskAssessment.equals(other : TObject) : boolean; 
var
  o : TFhirRiskAssessment;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRiskAssessment)) then
    result := false
  else
  begin
    o := TFhirRiskAssessment(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnElement, o.basedOnElement, true) and 
      compareDeep(parentElement, o.parentElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(methodElement, o.methodElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(conditionElement, o.conditionElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(basisList, o.basisList, true) and 
      compareDeep(predictionList, o.predictionList, true) and compareDeep(mitigationElement, o.mitigationElement, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirRiskAssessment.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FBasedOn) and isEmptyProp(FParent) and isEmptyProp(FStatus) and isEmptyProp(FMethod) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FCondition) and isEmptyProp(FPerformer) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FbasisList) and isEmptyProp(FpredictionList) and isEmptyProp(FMitigation) and isEmptyProp(FnoteList);
end;

procedure TFhirRiskAssessment.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('parent');
  fields.add('status');
  fields.add('method');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('condition');
  fields.add('performer');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('basis');
  fields.add('prediction');
  fields.add('mitigation');
  fields.add('note');
end;

function TFhirRiskAssessment.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FBasisList.sizeInBytes(magic));
  inc(result, FPredictionList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirRiskAssessment.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRiskAssessment.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirRiskAssessment.SetBasedOn(value : TFhirReference);
begin
  FBasedOn.free;
  FBasedOn := value;
end;

procedure TFhirRiskAssessment.SetParent(value : TFhirReference);
begin
  FParent.free;
  FParent := value;
end;

procedure TFhirRiskAssessment.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirRiskAssessment.GetStatusST : TFhirObservationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirObservationStatusEnum(0)
  else
    result := TFhirObservationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirObservationStatusEnum, FStatus.value));
end;

procedure TFhirRiskAssessment.SetStatusST(value : TFhirObservationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirObservationStatusEnum[value], CODES_TFhirObservationStatusEnum[value]);
end;

procedure TFhirRiskAssessment.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

procedure TFhirRiskAssessment.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirRiskAssessment.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirRiskAssessment.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirRiskAssessment.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

procedure TFhirRiskAssessment.SetCondition(value : TFhirReference);
begin
  FCondition.free;
  FCondition := value;
end;

procedure TFhirRiskAssessment.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value;
end;

function TFhirRiskAssessment.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirRiskAssessment.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirRiskAssessment.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirRiskAssessment.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirRiskAssessment.GetBasisList : TFhirReferenceList;
begin
  if FBasisList = nil then
    FBasisList := TFhirReferenceList.Create;
  result := FBasisList;
end;

function TFhirRiskAssessment.GetHasBasisList : boolean;
begin
  result := (FBasisList <> nil) and (FBasisList.count > 0);
end;

function TFhirRiskAssessment.GetPredictionList : TFhirRiskAssessmentPredictionList;
begin
  if FPredictionList = nil then
    FPredictionList := TFhirRiskAssessmentPredictionList.Create;
  result := FPredictionList;
end;

function TFhirRiskAssessment.GetHasPredictionList : boolean;
begin
  result := (FPredictionList <> nil) and (FPredictionList.count > 0);
end;

procedure TFhirRiskAssessment.SetMitigation(value : TFhirString);
begin
  FMitigation.free;
  FMitigation := value;
end;

function TFhirRiskAssessment.GetMitigationST : String;
begin
  if FMitigation = nil then
    result := ''
  else
    result := FMitigation.value;
end;

procedure TFhirRiskAssessment.SetMitigationST(value : String);
begin
  if value <> '' then
  begin
    if FMitigation = nil then
      FMitigation := TFhirString.create;
    FMitigation.value := value
  end
  else if FMitigation <> nil then
    FMitigation.value := '';
end;

function TFhirRiskAssessment.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirRiskAssessment.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirRiskAssessmentListEnumerator }

constructor TFhirRiskAssessmentListEnumerator.Create(list : TFhirRiskAssessmentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRiskAssessmentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRiskAssessmentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRiskAssessmentListEnumerator.GetCurrent : TFhirRiskAssessment;
begin
  Result := FList[FIndex];
end;

function TFhirRiskAssessmentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRiskAssessmentList }

function TFhirRiskAssessmentList.AddItem(value: TFhirRiskAssessment): TFhirRiskAssessment;
begin
  assert(value.ClassName = 'TFhirRiskAssessment', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRiskAssessment');
  add(value);
  result := value;
end;

function TFhirRiskAssessmentList.Append: TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentList.ClearItems;
begin
  Clear;
end;

function TFhirRiskAssessmentList.GetEnumerator : TFhirRiskAssessmentListEnumerator;
begin
  result := TFhirRiskAssessmentListEnumerator.Create(self.link);
end;

function TFhirRiskAssessmentList.Clone: TFhirRiskAssessmentList;
begin
  result := TFhirRiskAssessmentList(inherited Clone);
end;

function TFhirRiskAssessmentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRiskAssessmentList.GetItemN(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentList.ItemClass: TFslObjectClass;
begin
  result := TFhirRiskAssessment;
end;
function TFhirRiskAssessmentList.IndexOf(value: TFhirRiskAssessment): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRiskAssessmentList.Insert(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRiskAssessmentList.InsertItem(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  Inherited Insert(index, value);
end;

function TFhirRiskAssessmentList.Item(index: Integer): TFhirRiskAssessment;
begin
  result := TFhirRiskAssessment(ObjectByIndex[index]);
end;

function TFhirRiskAssessmentList.Link: TFhirRiskAssessmentList;
begin
  result := TFhirRiskAssessmentList(inherited Link);
end;

procedure TFhirRiskAssessmentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRiskAssessmentList.SetItemByIndex(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  FhirRiskAssessments[index] := value;
end;

procedure TFhirRiskAssessmentList.SetItemN(index: Integer; value: TFhirRiskAssessment);
begin
  assert(value is TFhirRiskAssessment);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RISKASSESSMENT}
{$IFDEF FHIR_SERVICEREQUEST}
{ TFhirServiceRequest }

constructor TFhirServiceRequest.Create;
begin
  inherited;
end;

destructor TFhirServiceRequest.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FRequisition.free;
  FStatus.free;
  FIntent.free;
  FCategoryList.Free;
  FPriority.free;
  FDoNotPerform.free;
  FCode.free;
  FOrderDetailList.Free;
  FQuantity.free;
  FSubject.free;
  FEncounter.free;
  FOccurrence.free;
  FAsNeeded.free;
  FAuthoredOn.free;
  FRequester.free;
  FPerformerType.free;
  FPerformerList.Free;
  FLocationCodeList.Free;
  FLocationReferenceList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FInsuranceList.Free;
  FSupportingInfoList.Free;
  FSpecimenList.Free;
  FBodySiteList.Free;
  FNoteList.Free;
  FPatientInstruction.free;
  FRelevantHistoryList.Free;
  inherited;
end;

procedure TFhirServiceRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirServiceRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirServiceRequest(oSource).FIdentifierList);
  end;
  if (TFhirServiceRequest(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirServiceRequest(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirServiceRequest(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirServiceRequest(oSource).FInstantiatesUriList);
  end;
  if (TFhirServiceRequest(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirServiceRequest(oSource).FBasedOnList);
  end;
  if (TFhirServiceRequest(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList.Create;
    FReplacesList.Assign(TFhirServiceRequest(oSource).FReplacesList);
  end;
  requisition := TFhirServiceRequest(oSource).requisition.Clone;
  statusElement := TFhirServiceRequest(oSource).statusElement.Clone;
  intentElement := TFhirServiceRequest(oSource).intentElement.Clone;
  if (TFhirServiceRequest(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirServiceRequest(oSource).FCategoryList);
  end;
  priorityElement := TFhirServiceRequest(oSource).priorityElement.Clone;
  doNotPerformElement := TFhirServiceRequest(oSource).doNotPerformElement.Clone;
  code := TFhirServiceRequest(oSource).code.Clone;
  if (TFhirServiceRequest(oSource).FOrderDetailList = nil) then
  begin
    FOrderDetailList.free;
    FOrderDetailList := nil;
  end
  else
  begin
    if FOrderDetailList = nil then
      FOrderDetailList := TFhirCodeableConceptList.Create;
    FOrderDetailList.Assign(TFhirServiceRequest(oSource).FOrderDetailList);
  end;
  quantity := TFhirServiceRequest(oSource).quantity.Clone;
  subject := TFhirServiceRequest(oSource).subject.Clone;
  encounter := TFhirServiceRequest(oSource).encounter.Clone;
  occurrence := TFhirServiceRequest(oSource).occurrence.Clone;
  asNeeded := TFhirServiceRequest(oSource).asNeeded.Clone;
  authoredOnElement := TFhirServiceRequest(oSource).authoredOnElement.Clone;
  requester := TFhirServiceRequest(oSource).requester.Clone;
  performerType := TFhirServiceRequest(oSource).performerType.Clone;
  if (TFhirServiceRequest(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList.Create;
    FPerformerList.Assign(TFhirServiceRequest(oSource).FPerformerList);
  end;
  if (TFhirServiceRequest(oSource).FLocationCodeList = nil) then
  begin
    FLocationCodeList.free;
    FLocationCodeList := nil;
  end
  else
  begin
    if FLocationCodeList = nil then
      FLocationCodeList := TFhirCodeableConceptList.Create;
    FLocationCodeList.Assign(TFhirServiceRequest(oSource).FLocationCodeList);
  end;
  if (TFhirServiceRequest(oSource).FLocationReferenceList = nil) then
  begin
    FLocationReferenceList.free;
    FLocationReferenceList := nil;
  end
  else
  begin
    if FLocationReferenceList = nil then
      FLocationReferenceList := TFhirReferenceList.Create;
    FLocationReferenceList.Assign(TFhirServiceRequest(oSource).FLocationReferenceList);
  end;
  if (TFhirServiceRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirServiceRequest(oSource).FReasonCodeList);
  end;
  if (TFhirServiceRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirServiceRequest(oSource).FReasonReferenceList);
  end;
  if (TFhirServiceRequest(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirReferenceList.Create;
    FInsuranceList.Assign(TFhirServiceRequest(oSource).FInsuranceList);
  end;
  if (TFhirServiceRequest(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirServiceRequest(oSource).FSupportingInfoList);
  end;
  if (TFhirServiceRequest(oSource).FSpecimenList = nil) then
  begin
    FSpecimenList.free;
    FSpecimenList := nil;
  end
  else
  begin
    if FSpecimenList = nil then
      FSpecimenList := TFhirReferenceList.Create;
    FSpecimenList.Assign(TFhirServiceRequest(oSource).FSpecimenList);
  end;
  if (TFhirServiceRequest(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirServiceRequest(oSource).FBodySiteList);
  end;
  if (TFhirServiceRequest(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirServiceRequest(oSource).FNoteList);
  end;
  patientInstructionElement := TFhirServiceRequest(oSource).patientInstructionElement.Clone;
  if (TFhirServiceRequest(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList.Create;
    FRelevantHistoryList.Assign(TFhirServiceRequest(oSource).FRelevantHistoryList);
  end;
end;

function TFhirServiceRequest.GetResourceType : TFhirResourceType;
begin
  result := frtServiceRequest;
end;

procedure TFhirServiceRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'requisition') Then
     list.add(self.link, 'requisition', FRequisition.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'orderDetail') Then
    list.addAll(self, 'orderDetail', FOrderDetailList);
  if (child_name = 'quantity[x]') or (child_name = 'quantity') Then
     list.add(self.link, 'quantity[x]', FQuantity.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'asNeeded[x]') or (child_name = 'asNeeded') Then
     list.add(self.link, 'asNeeded[x]', FAsNeeded.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performerType') Then
     list.add(self.link, 'performerType', FPerformerType.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'locationCode') Then
    list.addAll(self, 'locationCode', FLocationCodeList);
  if (child_name = 'locationReference') Then
    list.addAll(self, 'locationReference', FLocationReferenceList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'specimen') Then
    list.addAll(self, 'specimen', FSpecimenList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'patientInstruction') Then
     list.add(self.link, 'patientInstruction', FPatientInstruction.Link);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
end;

procedure TFhirServiceRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference', true, TFhirReference, FReplacesList.Link));
  oList.add(TFHIRProperty.create(self, 'requisition', 'Identifier', false, TFhirIdentifier, FRequisition.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'orderDetail', 'CodeableConcept', true, TFhirCodeableConcept, FOrderDetailList.Link));
  oList.add(TFHIRProperty.create(self, 'quantity[x]', 'Quantity|Ratio|Range', false, TFhirDataType, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'asNeeded[x]', 'boolean|CodeableConcept', false, TFhirDataType, FAsNeeded.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link));
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerType.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', true, TFhirReference, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'locationCode', 'CodeableConcept', true, TFhirCodeableConcept, FLocationCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'locationReference', 'Reference', true, TFhirReference, FLocationReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'Reference', true, TFhirReference, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'specimen', 'Reference', true, TFhirReference, FSpecimenList.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'patientInstruction', 'string', false, TFhirString, FPatientInstruction.Link));
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference', true, TFhirReference, FRelevantHistoryList.Link));
end;

function TFhirServiceRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'requisition') then
  begin
    Requisition := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'orderDetail') then
  begin
    OrderDetailList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Ratio', 'Range'])) then
  begin
    Quantity := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then
  begin
    AsNeeded := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'locationCode') then
  begin
    LocationCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'locationReference') then
  begin
    LocationReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'specimen') then
  begin
    SpecimenList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'patientInstruction') then
  begin
    PatientInstructionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirServiceRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'orderDetail') then OrderDetailList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'locationCode') then LocationCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'locationReference') then LocationReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'specimen') then SpecimenList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirServiceRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'replaces') then result := ReplacesList.new()
  else if (propName = 'requisition') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull]) 
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'orderDetail') then result := OrderDetailList.new()
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Ratio', 'Range'])) then raise EFHIRException.create('Cannot make property Quantity')
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property AsNeeded')
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'requester') then result := TFhirReference.create()
  else if (propName = 'performerType') then result := TFhirCodeableConcept.create()
  else if (propName = 'performer') then result := PerformerList.new()
  else if (propName = 'locationCode') then result := LocationCodeList.new()
  else if (propName = 'locationReference') then result := LocationReferenceList.new()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new()
  else if (propName = 'specimen') then result := SpecimenList.new()
  else if (propName = 'bodySite') then result := BodySiteList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'patientInstruction') then result := TFhirString.create()
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirServiceRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'requisition') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'orderDetail') then result := 'CodeableConcept'
  else if (propName = 'quantity[x]') then result := 'Quantity|Ratio|Range'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'asNeeded[x]') then result := 'boolean|CodeableConcept'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'locationCode') then result := 'CodeableConcept'
  else if (propName = 'locationReference') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'insurance') then result := 'Reference'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'specimen') then result := 'Reference'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'patientInstruction') then result := 'string'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirServiceRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value)
  else if (propName = 'requisition') then RequisitionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'orderDetail') then deletePropertyValue('orderDetail', OrderDetailList, value)
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Ratio', 'Range'])) then QuantityElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performerType') then PerformerTypeElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (propName = 'locationCode') then deletePropertyValue('locationCode', LocationCodeList, value)
  else if (propName = 'locationReference') then deletePropertyValue('locationReference', LocationReferenceList, value)
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value)
  else if (propName = 'specimen') then deletePropertyValue('specimen', SpecimenList, value)
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'patientInstruction') then PatientInstructionElement := nil
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirServiceRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new)
  else if (propName = 'requisition') then RequisitionElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new)
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'orderDetail') then replacePropertyValue('orderDetail', OrderDetailList, existing, new)
  else if (isMatchingName(propName, 'quantity', ['Quantity', 'Ratio', 'Range'])) then QuantityElement := new as TFhirDataType
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType
  else if (isMatchingName(propName, 'asNeeded', ['Boolean', 'CodeableConcept'])) then AsNeededElement := new as TFhirDataType
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'requester') then RequesterElement := new as TFhirReference
  else if (propName = 'performerType') then PerformerTypeElement := new as TFhirCodeableConcept
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (propName = 'locationCode') then replacePropertyValue('locationCode', LocationCodeList, existing, new)
  else if (propName = 'locationReference') then replacePropertyValue('locationReference', LocationReferenceList, existing, new)
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new)
  else if (propName = 'specimen') then replacePropertyValue('specimen', SpecimenList, existing, new)
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'patientInstruction') then PatientInstructionElement := asString(new)
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirServiceRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'replaces') then ReplacesList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'orderDetail') then OrderDetailList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'locationCode') then LocationCodeList.move(source, destination)
  else if (propName = 'locationReference') then LocationReferenceList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination)
  else if (propName = 'specimen') then SpecimenList.move(source, destination)
  else if (propName = 'bodySite') then BodySiteList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirServiceRequest.fhirType : string;
begin
  result := 'ServiceRequest';
end;

function TFhirServiceRequest.Link : TFhirServiceRequest;
begin
  result := TFhirServiceRequest(inherited Link);
end;

function TFhirServiceRequest.Clone : TFhirServiceRequest;
begin
  result := TFhirServiceRequest(inherited Clone);
end;

function TFhirServiceRequest.equals(other : TObject) : boolean; 
var
  o : TFhirServiceRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirServiceRequest)) then
    result := false
  else
  begin
    o := TFhirServiceRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(requisitionElement, o.requisitionElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(doNotPerformElement, o.doNotPerformElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(orderDetailList, o.orderDetailList, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(occurrenceElement, o.occurrenceElement, true) and compareDeep(asNeededElement, o.asNeededElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(performerTypeElement, o.performerTypeElement, true) and compareDeep(performerList, o.performerList, true) and 
      compareDeep(locationCodeList, o.locationCodeList, true) and compareDeep(locationReferenceList, o.locationReferenceList, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(insuranceList, o.insuranceList, true) and compareDeep(supportingInfoList, o.supportingInfoList, true) and 
      compareDeep(specimenList, o.specimenList, true) and compareDeep(bodySiteList, o.bodySiteList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(patientInstructionElement, o.patientInstructionElement, true) and 
      compareDeep(relevantHistoryList, o.relevantHistoryList, true);
  end;
end;

function TFhirServiceRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FRequisition) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FcategoryList) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform) and isEmptyProp(FCode) and isEmptyProp(ForderDetailList) and isEmptyProp(FQuantity) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrence) and isEmptyProp(FAsNeeded) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FPerformerType) and isEmptyProp(FperformerList) and isEmptyProp(FlocationCodeList) and isEmptyProp(FlocationReferenceList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FinsuranceList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FspecimenList) and isEmptyProp(FbodySiteList) and isEmptyProp(FnoteList)
       and isEmptyProp(FPatientInstruction) and isEmptyProp(FrelevantHistoryList);
end;

procedure TFhirServiceRequest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('requisition');
  fields.add('status');
  fields.add('intent');
  fields.add('category');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('code');
  fields.add('orderDetail');
  fields.add('quantity[x]');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrence[x]');
  fields.add('asNeeded[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('performerType');
  fields.add('performer');
  fields.add('locationCode');
  fields.add('locationReference');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('insurance');
  fields.add('supportingInfo');
  fields.add('specimen');
  fields.add('bodySite');
  fields.add('note');
  fields.add('patientInstruction');
  fields.add('relevantHistory');
end;

function TFhirServiceRequest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FReplacesList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FOrderDetailList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FLocationCodeList.sizeInBytes(magic));
  inc(result, FLocationReferenceList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FSupportingInfoList.sizeInBytes(magic));
  inc(result, FSpecimenList.sizeInBytes(magic));
  inc(result, FBodySiteList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FRelevantHistoryList.sizeInBytes(magic));
end;

function TFhirServiceRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirServiceRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirServiceRequest.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirServiceRequest.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirServiceRequest.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirServiceRequest.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirServiceRequest.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirServiceRequest.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirServiceRequest.GetReplacesList : TFhirReferenceList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList.Create;
  result := FReplacesList;
end;

function TFhirServiceRequest.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirServiceRequest.SetRequisition(value : TFhirIdentifier);
begin
  FRequisition.free;
  FRequisition := value;
end;

procedure TFhirServiceRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirServiceRequest.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirServiceRequest.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirServiceRequest.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirServiceRequest.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirServiceRequest.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

function TFhirServiceRequest.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirServiceRequest.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirServiceRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirServiceRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirServiceRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirServiceRequest.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

function TFhirServiceRequest.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirServiceRequest.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirServiceRequest.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirServiceRequest.GetOrderDetailList : TFhirCodeableConceptList;
begin
  if FOrderDetailList = nil then
    FOrderDetailList := TFhirCodeableConceptList.Create;
  result := FOrderDetailList;
end;

function TFhirServiceRequest.GetHasOrderDetailList : boolean;
begin
  result := (FOrderDetailList <> nil) and (FOrderDetailList.count > 0);
end;

procedure TFhirServiceRequest.SetQuantity(value : TFhirDataType);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirServiceRequest.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirServiceRequest.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirServiceRequest.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

procedure TFhirServiceRequest.SetAsNeeded(value : TFhirDataType);
begin
  FAsNeeded.free;
  FAsNeeded := value;
end;

procedure TFhirServiceRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirServiceRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirServiceRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirServiceRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value;
end;

procedure TFhirServiceRequest.SetPerformerType(value : TFhirCodeableConcept);
begin
  FPerformerType.free;
  FPerformerType := value;
end;

function TFhirServiceRequest.GetPerformerList : TFhirReferenceList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList.Create;
  result := FPerformerList;
end;

function TFhirServiceRequest.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirServiceRequest.GetLocationCodeList : TFhirCodeableConceptList;
begin
  if FLocationCodeList = nil then
    FLocationCodeList := TFhirCodeableConceptList.Create;
  result := FLocationCodeList;
end;

function TFhirServiceRequest.GetHasLocationCodeList : boolean;
begin
  result := (FLocationCodeList <> nil) and (FLocationCodeList.count > 0);
end;

function TFhirServiceRequest.GetLocationReferenceList : TFhirReferenceList;
begin
  if FLocationReferenceList = nil then
    FLocationReferenceList := TFhirReferenceList.Create;
  result := FLocationReferenceList;
end;

function TFhirServiceRequest.GetHasLocationReferenceList : boolean;
begin
  result := (FLocationReferenceList <> nil) and (FLocationReferenceList.count > 0);
end;

function TFhirServiceRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirServiceRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirServiceRequest.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirServiceRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirServiceRequest.GetInsuranceList : TFhirReferenceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirReferenceList.Create;
  result := FInsuranceList;
end;

function TFhirServiceRequest.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirServiceRequest.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirServiceRequest.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirServiceRequest.GetSpecimenList : TFhirReferenceList;
begin
  if FSpecimenList = nil then
    FSpecimenList := TFhirReferenceList.Create;
  result := FSpecimenList;
end;

function TFhirServiceRequest.GetHasSpecimenList : boolean;
begin
  result := (FSpecimenList <> nil) and (FSpecimenList.count > 0);
end;

function TFhirServiceRequest.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

function TFhirServiceRequest.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

function TFhirServiceRequest.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirServiceRequest.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirServiceRequest.SetPatientInstruction(value : TFhirString);
begin
  FPatientInstruction.free;
  FPatientInstruction := value;
end;

function TFhirServiceRequest.GetPatientInstructionST : String;
begin
  if FPatientInstruction = nil then
    result := ''
  else
    result := FPatientInstruction.value;
end;

procedure TFhirServiceRequest.SetPatientInstructionST(value : String);
begin
  if value <> '' then
  begin
    if FPatientInstruction = nil then
      FPatientInstruction := TFhirString.create;
    FPatientInstruction.value := value
  end
  else if FPatientInstruction <> nil then
    FPatientInstruction.value := '';
end;

function TFhirServiceRequest.GetRelevantHistoryList : TFhirReferenceList;
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList.Create;
  result := FRelevantHistoryList;
end;

function TFhirServiceRequest.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

{ TFhirServiceRequestListEnumerator }

constructor TFhirServiceRequestListEnumerator.Create(list : TFhirServiceRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirServiceRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirServiceRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirServiceRequestListEnumerator.GetCurrent : TFhirServiceRequest;
begin
  Result := FList[FIndex];
end;

function TFhirServiceRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirServiceRequestList }

function TFhirServiceRequestList.AddItem(value: TFhirServiceRequest): TFhirServiceRequest;
begin
  assert(value.ClassName = 'TFhirServiceRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirServiceRequest');
  add(value);
  result := value;
end;

function TFhirServiceRequestList.Append: TFhirServiceRequest;
begin
  result := TFhirServiceRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirServiceRequestList.ClearItems;
begin
  Clear;
end;

function TFhirServiceRequestList.GetEnumerator : TFhirServiceRequestListEnumerator;
begin
  result := TFhirServiceRequestListEnumerator.Create(self.link);
end;

function TFhirServiceRequestList.Clone: TFhirServiceRequestList;
begin
  result := TFhirServiceRequestList(inherited Clone);
end;

function TFhirServiceRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirServiceRequestList.GetItemN(index: Integer): TFhirServiceRequest;
begin
  result := TFhirServiceRequest(ObjectByIndex[index]);
end;

function TFhirServiceRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirServiceRequest;
end;
function TFhirServiceRequestList.IndexOf(value: TFhirServiceRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirServiceRequestList.Insert(index: Integer): TFhirServiceRequest;
begin
  result := TFhirServiceRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirServiceRequestList.InsertItem(index: Integer; value: TFhirServiceRequest);
begin
  assert(value is TFhirServiceRequest);
  Inherited Insert(index, value);
end;

function TFhirServiceRequestList.Item(index: Integer): TFhirServiceRequest;
begin
  result := TFhirServiceRequest(ObjectByIndex[index]);
end;

function TFhirServiceRequestList.Link: TFhirServiceRequestList;
begin
  result := TFhirServiceRequestList(inherited Link);
end;

procedure TFhirServiceRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirServiceRequestList.SetItemByIndex(index: Integer; value: TFhirServiceRequest);
begin
  assert(value is TFhirServiceRequest);
  FhirServiceRequests[index] := value;
end;

procedure TFhirServiceRequestList.SetItemN(index: Integer; value: TFhirServiceRequest);
begin
  assert(value is TFhirServiceRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SERVICEREQUEST}
{$IFDEF FHIR_SPECIMEN}
{ TFhirSpecimenCollection }

constructor TFhirSpecimenCollection.Create;
begin
  inherited;
end;

destructor TFhirSpecimenCollection.Destroy;
begin
  FCollector.free;
  FCollected.free;
  FDuration.free;
  FQuantity.free;
  FMethod.free;
  FBodySite.free;
  FFastingStatus.free;
  inherited;
end;

procedure TFhirSpecimenCollection.Assign(oSource : TFslObject);
begin
  inherited;
  collector := TFhirSpecimenCollection(oSource).collector.Clone;
  collected := TFhirSpecimenCollection(oSource).collected.Clone;
  duration := TFhirSpecimenCollection(oSource).duration.Clone;
  quantity := TFhirSpecimenCollection(oSource).quantity.Clone;
  method := TFhirSpecimenCollection(oSource).method.Clone;
  bodySite := TFhirSpecimenCollection(oSource).bodySite.Clone;
  fastingStatus := TFhirSpecimenCollection(oSource).fastingStatus.Clone;
end;

procedure TFhirSpecimenCollection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'collector') Then
     list.add(self.link, 'collector', FCollector.Link);
  if (child_name = 'collected[x]') or (child_name = 'collected') Then
     list.add(self.link, 'collected[x]', FCollected.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'fastingStatus[x]') or (child_name = 'fastingStatus') Then
     list.add(self.link, 'fastingStatus[x]', FFastingStatus.Link);
end;

procedure TFhirSpecimenCollection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'collector', 'Reference', false, TFhirReference, FCollector.Link));
  oList.add(TFHIRProperty.create(self, 'collected[x]', 'dateTime|Period', false, TFhirDataType, FCollected.Link));
  oList.add(TFHIRProperty.create(self, 'duration', 'Duration', false, TFhirDuration, FDuration.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));
  oList.add(TFHIRProperty.create(self, 'fastingStatus[x]', 'CodeableConcept|Duration', false, TFhirDataType, FFastingStatus.Link));
end;

function TFhirSpecimenCollection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'collector') then
  begin
    Collector := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then
  begin
    Collected := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'fastingStatus', ['CodeableConcept', 'Duration'])) then
  begin
    FastingStatus := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenCollection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSpecimenCollection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'collector') then result := TFhirReference.create()
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Collected')
  else if (propName = 'duration') then result := TFhirDuration.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'method') then result := TFhirCodeableConcept.create()
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'fastingStatus', ['CodeableConcept', 'Duration'])) then raise EFHIRException.create('Cannot make property FastingStatus')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenCollection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'collector') then result := 'Reference'
  else if (propName = 'collected[x]') then result := 'dateTime|Period'
  else if (propName = 'duration') then result := 'Duration'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'fastingStatus[x]') then result := 'CodeableConcept|Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenCollection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := nil
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (isMatchingName(propName, 'fastingStatus', ['CodeableConcept', 'Duration'])) then FastingStatusElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenCollection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'collector') then CollectorElement := new as TFhirReference
  else if (isMatchingName(propName, 'collected', ['DateTime', 'Period'])) then CollectedElement := new as TFhirDataType
  else if (propName = 'duration') then DurationElement := new as TFhirDuration
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'fastingStatus', ['CodeableConcept', 'Duration'])) then FastingStatusElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenCollection.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenCollection.fhirType : string;
begin
  result := 'Specimen.collection';
end;

function TFhirSpecimenCollection.Link : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Link);
end;

function TFhirSpecimenCollection.Clone : TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(inherited Clone);
end;

function TFhirSpecimenCollection.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenCollection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenCollection)) then
    result := false
  else
  begin
    o := TFhirSpecimenCollection(other);
    result := compareDeep(collectorElement, o.collectorElement, true) and compareDeep(collectedElement, o.collectedElement, true) and 
      compareDeep(durationElement, o.durationElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(methodElement, o.methodElement, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(fastingStatusElement, o.fastingStatusElement, true);
  end;
end;

function TFhirSpecimenCollection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCollector) and isEmptyProp(FCollected) and isEmptyProp(FDuration) and isEmptyProp(FQuantity) and isEmptyProp(FMethod) and isEmptyProp(FBodySite) and isEmptyProp(FFastingStatus);
end;

procedure TFhirSpecimenCollection.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('collector');
  fields.add('collected[x]');
  fields.add('duration');
  fields.add('quantity');
  fields.add('method');
  fields.add('bodySite');
  fields.add('fastingStatus[x]');
end;

function TFhirSpecimenCollection.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSpecimenCollection.SetCollector(value : TFhirReference);
begin
  FCollector.free;
  FCollector := value;
end;

procedure TFhirSpecimenCollection.SetCollected(value : TFhirDataType);
begin
  FCollected.free;
  FCollected := value;
end;

procedure TFhirSpecimenCollection.SetDuration(value : TFhirDuration);
begin
  FDuration.free;
  FDuration := value;
end;

procedure TFhirSpecimenCollection.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirSpecimenCollection.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

procedure TFhirSpecimenCollection.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

procedure TFhirSpecimenCollection.SetFastingStatus(value : TFhirDataType);
begin
  FFastingStatus.free;
  FFastingStatus := value;
end;

{ TFhirSpecimenCollectionListEnumerator }

constructor TFhirSpecimenCollectionListEnumerator.Create(list : TFhirSpecimenCollectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenCollectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenCollectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenCollectionListEnumerator.GetCurrent : TFhirSpecimenCollection;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenCollectionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSpecimenCollectionList }

function TFhirSpecimenCollectionList.AddItem(value: TFhirSpecimenCollection): TFhirSpecimenCollection;
begin
  assert(value.ClassName = 'TFhirSpecimenCollection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenCollection');
  add(value);
  result := value;
end;

function TFhirSpecimenCollectionList.Append: TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenCollectionList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenCollectionList.GetEnumerator : TFhirSpecimenCollectionListEnumerator;
begin
  result := TFhirSpecimenCollectionListEnumerator.Create(self.link);
end;

function TFhirSpecimenCollectionList.Clone: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Clone);
end;

function TFhirSpecimenCollectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenCollectionList.GetItemN(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenCollection;
end;
function TFhirSpecimenCollectionList.IndexOf(value: TFhirSpecimenCollection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenCollectionList.Insert(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenCollectionList.InsertItem(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  Inherited Insert(index, value);
end;

function TFhirSpecimenCollectionList.Item(index: Integer): TFhirSpecimenCollection;
begin
  result := TFhirSpecimenCollection(ObjectByIndex[index]);
end;

function TFhirSpecimenCollectionList.Link: TFhirSpecimenCollectionList;
begin
  result := TFhirSpecimenCollectionList(inherited Link);
end;

procedure TFhirSpecimenCollectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenCollectionList.SetItemByIndex(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  FhirSpecimenCollections[index] := value;
end;

procedure TFhirSpecimenCollectionList.SetItemN(index: Integer; value: TFhirSpecimenCollection);
begin
  assert(value is TFhirSpecimenCollection);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenProcessing }

constructor TFhirSpecimenProcessing.Create;
begin
  inherited;
end;

destructor TFhirSpecimenProcessing.Destroy;
begin
  FDescription.free;
  FProcedure_.free;
  FAdditiveList.Free;
  FTime.free;
  inherited;
end;

procedure TFhirSpecimenProcessing.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSpecimenProcessing(oSource).descriptionElement.Clone;
  procedure_ := TFhirSpecimenProcessing(oSource).procedure_.Clone;
  if (TFhirSpecimenProcessing(oSource).FAdditiveList = nil) then
  begin
    FAdditiveList.free;
    FAdditiveList := nil;
  end
  else
  begin
    if FAdditiveList = nil then
      FAdditiveList := TFhirReferenceList.Create;
    FAdditiveList.Assign(TFhirSpecimenProcessing(oSource).FAdditiveList);
  end;
  time := TFhirSpecimenProcessing(oSource).time.Clone;
end;

procedure TFhirSpecimenProcessing.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'procedure') Then
     list.add(self.link, 'procedure', FProcedure_.Link);
  if (child_name = 'additive') Then
    list.addAll(self, 'additive', FAdditiveList);
  if (child_name = 'time[x]') or (child_name = 'time') Then
     list.add(self.link, 'time[x]', FTime.Link);
end;

procedure TFhirSpecimenProcessing.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'procedure', 'CodeableConcept', false, TFhirCodeableConcept, FProcedure_.Link));
  oList.add(TFHIRProperty.create(self, 'additive', 'Reference', true, TFhirReference, FAdditiveList.Link));
  oList.add(TFHIRProperty.create(self, 'time[x]', 'dateTime|Period', false, TFhirDataType, FTime.Link));
end;

function TFhirSpecimenProcessing.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'procedure') then
  begin
    Procedure_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'additive') then
  begin
    AdditiveList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then
  begin
    Time := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenProcessing.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'additive') then AdditiveList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSpecimenProcessing.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'procedure') then result := TFhirCodeableConcept.create()
  else if (propName = 'additive') then result := AdditiveList.new()
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then raise EFHIRException.create('Cannot make property Time')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenProcessing.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'procedure') then result := 'CodeableConcept'
  else if (propName = 'additive') then result := 'Reference'
  else if (propName = 'time[x]') then result := 'dateTime|Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenProcessing.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'procedure') then Procedure_Element := nil
  else if (propName = 'additive') then deletePropertyValue('additive', AdditiveList, value)
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenProcessing.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'procedure') then Procedure_Element := new as TFhirCodeableConcept
  else if (propName = 'additive') then replacePropertyValue('additive', AdditiveList, existing, new)
  else if (isMatchingName(propName, 'time', ['DateTime', 'Period'])) then TimeElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenProcessing.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'additive') then AdditiveList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenProcessing.fhirType : string;
begin
  result := 'Specimen.processing';
end;

function TFhirSpecimenProcessing.Link : TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(inherited Link);
end;

function TFhirSpecimenProcessing.Clone : TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(inherited Clone);
end;

function TFhirSpecimenProcessing.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenProcessing;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenProcessing)) then
    result := false
  else
  begin
    o := TFhirSpecimenProcessing(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(procedure_Element, o.procedure_Element, true) and 
      compareDeep(additiveList, o.additiveList, true) and compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirSpecimenProcessing.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FProcedure_) and isEmptyProp(FadditiveList) and isEmptyProp(FTime);
end;

procedure TFhirSpecimenProcessing.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('procedure');
  fields.add('additive');
  fields.add('time[x]');
end;

function TFhirSpecimenProcessing.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAdditiveList.sizeInBytes(magic));
end;

procedure TFhirSpecimenProcessing.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSpecimenProcessing.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSpecimenProcessing.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSpecimenProcessing.SetProcedure_(value : TFhirCodeableConcept);
begin
  FProcedure_.free;
  FProcedure_ := value;
end;

function TFhirSpecimenProcessing.GetAdditiveList : TFhirReferenceList;
begin
  if FAdditiveList = nil then
    FAdditiveList := TFhirReferenceList.Create;
  result := FAdditiveList;
end;

function TFhirSpecimenProcessing.GetHasAdditiveList : boolean;
begin
  result := (FAdditiveList <> nil) and (FAdditiveList.count > 0);
end;

procedure TFhirSpecimenProcessing.SetTime(value : TFhirDataType);
begin
  FTime.free;
  FTime := value;
end;

{ TFhirSpecimenProcessingListEnumerator }

constructor TFhirSpecimenProcessingListEnumerator.Create(list : TFhirSpecimenProcessingList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenProcessingListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenProcessingListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenProcessingListEnumerator.GetCurrent : TFhirSpecimenProcessing;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenProcessingListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSpecimenProcessingList }

function TFhirSpecimenProcessingList.AddItem(value: TFhirSpecimenProcessing): TFhirSpecimenProcessing;
begin
  assert(value.ClassName = 'TFhirSpecimenProcessing', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenProcessing');
  add(value);
  result := value;
end;

function TFhirSpecimenProcessingList.Append: TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenProcessingList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenProcessingList.GetEnumerator : TFhirSpecimenProcessingListEnumerator;
begin
  result := TFhirSpecimenProcessingListEnumerator.Create(self.link);
end;

function TFhirSpecimenProcessingList.Clone: TFhirSpecimenProcessingList;
begin
  result := TFhirSpecimenProcessingList(inherited Clone);
end;

function TFhirSpecimenProcessingList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenProcessingList.GetItemN(index: Integer): TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(ObjectByIndex[index]);
end;

function TFhirSpecimenProcessingList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenProcessing;
end;
function TFhirSpecimenProcessingList.IndexOf(value: TFhirSpecimenProcessing): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenProcessingList.Insert(index: Integer): TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenProcessingList.InsertItem(index: Integer; value: TFhirSpecimenProcessing);
begin
  assert(value is TFhirSpecimenProcessing);
  Inherited Insert(index, value);
end;

function TFhirSpecimenProcessingList.Item(index: Integer): TFhirSpecimenProcessing;
begin
  result := TFhirSpecimenProcessing(ObjectByIndex[index]);
end;

function TFhirSpecimenProcessingList.Link: TFhirSpecimenProcessingList;
begin
  result := TFhirSpecimenProcessingList(inherited Link);
end;

procedure TFhirSpecimenProcessingList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenProcessingList.SetItemByIndex(index: Integer; value: TFhirSpecimenProcessing);
begin
  assert(value is TFhirSpecimenProcessing);
  FhirSpecimenProcessings[index] := value;
end;

procedure TFhirSpecimenProcessingList.SetItemN(index: Integer; value: TFhirSpecimenProcessing);
begin
  assert(value is TFhirSpecimenProcessing);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimenContainer }

constructor TFhirSpecimenContainer.Create;
begin
  inherited;
end;

destructor TFhirSpecimenContainer.Destroy;
begin
  FIdentifierList.Free;
  FDescription.free;
  FType_.free;
  FCapacity.free;
  FSpecimenQuantity.free;
  FAdditive.free;
  inherited;
end;

procedure TFhirSpecimenContainer.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSpecimenContainer(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSpecimenContainer(oSource).FIdentifierList);
  end;
  descriptionElement := TFhirSpecimenContainer(oSource).descriptionElement.Clone;
  type_ := TFhirSpecimenContainer(oSource).type_.Clone;
  capacity := TFhirSpecimenContainer(oSource).capacity.Clone;
  specimenQuantity := TFhirSpecimenContainer(oSource).specimenQuantity.Clone;
  additive := TFhirSpecimenContainer(oSource).additive.Clone;
end;

procedure TFhirSpecimenContainer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'capacity') Then
     list.add(self.link, 'capacity', FCapacity.Link);
  if (child_name = 'specimenQuantity') Then
     list.add(self.link, 'specimenQuantity', FSpecimenQuantity.Link);
  if (child_name = 'additive[x]') or (child_name = 'additive') Then
     list.add(self.link, 'additive[x]', FAdditive.Link);
end;

procedure TFhirSpecimenContainer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'capacity', 'Quantity', false, TFhirQuantity, FCapacity.Link));
  oList.add(TFHIRProperty.create(self, 'specimenQuantity', 'Quantity', false, TFhirQuantity, FSpecimenQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'additive[x]', 'CodeableConcept|Reference', false, TFhirDataType, FAdditive.Link));
end;

function TFhirSpecimenContainer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'capacity') then
  begin
    Capacity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'specimenQuantity') then
  begin
    SpecimenQuantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then
  begin
    Additive := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimenContainer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirSpecimenContainer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'capacity') then result := TFhirQuantity.create()
  else if (propName = 'specimenQuantity') then result := TFhirQuantity.create()
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Additive')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimenContainer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'capacity') then result := 'Quantity'
  else if (propName = 'specimenQuantity') then result := 'Quantity'
  else if (propName = 'additive[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimenContainer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'capacity') then CapacityElement := nil
  else if (propName = 'specimenQuantity') then SpecimenQuantityElement := nil
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimenContainer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'capacity') then CapacityElement := new as TFhirQuantity
  else if (propName = 'specimenQuantity') then SpecimenQuantityElement := new as TFhirQuantity
  else if (isMatchingName(propName, 'additive', ['CodeableConcept', 'Reference'])) then AdditiveElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimenContainer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimenContainer.fhirType : string;
begin
  result := 'Specimen.container';
end;

function TFhirSpecimenContainer.Link : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Link);
end;

function TFhirSpecimenContainer.Clone : TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(inherited Clone);
end;

function TFhirSpecimenContainer.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimenContainer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimenContainer)) then
    result := false
  else
  begin
    o := TFhirSpecimenContainer(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(capacityElement, o.capacityElement, true) and 
      compareDeep(specimenQuantityElement, o.specimenQuantityElement, true) and compareDeep(additiveElement, o.additiveElement, true);
  end;
end;

function TFhirSpecimenContainer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDescription) and isEmptyProp(FType_) and isEmptyProp(FCapacity) and isEmptyProp(FSpecimenQuantity) and isEmptyProp(FAdditive);
end;

procedure TFhirSpecimenContainer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('description');
  fields.add('type');
  fields.add('capacity');
  fields.add('specimenQuantity');
  fields.add('additive[x]');
end;

function TFhirSpecimenContainer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirSpecimenContainer.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSpecimenContainer.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSpecimenContainer.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSpecimenContainer.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSpecimenContainer.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSpecimenContainer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSpecimenContainer.SetCapacity(value : TFhirQuantity);
begin
  FCapacity.free;
  FCapacity := value;
end;

procedure TFhirSpecimenContainer.SetSpecimenQuantity(value : TFhirQuantity);
begin
  FSpecimenQuantity.free;
  FSpecimenQuantity := value;
end;

procedure TFhirSpecimenContainer.SetAdditive(value : TFhirDataType);
begin
  FAdditive.free;
  FAdditive := value;
end;

{ TFhirSpecimenContainerListEnumerator }

constructor TFhirSpecimenContainerListEnumerator.Create(list : TFhirSpecimenContainerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenContainerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenContainerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenContainerListEnumerator.GetCurrent : TFhirSpecimenContainer;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenContainerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSpecimenContainerList }

function TFhirSpecimenContainerList.AddItem(value: TFhirSpecimenContainer): TFhirSpecimenContainer;
begin
  assert(value.ClassName = 'TFhirSpecimenContainer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimenContainer');
  add(value);
  result := value;
end;

function TFhirSpecimenContainerList.Append: TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenContainerList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenContainerList.GetEnumerator : TFhirSpecimenContainerListEnumerator;
begin
  result := TFhirSpecimenContainerListEnumerator.Create(self.link);
end;

function TFhirSpecimenContainerList.Clone: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Clone);
end;

function TFhirSpecimenContainerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenContainerList.GetItemN(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimenContainer;
end;
function TFhirSpecimenContainerList.IndexOf(value: TFhirSpecimenContainer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenContainerList.Insert(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenContainerList.InsertItem(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  Inherited Insert(index, value);
end;

function TFhirSpecimenContainerList.Item(index: Integer): TFhirSpecimenContainer;
begin
  result := TFhirSpecimenContainer(ObjectByIndex[index]);
end;

function TFhirSpecimenContainerList.Link: TFhirSpecimenContainerList;
begin
  result := TFhirSpecimenContainerList(inherited Link);
end;

procedure TFhirSpecimenContainerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenContainerList.SetItemByIndex(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  FhirSpecimenContainers[index] := value;
end;

procedure TFhirSpecimenContainerList.SetItemN(index: Integer; value: TFhirSpecimenContainer);
begin
  assert(value is TFhirSpecimenContainer);
  ObjectByIndex[index] := value;
end;

{ TFhirSpecimen }

constructor TFhirSpecimen.Create;
begin
  inherited;
end;

destructor TFhirSpecimen.Destroy;
begin
  FIdentifierList.Free;
  FAccessionIdentifier.free;
  FStatus.free;
  FType_.free;
  FSubject.free;
  FReceivedTime.free;
  FParentList.Free;
  FRequestList.Free;
  FCollection.free;
  FProcessingList.Free;
  FContainerList.Free;
  FConditionList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirSpecimen.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSpecimen(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSpecimen(oSource).FIdentifierList);
  end;
  accessionIdentifier := TFhirSpecimen(oSource).accessionIdentifier.Clone;
  statusElement := TFhirSpecimen(oSource).statusElement.Clone;
  type_ := TFhirSpecimen(oSource).type_.Clone;
  subject := TFhirSpecimen(oSource).subject.Clone;
  receivedTimeElement := TFhirSpecimen(oSource).receivedTimeElement.Clone;
  if (TFhirSpecimen(oSource).FParentList = nil) then
  begin
    FParentList.free;
    FParentList := nil;
  end
  else
  begin
    if FParentList = nil then
      FParentList := TFhirReferenceList.Create;
    FParentList.Assign(TFhirSpecimen(oSource).FParentList);
  end;
  if (TFhirSpecimen(oSource).FRequestList = nil) then
  begin
    FRequestList.free;
    FRequestList := nil;
  end
  else
  begin
    if FRequestList = nil then
      FRequestList := TFhirReferenceList.Create;
    FRequestList.Assign(TFhirSpecimen(oSource).FRequestList);
  end;
  collection := TFhirSpecimen(oSource).collection.Clone;
  if (TFhirSpecimen(oSource).FProcessingList = nil) then
  begin
    FProcessingList.free;
    FProcessingList := nil;
  end
  else
  begin
    if FProcessingList = nil then
      FProcessingList := TFhirSpecimenProcessingList.Create;
    FProcessingList.Assign(TFhirSpecimen(oSource).FProcessingList);
  end;
  if (TFhirSpecimen(oSource).FContainerList = nil) then
  begin
    FContainerList.free;
    FContainerList := nil;
  end
  else
  begin
    if FContainerList = nil then
      FContainerList := TFhirSpecimenContainerList.Create;
    FContainerList.Assign(TFhirSpecimen(oSource).FContainerList);
  end;
  if (TFhirSpecimen(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirCodeableConceptList.Create;
    FConditionList.Assign(TFhirSpecimen(oSource).FConditionList);
  end;
  if (TFhirSpecimen(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirSpecimen(oSource).FNoteList);
  end;
end;

function TFhirSpecimen.GetResourceType : TFhirResourceType;
begin
  result := frtSpecimen;
end;

procedure TFhirSpecimen.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'accessionIdentifier') Then
     list.add(self.link, 'accessionIdentifier', FAccessionIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'receivedTime') Then
     list.add(self.link, 'receivedTime', FReceivedTime.Link);
  if (child_name = 'parent') Then
    list.addAll(self, 'parent', FParentList);
  if (child_name = 'request') Then
    list.addAll(self, 'request', FRequestList);
  if (child_name = 'collection') Then
     list.add(self.link, 'collection', FCollection.Link);
  if (child_name = 'processing') Then
    list.addAll(self, 'processing', FProcessingList);
  if (child_name = 'container') Then
    list.addAll(self, 'container', FContainerList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirSpecimen.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'accessionIdentifier', 'Identifier', false, TFhirIdentifier, FAccessionIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'receivedTime', 'dateTime', false, TFhirDateTime, FReceivedTime.Link));
  oList.add(TFHIRProperty.create(self, 'parent', 'Reference', true, TFhirReference, FParentList.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'Reference', true, TFhirReference, FRequestList.Link));
  oList.add(TFHIRProperty.create(self, 'collection', 'BackboneElement', false, TFhirSpecimenCollection, FCollection.Link));
  oList.add(TFHIRProperty.create(self, 'processing', 'BackboneElement', true, TFhirSpecimenProcessing, FProcessingList.Link));
  oList.add(TFHIRProperty.create(self, 'container', 'BackboneElement', true, TFhirSpecimenContainer, FContainerList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'CodeableConcept', true, TFhirCodeableConcept, FConditionList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirSpecimen.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'accessionIdentifier') then
  begin
    AccessionIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSpecimenStatusEnum, CODES_TFhirSpecimenStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'receivedTime') then
  begin
    ReceivedTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    ParentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    RequestList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'collection') then
  begin
    Collection := propValue as TFhirSpecimenCollection;
    result := propValue;
  end
  else if (propName = 'processing') then
  begin
    ProcessingList.add(propValue as TFhirSpecimenProcessing);
    result := propValue;
  end
  else if (propName = 'container') then
  begin
    ContainerList.add(propValue as TFhirSpecimenContainer);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSpecimen.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'parent') then ParentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'request') then RequestList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'processing') then ProcessingList.insertItem(index, propValue as TFhirSpecimenProcessing)
  else if (propName = 'container') then ContainerList.insertItem(index, propValue as TFhirSpecimenContainer)
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirSpecimen.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'accessionIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSpecimenStatusEnum[SpecimenStatusNull], CODES_TFhirSpecimenStatusEnum[SpecimenStatusNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'receivedTime') then result := TFhirDateTime.create()
  else if (propName = 'parent') then result := ParentList.new()
  else if (propName = 'request') then result := RequestList.new()
  else if (propName = 'collection') then result := TFhirSpecimenCollection.create()
  else if (propName = 'processing') then result := ProcessingList.new()
  else if (propName = 'container') then result := ContainerList.new()
  else if (propName = 'condition') then result := ConditionList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSpecimen.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'accessionIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'receivedTime') then result := 'dateTime'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'request') then result := 'Reference'
  else if (propName = 'collection') then result := 'BackboneElement'
  else if (propName = 'processing') then result := 'BackboneElement'
  else if (propName = 'container') then result := 'BackboneElement'
  else if (propName = 'condition') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSpecimen.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'accessionIdentifier') then AccessionIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'receivedTime') then ReceivedTimeElement := nil
  else if (propName = 'parent') then deletePropertyValue('parent', ParentList, value)
  else if (propName = 'request') then deletePropertyValue('request', RequestList, value)
  else if (propName = 'collection') then CollectionElement := nil
  else if (propName = 'processing') then deletePropertyValue('processing', ProcessingList, value)
  else if (propName = 'container') then deletePropertyValue('container', ContainerList, value)
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSpecimen.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'accessionIdentifier') then AccessionIdentifierElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSpecimenStatusEnum, CODES_TFhirSpecimenStatusEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'receivedTime') then ReceivedTimeElement := asDateTime(new)
  else if (propName = 'parent') then replacePropertyValue('parent', ParentList, existing, new)
  else if (propName = 'request') then replacePropertyValue('request', RequestList, existing, new)
  else if (propName = 'collection') then CollectionElement := new as TFhirSpecimenCollection
  else if (propName = 'processing') then replacePropertyValue('processing', ProcessingList, existing, new)
  else if (propName = 'container') then replacePropertyValue('container', ContainerList, existing, new)
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSpecimen.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'parent') then ParentList.move(source, destination)
  else if (propName = 'request') then RequestList.move(source, destination)
  else if (propName = 'processing') then ProcessingList.move(source, destination)
  else if (propName = 'container') then ContainerList.move(source, destination)
  else if (propName = 'condition') then ConditionList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSpecimen.fhirType : string;
begin
  result := 'Specimen';
end;

function TFhirSpecimen.Link : TFhirSpecimen;
begin
  result := TFhirSpecimen(inherited Link);
end;

function TFhirSpecimen.Clone : TFhirSpecimen;
begin
  result := TFhirSpecimen(inherited Clone);
end;

function TFhirSpecimen.equals(other : TObject) : boolean; 
var
  o : TFhirSpecimen;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSpecimen)) then
    result := false
  else
  begin
    o := TFhirSpecimen(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(accessionIdentifierElement, o.accessionIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(receivedTimeElement, o.receivedTimeElement, true) and 
      compareDeep(parentList, o.parentList, true) and compareDeep(requestList, o.requestList, true) and 
      compareDeep(collectionElement, o.collectionElement, true) and compareDeep(processingList, o.processingList, true) and 
      compareDeep(containerList, o.containerList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirSpecimen.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FAccessionIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FSubject) and isEmptyProp(FReceivedTime) and isEmptyProp(FparentList) and isEmptyProp(FrequestList) and isEmptyProp(FCollection) and isEmptyProp(FprocessingList) and isEmptyProp(FcontainerList) and isEmptyProp(FconditionList) and isEmptyProp(FnoteList);
end;

procedure TFhirSpecimen.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('accessionIdentifier');
  fields.add('status');
  fields.add('type');
  fields.add('subject');
  fields.add('receivedTime');
  fields.add('parent');
  fields.add('request');
  fields.add('collection');
  fields.add('processing');
  fields.add('container');
  fields.add('condition');
  fields.add('note');
end;

function TFhirSpecimen.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FParentList.sizeInBytes(magic));
  inc(result, FRequestList.sizeInBytes(magic));
  inc(result, FProcessingList.sizeInBytes(magic));
  inc(result, FContainerList.sizeInBytes(magic));
  inc(result, FConditionList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirSpecimen.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSpecimen.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSpecimen.SetAccessionIdentifier(value : TFhirIdentifier);
begin
  FAccessionIdentifier.free;
  FAccessionIdentifier := value;
end;

procedure TFhirSpecimen.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSpecimen.GetStatusST : TFhirSpecimenStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSpecimenStatusEnum(0)
  else
    result := TFhirSpecimenStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSpecimenStatusEnum, FStatus.value));
end;

procedure TFhirSpecimen.SetStatusST(value : TFhirSpecimenStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSpecimenStatusEnum[value], CODES_TFhirSpecimenStatusEnum[value]);
end;

procedure TFhirSpecimen.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSpecimen.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirSpecimen.SetReceivedTime(value : TFhirDateTime);
begin
  FReceivedTime.free;
  FReceivedTime := value;
end;

function TFhirSpecimen.GetReceivedTimeST : TFslDateTime;
begin
  if FReceivedTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FReceivedTime.value;
end;

procedure TFhirSpecimen.SetReceivedTimeST(value : TFslDateTime);
begin
  if FReceivedTime = nil then
    FReceivedTime := TFhirDateTime.create;
  FReceivedTime.value := value
end;

function TFhirSpecimen.GetParentList : TFhirReferenceList;
begin
  if FParentList = nil then
    FParentList := TFhirReferenceList.Create;
  result := FParentList;
end;

function TFhirSpecimen.GetHasParentList : boolean;
begin
  result := (FParentList <> nil) and (FParentList.count > 0);
end;

function TFhirSpecimen.GetRequestList : TFhirReferenceList;
begin
  if FRequestList = nil then
    FRequestList := TFhirReferenceList.Create;
  result := FRequestList;
end;

function TFhirSpecimen.GetHasRequestList : boolean;
begin
  result := (FRequestList <> nil) and (FRequestList.count > 0);
end;

procedure TFhirSpecimen.SetCollection(value : TFhirSpecimenCollection);
begin
  FCollection.free;
  FCollection := value;
end;

function TFhirSpecimen.GetProcessingList : TFhirSpecimenProcessingList;
begin
  if FProcessingList = nil then
    FProcessingList := TFhirSpecimenProcessingList.Create;
  result := FProcessingList;
end;

function TFhirSpecimen.GetHasProcessingList : boolean;
begin
  result := (FProcessingList <> nil) and (FProcessingList.count > 0);
end;

function TFhirSpecimen.GetContainerList : TFhirSpecimenContainerList;
begin
  if FContainerList = nil then
    FContainerList := TFhirSpecimenContainerList.Create;
  result := FContainerList;
end;

function TFhirSpecimen.GetHasContainerList : boolean;
begin
  result := (FContainerList <> nil) and (FContainerList.count > 0);
end;

function TFhirSpecimen.GetConditionList : TFhirCodeableConceptList;
begin
  if FConditionList = nil then
    FConditionList := TFhirCodeableConceptList.Create;
  result := FConditionList;
end;

function TFhirSpecimen.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirSpecimen.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirSpecimen.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirSpecimenListEnumerator }

constructor TFhirSpecimenListEnumerator.Create(list : TFhirSpecimenList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSpecimenListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSpecimenListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSpecimenListEnumerator.GetCurrent : TFhirSpecimen;
begin
  Result := FList[FIndex];
end;

function TFhirSpecimenListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSpecimenList }

function TFhirSpecimenList.AddItem(value: TFhirSpecimen): TFhirSpecimen;
begin
  assert(value.ClassName = 'TFhirSpecimen', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSpecimen');
  add(value);
  result := value;
end;

function TFhirSpecimenList.Append: TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenList.ClearItems;
begin
  Clear;
end;

function TFhirSpecimenList.GetEnumerator : TFhirSpecimenListEnumerator;
begin
  result := TFhirSpecimenListEnumerator.Create(self.link);
end;

function TFhirSpecimenList.Clone: TFhirSpecimenList;
begin
  result := TFhirSpecimenList(inherited Clone);
end;

function TFhirSpecimenList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSpecimenList.GetItemN(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen(ObjectByIndex[index]);
end;

function TFhirSpecimenList.ItemClass: TFslObjectClass;
begin
  result := TFhirSpecimen;
end;
function TFhirSpecimenList.IndexOf(value: TFhirSpecimen): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSpecimenList.Insert(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSpecimenList.InsertItem(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  Inherited Insert(index, value);
end;

function TFhirSpecimenList.Item(index: Integer): TFhirSpecimen;
begin
  result := TFhirSpecimen(ObjectByIndex[index]);
end;

function TFhirSpecimenList.Link: TFhirSpecimenList;
begin
  result := TFhirSpecimenList(inherited Link);
end;

procedure TFhirSpecimenList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSpecimenList.SetItemByIndex(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  FhirSpecimen[index] := value;
end;

procedure TFhirSpecimenList.SetItemN(index: Integer; value: TFhirSpecimen);
begin
  assert(value is TFhirSpecimen);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SPECIMEN}
{$IFDEF FHIR_SUPPLYDELIVERY}
{ TFhirSupplyDeliverySuppliedItem }

constructor TFhirSupplyDeliverySuppliedItem.Create;
begin
  inherited;
end;

destructor TFhirSupplyDeliverySuppliedItem.Destroy;
begin
  FQuantity.free;
  FItem.free;
  inherited;
end;

procedure TFhirSupplyDeliverySuppliedItem.Assign(oSource : TFslObject);
begin
  inherited;
  quantity := TFhirSupplyDeliverySuppliedItem(oSource).quantity.Clone;
  item := TFhirSupplyDeliverySuppliedItem(oSource).item.Clone;
end;

procedure TFhirSupplyDeliverySuppliedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
end;

procedure TFhirSupplyDeliverySuppliedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference', false, TFhirDataType, FItem.Link));
end;

function TFhirSupplyDeliverySuppliedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyDeliverySuppliedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSupplyDeliverySuppliedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyDeliverySuppliedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyDeliverySuppliedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := nil
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyDeliverySuppliedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyDeliverySuppliedItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyDeliverySuppliedItem.fhirType : string;
begin
  result := 'SupplyDelivery.suppliedItem';
end;

function TFhirSupplyDeliverySuppliedItem.Link : TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(inherited Link);
end;

function TFhirSupplyDeliverySuppliedItem.Clone : TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(inherited Clone);
end;

function TFhirSupplyDeliverySuppliedItem.equals(other : TObject) : boolean; 
var
  o : TFhirSupplyDeliverySuppliedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyDeliverySuppliedItem)) then
    result := false
  else
  begin
    o := TFhirSupplyDeliverySuppliedItem(other);
    result := compareDeep(quantityElement, o.quantityElement, true) and compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirSupplyDeliverySuppliedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FQuantity) and isEmptyProp(FItem);
end;

procedure TFhirSupplyDeliverySuppliedItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('quantity');
  fields.add('item[x]');
end;

function TFhirSupplyDeliverySuppliedItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSupplyDeliverySuppliedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirSupplyDeliverySuppliedItem.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value;
end;

{ TFhirSupplyDeliverySuppliedItemListEnumerator }

constructor TFhirSupplyDeliverySuppliedItemListEnumerator.Create(list : TFhirSupplyDeliverySuppliedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyDeliverySuppliedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyDeliverySuppliedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyDeliverySuppliedItemListEnumerator.GetCurrent : TFhirSupplyDeliverySuppliedItem;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyDeliverySuppliedItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSupplyDeliverySuppliedItemList }

function TFhirSupplyDeliverySuppliedItemList.AddItem(value: TFhirSupplyDeliverySuppliedItem): TFhirSupplyDeliverySuppliedItem;
begin
  assert(value.ClassName = 'TFhirSupplyDeliverySuppliedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDeliverySuppliedItem');
  add(value);
  result := value;
end;

function TFhirSupplyDeliverySuppliedItemList.Append: TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliverySuppliedItemList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDeliverySuppliedItemList.GetEnumerator : TFhirSupplyDeliverySuppliedItemListEnumerator;
begin
  result := TFhirSupplyDeliverySuppliedItemListEnumerator.Create(self.link);
end;

function TFhirSupplyDeliverySuppliedItemList.Clone: TFhirSupplyDeliverySuppliedItemList;
begin
  result := TFhirSupplyDeliverySuppliedItemList(inherited Clone);
end;

function TFhirSupplyDeliverySuppliedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDeliverySuppliedItemList.GetItemN(index: Integer): TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(ObjectByIndex[index]);
end;

function TFhirSupplyDeliverySuppliedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyDeliverySuppliedItem;
end;
function TFhirSupplyDeliverySuppliedItemList.IndexOf(value: TFhirSupplyDeliverySuppliedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyDeliverySuppliedItemList.Insert(index: Integer): TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliverySuppliedItemList.InsertItem(index: Integer; value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value is TFhirSupplyDeliverySuppliedItem);
  Inherited Insert(index, value);
end;

function TFhirSupplyDeliverySuppliedItemList.Item(index: Integer): TFhirSupplyDeliverySuppliedItem;
begin
  result := TFhirSupplyDeliverySuppliedItem(ObjectByIndex[index]);
end;

function TFhirSupplyDeliverySuppliedItemList.Link: TFhirSupplyDeliverySuppliedItemList;
begin
  result := TFhirSupplyDeliverySuppliedItemList(inherited Link);
end;

procedure TFhirSupplyDeliverySuppliedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDeliverySuppliedItemList.SetItemByIndex(index: Integer; value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value is TFhirSupplyDeliverySuppliedItem);
  FhirSupplyDeliverySuppliedItems[index] := value;
end;

procedure TFhirSupplyDeliverySuppliedItemList.SetItemN(index: Integer; value: TFhirSupplyDeliverySuppliedItem);
begin
  assert(value is TFhirSupplyDeliverySuppliedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyDelivery }

constructor TFhirSupplyDelivery.Create;
begin
  inherited;
end;

destructor TFhirSupplyDelivery.Destroy;
begin
  FIdentifierList.Free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FStatus.free;
  FPatient.free;
  FType_.free;
  FSuppliedItem.free;
  FOccurrence.free;
  FSupplier.free;
  FDestination.free;
  FReceiverList.Free;
  inherited;
end;

procedure TFhirSupplyDelivery.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSupplyDelivery(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSupplyDelivery(oSource).FIdentifierList);
  end;
  if (TFhirSupplyDelivery(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirSupplyDelivery(oSource).FBasedOnList);
  end;
  if (TFhirSupplyDelivery(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirSupplyDelivery(oSource).FPartOfList);
  end;
  statusElement := TFhirSupplyDelivery(oSource).statusElement.Clone;
  patient := TFhirSupplyDelivery(oSource).patient.Clone;
  type_ := TFhirSupplyDelivery(oSource).type_.Clone;
  suppliedItem := TFhirSupplyDelivery(oSource).suppliedItem.Clone;
  occurrence := TFhirSupplyDelivery(oSource).occurrence.Clone;
  supplier := TFhirSupplyDelivery(oSource).supplier.Clone;
  destination := TFhirSupplyDelivery(oSource).destination.Clone;
  if (TFhirSupplyDelivery(oSource).FReceiverList = nil) then
  begin
    FReceiverList.free;
    FReceiverList := nil;
  end
  else
  begin
    if FReceiverList = nil then
      FReceiverList := TFhirReferenceList.Create;
    FReceiverList.Assign(TFhirSupplyDelivery(oSource).FReceiverList);
  end;
end;

function TFhirSupplyDelivery.GetResourceType : TFhirResourceType;
begin
  result := frtSupplyDelivery;
end;

procedure TFhirSupplyDelivery.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'suppliedItem') Then
     list.add(self.link, 'suppliedItem', FSuppliedItem.Link);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'supplier') Then
     list.add(self.link, 'supplier', FSupplier.Link);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'receiver') Then
    list.addAll(self, 'receiver', FReceiverList);
end;

procedure TFhirSupplyDelivery.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'suppliedItem', 'BackboneElement', false, TFhirSupplyDeliverySuppliedItem, FSuppliedItem.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference', false, TFhirReference, FSupplier.Link));
  oList.add(TFHIRProperty.create(self, 'destination', 'Reference', false, TFhirReference, FDestination.Link));
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference', true, TFhirReference, FReceiverList.Link));
end;

function TFhirSupplyDelivery.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSupplyDeliveryStatusEnum, CODES_TFhirSupplyDeliveryStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'suppliedItem') then
  begin
    SuppliedItem := propValue as TFhirSupplyDeliverySuppliedItem;
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    Supplier := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    ReceiverList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyDelivery.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'receiver') then ReceiverList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSupplyDelivery.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSupplyDeliveryStatusEnum[SupplyDeliveryStatusNull], CODES_TFhirSupplyDeliveryStatusEnum[SupplyDeliveryStatusNull]) 
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'suppliedItem') then result := TFhirSupplyDeliverySuppliedItem.create()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (propName = 'supplier') then result := TFhirReference.create()
  else if (propName = 'destination') then result := TFhirReference.create()
  else if (propName = 'receiver') then result := ReceiverList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyDelivery.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'suppliedItem') then result := 'BackboneElement'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'receiver') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyDelivery.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'suppliedItem') then SuppliedItemElement := nil
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil
  else if (propName = 'supplier') then SupplierElement := nil
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'receiver') then deletePropertyValue('receiver', ReceiverList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyDelivery.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSupplyDeliveryStatusEnum, CODES_TFhirSupplyDeliveryStatusEnum, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'suppliedItem') then SuppliedItemElement := new as TFhirSupplyDeliverySuppliedItem
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType
  else if (propName = 'supplier') then SupplierElement := new as TFhirReference
  else if (propName = 'destination') then DestinationElement := new as TFhirReference
  else if (propName = 'receiver') then replacePropertyValue('receiver', ReceiverList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyDelivery.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'receiver') then ReceiverList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyDelivery.fhirType : string;
begin
  result := 'SupplyDelivery';
end;

function TFhirSupplyDelivery.Link : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(inherited Link);
end;

function TFhirSupplyDelivery.Clone : TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(inherited Clone);
end;

function TFhirSupplyDelivery.equals(other : TObject) : boolean; 
var
  o : TFhirSupplyDelivery;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyDelivery)) then
    result := false
  else
  begin
    o := TFhirSupplyDelivery(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(suppliedItemElement, o.suppliedItemElement, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(supplierElement, o.supplierElement, true) and compareDeep(destinationElement, o.destinationElement, true) and 
      compareDeep(receiverList, o.receiverList, true);
  end;
end;

function TFhirSupplyDelivery.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FPatient) and isEmptyProp(FType_) and isEmptyProp(FSuppliedItem) and isEmptyProp(FOccurrence) and isEmptyProp(FSupplier) and isEmptyProp(FDestination) and isEmptyProp(FreceiverList);
end;

procedure TFhirSupplyDelivery.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('patient');
  fields.add('type');
  fields.add('suppliedItem');
  fields.add('occurrence[x]');
  fields.add('supplier');
  fields.add('destination');
  fields.add('receiver');
end;

function TFhirSupplyDelivery.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FReceiverList.sizeInBytes(magic));
end;

function TFhirSupplyDelivery.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSupplyDelivery.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirSupplyDelivery.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirSupplyDelivery.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirSupplyDelivery.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirSupplyDelivery.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirSupplyDelivery.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSupplyDelivery.GetStatusST : TFhirSupplyDeliveryStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSupplyDeliveryStatusEnum(0)
  else
    result := TFhirSupplyDeliveryStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSupplyDeliveryStatusEnum, FStatus.value));
end;

procedure TFhirSupplyDelivery.SetStatusST(value : TFhirSupplyDeliveryStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSupplyDeliveryStatusEnum[value], CODES_TFhirSupplyDeliveryStatusEnum[value]);
end;

procedure TFhirSupplyDelivery.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirSupplyDelivery.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirSupplyDelivery.SetSuppliedItem(value : TFhirSupplyDeliverySuppliedItem);
begin
  FSuppliedItem.free;
  FSuppliedItem := value;
end;

procedure TFhirSupplyDelivery.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

procedure TFhirSupplyDelivery.SetSupplier(value : TFhirReference);
begin
  FSupplier.free;
  FSupplier := value;
end;

procedure TFhirSupplyDelivery.SetDestination(value : TFhirReference);
begin
  FDestination.free;
  FDestination := value;
end;

function TFhirSupplyDelivery.GetReceiverList : TFhirReferenceList;
begin
  if FReceiverList = nil then
    FReceiverList := TFhirReferenceList.Create;
  result := FReceiverList;
end;

function TFhirSupplyDelivery.GetHasReceiverList : boolean;
begin
  result := (FReceiverList <> nil) and (FReceiverList.count > 0);
end;

{ TFhirSupplyDeliveryListEnumerator }

constructor TFhirSupplyDeliveryListEnumerator.Create(list : TFhirSupplyDeliveryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyDeliveryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyDeliveryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyDeliveryListEnumerator.GetCurrent : TFhirSupplyDelivery;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyDeliveryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSupplyDeliveryList }

function TFhirSupplyDeliveryList.AddItem(value: TFhirSupplyDelivery): TFhirSupplyDelivery;
begin
  assert(value.ClassName = 'TFhirSupplyDelivery', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyDelivery');
  add(value);
  result := value;
end;

function TFhirSupplyDeliveryList.Append: TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliveryList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyDeliveryList.GetEnumerator : TFhirSupplyDeliveryListEnumerator;
begin
  result := TFhirSupplyDeliveryListEnumerator.Create(self.link);
end;

function TFhirSupplyDeliveryList.Clone: TFhirSupplyDeliveryList;
begin
  result := TFhirSupplyDeliveryList(inherited Clone);
end;

function TFhirSupplyDeliveryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyDeliveryList.GetItemN(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(ObjectByIndex[index]);
end;

function TFhirSupplyDeliveryList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyDelivery;
end;
function TFhirSupplyDeliveryList.IndexOf(value: TFhirSupplyDelivery): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyDeliveryList.Insert(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyDeliveryList.InsertItem(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  Inherited Insert(index, value);
end;

function TFhirSupplyDeliveryList.Item(index: Integer): TFhirSupplyDelivery;
begin
  result := TFhirSupplyDelivery(ObjectByIndex[index]);
end;

function TFhirSupplyDeliveryList.Link: TFhirSupplyDeliveryList;
begin
  result := TFhirSupplyDeliveryList(inherited Link);
end;

procedure TFhirSupplyDeliveryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyDeliveryList.SetItemByIndex(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  FhirSupplyDeliveries[index] := value;
end;

procedure TFhirSupplyDeliveryList.SetItemN(index: Integer; value: TFhirSupplyDelivery);
begin
  assert(value is TFhirSupplyDelivery);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUPPLYDELIVERY}
{$IFDEF FHIR_SUPPLYREQUEST}
{ TFhirSupplyRequestParameter }

constructor TFhirSupplyRequestParameter.Create;
begin
  inherited;
end;

destructor TFhirSupplyRequestParameter.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirSupplyRequestParameter.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirSupplyRequestParameter(oSource).code.Clone;
  value := TFhirSupplyRequestParameter(oSource).value.Clone;
end;

procedure TFhirSupplyRequestParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirSupplyRequestParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|Range|boolean', false, TFhirDataType, FValue.Link));
end;

function TFhirSupplyRequestParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyRequestParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSupplyRequestParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyRequestParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|Range|boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyRequestParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyRequestParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range', 'Boolean'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyRequestParameter.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyRequestParameter.fhirType : string;
begin
  result := 'SupplyRequest.parameter';
end;

function TFhirSupplyRequestParameter.Link : TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter(inherited Link);
end;

function TFhirSupplyRequestParameter.Clone : TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter(inherited Clone);
end;

function TFhirSupplyRequestParameter.equals(other : TObject) : boolean; 
var
  o : TFhirSupplyRequestParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyRequestParameter)) then
    result := false
  else
  begin
    o := TFhirSupplyRequestParameter(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirSupplyRequestParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirSupplyRequestParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
end;

function TFhirSupplyRequestParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSupplyRequestParameter.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirSupplyRequestParameter.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirSupplyRequestParameterListEnumerator }

constructor TFhirSupplyRequestParameterListEnumerator.Create(list : TFhirSupplyRequestParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyRequestParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyRequestParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyRequestParameterListEnumerator.GetCurrent : TFhirSupplyRequestParameter;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyRequestParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSupplyRequestParameterList }

function TFhirSupplyRequestParameterList.AddItem(value: TFhirSupplyRequestParameter): TFhirSupplyRequestParameter;
begin
  assert(value.ClassName = 'TFhirSupplyRequestParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyRequestParameter');
  add(value);
  result := value;
end;

function TFhirSupplyRequestParameterList.Append: TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestParameterList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyRequestParameterList.GetEnumerator : TFhirSupplyRequestParameterListEnumerator;
begin
  result := TFhirSupplyRequestParameterListEnumerator.Create(self.link);
end;

function TFhirSupplyRequestParameterList.Clone: TFhirSupplyRequestParameterList;
begin
  result := TFhirSupplyRequestParameterList(inherited Clone);
end;

function TFhirSupplyRequestParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyRequestParameterList.GetItemN(index: Integer): TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter(ObjectByIndex[index]);
end;

function TFhirSupplyRequestParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyRequestParameter;
end;
function TFhirSupplyRequestParameterList.IndexOf(value: TFhirSupplyRequestParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyRequestParameterList.Insert(index: Integer): TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestParameterList.InsertItem(index: Integer; value: TFhirSupplyRequestParameter);
begin
  assert(value is TFhirSupplyRequestParameter);
  Inherited Insert(index, value);
end;

function TFhirSupplyRequestParameterList.Item(index: Integer): TFhirSupplyRequestParameter;
begin
  result := TFhirSupplyRequestParameter(ObjectByIndex[index]);
end;

function TFhirSupplyRequestParameterList.Link: TFhirSupplyRequestParameterList;
begin
  result := TFhirSupplyRequestParameterList(inherited Link);
end;

procedure TFhirSupplyRequestParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyRequestParameterList.SetItemByIndex(index: Integer; value: TFhirSupplyRequestParameter);
begin
  assert(value is TFhirSupplyRequestParameter);
  FhirSupplyRequestParameters[index] := value;
end;

procedure TFhirSupplyRequestParameterList.SetItemN(index: Integer; value: TFhirSupplyRequestParameter);
begin
  assert(value is TFhirSupplyRequestParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirSupplyRequest }

constructor TFhirSupplyRequest.Create;
begin
  inherited;
end;

destructor TFhirSupplyRequest.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCategory.free;
  FPriority.free;
  FItem.free;
  FQuantity.free;
  FParameterList.Free;
  FOccurrence.free;
  FAuthoredOn.free;
  FRequester.free;
  FSupplierList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FDeliverFrom.free;
  FDeliverTo.free;
  inherited;
end;

procedure TFhirSupplyRequest.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSupplyRequest(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSupplyRequest(oSource).FIdentifierList);
  end;
  statusElement := TFhirSupplyRequest(oSource).statusElement.Clone;
  category := TFhirSupplyRequest(oSource).category.Clone;
  priorityElement := TFhirSupplyRequest(oSource).priorityElement.Clone;
  item := TFhirSupplyRequest(oSource).item.Clone;
  quantity := TFhirSupplyRequest(oSource).quantity.Clone;
  if (TFhirSupplyRequest(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirSupplyRequestParameterList.Create;
    FParameterList.Assign(TFhirSupplyRequest(oSource).FParameterList);
  end;
  occurrence := TFhirSupplyRequest(oSource).occurrence.Clone;
  authoredOnElement := TFhirSupplyRequest(oSource).authoredOnElement.Clone;
  requester := TFhirSupplyRequest(oSource).requester.Clone;
  if (TFhirSupplyRequest(oSource).FSupplierList = nil) then
  begin
    FSupplierList.free;
    FSupplierList := nil;
  end
  else
  begin
    if FSupplierList = nil then
      FSupplierList := TFhirReferenceList.Create;
    FSupplierList.Assign(TFhirSupplyRequest(oSource).FSupplierList);
  end;
  if (TFhirSupplyRequest(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirSupplyRequest(oSource).FReasonCodeList);
  end;
  if (TFhirSupplyRequest(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirSupplyRequest(oSource).FReasonReferenceList);
  end;
  deliverFrom := TFhirSupplyRequest(oSource).deliverFrom.Clone;
  deliverTo := TFhirSupplyRequest(oSource).deliverTo.Clone;
end;

function TFhirSupplyRequest.GetResourceType : TFhirResourceType;
begin
  result := frtSupplyRequest;
end;

procedure TFhirSupplyRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'item[x]') or (child_name = 'item') Then
     list.add(self.link, 'item[x]', FItem.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'supplier') Then
    list.addAll(self, 'supplier', FSupplierList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'deliverFrom') Then
     list.add(self.link, 'deliverFrom', FDeliverFrom.Link);
  if (child_name = 'deliverTo') Then
     list.add(self.link, 'deliverTo', FDeliverTo.Link);
end;

procedure TFhirSupplyRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'item[x]', 'CodeableConcept|Reference', false, TFhirDataType, FItem.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirSupplyRequestParameter, FParameterList.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link));
  oList.add(TFHIRProperty.create(self, 'supplier', 'Reference', true, TFhirReference, FSupplierList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'deliverFrom', 'Reference', false, TFhirReference, FDeliverFrom.Link));
  oList.add(TFHIRProperty.create(self, 'deliverTo', 'Reference', false, TFhirReference, FDeliverTo.Link));
end;

function TFhirSupplyRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSupplyRequestStatusEnum, CODES_TFhirSupplyRequestStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then
  begin
    Item := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirSupplyRequestParameter);
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'supplier') then
  begin
    SupplierList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'deliverFrom') then
  begin
    DeliverFrom := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'deliverTo') then
  begin
    DeliverTo := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSupplyRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirSupplyRequestParameter)
  else if (propName = 'supplier') then SupplierList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSupplyRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSupplyRequestStatusEnum[SupplyRequestStatusNull], CODES_TFhirSupplyRequestStatusEnum[SupplyRequestStatusNull]) 
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Item')
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'parameter') then result := ParameterList.new()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'requester') then result := TFhirReference.create()
  else if (propName = 'supplier') then result := SupplierList.new()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'deliverFrom') then result := TFhirReference.create()
  else if (propName = 'deliverTo') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSupplyRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'item[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'parameter') then result := 'BackboneElement'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'supplier') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'deliverFrom') then result := 'Reference'
  else if (propName = 'deliverTo') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSupplyRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'supplier') then deletePropertyValue('supplier', SupplierList, value)
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'deliverFrom') then DeliverFromElement := nil
  else if (propName = 'deliverTo') then DeliverToElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSupplyRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSupplyRequestStatusEnum, CODES_TFhirSupplyRequestStatusEnum, new)
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (isMatchingName(propName, 'item', ['CodeableConcept', 'Reference'])) then ItemElement := new as TFhirDataType
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'requester') then RequesterElement := new as TFhirReference
  else if (propName = 'supplier') then replacePropertyValue('supplier', SupplierList, existing, new)
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'deliverFrom') then DeliverFromElement := new as TFhirReference
  else if (propName = 'deliverTo') then DeliverToElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSupplyRequest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'parameter') then ParameterList.move(source, destination)
  else if (propName = 'supplier') then SupplierList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSupplyRequest.fhirType : string;
begin
  result := 'SupplyRequest';
end;

function TFhirSupplyRequest.Link : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(inherited Link);
end;

function TFhirSupplyRequest.Clone : TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(inherited Clone);
end;

function TFhirSupplyRequest.equals(other : TObject) : boolean; 
var
  o : TFhirSupplyRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSupplyRequest)) then
    result := false
  else
  begin
    o := TFhirSupplyRequest(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(categoryElement, o.categoryElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(itemElement, o.itemElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(parameterList, o.parameterList, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(supplierList, o.supplierList, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(deliverFromElement, o.deliverFromElement, true) and 
      compareDeep(deliverToElement, o.deliverToElement, true);
  end;
end;

function TFhirSupplyRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCategory) and isEmptyProp(FPriority) and isEmptyProp(FItem) and isEmptyProp(FQuantity) and isEmptyProp(FparameterList) and isEmptyProp(FOccurrence) and isEmptyProp(FAuthoredOn) and isEmptyProp(FRequester) and isEmptyProp(FsupplierList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FDeliverFrom) and isEmptyProp(FDeliverTo);
end;

procedure TFhirSupplyRequest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('category');
  fields.add('priority');
  fields.add('item[x]');
  fields.add('quantity');
  fields.add('parameter');
  fields.add('occurrence[x]');
  fields.add('authoredOn');
  fields.add('requester');
  fields.add('supplier');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('deliverFrom');
  fields.add('deliverTo');
end;

function TFhirSupplyRequest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FParameterList.sizeInBytes(magic));
  inc(result, FSupplierList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
end;

function TFhirSupplyRequest.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSupplyRequest.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSupplyRequest.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSupplyRequest.GetStatusST : TFhirSupplyRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSupplyRequestStatusEnum(0)
  else
    result := TFhirSupplyRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSupplyRequestStatusEnum, FStatus.value));
end;

procedure TFhirSupplyRequest.SetStatusST(value : TFhirSupplyRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSupplyRequestStatusEnum[value], CODES_TFhirSupplyRequestStatusEnum[value]);
end;

procedure TFhirSupplyRequest.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirSupplyRequest.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirSupplyRequest.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirSupplyRequest.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirSupplyRequest.SetItem(value : TFhirDataType);
begin
  FItem.free;
  FItem := value;
end;

procedure TFhirSupplyRequest.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirSupplyRequest.GetParameterList : TFhirSupplyRequestParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirSupplyRequestParameterList.Create;
  result := FParameterList;
end;

function TFhirSupplyRequest.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

procedure TFhirSupplyRequest.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

procedure TFhirSupplyRequest.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirSupplyRequest.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirSupplyRequest.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirSupplyRequest.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value;
end;

function TFhirSupplyRequest.GetSupplierList : TFhirReferenceList;
begin
  if FSupplierList = nil then
    FSupplierList := TFhirReferenceList.Create;
  result := FSupplierList;
end;

function TFhirSupplyRequest.GetHasSupplierList : boolean;
begin
  result := (FSupplierList <> nil) and (FSupplierList.count > 0);
end;

function TFhirSupplyRequest.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirSupplyRequest.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirSupplyRequest.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirSupplyRequest.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

procedure TFhirSupplyRequest.SetDeliverFrom(value : TFhirReference);
begin
  FDeliverFrom.free;
  FDeliverFrom := value;
end;

procedure TFhirSupplyRequest.SetDeliverTo(value : TFhirReference);
begin
  FDeliverTo.free;
  FDeliverTo := value;
end;

{ TFhirSupplyRequestListEnumerator }

constructor TFhirSupplyRequestListEnumerator.Create(list : TFhirSupplyRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSupplyRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSupplyRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSupplyRequestListEnumerator.GetCurrent : TFhirSupplyRequest;
begin
  Result := FList[FIndex];
end;

function TFhirSupplyRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSupplyRequestList }

function TFhirSupplyRequestList.AddItem(value: TFhirSupplyRequest): TFhirSupplyRequest;
begin
  assert(value.ClassName = 'TFhirSupplyRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSupplyRequest');
  add(value);
  result := value;
end;

function TFhirSupplyRequestList.Append: TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestList.ClearItems;
begin
  Clear;
end;

function TFhirSupplyRequestList.GetEnumerator : TFhirSupplyRequestListEnumerator;
begin
  result := TFhirSupplyRequestListEnumerator.Create(self.link);
end;

function TFhirSupplyRequestList.Clone: TFhirSupplyRequestList;
begin
  result := TFhirSupplyRequestList(inherited Clone);
end;

function TFhirSupplyRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSupplyRequestList.GetItemN(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(ObjectByIndex[index]);
end;

function TFhirSupplyRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirSupplyRequest;
end;
function TFhirSupplyRequestList.IndexOf(value: TFhirSupplyRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSupplyRequestList.Insert(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSupplyRequestList.InsertItem(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  Inherited Insert(index, value);
end;

function TFhirSupplyRequestList.Item(index: Integer): TFhirSupplyRequest;
begin
  result := TFhirSupplyRequest(ObjectByIndex[index]);
end;

function TFhirSupplyRequestList.Link: TFhirSupplyRequestList;
begin
  result := TFhirSupplyRequestList(inherited Link);
end;

procedure TFhirSupplyRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSupplyRequestList.SetItemByIndex(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  FhirSupplyRequests[index] := value;
end;

procedure TFhirSupplyRequestList.SetItemN(index: Integer; value: TFhirSupplyRequest);
begin
  assert(value is TFhirSupplyRequest);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUPPLYREQUEST}
{$IFDEF FHIR_VISIONPRESCRIPTION}
{ TFhirVisionPrescriptionLensSpecification }

constructor TFhirVisionPrescriptionLensSpecification.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescriptionLensSpecification.Destroy;
begin
  FProduct.free;
  FEye.free;
  FSphere.free;
  FCylinder.free;
  FAxis.free;
  FPrismList.Free;
  FAdd.free;
  FPower.free;
  FBackCurve.free;
  FDiameter.free;
  FDuration.free;
  FColor.free;
  FBrand.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirVisionPrescriptionLensSpecification.Assign(oSource : TFslObject);
begin
  inherited;
  product := TFhirVisionPrescriptionLensSpecification(oSource).product.Clone;
  eyeElement := TFhirVisionPrescriptionLensSpecification(oSource).eyeElement.Clone;
  sphereElement := TFhirVisionPrescriptionLensSpecification(oSource).sphereElement.Clone;
  cylinderElement := TFhirVisionPrescriptionLensSpecification(oSource).cylinderElement.Clone;
  axisElement := TFhirVisionPrescriptionLensSpecification(oSource).axisElement.Clone;
  if (TFhirVisionPrescriptionLensSpecification(oSource).FPrismList = nil) then
  begin
    FPrismList.free;
    FPrismList := nil;
  end
  else
  begin
    if FPrismList = nil then
      FPrismList := TFhirVisionPrescriptionLensSpecificationPrismList.Create;
    FPrismList.Assign(TFhirVisionPrescriptionLensSpecification(oSource).FPrismList);
  end;
  addElement := TFhirVisionPrescriptionLensSpecification(oSource).addElement.Clone;
  powerElement := TFhirVisionPrescriptionLensSpecification(oSource).powerElement.Clone;
  backCurveElement := TFhirVisionPrescriptionLensSpecification(oSource).backCurveElement.Clone;
  diameterElement := TFhirVisionPrescriptionLensSpecification(oSource).diameterElement.Clone;
  duration := TFhirVisionPrescriptionLensSpecification(oSource).duration.Clone;
  colorElement := TFhirVisionPrescriptionLensSpecification(oSource).colorElement.Clone;
  brandElement := TFhirVisionPrescriptionLensSpecification(oSource).brandElement.Clone;
  if (TFhirVisionPrescriptionLensSpecification(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirVisionPrescriptionLensSpecification(oSource).FNoteList);
  end;
end;

procedure TFhirVisionPrescriptionLensSpecification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'product') Then
     list.add(self.link, 'product', FProduct.Link);
  if (child_name = 'eye') Then
     list.add(self.link, 'eye', FEye.Link);
  if (child_name = 'sphere') Then
     list.add(self.link, 'sphere', FSphere.Link);
  if (child_name = 'cylinder') Then
     list.add(self.link, 'cylinder', FCylinder.Link);
  if (child_name = 'axis') Then
     list.add(self.link, 'axis', FAxis.Link);
  if (child_name = 'prism') Then
    list.addAll(self, 'prism', FPrismList);
  if (child_name = 'add') Then
     list.add(self.link, 'add', FAdd.Link);
  if (child_name = 'power') Then
     list.add(self.link, 'power', FPower.Link);
  if (child_name = 'backCurve') Then
     list.add(self.link, 'backCurve', FBackCurve.Link);
  if (child_name = 'diameter') Then
     list.add(self.link, 'diameter', FDiameter.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'color') Then
     list.add(self.link, 'color', FColor.Link);
  if (child_name = 'brand') Then
     list.add(self.link, 'brand', FBrand.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirVisionPrescriptionLensSpecification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'product', 'CodeableConcept', false, TFhirCodeableConcept, FProduct.Link));
  oList.add(TFHIRProperty.create(self, 'eye', 'code', false, TFhirEnum, FEye.Link));
  oList.add(TFHIRProperty.create(self, 'sphere', 'decimal', false, TFhirDecimal, FSphere.Link));
  oList.add(TFHIRProperty.create(self, 'cylinder', 'decimal', false, TFhirDecimal, FCylinder.Link));
  oList.add(TFHIRProperty.create(self, 'axis', 'integer', false, TFhirInteger, FAxis.Link));
  oList.add(TFHIRProperty.create(self, 'prism', 'BackboneElement', true, TFhirVisionPrescriptionLensSpecificationPrism, FPrismList.Link));
  oList.add(TFHIRProperty.create(self, 'add', 'decimal', false, TFhirDecimal, FAdd.Link));
  oList.add(TFHIRProperty.create(self, 'power', 'decimal', false, TFhirDecimal, FPower.Link));
  oList.add(TFHIRProperty.create(self, 'backCurve', 'decimal', false, TFhirDecimal, FBackCurve.Link));
  oList.add(TFHIRProperty.create(self, 'diameter', 'decimal', false, TFhirDecimal, FDiameter.Link));
  oList.add(TFHIRProperty.create(self, 'duration', 'Quantity', false, TFhirQuantity, FDuration.Link));
  oList.add(TFHIRProperty.create(self, 'color', 'string', false, TFhirString, FColor.Link));
  oList.add(TFHIRProperty.create(self, 'brand', 'string', false, TFhirString, FBrand.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirVisionPrescriptionLensSpecification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'product') then
  begin
    Product := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'eye') then
  begin
    EyeElement := asEnum(SYSTEMS_TFhirVisionEyesEnum, CODES_TFhirVisionEyesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'sphere') then
  begin
    SphereElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'cylinder') then
  begin
    CylinderElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'axis') then
  begin
    AxisElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'prism') then
  begin
    PrismList.add(propValue as TFhirVisionPrescriptionLensSpecificationPrism);
    result := propValue;
  end
  else if (propName = 'add') then
  begin
    AddElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'power') then
  begin
    PowerElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'backCurve') then
  begin
    BackCurveElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'diameter') then
  begin
    DiameterElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    Duration := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'color') then
  begin
    ColorElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'brand') then
  begin
    BrandElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVisionPrescriptionLensSpecification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'prism') then PrismList.insertItem(index, propValue as TFhirVisionPrescriptionLensSpecificationPrism)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirVisionPrescriptionLensSpecification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'product') then result := TFhirCodeableConcept.create()
  else if (propName = 'eye') then result := TFhirEnum.create(SYSTEMS_TFhirVisionEyesEnum[VisionEyesNull], CODES_TFhirVisionEyesEnum[VisionEyesNull]) 
  else if (propName = 'sphere') then result := TFhirDecimal.create()
  else if (propName = 'cylinder') then result := TFhirDecimal.create()
  else if (propName = 'axis') then result := TFhirInteger.create()
  else if (propName = 'prism') then result := PrismList.new()
  else if (propName = 'add') then result := TFhirDecimal.create()
  else if (propName = 'power') then result := TFhirDecimal.create()
  else if (propName = 'backCurve') then result := TFhirDecimal.create()
  else if (propName = 'diameter') then result := TFhirDecimal.create()
  else if (propName = 'duration') then result := TFhirQuantity.create()
  else if (propName = 'color') then result := TFhirString.create()
  else if (propName = 'brand') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescriptionLensSpecification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'product') then result := 'CodeableConcept'
  else if (propName = 'eye') then result := 'code'
  else if (propName = 'sphere') then result := 'decimal'
  else if (propName = 'cylinder') then result := 'decimal'
  else if (propName = 'axis') then result := 'integer'
  else if (propName = 'prism') then result := 'BackboneElement'
  else if (propName = 'add') then result := 'decimal'
  else if (propName = 'power') then result := 'decimal'
  else if (propName = 'backCurve') then result := 'decimal'
  else if (propName = 'diameter') then result := 'decimal'
  else if (propName = 'duration') then result := 'Quantity'
  else if (propName = 'color') then result := 'string'
  else if (propName = 'brand') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescriptionLensSpecification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := nil
  else if (propName = 'eye') then EyeElement := nil
  else if (propName = 'sphere') then SphereElement := nil
  else if (propName = 'cylinder') then CylinderElement := nil
  else if (propName = 'axis') then AxisElement := nil
  else if (propName = 'prism') then deletePropertyValue('prism', PrismList, value)
  else if (propName = 'add') then AddElement := nil
  else if (propName = 'power') then PowerElement := nil
  else if (propName = 'backCurve') then BackCurveElement := nil
  else if (propName = 'diameter') then DiameterElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'color') then ColorElement := nil
  else if (propName = 'brand') then BrandElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescriptionLensSpecification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'product') then ProductElement := new as TFhirCodeableConcept
  else if (propName = 'eye') then EyeElement := asEnum(SYSTEMS_TFhirVisionEyesEnum, CODES_TFhirVisionEyesEnum, new)
  else if (propName = 'sphere') then SphereElement := asDecimal(new)
  else if (propName = 'cylinder') then CylinderElement := asDecimal(new)
  else if (propName = 'axis') then AxisElement := asInteger(new)
  else if (propName = 'prism') then replacePropertyValue('prism', PrismList, existing, new)
  else if (propName = 'add') then AddElement := asDecimal(new)
  else if (propName = 'power') then PowerElement := asDecimal(new)
  else if (propName = 'backCurve') then BackCurveElement := asDecimal(new)
  else if (propName = 'diameter') then DiameterElement := asDecimal(new)
  else if (propName = 'duration') then DurationElement := new as TFhirQuantity
  else if (propName = 'color') then ColorElement := asString(new)
  else if (propName = 'brand') then BrandElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescriptionLensSpecification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'prism') then PrismList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescriptionLensSpecification.fhirType : string;
begin
  result := 'VisionPrescription.lensSpecification';
end;

function TFhirVisionPrescriptionLensSpecification.Link : TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification(inherited Link);
end;

function TFhirVisionPrescriptionLensSpecification.Clone : TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification(inherited Clone);
end;

function TFhirVisionPrescriptionLensSpecification.equals(other : TObject) : boolean; 
var
  o : TFhirVisionPrescriptionLensSpecification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescriptionLensSpecification)) then
    result := false
  else
  begin
    o := TFhirVisionPrescriptionLensSpecification(other);
    result := compareDeep(productElement, o.productElement, true) and compareDeep(eyeElement, o.eyeElement, true) and 
      compareDeep(sphereElement, o.sphereElement, true) and compareDeep(cylinderElement, o.cylinderElement, true) and 
      compareDeep(axisElement, o.axisElement, true) and compareDeep(prismList, o.prismList, true) and 
      compareDeep(addElement, o.addElement, true) and compareDeep(powerElement, o.powerElement, true) and 
      compareDeep(backCurveElement, o.backCurveElement, true) and compareDeep(diameterElement, o.diameterElement, true) and 
      compareDeep(durationElement, o.durationElement, true) and compareDeep(colorElement, o.colorElement, true) and 
      compareDeep(brandElement, o.brandElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirVisionPrescriptionLensSpecification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FProduct) and isEmptyProp(FEye) and isEmptyProp(FSphere) and isEmptyProp(FCylinder) and isEmptyProp(FAxis) and isEmptyProp(FprismList) and isEmptyProp(FAdd) and isEmptyProp(FPower) and isEmptyProp(FBackCurve) and isEmptyProp(FDiameter) and isEmptyProp(FDuration) and isEmptyProp(FColor) and isEmptyProp(FBrand) and isEmptyProp(FnoteList);
end;

procedure TFhirVisionPrescriptionLensSpecification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('product');
  fields.add('eye');
  fields.add('sphere');
  fields.add('cylinder');
  fields.add('axis');
  fields.add('prism');
  fields.add('add');
  fields.add('power');
  fields.add('backCurve');
  fields.add('diameter');
  fields.add('duration');
  fields.add('color');
  fields.add('brand');
  fields.add('note');
end;

function TFhirVisionPrescriptionLensSpecification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPrismList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirVisionPrescriptionLensSpecification.SetProduct(value : TFhirCodeableConcept);
begin
  FProduct.free;
  FProduct := value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetEye(value : TFhirEnum);
begin
  FEye.free;
  FEye := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetEyeST : TFhirVisionEyesEnum;
begin
  if FEye = nil then
    result := TFhirVisionEyesEnum(0)
  else
    result := TFhirVisionEyesEnum(StringArrayIndexOfSensitive(CODES_TFhirVisionEyesEnum, FEye.value));
end;

procedure TFhirVisionPrescriptionLensSpecification.SetEyeST(value : TFhirVisionEyesEnum);
begin
  if ord(value) = 0 then
    EyeElement := nil
  else
    EyeElement := TFhirEnum.create(SYSTEMS_TFhirVisionEyesEnum[value], CODES_TFhirVisionEyesEnum[value]);
end;

procedure TFhirVisionPrescriptionLensSpecification.SetSphere(value : TFhirDecimal);
begin
  FSphere.free;
  FSphere := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetSphereST : String;
begin
  if FSphere = nil then
    result := ''
  else
    result := FSphere.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetSphereST(value : String);
begin
  if value <> '' then
  begin
    if FSphere = nil then
      FSphere := TFhirDecimal.create;
    FSphere.value := value
  end
  else if FSphere <> nil then
    FSphere.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetCylinder(value : TFhirDecimal);
begin
  FCylinder.free;
  FCylinder := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetCylinderST : String;
begin
  if FCylinder = nil then
    result := ''
  else
    result := FCylinder.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetCylinderST(value : String);
begin
  if value <> '' then
  begin
    if FCylinder = nil then
      FCylinder := TFhirDecimal.create;
    FCylinder.value := value
  end
  else if FCylinder <> nil then
    FCylinder.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetAxis(value : TFhirInteger);
begin
  FAxis.free;
  FAxis := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetAxisST : String;
begin
  if FAxis = nil then
    result := ''
  else
    result := FAxis.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetAxisST(value : String);
begin
  if value <> '' then
  begin
    if FAxis = nil then
      FAxis := TFhirInteger.create;
    FAxis.value := value
  end
  else if FAxis <> nil then
    FAxis.value := '';
end;

function TFhirVisionPrescriptionLensSpecification.GetPrismList : TFhirVisionPrescriptionLensSpecificationPrismList;
begin
  if FPrismList = nil then
    FPrismList := TFhirVisionPrescriptionLensSpecificationPrismList.Create;
  result := FPrismList;
end;

function TFhirVisionPrescriptionLensSpecification.GetHasPrismList : boolean;
begin
  result := (FPrismList <> nil) and (FPrismList.count > 0);
end;

procedure TFhirVisionPrescriptionLensSpecification.SetAdd(value : TFhirDecimal);
begin
  FAdd.free;
  FAdd := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetAddST : String;
begin
  if FAdd = nil then
    result := ''
  else
    result := FAdd.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetAddST(value : String);
begin
  if value <> '' then
  begin
    if FAdd = nil then
      FAdd := TFhirDecimal.create;
    FAdd.value := value
  end
  else if FAdd <> nil then
    FAdd.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetPower(value : TFhirDecimal);
begin
  FPower.free;
  FPower := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetPowerST : String;
begin
  if FPower = nil then
    result := ''
  else
    result := FPower.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetPowerST(value : String);
begin
  if value <> '' then
  begin
    if FPower = nil then
      FPower := TFhirDecimal.create;
    FPower.value := value
  end
  else if FPower <> nil then
    FPower.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetBackCurve(value : TFhirDecimal);
begin
  FBackCurve.free;
  FBackCurve := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetBackCurveST : String;
begin
  if FBackCurve = nil then
    result := ''
  else
    result := FBackCurve.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetBackCurveST(value : String);
begin
  if value <> '' then
  begin
    if FBackCurve = nil then
      FBackCurve := TFhirDecimal.create;
    FBackCurve.value := value
  end
  else if FBackCurve <> nil then
    FBackCurve.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetDiameter(value : TFhirDecimal);
begin
  FDiameter.free;
  FDiameter := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetDiameterST : String;
begin
  if FDiameter = nil then
    result := ''
  else
    result := FDiameter.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetDiameterST(value : String);
begin
  if value <> '' then
  begin
    if FDiameter = nil then
      FDiameter := TFhirDecimal.create;
    FDiameter.value := value
  end
  else if FDiameter <> nil then
    FDiameter.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetDuration(value : TFhirQuantity);
begin
  FDuration.free;
  FDuration := value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetColor(value : TFhirString);
begin
  FColor.free;
  FColor := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetColorST : String;
begin
  if FColor = nil then
    result := ''
  else
    result := FColor.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetColorST(value : String);
begin
  if value <> '' then
  begin
    if FColor = nil then
      FColor := TFhirString.create;
    FColor.value := value
  end
  else if FColor <> nil then
    FColor.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecification.SetBrand(value : TFhirString);
begin
  FBrand.free;
  FBrand := value;
end;

function TFhirVisionPrescriptionLensSpecification.GetBrandST : String;
begin
  if FBrand = nil then
    result := ''
  else
    result := FBrand.value;
end;

procedure TFhirVisionPrescriptionLensSpecification.SetBrandST(value : String);
begin
  if value <> '' then
  begin
    if FBrand = nil then
      FBrand := TFhirString.create;
    FBrand.value := value
  end
  else if FBrand <> nil then
    FBrand.value := '';
end;

function TFhirVisionPrescriptionLensSpecification.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirVisionPrescriptionLensSpecification.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirVisionPrescriptionLensSpecificationListEnumerator }

constructor TFhirVisionPrescriptionLensSpecificationListEnumerator.Create(list : TFhirVisionPrescriptionLensSpecificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionLensSpecificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionLensSpecificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionLensSpecificationListEnumerator.GetCurrent : TFhirVisionPrescriptionLensSpecification;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionLensSpecificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVisionPrescriptionLensSpecificationList }

function TFhirVisionPrescriptionLensSpecificationList.AddItem(value: TFhirVisionPrescriptionLensSpecification): TFhirVisionPrescriptionLensSpecification;
begin
  assert(value.ClassName = 'TFhirVisionPrescriptionLensSpecification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescriptionLensSpecification');
  add(value);
  result := value;
end;

function TFhirVisionPrescriptionLensSpecificationList.Append: TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionLensSpecificationList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionLensSpecificationList.GetEnumerator : TFhirVisionPrescriptionLensSpecificationListEnumerator;
begin
  result := TFhirVisionPrescriptionLensSpecificationListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionLensSpecificationList.Clone: TFhirVisionPrescriptionLensSpecificationList;
begin
  result := TFhirVisionPrescriptionLensSpecificationList(inherited Clone);
end;

function TFhirVisionPrescriptionLensSpecificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionLensSpecificationList.GetItemN(index: Integer): TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionLensSpecificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescriptionLensSpecification;
end;
function TFhirVisionPrescriptionLensSpecificationList.IndexOf(value: TFhirVisionPrescriptionLensSpecification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionLensSpecificationList.Insert(index: Integer): TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionLensSpecificationList.InsertItem(index: Integer; value: TFhirVisionPrescriptionLensSpecification);
begin
  assert(value is TFhirVisionPrescriptionLensSpecification);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionLensSpecificationList.Item(index: Integer): TFhirVisionPrescriptionLensSpecification;
begin
  result := TFhirVisionPrescriptionLensSpecification(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionLensSpecificationList.Link: TFhirVisionPrescriptionLensSpecificationList;
begin
  result := TFhirVisionPrescriptionLensSpecificationList(inherited Link);
end;

procedure TFhirVisionPrescriptionLensSpecificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionLensSpecificationList.SetItemByIndex(index: Integer; value: TFhirVisionPrescriptionLensSpecification);
begin
  assert(value is TFhirVisionPrescriptionLensSpecification);
  FhirVisionPrescriptionLensSpecifications[index] := value;
end;

procedure TFhirVisionPrescriptionLensSpecificationList.SetItemN(index: Integer; value: TFhirVisionPrescriptionLensSpecification);
begin
  assert(value is TFhirVisionPrescriptionLensSpecification);
  ObjectByIndex[index] := value;
end;

{ TFhirVisionPrescriptionLensSpecificationPrism }

constructor TFhirVisionPrescriptionLensSpecificationPrism.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescriptionLensSpecificationPrism.Destroy;
begin
  FAmount.free;
  FBase.free;
  inherited;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.Assign(oSource : TFslObject);
begin
  inherited;
  amountElement := TFhirVisionPrescriptionLensSpecificationPrism(oSource).amountElement.Clone;
  baseElement := TFhirVisionPrescriptionLensSpecificationPrism(oSource).baseElement.Clone;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'amount') Then
     list.add(self.link, 'amount', FAmount.Link);
  if (child_name = 'base') Then
     list.add(self.link, 'base', FBase.Link);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'amount', 'decimal', false, TFhirDecimal, FAmount.Link));
  oList.add(TFHIRProperty.create(self, 'base', 'code', false, TFhirEnum, FBase.Link));
end;

function TFhirVisionPrescriptionLensSpecificationPrism.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'amount') then
  begin
    AmountElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'base') then
  begin
    BaseElement := asEnum(SYSTEMS_TFhirVisionBaseEnum, CODES_TFhirVisionBaseEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirVisionPrescriptionLensSpecificationPrism.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'amount') then result := TFhirDecimal.create()
  else if (propName = 'base') then result := TFhirEnum.create(SYSTEMS_TFhirVisionBaseEnum[VisionBaseNull], CODES_TFhirVisionBaseEnum[VisionBaseNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescriptionLensSpecificationPrism.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'amount') then result := 'decimal'
  else if (propName = 'base') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'amount') then AmountElement := nil
  else if (propName = 'base') then BaseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'amount') then AmountElement := asDecimal(new)
  else if (propName = 'base') then BaseElement := asEnum(SYSTEMS_TFhirVisionBaseEnum, CODES_TFhirVisionBaseEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescriptionLensSpecificationPrism.fhirType : string;
begin
  result := 'VisionPrescription.lensSpecification.prism';
end;

function TFhirVisionPrescriptionLensSpecificationPrism.Link : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism(inherited Link);
end;

function TFhirVisionPrescriptionLensSpecificationPrism.Clone : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism(inherited Clone);
end;

function TFhirVisionPrescriptionLensSpecificationPrism.equals(other : TObject) : boolean; 
var
  o : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescriptionLensSpecificationPrism)) then
    result := false
  else
  begin
    o := TFhirVisionPrescriptionLensSpecificationPrism(other);
    result := compareDeep(amountElement, o.amountElement, true) and compareDeep(baseElement, o.baseElement, true);
  end;
end;

function TFhirVisionPrescriptionLensSpecificationPrism.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAmount) and isEmptyProp(FBase);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('amount');
  fields.add('base');
end;

function TFhirVisionPrescriptionLensSpecificationPrism.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.SetAmount(value : TFhirDecimal);
begin
  FAmount.free;
  FAmount := value;
end;

function TFhirVisionPrescriptionLensSpecificationPrism.GetAmountST : String;
begin
  if FAmount = nil then
    result := ''
  else
    result := FAmount.value;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.SetAmountST(value : String);
begin
  if value <> '' then
  begin
    if FAmount = nil then
      FAmount := TFhirDecimal.create;
    FAmount.value := value
  end
  else if FAmount <> nil then
    FAmount.value := '';
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.SetBase(value : TFhirEnum);
begin
  FBase.free;
  FBase := value;
end;

function TFhirVisionPrescriptionLensSpecificationPrism.GetBaseST : TFhirVisionBaseEnum;
begin
  if FBase = nil then
    result := TFhirVisionBaseEnum(0)
  else
    result := TFhirVisionBaseEnum(StringArrayIndexOfSensitive(CODES_TFhirVisionBaseEnum, FBase.value));
end;

procedure TFhirVisionPrescriptionLensSpecificationPrism.SetBaseST(value : TFhirVisionBaseEnum);
begin
  if ord(value) = 0 then
    BaseElement := nil
  else
    BaseElement := TFhirEnum.create(SYSTEMS_TFhirVisionBaseEnum[value], CODES_TFhirVisionBaseEnum[value]);
end;

{ TFhirVisionPrescriptionLensSpecificationPrismListEnumerator }

constructor TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.Create(list : TFhirVisionPrescriptionLensSpecificationPrismList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.GetCurrent : TFhirVisionPrescriptionLensSpecificationPrism;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVisionPrescriptionLensSpecificationPrismList }

function TFhirVisionPrescriptionLensSpecificationPrismList.AddItem(value: TFhirVisionPrescriptionLensSpecificationPrism): TFhirVisionPrescriptionLensSpecificationPrism;
begin
  assert(value.ClassName = 'TFhirVisionPrescriptionLensSpecificationPrism', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescriptionLensSpecificationPrism');
  add(value);
  result := value;
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Append: TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.GetEnumerator : TFhirVisionPrescriptionLensSpecificationPrismListEnumerator;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrismListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Clone: TFhirVisionPrescriptionLensSpecificationPrismList;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrismList(inherited Clone);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.GetItemN(index: Integer): TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism;
end;
function TFhirVisionPrescriptionLensSpecificationPrismList.IndexOf(value: TFhirVisionPrescriptionLensSpecificationPrism): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Insert(index: Integer): TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.InsertItem(index: Integer; value: TFhirVisionPrescriptionLensSpecificationPrism);
begin
  assert(value is TFhirVisionPrescriptionLensSpecificationPrism);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Item(index: Integer): TFhirVisionPrescriptionLensSpecificationPrism;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrism(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionLensSpecificationPrismList.Link: TFhirVisionPrescriptionLensSpecificationPrismList;
begin
  result := TFhirVisionPrescriptionLensSpecificationPrismList(inherited Link);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.SetItemByIndex(index: Integer; value: TFhirVisionPrescriptionLensSpecificationPrism);
begin
  assert(value is TFhirVisionPrescriptionLensSpecificationPrism);
  FhirVisionPrescriptionLensSpecificationPrisms[index] := value;
end;

procedure TFhirVisionPrescriptionLensSpecificationPrismList.SetItemN(index: Integer; value: TFhirVisionPrescriptionLensSpecificationPrism);
begin
  assert(value is TFhirVisionPrescriptionLensSpecificationPrism);
  ObjectByIndex[index] := value;
end;

{ TFhirVisionPrescription }

constructor TFhirVisionPrescription.Create;
begin
  inherited;
end;

destructor TFhirVisionPrescription.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FCreated.free;
  FPatient.free;
  FEncounter.free;
  FDateWritten.free;
  FPrescriber.free;
  FLensSpecificationList.Free;
  inherited;
end;

procedure TFhirVisionPrescription.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirVisionPrescription(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirVisionPrescription(oSource).FIdentifierList);
  end;
  statusElement := TFhirVisionPrescription(oSource).statusElement.Clone;
  createdElement := TFhirVisionPrescription(oSource).createdElement.Clone;
  patient := TFhirVisionPrescription(oSource).patient.Clone;
  encounter := TFhirVisionPrescription(oSource).encounter.Clone;
  dateWrittenElement := TFhirVisionPrescription(oSource).dateWrittenElement.Clone;
  prescriber := TFhirVisionPrescription(oSource).prescriber.Clone;
  if (TFhirVisionPrescription(oSource).FLensSpecificationList = nil) then
  begin
    FLensSpecificationList.free;
    FLensSpecificationList := nil;
  end
  else
  begin
    if FLensSpecificationList = nil then
      FLensSpecificationList := TFhirVisionPrescriptionLensSpecificationList.Create;
    FLensSpecificationList.Assign(TFhirVisionPrescription(oSource).FLensSpecificationList);
  end;
end;

function TFhirVisionPrescription.GetResourceType : TFhirResourceType;
begin
  result := frtVisionPrescription;
end;

procedure TFhirVisionPrescription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'created') Then
     list.add(self.link, 'created', FCreated.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'dateWritten') Then
     list.add(self.link, 'dateWritten', FDateWritten.Link);
  if (child_name = 'prescriber') Then
     list.add(self.link, 'prescriber', FPrescriber.Link);
  if (child_name = 'lensSpecification') Then
    list.addAll(self, 'lensSpecification', FLensSpecificationList);
end;

procedure TFhirVisionPrescription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'created', 'dateTime', false, TFhirDateTime, FCreated.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'dateWritten', 'dateTime', false, TFhirDateTime, FDateWritten.Link));
  oList.add(TFHIRProperty.create(self, 'prescriber', 'Reference', false, TFhirReference, FPrescriber.Link));
  oList.add(TFHIRProperty.create(self, 'lensSpecification', 'BackboneElement', true, TFhirVisionPrescriptionLensSpecification, FLensSpecificationList.Link));
end;

function TFhirVisionPrescription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'created') then
  begin
    CreatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'dateWritten') then
  begin
    DateWrittenElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'prescriber') then
  begin
    Prescriber := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'lensSpecification') then
  begin
    LensSpecificationList.add(propValue as TFhirVisionPrescriptionLensSpecification);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVisionPrescription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'lensSpecification') then LensSpecificationList.insertItem(index, propValue as TFhirVisionPrescriptionLensSpecification)
  else inherited;
end;

function TFhirVisionPrescription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull], CODES_TFhirFinancialResourceStatusCodesEnum[FinancialResourceStatusCodesNull]) 
  else if (propName = 'created') then result := TFhirDateTime.create()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'dateWritten') then result := TFhirDateTime.create()
  else if (propName = 'prescriber') then result := TFhirReference.create()
  else if (propName = 'lensSpecification') then result := LensSpecificationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVisionPrescription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'created') then result := 'dateTime'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'dateWritten') then result := 'dateTime'
  else if (propName = 'prescriber') then result := 'Reference'
  else if (propName = 'lensSpecification') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVisionPrescription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'created') then CreatedElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'dateWritten') then DateWrittenElement := nil
  else if (propName = 'prescriber') then PrescriberElement := nil
  else if (propName = 'lensSpecification') then deletePropertyValue('lensSpecification', LensSpecificationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVisionPrescription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFinancialResourceStatusCodesEnum, CODES_TFhirFinancialResourceStatusCodesEnum, new)
  else if (propName = 'created') then CreatedElement := asDateTime(new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'dateWritten') then DateWrittenElement := asDateTime(new)
  else if (propName = 'prescriber') then PrescriberElement := new as TFhirReference
  else if (propName = 'lensSpecification') then replacePropertyValue('lensSpecification', LensSpecificationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVisionPrescription.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'lensSpecification') then LensSpecificationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVisionPrescription.fhirType : string;
begin
  result := 'VisionPrescription';
end;

function TFhirVisionPrescription.Link : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(inherited Link);
end;

function TFhirVisionPrescription.Clone : TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(inherited Clone);
end;

function TFhirVisionPrescription.equals(other : TObject) : boolean; 
var
  o : TFhirVisionPrescription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVisionPrescription)) then
    result := false
  else
  begin
    o := TFhirVisionPrescription(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(createdElement, o.createdElement, true) and compareDeep(patientElement, o.patientElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(dateWrittenElement, o.dateWrittenElement, true) and 
      compareDeep(prescriberElement, o.prescriberElement, true) and compareDeep(lensSpecificationList, o.lensSpecificationList, true);
  end;
end;

function TFhirVisionPrescription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FCreated) and isEmptyProp(FPatient) and isEmptyProp(FEncounter) and isEmptyProp(FDateWritten) and isEmptyProp(FPrescriber) and isEmptyProp(FlensSpecificationList);
end;

procedure TFhirVisionPrescription.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('created');
  fields.add('patient');
  fields.add('encounter');
  fields.add('dateWritten');
  fields.add('prescriber');
  fields.add('lensSpecification');
end;

function TFhirVisionPrescription.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FLensSpecificationList.sizeInBytes(magic));
end;

function TFhirVisionPrescription.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirVisionPrescription.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirVisionPrescription.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirVisionPrescription.GetStatusST : TFhirFinancialResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirFinancialResourceStatusCodesEnum(0)
  else
    result := TFhirFinancialResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirFinancialResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirVisionPrescription.SetStatusST(value : TFhirFinancialResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirFinancialResourceStatusCodesEnum[value], CODES_TFhirFinancialResourceStatusCodesEnum[value]);
end;

procedure TFhirVisionPrescription.SetCreated(value : TFhirDateTime);
begin
  FCreated.free;
  FCreated := value;
end;

function TFhirVisionPrescription.GetCreatedST : TFslDateTime;
begin
  if FCreated = nil then
    result := TFslDateTime.makeNull
  else
    result := FCreated.value;
end;

procedure TFhirVisionPrescription.SetCreatedST(value : TFslDateTime);
begin
  if FCreated = nil then
    FCreated := TFhirDateTime.create;
  FCreated.value := value
end;

procedure TFhirVisionPrescription.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirVisionPrescription.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirVisionPrescription.SetDateWritten(value : TFhirDateTime);
begin
  FDateWritten.free;
  FDateWritten := value;
end;

function TFhirVisionPrescription.GetDateWrittenST : TFslDateTime;
begin
  if FDateWritten = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateWritten.value;
end;

procedure TFhirVisionPrescription.SetDateWrittenST(value : TFslDateTime);
begin
  if FDateWritten = nil then
    FDateWritten := TFhirDateTime.create;
  FDateWritten.value := value
end;

procedure TFhirVisionPrescription.SetPrescriber(value : TFhirReference);
begin
  FPrescriber.free;
  FPrescriber := value;
end;

function TFhirVisionPrescription.GetLensSpecificationList : TFhirVisionPrescriptionLensSpecificationList;
begin
  if FLensSpecificationList = nil then
    FLensSpecificationList := TFhirVisionPrescriptionLensSpecificationList.Create;
  result := FLensSpecificationList;
end;

function TFhirVisionPrescription.GetHasLensSpecificationList : boolean;
begin
  result := (FLensSpecificationList <> nil) and (FLensSpecificationList.count > 0);
end;

{ TFhirVisionPrescriptionListEnumerator }

constructor TFhirVisionPrescriptionListEnumerator.Create(list : TFhirVisionPrescriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVisionPrescriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVisionPrescriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVisionPrescriptionListEnumerator.GetCurrent : TFhirVisionPrescription;
begin
  Result := FList[FIndex];
end;

function TFhirVisionPrescriptionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVisionPrescriptionList }

function TFhirVisionPrescriptionList.AddItem(value: TFhirVisionPrescription): TFhirVisionPrescription;
begin
  assert(value.ClassName = 'TFhirVisionPrescription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVisionPrescription');
  add(value);
  result := value;
end;

function TFhirVisionPrescriptionList.Append: TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionList.ClearItems;
begin
  Clear;
end;

function TFhirVisionPrescriptionList.GetEnumerator : TFhirVisionPrescriptionListEnumerator;
begin
  result := TFhirVisionPrescriptionListEnumerator.Create(self.link);
end;

function TFhirVisionPrescriptionList.Clone: TFhirVisionPrescriptionList;
begin
  result := TFhirVisionPrescriptionList(inherited Clone);
end;

function TFhirVisionPrescriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVisionPrescriptionList.GetItemN(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirVisionPrescription;
end;
function TFhirVisionPrescriptionList.IndexOf(value: TFhirVisionPrescription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVisionPrescriptionList.Insert(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVisionPrescriptionList.InsertItem(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  Inherited Insert(index, value);
end;

function TFhirVisionPrescriptionList.Item(index: Integer): TFhirVisionPrescription;
begin
  result := TFhirVisionPrescription(ObjectByIndex[index]);
end;

function TFhirVisionPrescriptionList.Link: TFhirVisionPrescriptionList;
begin
  result := TFhirVisionPrescriptionList(inherited Link);
end;

procedure TFhirVisionPrescriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVisionPrescriptionList.SetItemByIndex(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  FhirVisionPrescriptions[index] := value;
end;

procedure TFhirVisionPrescriptionList.SetItemN(index: Integer; value: TFhirVisionPrescription);
begin
  assert(value is TFhirVisionPrescription);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VISIONPRESCRIPTION}


end.

