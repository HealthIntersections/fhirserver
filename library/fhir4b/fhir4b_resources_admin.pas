unit fhir4b_resources_admin;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir4b.inc}

interface

// Generated on Mon, Dec 27, 2021 21:46+1100 for FHIR v4.3.0

uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities,  
  fhir4b_base, fhir4b_enums, fhir4b_types, fhir4b_resources_base, fhir4b_resources_canonical;



type
{$IFDEF FHIR_CATALOGENTRY}
  TFhirCatalogEntryRelatedEntry = class;
  TFhirCatalogEntryRelatedEntryList = class;
  TFhirCatalogEntry = class;
  TFhirCatalogEntryList = class;
{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_DEVICE}
  TFhirDeviceUdiCarrier = class;
  TFhirDeviceUdiCarrierList = class;
  TFhirDeviceDeviceName = class;
  TFhirDeviceDeviceNameList = class;
  TFhirDeviceSpecialization = class;
  TFhirDeviceSpecializationList = class;
  TFhirDeviceVersion = class;
  TFhirDeviceVersionList = class;
  TFhirDeviceProperty = class;
  TFhirDevicePropertyList = class;
  TFhirDevice = class;
  TFhirDeviceList = class;
{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  TFhirDeviceDefinitionUdiDeviceIdentifier = class;
  TFhirDeviceDefinitionUdiDeviceIdentifierList = class;
  TFhirDeviceDefinitionDeviceName = class;
  TFhirDeviceDefinitionDeviceNameList = class;
  TFhirDeviceDefinitionSpecialization = class;
  TFhirDeviceDefinitionSpecializationList = class;
  TFhirDeviceDefinitionCapability = class;
  TFhirDeviceDefinitionCapabilityList = class;
  TFhirDeviceDefinitionProperty = class;
  TFhirDeviceDefinitionPropertyList = class;
  TFhirDeviceDefinitionMaterial = class;
  TFhirDeviceDefinitionMaterialList = class;
  TFhirDeviceDefinition = class;
  TFhirDeviceDefinitionList = class;
{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  TFhirDeviceMetricCalibration = class;
  TFhirDeviceMetricCalibrationList = class;
  TFhirDeviceMetric = class;
  TFhirDeviceMetricList = class;
{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
  TFhirEncounterStatusHistory = class;
  TFhirEncounterStatusHistoryList = class;
  TFhirEncounterClassHistory = class;
  TFhirEncounterClassHistoryList = class;
  TFhirEncounterParticipant = class;
  TFhirEncounterParticipantList = class;
  TFhirEncounterDiagnosis = class;
  TFhirEncounterDiagnosisList = class;
  TFhirEncounterHospitalization = class;
  TFhirEncounterHospitalizationList = class;
  TFhirEncounterLocation = class;
  TFhirEncounterLocationList = class;
  TFhirEncounter = class;
  TFhirEncounterList = class;
{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  TFhirEndpoint = class;
  TFhirEndpointList = class;
{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_GROUP}
  TFhirGroupCharacteristic = class;
  TFhirGroupCharacteristicList = class;
  TFhirGroupMember = class;
  TFhirGroupMemberList = class;
  TFhirGroup = class;
  TFhirGroupList = class;
{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  TFhirHealthcareServiceEligibility = class;
  TFhirHealthcareServiceEligibilityList = class;
  TFhirHealthcareServiceAvailableTime = class;
  TFhirHealthcareServiceAvailableTimeList = class;
  TFhirHealthcareServiceNotAvailable = class;
  TFhirHealthcareServiceNotAvailableList = class;
  TFhirHealthcareService = class;
  TFhirHealthcareServiceList = class;
{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
  TFhirLocationPosition = class;
  TFhirLocationPositionList = class;
  TFhirLocationHoursOfOperation = class;
  TFhirLocationHoursOfOperationList = class;
  TFhirLocation = class;
  TFhirLocationList = class;
{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  TFhirMedia = class;
  TFhirMediaList = class;
{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_ORGANIZATION}
  TFhirOrganizationContact = class;
  TFhirOrganizationContactList = class;
  TFhirOrganization = class;
  TFhirOrganizationList = class;
{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  TFhirOrganizationAffiliation = class;
  TFhirOrganizationAffiliationList = class;
{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  TFhirPatientContact = class;
  TFhirPatientContactList = class;
  TFhirPatientCommunication = class;
  TFhirPatientCommunicationList = class;
  TFhirPatientLink = class;
  TFhirPatientLinkList = class;
  TFhirPatient = class;
  TFhirPatientList = class;
{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
  TFhirPersonLink = class;
  TFhirPersonLinkList = class;
  TFhirPerson = class;
  TFhirPersonList = class;
{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  TFhirPractitionerQualification = class;
  TFhirPractitionerQualificationList = class;
  TFhirPractitioner = class;
  TFhirPractitionerList = class;
{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  TFhirPractitionerRoleAvailableTime = class;
  TFhirPractitionerRoleAvailableTimeList = class;
  TFhirPractitionerRoleNotAvailable = class;
  TFhirPractitionerRoleNotAvailableList = class;
  TFhirPractitionerRole = class;
  TFhirPractitionerRoleList = class;
{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
  TFhirRelatedPersonCommunication = class;
  TFhirRelatedPersonCommunicationList = class;
  TFhirRelatedPerson = class;
  TFhirRelatedPersonList = class;
{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
  TFhirSchedule = class;
  TFhirScheduleList = class;
{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
  TFhirSlot = class;
  TFhirSlotList = class;
{$ENDIF FHIR_SLOT}




{$IFDEF FHIR_CATALOGENTRY}
  // Used for example, to point to a substance, or to a device used to administer a medication.
  TFhirCatalogEntryRelatedEntry = class (TFhirBackboneElement)
  protected
    FRelationtype : TFhirEnum;
    FItem : TFhirReference;
    procedure SetRelationtype(value : TFhirEnum);
    function GetRelationtypeST : TFhirCatalogEntryRelationTypeEnum;
    procedure SetRelationtypeST(value : TFhirCatalogEntryRelationTypeEnum);
    procedure SetItem(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCatalogEntryRelatedEntry; overload;
    function Clone : TFhirCatalogEntryRelatedEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of relation to the related item: child, parent, packageContent, containerPackage, usedIn, uses, requires, etc.
    property relationtype : TFhirCatalogEntryRelationTypeEnum read GetRelationtypeST write SetRelationtypeST;
    property relationtypeElement : TFhirEnum read FRelationtype write SetRelationtype;

    // Typed access to The reference to the related item. (defined for API consistency)
    property item : TFhirReference read FItem write SetItem;
    // The reference to the related item.
    property itemElement : TFhirReference read FItem write SetItem;

  end;

  TFhirCatalogEntryRelatedEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCatalogEntryRelatedEntryList;
    function GetCurrent : TFhirCatalogEntryRelatedEntry;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCatalogEntryRelatedEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCatalogEntryRelatedEntry read GetCurrent;
  end;

  TFhirCatalogEntryRelatedEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCatalogEntryRelatedEntry;
    procedure SetItemN(index : Integer; value : TFhirCatalogEntryRelatedEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCatalogEntryRelatedEntryList; overload;
    function Clone : TFhirCatalogEntryRelatedEntryList; overload;
    function GetEnumerator : TFhirCatalogEntryRelatedEntryListEnumerator;
    
    //  Add a FhirCatalogEntryRelatedEntry to the end of the list.
    function Append : TFhirCatalogEntryRelatedEntry;
    
    // Add an already existing FhirCatalogEntryRelatedEntry to the end of the list.
    function AddItem(value : TFhirCatalogEntryRelatedEntry) : TFhirCatalogEntryRelatedEntry; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCatalogEntryRelatedEntry) : Integer;
    
    // Insert FhirCatalogEntryRelatedEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCatalogEntryRelatedEntry;
    
    // Insert an existing FhirCatalogEntryRelatedEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCatalogEntryRelatedEntry);
    
    // Get the iIndexth FhirCatalogEntryRelatedEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCatalogEntryRelatedEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCatalogEntryRelatedEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCatalogEntryRelatedEntries[index : Integer] : TFhirCatalogEntryRelatedEntry read GetItemN write SetItemN; default;
  End;

  // Catalog entries are wrappers that contextualize items included in a catalog.
  TFhirCatalogEntry = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FOrderable : TFhirBoolean;
    FReferencedItem : TFhirReference;
    FadditionalIdentifierList : TFhirIdentifierList;
    FclassificationList : TFhirCodeableConceptList;
    FStatus : TFhirEnum;
    FValidityPeriod : TFhirPeriod;
    FValidTo : TFhirDateTime;
    FLastUpdated : TFhirDateTime;
    FadditionalCharacteristicList : TFhirCodeableConceptList;
    FadditionalClassificationList : TFhirCodeableConceptList;
    FrelatedEntryList : TFhirCatalogEntryRelatedEntryList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetOrderable(value : TFhirBoolean);
    function GetOrderableST : Boolean;
    procedure SetOrderableST(value : Boolean);
    procedure SetReferencedItem(value : TFhirReference);
    function GetAdditionalIdentifierList : TFhirIdentifierList;
    function GetHasAdditionalIdentifierList : Boolean;
    function GetClassificationList : TFhirCodeableConceptList;
    function GetHasClassificationList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetValidityPeriod(value : TFhirPeriod);
    procedure SetValidTo(value : TFhirDateTime);
    function GetValidToST : TFslDateTime;
    procedure SetValidToST(value : TFslDateTime);
    procedure SetLastUpdated(value : TFhirDateTime);
    function GetLastUpdatedST : TFslDateTime;
    procedure SetLastUpdatedST(value : TFslDateTime);
    function GetAdditionalCharacteristicList : TFhirCodeableConceptList;
    function GetHasAdditionalCharacteristicList : Boolean;
    function GetAdditionalClassificationList : TFhirCodeableConceptList;
    function GetHasAdditionalClassificationList : Boolean;
    function GetRelatedEntryList : TFhirCatalogEntryRelatedEntryList;
    function GetHasRelatedEntryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirCatalogEntry; overload;
    function Clone : TFhirCatalogEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Used in supporting different identifiers for the same product, e.g. manufacturer code and retailer code.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The type of item - medication, device, service, protocol or other. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of item - medication, device, service, protocol or other.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Whether the entry represents an orderable item.
    property orderable : Boolean read GetOrderableST write SetOrderableST;
    // Whether the entry represents an orderable item.
    property orderableElement : TFhirBoolean read FOrderable write SetOrderable;

    // Typed access to The item in a catalog or definition. (defined for API consistency)
    property referencedItem : TFhirReference read FReferencedItem write SetReferencedItem;
    // The item in a catalog or definition.
    property referencedItemElement : TFhirReference read FReferencedItem write SetReferencedItem;

    // Used in supporting related concepts, e.g. NDC to RxNorm.
    property additionalIdentifierList : TFhirIdentifierList read GetAdditionalIdentifierList;
    property hasAdditionalIdentifierList : boolean read GetHasAdditionalIdentifierList;

    // Classes of devices, or ATC for medication.
    property classificationList : TFhirCodeableConceptList read GetClassificationList;
    property hasClassificationList : boolean read GetHasClassificationList;

    // Used to support catalog exchange even for unsupported products, e.g. getting list of medications even if not prescribable.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The time period in which this catalog entry is expected to be active. (defined for API consistency)
    property validityPeriod : TFhirPeriod read FValidityPeriod write SetValidityPeriod;
    // The time period in which this catalog entry is expected to be active.
    property validityPeriodElement : TFhirPeriod read FValidityPeriod write SetValidityPeriod;

    // Typed access to The date until which this catalog entry is expected to be active.
    property validTo : TFslDateTime read GetValidToST write SetValidToST;
    // The date until which this catalog entry is expected to be active.
    property validToElement : TFhirDateTime read FValidTo write SetValidTo;

    // Typed access to Typically date of issue is different from the beginning of the validity. This can be used to see when an item was last updated.
    property lastUpdated : TFslDateTime read GetLastUpdatedST write SetLastUpdatedST;
    // Typically date of issue is different from the beginning of the validity. This can be used to see when an item was last updated.
    property lastUpdatedElement : TFhirDateTime read FLastUpdated write SetLastUpdated;

    // Used for examplefor Out of Formulary, or any specifics.
    property additionalCharacteristicList : TFhirCodeableConceptList read GetAdditionalCharacteristicList;
    property hasAdditionalCharacteristicList : boolean read GetHasAdditionalCharacteristicList;

    // User for example for ATC classification, or.
    property additionalClassificationList : TFhirCodeableConceptList read GetAdditionalClassificationList;
    property hasAdditionalClassificationList : boolean read GetHasAdditionalClassificationList;

    // Used for example, to point to a substance, or to a device used to administer a medication.
    property relatedEntryList : TFhirCatalogEntryRelatedEntryList read GetRelatedEntryList;
    property hasRelatedEntryList : boolean read GetHasRelatedEntryList;

  end;

  TFhirCatalogEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirCatalogEntryList;
    function GetCurrent : TFhirCatalogEntry;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirCatalogEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirCatalogEntry read GetCurrent;
  end;

  TFhirCatalogEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirCatalogEntry;
    procedure SetItemN(index : Integer; value : TFhirCatalogEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirCatalogEntryList; overload;
    function Clone : TFhirCatalogEntryList; overload;
    function GetEnumerator : TFhirCatalogEntryListEnumerator;
    
    //  Add a FhirCatalogEntry to the end of the list.
    function Append : TFhirCatalogEntry;
    
    // Add an already existing FhirCatalogEntry to the end of the list.
    function AddItem(value : TFhirCatalogEntry) : TFhirCatalogEntry; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirCatalogEntry) : Integer;
    
    // Insert FhirCatalogEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirCatalogEntry;
    
    // Insert an existing FhirCatalogEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirCatalogEntry);
    
    // Get the iIndexth FhirCatalogEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirCatalogEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirCatalogEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirCatalogEntries[index : Integer] : TFhirCatalogEntry read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_DEVICE}
  // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
  TFhirDeviceUdiCarrier = class (TFhirBackboneElement)
  protected
    FDeviceIdentifier : TFhirString;
    FIssuer : TFhirUri;
    FJurisdiction : TFhirUri;
    FCarrierAIDC : TFhirBase64Binary;
    FCarrierHRF : TFhirString;
    FEntryType : TFhirEnum;
    procedure SetDeviceIdentifier(value : TFhirString);
    function GetDeviceIdentifierST : String;
    procedure SetDeviceIdentifierST(value : String);
    procedure SetIssuer(value : TFhirUri);
    function GetIssuerST : String;
    procedure SetIssuerST(value : String);
    procedure SetJurisdiction(value : TFhirUri);
    function GetJurisdictionST : String;
    procedure SetJurisdictionST(value : String);
    procedure SetCarrierAIDC(value : TFhirBase64Binary);
    function GetCarrierAIDCST : TBytes;
    procedure SetCarrierAIDCST(value : TBytes);
    procedure SetCarrierHRF(value : TFhirString);
    function GetCarrierHRFST : String;
    procedure SetCarrierHRFST(value : String);
    procedure SetEntryType(value : TFhirEnum);
    function GetEntryTypeST : TFhirUDIEntryTypeEnum;
    procedure SetEntryTypeST(value : TFhirUDIEntryTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceUdiCarrier; overload;
    function Clone : TFhirDeviceUdiCarrier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The device identifier (DI) is a mandatory, fixed portion of a UDI that identifies the labeler and the specific version or model of a device.
    property deviceIdentifier : String read GetDeviceIdentifierST write SetDeviceIdentifierST;
    // The device identifier (DI) is a mandatory, fixed portion of a UDI that identifies the labeler and the specific version or model of a device.
    property deviceIdentifierElement : TFhirString read FDeviceIdentifier write SetDeviceIdentifier;

    // Typed access to Organization that is charged with issuing UDIs for devices.  For example, the US FDA issuers include : 1) GS1:  http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-dI,  3) ICCBBA for blood containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di.
    property issuer : String read GetIssuerST write SetIssuerST;
    // Organization that is charged with issuing UDIs for devices.  For example, the US FDA issuers include : 1) GS1:  http://hl7.org/fhir/NamingSystem/gs1-di,  2) HIBCC: http://hl7.org/fhir/NamingSystem/hibcc-dI,  3) ICCBBA for blood containers: http://hl7.org/fhir/NamingSystem/iccbba-blood-di,  4) ICCBA for other devices: http://hl7.org/fhir/NamingSystem/iccbba-other-di.
    property issuerElement : TFhirUri read FIssuer write SetIssuer;

    // Typed access to The identity of the authoritative source for UDI generation within a  jurisdiction.  All UDIs are globally unique within a single namespace with the appropriate repository uri as the system.  For example,  UDIs of devices managed in the U.S. by the FDA, the value is  http://hl7.org/fhir/NamingSystem/fda-udi.
    property jurisdiction : String read GetJurisdictionST write SetJurisdictionST;
    // The identity of the authoritative source for UDI generation within a  jurisdiction.  All UDIs are globally unique within a single namespace with the appropriate repository uri as the system.  For example,  UDIs of devices managed in the U.S. by the FDA, the value is  http://hl7.org/fhir/NamingSystem/fda-udi.
    property jurisdictionElement : TFhirUri read FJurisdiction write SetJurisdiction;

    // Typed access to The full UDI carrier of the Automatic Identification and Data Capture (AIDC) technology representation of the barcode string as printed on the packaging of the device - e.g., a barcode or RFID.   Because of limitations on character sets in XML and the need to round-trip JSON data through XML, AIDC Formats *SHALL* be base64 encoded.
    property carrierAIDC : TBytes read GetCarrierAIDCST write SetCarrierAIDCST;
    // The full UDI carrier of the Automatic Identification and Data Capture (AIDC) technology representation of the barcode string as printed on the packaging of the device - e.g., a barcode or RFID.   Because of limitations on character sets in XML and the need to round-trip JSON data through XML, AIDC Formats *SHALL* be base64 encoded.
    property carrierAIDCElement : TFhirBase64Binary read FCarrierAIDC write SetCarrierAIDC;

    // Typed access to The full UDI carrier as the human readable form (HRF) representation of the barcode string as printed on the packaging of the device.
    property carrierHRF : String read GetCarrierHRFST write SetCarrierHRFST;
    // The full UDI carrier as the human readable form (HRF) representation of the barcode string as printed on the packaging of the device.
    property carrierHRFElement : TFhirString read FCarrierHRF write SetCarrierHRF;

    // A coded entry to indicate how the data was entered.
    property entryType : TFhirUDIEntryTypeEnum read GetEntryTypeST write SetEntryTypeST;
    property entryTypeElement : TFhirEnum read FEntryType write SetEntryType;

  end;

  TFhirDeviceUdiCarrierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceUdiCarrierList;
    function GetCurrent : TFhirDeviceUdiCarrier;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceUdiCarrierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceUdiCarrier read GetCurrent;
  end;

  TFhirDeviceUdiCarrierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceUdiCarrier;
    procedure SetItemN(index : Integer; value : TFhirDeviceUdiCarrier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceUdiCarrierList; overload;
    function Clone : TFhirDeviceUdiCarrierList; overload;
    function GetEnumerator : TFhirDeviceUdiCarrierListEnumerator;
    
    //  Add a FhirDeviceUdiCarrier to the end of the list.
    function Append : TFhirDeviceUdiCarrier;
    
    // Add an already existing FhirDeviceUdiCarrier to the end of the list.
    function AddItem(value : TFhirDeviceUdiCarrier) : TFhirDeviceUdiCarrier; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceUdiCarrier) : Integer;
    
    // Insert FhirDeviceUdiCarrier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceUdiCarrier;
    
    // Insert an existing FhirDeviceUdiCarrier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceUdiCarrier);
    
    // Get the iIndexth FhirDeviceUdiCarrier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceUdiCarrier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceUdiCarrier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceUdiCarriers[index : Integer] : TFhirDeviceUdiCarrier read GetItemN write SetItemN; default;
  End;

  // This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
  TFhirDeviceDeviceName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirEnum;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceNameTypeEnum;
    procedure SetType_ST(value : TFhirDeviceNameTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDeviceName; overload;
    function Clone : TFhirDeviceDeviceName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name that identifies the device.
    property name : String read GetNameST write SetNameST;
    // The name that identifies the device.
    property nameElement : TFhirString read FName write SetName;

    // The type of deviceName. UDILabelName | UserFriendlyName | PatientReportedName | ManufactureDeviceName | ModelName.
    property type_ : TFhirDeviceNameTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirDeviceDeviceNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDeviceNameList;
    function GetCurrent : TFhirDeviceDeviceName;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDeviceNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDeviceName read GetCurrent;
  end;

  TFhirDeviceDeviceNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDeviceName;
    procedure SetItemN(index : Integer; value : TFhirDeviceDeviceName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDeviceNameList; overload;
    function Clone : TFhirDeviceDeviceNameList; overload;
    function GetEnumerator : TFhirDeviceDeviceNameListEnumerator;
    
    //  Add a FhirDeviceDeviceName to the end of the list.
    function Append : TFhirDeviceDeviceName;
    
    // Add an already existing FhirDeviceDeviceName to the end of the list.
    function AddItem(value : TFhirDeviceDeviceName) : TFhirDeviceDeviceName; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDeviceName) : Integer;
    
    // Insert FhirDeviceDeviceName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDeviceName;
    
    // Insert an existing FhirDeviceDeviceName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDeviceName);
    
    // Get the iIndexth FhirDeviceDeviceName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDeviceName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDeviceName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDeviceNames[index : Integer] : TFhirDeviceDeviceName read GetItemN write SetItemN; default;
  End;

  // The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
  TFhirDeviceSpecialization = class (TFhirBackboneElement)
  protected
    FSystemType : TFhirCodeableConcept;
    FVersion : TFhirString;
    procedure SetSystemType(value : TFhirCodeableConcept);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceSpecialization; overload;
    function Clone : TFhirDeviceSpecialization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The standard that is used to operate and communicate. (defined for API consistency)
    property systemType : TFhirCodeableConcept read FSystemType write SetSystemType;
    // The standard that is used to operate and communicate.
    property systemTypeElement : TFhirCodeableConcept read FSystemType write SetSystemType;

    // Typed access to The version of the standard that is used to operate and communicate.
    property version : String read GetVersionST write SetVersionST;
    // The version of the standard that is used to operate and communicate.
    property versionElement : TFhirString read FVersion write SetVersion;

  end;

  TFhirDeviceSpecializationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceSpecializationList;
    function GetCurrent : TFhirDeviceSpecialization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceSpecializationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceSpecialization read GetCurrent;
  end;

  TFhirDeviceSpecializationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceSpecialization;
    procedure SetItemN(index : Integer; value : TFhirDeviceSpecialization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceSpecializationList; overload;
    function Clone : TFhirDeviceSpecializationList; overload;
    function GetEnumerator : TFhirDeviceSpecializationListEnumerator;
    
    //  Add a FhirDeviceSpecialization to the end of the list.
    function Append : TFhirDeviceSpecialization;
    
    // Add an already existing FhirDeviceSpecialization to the end of the list.
    function AddItem(value : TFhirDeviceSpecialization) : TFhirDeviceSpecialization; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceSpecialization) : Integer;
    
    // Insert FhirDeviceSpecialization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceSpecialization;
    
    // Insert an existing FhirDeviceSpecialization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceSpecialization);
    
    // Get the iIndexth FhirDeviceSpecialization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceSpecialization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceSpecialization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceSpecializations[index : Integer] : TFhirDeviceSpecialization read GetItemN write SetItemN; default;
  End;

  // The actual design of the device or software version running on the device.
  TFhirDeviceVersion = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FComponent : TFhirIdentifier;
    FValue : TFhirString;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetComponent(value : TFhirIdentifier);
    procedure SetValue(value : TFhirString);
    function GetValueST : String;
    procedure SetValueST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceVersion; overload;
    function Clone : TFhirDeviceVersion; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the device version, e.g. manufacturer, approved, internal. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of the device version, e.g. manufacturer, approved, internal.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A single component of the device version. (defined for API consistency)
    property component : TFhirIdentifier read FComponent write SetComponent;
    // A single component of the device version.
    property componentElement : TFhirIdentifier read FComponent write SetComponent;

    // Typed access to The version text.
    property value : String read GetValueST write SetValueST;
    // The version text.
    property valueElement : TFhirString read FValue write SetValue;

  end;

  TFhirDeviceVersionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceVersionList;
    function GetCurrent : TFhirDeviceVersion;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceVersionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceVersion read GetCurrent;
  end;

  TFhirDeviceVersionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceVersion;
    procedure SetItemN(index : Integer; value : TFhirDeviceVersion);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceVersionList; overload;
    function Clone : TFhirDeviceVersionList; overload;
    function GetEnumerator : TFhirDeviceVersionListEnumerator;
    
    //  Add a FhirDeviceVersion to the end of the list.
    function Append : TFhirDeviceVersion;
    
    // Add an already existing FhirDeviceVersion to the end of the list.
    function AddItem(value : TFhirDeviceVersion) : TFhirDeviceVersion; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceVersion) : Integer;
    
    // Insert FhirDeviceVersion before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceVersion;
    
    // Insert an existing FhirDeviceVersion before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceVersion);
    
    // Get the iIndexth FhirDeviceVersion. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceVersion);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceVersion;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceVersions[index : Integer] : TFhirDeviceVersion read GetItemN write SetItemN; default;
  End;

  // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
  TFhirDeviceProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FvalueQuantityList : TFhirQuantityList;
    FvalueCodeList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetValueQuantityList : TFhirQuantityList;
    function GetHasValueQuantityList : Boolean;
    function GetValueCodeList : TFhirCodeableConceptList;
    function GetHasValueCodeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceProperty; overload;
    function Clone : TFhirDeviceProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code that specifies the property DeviceDefinitionPropetyCode (Extensible). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code that specifies the property DeviceDefinitionPropetyCode (Extensible).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Property value as a quantity.
    property valueQuantityList : TFhirQuantityList read GetValueQuantityList;
    property hasValueQuantityList : boolean read GetHasValueQuantityList;

    // Property value as a code, e.g., NTP4 (synced to NTP).
    property valueCodeList : TFhirCodeableConceptList read GetValueCodeList;
    property hasValueCodeList : boolean read GetHasValueCodeList;

  end;

  TFhirDevicePropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDevicePropertyList;
    function GetCurrent : TFhirDeviceProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDevicePropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceProperty read GetCurrent;
  end;

  TFhirDevicePropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceProperty;
    procedure SetItemN(index : Integer; value : TFhirDeviceProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDevicePropertyList; overload;
    function Clone : TFhirDevicePropertyList; overload;
    function GetEnumerator : TFhirDevicePropertyListEnumerator;
    
    //  Add a FhirDeviceProperty to the end of the list.
    function Append : TFhirDeviceProperty;
    
    // Add an already existing FhirDeviceProperty to the end of the list.
    function AddItem(value : TFhirDeviceProperty) : TFhirDeviceProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceProperty) : Integer;
    
    // Insert FhirDeviceProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceProperty;
    
    // Insert an existing FhirDeviceProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceProperty);
    
    // Get the iIndexth FhirDeviceProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceProperties[index : Integer] : TFhirDeviceProperty read GetItemN write SetItemN; default;
  End;

  // A type of a manufactured item that is used in the provision of healthcare without being substantially changed through that activity. The device may be a medical or non-medical device.
  TFhirDevice = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FDefinition : TFhirReference;
    FudiCarrierList : TFhirDeviceUdiCarrierList;
    FStatus : TFhirEnum;
    FstatusReasonList : TFhirCodeableConceptList;
    FDistinctIdentifier : TFhirString;
    FManufacturer : TFhirString;
    FManufactureDate : TFhirDateTime;
    FExpirationDate : TFhirDateTime;
    FLotNumber : TFhirString;
    FSerialNumber : TFhirString;
    FdeviceNameList : TFhirDeviceDeviceNameList;
    FModelNumber : TFhirString;
    FPartNumber : TFhirString;
    FType_ : TFhirCodeableConcept;
    FspecializationList : TFhirDeviceSpecializationList;
    FversionList : TFhirDeviceVersionList;
    Fproperty_List : TFhirDevicePropertyList;
    FPatient : TFhirReference;
    FOwner : TFhirReference;
    FcontactList : TFhirContactPointList;
    FLocation : TFhirReference;
    FUrl : TFhirUri;
    FnoteList : TFhirAnnotationList;
    FsafetyList : TFhirCodeableConceptList;
    FParent : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetDefinition(value : TFhirReference);
    function GetUdiCarrierList : TFhirDeviceUdiCarrierList;
    function GetHasUdiCarrierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirFHIRDeviceStatusEnum;
    procedure SetStatusST(value : TFhirFHIRDeviceStatusEnum);
    function GetStatusReasonList : TFhirCodeableConceptList;
    function GetHasStatusReasonList : Boolean;
    procedure SetDistinctIdentifier(value : TFhirString);
    function GetDistinctIdentifierST : String;
    procedure SetDistinctIdentifierST(value : String);
    procedure SetManufacturer(value : TFhirString);
    function GetManufacturerST : String;
    procedure SetManufacturerST(value : String);
    procedure SetManufactureDate(value : TFhirDateTime);
    function GetManufactureDateST : TFslDateTime;
    procedure SetManufactureDateST(value : TFslDateTime);
    procedure SetExpirationDate(value : TFhirDateTime);
    function GetExpirationDateST : TFslDateTime;
    procedure SetExpirationDateST(value : TFslDateTime);
    procedure SetLotNumber(value : TFhirString);
    function GetLotNumberST : String;
    procedure SetLotNumberST(value : String);
    procedure SetSerialNumber(value : TFhirString);
    function GetSerialNumberST : String;
    procedure SetSerialNumberST(value : String);
    function GetDeviceNameList : TFhirDeviceDeviceNameList;
    function GetHasDeviceNameList : Boolean;
    procedure SetModelNumber(value : TFhirString);
    function GetModelNumberST : String;
    procedure SetModelNumberST(value : String);
    procedure SetPartNumber(value : TFhirString);
    function GetPartNumberST : String;
    procedure SetPartNumberST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetSpecializationList : TFhirDeviceSpecializationList;
    function GetHasSpecializationList : Boolean;
    function GetVersionList : TFhirDeviceVersionList;
    function GetHasVersionList : Boolean;
    function GetProperty_List : TFhirDevicePropertyList;
    function GetHasProperty_List : Boolean;
    procedure SetPatient(value : TFhirReference);
    procedure SetOwner(value : TFhirReference);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetLocation(value : TFhirReference);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSafetyList : TFhirCodeableConceptList;
    function GetHasSafetyList : Boolean;
    procedure SetParent(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDevice; overload;
    function Clone : TFhirDevice; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique instance identifiers assigned to a device by manufacturers other organizations or owners.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The reference to the definition for the device. (defined for API consistency)
    property definition : TFhirReference read FDefinition write SetDefinition;
    // The reference to the definition for the device.
    property definitionElement : TFhirReference read FDefinition write SetDefinition;

    // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
    property udiCarrierList : TFhirDeviceUdiCarrierList read GetUdiCarrierList;
    property hasUdiCarrierList : boolean read GetHasUdiCarrierList;

    // Status of the Device availability.
    property status : TFhirFHIRDeviceStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Reason for the dtatus of the Device availability.
    property statusReasonList : TFhirCodeableConceptList read GetStatusReasonList;
    property hasStatusReasonList : boolean read GetHasStatusReasonList;

    // Typed access to The distinct identification string as required by regulation for a human cell, tissue, or cellular and tissue-based product.
    property distinctIdentifier : String read GetDistinctIdentifierST write SetDistinctIdentifierST;
    // The distinct identification string as required by regulation for a human cell, tissue, or cellular and tissue-based product.
    property distinctIdentifierElement : TFhirString read FDistinctIdentifier write SetDistinctIdentifier;

    // Typed access to A name of the manufacturer.
    property manufacturer : String read GetManufacturerST write SetManufacturerST;
    // A name of the manufacturer.
    property manufacturerElement : TFhirString read FManufacturer write SetManufacturer;

    // Typed access to The date and time when the device was manufactured.
    property manufactureDate : TFslDateTime read GetManufactureDateST write SetManufactureDateST;
    // The date and time when the device was manufactured.
    property manufactureDateElement : TFhirDateTime read FManufactureDate write SetManufactureDate;

    // Typed access to The date and time beyond which this device is no longer valid or should not be used (if applicable).
    property expirationDate : TFslDateTime read GetExpirationDateST write SetExpirationDateST;
    // The date and time beyond which this device is no longer valid or should not be used (if applicable).
    property expirationDateElement : TFhirDateTime read FExpirationDate write SetExpirationDate;

    // Typed access to Lot number assigned by the manufacturer.
    property lotNumber : String read GetLotNumberST write SetLotNumberST;
    // Lot number assigned by the manufacturer.
    property lotNumberElement : TFhirString read FLotNumber write SetLotNumber;

    // Typed access to The serial number assigned by the organization when the device was manufactured.
    property serialNumber : String read GetSerialNumberST write SetSerialNumberST;
    // The serial number assigned by the organization when the device was manufactured.
    property serialNumberElement : TFhirString read FSerialNumber write SetSerialNumber;

    // This represents the manufacturer's name of the device as provided by the device, from a UDI label, or by a person describing the Device.  This typically would be used when a person provides the name(s) or when the device represents one of the names available from DeviceDefinition.
    property deviceNameList : TFhirDeviceDeviceNameList read GetDeviceNameList;
    property hasDeviceNameList : boolean read GetHasDeviceNameList;

    // Typed access to The manufacturer's model number for the device.
    property modelNumber : String read GetModelNumberST write SetModelNumberST;
    // The manufacturer's model number for the device.
    property modelNumberElement : TFhirString read FModelNumber write SetModelNumber;

    // Typed access to The part number or catalog number of the device.
    property partNumber : String read GetPartNumberST write SetPartNumberST;
    // The part number or catalog number of the device.
    property partNumberElement : TFhirString read FPartNumber write SetPartNumber;

    // Typed access to The kind or type of device. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind or type of device.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
    property specializationList : TFhirDeviceSpecializationList read GetSpecializationList;
    property hasSpecializationList : boolean read GetHasSpecializationList;

    // The actual design of the device or software version running on the device.
    property versionList : TFhirDeviceVersionList read GetVersionList;
    property hasVersionList : boolean read GetHasVersionList;

    // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
    property property_List : TFhirDevicePropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Typed access to Patient information, If the device is affixed to a person. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // Patient information, If the device is affixed to a person.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to An organization that is responsible for the provision and ongoing maintenance of the device. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // An organization that is responsible for the provision and ongoing maintenance of the device.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Contact details for an organization or a particular human that is responsible for the device.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The place where the device can be found. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The place where the device can be found.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to A network address on which the device may be contacted directly.
    property url : String read GetUrlST write SetUrlST;
    // A network address on which the device may be contacted directly.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Descriptive information, usage information or implantation information that is not captured in an existing element.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Provides additional safety characteristics about a medical device.  For example devices containing latex.
    property safetyList : TFhirCodeableConceptList read GetSafetyList;
    property hasSafetyList : boolean read GetHasSafetyList;

    // Typed access to The device that this device is attached to or is part of. (defined for API consistency)
    property parent : TFhirReference read FParent write SetParent;
    // The device that this device is attached to or is part of.
    property parentElement : TFhirReference read FParent write SetParent;

  end;

  TFhirDeviceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceList;
    function GetCurrent : TFhirDevice;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDevice read GetCurrent;
  end;

  TFhirDeviceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDevice;
    procedure SetItemN(index : Integer; value : TFhirDevice);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceList; overload;
    function Clone : TFhirDeviceList; overload;
    function GetEnumerator : TFhirDeviceListEnumerator;
    
    //  Add a FhirDevice to the end of the list.
    function Append : TFhirDevice;
    
    // Add an already existing FhirDevice to the end of the list.
    function AddItem(value : TFhirDevice) : TFhirDevice; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDevice) : Integer;
    
    // Insert FhirDevice before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDevice;
    
    // Insert an existing FhirDevice before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDevice);
    
    // Get the iIndexth FhirDevice. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDevice);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDevice;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDevices[index : Integer] : TFhirDevice read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
  // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
  TFhirDeviceDefinitionUdiDeviceIdentifier = class (TFhirBackboneElement)
  protected
    FDeviceIdentifier : TFhirString;
    FIssuer : TFhirUri;
    FJurisdiction : TFhirUri;
    procedure SetDeviceIdentifier(value : TFhirString);
    function GetDeviceIdentifierST : String;
    procedure SetDeviceIdentifierST(value : String);
    procedure SetIssuer(value : TFhirUri);
    function GetIssuerST : String;
    procedure SetIssuerST(value : String);
    procedure SetJurisdiction(value : TFhirUri);
    function GetJurisdictionST : String;
    procedure SetJurisdictionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionUdiDeviceIdentifier; overload;
    function Clone : TFhirDeviceDefinitionUdiDeviceIdentifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdication porvided in the DeviceDefinition.udiDeviceIdentifier.
    property deviceIdentifier : String read GetDeviceIdentifierST write SetDeviceIdentifierST;
    // The identifier that is to be associated with every Device that references this DeviceDefintiion for the issuer and jurisdication porvided in the DeviceDefinition.udiDeviceIdentifier.
    property deviceIdentifierElement : TFhirString read FDeviceIdentifier write SetDeviceIdentifier;

    // Typed access to The organization that assigns the identifier algorithm.
    property issuer : String read GetIssuerST write SetIssuerST;
    // The organization that assigns the identifier algorithm.
    property issuerElement : TFhirUri read FIssuer write SetIssuer;

    // Typed access to The jurisdiction to which the deviceIdentifier applies.
    property jurisdiction : String read GetJurisdictionST write SetJurisdictionST;
    // The jurisdiction to which the deviceIdentifier applies.
    property jurisdictionElement : TFhirUri read FJurisdiction write SetJurisdiction;

  end;

  TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    function GetCurrent : TFhirDeviceDefinitionUdiDeviceIdentifier;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionUdiDeviceIdentifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionUdiDeviceIdentifier read GetCurrent;
  end;

  TFhirDeviceDefinitionUdiDeviceIdentifierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionUdiDeviceIdentifierList; overload;
    function Clone : TFhirDeviceDefinitionUdiDeviceIdentifierList; overload;
    function GetEnumerator : TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator;
    
    //  Add a FhirDeviceDefinitionUdiDeviceIdentifier to the end of the list.
    function Append : TFhirDeviceDefinitionUdiDeviceIdentifier;
    
    // Add an already existing FhirDeviceDefinitionUdiDeviceIdentifier to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionUdiDeviceIdentifier) : TFhirDeviceDefinitionUdiDeviceIdentifier; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionUdiDeviceIdentifier) : Integer;
    
    // Insert FhirDeviceDefinitionUdiDeviceIdentifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    
    // Insert an existing FhirDeviceDefinitionUdiDeviceIdentifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
    
    // Get the iIndexth FhirDeviceDefinitionUdiDeviceIdentifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionUdiDeviceIdentifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionUdiDeviceIdentifier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionUdiDeviceIdentifiers[index : Integer] : TFhirDeviceDefinitionUdiDeviceIdentifier read GetItemN write SetItemN; default;
  End;

  // A name given to the device to identify it.
  TFhirDeviceDefinitionDeviceName = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirEnum;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceNameTypeEnum;
    procedure SetType_ST(value : TFhirDeviceNameTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionDeviceName; overload;
    function Clone : TFhirDeviceDefinitionDeviceName; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the device.
    property name : String read GetNameST write SetNameST;
    // The name of the device.
    property nameElement : TFhirString read FName write SetName;

    // The type of deviceName. UDILabelName | UserFriendlyName | PatientReportedName | ManufactureDeviceName | ModelName.
    property type_ : TFhirDeviceNameTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirDeviceDefinitionDeviceNameListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionDeviceNameList;
    function GetCurrent : TFhirDeviceDefinitionDeviceName;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionDeviceNameList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionDeviceName read GetCurrent;
  end;

  TFhirDeviceDefinitionDeviceNameList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionDeviceName;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionDeviceName);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionDeviceNameList; overload;
    function Clone : TFhirDeviceDefinitionDeviceNameList; overload;
    function GetEnumerator : TFhirDeviceDefinitionDeviceNameListEnumerator;
    
    //  Add a FhirDeviceDefinitionDeviceName to the end of the list.
    function Append : TFhirDeviceDefinitionDeviceName;
    
    // Add an already existing FhirDeviceDefinitionDeviceName to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionDeviceName) : TFhirDeviceDefinitionDeviceName; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionDeviceName) : Integer;
    
    // Insert FhirDeviceDefinitionDeviceName before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionDeviceName;
    
    // Insert an existing FhirDeviceDefinitionDeviceName before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionDeviceName);
    
    // Get the iIndexth FhirDeviceDefinitionDeviceName. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionDeviceName);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionDeviceName;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionDeviceNames[index : Integer] : TFhirDeviceDefinitionDeviceName read GetItemN write SetItemN; default;
  End;

  // The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
  TFhirDeviceDefinitionSpecialization = class (TFhirBackboneElement)
  protected
    FSystemType : TFhirString;
    FVersion : TFhirString;
    procedure SetSystemType(value : TFhirString);
    function GetSystemTypeST : String;
    procedure SetSystemTypeST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionSpecialization; overload;
    function Clone : TFhirDeviceDefinitionSpecialization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The standard that is used to operate and communicate.
    property systemType : String read GetSystemTypeST write SetSystemTypeST;
    // The standard that is used to operate and communicate.
    property systemTypeElement : TFhirString read FSystemType write SetSystemType;

    // Typed access to The version of the standard that is used to operate and communicate.
    property version : String read GetVersionST write SetVersionST;
    // The version of the standard that is used to operate and communicate.
    property versionElement : TFhirString read FVersion write SetVersion;

  end;

  TFhirDeviceDefinitionSpecializationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionSpecializationList;
    function GetCurrent : TFhirDeviceDefinitionSpecialization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionSpecializationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionSpecialization read GetCurrent;
  end;

  TFhirDeviceDefinitionSpecializationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionSpecialization;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionSpecialization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionSpecializationList; overload;
    function Clone : TFhirDeviceDefinitionSpecializationList; overload;
    function GetEnumerator : TFhirDeviceDefinitionSpecializationListEnumerator;
    
    //  Add a FhirDeviceDefinitionSpecialization to the end of the list.
    function Append : TFhirDeviceDefinitionSpecialization;
    
    // Add an already existing FhirDeviceDefinitionSpecialization to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionSpecialization) : TFhirDeviceDefinitionSpecialization; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionSpecialization) : Integer;
    
    // Insert FhirDeviceDefinitionSpecialization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionSpecialization;
    
    // Insert an existing FhirDeviceDefinitionSpecialization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionSpecialization);
    
    // Get the iIndexth FhirDeviceDefinitionSpecialization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionSpecialization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionSpecialization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionSpecializations[index : Integer] : TFhirDeviceDefinitionSpecialization read GetItemN write SetItemN; default;
  End;

  // Device capabilities.
  TFhirDeviceDefinitionCapability = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FdescriptionList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetDescriptionList : TFhirCodeableConceptList;
    function GetHasDescriptionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionCapability; overload;
    function Clone : TFhirDeviceDefinitionCapability; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Type of capability. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of capability.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Description of capability.
    property descriptionList : TFhirCodeableConceptList read GetDescriptionList;
    property hasDescriptionList : boolean read GetHasDescriptionList;

  end;

  TFhirDeviceDefinitionCapabilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionCapabilityList;
    function GetCurrent : TFhirDeviceDefinitionCapability;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionCapabilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionCapability read GetCurrent;
  end;

  TFhirDeviceDefinitionCapabilityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionCapability;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionCapability);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionCapabilityList; overload;
    function Clone : TFhirDeviceDefinitionCapabilityList; overload;
    function GetEnumerator : TFhirDeviceDefinitionCapabilityListEnumerator;
    
    //  Add a FhirDeviceDefinitionCapability to the end of the list.
    function Append : TFhirDeviceDefinitionCapability;
    
    // Add an already existing FhirDeviceDefinitionCapability to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionCapability) : TFhirDeviceDefinitionCapability; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionCapability) : Integer;
    
    // Insert FhirDeviceDefinitionCapability before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionCapability;
    
    // Insert an existing FhirDeviceDefinitionCapability before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionCapability);
    
    // Get the iIndexth FhirDeviceDefinitionCapability. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionCapability);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionCapability;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionCapabilities[index : Integer] : TFhirDeviceDefinitionCapability read GetItemN write SetItemN; default;
  End;

  // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
  TFhirDeviceDefinitionProperty = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FvalueQuantityList : TFhirQuantityList;
    FvalueCodeList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetValueQuantityList : TFhirQuantityList;
    function GetHasValueQuantityList : Boolean;
    function GetValueCodeList : TFhirCodeableConceptList;
    function GetHasValueCodeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionProperty; overload;
    function Clone : TFhirDeviceDefinitionProperty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code that specifies the property DeviceDefinitionPropetyCode (Extensible). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Code that specifies the property DeviceDefinitionPropetyCode (Extensible).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Property value as a quantity.
    property valueQuantityList : TFhirQuantityList read GetValueQuantityList;
    property hasValueQuantityList : boolean read GetHasValueQuantityList;

    // Property value as a code, e.g., NTP4 (synced to NTP).
    property valueCodeList : TFhirCodeableConceptList read GetValueCodeList;
    property hasValueCodeList : boolean read GetHasValueCodeList;

  end;

  TFhirDeviceDefinitionPropertyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionPropertyList;
    function GetCurrent : TFhirDeviceDefinitionProperty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionPropertyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionProperty read GetCurrent;
  end;

  TFhirDeviceDefinitionPropertyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionProperty;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionProperty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionPropertyList; overload;
    function Clone : TFhirDeviceDefinitionPropertyList; overload;
    function GetEnumerator : TFhirDeviceDefinitionPropertyListEnumerator;
    
    //  Add a FhirDeviceDefinitionProperty to the end of the list.
    function Append : TFhirDeviceDefinitionProperty;
    
    // Add an already existing FhirDeviceDefinitionProperty to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionProperty) : TFhirDeviceDefinitionProperty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionProperty) : Integer;
    
    // Insert FhirDeviceDefinitionProperty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionProperty;
    
    // Insert an existing FhirDeviceDefinitionProperty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionProperty);
    
    // Get the iIndexth FhirDeviceDefinitionProperty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionProperty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionProperty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionProperties[index : Integer] : TFhirDeviceDefinitionProperty read GetItemN write SetItemN; default;
  End;

  // A substance used to create the material(s) of which the device is made.
  TFhirDeviceDefinitionMaterial = class (TFhirBackboneElement)
  protected
    FSubstance : TFhirCodeableConcept;
    FAlternate : TFhirBoolean;
    FAllergenicIndicator : TFhirBoolean;
    procedure SetSubstance(value : TFhirCodeableConcept);
    procedure SetAlternate(value : TFhirBoolean);
    function GetAlternateST : Boolean;
    procedure SetAlternateST(value : Boolean);
    procedure SetAllergenicIndicator(value : TFhirBoolean);
    function GetAllergenicIndicatorST : Boolean;
    procedure SetAllergenicIndicatorST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinitionMaterial; overload;
    function Clone : TFhirDeviceDefinitionMaterial; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The substance. (defined for API consistency)
    property substance : TFhirCodeableConcept read FSubstance write SetSubstance;
    // The substance.
    property substanceElement : TFhirCodeableConcept read FSubstance write SetSubstance;

    // Typed access to Indicates an alternative material of the device.
    property alternate : Boolean read GetAlternateST write SetAlternateST;
    // Indicates an alternative material of the device.
    property alternateElement : TFhirBoolean read FAlternate write SetAlternate;

    // Typed access to Whether the substance is a known or suspected allergen.
    property allergenicIndicator : Boolean read GetAllergenicIndicatorST write SetAllergenicIndicatorST;
    // Whether the substance is a known or suspected allergen.
    property allergenicIndicatorElement : TFhirBoolean read FAllergenicIndicator write SetAllergenicIndicator;

  end;

  TFhirDeviceDefinitionMaterialListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionMaterialList;
    function GetCurrent : TFhirDeviceDefinitionMaterial;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionMaterialList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinitionMaterial read GetCurrent;
  end;

  TFhirDeviceDefinitionMaterialList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinitionMaterial;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinitionMaterial);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionMaterialList; overload;
    function Clone : TFhirDeviceDefinitionMaterialList; overload;
    function GetEnumerator : TFhirDeviceDefinitionMaterialListEnumerator;
    
    //  Add a FhirDeviceDefinitionMaterial to the end of the list.
    function Append : TFhirDeviceDefinitionMaterial;
    
    // Add an already existing FhirDeviceDefinitionMaterial to the end of the list.
    function AddItem(value : TFhirDeviceDefinitionMaterial) : TFhirDeviceDefinitionMaterial; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinitionMaterial) : Integer;
    
    // Insert FhirDeviceDefinitionMaterial before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinitionMaterial;
    
    // Insert an existing FhirDeviceDefinitionMaterial before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinitionMaterial);
    
    // Get the iIndexth FhirDeviceDefinitionMaterial. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinitionMaterial);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinitionMaterial;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitionMaterials[index : Integer] : TFhirDeviceDefinitionMaterial read GetItemN write SetItemN; default;
  End;

  // The characteristics, operational status and capabilities of a medical-related component of a medical device.
  TFhirDeviceDefinition = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FudiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    FManufacturer : TFhirDataType;
    FdeviceNameList : TFhirDeviceDefinitionDeviceNameList;
    FModelNumber : TFhirString;
    FType_ : TFhirCodeableConcept;
    FspecializationList : TFhirDeviceDefinitionSpecializationList;
    FversionList : TFhirStringList;
    FsafetyList : TFhirCodeableConceptList;
    FshelfLifeStorageList : TFhirProductShelfLifeList;
    FPhysicalCharacteristics : TFhirProdCharacteristic;
    FlanguageCodeList : TFhirCodeableConceptList;
    FcapabilityList : TFhirDeviceDefinitionCapabilityList;
    Fproperty_List : TFhirDeviceDefinitionPropertyList;
    FOwner : TFhirReference;
    FcontactList : TFhirContactPointList;
    FUrl : TFhirUri;
    FOnlineInformation : TFhirUri;
    FnoteList : TFhirAnnotationList;
    FQuantity : TFhirQuantity;
    FParentDevice : TFhirReference;
    FmaterialList : TFhirDeviceDefinitionMaterialList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetUdiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
    function GetHasUdiDeviceIdentifierList : Boolean;
    procedure SetManufacturer(value : TFhirDataType);
    function GetDeviceNameList : TFhirDeviceDefinitionDeviceNameList;
    function GetHasDeviceNameList : Boolean;
    procedure SetModelNumber(value : TFhirString);
    function GetModelNumberST : String;
    procedure SetModelNumberST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetSpecializationList : TFhirDeviceDefinitionSpecializationList;
    function GetHasSpecializationList : Boolean;
    function GetVersionList : TFhirStringList;
    function GetHasVersionList : Boolean;
    function GetSafetyList : TFhirCodeableConceptList;
    function GetHasSafetyList : Boolean;
    function GetShelfLifeStorageList : TFhirProductShelfLifeList;
    function GetHasShelfLifeStorageList : Boolean;
    procedure SetPhysicalCharacteristics(value : TFhirProdCharacteristic);
    function GetLanguageCodeList : TFhirCodeableConceptList;
    function GetHasLanguageCodeList : Boolean;
    function GetCapabilityList : TFhirDeviceDefinitionCapabilityList;
    function GetHasCapabilityList : Boolean;
    function GetProperty_List : TFhirDeviceDefinitionPropertyList;
    function GetHasProperty_List : Boolean;
    procedure SetOwner(value : TFhirReference);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetOnlineInformation(value : TFhirUri);
    function GetOnlineInformationST : String;
    procedure SetOnlineInformationST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetParentDevice(value : TFhirReference);
    function GetMaterialList : TFhirDeviceDefinitionMaterialList;
    function GetHasMaterialList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceDefinition; overload;
    function Clone : TFhirDeviceDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique instance identifiers assigned to a device by the software, manufacturers, other organizations or owners. For example: handle ID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Unique device identifier (UDI) assigned to device label or package.  Note that the Device may include multiple udiCarriers as it either may include just the udiCarrier for the jurisdiction it is sold, or for multiple jurisdictions it could have been sold.
    property udiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList read GetUdiDeviceIdentifierList;
    property hasUdiDeviceIdentifierList : boolean read GetHasUdiDeviceIdentifierList;

    // Typed access to A name of the manufacturer. (defined for API consistency)
    property manufacturer : TFhirDataType read FManufacturer write SetManufacturer;
    // A name of the manufacturer.
    property manufacturerElement : TFhirDataType read FManufacturer write SetManufacturer;

    // A name given to the device to identify it.
    property deviceNameList : TFhirDeviceDefinitionDeviceNameList read GetDeviceNameList;
    property hasDeviceNameList : boolean read GetHasDeviceNameList;

    // Typed access to The model number for the device.
    property modelNumber : String read GetModelNumberST write SetModelNumberST;
    // The model number for the device.
    property modelNumberElement : TFhirString read FModelNumber write SetModelNumber;

    // Typed access to What kind of device or device system this is. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // What kind of device or device system this is.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The capabilities supported on a  device, the standards to which the device conforms for a particular purpose, and used for the communication.
    property specializationList : TFhirDeviceDefinitionSpecializationList read GetSpecializationList;
    property hasSpecializationList : boolean read GetHasSpecializationList;

    // The available versions of the device, e.g., software versions.
    property versionList : TFhirStringList read GetVersionList;
    property hasVersionList : boolean read GetHasVersionList;

    // Safety characteristics of the device.
    property safetyList : TFhirCodeableConceptList read GetSafetyList;
    property hasSafetyList : boolean read GetHasSafetyList;

    // Shelf Life and storage information.
    property shelfLifeStorageList : TFhirProductShelfLifeList read GetShelfLifeStorageList;
    property hasShelfLifeStorageList : boolean read GetHasShelfLifeStorageList;

    // Typed access to Dimensions, color etc. (defined for API consistency)
    property physicalCharacteristics : TFhirProdCharacteristic read FPhysicalCharacteristics write SetPhysicalCharacteristics;
    // Dimensions, color etc.
    property physicalCharacteristicsElement : TFhirProdCharacteristic read FPhysicalCharacteristics write SetPhysicalCharacteristics;

    // Language code for the human-readable text strings produced by the device (all supported).
    property languageCodeList : TFhirCodeableConceptList read GetLanguageCodeList;
    property hasLanguageCodeList : boolean read GetHasLanguageCodeList;

    // Device capabilities.
    property capabilityList : TFhirDeviceDefinitionCapabilityList read GetCapabilityList;
    property hasCapabilityList : boolean read GetHasCapabilityList;

    // The actual configuration settings of a device as it actually operates, e.g., regulation status, time properties.
    property property_List : TFhirDeviceDefinitionPropertyList read GetProperty_List;
    property hasProperty_List : boolean read GetHasProperty_List;

    // Typed access to An organization that is responsible for the provision and ongoing maintenance of the device. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // An organization that is responsible for the provision and ongoing maintenance of the device.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Contact details for an organization or a particular human that is responsible for the device.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A network address on which the device may be contacted directly.
    property url : String read GetUrlST write SetUrlST;
    // A network address on which the device may be contacted directly.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to Access to on-line information about the device.
    property onlineInformation : String read GetOnlineInformationST write SetOnlineInformationST;
    // Access to on-line information about the device.
    property onlineInformationElement : TFhirUri read FOnlineInformation write SetOnlineInformation;

    // Descriptive information, usage information or implantation information that is not captured in an existing element.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The quantity of the device present in the packaging (e.g. the number of devices present in a pack, or the number of devices in the same package of the medicinal product). (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The quantity of the device present in the packaging (e.g. the number of devices present in a pack, or the number of devices in the same package of the medicinal product).
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The parent device it can be part of. (defined for API consistency)
    property parentDevice : TFhirReference read FParentDevice write SetParentDevice;
    // The parent device it can be part of.
    property parentDeviceElement : TFhirReference read FParentDevice write SetParentDevice;

    // A substance used to create the material(s) of which the device is made.
    property materialList : TFhirDeviceDefinitionMaterialList read GetMaterialList;
    property hasMaterialList : boolean read GetHasMaterialList;

  end;

  TFhirDeviceDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceDefinitionList;
    function GetCurrent : TFhirDeviceDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceDefinition read GetCurrent;
  end;

  TFhirDeviceDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceDefinition;
    procedure SetItemN(index : Integer; value : TFhirDeviceDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceDefinitionList; overload;
    function Clone : TFhirDeviceDefinitionList; overload;
    function GetEnumerator : TFhirDeviceDefinitionListEnumerator;
    
    //  Add a FhirDeviceDefinition to the end of the list.
    function Append : TFhirDeviceDefinition;
    
    // Add an already existing FhirDeviceDefinition to the end of the list.
    function AddItem(value : TFhirDeviceDefinition) : TFhirDeviceDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceDefinition) : Integer;
    
    // Insert FhirDeviceDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceDefinition;
    
    // Insert an existing FhirDeviceDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceDefinition);
    
    // Get the iIndexth FhirDeviceDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceDefinitions[index : Integer] : TFhirDeviceDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
  // Describes the calibrations that have been performed or that are required to be performed.
  TFhirDeviceMetricCalibration = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FState : TFhirEnum;
    FTime : TFhirInstant;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirDeviceMetricCalibrationTypeEnum;
    procedure SetType_ST(value : TFhirDeviceMetricCalibrationTypeEnum);
    procedure SetState(value : TFhirEnum);
    function GetStateST : TFhirDeviceMetricCalibrationStateEnum;
    procedure SetStateST(value : TFhirDeviceMetricCalibrationStateEnum);
    procedure SetTime(value : TFhirInstant);
    function GetTimeST : TFslDateTime;
    procedure SetTimeST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceMetricCalibration; overload;
    function Clone : TFhirDeviceMetricCalibration; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Describes the type of the calibration method.
    property type_ : TFhirDeviceMetricCalibrationTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Describes the state of the calibration.
    property state : TFhirDeviceMetricCalibrationStateEnum read GetStateST write SetStateST;
    property stateElement : TFhirEnum read FState write SetState;

    // Typed access to Describes the time last calibration has been performed.
    property time : TFslDateTime read GetTimeST write SetTimeST;
    // Describes the time last calibration has been performed.
    property timeElement : TFhirInstant read FTime write SetTime;

  end;

  TFhirDeviceMetricCalibrationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceMetricCalibrationList;
    function GetCurrent : TFhirDeviceMetricCalibration;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceMetricCalibrationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceMetricCalibration read GetCurrent;
  end;

  TFhirDeviceMetricCalibrationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceMetricCalibration;
    procedure SetItemN(index : Integer; value : TFhirDeviceMetricCalibration);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceMetricCalibrationList; overload;
    function Clone : TFhirDeviceMetricCalibrationList; overload;
    function GetEnumerator : TFhirDeviceMetricCalibrationListEnumerator;
    
    //  Add a FhirDeviceMetricCalibration to the end of the list.
    function Append : TFhirDeviceMetricCalibration;
    
    // Add an already existing FhirDeviceMetricCalibration to the end of the list.
    function AddItem(value : TFhirDeviceMetricCalibration) : TFhirDeviceMetricCalibration; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceMetricCalibration) : Integer;
    
    // Insert FhirDeviceMetricCalibration before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceMetricCalibration;
    
    // Insert an existing FhirDeviceMetricCalibration before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceMetricCalibration);
    
    // Get the iIndexth FhirDeviceMetricCalibration. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceMetricCalibration);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceMetricCalibration;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceMetricCalibrations[index : Integer] : TFhirDeviceMetricCalibration read GetItemN write SetItemN; default;
  End;

  // Describes a measurement, calculation or setting capability of a medical device.
  TFhirDeviceMetric = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FType_ : TFhirCodeableConcept;
    FUnit_ : TFhirCodeableConcept;
    FSource : TFhirReference;
    FParent : TFhirReference;
    FOperationalStatus : TFhirEnum;
    FColor : TFhirEnum;
    FCategory : TFhirEnum;
    FMeasurementPeriod : TFhirTiming;
    FcalibrationList : TFhirDeviceMetricCalibrationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetUnit_(value : TFhirCodeableConcept);
    procedure SetSource(value : TFhirReference);
    procedure SetParent(value : TFhirReference);
    procedure SetOperationalStatus(value : TFhirEnum);
    function GetOperationalStatusST : TFhirDeviceMetricOperationalStatusEnum;
    procedure SetOperationalStatusST(value : TFhirDeviceMetricOperationalStatusEnum);
    procedure SetColor(value : TFhirEnum);
    function GetColorST : TFhirDeviceMetricColorEnum;
    procedure SetColorST(value : TFhirDeviceMetricColorEnum);
    procedure SetCategory(value : TFhirEnum);
    function GetCategoryST : TFhirDeviceMetricCategoryEnum;
    procedure SetCategoryST(value : TFhirDeviceMetricCategoryEnum);
    procedure SetMeasurementPeriod(value : TFhirTiming);
    function GetCalibrationList : TFhirDeviceMetricCalibrationList;
    function GetHasCalibrationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirDeviceMetric; overload;
    function Clone : TFhirDeviceMetric; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique instance identifiers assigned to a device by the device or gateway software, manufacturers, other organizations or owners. For example: handle ID.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Describes the type of the metric. For example: Heart Rate, PEEP Setting, etc.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Describes the unit that an observed value determined for this metric will have. For example: Percent, Seconds, etc. (defined for API consistency)
    property unit_ : TFhirCodeableConcept read FUnit_ write SetUnit_;
    // Describes the unit that an observed value determined for this metric will have. For example: Percent, Seconds, etc.
    property unit_Element : TFhirCodeableConcept read FUnit_ write SetUnit_;

    // Typed access to Describes the link to the  Device that this DeviceMetric belongs to and that contains administrative device information such as manufacturer, serial number, etc. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // Describes the link to the  Device that this DeviceMetric belongs to and that contains administrative device information such as manufacturer, serial number, etc.
    property sourceElement : TFhirReference read FSource write SetSource;

    // Typed access to Describes the link to the  Device that this DeviceMetric belongs to and that provide information about the location of this DeviceMetric in the containment structure of the parent Device. An example would be a Device that represents a Channel. This reference can be used by a client application to distinguish DeviceMetrics that have the same type, but should be interpreted based on their containment location. (defined for API consistency)
    property parent : TFhirReference read FParent write SetParent;
    // Describes the link to the  Device that this DeviceMetric belongs to and that provide information about the location of this DeviceMetric in the containment structure of the parent Device. An example would be a Device that represents a Channel. This reference can be used by a client application to distinguish DeviceMetrics that have the same type, but should be interpreted based on their containment location.
    property parentElement : TFhirReference read FParent write SetParent;

    // Indicates current operational state of the device. For example: On, Off, Standby, etc.
    property operationalStatus : TFhirDeviceMetricOperationalStatusEnum read GetOperationalStatusST write SetOperationalStatusST;
    property operationalStatusElement : TFhirEnum read FOperationalStatus write SetOperationalStatus;

    // Describes the color representation for the metric. This is often used to aid clinicians to track and identify parameter types by color. In practice, consider a Patient Monitor that has ECG/HR and Pleth for example; the parameters are displayed in different characteristic colors, such as HR-blue, BP-green, and PR and SpO2- magenta.
    property color : TFhirDeviceMetricColorEnum read GetColorST write SetColorST;
    property colorElement : TFhirEnum read FColor write SetColor;

    // Indicates the category of the observation generation process. A DeviceMetric can be for example a setting, measurement, or calculation.
    property category : TFhirDeviceMetricCategoryEnum read GetCategoryST write SetCategoryST;
    property categoryElement : TFhirEnum read FCategory write SetCategory;

    // Typed access to Describes the measurement repetition time. This is not necessarily the same as the update period. The measurement repetition time can range from milliseconds up to hours. An example for a measurement repetition time in the range of milliseconds is the sampling rate of an ECG. An example for a measurement repetition time in the range of hours is a NIBP that is triggered automatically every hour. The update period may be different than the measurement repetition time, if the device does not update the published observed value with the same frequency as it was measured. (defined for API consistency)
    property measurementPeriod : TFhirTiming read FMeasurementPeriod write SetMeasurementPeriod;
    // Describes the measurement repetition time. This is not necessarily the same as the update period. The measurement repetition time can range from milliseconds up to hours. An example for a measurement repetition time in the range of milliseconds is the sampling rate of an ECG. An example for a measurement repetition time in the range of hours is a NIBP that is triggered automatically every hour. The update period may be different than the measurement repetition time, if the device does not update the published observed value with the same frequency as it was measured.
    property measurementPeriodElement : TFhirTiming read FMeasurementPeriod write SetMeasurementPeriod;

    // Describes the calibrations that have been performed or that are required to be performed.
    property calibrationList : TFhirDeviceMetricCalibrationList read GetCalibrationList;
    property hasCalibrationList : boolean read GetHasCalibrationList;

  end;

  TFhirDeviceMetricListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirDeviceMetricList;
    function GetCurrent : TFhirDeviceMetric;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirDeviceMetricList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirDeviceMetric read GetCurrent;
  end;

  TFhirDeviceMetricList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirDeviceMetric;
    procedure SetItemN(index : Integer; value : TFhirDeviceMetric);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirDeviceMetricList; overload;
    function Clone : TFhirDeviceMetricList; overload;
    function GetEnumerator : TFhirDeviceMetricListEnumerator;
    
    //  Add a FhirDeviceMetric to the end of the list.
    function Append : TFhirDeviceMetric;
    
    // Add an already existing FhirDeviceMetric to the end of the list.
    function AddItem(value : TFhirDeviceMetric) : TFhirDeviceMetric; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirDeviceMetric) : Integer;
    
    // Insert FhirDeviceMetric before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirDeviceMetric;
    
    // Insert an existing FhirDeviceMetric before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirDeviceMetric);
    
    // Get the iIndexth FhirDeviceMetric. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirDeviceMetric);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirDeviceMetric;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirDeviceMetrics[index : Integer] : TFhirDeviceMetric read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
  // The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
  TFhirEncounterStatusHistory = class (TFhirBackboneElement)
  protected
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEncounterStatusEnum;
    procedure SetStatusST(value : TFhirEncounterStatusEnum);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterStatusHistory; overload;
    function Clone : TFhirEncounterStatusHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // planned | arrived | triaged | in-progress | onleave | finished | cancelled +.
    property status : TFhirEncounterStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The time that the episode was in the specified status. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time that the episode was in the specified status.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterStatusHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterStatusHistoryList;
    function GetCurrent : TFhirEncounterStatusHistory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterStatusHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterStatusHistory read GetCurrent;
  end;

  TFhirEncounterStatusHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterStatusHistory;
    procedure SetItemN(index : Integer; value : TFhirEncounterStatusHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterStatusHistoryList; overload;
    function Clone : TFhirEncounterStatusHistoryList; overload;
    function GetEnumerator : TFhirEncounterStatusHistoryListEnumerator;
    
    //  Add a FhirEncounterStatusHistory to the end of the list.
    function Append : TFhirEncounterStatusHistory;
    
    // Add an already existing FhirEncounterStatusHistory to the end of the list.
    function AddItem(value : TFhirEncounterStatusHistory) : TFhirEncounterStatusHistory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterStatusHistory) : Integer;
    
    // Insert FhirEncounterStatusHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterStatusHistory;
    
    // Insert an existing FhirEncounterStatusHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterStatusHistory);
    
    // Get the iIndexth FhirEncounterStatusHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterStatusHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterStatusHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterStatusHistories[index : Integer] : TFhirEncounterStatusHistory read GetItemN write SetItemN; default;
  End;

  // The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
  TFhirEncounterClassHistory = class (TFhirBackboneElement)
  protected
    FClass_ : TFhirCoding;
    FPeriod : TFhirPeriod;
    procedure SetClass_(value : TFhirCoding);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterClassHistory; overload;
    function Clone : TFhirEncounterClassHistory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to inpatient | outpatient | ambulatory | emergency +. (defined for API consistency)
    property class_ : TFhirCoding read FClass_ write SetClass_;
    // inpatient | outpatient | ambulatory | emergency +.
    property class_Element : TFhirCoding read FClass_ write SetClass_;

    // Typed access to The time that the episode was in the specified class. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The time that the episode was in the specified class.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterClassHistoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterClassHistoryList;
    function GetCurrent : TFhirEncounterClassHistory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterClassHistoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterClassHistory read GetCurrent;
  end;

  TFhirEncounterClassHistoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterClassHistory;
    procedure SetItemN(index : Integer; value : TFhirEncounterClassHistory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterClassHistoryList; overload;
    function Clone : TFhirEncounterClassHistoryList; overload;
    function GetEnumerator : TFhirEncounterClassHistoryListEnumerator;
    
    //  Add a FhirEncounterClassHistory to the end of the list.
    function Append : TFhirEncounterClassHistory;
    
    // Add an already existing FhirEncounterClassHistory to the end of the list.
    function AddItem(value : TFhirEncounterClassHistory) : TFhirEncounterClassHistory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterClassHistory) : Integer;
    
    // Insert FhirEncounterClassHistory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterClassHistory;
    
    // Insert an existing FhirEncounterClassHistory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterClassHistory);
    
    // Get the iIndexth FhirEncounterClassHistory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterClassHistory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterClassHistory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterClassHistories[index : Integer] : TFhirEncounterClassHistory read GetItemN write SetItemN; default;
  End;

  // The list of people responsible for providing the service.
  TFhirEncounterParticipant = class (TFhirBackboneElement)
  protected
    Ftype_List : TFhirCodeableConceptList;
    FPeriod : TFhirPeriod;
    FIndividual : TFhirReference;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetIndividual(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterParticipant; overload;
    function Clone : TFhirEncounterParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Role of participant in encounter.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to The period of time that the specified participant participated in the encounter. These can overlap or be sub-sets of the overall encounter's period. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time that the specified participant participated in the encounter. These can overlap or be sub-sets of the overall encounter's period.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Persons involved in the encounter other than the patient. (defined for API consistency)
    property individual : TFhirReference read FIndividual write SetIndividual;
    // Persons involved in the encounter other than the patient.
    property individualElement : TFhirReference read FIndividual write SetIndividual;

  end;

  TFhirEncounterParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterParticipantList;
    function GetCurrent : TFhirEncounterParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterParticipant read GetCurrent;
  end;

  TFhirEncounterParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterParticipant;
    procedure SetItemN(index : Integer; value : TFhirEncounterParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterParticipantList; overload;
    function Clone : TFhirEncounterParticipantList; overload;
    function GetEnumerator : TFhirEncounterParticipantListEnumerator;
    
    //  Add a FhirEncounterParticipant to the end of the list.
    function Append : TFhirEncounterParticipant;
    
    // Add an already existing FhirEncounterParticipant to the end of the list.
    function AddItem(value : TFhirEncounterParticipant) : TFhirEncounterParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterParticipant) : Integer;
    
    // Insert FhirEncounterParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterParticipant;
    
    // Insert an existing FhirEncounterParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterParticipant);
    
    // Get the iIndexth FhirEncounterParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterParticipants[index : Integer] : TFhirEncounterParticipant read GetItemN write SetItemN; default;
  End;

  // The list of diagnosis relevant to this encounter.
  TFhirEncounterDiagnosis = class (TFhirBackboneElement)
  protected
    FCondition : TFhirReference;
    FUse : TFhirCodeableConcept;
    FRank : TFhirPositiveInt;
    procedure SetCondition(value : TFhirReference);
    procedure SetUse(value : TFhirCodeableConcept);
    procedure SetRank(value : TFhirPositiveInt);
    function GetRankST : String;
    procedure SetRankST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterDiagnosis; overload;
    function Clone : TFhirEncounterDiagnosis; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reason the encounter takes place, as specified using information from another resource. For admissions, this is the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure. (defined for API consistency)
    property condition : TFhirReference read FCondition write SetCondition;
    // Reason the encounter takes place, as specified using information from another resource. For admissions, this is the admission diagnosis. The indication will typically be a Condition (with other resources referenced in the evidence.detail), or a Procedure.
    property conditionElement : TFhirReference read FCondition write SetCondition;

    // Typed access to Role that this diagnosis has within the encounter (e.g. admission, billing, discharge �). (defined for API consistency)
    property use : TFhirCodeableConcept read FUse write SetUse;
    // Role that this diagnosis has within the encounter (e.g. admission, billing, discharge �).
    property useElement : TFhirCodeableConcept read FUse write SetUse;

    // Typed access to Ranking of the diagnosis (for each role type).
    property rank : String read GetRankST write SetRankST;
    // Ranking of the diagnosis (for each role type).
    property rankElement : TFhirPositiveInt read FRank write SetRank;

  end;

  TFhirEncounterDiagnosisListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterDiagnosisList;
    function GetCurrent : TFhirEncounterDiagnosis;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterDiagnosisList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterDiagnosis read GetCurrent;
  end;

  TFhirEncounterDiagnosisList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterDiagnosis;
    procedure SetItemN(index : Integer; value : TFhirEncounterDiagnosis);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterDiagnosisList; overload;
    function Clone : TFhirEncounterDiagnosisList; overload;
    function GetEnumerator : TFhirEncounterDiagnosisListEnumerator;
    
    //  Add a FhirEncounterDiagnosis to the end of the list.
    function Append : TFhirEncounterDiagnosis;
    
    // Add an already existing FhirEncounterDiagnosis to the end of the list.
    function AddItem(value : TFhirEncounterDiagnosis) : TFhirEncounterDiagnosis; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterDiagnosis) : Integer;
    
    // Insert FhirEncounterDiagnosis before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterDiagnosis;
    
    // Insert an existing FhirEncounterDiagnosis before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterDiagnosis);
    
    // Get the iIndexth FhirEncounterDiagnosis. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterDiagnosis);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterDiagnosis;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterDiagnoses[index : Integer] : TFhirEncounterDiagnosis read GetItemN write SetItemN; default;
  End;

  // Details about the admission to a healthcare service.
  TFhirEncounterHospitalization = class (TFhirBackboneElement)
  protected
    FPreAdmissionIdentifier : TFhirIdentifier;
    FOrigin : TFhirReference;
    FAdmitSource : TFhirCodeableConcept;
    FReAdmission : TFhirCodeableConcept;
    FdietPreferenceList : TFhirCodeableConceptList;
    FspecialCourtesyList : TFhirCodeableConceptList;
    FspecialArrangementList : TFhirCodeableConceptList;
    FDestination : TFhirReference;
    FDischargeDisposition : TFhirCodeableConcept;
    procedure SetPreAdmissionIdentifier(value : TFhirIdentifier);
    procedure SetOrigin(value : TFhirReference);
    procedure SetAdmitSource(value : TFhirCodeableConcept);
    procedure SetReAdmission(value : TFhirCodeableConcept);
    function GetDietPreferenceList : TFhirCodeableConceptList;
    function GetHasDietPreferenceList : Boolean;
    function GetSpecialCourtesyList : TFhirCodeableConceptList;
    function GetHasSpecialCourtesyList : Boolean;
    function GetSpecialArrangementList : TFhirCodeableConceptList;
    function GetHasSpecialArrangementList : Boolean;
    procedure SetDestination(value : TFhirReference);
    procedure SetDischargeDisposition(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterHospitalization; overload;
    function Clone : TFhirEncounterHospitalization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Pre-admission identifier. (defined for API consistency)
    property preAdmissionIdentifier : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;
    // Pre-admission identifier.
    property preAdmissionIdentifierElement : TFhirIdentifier read FPreAdmissionIdentifier write SetPreAdmissionIdentifier;

    // Typed access to The location/organization from which the patient came before admission. (defined for API consistency)
    property origin : TFhirReference read FOrigin write SetOrigin;
    // The location/organization from which the patient came before admission.
    property originElement : TFhirReference read FOrigin write SetOrigin;

    // Typed access to From where patient was admitted (physician referral, transfer). (defined for API consistency)
    property admitSource : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;
    // From where patient was admitted (physician referral, transfer).
    property admitSourceElement : TFhirCodeableConcept read FAdmitSource write SetAdmitSource;

    // Typed access to Whether this hospitalization is a readmission and why if known. (defined for API consistency)
    property reAdmission : TFhirCodeableConcept read FReAdmission write SetReAdmission;
    // Whether this hospitalization is a readmission and why if known.
    property reAdmissionElement : TFhirCodeableConcept read FReAdmission write SetReAdmission;

    // Diet preferences reported by the patient.
    property dietPreferenceList : TFhirCodeableConceptList read GetDietPreferenceList;
    property hasDietPreferenceList : boolean read GetHasDietPreferenceList;

    // Special courtesies (VIP, board member).
    property specialCourtesyList : TFhirCodeableConceptList read GetSpecialCourtesyList;
    property hasSpecialCourtesyList : boolean read GetHasSpecialCourtesyList;

    // Any special requests that have been made for this hospitalization encounter, such as the provision of specific equipment or other things.
    property specialArrangementList : TFhirCodeableConceptList read GetSpecialArrangementList;
    property hasSpecialArrangementList : boolean read GetHasSpecialArrangementList;

    // Typed access to Location/organization to which the patient is discharged. (defined for API consistency)
    property destination : TFhirReference read FDestination write SetDestination;
    // Location/organization to which the patient is discharged.
    property destinationElement : TFhirReference read FDestination write SetDestination;

    // Typed access to Category or kind of location after discharge. (defined for API consistency)
    property dischargeDisposition : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;
    // Category or kind of location after discharge.
    property dischargeDispositionElement : TFhirCodeableConcept read FDischargeDisposition write SetDischargeDisposition;

  end;

  TFhirEncounterHospitalizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterHospitalizationList;
    function GetCurrent : TFhirEncounterHospitalization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterHospitalizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterHospitalization read GetCurrent;
  end;

  TFhirEncounterHospitalizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterHospitalization;
    procedure SetItemN(index : Integer; value : TFhirEncounterHospitalization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterHospitalizationList; overload;
    function Clone : TFhirEncounterHospitalizationList; overload;
    function GetEnumerator : TFhirEncounterHospitalizationListEnumerator;
    
    //  Add a FhirEncounterHospitalization to the end of the list.
    function Append : TFhirEncounterHospitalization;
    
    // Add an already existing FhirEncounterHospitalization to the end of the list.
    function AddItem(value : TFhirEncounterHospitalization) : TFhirEncounterHospitalization; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterHospitalization) : Integer;
    
    // Insert FhirEncounterHospitalization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterHospitalization;
    
    // Insert an existing FhirEncounterHospitalization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterHospitalization);
    
    // Get the iIndexth FhirEncounterHospitalization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterHospitalization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterHospitalization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterHospitalizations[index : Integer] : TFhirEncounterHospitalization read GetItemN write SetItemN; default;
  End;

  // List of locations where  the patient has been during this encounter.
  TFhirEncounterLocation = class (TFhirBackboneElement)
  protected
    FLocation : TFhirReference;
    FStatus : TFhirEnum;
    FPhysicalType : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    procedure SetLocation(value : TFhirReference);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEncounterLocationStatusEnum;
    procedure SetStatusST(value : TFhirEncounterLocationStatusEnum);
    procedure SetPhysicalType(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounterLocation; overload;
    function Clone : TFhirEncounterLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The location where the encounter takes place. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // The location where the encounter takes place.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // The status of the participants' presence at the specified location during the period specified. If the participant is no longer at the location, then the period will have an end date/time.
    property status : TFhirEncounterLocationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to This will be used to specify the required levels (bed/ward/room/etc.) desired to be recorded to simplify either messaging or query. (defined for API consistency)
    property physicalType : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;
    // This will be used to specify the required levels (bed/ward/room/etc.) desired to be recorded to simplify either messaging or query.
    property physicalTypeElement : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;

    // Typed access to Time period during which the patient was present at the location. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Time period during which the patient was present at the location.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEncounterLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterLocationList;
    function GetCurrent : TFhirEncounterLocation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounterLocation read GetCurrent;
  end;

  TFhirEncounterLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounterLocation;
    procedure SetItemN(index : Integer; value : TFhirEncounterLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterLocationList; overload;
    function Clone : TFhirEncounterLocationList; overload;
    function GetEnumerator : TFhirEncounterLocationListEnumerator;
    
    //  Add a FhirEncounterLocation to the end of the list.
    function Append : TFhirEncounterLocation;
    
    // Add an already existing FhirEncounterLocation to the end of the list.
    function AddItem(value : TFhirEncounterLocation) : TFhirEncounterLocation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounterLocation) : Integer;
    
    // Insert FhirEncounterLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounterLocation;
    
    // Insert an existing FhirEncounterLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounterLocation);
    
    // Get the iIndexth FhirEncounterLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounterLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounterLocation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounterLocations[index : Integer] : TFhirEncounterLocation read GetItemN write SetItemN; default;
  End;

  // An interaction between a patient and healthcare provider(s) for the purpose of providing healthcare service(s) or assessing the health status of a patient.
  TFhirEncounter = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FstatusHistoryList : TFhirEncounterStatusHistoryList;
    FClass_ : TFhirCoding;
    FclassHistoryList : TFhirEncounterClassHistoryList;
    Ftype_List : TFhirCodeableConceptList;
    FServiceType : TFhirCodeableConcept;
    FPriority : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FepisodeOfCareList : TFhirReferenceList;
    FbasedOnList : TFhirReferenceList;
    FparticipantList : TFhirEncounterParticipantList;
    FappointmentList : TFhirReferenceList;
    FPeriod : TFhirPeriod;
    FLength : TFhirDuration;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FdiagnosisList : TFhirEncounterDiagnosisList;
    FaccountList : TFhirReferenceList;
    FHospitalization : TFhirEncounterHospitalization;
    FlocationList : TFhirEncounterLocationList;
    FServiceProvider : TFhirReference;
    FPartOf : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEncounterStatusEnum;
    procedure SetStatusST(value : TFhirEncounterStatusEnum);
    function GetStatusHistoryList : TFhirEncounterStatusHistoryList;
    function GetHasStatusHistoryList : Boolean;
    procedure SetClass_(value : TFhirCoding);
    function GetClassHistoryList : TFhirEncounterClassHistoryList;
    function GetHasClassHistoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetServiceType(value : TFhirCodeableConcept);
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    function GetEpisodeOfCareList : TFhirReferenceList;
    function GetHasEpisodeOfCareList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetParticipantList : TFhirEncounterParticipantList;
    function GetHasParticipantList : Boolean;
    function GetAppointmentList : TFhirReferenceList;
    function GetHasAppointmentList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetLength(value : TFhirDuration);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetDiagnosisList : TFhirEncounterDiagnosisList;
    function GetHasDiagnosisList : Boolean;
    function GetAccountList : TFhirReferenceList;
    function GetHasAccountList : Boolean;
    procedure SetHospitalization(value : TFhirEncounterHospitalization);
    function GetLocationList : TFhirEncounterLocationList;
    function GetHasLocationList : Boolean;
    procedure SetServiceProvider(value : TFhirReference);
    procedure SetPartOf(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEncounter; overload;
    function Clone : TFhirEncounter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier(s) by which this encounter is known.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // planned | arrived | triaged | in-progress | onleave | finished | cancelled +.
    property status : TFhirEncounterStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The status history permits the encounter resource to contain the status history without needing to read through the historical versions of the resource, or even have the server store them.
    property statusHistoryList : TFhirEncounterStatusHistoryList read GetStatusHistoryList;
    property hasStatusHistoryList : boolean read GetHasStatusHistoryList;

    // Typed access to Concepts representing classification of patient encounter such as ambulatory (outpatient), inpatient, emergency, home health or others due to local variations. (defined for API consistency)
    property class_ : TFhirCoding read FClass_ write SetClass_;
    // Concepts representing classification of patient encounter such as ambulatory (outpatient), inpatient, emergency, home health or others due to local variations.
    property class_Element : TFhirCoding read FClass_ write SetClass_;

    // The class history permits the tracking of the encounters transitions without needing to go  through the resource history.  This would be used for a case where an admission starts of as an emergency encounter, then transitions into an inpatient scenario. Doing this and not restarting a new encounter ensures that any lab/diagnostic results can more easily follow the patient and not require re-processing and not get lost or cancelled during a kind of discharge from emergency to inpatient.
    property classHistoryList : TFhirEncounterClassHistoryList read GetClassHistoryList;
    property hasClassHistoryList : boolean read GetHasClassHistoryList;

    // Specific type of encounter (e.g. e-mail consultation, surgical day-care, skilled nursing, rehabilitation).
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to Broad categorization of the service that is to be provided (e.g. cardiology). (defined for API consistency)
    property serviceType : TFhirCodeableConcept read FServiceType write SetServiceType;
    // Broad categorization of the service that is to be provided (e.g. cardiology).
    property serviceTypeElement : TFhirCodeableConcept read FServiceType write SetServiceType;

    // Typed access to Indicates the urgency of the encounter. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Indicates the urgency of the encounter.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to The patient or group present at the encounter. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient or group present at the encounter.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Where a specific encounter should be classified as a part of a specific episode(s) of care this field should be used. This association can facilitate grouping of related encounters together for a specific purpose, such as government reporting, issue tracking, association via a common problem.  The association is recorded on the encounter as these are typically created after the episode of care and grouped on entry rather than editing the episode of care to append another encounter to it (the episode of care could span years).
    property episodeOfCareList : TFhirReferenceList read GetEpisodeOfCareList;
    property hasEpisodeOfCareList : boolean read GetHasEpisodeOfCareList;

    // The request this encounter satisfies (e.g. incoming referral or procedure request).
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // The list of people responsible for providing the service.
    property participantList : TFhirEncounterParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // The appointment that scheduled this encounter.
    property appointmentList : TFhirReferenceList read GetAppointmentList;
    property hasAppointmentList : boolean read GetHasAppointmentList;

    // Typed access to The start and end time of the encounter. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The start and end time of the encounter.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Quantity of time the encounter lasted. This excludes the time during leaves of absence. (defined for API consistency)
    property length : TFhirDuration read FLength write SetLength;
    // Quantity of time the encounter lasted. This excludes the time during leaves of absence.
    property lengthElement : TFhirDuration read FLength write SetLength;

    // Reason the encounter takes place, expressed as a code. For admissions, this can be used for a coded admission diagnosis.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Reason the encounter takes place, expressed as a code. For admissions, this can be used for a coded admission diagnosis.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // The list of diagnosis relevant to this encounter.
    property diagnosisList : TFhirEncounterDiagnosisList read GetDiagnosisList;
    property hasDiagnosisList : boolean read GetHasDiagnosisList;

    // The set of accounts that may be used for billing for this Encounter.
    property accountList : TFhirReferenceList read GetAccountList;
    property hasAccountList : boolean read GetHasAccountList;

    // Typed access to Details about the admission to a healthcare service. (defined for API consistency)
    property hospitalization : TFhirEncounterHospitalization read FHospitalization write SetHospitalization;
    // Details about the admission to a healthcare service.
    property hospitalizationElement : TFhirEncounterHospitalization read FHospitalization write SetHospitalization;

    // List of locations where  the patient has been during this encounter.
    property locationList : TFhirEncounterLocationList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Typed access to The organization that is primarily responsible for this Encounter's services. This MAY be the same as the organization on the Patient record, however it could be different, such as if the actor performing the services was from an external organization (which may be billed seperately) for an external consultation.  Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy. (defined for API consistency)
    property serviceProvider : TFhirReference read FServiceProvider write SetServiceProvider;
    // The organization that is primarily responsible for this Encounter's services. This MAY be the same as the organization on the Patient record, however it could be different, such as if the actor performing the services was from an external organization (which may be billed seperately) for an external consultation.  Refer to the example bundle showing an abbreviated set of Encounters for a colonoscopy.
    property serviceProviderElement : TFhirReference read FServiceProvider write SetServiceProvider;

    // Typed access to Another Encounter of which this encounter is a part of (administratively or in time). (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // Another Encounter of which this encounter is a part of (administratively or in time).
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

  end;

  TFhirEncounterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEncounterList;
    function GetCurrent : TFhirEncounter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEncounterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEncounter read GetCurrent;
  end;

  TFhirEncounterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEncounter;
    procedure SetItemN(index : Integer; value : TFhirEncounter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEncounterList; overload;
    function Clone : TFhirEncounterList; overload;
    function GetEnumerator : TFhirEncounterListEnumerator;
    
    //  Add a FhirEncounter to the end of the list.
    function Append : TFhirEncounter;
    
    // Add an already existing FhirEncounter to the end of the list.
    function AddItem(value : TFhirEncounter) : TFhirEncounter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEncounter) : Integer;
    
    // Insert FhirEncounter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEncounter;
    
    // Insert an existing FhirEncounter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEncounter);
    
    // Get the iIndexth FhirEncounter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEncounter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEncounter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEncounters[index : Integer] : TFhirEncounter read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
  // The technical details of an endpoint that can be used for electronic services, such as for web services providing XDS.b or a REST endpoint for another FHIR server. This may include any security context information.
  TFhirEndpoint = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FConnectionType : TFhirCoding;
    FName : TFhirString;
    FManagingOrganization : TFhirReference;
    FcontactList : TFhirContactPointList;
    FPeriod : TFhirPeriod;
    FpayloadTypeList : TFhirCodeableConceptList;
    FpayloadMimeTypeList : TFhirCodeList;
    FAddress : TFhirUrl;
    FheaderList : TFhirStringList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEndpointStatusEnum;
    procedure SetStatusST(value : TFhirEndpointStatusEnum);
    procedure SetConnectionType(value : TFhirCoding);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetManagingOrganization(value : TFhirReference);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    function GetPayloadTypeList : TFhirCodeableConceptList;
    function GetHasPayloadTypeList : Boolean;
    function GetPayloadMimeTypeList : TFhirCodeList;
    function GetHasPayloadMimeTypeList : Boolean;
    procedure SetAddress(value : TFhirUrl);
    function GetAddressST : String;
    procedure SetAddressST(value : String);
    function GetHeaderList : TFhirStringList;
    function GetHasHeaderList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEndpoint; overload;
    function Clone : TFhirEndpoint; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the organization that is used to identify the endpoint across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // active | suspended | error | off | test.
    property status : TFhirEndpointStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A coded value that represents the technical details of the usage of this endpoint, such as what WSDLs should be used in what way. (e.g. XDS.b/DICOM/cds-hook). (defined for API consistency)
    property connectionType : TFhirCoding read FConnectionType write SetConnectionType;
    // A coded value that represents the technical details of the usage of this endpoint, such as what WSDLs should be used in what way. (e.g. XDS.b/DICOM/cds-hook).
    property connectionTypeElement : TFhirCoding read FConnectionType write SetConnectionType;

    // Typed access to A friendly name that this endpoint can be referred to with.
    property name : String read GetNameST write SetNameST;
    // A friendly name that this endpoint can be referred to with.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The organization that manages this endpoint (even if technically another organization is hosting this in the cloud, it is the organization associated with the data). (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization that manages this endpoint (even if technically another organization is hosting this in the cloud, it is the organization associated with the data).
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Contact details for a human to contact about the subscription. The primary use of this for system administrator troubleshooting.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The interval during which the endpoint is expected to be operational. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The interval during which the endpoint is expected to be operational.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // The payload type describes the acceptable content that can be communicated on the endpoint.
    property payloadTypeList : TFhirCodeableConceptList read GetPayloadTypeList;
    property hasPayloadTypeList : boolean read GetHasPayloadTypeList;

    // The mime type to send the payload in - e.g. application/fhir+xml, application/fhir+json. If the mime type is not specified, then the sender could send any content (including no content depending on the connectionType).
    property payloadMimeTypeList : TFhirCodeList read GetPayloadMimeTypeList;
    property hasPayloadMimeTypeList : boolean read GetHasPayloadMimeTypeList;

    // Typed access to The uri that describes the actual end-point to connect to.
    property address : String read GetAddressST write SetAddressST;
    // The uri that describes the actual end-point to connect to.
    property addressElement : TFhirUrl read FAddress write SetAddress;

    // Additional headers / information to send as part of the notification.
    property headerList : TFhirStringList read GetHeaderList;
    property hasHeaderList : boolean read GetHasHeaderList;

  end;

  TFhirEndpointListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEndpointList;
    function GetCurrent : TFhirEndpoint;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEndpointList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEndpoint read GetCurrent;
  end;

  TFhirEndpointList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEndpoint;
    procedure SetItemN(index : Integer; value : TFhirEndpoint);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEndpointList; overload;
    function Clone : TFhirEndpointList; overload;
    function GetEnumerator : TFhirEndpointListEnumerator;
    
    //  Add a FhirEndpoint to the end of the list.
    function Append : TFhirEndpoint;
    
    // Add an already existing FhirEndpoint to the end of the list.
    function AddItem(value : TFhirEndpoint) : TFhirEndpoint; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEndpoint) : Integer;
    
    // Insert FhirEndpoint before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEndpoint;
    
    // Insert an existing FhirEndpoint before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEndpoint);
    
    // Get the iIndexth FhirEndpoint. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEndpoint);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEndpoint;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEndpoints[index : Integer] : TFhirEndpoint read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_GROUP}
  // Identifies traits whose presence r absence is shared by members of the group.
  TFhirGroupCharacteristic = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FExclude : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetExclude(value : TFhirBoolean);
    function GetExcludeST : Boolean;
    procedure SetExcludeST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroupCharacteristic; overload;
    function Clone : TFhirGroupCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code that identifies the kind of trait being asserted. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies the kind of trait being asserted.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The value of the trait that holds (or does not hold - see 'exclude') for members of the group. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the trait that holds (or does not hold - see 'exclude') for members of the group.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to If true, indicates the characteristic is one that is NOT held by members of the group.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // If true, indicates the characteristic is one that is NOT held by members of the group.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to The period over which the characteristic is tested; e.g. the patient had an operation during the month of June. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period over which the characteristic is tested; e.g. the patient had an operation during the month of June.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirGroupCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupCharacteristicList;
    function GetCurrent : TFhirGroupCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGroupCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroupCharacteristic read GetCurrent;
  end;

  TFhirGroupCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroupCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirGroupCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGroupCharacteristicList; overload;
    function Clone : TFhirGroupCharacteristicList; overload;
    function GetEnumerator : TFhirGroupCharacteristicListEnumerator;
    
    //  Add a FhirGroupCharacteristic to the end of the list.
    function Append : TFhirGroupCharacteristic;
    
    // Add an already existing FhirGroupCharacteristic to the end of the list.
    function AddItem(value : TFhirGroupCharacteristic) : TFhirGroupCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroupCharacteristic) : Integer;
    
    // Insert FhirGroupCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroupCharacteristic;
    
    // Insert an existing FhirGroupCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroupCharacteristic);
    
    // Get the iIndexth FhirGroupCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroupCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroupCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGroupCharacteristics[index : Integer] : TFhirGroupCharacteristic read GetItemN write SetItemN; default;
  End;

  // Identifies the resource instances that are members of the group.
  TFhirGroupMember = class (TFhirBackboneElement)
  protected
    FEntity : TFhirReference;
    FPeriod : TFhirPeriod;
    FInactive : TFhirBoolean;
    procedure SetEntity(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetInactive(value : TFhirBoolean);
    function GetInactiveST : Boolean;
    procedure SetInactiveST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroupMember; overload;
    function Clone : TFhirGroupMember; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A reference to the entity that is a member of the group. Must be consistent with Group.type. If the entity is another group, then the type must be the same. (defined for API consistency)
    property entity : TFhirReference read FEntity write SetEntity;
    // A reference to the entity that is a member of the group. Must be consistent with Group.type. If the entity is another group, then the type must be the same.
    property entityElement : TFhirReference read FEntity write SetEntity;

    // Typed access to The period that the member was in the group, if known. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period that the member was in the group, if known.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to A flag to indicate that the member is no longer in the group, but previously may have been a member.
    property inactive : Boolean read GetInactiveST write SetInactiveST;
    // A flag to indicate that the member is no longer in the group, but previously may have been a member.
    property inactiveElement : TFhirBoolean read FInactive write SetInactive;

  end;

  TFhirGroupMemberListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupMemberList;
    function GetCurrent : TFhirGroupMember;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGroupMemberList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroupMember read GetCurrent;
  end;

  TFhirGroupMemberList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroupMember;
    procedure SetItemN(index : Integer; value : TFhirGroupMember);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGroupMemberList; overload;
    function Clone : TFhirGroupMemberList; overload;
    function GetEnumerator : TFhirGroupMemberListEnumerator;
    
    //  Add a FhirGroupMember to the end of the list.
    function Append : TFhirGroupMember;
    
    // Add an already existing FhirGroupMember to the end of the list.
    function AddItem(value : TFhirGroupMember) : TFhirGroupMember; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroupMember) : Integer;
    
    // Insert FhirGroupMember before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroupMember;
    
    // Insert an existing FhirGroupMember before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroupMember);
    
    // Get the iIndexth FhirGroupMember. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroupMember);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroupMember;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGroupMembers[index : Integer] : TFhirGroupMember read GetItemN write SetItemN; default;
  End;

  // Represents a defined collection of entities that may be discussed or acted upon collectively but which are not expected to act collectively, and are not formally or legally recognized; i.e. a collection of entities that isn't an Organization.
  TFhirGroup = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FType_ : TFhirEnum;
    FActual : TFhirBoolean;
    FCode : TFhirCodeableConcept;
    FName : TFhirString;
    FQuantity : TFhirUnsignedInt;
    FManagingEntity : TFhirReference;
    FcharacteristicList : TFhirGroupCharacteristicList;
    FmemberList : TFhirGroupMemberList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirGroupTypeEnum;
    procedure SetType_ST(value : TFhirGroupTypeEnum);
    procedure SetActual(value : TFhirBoolean);
    function GetActualST : Boolean;
    procedure SetActualST(value : Boolean);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetQuantity(value : TFhirUnsignedInt);
    function GetQuantityST : String;
    procedure SetQuantityST(value : String);
    procedure SetManagingEntity(value : TFhirReference);
    function GetCharacteristicList : TFhirGroupCharacteristicList;
    function GetHasCharacteristicList : Boolean;
    function GetMemberList : TFhirGroupMemberList;
    function GetHasMemberList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGroup; overload;
    function Clone : TFhirGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A unique business identifier for this group.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Indicates whether the record for the group is available for use or is merely being retained for historical purposes.
    property active : Boolean read GetActiveST write SetActiveST;
    // Indicates whether the record for the group is available for use or is merely being retained for historical purposes.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Identifies the broad classification of the kind of resources the group includes.
    property type_ : TFhirGroupTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to If true, indicates that the resource refers to a specific group of real individuals.  If false, the group defines a set of intended individuals.
    property actual : Boolean read GetActualST write SetActualST;
    // If true, indicates that the resource refers to a specific group of real individuals.  If false, the group defines a set of intended individuals.
    property actualElement : TFhirBoolean read FActual write SetActual;

    // Typed access to Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Provides a specific type of resource the group includes; e.g. "cow", "syringe", etc.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A label assigned to the group for human identification and communication.
    property name : String read GetNameST write SetNameST;
    // A label assigned to the group for human identification and communication.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A count of the number of resource instances that are part of the group.
    property quantity : String read GetQuantityST write SetQuantityST;
    // A count of the number of resource instances that are part of the group.
    property quantityElement : TFhirUnsignedInt read FQuantity write SetQuantity;

    // Typed access to Entity responsible for defining and maintaining Group characteristics and/or registered members. (defined for API consistency)
    property managingEntity : TFhirReference read FManagingEntity write SetManagingEntity;
    // Entity responsible for defining and maintaining Group characteristics and/or registered members.
    property managingEntityElement : TFhirReference read FManagingEntity write SetManagingEntity;

    // Identifies traits whose presence r absence is shared by members of the group.
    property characteristicList : TFhirGroupCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Identifies the resource instances that are members of the group.
    property memberList : TFhirGroupMemberList read GetMemberList;
    property hasMemberList : boolean read GetHasMemberList;

  end;

  TFhirGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGroupList;
    function GetCurrent : TFhirGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGroup read GetCurrent;
  end;

  TFhirGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGroup;
    procedure SetItemN(index : Integer; value : TFhirGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGroupList; overload;
    function Clone : TFhirGroupList; overload;
    function GetEnumerator : TFhirGroupListEnumerator;
    
    //  Add a FhirGroup to the end of the list.
    function Append : TFhirGroup;
    
    // Add an already existing FhirGroup to the end of the list.
    function AddItem(value : TFhirGroup) : TFhirGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGroup) : Integer;
    
    // Insert FhirGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGroup;
    
    // Insert an existing FhirGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGroup);
    
    // Get the iIndexth FhirGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGroups[index : Integer] : TFhirGroup read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
  // Does this service have specific eligibility requirements that need to be met in order to use the service?
  TFhirHealthcareServiceEligibility = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FComment : TFhirMarkdown;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetComment(value : TFhirMarkdown);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceEligibility; overload;
    function Clone : TFhirHealthcareServiceEligibility; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Coded value for the eligibility. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded value for the eligibility.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Describes the eligibility conditions for the service.
    property comment : String read GetCommentST write SetCommentST;
    // Describes the eligibility conditions for the service.
    property commentElement : TFhirMarkdown read FComment write SetComment;

  end;

  TFhirHealthcareServiceEligibilityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceEligibilityList;
    function GetCurrent : TFhirHealthcareServiceEligibility;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceEligibilityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceEligibility read GetCurrent;
  end;

  TFhirHealthcareServiceEligibilityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareServiceEligibility;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceEligibility);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceEligibilityList; overload;
    function Clone : TFhirHealthcareServiceEligibilityList; overload;
    function GetEnumerator : TFhirHealthcareServiceEligibilityListEnumerator;
    
    //  Add a FhirHealthcareServiceEligibility to the end of the list.
    function Append : TFhirHealthcareServiceEligibility;
    
    // Add an already existing FhirHealthcareServiceEligibility to the end of the list.
    function AddItem(value : TFhirHealthcareServiceEligibility) : TFhirHealthcareServiceEligibility; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceEligibility) : Integer;
    
    // Insert FhirHealthcareServiceEligibility before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceEligibility;
    
    // Insert an existing FhirHealthcareServiceEligibility before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceEligibility);
    
    // Get the iIndexth FhirHealthcareServiceEligibility. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceEligibility);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceEligibility;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServiceEligibilities[index : Integer] : TFhirHealthcareServiceEligibility read GetItemN write SetItemN; default;
  End;

  // A collection of times that the Service Site is available.
  TFhirHealthcareServiceAvailableTime = class (TFhirBackboneElement)
  protected
    FDaysOfWeek : TFhirEnumList;
    FAllDay : TFhirBoolean;
    FAvailableStartTime : TFhirTime;
    FAvailableEndTime : TFhirTime;
    function GetDaysOfWeek : TFhirEnumList;
    function GetHasDaysOfWeek : Boolean;
    function GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
    procedure SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
    procedure SetAllDay(value : TFhirBoolean);
    function GetAllDayST : Boolean;
    procedure SetAllDayST(value : Boolean);
    procedure SetAvailableStartTime(value : TFhirTime);
    function GetAvailableStartTimeST : String;
    procedure SetAvailableStartTimeST(value : String);
    procedure SetAvailableEndTime(value : TFhirTime);
    function GetAvailableEndTimeST : String;
    procedure SetAvailableEndTimeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceAvailableTime; overload;
    function Clone : TFhirHealthcareServiceAvailableTime; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates which days of the week are available between the start and end Times.
    property daysOfWeek : TFhirDaysOfWeekEnumList read GetDaysOfWeekST write SetDaysOfWeekST;
    property daysOfWeekList : TFhirEnumList read GetDaysOfWeek;
    property hasDaysOfWeek : boolean read GetHasDaysOfWeek;
    // Typed access to Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDay : Boolean read GetAllDayST write SetAllDayST;
    // Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDayElement : TFhirBoolean read FAllDay write SetAllDay;

    // Typed access to The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTime : String read GetAvailableStartTimeST write SetAvailableStartTimeST;
    // The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTimeElement : TFhirTime read FAvailableStartTime write SetAvailableStartTime;

    // Typed access to The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTime : String read GetAvailableEndTimeST write SetAvailableEndTimeST;
    // The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTimeElement : TFhirTime read FAvailableEndTime write SetAvailableEndTime;

  end;

  TFhirHealthcareServiceAvailableTimeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceAvailableTimeList;
    function GetCurrent : TFhirHealthcareServiceAvailableTime;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceAvailableTimeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceAvailableTime read GetCurrent;
  end;

  TFhirHealthcareServiceAvailableTimeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareServiceAvailableTime;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceAvailableTime);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceAvailableTimeList; overload;
    function Clone : TFhirHealthcareServiceAvailableTimeList; overload;
    function GetEnumerator : TFhirHealthcareServiceAvailableTimeListEnumerator;
    
    //  Add a FhirHealthcareServiceAvailableTime to the end of the list.
    function Append : TFhirHealthcareServiceAvailableTime;
    
    // Add an already existing FhirHealthcareServiceAvailableTime to the end of the list.
    function AddItem(value : TFhirHealthcareServiceAvailableTime) : TFhirHealthcareServiceAvailableTime; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceAvailableTime) : Integer;
    
    // Insert FhirHealthcareServiceAvailableTime before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceAvailableTime;
    
    // Insert an existing FhirHealthcareServiceAvailableTime before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceAvailableTime);
    
    // Get the iIndexth FhirHealthcareServiceAvailableTime. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceAvailableTime);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceAvailableTime;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServiceAvailableTimes[index : Integer] : TFhirHealthcareServiceAvailableTime read GetItemN write SetItemN; default;
  End;

  // The HealthcareService is not available during this period of time due to the provided reason.
  TFhirHealthcareServiceNotAvailable = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FDuring : TFhirPeriod;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetDuring(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareServiceNotAvailable; overload;
    function Clone : TFhirHealthcareServiceNotAvailable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The reason that can be presented to the user as to why this time is not available.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The reason that can be presented to the user as to why this time is not available.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Service is not available (seasonally or for a public holiday) from this date. (defined for API consistency)
    property during : TFhirPeriod read FDuring write SetDuring;
    // Service is not available (seasonally or for a public holiday) from this date.
    property duringElement : TFhirPeriod read FDuring write SetDuring;

  end;

  TFhirHealthcareServiceNotAvailableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceNotAvailableList;
    function GetCurrent : TFhirHealthcareServiceNotAvailable;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceNotAvailableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareServiceNotAvailable read GetCurrent;
  end;

  TFhirHealthcareServiceNotAvailableList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareServiceNotAvailable;
    procedure SetItemN(index : Integer; value : TFhirHealthcareServiceNotAvailable);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceNotAvailableList; overload;
    function Clone : TFhirHealthcareServiceNotAvailableList; overload;
    function GetEnumerator : TFhirHealthcareServiceNotAvailableListEnumerator;
    
    //  Add a FhirHealthcareServiceNotAvailable to the end of the list.
    function Append : TFhirHealthcareServiceNotAvailable;
    
    // Add an already existing FhirHealthcareServiceNotAvailable to the end of the list.
    function AddItem(value : TFhirHealthcareServiceNotAvailable) : TFhirHealthcareServiceNotAvailable; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareServiceNotAvailable) : Integer;
    
    // Insert FhirHealthcareServiceNotAvailable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareServiceNotAvailable;
    
    // Insert an existing FhirHealthcareServiceNotAvailable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareServiceNotAvailable);
    
    // Get the iIndexth FhirHealthcareServiceNotAvailable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareServiceNotAvailable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareServiceNotAvailable;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServiceNotAvailables[index : Integer] : TFhirHealthcareServiceNotAvailable read GetItemN write SetItemN; default;
  End;

  // The details of a healthcare service available at a location.
  TFhirHealthcareService = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FProvidedBy : TFhirReference;
    FcategoryList : TFhirCodeableConceptList;
    Ftype_List : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList;
    FName : TFhirString;
    FComment : TFhirString;
    FExtraDetails : TFhirMarkdown;
    FPhoto : TFhirAttachment;
    FtelecomList : TFhirContactPointList;
    FcoverageAreaList : TFhirReferenceList;
    FserviceProvisionCodeList : TFhirCodeableConceptList;
    FeligibilityList : TFhirHealthcareServiceEligibilityList;
    Fprogram_List : TFhirCodeableConceptList;
    FcharacteristicList : TFhirCodeableConceptList;
    FcommunicationList : TFhirCodeableConceptList;
    FreferralMethodList : TFhirCodeableConceptList;
    FAppointmentRequired : TFhirBoolean;
    FavailableTimeList : TFhirHealthcareServiceAvailableTimeList;
    FnotAvailableList : TFhirHealthcareServiceNotAvailableList;
    FAvailabilityExceptions : TFhirString;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetProvidedBy(value : TFhirReference);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList;
    function GetHasLocationList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
    procedure SetExtraDetails(value : TFhirMarkdown);
    function GetExtraDetailsST : String;
    procedure SetExtraDetailsST(value : String);
    procedure SetPhoto(value : TFhirAttachment);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetCoverageAreaList : TFhirReferenceList;
    function GetHasCoverageAreaList : Boolean;
    function GetServiceProvisionCodeList : TFhirCodeableConceptList;
    function GetHasServiceProvisionCodeList : Boolean;
    function GetEligibilityList : TFhirHealthcareServiceEligibilityList;
    function GetHasEligibilityList : Boolean;
    function GetProgram_List : TFhirCodeableConceptList;
    function GetHasProgram_List : Boolean;
    function GetCharacteristicList : TFhirCodeableConceptList;
    function GetHasCharacteristicList : Boolean;
    function GetCommunicationList : TFhirCodeableConceptList;
    function GetHasCommunicationList : Boolean;
    function GetReferralMethodList : TFhirCodeableConceptList;
    function GetHasReferralMethodList : Boolean;
    procedure SetAppointmentRequired(value : TFhirBoolean);
    function GetAppointmentRequiredST : Boolean;
    procedure SetAppointmentRequiredST(value : Boolean);
    function GetAvailableTimeList : TFhirHealthcareServiceAvailableTimeList;
    function GetHasAvailableTimeList : Boolean;
    function GetNotAvailableList : TFhirHealthcareServiceNotAvailableList;
    function GetHasNotAvailableList : Boolean;
    procedure SetAvailabilityExceptions(value : TFhirString);
    function GetAvailabilityExceptionsST : String;
    procedure SetAvailabilityExceptionsST(value : String);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirHealthcareService; overload;
    function Clone : TFhirHealthcareService; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External identifiers for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to This flag is used to mark the record to not be used. This is not used when a center is closed for maintenance, or for holidays, the notAvailable period is to be used for this.
    property active : Boolean read GetActiveST write SetActiveST;
    // This flag is used to mark the record to not be used. This is not used when a center is closed for maintenance, or for holidays, the notAvailable period is to be used for this.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The organization that provides this healthcare service. (defined for API consistency)
    property providedBy : TFhirReference read FProvidedBy write SetProvidedBy;
    // The organization that provides this healthcare service.
    property providedByElement : TFhirReference read FProvidedBy write SetProvidedBy;

    // Identifies the broad category of service being performed or delivered.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The specific type of service that may be delivered or performed.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Collection of specialties handled by the service site. This is more of a medical term.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) where this healthcare service may be provided.
    property locationList : TFhirReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Typed access to Further description of the service as it would be presented to a consumer while searching.
    property name : String read GetNameST write SetNameST;
    // Further description of the service as it would be presented to a consumer while searching.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Any additional description of the service and/or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
    property comment : String read GetCommentST write SetCommentST;
    // Any additional description of the service and/or any specific issues not covered by the other attributes, which can be displayed as further detail under the serviceName.
    property commentElement : TFhirString read FComment write SetComment;

    // Typed access to Extra details about the service that can't be placed in the other fields.
    property extraDetails : String read GetExtraDetailsST write SetExtraDetailsST;
    // Extra details about the service that can't be placed in the other fields.
    property extraDetailsElement : TFhirMarkdown read FExtraDetails write SetExtraDetails;

    // Typed access to If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list. (defined for API consistency)
    property photo : TFhirAttachment read FPhoto write SetPhoto;
    // If there is a photo/symbol associated with this HealthcareService, it may be included here to facilitate quick identification of the service in a list.
    property photoElement : TFhirAttachment read FPhoto write SetPhoto;

    // List of contacts related to this specific healthcare service.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // The location(s) that this service is available to (not where the service is provided).
    property coverageAreaList : TFhirReferenceList read GetCoverageAreaList;
    property hasCoverageAreaList : boolean read GetHasCoverageAreaList;

    // The code(s) that detail the conditions under which the healthcare service is available/offered.
    property serviceProvisionCodeList : TFhirCodeableConceptList read GetServiceProvisionCodeList;
    property hasServiceProvisionCodeList : boolean read GetHasServiceProvisionCodeList;

    // Does this service have specific eligibility requirements that need to be met in order to use the service?
    property eligibilityList : TFhirHealthcareServiceEligibilityList read GetEligibilityList;
    property hasEligibilityList : boolean read GetHasEligibilityList;

    // Programs that this service is applicable to.
    property program_List : TFhirCodeableConceptList read GetProgram_List;
    property hasProgram_List : boolean read GetHasProgram_List;

    // Collection of characteristics (attributes).
    property characteristicList : TFhirCodeableConceptList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Some services are specifically made available in multiple languages, this property permits a directory to declare the languages this is offered in. Typically this is only provided where a service operates in communities with mixed languages used.
    property communicationList : TFhirCodeableConceptList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

    // Ways that the service accepts referrals, if this is not provided then it is implied that no referral is required.
    property referralMethodList : TFhirCodeableConceptList read GetReferralMethodList;
    property hasReferralMethodList : boolean read GetHasReferralMethodList;

    // Typed access to Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
    property appointmentRequired : Boolean read GetAppointmentRequiredST write SetAppointmentRequiredST;
    // Indicates whether or not a prospective consumer will require an appointment for a particular service at a site to be provided by the Organization. Indicates if an appointment is required for access to this service.
    property appointmentRequiredElement : TFhirBoolean read FAppointmentRequired write SetAppointmentRequired;

    // A collection of times that the Service Site is available.
    property availableTimeList : TFhirHealthcareServiceAvailableTimeList read GetAvailableTimeList;
    property hasAvailableTimeList : boolean read GetHasAvailableTimeList;

    // The HealthcareService is not available during this period of time due to the provided reason.
    property notAvailableList : TFhirHealthcareServiceNotAvailableList read GetNotAvailableList;
    property hasNotAvailableList : boolean read GetHasNotAvailableList;

    // Typed access to A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptions : String read GetAvailabilityExceptionsST write SetAvailabilityExceptionsST;
    // A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptionsElement : TFhirString read FAvailabilityExceptions write SetAvailabilityExceptions;

    // Technical endpoints providing access to services operated for the specific healthcare services defined at this resource.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirHealthcareServiceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirHealthcareServiceList;
    function GetCurrent : TFhirHealthcareService;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirHealthcareServiceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirHealthcareService read GetCurrent;
  end;

  TFhirHealthcareServiceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirHealthcareService;
    procedure SetItemN(index : Integer; value : TFhirHealthcareService);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirHealthcareServiceList; overload;
    function Clone : TFhirHealthcareServiceList; overload;
    function GetEnumerator : TFhirHealthcareServiceListEnumerator;
    
    //  Add a FhirHealthcareService to the end of the list.
    function Append : TFhirHealthcareService;
    
    // Add an already existing FhirHealthcareService to the end of the list.
    function AddItem(value : TFhirHealthcareService) : TFhirHealthcareService; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirHealthcareService) : Integer;
    
    // Insert FhirHealthcareService before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirHealthcareService;
    
    // Insert an existing FhirHealthcareService before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirHealthcareService);
    
    // Get the iIndexth FhirHealthcareService. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirHealthcareService);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirHealthcareService;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirHealthcareServices[index : Integer] : TFhirHealthcareService read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
  // The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
  TFhirLocationPosition = class (TFhirBackboneElement)
  protected
    FLongitude : TFhirDecimal;
    FLatitude : TFhirDecimal;
    FAltitude : TFhirDecimal;
    procedure SetLongitude(value : TFhirDecimal);
    function GetLongitudeST : String;
    procedure SetLongitudeST(value : String);
    procedure SetLatitude(value : TFhirDecimal);
    function GetLatitudeST : String;
    procedure SetLatitudeST(value : String);
    procedure SetAltitude(value : TFhirDecimal);
    function GetAltitudeST : String;
    procedure SetAltitudeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocationPosition; overload;
    function Clone : TFhirLocationPosition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    property longitude : String read GetLongitudeST write SetLongitudeST;
    // Longitude. The value domain and the interpretation are the same as for the text of the longitude element in KML (see notes below).
    property longitudeElement : TFhirDecimal read FLongitude write SetLongitude;

    // Typed access to Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    property latitude : String read GetLatitudeST write SetLatitudeST;
    // Latitude. The value domain and the interpretation are the same as for the text of the latitude element in KML (see notes below).
    property latitudeElement : TFhirDecimal read FLatitude write SetLatitude;

    // Typed access to Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    property altitude : String read GetAltitudeST write SetAltitudeST;
    // Altitude. The value domain and the interpretation are the same as for the text of the altitude element in KML (see notes below).
    property altitudeElement : TFhirDecimal read FAltitude write SetAltitude;

  end;

  TFhirLocationPositionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationPositionList;
    function GetCurrent : TFhirLocationPosition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLocationPositionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocationPosition read GetCurrent;
  end;

  TFhirLocationPositionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocationPosition;
    procedure SetItemN(index : Integer; value : TFhirLocationPosition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLocationPositionList; overload;
    function Clone : TFhirLocationPositionList; overload;
    function GetEnumerator : TFhirLocationPositionListEnumerator;
    
    //  Add a FhirLocationPosition to the end of the list.
    function Append : TFhirLocationPosition;
    
    // Add an already existing FhirLocationPosition to the end of the list.
    function AddItem(value : TFhirLocationPosition) : TFhirLocationPosition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocationPosition) : Integer;
    
    // Insert FhirLocationPosition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocationPosition;
    
    // Insert an existing FhirLocationPosition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocationPosition);
    
    // Get the iIndexth FhirLocationPosition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocationPosition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocationPosition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLocationPositions[index : Integer] : TFhirLocationPosition read GetItemN write SetItemN; default;
  End;

  // What days/times during a week is this location usually open.
  TFhirLocationHoursOfOperation = class (TFhirBackboneElement)
  protected
    FDaysOfWeek : TFhirEnumList;
    FAllDay : TFhirBoolean;
    FOpeningTime : TFhirTime;
    FClosingTime : TFhirTime;
    function GetDaysOfWeek : TFhirEnumList;
    function GetHasDaysOfWeek : Boolean;
    function GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
    procedure SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
    procedure SetAllDay(value : TFhirBoolean);
    function GetAllDayST : Boolean;
    procedure SetAllDayST(value : Boolean);
    procedure SetOpeningTime(value : TFhirTime);
    function GetOpeningTimeST : String;
    procedure SetOpeningTimeST(value : String);
    procedure SetClosingTime(value : TFhirTime);
    function GetClosingTimeST : String;
    procedure SetClosingTimeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocationHoursOfOperation; overload;
    function Clone : TFhirLocationHoursOfOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates which days of the week are available between the start and end Times.
    property daysOfWeek : TFhirDaysOfWeekEnumList read GetDaysOfWeekST write SetDaysOfWeekST;
    property daysOfWeekList : TFhirEnumList read GetDaysOfWeek;
    property hasDaysOfWeek : boolean read GetHasDaysOfWeek;
    // Typed access to The Location is open all day.
    property allDay : Boolean read GetAllDayST write SetAllDayST;
    // The Location is open all day.
    property allDayElement : TFhirBoolean read FAllDay write SetAllDay;

    // Typed access to Time that the Location opens.
    property openingTime : String read GetOpeningTimeST write SetOpeningTimeST;
    // Time that the Location opens.
    property openingTimeElement : TFhirTime read FOpeningTime write SetOpeningTime;

    // Typed access to Time that the Location closes.
    property closingTime : String read GetClosingTimeST write SetClosingTimeST;
    // Time that the Location closes.
    property closingTimeElement : TFhirTime read FClosingTime write SetClosingTime;

  end;

  TFhirLocationHoursOfOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationHoursOfOperationList;
    function GetCurrent : TFhirLocationHoursOfOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLocationHoursOfOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocationHoursOfOperation read GetCurrent;
  end;

  TFhirLocationHoursOfOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocationHoursOfOperation;
    procedure SetItemN(index : Integer; value : TFhirLocationHoursOfOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLocationHoursOfOperationList; overload;
    function Clone : TFhirLocationHoursOfOperationList; overload;
    function GetEnumerator : TFhirLocationHoursOfOperationListEnumerator;
    
    //  Add a FhirLocationHoursOfOperation to the end of the list.
    function Append : TFhirLocationHoursOfOperation;
    
    // Add an already existing FhirLocationHoursOfOperation to the end of the list.
    function AddItem(value : TFhirLocationHoursOfOperation) : TFhirLocationHoursOfOperation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocationHoursOfOperation) : Integer;
    
    // Insert FhirLocationHoursOfOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocationHoursOfOperation;
    
    // Insert an existing FhirLocationHoursOfOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocationHoursOfOperation);
    
    // Get the iIndexth FhirLocationHoursOfOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocationHoursOfOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocationHoursOfOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLocationHoursOfOperations[index : Integer] : TFhirLocationHoursOfOperation read GetItemN write SetItemN; default;
  End;

  // Details and position information for a physical place where services are provided and resources and participants may be stored, found, contained, or accommodated.
  TFhirLocation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FOperationalStatus : TFhirCoding;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FDescription : TFhirString;
    FMode : TFhirEnum;
    Ftype_List : TFhirCodeableConceptList;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    FPhysicalType : TFhirCodeableConcept;
    FPosition : TFhirLocationPosition;
    FManagingOrganization : TFhirReference;
    FPartOf : TFhirReference;
    FhoursOfOperationList : TFhirLocationHoursOfOperationList;
    FAvailabilityExceptions : TFhirString;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirLocationStatusEnum;
    procedure SetStatusST(value : TFhirLocationStatusEnum);
    procedure SetOperationalStatus(value : TFhirCoding);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirLocationModeEnum;
    procedure SetModeST(value : TFhirLocationModeEnum);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetAddress(value : TFhirAddress);
    procedure SetPhysicalType(value : TFhirCodeableConcept);
    procedure SetPosition(value : TFhirLocationPosition);
    procedure SetManagingOrganization(value : TFhirReference);
    procedure SetPartOf(value : TFhirReference);
    function GetHoursOfOperationList : TFhirLocationHoursOfOperationList;
    function GetHasHoursOfOperationList : Boolean;
    procedure SetAvailabilityExceptions(value : TFhirString);
    function GetAvailabilityExceptionsST : String;
    procedure SetAvailabilityExceptionsST(value : String);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLocation; overload;
    function Clone : TFhirLocation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique code or number identifying the location to its users.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The status property covers the general availability of the resource, not the current value which may be covered by the operationStatus, or by a schedule/slots if they are configured for the location.
    property status : TFhirLocationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The operational status covers operation values most relevant to beds (but can also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis chair). This typically covers concepts such as contamination, housekeeping, and other activities like maintenance. (defined for API consistency)
    property operationalStatus : TFhirCoding read FOperationalStatus write SetOperationalStatus;
    // The operational status covers operation values most relevant to beds (but can also apply to rooms/units/chairs/etc. such as an isolation unit/dialysis chair). This typically covers concepts such as contamination, housekeeping, and other activities like maintenance.
    property operationalStatusElement : TFhirCoding read FOperationalStatus write SetOperationalStatus;

    // Typed access to Name of the location as used by humans. Does not need to be unique.
    property name : String read GetNameST write SetNameST;
    // Name of the location as used by humans. Does not need to be unique.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the location is known as, or was known as, in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to Description of the Location, which helps in finding or referencing the place.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of the Location, which helps in finding or referencing the place.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Indicates whether a resource instance represents a specific location or a class of locations.
    property mode : TFhirLocationModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Indicates the type of function performed at the location.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // The contact details of communication devices available at the location. This can include phone numbers, fax numbers, mobile numbers, email addresses and web sites.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Physical location. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Physical location.
    property addressElement : TFhirAddress read FAddress write SetAddress;

    // Typed access to Physical form of the location, e.g. building, room, vehicle, road. (defined for API consistency)
    property physicalType : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;
    // Physical form of the location, e.g. building, room, vehicle, road.
    property physicalTypeElement : TFhirCodeableConcept read FPhysicalType write SetPhysicalType;

    // Typed access to The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML). (defined for API consistency)
    property position : TFhirLocationPosition read FPosition write SetPosition;
    // The absolute geographic location of the Location, expressed using the WGS84 datum (This is the same co-ordinate system used in KML).
    property positionElement : TFhirLocationPosition read FPosition write SetPosition;

    // Typed access to The organization responsible for the provisioning and upkeep of the location. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization responsible for the provisioning and upkeep of the location.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Typed access to Another Location of which this Location is physically a part of. (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // Another Location of which this Location is physically a part of.
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

    // What days/times during a week is this location usually open.
    property hoursOfOperationList : TFhirLocationHoursOfOperationList read GetHoursOfOperationList;
    property hasHoursOfOperationList : boolean read GetHasHoursOfOperationList;

    // Typed access to A description of when the locations opening ours are different to normal, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as detailed in the opening hours Times.
    property availabilityExceptions : String read GetAvailabilityExceptionsST write SetAvailabilityExceptionsST;
    // A description of when the locations opening ours are different to normal, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as detailed in the opening hours Times.
    property availabilityExceptionsElement : TFhirString read FAvailabilityExceptions write SetAvailabilityExceptions;

    // Technical endpoints providing access to services operated for the location.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirLocationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLocationList;
    function GetCurrent : TFhirLocation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLocationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLocation read GetCurrent;
  end;

  TFhirLocationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLocation;
    procedure SetItemN(index : Integer; value : TFhirLocation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLocationList; overload;
    function Clone : TFhirLocationList; overload;
    function GetEnumerator : TFhirLocationListEnumerator;
    
    //  Add a FhirLocation to the end of the list.
    function Append : TFhirLocation;
    
    // Add an already existing FhirLocation to the end of the list.
    function AddItem(value : TFhirLocation) : TFhirLocation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLocation) : Integer;
    
    // Insert FhirLocation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLocation;
    
    // Insert an existing FhirLocation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLocation);
    
    // Get the iIndexth FhirLocation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLocation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLocation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLocations[index : Integer] : TFhirLocation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
  // A photo, video, or audio recording acquired or used in healthcare. The actual content may be inline or provided by direct reference.
  TFhirMedia = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FType_ : TFhirCodeableConcept;
    FModality : TFhirCodeableConcept;
    FView : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FCreated : TFhirDataType;
    FIssued : TFhirInstant;
    FOperator : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FBodySite : TFhirCodeableConcept;
    FDeviceName : TFhirString;
    FDevice : TFhirReference;
    FHeight : TFhirPositiveInt;
    FWidth : TFhirPositiveInt;
    FFrames : TFhirPositiveInt;
    FDuration : TFhirDecimal;
    FContent : TFhirAttachment;
    FnoteList : TFhirAnnotationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirEventStatusEnum;
    procedure SetStatusST(value : TFhirEventStatusEnum);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetModality(value : TFhirCodeableConcept);
    procedure SetView(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetCreated(value : TFhirDataType);
    procedure SetIssued(value : TFhirInstant);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    procedure SetOperator(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    procedure SetBodySite(value : TFhirCodeableConcept);
    procedure SetDeviceName(value : TFhirString);
    function GetDeviceNameST : String;
    procedure SetDeviceNameST(value : String);
    procedure SetDevice(value : TFhirReference);
    procedure SetHeight(value : TFhirPositiveInt);
    function GetHeightST : String;
    procedure SetHeightST(value : String);
    procedure SetWidth(value : TFhirPositiveInt);
    function GetWidthST : String;
    procedure SetWidthST(value : String);
    procedure SetFrames(value : TFhirPositiveInt);
    function GetFramesST : String;
    procedure SetFramesST(value : String);
    procedure SetDuration(value : TFhirDecimal);
    function GetDurationST : String;
    procedure SetDurationST(value : String);
    procedure SetContent(value : TFhirAttachment);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMedia; overload;
    function Clone : TFhirMedia; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers associated with the image - these may include identifiers for the image itself, identifiers for the context of its collection (e.g. series ids) and context ids such as accession numbers or other workflow identifiers.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A procedure that is fulfilled in whole or in part by the creation of this media.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A larger event of which this particular event is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The current state of the {{title)))).
    property status : TFhirEventStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A code that classifies whether the media is an image, video or audio recording or some other media category. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code that classifies whether the media is an image, video or audio recording or some other media category.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Details of the type of the media - usually, how it was acquired (what type of device). If images sourced from a DICOM system, are wrapped in a Media resource, then this is the modality. (defined for API consistency)
    property modality : TFhirCodeableConcept read FModality write SetModality;
    // Details of the type of the media - usually, how it was acquired (what type of device). If images sourced from a DICOM system, are wrapped in a Media resource, then this is the modality.
    property modalityElement : TFhirCodeableConcept read FModality write SetModality;

    // Typed access to The name of the imaging view e.g. Lateral or Antero-posterior (AP). (defined for API consistency)
    property view : TFhirCodeableConcept read FView write SetView;
    // The name of the imaging view e.g. Lateral or Antero-posterior (AP).
    property viewElement : TFhirCodeableConcept read FView write SetView;

    // Typed access to Who/What this Media is a record of. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Who/What this Media is a record of.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter that establishes the context for this media. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter that establishes the context for this media.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date and time(s) at which the media was collected. (defined for API consistency)
    property created : TFhirDataType read FCreated write SetCreated;
    // The date and time(s) at which the media was collected.
    property createdElement : TFhirDataType read FCreated write SetCreated;

    // Typed access to The date and time this version of the media was made available to providers, typically after having been reviewed.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // The date and time this version of the media was made available to providers, typically after having been reviewed.
    property issuedElement : TFhirInstant read FIssued write SetIssued;

    // Typed access to The person who administered the collection of the image. (defined for API consistency)
    property operator : TFhirReference read FOperator write SetOperator;
    // The person who administered the collection of the image.
    property operatorElement : TFhirReference read FOperator write SetOperator;

    // Describes why the event occurred in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Typed access to Indicates the site on the subject's body where the observation was made (i.e. the target site). (defined for API consistency)
    property bodySite : TFhirCodeableConcept read FBodySite write SetBodySite;
    // Indicates the site on the subject's body where the observation was made (i.e. the target site).
    property bodySiteElement : TFhirCodeableConcept read FBodySite write SetBodySite;

    // Typed access to The name of the device / manufacturer of the device  that was used to make the recording.
    property deviceName : String read GetDeviceNameST write SetDeviceNameST;
    // The name of the device / manufacturer of the device  that was used to make the recording.
    property deviceNameElement : TFhirString read FDeviceName write SetDeviceName;

    // Typed access to The device used to collect the media. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // The device used to collect the media.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Typed access to Height of the image in pixels (photo/video).
    property height : String read GetHeightST write SetHeightST;
    // Height of the image in pixels (photo/video).
    property heightElement : TFhirPositiveInt read FHeight write SetHeight;

    // Typed access to Width of the image in pixels (photo/video).
    property width : String read GetWidthST write SetWidthST;
    // Width of the image in pixels (photo/video).
    property widthElement : TFhirPositiveInt read FWidth write SetWidth;

    // Typed access to The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
    property frames : String read GetFramesST write SetFramesST;
    // The number of frames in a photo. This is used with a multi-page fax, or an imaging acquisition context that takes multiple slices in a single image, or an animated gif. If there is more than one frame, this SHALL have a value in order to alert interface software that a multi-frame capable rendering widget is required.
    property framesElement : TFhirPositiveInt read FFrames write SetFrames;

    // Typed access to The duration of the recording in seconds - for audio and video.
    property duration : String read GetDurationST write SetDurationST;
    // The duration of the recording in seconds - for audio and video.
    property durationElement : TFhirDecimal read FDuration write SetDuration;

    // Typed access to The actual content of the media - inline or by direct reference to the media source file. (defined for API consistency)
    property content : TFhirAttachment read FContent write SetContent;
    // The actual content of the media - inline or by direct reference to the media source file.
    property contentElement : TFhirAttachment read FContent write SetContent;

    // Comments made about the media by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirMediaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMediaList;
    function GetCurrent : TFhirMedia;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMediaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMedia read GetCurrent;
  end;

  TFhirMediaList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMedia;
    procedure SetItemN(index : Integer; value : TFhirMedia);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMediaList; overload;
    function Clone : TFhirMediaList; overload;
    function GetEnumerator : TFhirMediaListEnumerator;
    
    //  Add a FhirMedia to the end of the list.
    function Append : TFhirMedia;
    
    // Add an already existing FhirMedia to the end of the list.
    function AddItem(value : TFhirMedia) : TFhirMedia; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMedia) : Integer;
    
    // Insert FhirMedia before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMedia;
    
    // Insert an existing FhirMedia before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMedia);
    
    // Get the iIndexth FhirMedia. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMedia);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMedia;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMedia[index : Integer] : TFhirMedia read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_ORGANIZATION}
  // Contact for the organization for a certain purpose.
  TFhirOrganizationContact = class (TFhirBackboneElement)
  protected
    FPurpose : TFhirCodeableConcept;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    procedure SetPurpose(value : TFhirCodeableConcept);
    procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetAddress(value : TFhirAddress);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganizationContact; overload;
    function Clone : TFhirOrganizationContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a purpose for which the contact can be reached. (defined for API consistency)
    property purpose : TFhirCodeableConcept read FPurpose write SetPurpose;
    // Indicates a purpose for which the contact can be reached.
    property purposeElement : TFhirCodeableConcept read FPurpose write SetPurpose;

    // Typed access to A name associated with the contact. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail (e.g. a telephone number or an email address) by which the party may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Visiting or postal addresses for the contact. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Visiting or postal addresses for the contact.
    property addressElement : TFhirAddress read FAddress write SetAddress;

  end;

  TFhirOrganizationContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationContactList;
    function GetCurrent : TFhirOrganizationContact;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganizationContact read GetCurrent;
  end;

  TFhirOrganizationContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganizationContact;
    procedure SetItemN(index : Integer; value : TFhirOrganizationContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOrganizationContactList; overload;
    function Clone : TFhirOrganizationContactList; overload;
    function GetEnumerator : TFhirOrganizationContactListEnumerator;
    
    //  Add a FhirOrganizationContact to the end of the list.
    function Append : TFhirOrganizationContact;
    
    // Add an already existing FhirOrganizationContact to the end of the list.
    function AddItem(value : TFhirOrganizationContact) : TFhirOrganizationContact; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganizationContact) : Integer;
    
    // Insert FhirOrganizationContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganizationContact;
    
    // Insert an existing FhirOrganizationContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganizationContact);
    
    // Get the iIndexth FhirOrganizationContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganizationContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOrganizationContacts[index : Integer] : TFhirOrganizationContact read GetItemN write SetItemN; default;
  End;

  // A formally or informally recognized grouping of people or organizations formed for the purpose of achieving some form of collective action.  Includes companies, institutions, corporations, departments, community groups, healthcare practice groups, payer/insurer, etc.
  TFhirOrganization = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    Ftype_List : TFhirCodeableConceptList;
    FName : TFhirString;
    FaliasList : TFhirStringList;
    FtelecomList : TFhirContactPointList;
    FaddressList : TFhirAddressList;
    FPartOf : TFhirReference;
    FcontactList : TFhirOrganizationContactList;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetPartOf(value : TFhirReference);
    function GetContactList : TFhirOrganizationContactList;
    function GetHasContactList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganization; overload;
    function Clone : TFhirOrganization; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the organization that is used to identify the organization across multiple disparate systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether the organization's record is still in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether the organization's record is still in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // The kind(s) of organization that this is.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Typed access to A name associated with the organization.
    property name : String read GetNameST write SetNameST;
    // A name associated with the organization.
    property nameElement : TFhirString read FName write SetName;

    // A list of alternate names that the organization is known as, or was known as in the past.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // A contact detail for the organization.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // An address for the organization.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to The organization of which this organization forms a part. (defined for API consistency)
    property partOf : TFhirReference read FPartOf write SetPartOf;
    // The organization of which this organization forms a part.
    property partOfElement : TFhirReference read FPartOf write SetPartOf;

    // Contact for the organization for a certain purpose.
    property contactList : TFhirOrganizationContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Technical endpoints providing access to services operated for the organization.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirOrganizationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationList;
    function GetCurrent : TFhirOrganization;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganization read GetCurrent;
  end;

  TFhirOrganizationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganization;
    procedure SetItemN(index : Integer; value : TFhirOrganization);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOrganizationList; overload;
    function Clone : TFhirOrganizationList; overload;
    function GetEnumerator : TFhirOrganizationListEnumerator;
    
    //  Add a FhirOrganization to the end of the list.
    function Append : TFhirOrganization;
    
    // Add an already existing FhirOrganization to the end of the list.
    function AddItem(value : TFhirOrganization) : TFhirOrganization; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganization) : Integer;
    
    // Insert FhirOrganization before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganization;
    
    // Insert an existing FhirOrganization before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganization);
    
    // Get the iIndexth FhirOrganization. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganization);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganization;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOrganizations[index : Integer] : TFhirOrganization read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
  // Defines an affiliation/assotiation/relationship between 2 distinct oganizations, that is not a part-of relationship/sub-division relationship.
  TFhirOrganizationAffiliation = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPeriod : TFhirPeriod;
    FOrganization : TFhirReference;
    FParticipatingOrganization : TFhirReference;
    FnetworkList : TFhirReferenceList;
    FcodeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList;
    FhealthcareServiceList : TFhirReferenceList;
    FtelecomList : TFhirContactPointList;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetOrganization(value : TFhirReference);
    procedure SetParticipatingOrganization(value : TFhirReference);
    function GetNetworkList : TFhirReferenceList;
    function GetHasNetworkList : Boolean;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList;
    function GetHasLocationList : Boolean;
    function GetHealthcareServiceList : TFhirReferenceList;
    function GetHasHealthcareServiceList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOrganizationAffiliation; overload;
    function Clone : TFhirOrganizationAffiliation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business identifiers that are specific to this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this organization affiliation record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this organization affiliation record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The period during which the participatingOrganization is affiliated with the primary organization. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the participatingOrganization is affiliated with the primary organization.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization where the role is available (primary organization/has members). (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // Organization where the role is available (primary organization/has members).
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to The Participating Organization provides/performs the role(s) defined by the code to the Primary Organization (e.g. providing services or is a member of). (defined for API consistency)
    property participatingOrganization : TFhirReference read FParticipatingOrganization write SetParticipatingOrganization;
    // The Participating Organization provides/performs the role(s) defined by the code to the Primary Organization (e.g. providing services or is a member of).
    property participatingOrganizationElement : TFhirReference read FParticipatingOrganization write SetParticipatingOrganization;

    // Health insurance provider network in which the participatingOrganization provides the role's services (if defined) at the indicated locations (if defined).
    property networkList : TFhirReferenceList read GetNetworkList;
    property hasNetworkList : boolean read GetHasNetworkList;

    // Definition of the role the participatingOrganization plays in the association.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Specific specialty of the participatingOrganization in the context of the role.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) at which the role occurs.
    property locationList : TFhirReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Healthcare services provided through the role.
    property healthcareServiceList : TFhirReferenceList read GetHealthcareServiceList;
    property hasHealthcareServiceList : boolean read GetHasHealthcareServiceList;

    // Contact details at the participatingOrganization relevant to this Affiliation.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Technical endpoints providing access to services operated for this role.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirOrganizationAffiliationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOrganizationAffiliationList;
    function GetCurrent : TFhirOrganizationAffiliation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOrganizationAffiliationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOrganizationAffiliation read GetCurrent;
  end;

  TFhirOrganizationAffiliationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOrganizationAffiliation;
    procedure SetItemN(index : Integer; value : TFhirOrganizationAffiliation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOrganizationAffiliationList; overload;
    function Clone : TFhirOrganizationAffiliationList; overload;
    function GetEnumerator : TFhirOrganizationAffiliationListEnumerator;
    
    //  Add a FhirOrganizationAffiliation to the end of the list.
    function Append : TFhirOrganizationAffiliation;
    
    // Add an already existing FhirOrganizationAffiliation to the end of the list.
    function AddItem(value : TFhirOrganizationAffiliation) : TFhirOrganizationAffiliation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOrganizationAffiliation) : Integer;
    
    // Insert FhirOrganizationAffiliation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOrganizationAffiliation;
    
    // Insert an existing FhirOrganizationAffiliation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOrganizationAffiliation);
    
    // Get the iIndexth FhirOrganizationAffiliation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOrganizationAffiliation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOrganizationAffiliation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOrganizationAffiliations[index : Integer] : TFhirOrganizationAffiliation read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
  // A contact party (e.g. guardian, partner, friend) for the patient.
  TFhirPatientContact = class (TFhirBackboneElement)
  protected
    FrelationshipList : TFhirCodeableConceptList;
    FName : TFhirHumanName;
    FtelecomList : TFhirContactPointList;
    FAddress : TFhirAddress;
    FGender : TFhirEnum;
    FOrganization : TFhirReference;
    FPeriod : TFhirPeriod;
    function GetRelationshipList : TFhirCodeableConceptList;
    function GetHasRelationshipList : Boolean;
    procedure SetName(value : TFhirHumanName);
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetAddress(value : TFhirAddress);
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetOrganization(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientContact; overload;
    function Clone : TFhirPatientContact; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The nature of the relationship between the patient and the contact person.
    property relationshipList : TFhirCodeableConceptList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // Typed access to A name associated with the contact person. (defined for API consistency)
    property name : TFhirHumanName read FName write SetName;
    // A name associated with the contact person.
    property nameElement : TFhirHumanName read FName write SetName;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Typed access to Address for the contact person. (defined for API consistency)
    property address : TFhirAddress read FAddress write SetAddress;
    // Address for the contact person.
    property addressElement : TFhirAddress read FAddress write SetAddress;

    // Administrative Gender - the gender that the contact person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to Organization on behalf of which the contact is acting or for which the contact is working. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // Organization on behalf of which the contact is acting or for which the contact is working.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to The period during which this contact person or organization is valid to be contacted relating to this patient. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which this contact person or organization is valid to be contacted relating to this patient.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirPatientContactListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientContactList;
    function GetCurrent : TFhirPatientContact;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientContactList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientContact read GetCurrent;
  end;

  TFhirPatientContactList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientContact;
    procedure SetItemN(index : Integer; value : TFhirPatientContact);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientContactList; overload;
    function Clone : TFhirPatientContactList; overload;
    function GetEnumerator : TFhirPatientContactListEnumerator;
    
    //  Add a FhirPatientContact to the end of the list.
    function Append : TFhirPatientContact;
    
    // Add an already existing FhirPatientContact to the end of the list.
    function AddItem(value : TFhirPatientContact) : TFhirPatientContact; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientContact) : Integer;
    
    // Insert FhirPatientContact before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientContact;
    
    // Insert an existing FhirPatientContact before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientContact);
    
    // Get the iIndexth FhirPatientContact. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientContact);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientContact;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatientContacts[index : Integer] : TFhirPatientContact read GetItemN write SetItemN; default;
  End;

  // A language which may be used to communicate with the patient about his or her health.
  TFhirPatientCommunication = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientCommunication; overload;
    function Clone : TFhirPatientCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

  end;

  TFhirPatientCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientCommunicationList;
    function GetCurrent : TFhirPatientCommunication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientCommunication read GetCurrent;
  end;

  TFhirPatientCommunicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientCommunication;
    procedure SetItemN(index : Integer; value : TFhirPatientCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientCommunicationList; overload;
    function Clone : TFhirPatientCommunicationList; overload;
    function GetEnumerator : TFhirPatientCommunicationListEnumerator;
    
    //  Add a FhirPatientCommunication to the end of the list.
    function Append : TFhirPatientCommunication;
    
    // Add an already existing FhirPatientCommunication to the end of the list.
    function AddItem(value : TFhirPatientCommunication) : TFhirPatientCommunication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientCommunication) : Integer;
    
    // Insert FhirPatientCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientCommunication;
    
    // Insert an existing FhirPatientCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientCommunication);
    
    // Get the iIndexth FhirPatientCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientCommunication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatientCommunications[index : Integer] : TFhirPatientCommunication read GetItemN write SetItemN; default;
  End;

  // Link to another patient resource that concerns the same actual patient.
  TFhirPatientLink = class (TFhirBackboneElement)
  protected
    FOther : TFhirReference;
    FType_ : TFhirEnum;
    procedure SetOther(value : TFhirReference);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirLinkTypeEnum;
    procedure SetType_ST(value : TFhirLinkTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatientLink; overload;
    function Clone : TFhirPatientLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The other patient resource that the link refers to. (defined for API consistency)
    property other : TFhirReference read FOther write SetOther;
    // The other patient resource that the link refers to.
    property otherElement : TFhirReference read FOther write SetOther;

    // The type of link between this patient resource and another patient resource.
    property type_ : TFhirLinkTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirPatientLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientLinkList;
    function GetCurrent : TFhirPatientLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatientLink read GetCurrent;
  end;

  TFhirPatientLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatientLink;
    procedure SetItemN(index : Integer; value : TFhirPatientLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientLinkList; overload;
    function Clone : TFhirPatientLinkList; overload;
    function GetEnumerator : TFhirPatientLinkListEnumerator;
    
    //  Add a FhirPatientLink to the end of the list.
    function Append : TFhirPatientLink;
    
    // Add an already existing FhirPatientLink to the end of the list.
    function AddItem(value : TFhirPatientLink) : TFhirPatientLink; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatientLink) : Integer;
    
    // Insert FhirPatientLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatientLink;
    
    // Insert an existing FhirPatientLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatientLink);
    
    // Get the iIndexth FhirPatientLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatientLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatientLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatientLinks[index : Integer] : TFhirPatientLink read GetItemN write SetItemN; default;
  End;

  // Demographics and other administrative information about an individual or animal receiving care or other health-related services.
  TFhirPatient = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FDeceased : TFhirDataType;
    FaddressList : TFhirAddressList;
    FMaritalStatus : TFhirCodeableConcept;
    FMultipleBirth : TFhirDataType;
    FphotoList : TFhirAttachmentList;
    FcontactList : TFhirPatientContactList;
    FcommunicationList : TFhirPatientCommunicationList;
    FgeneralPractitionerList : TFhirReferenceList;
    FManagingOrganization : TFhirReference;
    Flink_List : TFhirPatientLinkList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    procedure SetDeceased(value : TFhirDataType);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetMaritalStatus(value : TFhirCodeableConcept);
    procedure SetMultipleBirth(value : TFhirDataType);
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    function GetContactList : TFhirPatientContactList;
    function GetHasContactList : Boolean;
    function GetCommunicationList : TFhirPatientCommunicationList;
    function GetHasCommunicationList : Boolean;
    function GetGeneralPractitionerList : TFhirReferenceList;
    function GetHasGeneralPractitionerList : Boolean;
    procedure SetManagingOrganization(value : TFhirReference);
    function GetLink_List : TFhirPatientLinkList;
    function GetHasLink_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPatient; overload;
    function Clone : TFhirPatient; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier for this patient.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization's business rules.  It is often used to filter patient lists to exclude inactive patients  Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this patient record is in active use.  Many systems use this property to mark as non-current patients, such as those that have not been seen for a period of time based on an organization's business rules.  It is often used to filter patient lists to exclude inactive patients  Deceased patients may also be marked as inactive for the same reasons, but may be active for some time after death.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // A name associated with the individual.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail (e.g. a telephone number or an email address) by which the individual may be contacted.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender - the gender that the patient is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date of birth for the individual.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date of birth for the individual.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Typed access to Indicates if the individual is deceased or not. (defined for API consistency)
    property deceased : TFhirDataType read FDeceased write SetDeceased;
    // Indicates if the individual is deceased or not.
    property deceasedElement : TFhirDataType read FDeceased write SetDeceased;

    // An address for the individual.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to This field contains a patient's most recent marital (civil) status. (defined for API consistency)
    property maritalStatus : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;
    // This field contains a patient's most recent marital (civil) status.
    property maritalStatusElement : TFhirCodeableConcept read FMaritalStatus write SetMaritalStatus;

    // Typed access to Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer). (defined for API consistency)
    property multipleBirth : TFhirDataType read FMultipleBirth write SetMultipleBirth;
    // Indicates whether the patient is part of a multiple (boolean) or indicates the actual birth order (integer).
    property multipleBirthElement : TFhirDataType read FMultipleBirth write SetMultipleBirth;

    // Image of the patient.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // A contact party (e.g. guardian, partner, friend) for the patient.
    property contactList : TFhirPatientContactList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // A language which may be used to communicate with the patient about his or her health.
    property communicationList : TFhirPatientCommunicationList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

    // Patient's nominated care provider.
    property generalPractitionerList : TFhirReferenceList read GetGeneralPractitionerList;
    property hasGeneralPractitionerList : boolean read GetHasGeneralPractitionerList;

    // Typed access to Organization that is the custodian of the patient record. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // Organization that is the custodian of the patient record.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Link to another patient resource that concerns the same actual patient.
    property link_List : TFhirPatientLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirPatientListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPatientList;
    function GetCurrent : TFhirPatient;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPatientList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPatient read GetCurrent;
  end;

  TFhirPatientList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPatient;
    procedure SetItemN(index : Integer; value : TFhirPatient);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPatientList; overload;
    function Clone : TFhirPatientList; overload;
    function GetEnumerator : TFhirPatientListEnumerator;
    
    //  Add a FhirPatient to the end of the list.
    function Append : TFhirPatient;
    
    // Add an already existing FhirPatient to the end of the list.
    function AddItem(value : TFhirPatient) : TFhirPatient; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPatient) : Integer;
    
    // Insert FhirPatient before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPatient;
    
    // Insert an existing FhirPatient before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPatient);
    
    // Get the iIndexth FhirPatient. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPatient);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPatient;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPatients[index : Integer] : TFhirPatient read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
  // Link to a resource that concerns the same actual person.
  TFhirPersonLink = class (TFhirBackboneElement)
  protected
    FTarget : TFhirReference;
    FAssurance : TFhirEnum;
    procedure SetTarget(value : TFhirReference);
    procedure SetAssurance(value : TFhirEnum);
    function GetAssuranceST : TFhirIdentityAssuranceLevelEnum;
    procedure SetAssuranceST(value : TFhirIdentityAssuranceLevelEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPersonLink; overload;
    function Clone : TFhirPersonLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The resource to which this actual person is associated. (defined for API consistency)
    property target : TFhirReference read FTarget write SetTarget;
    // The resource to which this actual person is associated.
    property targetElement : TFhirReference read FTarget write SetTarget;

    // Level of assurance that this link is associated with the target resource.
    property assurance : TFhirIdentityAssuranceLevelEnum read GetAssuranceST write SetAssuranceST;
    property assuranceElement : TFhirEnum read FAssurance write SetAssurance;

  end;

  TFhirPersonLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPersonLinkList;
    function GetCurrent : TFhirPersonLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPersonLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPersonLink read GetCurrent;
  end;

  TFhirPersonLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPersonLink;
    procedure SetItemN(index : Integer; value : TFhirPersonLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPersonLinkList; overload;
    function Clone : TFhirPersonLinkList; overload;
    function GetEnumerator : TFhirPersonLinkListEnumerator;
    
    //  Add a FhirPersonLink to the end of the list.
    function Append : TFhirPersonLink;
    
    // Add an already existing FhirPersonLink to the end of the list.
    function AddItem(value : TFhirPersonLink) : TFhirPersonLink; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPersonLink) : Integer;
    
    // Insert FhirPersonLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPersonLink;
    
    // Insert an existing FhirPersonLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPersonLink);
    
    // Get the iIndexth FhirPersonLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPersonLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPersonLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPersonLinks[index : Integer] : TFhirPersonLink read GetItemN write SetItemN; default;
  End;

  // Demographics and administrative information about a person independent of a specific health-related context.
  TFhirPerson = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FaddressList : TFhirAddressList;
    FPhoto : TFhirAttachment;
    FManagingOrganization : TFhirReference;
    FActive : TFhirBoolean;
    Flink_List : TFhirPersonLinkList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetPhoto(value : TFhirAttachment);
    procedure SetManagingOrganization(value : TFhirReference);
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetLink_List : TFhirPersonLinkList;
    function GetHasLink_List : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPerson; overload;
    function Clone : TFhirPerson; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for a person within a particular scope.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A name associated with the person.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The birth date for the person.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The birth date for the person.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // One or more addresses for the person.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Typed access to An image that can be displayed as a thumbnail of the person to enhance the identification of the individual. (defined for API consistency)
    property photo : TFhirAttachment read FPhoto write SetPhoto;
    // An image that can be displayed as a thumbnail of the person to enhance the identification of the individual.
    property photoElement : TFhirAttachment read FPhoto write SetPhoto;

    // Typed access to The organization that is the custodian of the person record. (defined for API consistency)
    property managingOrganization : TFhirReference read FManagingOrganization write SetManagingOrganization;
    // The organization that is the custodian of the person record.
    property managingOrganizationElement : TFhirReference read FManagingOrganization write SetManagingOrganization;

    // Typed access to Whether this person's record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this person's record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Link to a resource that concerns the same actual person.
    property link_List : TFhirPersonLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

  end;

  TFhirPersonListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPersonList;
    function GetCurrent : TFhirPerson;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPersonList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPerson read GetCurrent;
  end;

  TFhirPersonList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPerson;
    procedure SetItemN(index : Integer; value : TFhirPerson);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPersonList; overload;
    function Clone : TFhirPersonList; overload;
    function GetEnumerator : TFhirPersonListEnumerator;
    
    //  Add a FhirPerson to the end of the list.
    function Append : TFhirPerson;
    
    // Add an already existing FhirPerson to the end of the list.
    function AddItem(value : TFhirPerson) : TFhirPerson; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPerson) : Integer;
    
    // Insert FhirPerson before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPerson;
    
    // Insert an existing FhirPerson before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPerson);
    
    // Get the iIndexth FhirPerson. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPerson);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPerson;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPeople[index : Integer] : TFhirPerson read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
  // The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
  TFhirPractitionerQualification = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FCode : TFhirCodeableConcept;
    FPeriod : TFhirPeriod;
    FIssuer : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetIssuer(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerQualification; overload;
    function Clone : TFhirPractitionerQualification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier that applies to this person's qualification in this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Coded representation of the qualification. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Coded representation of the qualification.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Period during which the qualification is valid. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Period during which the qualification is valid.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Organization that regulates and issues the qualification. (defined for API consistency)
    property issuer : TFhirReference read FIssuer write SetIssuer;
    // Organization that regulates and issues the qualification.
    property issuerElement : TFhirReference read FIssuer write SetIssuer;

  end;

  TFhirPractitionerQualificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerQualificationList;
    function GetCurrent : TFhirPractitionerQualification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerQualificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerQualification read GetCurrent;
  end;

  TFhirPractitionerQualificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerQualification;
    procedure SetItemN(index : Integer; value : TFhirPractitionerQualification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerQualificationList; overload;
    function Clone : TFhirPractitionerQualificationList; overload;
    function GetEnumerator : TFhirPractitionerQualificationListEnumerator;
    
    //  Add a FhirPractitionerQualification to the end of the list.
    function Append : TFhirPractitionerQualification;
    
    // Add an already existing FhirPractitionerQualification to the end of the list.
    function AddItem(value : TFhirPractitionerQualification) : TFhirPractitionerQualification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerQualification) : Integer;
    
    // Insert FhirPractitionerQualification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerQualification;
    
    // Insert an existing FhirPractitionerQualification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerQualification);
    
    // Get the iIndexth FhirPractitionerQualification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerQualification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerQualification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerQualifications[index : Integer] : TFhirPractitionerQualification read GetItemN write SetItemN; default;
  End;

  // A person who is directly or indirectly involved in the provisioning of healthcare.
  TFhirPractitioner = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FaddressList : TFhirAddressList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FphotoList : TFhirAttachmentList;
    FqualificationList : TFhirPractitionerQualificationList;
    FcommunicationList : TFhirCodeableConceptList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    function GetQualificationList : TFhirPractitionerQualificationList;
    function GetHasQualificationList : Boolean;
    function GetCommunicationList : TFhirCodeableConceptList;
    function GetHasCommunicationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitioner; overload;
    function Clone : TFhirPractitioner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An identifier that applies to this person in this role.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this practitioner's record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this practitioner's record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // The name(s) associated with the practitioner.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the practitioner, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Address(es) of the practitioner that are not role specific (typically home address).  Work addresses are not typically entered in this property as they are usually role dependent.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date of birth for the practitioner.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date of birth for the practitioner.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Image of the person.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // The official certifications, training, and licenses that authorize or otherwise pertain to the provision of care by the practitioner.  For example, a medical license issued by a medical board authorizing the practitioner to practice medicine within a certian locality.
    property qualificationList : TFhirPractitionerQualificationList read GetQualificationList;
    property hasQualificationList : boolean read GetHasQualificationList;

    // A language the practitioner can use in patient communication.
    property communicationList : TFhirCodeableConceptList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

  end;

  TFhirPractitionerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerList;
    function GetCurrent : TFhirPractitioner;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitioner read GetCurrent;
  end;

  TFhirPractitionerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitioner;
    procedure SetItemN(index : Integer; value : TFhirPractitioner);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerList; overload;
    function Clone : TFhirPractitionerList; overload;
    function GetEnumerator : TFhirPractitionerListEnumerator;
    
    //  Add a FhirPractitioner to the end of the list.
    function Append : TFhirPractitioner;
    
    // Add an already existing FhirPractitioner to the end of the list.
    function AddItem(value : TFhirPractitioner) : TFhirPractitioner; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitioner) : Integer;
    
    // Insert FhirPractitioner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitioner;
    
    // Insert an existing FhirPractitioner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitioner);
    
    // Get the iIndexth FhirPractitioner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitioner);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitioner;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitioners[index : Integer] : TFhirPractitioner read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
  // A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
  TFhirPractitionerRoleAvailableTime = class (TFhirBackboneElement)
  protected
    FDaysOfWeek : TFhirEnumList;
    FAllDay : TFhirBoolean;
    FAvailableStartTime : TFhirTime;
    FAvailableEndTime : TFhirTime;
    function GetDaysOfWeek : TFhirEnumList;
    function GetHasDaysOfWeek : Boolean;
    function GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
    procedure SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
    procedure SetAllDay(value : TFhirBoolean);
    function GetAllDayST : Boolean;
    procedure SetAllDayST(value : Boolean);
    procedure SetAvailableStartTime(value : TFhirTime);
    function GetAvailableStartTimeST : String;
    procedure SetAvailableStartTimeST(value : String);
    procedure SetAvailableEndTime(value : TFhirTime);
    function GetAvailableEndTimeST : String;
    procedure SetAvailableEndTimeST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRoleAvailableTime; overload;
    function Clone : TFhirPractitionerRoleAvailableTime; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates which days of the week are available between the start and end Times.
    property daysOfWeek : TFhirDaysOfWeekEnumList read GetDaysOfWeekST write SetDaysOfWeekST;
    property daysOfWeekList : TFhirEnumList read GetDaysOfWeek;
    property hasDaysOfWeek : boolean read GetHasDaysOfWeek;
    // Typed access to Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDay : Boolean read GetAllDayST write SetAllDayST;
    // Is this always available? (hence times are irrelevant) e.g. 24 hour service.
    property allDayElement : TFhirBoolean read FAllDay write SetAllDay;

    // Typed access to The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTime : String read GetAvailableStartTimeST write SetAvailableStartTimeST;
    // The opening time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableStartTimeElement : TFhirTime read FAvailableStartTime write SetAvailableStartTime;

    // Typed access to The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTime : String read GetAvailableEndTimeST write SetAvailableEndTimeST;
    // The closing time of day. Note: If the AllDay flag is set, then this time is ignored.
    property availableEndTimeElement : TFhirTime read FAvailableEndTime write SetAvailableEndTime;

  end;

  TFhirPractitionerRoleAvailableTimeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleAvailableTimeList;
    function GetCurrent : TFhirPractitionerRoleAvailableTime;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleAvailableTimeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRoleAvailableTime read GetCurrent;
  end;

  TFhirPractitionerRoleAvailableTimeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerRoleAvailableTime;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRoleAvailableTime);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerRoleAvailableTimeList; overload;
    function Clone : TFhirPractitionerRoleAvailableTimeList; overload;
    function GetEnumerator : TFhirPractitionerRoleAvailableTimeListEnumerator;
    
    //  Add a FhirPractitionerRoleAvailableTime to the end of the list.
    function Append : TFhirPractitionerRoleAvailableTime;
    
    // Add an already existing FhirPractitionerRoleAvailableTime to the end of the list.
    function AddItem(value : TFhirPractitionerRoleAvailableTime) : TFhirPractitionerRoleAvailableTime; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRoleAvailableTime) : Integer;
    
    // Insert FhirPractitionerRoleAvailableTime before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRoleAvailableTime;
    
    // Insert an existing FhirPractitionerRoleAvailableTime before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRoleAvailableTime);
    
    // Get the iIndexth FhirPractitionerRoleAvailableTime. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRoleAvailableTime);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRoleAvailableTime;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerRoleAvailableTimes[index : Integer] : TFhirPractitionerRoleAvailableTime read GetItemN write SetItemN; default;
  End;

  // The practitioner is not available or performing this role during this period of time due to the provided reason.
  TFhirPractitionerRoleNotAvailable = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FDuring : TFhirPeriod;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetDuring(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRoleNotAvailable; overload;
    function Clone : TFhirPractitionerRoleNotAvailable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The reason that can be presented to the user as to why this time is not available.
    property description : String read GetDescriptionST write SetDescriptionST;
    // The reason that can be presented to the user as to why this time is not available.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Service is not available (seasonally or for a public holiday) from this date. (defined for API consistency)
    property during : TFhirPeriod read FDuring write SetDuring;
    // Service is not available (seasonally or for a public holiday) from this date.
    property duringElement : TFhirPeriod read FDuring write SetDuring;

  end;

  TFhirPractitionerRoleNotAvailableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleNotAvailableList;
    function GetCurrent : TFhirPractitionerRoleNotAvailable;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleNotAvailableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRoleNotAvailable read GetCurrent;
  end;

  TFhirPractitionerRoleNotAvailableList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerRoleNotAvailable;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRoleNotAvailable);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerRoleNotAvailableList; overload;
    function Clone : TFhirPractitionerRoleNotAvailableList; overload;
    function GetEnumerator : TFhirPractitionerRoleNotAvailableListEnumerator;
    
    //  Add a FhirPractitionerRoleNotAvailable to the end of the list.
    function Append : TFhirPractitionerRoleNotAvailable;
    
    // Add an already existing FhirPractitionerRoleNotAvailable to the end of the list.
    function AddItem(value : TFhirPractitionerRoleNotAvailable) : TFhirPractitionerRoleNotAvailable; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRoleNotAvailable) : Integer;
    
    // Insert FhirPractitionerRoleNotAvailable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRoleNotAvailable;
    
    // Insert an existing FhirPractitionerRoleNotAvailable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRoleNotAvailable);
    
    // Get the iIndexth FhirPractitionerRoleNotAvailable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRoleNotAvailable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRoleNotAvailable;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerRoleNotAvailables[index : Integer] : TFhirPractitionerRoleNotAvailable read GetItemN write SetItemN; default;
  End;

  // A specific set of Roles/Locations/specialties/services that a practitioner may perform at an organization for a period of time.
  TFhirPractitionerRole = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPeriod : TFhirPeriod;
    FPractitioner : TFhirReference;
    FOrganization : TFhirReference;
    FcodeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FlocationList : TFhirReferenceList;
    FhealthcareServiceList : TFhirReferenceList;
    FtelecomList : TFhirContactPointList;
    FavailableTimeList : TFhirPractitionerRoleAvailableTimeList;
    FnotAvailableList : TFhirPractitionerRoleNotAvailableList;
    FAvailabilityExceptions : TFhirString;
    FendpointList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetPractitioner(value : TFhirReference);
    procedure SetOrganization(value : TFhirReference);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetLocationList : TFhirReferenceList;
    function GetHasLocationList : Boolean;
    function GetHealthcareServiceList : TFhirReferenceList;
    function GetHasHealthcareServiceList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    function GetAvailableTimeList : TFhirPractitionerRoleAvailableTimeList;
    function GetHasAvailableTimeList : Boolean;
    function GetNotAvailableList : TFhirPractitionerRoleNotAvailableList;
    function GetHasNotAvailableList : Boolean;
    procedure SetAvailabilityExceptions(value : TFhirString);
    function GetAvailabilityExceptionsST : String;
    procedure SetAvailabilityExceptionsST(value : String);
    function GetEndpointList : TFhirReferenceList;
    function GetHasEndpointList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPractitionerRole; overload;
    function Clone : TFhirPractitionerRole; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Business Identifiers that are specific to a role/location.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this practitioner role record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this practitioner role record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The period during which the person is authorized to act as a practitioner in these role(s) for the organization. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the person is authorized to act as a practitioner in these role(s) for the organization.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Practitioner that is able to provide the defined services for the organization. (defined for API consistency)
    property practitioner : TFhirReference read FPractitioner write SetPractitioner;
    // Practitioner that is able to provide the defined services for the organization.
    property practitionerElement : TFhirReference read FPractitioner write SetPractitioner;

    // Typed access to The organization where the Practitioner performs the roles associated. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // The organization where the Practitioner performs the roles associated.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Roles which this practitioner is authorized to perform for the organization.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Specific specialty of the practitioner.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // The location(s) at which this practitioner provides care.
    property locationList : TFhirReferenceList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // The list of healthcare services that this worker provides for this role's Organization/Location(s).
    property healthcareServiceList : TFhirReferenceList read GetHealthcareServiceList;
    property hasHealthcareServiceList : boolean read GetHasHealthcareServiceList;

    // Contact details that are specific to the role/location/service.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // A collection of times the practitioner is available or performing this role at the location and/or healthcareservice.
    property availableTimeList : TFhirPractitionerRoleAvailableTimeList read GetAvailableTimeList;
    property hasAvailableTimeList : boolean read GetHasAvailableTimeList;

    // The practitioner is not available or performing this role during this period of time due to the provided reason.
    property notAvailableList : TFhirPractitionerRoleNotAvailableList read GetNotAvailableList;
    property hasNotAvailableList : boolean read GetHasNotAvailableList;

    // Typed access to A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptions : String read GetAvailabilityExceptionsST write SetAvailabilityExceptionsST;
    // A description of site availability exceptions, e.g. public holiday availability. Succinctly describing all possible exceptions to normal site availability as details in the available Times and not available Times.
    property availabilityExceptionsElement : TFhirString read FAvailabilityExceptions write SetAvailabilityExceptions;

    // Technical endpoints providing access to services operated for the practitioner with this role.
    property endpointList : TFhirReferenceList read GetEndpointList;
    property hasEndpointList : boolean read GetHasEndpointList;

  end;

  TFhirPractitionerRoleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPractitionerRoleList;
    function GetCurrent : TFhirPractitionerRole;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPractitionerRoleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPractitionerRole read GetCurrent;
  end;

  TFhirPractitionerRoleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPractitionerRole;
    procedure SetItemN(index : Integer; value : TFhirPractitionerRole);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPractitionerRoleList; overload;
    function Clone : TFhirPractitionerRoleList; overload;
    function GetEnumerator : TFhirPractitionerRoleListEnumerator;
    
    //  Add a FhirPractitionerRole to the end of the list.
    function Append : TFhirPractitionerRole;
    
    // Add an already existing FhirPractitionerRole to the end of the list.
    function AddItem(value : TFhirPractitionerRole) : TFhirPractitionerRole; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPractitionerRole) : Integer;
    
    // Insert FhirPractitionerRole before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPractitionerRole;
    
    // Insert an existing FhirPractitionerRole before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPractitionerRole);
    
    // Get the iIndexth FhirPractitionerRole. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPractitionerRole);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPractitionerRole;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPractitionerRoles[index : Integer] : TFhirPractitionerRole read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
  // A language which may be used to communicate with about the patient's health.
  TFhirRelatedPersonCommunication = class (TFhirBackboneElement)
  protected
    FLanguage : TFhirCodeableConcept;
    FPreferred : TFhirBoolean;
    procedure SetLanguage(value : TFhirCodeableConcept);
    procedure SetPreferred(value : TFhirBoolean);
    function GetPreferredST : Boolean;
    procedure SetPreferredST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRelatedPersonCommunication; overload;
    function Clone : TFhirRelatedPersonCommunication; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English. (defined for API consistency)
    property language : TFhirCodeableConcept read FLanguage write SetLanguage;
    // The ISO-639-1 alpha 2 code in lower case for the language, optionally followed by a hyphen and the ISO-3166-1 alpha 2 code for the region in upper case; e.g. "en" for English, or "en-US" for American English versus "en-EN" for England English.
    property languageElement : TFhirCodeableConcept read FLanguage write SetLanguage;

    // Typed access to Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferred : Boolean read GetPreferredST write SetPreferredST;
    // Indicates whether or not the patient prefers this language (over other languages he masters up a certain level).
    property preferredElement : TFhirBoolean read FPreferred write SetPreferred;

  end;

  TFhirRelatedPersonCommunicationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRelatedPersonCommunicationList;
    function GetCurrent : TFhirRelatedPersonCommunication;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRelatedPersonCommunicationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRelatedPersonCommunication read GetCurrent;
  end;

  TFhirRelatedPersonCommunicationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRelatedPersonCommunication;
    procedure SetItemN(index : Integer; value : TFhirRelatedPersonCommunication);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRelatedPersonCommunicationList; overload;
    function Clone : TFhirRelatedPersonCommunicationList; overload;
    function GetEnumerator : TFhirRelatedPersonCommunicationListEnumerator;
    
    //  Add a FhirRelatedPersonCommunication to the end of the list.
    function Append : TFhirRelatedPersonCommunication;
    
    // Add an already existing FhirRelatedPersonCommunication to the end of the list.
    function AddItem(value : TFhirRelatedPersonCommunication) : TFhirRelatedPersonCommunication; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRelatedPersonCommunication) : Integer;
    
    // Insert FhirRelatedPersonCommunication before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRelatedPersonCommunication;
    
    // Insert an existing FhirRelatedPersonCommunication before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRelatedPersonCommunication);
    
    // Get the iIndexth FhirRelatedPersonCommunication. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRelatedPersonCommunication);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRelatedPersonCommunication;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRelatedPersonCommunications[index : Integer] : TFhirRelatedPersonCommunication read GetItemN write SetItemN; default;
  End;

  // Information about a person that is involved in the care for a patient, but who is not the target of healthcare, nor has a formal responsibility in the care process.
  TFhirRelatedPerson = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FPatient : TFhirReference;
    FrelationshipList : TFhirCodeableConceptList;
    FnameList : TFhirHumanNameList;
    FtelecomList : TFhirContactPointList;
    FGender : TFhirEnum;
    FBirthDate : TFhirDate;
    FaddressList : TFhirAddressList;
    FphotoList : TFhirAttachmentList;
    FPeriod : TFhirPeriod;
    FcommunicationList : TFhirRelatedPersonCommunicationList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetPatient(value : TFhirReference);
    function GetRelationshipList : TFhirCodeableConceptList;
    function GetHasRelationshipList : Boolean;
    function GetNameList : TFhirHumanNameList;
    function GetHasNameList : Boolean;
    function GetTelecomList : TFhirContactPointList;
    function GetHasTelecomList : Boolean;
    procedure SetGender(value : TFhirEnum);
    function GetGenderST : TFhirAdministrativeGenderEnum;
    procedure SetGenderST(value : TFhirAdministrativeGenderEnum);
    procedure SetBirthDate(value : TFhirDate);
    function GetBirthDateST : TFslDateTime;
    procedure SetBirthDateST(value : TFslDateTime);
    function GetAddressList : TFhirAddressList;
    function GetHasAddressList : Boolean;
    function GetPhotoList : TFhirAttachmentList;
    function GetHasPhotoList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    function GetCommunicationList : TFhirRelatedPersonCommunicationList;
    function GetHasCommunicationList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRelatedPerson; overload;
    function Clone : TFhirRelatedPerson; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for a person within a particular scope.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this related person record is in active use.
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this related person record is in active use.
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to The patient this person is related to. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient this person is related to.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // The nature of the relationship between a patient and the related person.
    property relationshipList : TFhirCodeableConceptList read GetRelationshipList;
    property hasRelationshipList : boolean read GetHasRelationshipList;

    // A name associated with the person.
    property nameList : TFhirHumanNameList read GetNameList;
    property hasNameList : boolean read GetHasNameList;

    // A contact detail for the person, e.g. a telephone number or an email address.
    property telecomList : TFhirContactPointList read GetTelecomList;
    property hasTelecomList : boolean read GetHasTelecomList;

    // Administrative Gender - the gender that the person is considered to have for administration and record keeping purposes.
    property gender : TFhirAdministrativeGenderEnum read GetGenderST write SetGenderST;
    property genderElement : TFhirEnum read FGender write SetGender;

    // Typed access to The date on which the related person was born.
    property birthDate : TFslDateTime read GetBirthDateST write SetBirthDateST;
    // The date on which the related person was born.
    property birthDateElement : TFhirDate read FBirthDate write SetBirthDate;

    // Address where the related person can be contacted or visited.
    property addressList : TFhirAddressList read GetAddressList;
    property hasAddressList : boolean read GetHasAddressList;

    // Image of the person.
    property photoList : TFhirAttachmentList read GetPhotoList;
    property hasPhotoList : boolean read GetHasPhotoList;

    // Typed access to The period of time during which this relationship is or was active. If there are no dates defined, then the interval is unknown. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period of time during which this relationship is or was active. If there are no dates defined, then the interval is unknown.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // A language which may be used to communicate with about the patient's health.
    property communicationList : TFhirRelatedPersonCommunicationList read GetCommunicationList;
    property hasCommunicationList : boolean read GetHasCommunicationList;

  end;

  TFhirRelatedPersonListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRelatedPersonList;
    function GetCurrent : TFhirRelatedPerson;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRelatedPersonList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRelatedPerson read GetCurrent;
  end;

  TFhirRelatedPersonList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRelatedPerson;
    procedure SetItemN(index : Integer; value : TFhirRelatedPerson);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRelatedPersonList; overload;
    function Clone : TFhirRelatedPersonList; overload;
    function GetEnumerator : TFhirRelatedPersonListEnumerator;
    
    //  Add a FhirRelatedPerson to the end of the list.
    function Append : TFhirRelatedPerson;
    
    // Add an already existing FhirRelatedPerson to the end of the list.
    function AddItem(value : TFhirRelatedPerson) : TFhirRelatedPerson; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRelatedPerson) : Integer;
    
    // Insert FhirRelatedPerson before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRelatedPerson;
    
    // Insert an existing FhirRelatedPerson before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRelatedPerson);
    
    // Get the iIndexth FhirRelatedPerson. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRelatedPerson);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRelatedPerson;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRelatedPeople[index : Integer] : TFhirRelatedPerson read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
  // A container for slots of time that may be available for booking appointments.
  TFhirSchedule = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FActive : TFhirBoolean;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FactorList : TFhirReferenceList;
    FPlanningHorizon : TFhirPeriod;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableConceptList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    function GetActorList : TFhirReferenceList;
    function GetHasActorList : Boolean;
    procedure SetPlanningHorizon(value : TFhirPeriod);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSchedule; overload;
    function Clone : TFhirSchedule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External Ids for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Whether this schedule record is in active use or should not be used (such as was entered in error).
    property active : Boolean read GetActiveST write SetActiveST;
    // Whether this schedule record is in active use or should not be used (such as was entered in error).
    property activeElement : TFhirBoolean read FActive write SetActive;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The specific service that is to be performed during this appointment.
    property serviceTypeList : TFhirCodeableConceptList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Slots that reference this schedule resource provide the availability details to these referenced resource(s).
    property actorList : TFhirReferenceList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Typed access to The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates. (defined for API consistency)
    property planningHorizon : TFhirPeriod read FPlanningHorizon write SetPlanningHorizon;
    // The period of time that the slots that reference this Schedule resource cover (even if none exist). These  cover the amount of time that an organization's planning horizon; the interval for which they are currently accepting appointments. This does not define a "template" for planning outside these dates.
    property planningHorizonElement : TFhirPeriod read FPlanningHorizon write SetPlanningHorizon;

    // Typed access to Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
    property comment : String read GetCommentST write SetCommentST;
    // Comments on the availability to describe any extended information. Such as custom constraints on the slots that may be associated.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirScheduleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirScheduleList;
    function GetCurrent : TFhirSchedule;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirScheduleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSchedule read GetCurrent;
  end;

  TFhirScheduleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSchedule;
    procedure SetItemN(index : Integer; value : TFhirSchedule);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirScheduleList; overload;
    function Clone : TFhirScheduleList; overload;
    function GetEnumerator : TFhirScheduleListEnumerator;
    
    //  Add a FhirSchedule to the end of the list.
    function Append : TFhirSchedule;
    
    // Add an already existing FhirSchedule to the end of the list.
    function AddItem(value : TFhirSchedule) : TFhirSchedule; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSchedule) : Integer;
    
    // Insert FhirSchedule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSchedule;
    
    // Insert an existing FhirSchedule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSchedule);
    
    // Get the iIndexth FhirSchedule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSchedule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSchedule;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSchedules[index : Integer] : TFhirSchedule read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
  // A slot of time on a schedule that may be available for booking appointments.
  TFhirSlot = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FserviceCategoryList : TFhirCodeableConceptList;
    FserviceTypeList : TFhirCodeableConceptList;
    FspecialtyList : TFhirCodeableConceptList;
    FAppointmentType : TFhirCodeableConcept;
    FSchedule : TFhirReference;
    FStatus : TFhirEnum;
    FStart : TFhirInstant;
    FEnd_ : TFhirInstant;
    FOverbooked : TFhirBoolean;
    FComment : TFhirString;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetServiceCategoryList : TFhirCodeableConceptList;
    function GetHasServiceCategoryList : Boolean;
    function GetServiceTypeList : TFhirCodeableConceptList;
    function GetHasServiceTypeList : Boolean;
    function GetSpecialtyList : TFhirCodeableConceptList;
    function GetHasSpecialtyList : Boolean;
    procedure SetAppointmentType(value : TFhirCodeableConcept);
    procedure SetSchedule(value : TFhirReference);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSlotStatusEnum;
    procedure SetStatusST(value : TFhirSlotStatusEnum);
    procedure SetStart(value : TFhirInstant);
    function GetStartST : TFslDateTime;
    procedure SetStartST(value : TFslDateTime);
    procedure SetEnd_(value : TFhirInstant);
    function GetEnd_ST : TFslDateTime;
    procedure SetEnd_ST(value : TFslDateTime);
    procedure SetOverbooked(value : TFhirBoolean);
    function GetOverbookedST : Boolean;
    procedure SetOverbookedST(value : Boolean);
    procedure SetComment(value : TFhirString);
    function GetCommentST : String;
    procedure SetCommentST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSlot; overload;
    function Clone : TFhirSlot; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // External Ids for this item.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A broad categorization of the service that is to be performed during this appointment.
    property serviceCategoryList : TFhirCodeableConceptList read GetServiceCategoryList;
    property hasServiceCategoryList : boolean read GetHasServiceCategoryList;

    // The type of appointments that can be booked into this slot (ideally this would be an identifiable service - which is at a location, rather than the location itself). If provided then this overrides the value provided on the availability resource.
    property serviceTypeList : TFhirCodeableConceptList read GetServiceTypeList;
    property hasServiceTypeList : boolean read GetHasServiceTypeList;

    // The specialty of a practitioner that would be required to perform the service requested in this appointment.
    property specialtyList : TFhirCodeableConceptList read GetSpecialtyList;
    property hasSpecialtyList : boolean read GetHasSpecialtyList;

    // Typed access to The style of appointment or patient that may be booked in the slot (not service type). (defined for API consistency)
    property appointmentType : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;
    // The style of appointment or patient that may be booked in the slot (not service type).
    property appointmentTypeElement : TFhirCodeableConcept read FAppointmentType write SetAppointmentType;

    // Typed access to The schedule resource that this slot defines an interval of status information. (defined for API consistency)
    property schedule : TFhirReference read FSchedule write SetSchedule;
    // The schedule resource that this slot defines an interval of status information.
    property scheduleElement : TFhirReference read FSchedule write SetSchedule;

    // busy | free | busy-unavailable | busy-tentative | entered-in-error.
    property status : TFhirSlotStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Date/Time that the slot is to begin.
    property start : TFslDateTime read GetStartST write SetStartST;
    // Date/Time that the slot is to begin.
    property startElement : TFhirInstant read FStart write SetStart;

    // Typed access to Date/Time that the slot is to conclude.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // Date/Time that the slot is to conclude.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to This slot has already been overbooked, appointments are unlikely to be accepted for this time.
    property overbooked : Boolean read GetOverbookedST write SetOverbookedST;
    // This slot has already been overbooked, appointments are unlikely to be accepted for this time.
    property overbookedElement : TFhirBoolean read FOverbooked write SetOverbooked;

    // Typed access to Comments on the slot to describe any extended information. Such as custom constraints on the slot.
    property comment : String read GetCommentST write SetCommentST;
    // Comments on the slot to describe any extended information. Such as custom constraints on the slot.
    property commentElement : TFhirString read FComment write SetComment;

  end;

  TFhirSlotListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSlotList;
    function GetCurrent : TFhirSlot;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSlotList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSlot read GetCurrent;
  end;

  TFhirSlotList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSlot;
    procedure SetItemN(index : Integer; value : TFhirSlot);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSlotList; overload;
    function Clone : TFhirSlotList; overload;
    function GetEnumerator : TFhirSlotListEnumerator;
    
    //  Add a FhirSlot to the end of the list.
    function Append : TFhirSlot;
    
    // Add an already existing FhirSlot to the end of the list.
    function AddItem(value : TFhirSlot) : TFhirSlot; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSlot) : Integer;
    
    // Insert FhirSlot before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSlot;
    
    // Insert an existing FhirSlot before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSlot);
    
    // Get the iIndexth FhirSlot. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSlot);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSlot;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSlots[index : Integer] : TFhirSlot read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SLOT}



implementation

uses
  fhir4b_utilities;



{$IFDEF FHIR_CATALOGENTRY}
{ TFhirCatalogEntryRelatedEntry }

constructor TFhirCatalogEntryRelatedEntry.Create;
begin
  inherited;
end;

destructor TFhirCatalogEntryRelatedEntry.Destroy;
begin
  FRelationtype.free;
  FItem.free;
  inherited;
end;

procedure TFhirCatalogEntryRelatedEntry.Assign(oSource : TFslObject);
begin
  inherited;
  relationtypeElement := TFhirCatalogEntryRelatedEntry(oSource).relationtypeElement.Clone;
  item := TFhirCatalogEntryRelatedEntry(oSource).item.Clone;
end;

procedure TFhirCatalogEntryRelatedEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationtype') Then
     list.add(self.link, 'relationtype', FRelationtype.Link);
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
end;

procedure TFhirCatalogEntryRelatedEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'relationtype', 'code', false, TFhirEnum, FRelationtype.Link));
  oList.add(TFHIRProperty.Create(self, 'item', 'Reference', false, TFhirReference, FItem.Link));
end;

function TFhirCatalogEntryRelatedEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationtype') then
  begin
    RelationtypeElement := asEnum(SYSTEMS_TFhirCatalogEntryRelationTypeEnum, CODES_TFhirCatalogEntryRelationTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    Item := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCatalogEntryRelatedEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirCatalogEntryRelatedEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relationtype') then result := TFhirEnum.Create(SYSTEMS_TFhirCatalogEntryRelationTypeEnum[CatalogEntryRelationTypeNull], CODES_TFhirCatalogEntryRelationTypeEnum[CatalogEntryRelationTypeNull]) 
  else if (propName = 'item') then result := TFhirReference.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCatalogEntryRelatedEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationtype') then result := 'code'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCatalogEntryRelatedEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationtype') then RelationtypeElement := nil
  else if (propName = 'item') then ItemElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCatalogEntryRelatedEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationtype') then RelationtypeElement := asEnum(SYSTEMS_TFhirCatalogEntryRelationTypeEnum, CODES_TFhirCatalogEntryRelationTypeEnum, new)
  else if (propName = 'item') then ItemElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCatalogEntryRelatedEntry.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirCatalogEntryRelatedEntry.fhirType : string;
begin
  result := 'CatalogEntry.relatedEntry';
end;

function TFhirCatalogEntryRelatedEntry.Link : TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(inherited Link);
end;

function TFhirCatalogEntryRelatedEntry.Clone : TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(inherited Clone);
end;

function TFhirCatalogEntryRelatedEntry.equals(other : TObject) : boolean; 
var
  o : TFhirCatalogEntryRelatedEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCatalogEntryRelatedEntry)) then
    result := false
  else
  begin
    o := TFhirCatalogEntryRelatedEntry(other);
    result := compareDeep(relationtypeElement, o.relationtypeElement, true) and 
      compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirCatalogEntryRelatedEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelationtype) and isEmptyProp(FItem);
end;

procedure TFhirCatalogEntryRelatedEntry.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('relationtype');
  fields.add('item');
end;

function TFhirCatalogEntryRelatedEntry.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirCatalogEntryRelatedEntry.SetRelationtype(value : TFhirEnum);
begin
  FRelationtype.free;
  FRelationtype := value;
end;

function TFhirCatalogEntryRelatedEntry.GetRelationtypeST : TFhirCatalogEntryRelationTypeEnum;
begin
  if FRelationtype = nil then
    result := TFhirCatalogEntryRelationTypeEnum(0)
  else
    result := TFhirCatalogEntryRelationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirCatalogEntryRelationTypeEnum, FRelationtype.value));
end;

procedure TFhirCatalogEntryRelatedEntry.SetRelationtypeST(value : TFhirCatalogEntryRelationTypeEnum);
begin
  if ord(value) = 0 then
    RelationtypeElement := nil
  else
    RelationtypeElement := TFhirEnum.Create(SYSTEMS_TFhirCatalogEntryRelationTypeEnum[value], CODES_TFhirCatalogEntryRelationTypeEnum[value]);
end;

procedure TFhirCatalogEntryRelatedEntry.SetItem(value : TFhirReference);
begin
  FItem.free;
  FItem := value;
end;

{ TFhirCatalogEntryRelatedEntryListEnumerator }

constructor TFhirCatalogEntryRelatedEntryListEnumerator.Create(list : TFhirCatalogEntryRelatedEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCatalogEntryRelatedEntryListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirCatalogEntryRelatedEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCatalogEntryRelatedEntryListEnumerator.GetCurrent : TFhirCatalogEntryRelatedEntry;
begin
  Result := FList[FIndex];
end;

function TFhirCatalogEntryRelatedEntryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCatalogEntryRelatedEntryList }

function TFhirCatalogEntryRelatedEntryList.AddItem(value: TFhirCatalogEntryRelatedEntry): TFhirCatalogEntryRelatedEntry;
begin
  assert(value.ClassName = 'TFhirCatalogEntryRelatedEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCatalogEntryRelatedEntry');
  add(value);
  result := value;
end;

function TFhirCatalogEntryRelatedEntryList.Append: TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryRelatedEntryList.ClearItems;
begin
  Clear;
end;

function TFhirCatalogEntryRelatedEntryList.GetEnumerator : TFhirCatalogEntryRelatedEntryListEnumerator;
begin
  result := TFhirCatalogEntryRelatedEntryListEnumerator.Create(self.link);
end;

function TFhirCatalogEntryRelatedEntryList.Clone: TFhirCatalogEntryRelatedEntryList;
begin
  result := TFhirCatalogEntryRelatedEntryList(inherited Clone);
end;

function TFhirCatalogEntryRelatedEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCatalogEntryRelatedEntryList.GetItemN(index: Integer): TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryRelatedEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCatalogEntryRelatedEntry;
end;
function TFhirCatalogEntryRelatedEntryList.IndexOf(value: TFhirCatalogEntryRelatedEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCatalogEntryRelatedEntryList.Insert(index: Integer): TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryRelatedEntryList.InsertItem(index: Integer; value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value is TFhirCatalogEntryRelatedEntry);
  Inherited Insert(index, value);
end;

function TFhirCatalogEntryRelatedEntryList.Item(index: Integer): TFhirCatalogEntryRelatedEntry;
begin
  result := TFhirCatalogEntryRelatedEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryRelatedEntryList.Link: TFhirCatalogEntryRelatedEntryList;
begin
  result := TFhirCatalogEntryRelatedEntryList(inherited Link);
end;

procedure TFhirCatalogEntryRelatedEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCatalogEntryRelatedEntryList.SetItemByIndex(index: Integer; value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value is TFhirCatalogEntryRelatedEntry);
  FhirCatalogEntryRelatedEntries[index] := value;
end;

procedure TFhirCatalogEntryRelatedEntryList.SetItemN(index: Integer; value: TFhirCatalogEntryRelatedEntry);
begin
  assert(value is TFhirCatalogEntryRelatedEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirCatalogEntry }

constructor TFhirCatalogEntry.Create;
begin
  inherited;
end;

destructor TFhirCatalogEntry.Destroy;
begin
  FIdentifierList.free;
  FType_.free;
  FOrderable.free;
  FReferencedItem.free;
  FAdditionalIdentifierList.free;
  FClassificationList.free;
  FStatus.free;
  FValidityPeriod.free;
  FValidTo.free;
  FLastUpdated.free;
  FAdditionalCharacteristicList.free;
  FAdditionalClassificationList.free;
  FRelatedEntryList.free;
  inherited;
end;

procedure TFhirCatalogEntry.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirCatalogEntry(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirCatalogEntry(oSource).FIdentifierList);
  end;
  type_ := TFhirCatalogEntry(oSource).type_.Clone;
  orderableElement := TFhirCatalogEntry(oSource).orderableElement.Clone;
  referencedItem := TFhirCatalogEntry(oSource).referencedItem.Clone;
  if (TFhirCatalogEntry(oSource).FAdditionalIdentifierList = nil) then
  begin
    FAdditionalIdentifierList.free;
    FAdditionalIdentifierList := nil;
  end
  else
  begin
    if FAdditionalIdentifierList = nil then
      FAdditionalIdentifierList := TFhirIdentifierList.Create;
    FAdditionalIdentifierList.Assign(TFhirCatalogEntry(oSource).FAdditionalIdentifierList);
  end;
  if (TFhirCatalogEntry(oSource).FClassificationList = nil) then
  begin
    FClassificationList.free;
    FClassificationList := nil;
  end
  else
  begin
    if FClassificationList = nil then
      FClassificationList := TFhirCodeableConceptList.Create;
    FClassificationList.Assign(TFhirCatalogEntry(oSource).FClassificationList);
  end;
  statusElement := TFhirCatalogEntry(oSource).statusElement.Clone;
  validityPeriod := TFhirCatalogEntry(oSource).validityPeriod.Clone;
  validToElement := TFhirCatalogEntry(oSource).validToElement.Clone;
  lastUpdatedElement := TFhirCatalogEntry(oSource).lastUpdatedElement.Clone;
  if (TFhirCatalogEntry(oSource).FAdditionalCharacteristicList = nil) then
  begin
    FAdditionalCharacteristicList.free;
    FAdditionalCharacteristicList := nil;
  end
  else
  begin
    if FAdditionalCharacteristicList = nil then
      FAdditionalCharacteristicList := TFhirCodeableConceptList.Create;
    FAdditionalCharacteristicList.Assign(TFhirCatalogEntry(oSource).FAdditionalCharacteristicList);
  end;
  if (TFhirCatalogEntry(oSource).FAdditionalClassificationList = nil) then
  begin
    FAdditionalClassificationList.free;
    FAdditionalClassificationList := nil;
  end
  else
  begin
    if FAdditionalClassificationList = nil then
      FAdditionalClassificationList := TFhirCodeableConceptList.Create;
    FAdditionalClassificationList.Assign(TFhirCatalogEntry(oSource).FAdditionalClassificationList);
  end;
  if (TFhirCatalogEntry(oSource).FRelatedEntryList = nil) then
  begin
    FRelatedEntryList.free;
    FRelatedEntryList := nil;
  end
  else
  begin
    if FRelatedEntryList = nil then
      FRelatedEntryList := TFhirCatalogEntryRelatedEntryList.Create;
    FRelatedEntryList.Assign(TFhirCatalogEntry(oSource).FRelatedEntryList);
  end;
end;

function TFhirCatalogEntry.GetResourceType : TFhirResourceType;
begin
  result := frtCatalogEntry;
end;

procedure TFhirCatalogEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'orderable') Then
     list.add(self.link, 'orderable', FOrderable.Link);
  if (child_name = 'referencedItem') Then
     list.add(self.link, 'referencedItem', FReferencedItem.Link);
  if (child_name = 'additionalIdentifier') Then
    list.addAll(self, 'additionalIdentifier', FAdditionalIdentifierList);
  if (child_name = 'classification') Then
    list.addAll(self, 'classification', FClassificationList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'validityPeriod') Then
     list.add(self.link, 'validityPeriod', FValidityPeriod.Link);
  if (child_name = 'validTo') Then
     list.add(self.link, 'validTo', FValidTo.Link);
  if (child_name = 'lastUpdated') Then
     list.add(self.link, 'lastUpdated', FLastUpdated.Link);
  if (child_name = 'additionalCharacteristic') Then
    list.addAll(self, 'additionalCharacteristic', FAdditionalCharacteristicList);
  if (child_name = 'additionalClassification') Then
    list.addAll(self, 'additionalClassification', FAdditionalClassificationList);
  if (child_name = 'relatedEntry') Then
    list.addAll(self, 'relatedEntry', FRelatedEntryList);
end;

procedure TFhirCatalogEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'orderable', 'boolean', false, TFhirBoolean, FOrderable.Link));
  oList.add(TFHIRProperty.Create(self, 'referencedItem', 'Reference', false, TFhirReference, FReferencedItem.Link));
  oList.add(TFHIRProperty.Create(self, 'additionalIdentifier', 'Identifier', true, TFhirIdentifier, FAdditionalIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'classification', 'CodeableConcept', true, TFhirCodeableConcept, FClassificationList.Link));
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'validityPeriod', 'Period', false, TFhirPeriod, FValidityPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'validTo', 'dateTime', false, TFhirDateTime, FValidTo.Link));
  oList.add(TFHIRProperty.Create(self, 'lastUpdated', 'dateTime', false, TFhirDateTime, FLastUpdated.Link));
  oList.add(TFHIRProperty.Create(self, 'additionalCharacteristic', 'CodeableConcept', true, TFhirCodeableConcept, FAdditionalCharacteristicList.Link));
  oList.add(TFHIRProperty.Create(self, 'additionalClassification', 'CodeableConcept', true, TFhirCodeableConcept, FAdditionalClassificationList.Link));
  oList.add(TFHIRProperty.Create(self, 'relatedEntry', 'BackboneElement', true, TFhirCatalogEntryRelatedEntry, FRelatedEntryList.Link));
end;

function TFhirCatalogEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'orderable') then
  begin
    OrderableElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'referencedItem') then
  begin
    ReferencedItem := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'additionalIdentifier') then
  begin
    AdditionalIdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'classification') then
  begin
    ClassificationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'validityPeriod') then
  begin
    ValidityPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'validTo') then
  begin
    ValidToElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'lastUpdated') then
  begin
    LastUpdatedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'additionalCharacteristic') then
  begin
    AdditionalCharacteristicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'additionalClassification') then
  begin
    AdditionalClassificationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'relatedEntry') then
  begin
    RelatedEntryList.add(propValue as TFhirCatalogEntryRelatedEntry);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirCatalogEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'additionalIdentifier') then AdditionalIdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'classification') then ClassificationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'additionalCharacteristic') then AdditionalCharacteristicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'additionalClassification') then AdditionalClassificationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'relatedEntry') then RelatedEntryList.insertItem(index, propValue as TFhirCatalogEntryRelatedEntry)
  else inherited;
end;

function TFhirCatalogEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.Create()
  else if (propName = 'orderable') then result := TFhirBoolean.Create()
  else if (propName = 'referencedItem') then result := TFhirReference.Create()
  else if (propName = 'additionalIdentifier') then result := AdditionalIdentifierList.new()
  else if (propName = 'classification') then result := ClassificationList.new()
  else if (propName = 'status') then result := TFhirEnum.Create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'validityPeriod') then result := TFhirPeriod.Create()
  else if (propName = 'validTo') then result := TFhirDateTime.Create()
  else if (propName = 'lastUpdated') then result := TFhirDateTime.Create()
  else if (propName = 'additionalCharacteristic') then result := AdditionalCharacteristicList.new()
  else if (propName = 'additionalClassification') then result := AdditionalClassificationList.new()
  else if (propName = 'relatedEntry') then result := RelatedEntryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirCatalogEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'orderable') then result := 'boolean'
  else if (propName = 'referencedItem') then result := 'Reference'
  else if (propName = 'additionalIdentifier') then result := 'Identifier'
  else if (propName = 'classification') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'validityPeriod') then result := 'Period'
  else if (propName = 'validTo') then result := 'dateTime'
  else if (propName = 'lastUpdated') then result := 'dateTime'
  else if (propName = 'additionalCharacteristic') then result := 'CodeableConcept'
  else if (propName = 'additionalClassification') then result := 'CodeableConcept'
  else if (propName = 'relatedEntry') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirCatalogEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'orderable') then OrderableElement := nil
  else if (propName = 'referencedItem') then ReferencedItemElement := nil
  else if (propName = 'additionalIdentifier') then deletePropertyValue('additionalIdentifier', AdditionalIdentifierList, value)
  else if (propName = 'classification') then deletePropertyValue('classification', ClassificationList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'validityPeriod') then ValidityPeriodElement := nil
  else if (propName = 'validTo') then ValidToElement := nil
  else if (propName = 'lastUpdated') then LastUpdatedElement := nil
  else if (propName = 'additionalCharacteristic') then deletePropertyValue('additionalCharacteristic', AdditionalCharacteristicList, value)
  else if (propName = 'additionalClassification') then deletePropertyValue('additionalClassification', AdditionalClassificationList, value)
  else if (propName = 'relatedEntry') then deletePropertyValue('relatedEntry', RelatedEntryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirCatalogEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'orderable') then OrderableElement := asBoolean(new)
  else if (propName = 'referencedItem') then ReferencedItemElement := new as TFhirReference
  else if (propName = 'additionalIdentifier') then replacePropertyValue('additionalIdentifier', AdditionalIdentifierList, existing, new)
  else if (propName = 'classification') then replacePropertyValue('classification', ClassificationList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'validityPeriod') then ValidityPeriodElement := new as TFhirPeriod
  else if (propName = 'validTo') then ValidToElement := asDateTime(new)
  else if (propName = 'lastUpdated') then LastUpdatedElement := asDateTime(new)
  else if (propName = 'additionalCharacteristic') then replacePropertyValue('additionalCharacteristic', AdditionalCharacteristicList, existing, new)
  else if (propName = 'additionalClassification') then replacePropertyValue('additionalClassification', AdditionalClassificationList, existing, new)
  else if (propName = 'relatedEntry') then replacePropertyValue('relatedEntry', RelatedEntryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirCatalogEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'additionalIdentifier') then AdditionalIdentifierList.move(source, destination)
  else if (propName = 'classification') then ClassificationList.move(source, destination)
  else if (propName = 'additionalCharacteristic') then AdditionalCharacteristicList.move(source, destination)
  else if (propName = 'additionalClassification') then AdditionalClassificationList.move(source, destination)
  else if (propName = 'relatedEntry') then RelatedEntryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirCatalogEntry.fhirType : string;
begin
  result := 'CatalogEntry';
end;

function TFhirCatalogEntry.Link : TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(inherited Link);
end;

function TFhirCatalogEntry.Clone : TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(inherited Clone);
end;

function TFhirCatalogEntry.equals(other : TObject) : boolean; 
var
  o : TFhirCatalogEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirCatalogEntry)) then
    result := false
  else
  begin
    o := TFhirCatalogEntry(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(orderableElement, o.orderableElement, true) and compareDeep(referencedItemElement, o.referencedItemElement, true) and 
      compareDeep(additionalIdentifierList, o.additionalIdentifierList, true) and compareDeep(classificationList, o.classificationList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(validityPeriodElement, o.validityPeriodElement, true) and 
      compareDeep(validToElement, o.validToElement, true) and compareDeep(lastUpdatedElement, o.lastUpdatedElement, true) and 
      compareDeep(additionalCharacteristicList, o.additionalCharacteristicList, true) and 
      compareDeep(additionalClassificationList, o.additionalClassificationList, true) and 
      compareDeep(relatedEntryList, o.relatedEntryList, true);
  end;
end;

function TFhirCatalogEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FOrderable) and isEmptyProp(FReferencedItem) and isEmptyProp(FadditionalIdentifierList) and isEmptyProp(FclassificationList) and isEmptyProp(FStatus) and isEmptyProp(FValidityPeriod) and isEmptyProp(FValidTo) and isEmptyProp(FLastUpdated) and isEmptyProp(FadditionalCharacteristicList) and isEmptyProp(FadditionalClassificationList) and isEmptyProp(FrelatedEntryList);
end;

procedure TFhirCatalogEntry.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('orderable');
  fields.add('referencedItem');
  fields.add('additionalIdentifier');
  fields.add('classification');
  fields.add('status');
  fields.add('validityPeriod');
  fields.add('validTo');
  fields.add('lastUpdated');
  fields.add('additionalCharacteristic');
  fields.add('additionalClassification');
  fields.add('relatedEntry');
end;

function TFhirCatalogEntry.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FAdditionalIdentifierList.sizeInBytes(magic));
  inc(result, FClassificationList.sizeInBytes(magic));
  inc(result, FAdditionalCharacteristicList.sizeInBytes(magic));
  inc(result, FAdditionalClassificationList.sizeInBytes(magic));
  inc(result, FRelatedEntryList.sizeInBytes(magic));
end;

function TFhirCatalogEntry.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirCatalogEntry.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirCatalogEntry.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirCatalogEntry.SetOrderable(value : TFhirBoolean);
begin
  FOrderable.free;
  FOrderable := value;
end;

function TFhirCatalogEntry.GetOrderableST : Boolean;
begin
  if FOrderable = nil then
    result := false
  else
    result := FOrderable.value;
end;

procedure TFhirCatalogEntry.SetOrderableST(value : Boolean);
begin
  if FOrderable = nil then
    FOrderable := TFhirBoolean.Create;
  FOrderable.value := value
end;

procedure TFhirCatalogEntry.SetReferencedItem(value : TFhirReference);
begin
  FReferencedItem.free;
  FReferencedItem := value;
end;

function TFhirCatalogEntry.GetAdditionalIdentifierList : TFhirIdentifierList;
begin
  if FAdditionalIdentifierList = nil then
    FAdditionalIdentifierList := TFhirIdentifierList.Create;
  result := FAdditionalIdentifierList;
end;

function TFhirCatalogEntry.GetHasAdditionalIdentifierList : boolean;
begin
  result := (FAdditionalIdentifierList <> nil) and (FAdditionalIdentifierList.count > 0);
end;

function TFhirCatalogEntry.GetClassificationList : TFhirCodeableConceptList;
begin
  if FClassificationList = nil then
    FClassificationList := TFhirCodeableConceptList.Create;
  result := FClassificationList;
end;

function TFhirCatalogEntry.GetHasClassificationList : boolean;
begin
  result := (FClassificationList <> nil) and (FClassificationList.count > 0);
end;

procedure TFhirCatalogEntry.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirCatalogEntry.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirCatalogEntry.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirCatalogEntry.SetValidityPeriod(value : TFhirPeriod);
begin
  FValidityPeriod.free;
  FValidityPeriod := value;
end;

procedure TFhirCatalogEntry.SetValidTo(value : TFhirDateTime);
begin
  FValidTo.free;
  FValidTo := value;
end;

function TFhirCatalogEntry.GetValidToST : TFslDateTime;
begin
  if FValidTo = nil then
    result := TFslDateTime.makeNull
  else
    result := FValidTo.value;
end;

procedure TFhirCatalogEntry.SetValidToST(value : TFslDateTime);
begin
  if FValidTo = nil then
    FValidTo := TFhirDateTime.Create;
  FValidTo.value := value
end;

procedure TFhirCatalogEntry.SetLastUpdated(value : TFhirDateTime);
begin
  FLastUpdated.free;
  FLastUpdated := value;
end;

function TFhirCatalogEntry.GetLastUpdatedST : TFslDateTime;
begin
  if FLastUpdated = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastUpdated.value;
end;

procedure TFhirCatalogEntry.SetLastUpdatedST(value : TFslDateTime);
begin
  if FLastUpdated = nil then
    FLastUpdated := TFhirDateTime.Create;
  FLastUpdated.value := value
end;

function TFhirCatalogEntry.GetAdditionalCharacteristicList : TFhirCodeableConceptList;
begin
  if FAdditionalCharacteristicList = nil then
    FAdditionalCharacteristicList := TFhirCodeableConceptList.Create;
  result := FAdditionalCharacteristicList;
end;

function TFhirCatalogEntry.GetHasAdditionalCharacteristicList : boolean;
begin
  result := (FAdditionalCharacteristicList <> nil) and (FAdditionalCharacteristicList.count > 0);
end;

function TFhirCatalogEntry.GetAdditionalClassificationList : TFhirCodeableConceptList;
begin
  if FAdditionalClassificationList = nil then
    FAdditionalClassificationList := TFhirCodeableConceptList.Create;
  result := FAdditionalClassificationList;
end;

function TFhirCatalogEntry.GetHasAdditionalClassificationList : boolean;
begin
  result := (FAdditionalClassificationList <> nil) and (FAdditionalClassificationList.count > 0);
end;

function TFhirCatalogEntry.GetRelatedEntryList : TFhirCatalogEntryRelatedEntryList;
begin
  if FRelatedEntryList = nil then
    FRelatedEntryList := TFhirCatalogEntryRelatedEntryList.Create;
  result := FRelatedEntryList;
end;

function TFhirCatalogEntry.GetHasRelatedEntryList : boolean;
begin
  result := (FRelatedEntryList <> nil) and (FRelatedEntryList.count > 0);
end;

{ TFhirCatalogEntryListEnumerator }

constructor TFhirCatalogEntryListEnumerator.Create(list : TFhirCatalogEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirCatalogEntryListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirCatalogEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirCatalogEntryListEnumerator.GetCurrent : TFhirCatalogEntry;
begin
  Result := FList[FIndex];
end;

function TFhirCatalogEntryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirCatalogEntryList }

function TFhirCatalogEntryList.AddItem(value: TFhirCatalogEntry): TFhirCatalogEntry;
begin
  assert(value.ClassName = 'TFhirCatalogEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirCatalogEntry');
  add(value);
  result := value;
end;

function TFhirCatalogEntryList.Append: TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryList.ClearItems;
begin
  Clear;
end;

function TFhirCatalogEntryList.GetEnumerator : TFhirCatalogEntryListEnumerator;
begin
  result := TFhirCatalogEntryListEnumerator.Create(self.link);
end;

function TFhirCatalogEntryList.Clone: TFhirCatalogEntryList;
begin
  result := TFhirCatalogEntryList(inherited Clone);
end;

function TFhirCatalogEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirCatalogEntryList.GetItemN(index: Integer): TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirCatalogEntry;
end;
function TFhirCatalogEntryList.IndexOf(value: TFhirCatalogEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirCatalogEntryList.Insert(index: Integer): TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirCatalogEntryList.InsertItem(index: Integer; value: TFhirCatalogEntry);
begin
  assert(value is TFhirCatalogEntry);
  Inherited Insert(index, value);
end;

function TFhirCatalogEntryList.Item(index: Integer): TFhirCatalogEntry;
begin
  result := TFhirCatalogEntry(ObjectByIndex[index]);
end;

function TFhirCatalogEntryList.Link: TFhirCatalogEntryList;
begin
  result := TFhirCatalogEntryList(inherited Link);
end;

procedure TFhirCatalogEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirCatalogEntryList.SetItemByIndex(index: Integer; value: TFhirCatalogEntry);
begin
  assert(value is TFhirCatalogEntry);
  FhirCatalogEntries[index] := value;
end;

procedure TFhirCatalogEntryList.SetItemN(index: Integer; value: TFhirCatalogEntry);
begin
  assert(value is TFhirCatalogEntry);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CATALOGENTRY}
{$IFDEF FHIR_DEVICE}
{ TFhirDeviceUdiCarrier }

constructor TFhirDeviceUdiCarrier.Create;
begin
  inherited;
end;

destructor TFhirDeviceUdiCarrier.Destroy;
begin
  FDeviceIdentifier.free;
  FIssuer.free;
  FJurisdiction.free;
  FCarrierAIDC.free;
  FCarrierHRF.free;
  FEntryType.free;
  inherited;
end;

procedure TFhirDeviceUdiCarrier.Assign(oSource : TFslObject);
begin
  inherited;
  deviceIdentifierElement := TFhirDeviceUdiCarrier(oSource).deviceIdentifierElement.Clone;
  issuerElement := TFhirDeviceUdiCarrier(oSource).issuerElement.Clone;
  jurisdictionElement := TFhirDeviceUdiCarrier(oSource).jurisdictionElement.Clone;
  carrierAIDCElement := TFhirDeviceUdiCarrier(oSource).carrierAIDCElement.Clone;
  carrierHRFElement := TFhirDeviceUdiCarrier(oSource).carrierHRFElement.Clone;
  entryTypeElement := TFhirDeviceUdiCarrier(oSource).entryTypeElement.Clone;
end;

procedure TFhirDeviceUdiCarrier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'deviceIdentifier') Then
     list.add(self.link, 'deviceIdentifier', FDeviceIdentifier.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
  if (child_name = 'carrierAIDC') Then
     list.add(self.link, 'carrierAIDC', FCarrierAIDC.Link);
  if (child_name = 'carrierHRF') Then
     list.add(self.link, 'carrierHRF', FCarrierHRF.Link);
  if (child_name = 'entryType') Then
     list.add(self.link, 'entryType', FEntryType.Link);
end;

procedure TFhirDeviceUdiCarrier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'deviceIdentifier', 'string', false, TFhirString, FDeviceIdentifier.Link));
  oList.add(TFHIRProperty.Create(self, 'issuer', 'uri', false, TFhirUri, FIssuer.Link));
  oList.add(TFHIRProperty.Create(self, 'jurisdiction', 'uri', false, TFhirUri, FJurisdiction.Link));
  oList.add(TFHIRProperty.Create(self, 'carrierAIDC', 'base64Binary', false, TFhirBase64Binary, FCarrierAIDC.Link));
  oList.add(TFHIRProperty.Create(self, 'carrierHRF', 'string', false, TFhirString, FCarrierHRF.Link));
  oList.add(TFHIRProperty.Create(self, 'entryType', 'code', false, TFhirEnum, FEntryType.Link));
end;

function TFhirDeviceUdiCarrier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then
  begin
    DeviceIdentifierElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    IssuerElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'carrierAIDC') then
  begin
    CarrierAIDCElement := asBase64Binary(propValue);
    result := propValue;
  end
  else if (propName = 'carrierHRF') then
  begin
    CarrierHRFElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'entryType') then
  begin
    EntryTypeElement := asEnum(SYSTEMS_TFhirUDIEntryTypeEnum, CODES_TFhirUDIEntryTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceUdiCarrier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceUdiCarrier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then result := TFhirString.Create()
  else if (propName = 'issuer') then result := TFhirUri.Create()
  else if (propName = 'jurisdiction') then result := TFhirUri.Create()
  else if (propName = 'carrierAIDC') then result := TFhirBase64Binary.Create()
  else if (propName = 'carrierHRF') then result := TFhirString.Create()
  else if (propName = 'entryType') then result := TFhirEnum.Create(SYSTEMS_TFhirUDIEntryTypeEnum[UDIEntryTypeNull], CODES_TFhirUDIEntryTypeEnum[UDIEntryTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceUdiCarrier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'deviceIdentifier') then result := 'string'
  else if (propName = 'issuer') then result := 'uri'
  else if (propName = 'jurisdiction') then result := 'uri'
  else if (propName = 'carrierAIDC') then result := 'base64Binary'
  else if (propName = 'carrierHRF') then result := 'string'
  else if (propName = 'entryType') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceUdiCarrier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else if (propName = 'carrierAIDC') then CarrierAIDCElement := nil
  else if (propName = 'carrierHRF') then CarrierHRFElement := nil
  else if (propName = 'entryType') then EntryTypeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceUdiCarrier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := asString(new)
  else if (propName = 'issuer') then IssuerElement := asUri(new)
  else if (propName = 'jurisdiction') then JurisdictionElement := asUri(new)
  else if (propName = 'carrierAIDC') then CarrierAIDCElement := asBase64Binary(new)
  else if (propName = 'carrierHRF') then CarrierHRFElement := asString(new)
  else if (propName = 'entryType') then EntryTypeElement := asEnum(SYSTEMS_TFhirUDIEntryTypeEnum, CODES_TFhirUDIEntryTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceUdiCarrier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceUdiCarrier.fhirType : string;
begin
  result := 'Device.udiCarrier';
end;

function TFhirDeviceUdiCarrier.Link : TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(inherited Link);
end;

function TFhirDeviceUdiCarrier.Clone : TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(inherited Clone);
end;

function TFhirDeviceUdiCarrier.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceUdiCarrier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceUdiCarrier)) then
    result := false
  else
  begin
    o := TFhirDeviceUdiCarrier(other);
    result := compareDeep(deviceIdentifierElement, o.deviceIdentifierElement, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true) and 
      compareDeep(carrierAIDCElement, o.carrierAIDCElement, true) and compareDeep(carrierHRFElement, o.carrierHRFElement, true) and 
      compareDeep(entryTypeElement, o.entryTypeElement, true);
  end;
end;

function TFhirDeviceUdiCarrier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDeviceIdentifier) and isEmptyProp(FIssuer) and isEmptyProp(FJurisdiction) and isEmptyProp(FCarrierAIDC) and isEmptyProp(FCarrierHRF) and isEmptyProp(FEntryType);
end;

procedure TFhirDeviceUdiCarrier.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('deviceIdentifier');
  fields.add('issuer');
  fields.add('jurisdiction');
  fields.add('carrierAIDC');
  fields.add('carrierHRF');
  fields.add('entryType');
end;

function TFhirDeviceUdiCarrier.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceUdiCarrier.SetDeviceIdentifier(value : TFhirString);
begin
  FDeviceIdentifier.free;
  FDeviceIdentifier := value;
end;

function TFhirDeviceUdiCarrier.GetDeviceIdentifierST : String;
begin
  if FDeviceIdentifier = nil then
    result := ''
  else
    result := FDeviceIdentifier.value;
end;

procedure TFhirDeviceUdiCarrier.SetDeviceIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceIdentifier = nil then
      FDeviceIdentifier := TFhirString.Create;
    FDeviceIdentifier.value := value
  end
  else if FDeviceIdentifier <> nil then
    FDeviceIdentifier.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetIssuer(value : TFhirUri);
begin
  FIssuer.free;
  FIssuer := value;
end;

function TFhirDeviceUdiCarrier.GetIssuerST : String;
begin
  if FIssuer = nil then
    result := ''
  else
    result := FIssuer.value;
end;

procedure TFhirDeviceUdiCarrier.SetIssuerST(value : String);
begin
  if value <> '' then
  begin
    if FIssuer = nil then
      FIssuer := TFhirUri.Create;
    FIssuer.value := value
  end
  else if FIssuer <> nil then
    FIssuer.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetJurisdiction(value : TFhirUri);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

function TFhirDeviceUdiCarrier.GetJurisdictionST : String;
begin
  if FJurisdiction = nil then
    result := ''
  else
    result := FJurisdiction.value;
end;

procedure TFhirDeviceUdiCarrier.SetJurisdictionST(value : String);
begin
  if value <> '' then
  begin
    if FJurisdiction = nil then
      FJurisdiction := TFhirUri.Create;
    FJurisdiction.value := value
  end
  else if FJurisdiction <> nil then
    FJurisdiction.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetCarrierAIDC(value : TFhirBase64Binary);
begin
  FCarrierAIDC.free;
  FCarrierAIDC := value;
end;

function TFhirDeviceUdiCarrier.GetCarrierAIDCST : TBytes;
begin
  if FCarrierAIDC = nil then
    result := nil
  else
    result := FCarrierAIDC.value;
end;

procedure TFhirDeviceUdiCarrier.SetCarrierAIDCST(value : TBytes);
begin
  if value <> nil then
  begin
    if FCarrierAIDC = nil then
      FCarrierAIDC := TFhirBase64Binary.Create;
    FCarrierAIDC.value := value
  end
  else if FCarrierAIDC <> nil then
    FCarrierAIDC.value := nil;
end;

procedure TFhirDeviceUdiCarrier.SetCarrierHRF(value : TFhirString);
begin
  FCarrierHRF.free;
  FCarrierHRF := value;
end;

function TFhirDeviceUdiCarrier.GetCarrierHRFST : String;
begin
  if FCarrierHRF = nil then
    result := ''
  else
    result := FCarrierHRF.value;
end;

procedure TFhirDeviceUdiCarrier.SetCarrierHRFST(value : String);
begin
  if value <> '' then
  begin
    if FCarrierHRF = nil then
      FCarrierHRF := TFhirString.Create;
    FCarrierHRF.value := value
  end
  else if FCarrierHRF <> nil then
    FCarrierHRF.value := '';
end;

procedure TFhirDeviceUdiCarrier.SetEntryType(value : TFhirEnum);
begin
  FEntryType.free;
  FEntryType := value;
end;

function TFhirDeviceUdiCarrier.GetEntryTypeST : TFhirUDIEntryTypeEnum;
begin
  if FEntryType = nil then
    result := TFhirUDIEntryTypeEnum(0)
  else
    result := TFhirUDIEntryTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirUDIEntryTypeEnum, FEntryType.value));
end;

procedure TFhirDeviceUdiCarrier.SetEntryTypeST(value : TFhirUDIEntryTypeEnum);
begin
  if ord(value) = 0 then
    EntryTypeElement := nil
  else
    EntryTypeElement := TFhirEnum.Create(SYSTEMS_TFhirUDIEntryTypeEnum[value], CODES_TFhirUDIEntryTypeEnum[value]);
end;

{ TFhirDeviceUdiCarrierListEnumerator }

constructor TFhirDeviceUdiCarrierListEnumerator.Create(list : TFhirDeviceUdiCarrierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceUdiCarrierListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceUdiCarrierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceUdiCarrierListEnumerator.GetCurrent : TFhirDeviceUdiCarrier;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceUdiCarrierListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceUdiCarrierList }

function TFhirDeviceUdiCarrierList.AddItem(value: TFhirDeviceUdiCarrier): TFhirDeviceUdiCarrier;
begin
  assert(value.ClassName = 'TFhirDeviceUdiCarrier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceUdiCarrier');
  add(value);
  result := value;
end;

function TFhirDeviceUdiCarrierList.Append: TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUdiCarrierList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceUdiCarrierList.GetEnumerator : TFhirDeviceUdiCarrierListEnumerator;
begin
  result := TFhirDeviceUdiCarrierListEnumerator.Create(self.link);
end;

function TFhirDeviceUdiCarrierList.Clone: TFhirDeviceUdiCarrierList;
begin
  result := TFhirDeviceUdiCarrierList(inherited Clone);
end;

function TFhirDeviceUdiCarrierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceUdiCarrierList.GetItemN(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(ObjectByIndex[index]);
end;

function TFhirDeviceUdiCarrierList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceUdiCarrier;
end;
function TFhirDeviceUdiCarrierList.IndexOf(value: TFhirDeviceUdiCarrier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceUdiCarrierList.Insert(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceUdiCarrierList.InsertItem(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  Inherited Insert(index, value);
end;

function TFhirDeviceUdiCarrierList.Item(index: Integer): TFhirDeviceUdiCarrier;
begin
  result := TFhirDeviceUdiCarrier(ObjectByIndex[index]);
end;

function TFhirDeviceUdiCarrierList.Link: TFhirDeviceUdiCarrierList;
begin
  result := TFhirDeviceUdiCarrierList(inherited Link);
end;

procedure TFhirDeviceUdiCarrierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceUdiCarrierList.SetItemByIndex(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  FhirDeviceUdiCarriers[index] := value;
end;

procedure TFhirDeviceUdiCarrierList.SetItemN(index: Integer; value: TFhirDeviceUdiCarrier);
begin
  assert(value is TFhirDeviceUdiCarrier);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDeviceName }

constructor TFhirDeviceDeviceName.Create;
begin
  inherited;
end;

destructor TFhirDeviceDeviceName.Destroy;
begin
  FName.free;
  FType_.free;
  inherited;
end;

procedure TFhirDeviceDeviceName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirDeviceDeviceName(oSource).nameElement.Clone;
  type_Element := TFhirDeviceDeviceName(oSource).type_Element.Clone;
end;

procedure TFhirDeviceDeviceName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirDeviceDeviceName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
end;

function TFhirDeviceDeviceName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDeviceName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDeviceName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.Create()
  else if (propName = 'type') then result := TFhirEnum.Create(SYSTEMS_TFhirDeviceNameTypeEnum[DeviceNameTypeNull], CODES_TFhirDeviceNameTypeEnum[DeviceNameTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDeviceName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDeviceName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDeviceName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDeviceName.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDeviceName.fhirType : string;
begin
  result := 'Device.deviceName';
end;

function TFhirDeviceDeviceName.Link : TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(inherited Link);
end;

function TFhirDeviceDeviceName.Clone : TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(inherited Clone);
end;

function TFhirDeviceDeviceName.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDeviceName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDeviceName)) then
    result := false
  else
  begin
    o := TFhirDeviceDeviceName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirDeviceDeviceName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_);
end;

procedure TFhirDeviceDeviceName.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
end;

function TFhirDeviceDeviceName.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDeviceName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirDeviceDeviceName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirDeviceDeviceName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirDeviceDeviceName.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDeviceName.GetType_ST : TFhirDeviceNameTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceNameTypeEnum(0)
  else
    result := TFhirDeviceNameTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceNameTypeEnum, FType_.value));
end;

procedure TFhirDeviceDeviceName.SetType_ST(value : TFhirDeviceNameTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.Create(SYSTEMS_TFhirDeviceNameTypeEnum[value], CODES_TFhirDeviceNameTypeEnum[value]);
end;

{ TFhirDeviceDeviceNameListEnumerator }

constructor TFhirDeviceDeviceNameListEnumerator.Create(list : TFhirDeviceDeviceNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDeviceNameListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceDeviceNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDeviceNameListEnumerator.GetCurrent : TFhirDeviceDeviceName;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDeviceNameListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDeviceNameList }

function TFhirDeviceDeviceNameList.AddItem(value: TFhirDeviceDeviceName): TFhirDeviceDeviceName;
begin
  assert(value.ClassName = 'TFhirDeviceDeviceName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDeviceName');
  add(value);
  result := value;
end;

function TFhirDeviceDeviceNameList.Append: TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDeviceNameList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDeviceNameList.GetEnumerator : TFhirDeviceDeviceNameListEnumerator;
begin
  result := TFhirDeviceDeviceNameListEnumerator.Create(self.link);
end;

function TFhirDeviceDeviceNameList.Clone: TFhirDeviceDeviceNameList;
begin
  result := TFhirDeviceDeviceNameList(inherited Clone);
end;

function TFhirDeviceDeviceNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDeviceNameList.GetItemN(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDeviceNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDeviceName;
end;
function TFhirDeviceDeviceNameList.IndexOf(value: TFhirDeviceDeviceName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDeviceNameList.Insert(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDeviceNameList.InsertItem(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  Inherited Insert(index, value);
end;

function TFhirDeviceDeviceNameList.Item(index: Integer): TFhirDeviceDeviceName;
begin
  result := TFhirDeviceDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDeviceNameList.Link: TFhirDeviceDeviceNameList;
begin
  result := TFhirDeviceDeviceNameList(inherited Link);
end;

procedure TFhirDeviceDeviceNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDeviceNameList.SetItemByIndex(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  FhirDeviceDeviceNames[index] := value;
end;

procedure TFhirDeviceDeviceNameList.SetItemN(index: Integer; value: TFhirDeviceDeviceName);
begin
  assert(value is TFhirDeviceDeviceName);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceSpecialization }

constructor TFhirDeviceSpecialization.Create;
begin
  inherited;
end;

destructor TFhirDeviceSpecialization.Destroy;
begin
  FSystemType.free;
  FVersion.free;
  inherited;
end;

procedure TFhirDeviceSpecialization.Assign(oSource : TFslObject);
begin
  inherited;
  systemType := TFhirDeviceSpecialization(oSource).systemType.Clone;
  versionElement := TFhirDeviceSpecialization(oSource).versionElement.Clone;
end;

procedure TFhirDeviceSpecialization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'systemType') Then
     list.add(self.link, 'systemType', FSystemType.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
end;

procedure TFhirDeviceSpecialization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'systemType', 'CodeableConcept', false, TFhirCodeableConcept, FSystemType.Link));
  oList.add(TFHIRProperty.Create(self, 'version', 'string', false, TFhirString, FVersion.Link));
end;

function TFhirDeviceSpecialization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'systemType') then
  begin
    SystemType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceSpecialization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceSpecialization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'systemType') then result := TFhirCodeableConcept.Create()
  else if (propName = 'version') then result := TFhirString.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceSpecialization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'systemType') then result := 'CodeableConcept'
  else if (propName = 'version') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceSpecialization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := nil
  else if (propName = 'version') then VersionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceSpecialization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := new as TFhirCodeableConcept
  else if (propName = 'version') then VersionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceSpecialization.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceSpecialization.fhirType : string;
begin
  result := 'Device.specialization';
end;

function TFhirDeviceSpecialization.Link : TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(inherited Link);
end;

function TFhirDeviceSpecialization.Clone : TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(inherited Clone);
end;

function TFhirDeviceSpecialization.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceSpecialization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceSpecialization)) then
    result := false
  else
  begin
    o := TFhirDeviceSpecialization(other);
    result := compareDeep(systemTypeElement, o.systemTypeElement, true) and compareDeep(versionElement, o.versionElement, true);
  end;
end;

function TFhirDeviceSpecialization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystemType) and isEmptyProp(FVersion);
end;

procedure TFhirDeviceSpecialization.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('systemType');
  fields.add('version');
end;

function TFhirDeviceSpecialization.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceSpecialization.SetSystemType(value : TFhirCodeableConcept);
begin
  FSystemType.free;
  FSystemType := value;
end;

procedure TFhirDeviceSpecialization.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirDeviceSpecialization.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirDeviceSpecialization.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.Create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

{ TFhirDeviceSpecializationListEnumerator }

constructor TFhirDeviceSpecializationListEnumerator.Create(list : TFhirDeviceSpecializationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceSpecializationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceSpecializationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceSpecializationListEnumerator.GetCurrent : TFhirDeviceSpecialization;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceSpecializationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceSpecializationList }

function TFhirDeviceSpecializationList.AddItem(value: TFhirDeviceSpecialization): TFhirDeviceSpecialization;
begin
  assert(value.ClassName = 'TFhirDeviceSpecialization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceSpecialization');
  add(value);
  result := value;
end;

function TFhirDeviceSpecializationList.Append: TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceSpecializationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceSpecializationList.GetEnumerator : TFhirDeviceSpecializationListEnumerator;
begin
  result := TFhirDeviceSpecializationListEnumerator.Create(self.link);
end;

function TFhirDeviceSpecializationList.Clone: TFhirDeviceSpecializationList;
begin
  result := TFhirDeviceSpecializationList(inherited Clone);
end;

function TFhirDeviceSpecializationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceSpecializationList.GetItemN(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceSpecializationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceSpecialization;
end;
function TFhirDeviceSpecializationList.IndexOf(value: TFhirDeviceSpecialization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceSpecializationList.Insert(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceSpecializationList.InsertItem(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  Inherited Insert(index, value);
end;

function TFhirDeviceSpecializationList.Item(index: Integer): TFhirDeviceSpecialization;
begin
  result := TFhirDeviceSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceSpecializationList.Link: TFhirDeviceSpecializationList;
begin
  result := TFhirDeviceSpecializationList(inherited Link);
end;

procedure TFhirDeviceSpecializationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceSpecializationList.SetItemByIndex(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  FhirDeviceSpecializations[index] := value;
end;

procedure TFhirDeviceSpecializationList.SetItemN(index: Integer; value: TFhirDeviceSpecialization);
begin
  assert(value is TFhirDeviceSpecialization);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceVersion }

constructor TFhirDeviceVersion.Create;
begin
  inherited;
end;

destructor TFhirDeviceVersion.Destroy;
begin
  FType_.free;
  FComponent.free;
  FValue.free;
  inherited;
end;

procedure TFhirDeviceVersion.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceVersion(oSource).type_.Clone;
  component := TFhirDeviceVersion(oSource).component.Clone;
  valueElement := TFhirDeviceVersion(oSource).valueElement.Clone;
end;

procedure TFhirDeviceVersion.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'component') Then
     list.add(self.link, 'component', FComponent.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirDeviceVersion.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'component', 'Identifier', false, TFhirIdentifier, FComponent.Link));
  oList.add(TFHIRProperty.Create(self, 'value', 'string', false, TFhirString, FValue.Link));
end;

function TFhirDeviceVersion.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    Component := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    ValueElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceVersion.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceVersion.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.Create()
  else if (propName = 'component') then result := TFhirIdentifier.Create()
  else if (propName = 'value') then result := TFhirString.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceVersion.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'component') then result := 'Identifier'
  else if (propName = 'value') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceVersion.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'component') then ComponentElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceVersion.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'component') then ComponentElement := new as TFhirIdentifier
  else if (propName = 'value') then ValueElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceVersion.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceVersion.fhirType : string;
begin
  result := 'Device.version';
end;

function TFhirDeviceVersion.Link : TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(inherited Link);
end;

function TFhirDeviceVersion.Clone : TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(inherited Clone);
end;

function TFhirDeviceVersion.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceVersion;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceVersion)) then
    result := false
  else
  begin
    o := TFhirDeviceVersion(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(componentElement, o.componentElement, true) and 
      compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirDeviceVersion.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FComponent) and isEmptyProp(FValue);
end;

procedure TFhirDeviceVersion.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('component');
  fields.add('value');
end;

function TFhirDeviceVersion.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceVersion.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirDeviceVersion.SetComponent(value : TFhirIdentifier);
begin
  FComponent.free;
  FComponent := value;
end;

procedure TFhirDeviceVersion.SetValue(value : TFhirString);
begin
  FValue.free;
  FValue := value;
end;

function TFhirDeviceVersion.GetValueST : String;
begin
  if FValue = nil then
    result := ''
  else
    result := FValue.value;
end;

procedure TFhirDeviceVersion.SetValueST(value : String);
begin
  if value <> '' then
  begin
    if FValue = nil then
      FValue := TFhirString.Create;
    FValue.value := value
  end
  else if FValue <> nil then
    FValue.value := '';
end;

{ TFhirDeviceVersionListEnumerator }

constructor TFhirDeviceVersionListEnumerator.Create(list : TFhirDeviceVersionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceVersionListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceVersionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceVersionListEnumerator.GetCurrent : TFhirDeviceVersion;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceVersionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceVersionList }

function TFhirDeviceVersionList.AddItem(value: TFhirDeviceVersion): TFhirDeviceVersion;
begin
  assert(value.ClassName = 'TFhirDeviceVersion', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceVersion');
  add(value);
  result := value;
end;

function TFhirDeviceVersionList.Append: TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceVersionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceVersionList.GetEnumerator : TFhirDeviceVersionListEnumerator;
begin
  result := TFhirDeviceVersionListEnumerator.Create(self.link);
end;

function TFhirDeviceVersionList.Clone: TFhirDeviceVersionList;
begin
  result := TFhirDeviceVersionList(inherited Clone);
end;

function TFhirDeviceVersionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceVersionList.GetItemN(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(ObjectByIndex[index]);
end;

function TFhirDeviceVersionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceVersion;
end;
function TFhirDeviceVersionList.IndexOf(value: TFhirDeviceVersion): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceVersionList.Insert(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceVersionList.InsertItem(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  Inherited Insert(index, value);
end;

function TFhirDeviceVersionList.Item(index: Integer): TFhirDeviceVersion;
begin
  result := TFhirDeviceVersion(ObjectByIndex[index]);
end;

function TFhirDeviceVersionList.Link: TFhirDeviceVersionList;
begin
  result := TFhirDeviceVersionList(inherited Link);
end;

procedure TFhirDeviceVersionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceVersionList.SetItemByIndex(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  FhirDeviceVersions[index] := value;
end;

procedure TFhirDeviceVersionList.SetItemN(index: Integer; value: TFhirDeviceVersion);
begin
  assert(value is TFhirDeviceVersion);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceProperty }

constructor TFhirDeviceProperty.Create;
begin
  inherited;
end;

destructor TFhirDeviceProperty.Destroy;
begin
  FType_.free;
  FValueQuantityList.free;
  FValueCodeList.free;
  inherited;
end;

procedure TFhirDeviceProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceProperty(oSource).type_.Clone;
  if (TFhirDeviceProperty(oSource).FValueQuantityList = nil) then
  begin
    FValueQuantityList.free;
    FValueQuantityList := nil;
  end
  else
  begin
    if FValueQuantityList = nil then
      FValueQuantityList := TFhirQuantityList.Create;
    FValueQuantityList.Assign(TFhirDeviceProperty(oSource).FValueQuantityList);
  end;
  if (TFhirDeviceProperty(oSource).FValueCodeList = nil) then
  begin
    FValueCodeList.free;
    FValueCodeList := nil;
  end
  else
  begin
    if FValueCodeList = nil then
      FValueCodeList := TFhirCodeableConceptList.Create;
    FValueCodeList.Assign(TFhirDeviceProperty(oSource).FValueCodeList);
  end;
end;

procedure TFhirDeviceProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'valueQuantity') Then
    list.addAll(self, 'valueQuantity', FValueQuantityList);
  if (child_name = 'valueCode') Then
    list.addAll(self, 'valueCode', FValueCodeList);
end;

procedure TFhirDeviceProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'valueQuantity', 'Quantity', true, TFhirQuantity, FValueQuantityList.Link));
  oList.add(TFHIRProperty.Create(self, 'valueCode', 'CodeableConcept', true, TFhirCodeableConcept, FValueCodeList.Link));
end;

function TFhirDeviceProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'valueQuantity') then
  begin
    ValueQuantityList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'valueCode') then
  begin
    ValueCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'valueCode') then ValueCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirDeviceProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.Create()
  else if (propName = 'valueQuantity') then result := ValueQuantityList.new()
  else if (propName = 'valueCode') then result := ValueCodeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'valueQuantity') then result := 'Quantity'
  else if (propName = 'valueCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'valueQuantity') then deletePropertyValue('valueQuantity', ValueQuantityList, value)
  else if (propName = 'valueCode') then deletePropertyValue('valueCode', ValueCodeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'valueQuantity') then replacePropertyValue('valueQuantity', ValueQuantityList, existing, new)
  else if (propName = 'valueCode') then replacePropertyValue('valueCode', ValueCodeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceProperty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.move(source, destination)
  else if (propName = 'valueCode') then ValueCodeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceProperty.fhirType : string;
begin
  result := 'Device.property';
end;

function TFhirDeviceProperty.Link : TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(inherited Link);
end;

function TFhirDeviceProperty.Clone : TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(inherited Clone);
end;

function TFhirDeviceProperty.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceProperty)) then
    result := false
  else
  begin
    o := TFhirDeviceProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueQuantityList, o.valueQuantityList, true) and 
      compareDeep(valueCodeList, o.valueCodeList, true);
  end;
end;

function TFhirDeviceProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FvalueQuantityList) and isEmptyProp(FvalueCodeList);
end;

procedure TFhirDeviceProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('valueQuantity');
  fields.add('valueCode');
end;

function TFhirDeviceProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FValueQuantityList.sizeInBytes(magic));
  inc(result, FValueCodeList.sizeInBytes(magic));
end;

procedure TFhirDeviceProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceProperty.GetValueQuantityList : TFhirQuantityList;
begin
  if FValueQuantityList = nil then
    FValueQuantityList := TFhirQuantityList.Create;
  result := FValueQuantityList;
end;

function TFhirDeviceProperty.GetHasValueQuantityList : boolean;
begin
  result := (FValueQuantityList <> nil) and (FValueQuantityList.count > 0);
end;

function TFhirDeviceProperty.GetValueCodeList : TFhirCodeableConceptList;
begin
  if FValueCodeList = nil then
    FValueCodeList := TFhirCodeableConceptList.Create;
  result := FValueCodeList;
end;

function TFhirDeviceProperty.GetHasValueCodeList : boolean;
begin
  result := (FValueCodeList <> nil) and (FValueCodeList.count > 0);
end;

{ TFhirDevicePropertyListEnumerator }

constructor TFhirDevicePropertyListEnumerator.Create(list : TFhirDevicePropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDevicePropertyListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDevicePropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDevicePropertyListEnumerator.GetCurrent : TFhirDeviceProperty;
begin
  Result := FList[FIndex];
end;

function TFhirDevicePropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDevicePropertyList }

function TFhirDevicePropertyList.AddItem(value: TFhirDeviceProperty): TFhirDeviceProperty;
begin
  assert(value.ClassName = 'TFhirDeviceProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceProperty');
  add(value);
  result := value;
end;

function TFhirDevicePropertyList.Append: TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDevicePropertyList.ClearItems;
begin
  Clear;
end;

function TFhirDevicePropertyList.GetEnumerator : TFhirDevicePropertyListEnumerator;
begin
  result := TFhirDevicePropertyListEnumerator.Create(self.link);
end;

function TFhirDevicePropertyList.Clone: TFhirDevicePropertyList;
begin
  result := TFhirDevicePropertyList(inherited Clone);
end;

function TFhirDevicePropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDevicePropertyList.GetItemN(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(ObjectByIndex[index]);
end;

function TFhirDevicePropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceProperty;
end;
function TFhirDevicePropertyList.IndexOf(value: TFhirDeviceProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDevicePropertyList.Insert(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDevicePropertyList.InsertItem(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  Inherited Insert(index, value);
end;

function TFhirDevicePropertyList.Item(index: Integer): TFhirDeviceProperty;
begin
  result := TFhirDeviceProperty(ObjectByIndex[index]);
end;

function TFhirDevicePropertyList.Link: TFhirDevicePropertyList;
begin
  result := TFhirDevicePropertyList(inherited Link);
end;

procedure TFhirDevicePropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDevicePropertyList.SetItemByIndex(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  FhirDeviceProperties[index] := value;
end;

procedure TFhirDevicePropertyList.SetItemN(index: Integer; value: TFhirDeviceProperty);
begin
  assert(value is TFhirDeviceProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirDevice }

constructor TFhirDevice.Create;
begin
  inherited;
end;

destructor TFhirDevice.Destroy;
begin
  FIdentifierList.free;
  FDefinition.free;
  FUdiCarrierList.free;
  FStatus.free;
  FStatusReasonList.free;
  FDistinctIdentifier.free;
  FManufacturer.free;
  FManufactureDate.free;
  FExpirationDate.free;
  FLotNumber.free;
  FSerialNumber.free;
  FDeviceNameList.free;
  FModelNumber.free;
  FPartNumber.free;
  FType_.free;
  FSpecializationList.free;
  FVersionList.free;
  FProperty_List.free;
  FPatient.free;
  FOwner.free;
  FContactList.free;
  FLocation.free;
  FUrl.free;
  FNoteList.free;
  FSafetyList.free;
  FParent.free;
  inherited;
end;

procedure TFhirDevice.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDevice(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDevice(oSource).FIdentifierList);
  end;
  definition := TFhirDevice(oSource).definition.Clone;
  if (TFhirDevice(oSource).FUdiCarrierList = nil) then
  begin
    FUdiCarrierList.free;
    FUdiCarrierList := nil;
  end
  else
  begin
    if FUdiCarrierList = nil then
      FUdiCarrierList := TFhirDeviceUdiCarrierList.Create;
    FUdiCarrierList.Assign(TFhirDevice(oSource).FUdiCarrierList);
  end;
  statusElement := TFhirDevice(oSource).statusElement.Clone;
  if (TFhirDevice(oSource).FStatusReasonList = nil) then
  begin
    FStatusReasonList.free;
    FStatusReasonList := nil;
  end
  else
  begin
    if FStatusReasonList = nil then
      FStatusReasonList := TFhirCodeableConceptList.Create;
    FStatusReasonList.Assign(TFhirDevice(oSource).FStatusReasonList);
  end;
  distinctIdentifierElement := TFhirDevice(oSource).distinctIdentifierElement.Clone;
  manufacturerElement := TFhirDevice(oSource).manufacturerElement.Clone;
  manufactureDateElement := TFhirDevice(oSource).manufactureDateElement.Clone;
  expirationDateElement := TFhirDevice(oSource).expirationDateElement.Clone;
  lotNumberElement := TFhirDevice(oSource).lotNumberElement.Clone;
  serialNumberElement := TFhirDevice(oSource).serialNumberElement.Clone;
  if (TFhirDevice(oSource).FDeviceNameList = nil) then
  begin
    FDeviceNameList.free;
    FDeviceNameList := nil;
  end
  else
  begin
    if FDeviceNameList = nil then
      FDeviceNameList := TFhirDeviceDeviceNameList.Create;
    FDeviceNameList.Assign(TFhirDevice(oSource).FDeviceNameList);
  end;
  modelNumberElement := TFhirDevice(oSource).modelNumberElement.Clone;
  partNumberElement := TFhirDevice(oSource).partNumberElement.Clone;
  type_ := TFhirDevice(oSource).type_.Clone;
  if (TFhirDevice(oSource).FSpecializationList = nil) then
  begin
    FSpecializationList.free;
    FSpecializationList := nil;
  end
  else
  begin
    if FSpecializationList = nil then
      FSpecializationList := TFhirDeviceSpecializationList.Create;
    FSpecializationList.Assign(TFhirDevice(oSource).FSpecializationList);
  end;
  if (TFhirDevice(oSource).FVersionList = nil) then
  begin
    FVersionList.free;
    FVersionList := nil;
  end
  else
  begin
    if FVersionList = nil then
      FVersionList := TFhirDeviceVersionList.Create;
    FVersionList.Assign(TFhirDevice(oSource).FVersionList);
  end;
  if (TFhirDevice(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirDevicePropertyList.Create;
    FProperty_List.Assign(TFhirDevice(oSource).FProperty_List);
  end;
  patient := TFhirDevice(oSource).patient.Clone;
  owner := TFhirDevice(oSource).owner.Clone;
  if (TFhirDevice(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirDevice(oSource).FContactList);
  end;
  location := TFhirDevice(oSource).location.Clone;
  urlElement := TFhirDevice(oSource).urlElement.Clone;
  if (TFhirDevice(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDevice(oSource).FNoteList);
  end;
  if (TFhirDevice(oSource).FSafetyList = nil) then
  begin
    FSafetyList.free;
    FSafetyList := nil;
  end
  else
  begin
    if FSafetyList = nil then
      FSafetyList := TFhirCodeableConceptList.Create;
    FSafetyList.Assign(TFhirDevice(oSource).FSafetyList);
  end;
  parent := TFhirDevice(oSource).parent.Clone;
end;

function TFhirDevice.GetResourceType : TFhirResourceType;
begin
  result := frtDevice;
end;

procedure TFhirDevice.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'udiCarrier') Then
    list.addAll(self, 'udiCarrier', FUdiCarrierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
    list.addAll(self, 'statusReason', FStatusReasonList);
  if (child_name = 'distinctIdentifier') Then
     list.add(self.link, 'distinctIdentifier', FDistinctIdentifier.Link);
  if (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer', FManufacturer.Link);
  if (child_name = 'manufactureDate') Then
     list.add(self.link, 'manufactureDate', FManufactureDate.Link);
  if (child_name = 'expirationDate') Then
     list.add(self.link, 'expirationDate', FExpirationDate.Link);
  if (child_name = 'lotNumber') Then
     list.add(self.link, 'lotNumber', FLotNumber.Link);
  if (child_name = 'serialNumber') Then
     list.add(self.link, 'serialNumber', FSerialNumber.Link);
  if (child_name = 'deviceName') Then
    list.addAll(self, 'deviceName', FDeviceNameList);
  if (child_name = 'modelNumber') Then
     list.add(self.link, 'modelNumber', FModelNumber.Link);
  if (child_name = 'partNumber') Then
     list.add(self.link, 'partNumber', FPartNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'specialization') Then
    list.addAll(self, 'specialization', FSpecializationList);
  if (child_name = 'version') Then
    list.addAll(self, 'version', FVersionList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'safety') Then
    list.addAll(self, 'safety', FSafetyList);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
end;

procedure TFhirDevice.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'definition', 'Reference', false, TFhirReference, FDefinition.Link));
  oList.add(TFHIRProperty.Create(self, 'udiCarrier', 'BackboneElement', true, TFhirDeviceUdiCarrier, FUdiCarrierList.Link));
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'statusReason', 'CodeableConcept', true, TFhirCodeableConcept, FStatusReasonList.Link));
  oList.add(TFHIRProperty.Create(self, 'distinctIdentifier', 'string', false, TFhirString, FDistinctIdentifier.Link));
  oList.add(TFHIRProperty.Create(self, 'manufacturer', 'string', false, TFhirString, FManufacturer.Link));
  oList.add(TFHIRProperty.Create(self, 'manufactureDate', 'dateTime', false, TFhirDateTime, FManufactureDate.Link));
  oList.add(TFHIRProperty.Create(self, 'expirationDate', 'dateTime', false, TFhirDateTime, FExpirationDate.Link));
  oList.add(TFHIRProperty.Create(self, 'lotNumber', 'string', false, TFhirString, FLotNumber.Link));
  oList.add(TFHIRProperty.Create(self, 'serialNumber', 'string', false, TFhirString, FSerialNumber.Link));
  oList.add(TFHIRProperty.Create(self, 'deviceName', 'BackboneElement', true, TFhirDeviceDeviceName, FDeviceNameList.Link));
  oList.add(TFHIRProperty.Create(self, 'modelNumber', 'string', false, TFhirString, FModelNumber.Link));
  oList.add(TFHIRProperty.Create(self, 'partNumber', 'string', false, TFhirString, FPartNumber.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'specialization', 'BackboneElement', true, TFhirDeviceSpecialization, FSpecializationList.Link));
  oList.add(TFHIRProperty.Create(self, 'version', 'BackboneElement', true, TFhirDeviceVersion, FVersionList.Link));
  oList.add(TFHIRProperty.Create(self, 'property', 'BackboneElement', true, TFhirDeviceProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.Create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.Create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link));
  oList.add(TFHIRProperty.Create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link));
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.Create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.Create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.Create(self, 'safety', 'CodeableConcept', true, TFhirCodeableConcept, FSafetyList.Link));
  oList.add(TFHIRProperty.Create(self, 'parent', 'Reference', false, TFhirReference, FParent.Link));
end;

function TFhirDevice.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    Definition := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'udiCarrier') then
  begin
    UdiCarrierList.add(propValue as TFhirDeviceUdiCarrier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirFHIRDeviceStatusEnum, CODES_TFhirFHIRDeviceStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'distinctIdentifier') then
  begin
    DistinctIdentifierElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'manufacturer') then
  begin
    ManufacturerElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'manufactureDate') then
  begin
    ManufactureDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'expirationDate') then
  begin
    ExpirationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'lotNumber') then
  begin
    LotNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'serialNumber') then
  begin
    SerialNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'deviceName') then
  begin
    DeviceNameList.add(propValue as TFhirDeviceDeviceName);
    result := propValue;
  end
  else if (propName = 'modelNumber') then
  begin
    ModelNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'partNumber') then
  begin
    PartNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'specialization') then
  begin
    SpecializationList.add(propValue as TFhirDeviceSpecialization);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionList.add(propValue as TFhirDeviceVersion);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirDeviceProperty);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'safety') then
  begin
    SafetyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDevice.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'udiCarrier') then UdiCarrierList.insertItem(index, propValue as TFhirDeviceUdiCarrier)
  else if (propName = 'statusReason') then StatusReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'deviceName') then DeviceNameList.insertItem(index, propValue as TFhirDeviceDeviceName)
  else if (propName = 'specialization') then SpecializationList.insertItem(index, propValue as TFhirDeviceSpecialization)
  else if (propName = 'version') then VersionList.insertItem(index, propValue as TFhirDeviceVersion)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirDeviceProperty)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'safety') then SafetyList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirDevice.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'definition') then result := TFhirReference.Create()
  else if (propName = 'udiCarrier') then result := UdiCarrierList.new()
  else if (propName = 'status') then result := TFhirEnum.Create(SYSTEMS_TFhirFHIRDeviceStatusEnum[FHIRDeviceStatusNull], CODES_TFhirFHIRDeviceStatusEnum[FHIRDeviceStatusNull]) 
  else if (propName = 'statusReason') then result := StatusReasonList.new()
  else if (propName = 'distinctIdentifier') then result := TFhirString.Create()
  else if (propName = 'manufacturer') then result := TFhirString.Create()
  else if (propName = 'manufactureDate') then result := TFhirDateTime.Create()
  else if (propName = 'expirationDate') then result := TFhirDateTime.Create()
  else if (propName = 'lotNumber') then result := TFhirString.Create()
  else if (propName = 'serialNumber') then result := TFhirString.Create()
  else if (propName = 'deviceName') then result := DeviceNameList.new()
  else if (propName = 'modelNumber') then result := TFhirString.Create()
  else if (propName = 'partNumber') then result := TFhirString.Create()
  else if (propName = 'type') then result := TFhirCodeableConcept.Create()
  else if (propName = 'specialization') then result := SpecializationList.new()
  else if (propName = 'version') then result := VersionList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'patient') then result := TFhirReference.Create()
  else if (propName = 'owner') then result := TFhirReference.Create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'location') then result := TFhirReference.Create()
  else if (propName = 'url') then result := TFhirUri.Create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'safety') then result := SafetyList.new()
  else if (propName = 'parent') then result := TFhirReference.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDevice.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'definition') then result := 'Reference'
  else if (propName = 'udiCarrier') then result := 'BackboneElement'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'distinctIdentifier') then result := 'string'
  else if (propName = 'manufacturer') then result := 'string'
  else if (propName = 'manufactureDate') then result := 'dateTime'
  else if (propName = 'expirationDate') then result := 'dateTime'
  else if (propName = 'lotNumber') then result := 'string'
  else if (propName = 'serialNumber') then result := 'string'
  else if (propName = 'deviceName') then result := 'BackboneElement'
  else if (propName = 'modelNumber') then result := 'string'
  else if (propName = 'partNumber') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialization') then result := 'BackboneElement'
  else if (propName = 'version') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'safety') then result := 'CodeableConcept'
  else if (propName = 'parent') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDevice.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'udiCarrier') then deletePropertyValue('udiCarrier', UdiCarrierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then deletePropertyValue('statusReason', StatusReasonList, value)
  else if (propName = 'distinctIdentifier') then DistinctIdentifierElement := nil
  else if (propName = 'manufacturer') then ManufacturerElement := nil
  else if (propName = 'manufactureDate') then ManufactureDateElement := nil
  else if (propName = 'expirationDate') then ExpirationDateElement := nil
  else if (propName = 'lotNumber') then LotNumberElement := nil
  else if (propName = 'serialNumber') then SerialNumberElement := nil
  else if (propName = 'deviceName') then deletePropertyValue('deviceName', DeviceNameList, value)
  else if (propName = 'modelNumber') then ModelNumberElement := nil
  else if (propName = 'partNumber') then PartNumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'specialization') then deletePropertyValue('specialization', SpecializationList, value)
  else if (propName = 'version') then deletePropertyValue('version', VersionList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'safety') then deletePropertyValue('safety', SafetyList, value)
  else if (propName = 'parent') then ParentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDevice.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'definition') then DefinitionElement := new as TFhirReference
  else if (propName = 'udiCarrier') then replacePropertyValue('udiCarrier', UdiCarrierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirFHIRDeviceStatusEnum, CODES_TFhirFHIRDeviceStatusEnum, new)
  else if (propName = 'statusReason') then replacePropertyValue('statusReason', StatusReasonList, existing, new)
  else if (propName = 'distinctIdentifier') then DistinctIdentifierElement := asString(new)
  else if (propName = 'manufacturer') then ManufacturerElement := asString(new)
  else if (propName = 'manufactureDate') then ManufactureDateElement := asDateTime(new)
  else if (propName = 'expirationDate') then ExpirationDateElement := asDateTime(new)
  else if (propName = 'lotNumber') then LotNumberElement := asString(new)
  else if (propName = 'serialNumber') then SerialNumberElement := asString(new)
  else if (propName = 'deviceName') then replacePropertyValue('deviceName', DeviceNameList, existing, new)
  else if (propName = 'modelNumber') then ModelNumberElement := asString(new)
  else if (propName = 'partNumber') then PartNumberElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'specialization') then replacePropertyValue('specialization', SpecializationList, existing, new)
  else if (propName = 'version') then replacePropertyValue('version', VersionList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'owner') then OwnerElement := new as TFhirReference
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'safety') then replacePropertyValue('safety', SafetyList, existing, new)
  else if (propName = 'parent') then ParentElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDevice.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'udiCarrier') then UdiCarrierList.move(source, destination)
  else if (propName = 'statusReason') then StatusReasonList.move(source, destination)
  else if (propName = 'deviceName') then DeviceNameList.move(source, destination)
  else if (propName = 'specialization') then SpecializationList.move(source, destination)
  else if (propName = 'version') then VersionList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'safety') then SafetyList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDevice.fhirType : string;
begin
  result := 'Device';
end;

function TFhirDevice.Link : TFhirDevice;
begin
  result := TFhirDevice(inherited Link);
end;

function TFhirDevice.Clone : TFhirDevice;
begin
  result := TFhirDevice(inherited Clone);
end;

function TFhirDevice.equals(other : TObject) : boolean; 
var
  o : TFhirDevice;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDevice)) then
    result := false
  else
  begin
    o := TFhirDevice(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(udiCarrierList, o.udiCarrierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusReasonList, o.statusReasonList, true) and compareDeep(distinctIdentifierElement, o.distinctIdentifierElement, true) and 
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(manufactureDateElement, o.manufactureDateElement, true) and 
      compareDeep(expirationDateElement, o.expirationDateElement, true) and compareDeep(lotNumberElement, o.lotNumberElement, true) and 
      compareDeep(serialNumberElement, o.serialNumberElement, true) and compareDeep(deviceNameList, o.deviceNameList, true) and 
      compareDeep(modelNumberElement, o.modelNumberElement, true) and compareDeep(partNumberElement, o.partNumberElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(specializationList, o.specializationList, true) and 
      compareDeep(versionList, o.versionList, true) and compareDeep(property_List, o.property_List, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(urlElement, o.urlElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(safetyList, o.safetyList, true) and compareDeep(parentElement, o.parentElement, true);
  end;
end;

function TFhirDevice.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FDefinition) and isEmptyProp(FudiCarrierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusReasonList) and isEmptyProp(FDistinctIdentifier) and isEmptyProp(FManufacturer) and isEmptyProp(FManufactureDate) and isEmptyProp(FExpirationDate) and isEmptyProp(FLotNumber) and isEmptyProp(FSerialNumber) and isEmptyProp(FdeviceNameList) and isEmptyProp(FModelNumber) and isEmptyProp(FPartNumber) and isEmptyProp(FType_) and isEmptyProp(FspecializationList) and isEmptyProp(FversionList) and isEmptyProp(Fproperty_List) and isEmptyProp(FPatient) and isEmptyProp(FOwner) and isEmptyProp(FcontactList) and isEmptyProp(FLocation) and isEmptyProp(FUrl) and isEmptyProp(FnoteList) and isEmptyProp(FsafetyList) and isEmptyProp(FParent);
end;

procedure TFhirDevice.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('definition');
  fields.add('udiCarrier');
  fields.add('status');
  fields.add('statusReason');
  fields.add('distinctIdentifier');
  fields.add('manufacturer');
  fields.add('manufactureDate');
  fields.add('expirationDate');
  fields.add('lotNumber');
  fields.add('serialNumber');
  fields.add('deviceName');
  fields.add('modelNumber');
  fields.add('partNumber');
  fields.add('type');
  fields.add('specialization');
  fields.add('version');
  fields.add('property');
  fields.add('patient');
  fields.add('owner');
  fields.add('contact');
  fields.add('location');
  fields.add('url');
  fields.add('note');
  fields.add('safety');
  fields.add('parent');
end;

function TFhirDevice.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FUdiCarrierList.sizeInBytes(magic));
  inc(result, FStatusReasonList.sizeInBytes(magic));
  inc(result, FDeviceNameList.sizeInBytes(magic));
  inc(result, FSpecializationList.sizeInBytes(magic));
  inc(result, FVersionList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSafetyList.sizeInBytes(magic));
end;

function TFhirDevice.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDevice.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDevice.SetDefinition(value : TFhirReference);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirDevice.GetUdiCarrierList : TFhirDeviceUdiCarrierList;
begin
  if FUdiCarrierList = nil then
    FUdiCarrierList := TFhirDeviceUdiCarrierList.Create;
  result := FUdiCarrierList;
end;

function TFhirDevice.GetHasUdiCarrierList : boolean;
begin
  result := (FUdiCarrierList <> nil) and (FUdiCarrierList.count > 0);
end;

procedure TFhirDevice.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirDevice.GetStatusST : TFhirFHIRDeviceStatusEnum;
begin
  if FStatus = nil then
    result := TFhirFHIRDeviceStatusEnum(0)
  else
    result := TFhirFHIRDeviceStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirFHIRDeviceStatusEnum, FStatus.value));
end;

procedure TFhirDevice.SetStatusST(value : TFhirFHIRDeviceStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirFHIRDeviceStatusEnum[value], CODES_TFhirFHIRDeviceStatusEnum[value]);
end;

function TFhirDevice.GetStatusReasonList : TFhirCodeableConceptList;
begin
  if FStatusReasonList = nil then
    FStatusReasonList := TFhirCodeableConceptList.Create;
  result := FStatusReasonList;
end;

function TFhirDevice.GetHasStatusReasonList : boolean;
begin
  result := (FStatusReasonList <> nil) and (FStatusReasonList.count > 0);
end;

procedure TFhirDevice.SetDistinctIdentifier(value : TFhirString);
begin
  FDistinctIdentifier.free;
  FDistinctIdentifier := value;
end;

function TFhirDevice.GetDistinctIdentifierST : String;
begin
  if FDistinctIdentifier = nil then
    result := ''
  else
    result := FDistinctIdentifier.value;
end;

procedure TFhirDevice.SetDistinctIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDistinctIdentifier = nil then
      FDistinctIdentifier := TFhirString.Create;
    FDistinctIdentifier.value := value
  end
  else if FDistinctIdentifier <> nil then
    FDistinctIdentifier.value := '';
end;

procedure TFhirDevice.SetManufacturer(value : TFhirString);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

function TFhirDevice.GetManufacturerST : String;
begin
  if FManufacturer = nil then
    result := ''
  else
    result := FManufacturer.value;
end;

procedure TFhirDevice.SetManufacturerST(value : String);
begin
  if value <> '' then
  begin
    if FManufacturer = nil then
      FManufacturer := TFhirString.Create;
    FManufacturer.value := value
  end
  else if FManufacturer <> nil then
    FManufacturer.value := '';
end;

procedure TFhirDevice.SetManufactureDate(value : TFhirDateTime);
begin
  FManufactureDate.free;
  FManufactureDate := value;
end;

function TFhirDevice.GetManufactureDateST : TFslDateTime;
begin
  if FManufactureDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FManufactureDate.value;
end;

procedure TFhirDevice.SetManufactureDateST(value : TFslDateTime);
begin
  if FManufactureDate = nil then
    FManufactureDate := TFhirDateTime.Create;
  FManufactureDate.value := value
end;

procedure TFhirDevice.SetExpirationDate(value : TFhirDateTime);
begin
  FExpirationDate.free;
  FExpirationDate := value;
end;

function TFhirDevice.GetExpirationDateST : TFslDateTime;
begin
  if FExpirationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FExpirationDate.value;
end;

procedure TFhirDevice.SetExpirationDateST(value : TFslDateTime);
begin
  if FExpirationDate = nil then
    FExpirationDate := TFhirDateTime.Create;
  FExpirationDate.value := value
end;

procedure TFhirDevice.SetLotNumber(value : TFhirString);
begin
  FLotNumber.free;
  FLotNumber := value;
end;

function TFhirDevice.GetLotNumberST : String;
begin
  if FLotNumber = nil then
    result := ''
  else
    result := FLotNumber.value;
end;

procedure TFhirDevice.SetLotNumberST(value : String);
begin
  if value <> '' then
  begin
    if FLotNumber = nil then
      FLotNumber := TFhirString.Create;
    FLotNumber.value := value
  end
  else if FLotNumber <> nil then
    FLotNumber.value := '';
end;

procedure TFhirDevice.SetSerialNumber(value : TFhirString);
begin
  FSerialNumber.free;
  FSerialNumber := value;
end;

function TFhirDevice.GetSerialNumberST : String;
begin
  if FSerialNumber = nil then
    result := ''
  else
    result := FSerialNumber.value;
end;

procedure TFhirDevice.SetSerialNumberST(value : String);
begin
  if value <> '' then
  begin
    if FSerialNumber = nil then
      FSerialNumber := TFhirString.Create;
    FSerialNumber.value := value
  end
  else if FSerialNumber <> nil then
    FSerialNumber.value := '';
end;

function TFhirDevice.GetDeviceNameList : TFhirDeviceDeviceNameList;
begin
  if FDeviceNameList = nil then
    FDeviceNameList := TFhirDeviceDeviceNameList.Create;
  result := FDeviceNameList;
end;

function TFhirDevice.GetHasDeviceNameList : boolean;
begin
  result := (FDeviceNameList <> nil) and (FDeviceNameList.count > 0);
end;

procedure TFhirDevice.SetModelNumber(value : TFhirString);
begin
  FModelNumber.free;
  FModelNumber := value;
end;

function TFhirDevice.GetModelNumberST : String;
begin
  if FModelNumber = nil then
    result := ''
  else
    result := FModelNumber.value;
end;

procedure TFhirDevice.SetModelNumberST(value : String);
begin
  if value <> '' then
  begin
    if FModelNumber = nil then
      FModelNumber := TFhirString.Create;
    FModelNumber.value := value
  end
  else if FModelNumber <> nil then
    FModelNumber.value := '';
end;

procedure TFhirDevice.SetPartNumber(value : TFhirString);
begin
  FPartNumber.free;
  FPartNumber := value;
end;

function TFhirDevice.GetPartNumberST : String;
begin
  if FPartNumber = nil then
    result := ''
  else
    result := FPartNumber.value;
end;

procedure TFhirDevice.SetPartNumberST(value : String);
begin
  if value <> '' then
  begin
    if FPartNumber = nil then
      FPartNumber := TFhirString.Create;
    FPartNumber.value := value
  end
  else if FPartNumber <> nil then
    FPartNumber.value := '';
end;

procedure TFhirDevice.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDevice.GetSpecializationList : TFhirDeviceSpecializationList;
begin
  if FSpecializationList = nil then
    FSpecializationList := TFhirDeviceSpecializationList.Create;
  result := FSpecializationList;
end;

function TFhirDevice.GetHasSpecializationList : boolean;
begin
  result := (FSpecializationList <> nil) and (FSpecializationList.count > 0);
end;

function TFhirDevice.GetVersionList : TFhirDeviceVersionList;
begin
  if FVersionList = nil then
    FVersionList := TFhirDeviceVersionList.Create;
  result := FVersionList;
end;

function TFhirDevice.GetHasVersionList : boolean;
begin
  result := (FVersionList <> nil) and (FVersionList.count > 0);
end;

function TFhirDevice.GetProperty_List : TFhirDevicePropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirDevicePropertyList.Create;
  result := FProperty_List;
end;

function TFhirDevice.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

procedure TFhirDevice.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirDevice.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value;
end;

function TFhirDevice.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirDevice.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirDevice.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirDevice.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirDevice.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirDevice.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.Create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirDevice.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDevice.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirDevice.GetSafetyList : TFhirCodeableConceptList;
begin
  if FSafetyList = nil then
    FSafetyList := TFhirCodeableConceptList.Create;
  result := FSafetyList;
end;

function TFhirDevice.GetHasSafetyList : boolean;
begin
  result := (FSafetyList <> nil) and (FSafetyList.count > 0);
end;

procedure TFhirDevice.SetParent(value : TFhirReference);
begin
  FParent.free;
  FParent := value;
end;

{ TFhirDeviceListEnumerator }

constructor TFhirDeviceListEnumerator.Create(list : TFhirDeviceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceListEnumerator.GetCurrent : TFhirDevice;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceList }

function TFhirDeviceList.AddItem(value: TFhirDevice): TFhirDevice;
begin
  assert(value.ClassName = 'TFhirDevice', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDevice');
  add(value);
  result := value;
end;

function TFhirDeviceList.Append: TFhirDevice;
begin
  result := TFhirDevice.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceList.GetEnumerator : TFhirDeviceListEnumerator;
begin
  result := TFhirDeviceListEnumerator.Create(self.link);
end;

function TFhirDeviceList.Clone: TFhirDeviceList;
begin
  result := TFhirDeviceList(inherited Clone);
end;

function TFhirDeviceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceList.GetItemN(index: Integer): TFhirDevice;
begin
  result := TFhirDevice(ObjectByIndex[index]);
end;

function TFhirDeviceList.ItemClass: TFslObjectClass;
begin
  result := TFhirDevice;
end;
function TFhirDeviceList.IndexOf(value: TFhirDevice): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceList.Insert(index: Integer): TFhirDevice;
begin
  result := TFhirDevice.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceList.InsertItem(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  Inherited Insert(index, value);
end;

function TFhirDeviceList.Item(index: Integer): TFhirDevice;
begin
  result := TFhirDevice(ObjectByIndex[index]);
end;

function TFhirDeviceList.Link: TFhirDeviceList;
begin
  result := TFhirDeviceList(inherited Link);
end;

procedure TFhirDeviceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceList.SetItemByIndex(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  FhirDevices[index] := value;
end;

procedure TFhirDeviceList.SetItemN(index: Integer; value: TFhirDevice);
begin
  assert(value is TFhirDevice);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICE}
{$IFDEF FHIR_DEVICEDEFINITION}
{ TFhirDeviceDefinitionUdiDeviceIdentifier }

constructor TFhirDeviceDefinitionUdiDeviceIdentifier.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionUdiDeviceIdentifier.Destroy;
begin
  FDeviceIdentifier.free;
  FIssuer.free;
  FJurisdiction.free;
  inherited;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.Assign(oSource : TFslObject);
begin
  inherited;
  deviceIdentifierElement := TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).deviceIdentifierElement.Clone;
  issuerElement := TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).issuerElement.Clone;
  jurisdictionElement := TFhirDeviceDefinitionUdiDeviceIdentifier(oSource).jurisdictionElement.Clone;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'deviceIdentifier') Then
     list.add(self.link, 'deviceIdentifier', FDeviceIdentifier.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
  if (child_name = 'jurisdiction') Then
     list.add(self.link, 'jurisdiction', FJurisdiction.Link);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'deviceIdentifier', 'string', false, TFhirString, FDeviceIdentifier.Link));
  oList.add(TFHIRProperty.Create(self, 'issuer', 'uri', false, TFhirUri, FIssuer.Link));
  oList.add(TFHIRProperty.Create(self, 'jurisdiction', 'uri', false, TFhirUri, FJurisdiction.Link));
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then
  begin
    DeviceIdentifierElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    IssuerElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'deviceIdentifier') then result := TFhirString.Create()
  else if (propName = 'issuer') then result := TFhirUri.Create()
  else if (propName = 'jurisdiction') then result := TFhirUri.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'deviceIdentifier') then result := 'string'
  else if (propName = 'issuer') then result := 'uri'
  else if (propName = 'jurisdiction') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else if (propName = 'jurisdiction') then JurisdictionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'deviceIdentifier') then DeviceIdentifierElement := asString(new)
  else if (propName = 'issuer') then IssuerElement := asUri(new)
  else if (propName = 'jurisdiction') then JurisdictionElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.fhirType : string;
begin
  result := 'DeviceDefinition.udiDeviceIdentifier';
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.Link : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(inherited Link);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.Clone : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(inherited Clone);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionUdiDeviceIdentifier)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionUdiDeviceIdentifier(other);
    result := compareDeep(deviceIdentifierElement, o.deviceIdentifierElement, true) and 
      compareDeep(issuerElement, o.issuerElement, true) and compareDeep(jurisdictionElement, o.jurisdictionElement, true);
  end;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDeviceIdentifier) and isEmptyProp(FIssuer) and isEmptyProp(FJurisdiction);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('deviceIdentifier');
  fields.add('issuer');
  fields.add('jurisdiction');
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetDeviceIdentifier(value : TFhirString);
begin
  FDeviceIdentifier.free;
  FDeviceIdentifier := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetDeviceIdentifierST : String;
begin
  if FDeviceIdentifier = nil then
    result := ''
  else
    result := FDeviceIdentifier.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetDeviceIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceIdentifier = nil then
      FDeviceIdentifier := TFhirString.Create;
    FDeviceIdentifier.value := value
  end
  else if FDeviceIdentifier <> nil then
    FDeviceIdentifier.value := '';
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetIssuer(value : TFhirUri);
begin
  FIssuer.free;
  FIssuer := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetIssuerST : String;
begin
  if FIssuer = nil then
    result := ''
  else
    result := FIssuer.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetIssuerST(value : String);
begin
  if value <> '' then
  begin
    if FIssuer = nil then
      FIssuer := TFhirUri.Create;
    FIssuer.value := value
  end
  else if FIssuer <> nil then
    FIssuer.value := '';
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetJurisdiction(value : TFhirUri);
begin
  FJurisdiction.free;
  FJurisdiction := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifier.GetJurisdictionST : String;
begin
  if FJurisdiction = nil then
    result := ''
  else
    result := FJurisdiction.value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifier.SetJurisdictionST(value : String);
begin
  if value <> '' then
  begin
    if FJurisdiction = nil then
      FJurisdiction := TFhirUri.Create;
    FJurisdiction.value := value
  end
  else if FJurisdiction <> nil then
    FJurisdiction.value := '';
end;

{ TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator }

constructor TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.Create(list : TFhirDeviceDefinitionUdiDeviceIdentifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.GetCurrent : TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionUdiDeviceIdentifierList }

function TFhirDeviceDefinitionUdiDeviceIdentifierList.AddItem(value: TFhirDeviceDefinitionUdiDeviceIdentifier): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionUdiDeviceIdentifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionUdiDeviceIdentifier');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Append: TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.GetEnumerator : TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Clone: TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierList(inherited Clone);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.GetItemN(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier;
end;
function TFhirDeviceDefinitionUdiDeviceIdentifierList.IndexOf(value: TFhirDeviceDefinitionUdiDeviceIdentifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Insert(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.InsertItem(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifier);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Item(index: Integer): TFhirDeviceDefinitionUdiDeviceIdentifier;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifier(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionUdiDeviceIdentifierList.Link: TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  result := TFhirDeviceDefinitionUdiDeviceIdentifierList(inherited Link);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifier);
  FhirDeviceDefinitionUdiDeviceIdentifiers[index] := value;
end;

procedure TFhirDeviceDefinitionUdiDeviceIdentifierList.SetItemN(index: Integer; value: TFhirDeviceDefinitionUdiDeviceIdentifier);
begin
  assert(value is TFhirDeviceDefinitionUdiDeviceIdentifier);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionDeviceName }

constructor TFhirDeviceDefinitionDeviceName.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionDeviceName.Destroy;
begin
  FName.free;
  FType_.free;
  inherited;
end;

procedure TFhirDeviceDefinitionDeviceName.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirDeviceDefinitionDeviceName(oSource).nameElement.Clone;
  type_Element := TFhirDeviceDefinitionDeviceName(oSource).type_Element.Clone;
end;

procedure TFhirDeviceDefinitionDeviceName.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirDeviceDefinitionDeviceName.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
end;

function TFhirDeviceDefinitionDeviceName.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionDeviceName.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionDeviceName.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.Create()
  else if (propName = 'type') then result := TFhirEnum.Create(SYSTEMS_TFhirDeviceNameTypeEnum[DeviceNameTypeNull], CODES_TFhirDeviceNameTypeEnum[DeviceNameTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionDeviceName.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionDeviceName.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionDeviceName.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceNameTypeEnum, CODES_TFhirDeviceNameTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionDeviceName.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionDeviceName.fhirType : string;
begin
  result := 'DeviceDefinition.deviceName';
end;

function TFhirDeviceDefinitionDeviceName.Link : TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(inherited Link);
end;

function TFhirDeviceDefinitionDeviceName.Clone : TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(inherited Clone);
end;

function TFhirDeviceDefinitionDeviceName.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionDeviceName;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionDeviceName)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionDeviceName(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirDeviceDefinitionDeviceName.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_);
end;

procedure TFhirDeviceDefinitionDeviceName.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
end;

function TFhirDeviceDefinitionDeviceName.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionDeviceName.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirDeviceDefinitionDeviceName.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirDeviceDefinitionDeviceName.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirDeviceDefinitionDeviceName.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDefinitionDeviceName.GetType_ST : TFhirDeviceNameTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceNameTypeEnum(0)
  else
    result := TFhirDeviceNameTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceNameTypeEnum, FType_.value));
end;

procedure TFhirDeviceDefinitionDeviceName.SetType_ST(value : TFhirDeviceNameTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.Create(SYSTEMS_TFhirDeviceNameTypeEnum[value], CODES_TFhirDeviceNameTypeEnum[value]);
end;

{ TFhirDeviceDefinitionDeviceNameListEnumerator }

constructor TFhirDeviceDefinitionDeviceNameListEnumerator.Create(list : TFhirDeviceDefinitionDeviceNameList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionDeviceNameListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceDefinitionDeviceNameListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionDeviceNameListEnumerator.GetCurrent : TFhirDeviceDefinitionDeviceName;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionDeviceNameListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionDeviceNameList }

function TFhirDeviceDefinitionDeviceNameList.AddItem(value: TFhirDeviceDefinitionDeviceName): TFhirDeviceDefinitionDeviceName;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionDeviceName', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionDeviceName');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionDeviceNameList.Append: TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionDeviceNameList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionDeviceNameList.GetEnumerator : TFhirDeviceDefinitionDeviceNameListEnumerator;
begin
  result := TFhirDeviceDefinitionDeviceNameListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionDeviceNameList.Clone: TFhirDeviceDefinitionDeviceNameList;
begin
  result := TFhirDeviceDefinitionDeviceNameList(inherited Clone);
end;

function TFhirDeviceDefinitionDeviceNameList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionDeviceNameList.GetItemN(index: Integer): TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionDeviceNameList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionDeviceName;
end;
function TFhirDeviceDefinitionDeviceNameList.IndexOf(value: TFhirDeviceDefinitionDeviceName): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionDeviceNameList.Insert(index: Integer): TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionDeviceNameList.InsertItem(index: Integer; value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value is TFhirDeviceDefinitionDeviceName);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionDeviceNameList.Item(index: Integer): TFhirDeviceDefinitionDeviceName;
begin
  result := TFhirDeviceDefinitionDeviceName(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionDeviceNameList.Link: TFhirDeviceDefinitionDeviceNameList;
begin
  result := TFhirDeviceDefinitionDeviceNameList(inherited Link);
end;

procedure TFhirDeviceDefinitionDeviceNameList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionDeviceNameList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value is TFhirDeviceDefinitionDeviceName);
  FhirDeviceDefinitionDeviceNames[index] := value;
end;

procedure TFhirDeviceDefinitionDeviceNameList.SetItemN(index: Integer; value: TFhirDeviceDefinitionDeviceName);
begin
  assert(value is TFhirDeviceDefinitionDeviceName);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionSpecialization }

constructor TFhirDeviceDefinitionSpecialization.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionSpecialization.Destroy;
begin
  FSystemType.free;
  FVersion.free;
  inherited;
end;

procedure TFhirDeviceDefinitionSpecialization.Assign(oSource : TFslObject);
begin
  inherited;
  systemTypeElement := TFhirDeviceDefinitionSpecialization(oSource).systemTypeElement.Clone;
  versionElement := TFhirDeviceDefinitionSpecialization(oSource).versionElement.Clone;
end;

procedure TFhirDeviceDefinitionSpecialization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'systemType') Then
     list.add(self.link, 'systemType', FSystemType.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
end;

procedure TFhirDeviceDefinitionSpecialization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'systemType', 'string', false, TFhirString, FSystemType.Link));
  oList.add(TFHIRProperty.Create(self, 'version', 'string', false, TFhirString, FVersion.Link));
end;

function TFhirDeviceDefinitionSpecialization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'systemType') then
  begin
    SystemTypeElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionSpecialization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionSpecialization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'systemType') then result := TFhirString.Create()
  else if (propName = 'version') then result := TFhirString.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionSpecialization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'systemType') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionSpecialization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := nil
  else if (propName = 'version') then VersionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionSpecialization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'systemType') then SystemTypeElement := asString(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionSpecialization.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionSpecialization.fhirType : string;
begin
  result := 'DeviceDefinition.specialization';
end;

function TFhirDeviceDefinitionSpecialization.Link : TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization(inherited Link);
end;

function TFhirDeviceDefinitionSpecialization.Clone : TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization(inherited Clone);
end;

function TFhirDeviceDefinitionSpecialization.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionSpecialization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionSpecialization)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionSpecialization(other);
    result := compareDeep(systemTypeElement, o.systemTypeElement, true) and compareDeep(versionElement, o.versionElement, true);
  end;
end;

function TFhirDeviceDefinitionSpecialization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSystemType) and isEmptyProp(FVersion);
end;

procedure TFhirDeviceDefinitionSpecialization.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('systemType');
  fields.add('version');
end;

function TFhirDeviceDefinitionSpecialization.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionSpecialization.SetSystemType(value : TFhirString);
begin
  FSystemType.free;
  FSystemType := value;
end;

function TFhirDeviceDefinitionSpecialization.GetSystemTypeST : String;
begin
  if FSystemType = nil then
    result := ''
  else
    result := FSystemType.value;
end;

procedure TFhirDeviceDefinitionSpecialization.SetSystemTypeST(value : String);
begin
  if value <> '' then
  begin
    if FSystemType = nil then
      FSystemType := TFhirString.Create;
    FSystemType.value := value
  end
  else if FSystemType <> nil then
    FSystemType.value := '';
end;

procedure TFhirDeviceDefinitionSpecialization.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirDeviceDefinitionSpecialization.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirDeviceDefinitionSpecialization.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.Create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

{ TFhirDeviceDefinitionSpecializationListEnumerator }

constructor TFhirDeviceDefinitionSpecializationListEnumerator.Create(list : TFhirDeviceDefinitionSpecializationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionSpecializationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceDefinitionSpecializationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionSpecializationListEnumerator.GetCurrent : TFhirDeviceDefinitionSpecialization;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionSpecializationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionSpecializationList }

function TFhirDeviceDefinitionSpecializationList.AddItem(value: TFhirDeviceDefinitionSpecialization): TFhirDeviceDefinitionSpecialization;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionSpecialization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionSpecialization');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionSpecializationList.Append: TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionSpecializationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionSpecializationList.GetEnumerator : TFhirDeviceDefinitionSpecializationListEnumerator;
begin
  result := TFhirDeviceDefinitionSpecializationListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionSpecializationList.Clone: TFhirDeviceDefinitionSpecializationList;
begin
  result := TFhirDeviceDefinitionSpecializationList(inherited Clone);
end;

function TFhirDeviceDefinitionSpecializationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionSpecializationList.GetItemN(index: Integer): TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionSpecializationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionSpecialization;
end;
function TFhirDeviceDefinitionSpecializationList.IndexOf(value: TFhirDeviceDefinitionSpecialization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionSpecializationList.Insert(index: Integer): TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionSpecializationList.InsertItem(index: Integer; value: TFhirDeviceDefinitionSpecialization);
begin
  assert(value is TFhirDeviceDefinitionSpecialization);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionSpecializationList.Item(index: Integer): TFhirDeviceDefinitionSpecialization;
begin
  result := TFhirDeviceDefinitionSpecialization(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionSpecializationList.Link: TFhirDeviceDefinitionSpecializationList;
begin
  result := TFhirDeviceDefinitionSpecializationList(inherited Link);
end;

procedure TFhirDeviceDefinitionSpecializationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionSpecializationList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionSpecialization);
begin
  assert(value is TFhirDeviceDefinitionSpecialization);
  FhirDeviceDefinitionSpecializations[index] := value;
end;

procedure TFhirDeviceDefinitionSpecializationList.SetItemN(index: Integer; value: TFhirDeviceDefinitionSpecialization);
begin
  assert(value is TFhirDeviceDefinitionSpecialization);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionCapability }

constructor TFhirDeviceDefinitionCapability.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionCapability.Destroy;
begin
  FType_.free;
  FDescriptionList.free;
  inherited;
end;

procedure TFhirDeviceDefinitionCapability.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceDefinitionCapability(oSource).type_.Clone;
  if (TFhirDeviceDefinitionCapability(oSource).FDescriptionList = nil) then
  begin
    FDescriptionList.free;
    FDescriptionList := nil;
  end
  else
  begin
    if FDescriptionList = nil then
      FDescriptionList := TFhirCodeableConceptList.Create;
    FDescriptionList.Assign(TFhirDeviceDefinitionCapability(oSource).FDescriptionList);
  end;
end;

procedure TFhirDeviceDefinitionCapability.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
    list.addAll(self, 'description', FDescriptionList);
end;

procedure TFhirDeviceDefinitionCapability.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'description', 'CodeableConcept', true, TFhirCodeableConcept, FDescriptionList.Link));
end;

function TFhirDeviceDefinitionCapability.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionCapability.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'description') then DescriptionList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirDeviceDefinitionCapability.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.Create()
  else if (propName = 'description') then result := DescriptionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionCapability.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionCapability.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then deletePropertyValue('description', DescriptionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionCapability.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'description') then replacePropertyValue('description', DescriptionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionCapability.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'description') then DescriptionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionCapability.fhirType : string;
begin
  result := 'DeviceDefinition.capability';
end;

function TFhirDeviceDefinitionCapability.Link : TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability(inherited Link);
end;

function TFhirDeviceDefinitionCapability.Clone : TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability(inherited Clone);
end;

function TFhirDeviceDefinitionCapability.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionCapability;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionCapability)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionCapability(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(descriptionList, o.descriptionList, true);
  end;
end;

function TFhirDeviceDefinitionCapability.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FdescriptionList);
end;

procedure TFhirDeviceDefinitionCapability.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('description');
end;

function TFhirDeviceDefinitionCapability.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDescriptionList.sizeInBytes(magic));
end;

procedure TFhirDeviceDefinitionCapability.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDefinitionCapability.GetDescriptionList : TFhirCodeableConceptList;
begin
  if FDescriptionList = nil then
    FDescriptionList := TFhirCodeableConceptList.Create;
  result := FDescriptionList;
end;

function TFhirDeviceDefinitionCapability.GetHasDescriptionList : boolean;
begin
  result := (FDescriptionList <> nil) and (FDescriptionList.count > 0);
end;

{ TFhirDeviceDefinitionCapabilityListEnumerator }

constructor TFhirDeviceDefinitionCapabilityListEnumerator.Create(list : TFhirDeviceDefinitionCapabilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionCapabilityListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceDefinitionCapabilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionCapabilityListEnumerator.GetCurrent : TFhirDeviceDefinitionCapability;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionCapabilityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionCapabilityList }

function TFhirDeviceDefinitionCapabilityList.AddItem(value: TFhirDeviceDefinitionCapability): TFhirDeviceDefinitionCapability;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionCapability', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionCapability');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionCapabilityList.Append: TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionCapabilityList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionCapabilityList.GetEnumerator : TFhirDeviceDefinitionCapabilityListEnumerator;
begin
  result := TFhirDeviceDefinitionCapabilityListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionCapabilityList.Clone: TFhirDeviceDefinitionCapabilityList;
begin
  result := TFhirDeviceDefinitionCapabilityList(inherited Clone);
end;

function TFhirDeviceDefinitionCapabilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionCapabilityList.GetItemN(index: Integer): TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionCapabilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionCapability;
end;
function TFhirDeviceDefinitionCapabilityList.IndexOf(value: TFhirDeviceDefinitionCapability): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionCapabilityList.Insert(index: Integer): TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionCapabilityList.InsertItem(index: Integer; value: TFhirDeviceDefinitionCapability);
begin
  assert(value is TFhirDeviceDefinitionCapability);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionCapabilityList.Item(index: Integer): TFhirDeviceDefinitionCapability;
begin
  result := TFhirDeviceDefinitionCapability(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionCapabilityList.Link: TFhirDeviceDefinitionCapabilityList;
begin
  result := TFhirDeviceDefinitionCapabilityList(inherited Link);
end;

procedure TFhirDeviceDefinitionCapabilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionCapabilityList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionCapability);
begin
  assert(value is TFhirDeviceDefinitionCapability);
  FhirDeviceDefinitionCapabilities[index] := value;
end;

procedure TFhirDeviceDefinitionCapabilityList.SetItemN(index: Integer; value: TFhirDeviceDefinitionCapability);
begin
  assert(value is TFhirDeviceDefinitionCapability);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionProperty }

constructor TFhirDeviceDefinitionProperty.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionProperty.Destroy;
begin
  FType_.free;
  FValueQuantityList.free;
  FValueCodeList.free;
  inherited;
end;

procedure TFhirDeviceDefinitionProperty.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirDeviceDefinitionProperty(oSource).type_.Clone;
  if (TFhirDeviceDefinitionProperty(oSource).FValueQuantityList = nil) then
  begin
    FValueQuantityList.free;
    FValueQuantityList := nil;
  end
  else
  begin
    if FValueQuantityList = nil then
      FValueQuantityList := TFhirQuantityList.Create;
    FValueQuantityList.Assign(TFhirDeviceDefinitionProperty(oSource).FValueQuantityList);
  end;
  if (TFhirDeviceDefinitionProperty(oSource).FValueCodeList = nil) then
  begin
    FValueCodeList.free;
    FValueCodeList := nil;
  end
  else
  begin
    if FValueCodeList = nil then
      FValueCodeList := TFhirCodeableConceptList.Create;
    FValueCodeList.Assign(TFhirDeviceDefinitionProperty(oSource).FValueCodeList);
  end;
end;

procedure TFhirDeviceDefinitionProperty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'valueQuantity') Then
    list.addAll(self, 'valueQuantity', FValueQuantityList);
  if (child_name = 'valueCode') Then
    list.addAll(self, 'valueCode', FValueCodeList);
end;

procedure TFhirDeviceDefinitionProperty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'valueQuantity', 'Quantity', true, TFhirQuantity, FValueQuantityList.Link));
  oList.add(TFHIRProperty.Create(self, 'valueCode', 'CodeableConcept', true, TFhirCodeableConcept, FValueCodeList.Link));
end;

function TFhirDeviceDefinitionProperty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'valueQuantity') then
  begin
    ValueQuantityList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'valueCode') then
  begin
    ValueCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionProperty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'valueCode') then ValueCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirDeviceDefinitionProperty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.Create()
  else if (propName = 'valueQuantity') then result := ValueQuantityList.new()
  else if (propName = 'valueCode') then result := ValueCodeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionProperty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'valueQuantity') then result := 'Quantity'
  else if (propName = 'valueCode') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionProperty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'valueQuantity') then deletePropertyValue('valueQuantity', ValueQuantityList, value)
  else if (propName = 'valueCode') then deletePropertyValue('valueCode', ValueCodeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionProperty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'valueQuantity') then replacePropertyValue('valueQuantity', ValueQuantityList, existing, new)
  else if (propName = 'valueCode') then replacePropertyValue('valueCode', ValueCodeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionProperty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'valueQuantity') then ValueQuantityList.move(source, destination)
  else if (propName = 'valueCode') then ValueCodeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionProperty.fhirType : string;
begin
  result := 'DeviceDefinition.property';
end;

function TFhirDeviceDefinitionProperty.Link : TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(inherited Link);
end;

function TFhirDeviceDefinitionProperty.Clone : TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(inherited Clone);
end;

function TFhirDeviceDefinitionProperty.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionProperty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionProperty)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionProperty(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueQuantityList, o.valueQuantityList, true) and 
      compareDeep(valueCodeList, o.valueCodeList, true);
  end;
end;

function TFhirDeviceDefinitionProperty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FvalueQuantityList) and isEmptyProp(FvalueCodeList);
end;

procedure TFhirDeviceDefinitionProperty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('valueQuantity');
  fields.add('valueCode');
end;

function TFhirDeviceDefinitionProperty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FValueQuantityList.sizeInBytes(magic));
  inc(result, FValueCodeList.sizeInBytes(magic));
end;

procedure TFhirDeviceDefinitionProperty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDefinitionProperty.GetValueQuantityList : TFhirQuantityList;
begin
  if FValueQuantityList = nil then
    FValueQuantityList := TFhirQuantityList.Create;
  result := FValueQuantityList;
end;

function TFhirDeviceDefinitionProperty.GetHasValueQuantityList : boolean;
begin
  result := (FValueQuantityList <> nil) and (FValueQuantityList.count > 0);
end;

function TFhirDeviceDefinitionProperty.GetValueCodeList : TFhirCodeableConceptList;
begin
  if FValueCodeList = nil then
    FValueCodeList := TFhirCodeableConceptList.Create;
  result := FValueCodeList;
end;

function TFhirDeviceDefinitionProperty.GetHasValueCodeList : boolean;
begin
  result := (FValueCodeList <> nil) and (FValueCodeList.count > 0);
end;

{ TFhirDeviceDefinitionPropertyListEnumerator }

constructor TFhirDeviceDefinitionPropertyListEnumerator.Create(list : TFhirDeviceDefinitionPropertyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionPropertyListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceDefinitionPropertyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionPropertyListEnumerator.GetCurrent : TFhirDeviceDefinitionProperty;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionPropertyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionPropertyList }

function TFhirDeviceDefinitionPropertyList.AddItem(value: TFhirDeviceDefinitionProperty): TFhirDeviceDefinitionProperty;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionProperty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionProperty');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionPropertyList.Append: TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPropertyList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionPropertyList.GetEnumerator : TFhirDeviceDefinitionPropertyListEnumerator;
begin
  result := TFhirDeviceDefinitionPropertyListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionPropertyList.Clone: TFhirDeviceDefinitionPropertyList;
begin
  result := TFhirDeviceDefinitionPropertyList(inherited Clone);
end;

function TFhirDeviceDefinitionPropertyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionPropertyList.GetItemN(index: Integer): TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPropertyList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionProperty;
end;
function TFhirDeviceDefinitionPropertyList.IndexOf(value: TFhirDeviceDefinitionProperty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionPropertyList.Insert(index: Integer): TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionPropertyList.InsertItem(index: Integer; value: TFhirDeviceDefinitionProperty);
begin
  assert(value is TFhirDeviceDefinitionProperty);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionPropertyList.Item(index: Integer): TFhirDeviceDefinitionProperty;
begin
  result := TFhirDeviceDefinitionProperty(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionPropertyList.Link: TFhirDeviceDefinitionPropertyList;
begin
  result := TFhirDeviceDefinitionPropertyList(inherited Link);
end;

procedure TFhirDeviceDefinitionPropertyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionPropertyList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionProperty);
begin
  assert(value is TFhirDeviceDefinitionProperty);
  FhirDeviceDefinitionProperties[index] := value;
end;

procedure TFhirDeviceDefinitionPropertyList.SetItemN(index: Integer; value: TFhirDeviceDefinitionProperty);
begin
  assert(value is TFhirDeviceDefinitionProperty);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinitionMaterial }

constructor TFhirDeviceDefinitionMaterial.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinitionMaterial.Destroy;
begin
  FSubstance.free;
  FAlternate.free;
  FAllergenicIndicator.free;
  inherited;
end;

procedure TFhirDeviceDefinitionMaterial.Assign(oSource : TFslObject);
begin
  inherited;
  substance := TFhirDeviceDefinitionMaterial(oSource).substance.Clone;
  alternateElement := TFhirDeviceDefinitionMaterial(oSource).alternateElement.Clone;
  allergenicIndicatorElement := TFhirDeviceDefinitionMaterial(oSource).allergenicIndicatorElement.Clone;
end;

procedure TFhirDeviceDefinitionMaterial.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'substance') Then
     list.add(self.link, 'substance', FSubstance.Link);
  if (child_name = 'alternate') Then
     list.add(self.link, 'alternate', FAlternate.Link);
  if (child_name = 'allergenicIndicator') Then
     list.add(self.link, 'allergenicIndicator', FAllergenicIndicator.Link);
end;

procedure TFhirDeviceDefinitionMaterial.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'substance', 'CodeableConcept', false, TFhirCodeableConcept, FSubstance.Link));
  oList.add(TFHIRProperty.Create(self, 'alternate', 'boolean', false, TFhirBoolean, FAlternate.Link));
  oList.add(TFHIRProperty.Create(self, 'allergenicIndicator', 'boolean', false, TFhirBoolean, FAllergenicIndicator.Link));
end;

function TFhirDeviceDefinitionMaterial.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'substance') then
  begin
    Substance := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'alternate') then
  begin
    AlternateElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'allergenicIndicator') then
  begin
    AllergenicIndicatorElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinitionMaterial.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceDefinitionMaterial.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'substance') then result := TFhirCodeableConcept.Create()
  else if (propName = 'alternate') then result := TFhirBoolean.Create()
  else if (propName = 'allergenicIndicator') then result := TFhirBoolean.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinitionMaterial.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'substance') then result := 'CodeableConcept'
  else if (propName = 'alternate') then result := 'boolean'
  else if (propName = 'allergenicIndicator') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinitionMaterial.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := nil
  else if (propName = 'alternate') then AlternateElement := nil
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinitionMaterial.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'substance') then SubstanceElement := new as TFhirCodeableConcept
  else if (propName = 'alternate') then AlternateElement := asBoolean(new)
  else if (propName = 'allergenicIndicator') then AllergenicIndicatorElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinitionMaterial.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinitionMaterial.fhirType : string;
begin
  result := 'DeviceDefinition.material';
end;

function TFhirDeviceDefinitionMaterial.Link : TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(inherited Link);
end;

function TFhirDeviceDefinitionMaterial.Clone : TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(inherited Clone);
end;

function TFhirDeviceDefinitionMaterial.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinitionMaterial;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinitionMaterial)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinitionMaterial(other);
    result := compareDeep(substanceElement, o.substanceElement, true) and compareDeep(alternateElement, o.alternateElement, true) and 
      compareDeep(allergenicIndicatorElement, o.allergenicIndicatorElement, true);
  end;
end;

function TFhirDeviceDefinitionMaterial.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSubstance) and isEmptyProp(FAlternate) and isEmptyProp(FAllergenicIndicator);
end;

procedure TFhirDeviceDefinitionMaterial.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('substance');
  fields.add('alternate');
  fields.add('allergenicIndicator');
end;

function TFhirDeviceDefinitionMaterial.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceDefinitionMaterial.SetSubstance(value : TFhirCodeableConcept);
begin
  FSubstance.free;
  FSubstance := value;
end;

procedure TFhirDeviceDefinitionMaterial.SetAlternate(value : TFhirBoolean);
begin
  FAlternate.free;
  FAlternate := value;
end;

function TFhirDeviceDefinitionMaterial.GetAlternateST : Boolean;
begin
  if FAlternate = nil then
    result := false
  else
    result := FAlternate.value;
end;

procedure TFhirDeviceDefinitionMaterial.SetAlternateST(value : Boolean);
begin
  if FAlternate = nil then
    FAlternate := TFhirBoolean.Create;
  FAlternate.value := value
end;

procedure TFhirDeviceDefinitionMaterial.SetAllergenicIndicator(value : TFhirBoolean);
begin
  FAllergenicIndicator.free;
  FAllergenicIndicator := value;
end;

function TFhirDeviceDefinitionMaterial.GetAllergenicIndicatorST : Boolean;
begin
  if FAllergenicIndicator = nil then
    result := false
  else
    result := FAllergenicIndicator.value;
end;

procedure TFhirDeviceDefinitionMaterial.SetAllergenicIndicatorST(value : Boolean);
begin
  if FAllergenicIndicator = nil then
    FAllergenicIndicator := TFhirBoolean.Create;
  FAllergenicIndicator.value := value
end;

{ TFhirDeviceDefinitionMaterialListEnumerator }

constructor TFhirDeviceDefinitionMaterialListEnumerator.Create(list : TFhirDeviceDefinitionMaterialList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionMaterialListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceDefinitionMaterialListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionMaterialListEnumerator.GetCurrent : TFhirDeviceDefinitionMaterial;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionMaterialListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionMaterialList }

function TFhirDeviceDefinitionMaterialList.AddItem(value: TFhirDeviceDefinitionMaterial): TFhirDeviceDefinitionMaterial;
begin
  assert(value.ClassName = 'TFhirDeviceDefinitionMaterial', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinitionMaterial');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionMaterialList.Append: TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionMaterialList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionMaterialList.GetEnumerator : TFhirDeviceDefinitionMaterialListEnumerator;
begin
  result := TFhirDeviceDefinitionMaterialListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionMaterialList.Clone: TFhirDeviceDefinitionMaterialList;
begin
  result := TFhirDeviceDefinitionMaterialList(inherited Clone);
end;

function TFhirDeviceDefinitionMaterialList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionMaterialList.GetItemN(index: Integer): TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionMaterialList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinitionMaterial;
end;
function TFhirDeviceDefinitionMaterialList.IndexOf(value: TFhirDeviceDefinitionMaterial): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionMaterialList.Insert(index: Integer): TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionMaterialList.InsertItem(index: Integer; value: TFhirDeviceDefinitionMaterial);
begin
  assert(value is TFhirDeviceDefinitionMaterial);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionMaterialList.Item(index: Integer): TFhirDeviceDefinitionMaterial;
begin
  result := TFhirDeviceDefinitionMaterial(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionMaterialList.Link: TFhirDeviceDefinitionMaterialList;
begin
  result := TFhirDeviceDefinitionMaterialList(inherited Link);
end;

procedure TFhirDeviceDefinitionMaterialList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionMaterialList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinitionMaterial);
begin
  assert(value is TFhirDeviceDefinitionMaterial);
  FhirDeviceDefinitionMaterials[index] := value;
end;

procedure TFhirDeviceDefinitionMaterialList.SetItemN(index: Integer; value: TFhirDeviceDefinitionMaterial);
begin
  assert(value is TFhirDeviceDefinitionMaterial);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceDefinition }

constructor TFhirDeviceDefinition.Create;
begin
  inherited;
end;

destructor TFhirDeviceDefinition.Destroy;
begin
  FIdentifierList.free;
  FUdiDeviceIdentifierList.free;
  FManufacturer.free;
  FDeviceNameList.free;
  FModelNumber.free;
  FType_.free;
  FSpecializationList.free;
  FVersionList.free;
  FSafetyList.free;
  FShelfLifeStorageList.free;
  FPhysicalCharacteristics.free;
  FLanguageCodeList.free;
  FCapabilityList.free;
  FProperty_List.free;
  FOwner.free;
  FContactList.free;
  FUrl.free;
  FOnlineInformation.free;
  FNoteList.free;
  FQuantity.free;
  FParentDevice.free;
  FMaterialList.free;
  inherited;
end;

procedure TFhirDeviceDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceDefinition(oSource).FIdentifierList);
  end;
  if (TFhirDeviceDefinition(oSource).FUdiDeviceIdentifierList = nil) then
  begin
    FUdiDeviceIdentifierList.free;
    FUdiDeviceIdentifierList := nil;
  end
  else
  begin
    if FUdiDeviceIdentifierList = nil then
      FUdiDeviceIdentifierList := TFhirDeviceDefinitionUdiDeviceIdentifierList.Create;
    FUdiDeviceIdentifierList.Assign(TFhirDeviceDefinition(oSource).FUdiDeviceIdentifierList);
  end;
  manufacturer := TFhirDeviceDefinition(oSource).manufacturer.Clone;
  if (TFhirDeviceDefinition(oSource).FDeviceNameList = nil) then
  begin
    FDeviceNameList.free;
    FDeviceNameList := nil;
  end
  else
  begin
    if FDeviceNameList = nil then
      FDeviceNameList := TFhirDeviceDefinitionDeviceNameList.Create;
    FDeviceNameList.Assign(TFhirDeviceDefinition(oSource).FDeviceNameList);
  end;
  modelNumberElement := TFhirDeviceDefinition(oSource).modelNumberElement.Clone;
  type_ := TFhirDeviceDefinition(oSource).type_.Clone;
  if (TFhirDeviceDefinition(oSource).FSpecializationList = nil) then
  begin
    FSpecializationList.free;
    FSpecializationList := nil;
  end
  else
  begin
    if FSpecializationList = nil then
      FSpecializationList := TFhirDeviceDefinitionSpecializationList.Create;
    FSpecializationList.Assign(TFhirDeviceDefinition(oSource).FSpecializationList);
  end;
  if (TFhirDeviceDefinition(oSource).FVersionList = nil) then
  begin
    FVersionList.free;
    FVersionList := nil;
  end
  else
  begin
    if FVersionList = nil then
      FVersionList := TFhirStringList.Create;
    FVersionList.Assign(TFhirDeviceDefinition(oSource).FVersionList);
  end;
  if (TFhirDeviceDefinition(oSource).FSafetyList = nil) then
  begin
    FSafetyList.free;
    FSafetyList := nil;
  end
  else
  begin
    if FSafetyList = nil then
      FSafetyList := TFhirCodeableConceptList.Create;
    FSafetyList.Assign(TFhirDeviceDefinition(oSource).FSafetyList);
  end;
  if (TFhirDeviceDefinition(oSource).FShelfLifeStorageList = nil) then
  begin
    FShelfLifeStorageList.free;
    FShelfLifeStorageList := nil;
  end
  else
  begin
    if FShelfLifeStorageList = nil then
      FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
    FShelfLifeStorageList.Assign(TFhirDeviceDefinition(oSource).FShelfLifeStorageList);
  end;
  physicalCharacteristics := TFhirDeviceDefinition(oSource).physicalCharacteristics.Clone;
  if (TFhirDeviceDefinition(oSource).FLanguageCodeList = nil) then
  begin
    FLanguageCodeList.free;
    FLanguageCodeList := nil;
  end
  else
  begin
    if FLanguageCodeList = nil then
      FLanguageCodeList := TFhirCodeableConceptList.Create;
    FLanguageCodeList.Assign(TFhirDeviceDefinition(oSource).FLanguageCodeList);
  end;
  if (TFhirDeviceDefinition(oSource).FCapabilityList = nil) then
  begin
    FCapabilityList.free;
    FCapabilityList := nil;
  end
  else
  begin
    if FCapabilityList = nil then
      FCapabilityList := TFhirDeviceDefinitionCapabilityList.Create;
    FCapabilityList.Assign(TFhirDeviceDefinition(oSource).FCapabilityList);
  end;
  if (TFhirDeviceDefinition(oSource).FProperty_List = nil) then
  begin
    FProperty_List.free;
    FProperty_List := nil;
  end
  else
  begin
    if FProperty_List = nil then
      FProperty_List := TFhirDeviceDefinitionPropertyList.Create;
    FProperty_List.Assign(TFhirDeviceDefinition(oSource).FProperty_List);
  end;
  owner := TFhirDeviceDefinition(oSource).owner.Clone;
  if (TFhirDeviceDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirDeviceDefinition(oSource).FContactList);
  end;
  urlElement := TFhirDeviceDefinition(oSource).urlElement.Clone;
  onlineInformationElement := TFhirDeviceDefinition(oSource).onlineInformationElement.Clone;
  if (TFhirDeviceDefinition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirDeviceDefinition(oSource).FNoteList);
  end;
  quantity := TFhirDeviceDefinition(oSource).quantity.Clone;
  parentDevice := TFhirDeviceDefinition(oSource).parentDevice.Clone;
  if (TFhirDeviceDefinition(oSource).FMaterialList = nil) then
  begin
    FMaterialList.free;
    FMaterialList := nil;
  end
  else
  begin
    if FMaterialList = nil then
      FMaterialList := TFhirDeviceDefinitionMaterialList.Create;
    FMaterialList.Assign(TFhirDeviceDefinition(oSource).FMaterialList);
  end;
end;

function TFhirDeviceDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceDefinition;
end;

procedure TFhirDeviceDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'udiDeviceIdentifier') Then
    list.addAll(self, 'udiDeviceIdentifier', FUdiDeviceIdentifierList);
  if (child_name = 'manufacturer[x]') or (child_name = 'manufacturer') Then
     list.add(self.link, 'manufacturer[x]', FManufacturer.Link);
  if (child_name = 'deviceName') Then
    list.addAll(self, 'deviceName', FDeviceNameList);
  if (child_name = 'modelNumber') Then
     list.add(self.link, 'modelNumber', FModelNumber.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'specialization') Then
    list.addAll(self, 'specialization', FSpecializationList);
  if (child_name = 'version') Then
    list.addAll(self, 'version', FVersionList);
  if (child_name = 'safety') Then
    list.addAll(self, 'safety', FSafetyList);
  if (child_name = 'shelfLifeStorage') Then
    list.addAll(self, 'shelfLifeStorage', FShelfLifeStorageList);
  if (child_name = 'physicalCharacteristics') Then
     list.add(self.link, 'physicalCharacteristics', FPhysicalCharacteristics.Link);
  if (child_name = 'languageCode') Then
    list.addAll(self, 'languageCode', FLanguageCodeList);
  if (child_name = 'capability') Then
    list.addAll(self, 'capability', FCapabilityList);
  if (child_name = 'property') Then
    list.addAll(self, 'property', FProperty_List);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'onlineInformation') Then
     list.add(self.link, 'onlineInformation', FOnlineInformation.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'parentDevice') Then
     list.add(self.link, 'parentDevice', FParentDevice.Link);
  if (child_name = 'material') Then
    list.addAll(self, 'material', FMaterialList);
end;

procedure TFhirDeviceDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'udiDeviceIdentifier', 'BackboneElement', true, TFhirDeviceDefinitionUdiDeviceIdentifier, FUdiDeviceIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'manufacturer[x]', 'string|Reference', false, TFhirDataType, FManufacturer.Link));
  oList.add(TFHIRProperty.Create(self, 'deviceName', 'BackboneElement', true, TFhirDeviceDefinitionDeviceName, FDeviceNameList.Link));
  oList.add(TFHIRProperty.Create(self, 'modelNumber', 'string', false, TFhirString, FModelNumber.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'specialization', 'BackboneElement', true, TFhirDeviceDefinitionSpecialization, FSpecializationList.Link));
  oList.add(TFHIRProperty.Create(self, 'version', 'string', true, TFhirString, FVersionList.Link));
  oList.add(TFHIRProperty.Create(self, 'safety', 'CodeableConcept', true, TFhirCodeableConcept, FSafetyList.Link));
  oList.add(TFHIRProperty.Create(self, 'shelfLifeStorage', 'ProductShelfLife', true, TFhirProductShelfLife, FShelfLifeStorageList.Link));
  oList.add(TFHIRProperty.Create(self, 'physicalCharacteristics', 'ProdCharacteristic', false, TFhirProdCharacteristic, FPhysicalCharacteristics.Link));
  oList.add(TFHIRProperty.Create(self, 'languageCode', 'CodeableConcept', true, TFhirCodeableConcept, FLanguageCodeList.Link));
  oList.add(TFHIRProperty.Create(self, 'capability', 'BackboneElement', true, TFhirDeviceDefinitionCapability, FCapabilityList.Link));
  oList.add(TFHIRProperty.Create(self, 'property', 'BackboneElement', true, TFhirDeviceDefinitionProperty, FProperty_List.Link));
  oList.add(TFHIRProperty.Create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link));
  oList.add(TFHIRProperty.Create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link));
  oList.add(TFHIRProperty.Create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.Create(self, 'onlineInformation', 'uri', false, TFhirUri, FOnlineInformation.Link));
  oList.add(TFHIRProperty.Create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.Create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.Create(self, 'parentDevice', 'Reference', false, TFhirReference, FParentDevice.Link));
  oList.add(TFHIRProperty.Create(self, 'material', 'BackboneElement', true, TFhirDeviceDefinitionMaterial, FMaterialList.Link));
end;

function TFhirDeviceDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'udiDeviceIdentifier') then
  begin
    UdiDeviceIdentifierList.add(propValue as TFhirDeviceDefinitionUdiDeviceIdentifier);
    result := propValue;
  end
  else if (isMatchingName(propName, 'manufacturer', ['String', 'Reference'])) then
  begin
    Manufacturer := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'deviceName') then
  begin
    DeviceNameList.add(propValue as TFhirDeviceDefinitionDeviceName);
    result := propValue;
  end
  else if (propName = 'modelNumber') then
  begin
    ModelNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'specialization') then
  begin
    SpecializationList.add(propValue as TFhirDeviceDefinitionSpecialization);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'safety') then
  begin
    SafetyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'shelfLifeStorage') then
  begin
    ShelfLifeStorageList.add(propValue as TFhirProductShelfLife);
    result := propValue;
  end
  else if (propName = 'physicalCharacteristics') then
  begin
    PhysicalCharacteristics := propValue as TFhirProdCharacteristic;
    result := propValue;
  end
  else if (propName = 'languageCode') then
  begin
    LanguageCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'capability') then
  begin
    CapabilityList.add(propValue as TFhirDeviceDefinitionCapability);
    result := propValue;
  end
  else if (propName = 'property') then
  begin
    Property_List.add(propValue as TFhirDeviceDefinitionProperty);
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'onlineInformation') then
  begin
    OnlineInformationElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'parentDevice') then
  begin
    ParentDevice := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'material') then
  begin
    MaterialList.add(propValue as TFhirDeviceDefinitionMaterial);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'udiDeviceIdentifier') then UdiDeviceIdentifierList.insertItem(index, propValue as TFhirDeviceDefinitionUdiDeviceIdentifier)
  else if (propName = 'deviceName') then DeviceNameList.insertItem(index, propValue as TFhirDeviceDefinitionDeviceName)
  else if (propName = 'specialization') then SpecializationList.insertItem(index, propValue as TFhirDeviceDefinitionSpecialization)
  else if (propName = 'version') then VersionList.insertItem(index, asString(propValue))
  else if (propName = 'safety') then SafetyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.insertItem(index, propValue as TFhirProductShelfLife)
  else if (propName = 'languageCode') then LanguageCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'capability') then CapabilityList.insertItem(index, propValue as TFhirDeviceDefinitionCapability)
  else if (propName = 'property') then Property_List.insertItem(index, propValue as TFhirDeviceDefinitionProperty)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'material') then MaterialList.insertItem(index, propValue as TFhirDeviceDefinitionMaterial)
  else inherited;
end;

function TFhirDeviceDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'udiDeviceIdentifier') then result := UdiDeviceIdentifierList.new()
  else if (isMatchingName(propName, 'manufacturer', ['String', 'Reference'])) then raise EFHIRException.Create('Cannot make property Manufacturer')
  else if (propName = 'deviceName') then result := DeviceNameList.new()
  else if (propName = 'modelNumber') then result := TFhirString.Create()
  else if (propName = 'type') then result := TFhirCodeableConcept.Create()
  else if (propName = 'specialization') then result := SpecializationList.new()
  else if (propName = 'version') then result := VersionList.new()
  else if (propName = 'safety') then result := SafetyList.new()
  else if (propName = 'shelfLifeStorage') then result := ShelfLifeStorageList.new()
  else if (propName = 'physicalCharacteristics') then result := TFhirProdCharacteristic.Create()
  else if (propName = 'languageCode') then result := LanguageCodeList.new()
  else if (propName = 'capability') then result := CapabilityList.new()
  else if (propName = 'property') then result := Property_List.new()
  else if (propName = 'owner') then result := TFhirReference.Create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'url') then result := TFhirUri.Create()
  else if (propName = 'onlineInformation') then result := TFhirUri.Create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'quantity') then result := TFhirQuantity.Create()
  else if (propName = 'parentDevice') then result := TFhirReference.Create()
  else if (propName = 'material') then result := MaterialList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'udiDeviceIdentifier') then result := 'BackboneElement'
  else if (propName = 'manufacturer[x]') then result := 'string|Reference'
  else if (propName = 'deviceName') then result := 'BackboneElement'
  else if (propName = 'modelNumber') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialization') then result := 'BackboneElement'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'safety') then result := 'CodeableConcept'
  else if (propName = 'shelfLifeStorage') then result := 'ProductShelfLife'
  else if (propName = 'physicalCharacteristics') then result := 'ProdCharacteristic'
  else if (propName = 'languageCode') then result := 'CodeableConcept'
  else if (propName = 'capability') then result := 'BackboneElement'
  else if (propName = 'property') then result := 'BackboneElement'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'onlineInformation') then result := 'uri'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'parentDevice') then result := 'Reference'
  else if (propName = 'material') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'udiDeviceIdentifier') then deletePropertyValue('udiDeviceIdentifier', UdiDeviceIdentifierList, value)
  else if (isMatchingName(propName, 'manufacturer', ['String', 'Reference'])) then ManufacturerElement := nil
  else if (propName = 'deviceName') then deletePropertyValue('deviceName', DeviceNameList, value)
  else if (propName = 'modelNumber') then ModelNumberElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'specialization') then deletePropertyValue('specialization', SpecializationList, value)
  else if (propName = 'version') then deletePropertyValue('version', VersionList, value)
  else if (propName = 'safety') then deletePropertyValue('safety', SafetyList, value)
  else if (propName = 'shelfLifeStorage') then deletePropertyValue('shelfLifeStorage', ShelfLifeStorageList, value)
  else if (propName = 'physicalCharacteristics') then PhysicalCharacteristicsElement := nil
  else if (propName = 'languageCode') then deletePropertyValue('languageCode', LanguageCodeList, value)
  else if (propName = 'capability') then deletePropertyValue('capability', CapabilityList, value)
  else if (propName = 'property') then deletePropertyValue('property', Property_List, value)
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'onlineInformation') then OnlineInformationElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'parentDevice') then ParentDeviceElement := nil
  else if (propName = 'material') then deletePropertyValue('material', MaterialList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'udiDeviceIdentifier') then replacePropertyValue('udiDeviceIdentifier', UdiDeviceIdentifierList, existing, new)
  else if (isMatchingName(propName, 'manufacturer', ['String', 'Reference'])) then ManufacturerElement := new as TFhirDataType
  else if (propName = 'deviceName') then replacePropertyValue('deviceName', DeviceNameList, existing, new)
  else if (propName = 'modelNumber') then ModelNumberElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'specialization') then replacePropertyValue('specialization', SpecializationList, existing, new)
  else if (propName = 'version') then replacePropertyValue('version', VersionList, existing, new)
  else if (propName = 'safety') then replacePropertyValue('safety', SafetyList, existing, new)
  else if (propName = 'shelfLifeStorage') then replacePropertyValue('shelfLifeStorage', ShelfLifeStorageList, existing, new)
  else if (propName = 'physicalCharacteristics') then PhysicalCharacteristicsElement := new as TFhirProdCharacteristic
  else if (propName = 'languageCode') then replacePropertyValue('languageCode', LanguageCodeList, existing, new)
  else if (propName = 'capability') then replacePropertyValue('capability', CapabilityList, existing, new)
  else if (propName = 'property') then replacePropertyValue('property', Property_List, existing, new)
  else if (propName = 'owner') then OwnerElement := new as TFhirReference
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'onlineInformation') then OnlineInformationElement := asUri(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'parentDevice') then ParentDeviceElement := new as TFhirReference
  else if (propName = 'material') then replacePropertyValue('material', MaterialList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'udiDeviceIdentifier') then UdiDeviceIdentifierList.move(source, destination)
  else if (propName = 'deviceName') then DeviceNameList.move(source, destination)
  else if (propName = 'specialization') then SpecializationList.move(source, destination)
  else if (propName = 'version') then VersionList.move(source, destination)
  else if (propName = 'safety') then SafetyList.move(source, destination)
  else if (propName = 'shelfLifeStorage') then ShelfLifeStorageList.move(source, destination)
  else if (propName = 'languageCode') then LanguageCodeList.move(source, destination)
  else if (propName = 'capability') then CapabilityList.move(source, destination)
  else if (propName = 'property') then Property_List.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'material') then MaterialList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceDefinition.fhirType : string;
begin
  result := 'DeviceDefinition';
end;

function TFhirDeviceDefinition.Link : TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(inherited Link);
end;

function TFhirDeviceDefinition.Clone : TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(inherited Clone);
end;

function TFhirDeviceDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceDefinition)) then
    result := false
  else
  begin
    o := TFhirDeviceDefinition(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(udiDeviceIdentifierList, o.udiDeviceIdentifierList, true) and 
      compareDeep(manufacturerElement, o.manufacturerElement, true) and compareDeep(deviceNameList, o.deviceNameList, true) and 
      compareDeep(modelNumberElement, o.modelNumberElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(specializationList, o.specializationList, true) and compareDeep(versionList, o.versionList, true) and 
      compareDeep(safetyList, o.safetyList, true) and compareDeep(shelfLifeStorageList, o.shelfLifeStorageList, true) and 
      compareDeep(physicalCharacteristicsElement, o.physicalCharacteristicsElement, true) and 
      compareDeep(languageCodeList, o.languageCodeList, true) and compareDeep(capabilityList, o.capabilityList, true) and 
      compareDeep(property_List, o.property_List, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(onlineInformationElement, o.onlineInformationElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(parentDeviceElement, o.parentDeviceElement, true) and 
      compareDeep(materialList, o.materialList, true);
  end;
end;

function TFhirDeviceDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FudiDeviceIdentifierList) and isEmptyProp(FManufacturer) and isEmptyProp(FdeviceNameList) and isEmptyProp(FModelNumber) and isEmptyProp(FType_) and isEmptyProp(FspecializationList) and isEmptyProp(FversionList) and isEmptyProp(FsafetyList) and isEmptyProp(FshelfLifeStorageList) and isEmptyProp(FPhysicalCharacteristics) and isEmptyProp(FlanguageCodeList) and isEmptyProp(FcapabilityList) and isEmptyProp(Fproperty_List) and isEmptyProp(FOwner) and isEmptyProp(FcontactList) and isEmptyProp(FUrl) and isEmptyProp(FOnlineInformation) and isEmptyProp(FnoteList) and isEmptyProp(FQuantity) and isEmptyProp(FParentDevice) and isEmptyProp(FmaterialList);
end;

procedure TFhirDeviceDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('udiDeviceIdentifier');
  fields.add('manufacturer[x]');
  fields.add('deviceName');
  fields.add('modelNumber');
  fields.add('type');
  fields.add('specialization');
  fields.add('version');
  fields.add('safety');
  fields.add('shelfLifeStorage');
  fields.add('physicalCharacteristics');
  fields.add('languageCode');
  fields.add('capability');
  fields.add('property');
  fields.add('owner');
  fields.add('contact');
  fields.add('url');
  fields.add('onlineInformation');
  fields.add('note');
  fields.add('quantity');
  fields.add('parentDevice');
  fields.add('material');
end;

function TFhirDeviceDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FUdiDeviceIdentifierList.sizeInBytes(magic));
  inc(result, FDeviceNameList.sizeInBytes(magic));
  inc(result, FSpecializationList.sizeInBytes(magic));
  inc(result, FVersionList.sizeInBytes(magic));
  inc(result, FSafetyList.sizeInBytes(magic));
  inc(result, FShelfLifeStorageList.sizeInBytes(magic));
  inc(result, FLanguageCodeList.sizeInBytes(magic));
  inc(result, FCapabilityList.sizeInBytes(magic));
  inc(result, FProperty_List.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FMaterialList.sizeInBytes(magic));
end;

function TFhirDeviceDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirDeviceDefinition.GetUdiDeviceIdentifierList : TFhirDeviceDefinitionUdiDeviceIdentifierList;
begin
  if FUdiDeviceIdentifierList = nil then
    FUdiDeviceIdentifierList := TFhirDeviceDefinitionUdiDeviceIdentifierList.Create;
  result := FUdiDeviceIdentifierList;
end;

function TFhirDeviceDefinition.GetHasUdiDeviceIdentifierList : boolean;
begin
  result := (FUdiDeviceIdentifierList <> nil) and (FUdiDeviceIdentifierList.count > 0);
end;

procedure TFhirDeviceDefinition.SetManufacturer(value : TFhirDataType);
begin
  FManufacturer.free;
  FManufacturer := value;
end;

function TFhirDeviceDefinition.GetDeviceNameList : TFhirDeviceDefinitionDeviceNameList;
begin
  if FDeviceNameList = nil then
    FDeviceNameList := TFhirDeviceDefinitionDeviceNameList.Create;
  result := FDeviceNameList;
end;

function TFhirDeviceDefinition.GetHasDeviceNameList : boolean;
begin
  result := (FDeviceNameList <> nil) and (FDeviceNameList.count > 0);
end;

procedure TFhirDeviceDefinition.SetModelNumber(value : TFhirString);
begin
  FModelNumber.free;
  FModelNumber := value;
end;

function TFhirDeviceDefinition.GetModelNumberST : String;
begin
  if FModelNumber = nil then
    result := ''
  else
    result := FModelNumber.value;
end;

procedure TFhirDeviceDefinition.SetModelNumberST(value : String);
begin
  if value <> '' then
  begin
    if FModelNumber = nil then
      FModelNumber := TFhirString.Create;
    FModelNumber.value := value
  end
  else if FModelNumber <> nil then
    FModelNumber.value := '';
end;

procedure TFhirDeviceDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceDefinition.GetSpecializationList : TFhirDeviceDefinitionSpecializationList;
begin
  if FSpecializationList = nil then
    FSpecializationList := TFhirDeviceDefinitionSpecializationList.Create;
  result := FSpecializationList;
end;

function TFhirDeviceDefinition.GetHasSpecializationList : boolean;
begin
  result := (FSpecializationList <> nil) and (FSpecializationList.count > 0);
end;

function TFhirDeviceDefinition.GetVersionList : TFhirStringList;
begin
  if FVersionList = nil then
    FVersionList := TFhirStringList.Create;
  result := FVersionList;
end;

function TFhirDeviceDefinition.GetHasVersionList : boolean;
begin
  result := (FVersionList <> nil) and (FVersionList.count > 0);
end;

function TFhirDeviceDefinition.GetSafetyList : TFhirCodeableConceptList;
begin
  if FSafetyList = nil then
    FSafetyList := TFhirCodeableConceptList.Create;
  result := FSafetyList;
end;

function TFhirDeviceDefinition.GetHasSafetyList : boolean;
begin
  result := (FSafetyList <> nil) and (FSafetyList.count > 0);
end;

function TFhirDeviceDefinition.GetShelfLifeStorageList : TFhirProductShelfLifeList;
begin
  if FShelfLifeStorageList = nil then
    FShelfLifeStorageList := TFhirProductShelfLifeList.Create;
  result := FShelfLifeStorageList;
end;

function TFhirDeviceDefinition.GetHasShelfLifeStorageList : boolean;
begin
  result := (FShelfLifeStorageList <> nil) and (FShelfLifeStorageList.count > 0);
end;

procedure TFhirDeviceDefinition.SetPhysicalCharacteristics(value : TFhirProdCharacteristic);
begin
  FPhysicalCharacteristics.free;
  FPhysicalCharacteristics := value;
end;

function TFhirDeviceDefinition.GetLanguageCodeList : TFhirCodeableConceptList;
begin
  if FLanguageCodeList = nil then
    FLanguageCodeList := TFhirCodeableConceptList.Create;
  result := FLanguageCodeList;
end;

function TFhirDeviceDefinition.GetHasLanguageCodeList : boolean;
begin
  result := (FLanguageCodeList <> nil) and (FLanguageCodeList.count > 0);
end;

function TFhirDeviceDefinition.GetCapabilityList : TFhirDeviceDefinitionCapabilityList;
begin
  if FCapabilityList = nil then
    FCapabilityList := TFhirDeviceDefinitionCapabilityList.Create;
  result := FCapabilityList;
end;

function TFhirDeviceDefinition.GetHasCapabilityList : boolean;
begin
  result := (FCapabilityList <> nil) and (FCapabilityList.count > 0);
end;

function TFhirDeviceDefinition.GetProperty_List : TFhirDeviceDefinitionPropertyList;
begin
  if FProperty_List = nil then
    FProperty_List := TFhirDeviceDefinitionPropertyList.Create;
  result := FProperty_List;
end;

function TFhirDeviceDefinition.GetHasProperty_List : boolean;
begin
  result := (FProperty_List <> nil) and (FProperty_List.count > 0);
end;

procedure TFhirDeviceDefinition.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value;
end;

function TFhirDeviceDefinition.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirDeviceDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirDeviceDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirDeviceDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirDeviceDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.Create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirDeviceDefinition.SetOnlineInformation(value : TFhirUri);
begin
  FOnlineInformation.free;
  FOnlineInformation := value;
end;

function TFhirDeviceDefinition.GetOnlineInformationST : String;
begin
  if FOnlineInformation = nil then
    result := ''
  else
    result := FOnlineInformation.value;
end;

procedure TFhirDeviceDefinition.SetOnlineInformationST(value : String);
begin
  if value <> '' then
  begin
    if FOnlineInformation = nil then
      FOnlineInformation := TFhirUri.Create;
    FOnlineInformation.value := value
  end
  else if FOnlineInformation <> nil then
    FOnlineInformation.value := '';
end;

function TFhirDeviceDefinition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirDeviceDefinition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirDeviceDefinition.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirDeviceDefinition.SetParentDevice(value : TFhirReference);
begin
  FParentDevice.free;
  FParentDevice := value;
end;

function TFhirDeviceDefinition.GetMaterialList : TFhirDeviceDefinitionMaterialList;
begin
  if FMaterialList = nil then
    FMaterialList := TFhirDeviceDefinitionMaterialList.Create;
  result := FMaterialList;
end;

function TFhirDeviceDefinition.GetHasMaterialList : boolean;
begin
  result := (FMaterialList <> nil) and (FMaterialList.count > 0);
end;

{ TFhirDeviceDefinitionListEnumerator }

constructor TFhirDeviceDefinitionListEnumerator.Create(list : TFhirDeviceDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceDefinitionListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceDefinitionListEnumerator.GetCurrent : TFhirDeviceDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceDefinitionList }

function TFhirDeviceDefinitionList.AddItem(value: TFhirDeviceDefinition): TFhirDeviceDefinition;
begin
  assert(value.ClassName = 'TFhirDeviceDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceDefinition');
  add(value);
  result := value;
end;

function TFhirDeviceDefinitionList.Append: TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceDefinitionList.GetEnumerator : TFhirDeviceDefinitionListEnumerator;
begin
  result := TFhirDeviceDefinitionListEnumerator.Create(self.link);
end;

function TFhirDeviceDefinitionList.Clone: TFhirDeviceDefinitionList;
begin
  result := TFhirDeviceDefinitionList(inherited Clone);
end;

function TFhirDeviceDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceDefinitionList.GetItemN(index: Integer): TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceDefinition;
end;
function TFhirDeviceDefinitionList.IndexOf(value: TFhirDeviceDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceDefinitionList.Insert(index: Integer): TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceDefinitionList.InsertItem(index: Integer; value: TFhirDeviceDefinition);
begin
  assert(value is TFhirDeviceDefinition);
  Inherited Insert(index, value);
end;

function TFhirDeviceDefinitionList.Item(index: Integer): TFhirDeviceDefinition;
begin
  result := TFhirDeviceDefinition(ObjectByIndex[index]);
end;

function TFhirDeviceDefinitionList.Link: TFhirDeviceDefinitionList;
begin
  result := TFhirDeviceDefinitionList(inherited Link);
end;

procedure TFhirDeviceDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceDefinitionList.SetItemByIndex(index: Integer; value: TFhirDeviceDefinition);
begin
  assert(value is TFhirDeviceDefinition);
  FhirDeviceDefinitions[index] := value;
end;

procedure TFhirDeviceDefinitionList.SetItemN(index: Integer; value: TFhirDeviceDefinition);
begin
  assert(value is TFhirDeviceDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEDEFINITION}
{$IFDEF FHIR_DEVICEMETRIC}
{ TFhirDeviceMetricCalibration }

constructor TFhirDeviceMetricCalibration.Create;
begin
  inherited;
end;

destructor TFhirDeviceMetricCalibration.Destroy;
begin
  FType_.free;
  FState.free;
  FTime.free;
  inherited;
end;

procedure TFhirDeviceMetricCalibration.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirDeviceMetricCalibration(oSource).type_Element.Clone;
  stateElement := TFhirDeviceMetricCalibration(oSource).stateElement.Clone;
  timeElement := TFhirDeviceMetricCalibration(oSource).timeElement.Clone;
end;

procedure TFhirDeviceMetricCalibration.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'state') Then
     list.add(self.link, 'state', FState.Link);
  if (child_name = 'time') Then
     list.add(self.link, 'time', FTime.Link);
end;

procedure TFhirDeviceMetricCalibration.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'state', 'code', false, TFhirEnum, FState.Link));
  oList.add(TFHIRProperty.Create(self, 'time', 'instant', false, TFhirInstant, FTime.Link));
end;

function TFhirDeviceMetricCalibration.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum, CODES_TFhirDeviceMetricCalibrationTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'state') then
  begin
    StateElement := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum, CODES_TFhirDeviceMetricCalibrationStateEnum, propValue);
    result := propValue;
  end
  else if (propName = 'time') then
  begin
    TimeElement := asInstant(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceMetricCalibration.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirDeviceMetricCalibration.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum[DeviceMetricCalibrationTypeNull], CODES_TFhirDeviceMetricCalibrationTypeEnum[DeviceMetricCalibrationTypeNull]) 
  else if (propName = 'state') then result := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum[DeviceMetricCalibrationStateNull], CODES_TFhirDeviceMetricCalibrationStateEnum[DeviceMetricCalibrationStateNull]) 
  else if (propName = 'time') then result := TFhirInstant.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceMetricCalibration.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'state') then result := 'code'
  else if (propName = 'time') then result := 'instant'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceMetricCalibration.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'state') then StateElement := nil
  else if (propName = 'time') then TimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceMetricCalibration.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum, CODES_TFhirDeviceMetricCalibrationTypeEnum, new)
  else if (propName = 'state') then StateElement := asEnum(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum, CODES_TFhirDeviceMetricCalibrationStateEnum, new)
  else if (propName = 'time') then TimeElement := asInstant(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceMetricCalibration.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceMetricCalibration.fhirType : string;
begin
  result := 'DeviceMetric.calibration';
end;

function TFhirDeviceMetricCalibration.Link : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(inherited Link);
end;

function TFhirDeviceMetricCalibration.Clone : TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(inherited Clone);
end;

function TFhirDeviceMetricCalibration.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceMetricCalibration;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceMetricCalibration)) then
    result := false
  else
  begin
    o := TFhirDeviceMetricCalibration(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(stateElement, o.stateElement, true) and 
      compareDeep(timeElement, o.timeElement, true);
  end;
end;

function TFhirDeviceMetricCalibration.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FState) and isEmptyProp(FTime);
end;

procedure TFhirDeviceMetricCalibration.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('state');
  fields.add('time');
end;

function TFhirDeviceMetricCalibration.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirDeviceMetricCalibration.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirDeviceMetricCalibration.GetType_ST : TFhirDeviceMetricCalibrationTypeEnum;
begin
  if FType_ = nil then
    result := TFhirDeviceMetricCalibrationTypeEnum(0)
  else
    result := TFhirDeviceMetricCalibrationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricCalibrationTypeEnum, FType_.value));
end;

procedure TFhirDeviceMetricCalibration.SetType_ST(value : TFhirDeviceMetricCalibrationTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricCalibrationTypeEnum[value], CODES_TFhirDeviceMetricCalibrationTypeEnum[value]);
end;

procedure TFhirDeviceMetricCalibration.SetState(value : TFhirEnum);
begin
  FState.free;
  FState := value;
end;

function TFhirDeviceMetricCalibration.GetStateST : TFhirDeviceMetricCalibrationStateEnum;
begin
  if FState = nil then
    result := TFhirDeviceMetricCalibrationStateEnum(0)
  else
    result := TFhirDeviceMetricCalibrationStateEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricCalibrationStateEnum, FState.value));
end;

procedure TFhirDeviceMetricCalibration.SetStateST(value : TFhirDeviceMetricCalibrationStateEnum);
begin
  if ord(value) = 0 then
    StateElement := nil
  else
    StateElement := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricCalibrationStateEnum[value], CODES_TFhirDeviceMetricCalibrationStateEnum[value]);
end;

procedure TFhirDeviceMetricCalibration.SetTime(value : TFhirInstant);
begin
  FTime.free;
  FTime := value;
end;

function TFhirDeviceMetricCalibration.GetTimeST : TFslDateTime;
begin
  if FTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FTime.value;
end;

procedure TFhirDeviceMetricCalibration.SetTimeST(value : TFslDateTime);
begin
  if FTime = nil then
    FTime := TFhirInstant.Create;
  FTime.value := value
end;

{ TFhirDeviceMetricCalibrationListEnumerator }

constructor TFhirDeviceMetricCalibrationListEnumerator.Create(list : TFhirDeviceMetricCalibrationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceMetricCalibrationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceMetricCalibrationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceMetricCalibrationListEnumerator.GetCurrent : TFhirDeviceMetricCalibration;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceMetricCalibrationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceMetricCalibrationList }

function TFhirDeviceMetricCalibrationList.AddItem(value: TFhirDeviceMetricCalibration): TFhirDeviceMetricCalibration;
begin
  assert(value.ClassName = 'TFhirDeviceMetricCalibration', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceMetricCalibration');
  add(value);
  result := value;
end;

function TFhirDeviceMetricCalibrationList.Append: TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricCalibrationList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceMetricCalibrationList.GetEnumerator : TFhirDeviceMetricCalibrationListEnumerator;
begin
  result := TFhirDeviceMetricCalibrationListEnumerator.Create(self.link);
end;

function TFhirDeviceMetricCalibrationList.Clone: TFhirDeviceMetricCalibrationList;
begin
  result := TFhirDeviceMetricCalibrationList(inherited Clone);
end;

function TFhirDeviceMetricCalibrationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceMetricCalibrationList.GetItemN(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(ObjectByIndex[index]);
end;

function TFhirDeviceMetricCalibrationList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceMetricCalibration;
end;
function TFhirDeviceMetricCalibrationList.IndexOf(value: TFhirDeviceMetricCalibration): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceMetricCalibrationList.Insert(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricCalibrationList.InsertItem(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  Inherited Insert(index, value);
end;

function TFhirDeviceMetricCalibrationList.Item(index: Integer): TFhirDeviceMetricCalibration;
begin
  result := TFhirDeviceMetricCalibration(ObjectByIndex[index]);
end;

function TFhirDeviceMetricCalibrationList.Link: TFhirDeviceMetricCalibrationList;
begin
  result := TFhirDeviceMetricCalibrationList(inherited Link);
end;

procedure TFhirDeviceMetricCalibrationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceMetricCalibrationList.SetItemByIndex(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  FhirDeviceMetricCalibrations[index] := value;
end;

procedure TFhirDeviceMetricCalibrationList.SetItemN(index: Integer; value: TFhirDeviceMetricCalibration);
begin
  assert(value is TFhirDeviceMetricCalibration);
  ObjectByIndex[index] := value;
end;

{ TFhirDeviceMetric }

constructor TFhirDeviceMetric.Create;
begin
  inherited;
end;

destructor TFhirDeviceMetric.Destroy;
begin
  FIdentifierList.free;
  FType_.free;
  FUnit_.free;
  FSource.free;
  FParent.free;
  FOperationalStatus.free;
  FColor.free;
  FCategory.free;
  FMeasurementPeriod.free;
  FCalibrationList.free;
  inherited;
end;

procedure TFhirDeviceMetric.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirDeviceMetric(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirDeviceMetric(oSource).FIdentifierList);
  end;
  type_ := TFhirDeviceMetric(oSource).type_.Clone;
  unit_ := TFhirDeviceMetric(oSource).unit_.Clone;
  source := TFhirDeviceMetric(oSource).source.Clone;
  parent := TFhirDeviceMetric(oSource).parent.Clone;
  operationalStatusElement := TFhirDeviceMetric(oSource).operationalStatusElement.Clone;
  colorElement := TFhirDeviceMetric(oSource).colorElement.Clone;
  categoryElement := TFhirDeviceMetric(oSource).categoryElement.Clone;
  measurementPeriod := TFhirDeviceMetric(oSource).measurementPeriod.Clone;
  if (TFhirDeviceMetric(oSource).FCalibrationList = nil) then
  begin
    FCalibrationList.free;
    FCalibrationList := nil;
  end
  else
  begin
    if FCalibrationList = nil then
      FCalibrationList := TFhirDeviceMetricCalibrationList.Create;
    FCalibrationList.Assign(TFhirDeviceMetric(oSource).FCalibrationList);
  end;
end;

function TFhirDeviceMetric.GetResourceType : TFhirResourceType;
begin
  result := frtDeviceMetric;
end;

procedure TFhirDeviceMetric.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'unit') Then
     list.add(self.link, 'unit', FUnit_.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'parent') Then
     list.add(self.link, 'parent', FParent.Link);
  if (child_name = 'operationalStatus') Then
     list.add(self.link, 'operationalStatus', FOperationalStatus.Link);
  if (child_name = 'color') Then
     list.add(self.link, 'color', FColor.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'measurementPeriod') Then
     list.add(self.link, 'measurementPeriod', FMeasurementPeriod.Link);
  if (child_name = 'calibration') Then
    list.addAll(self, 'calibration', FCalibrationList);
end;

procedure TFhirDeviceMetric.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'unit', 'CodeableConcept', false, TFhirCodeableConcept, FUnit_.Link));
  oList.add(TFHIRProperty.Create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
  oList.add(TFHIRProperty.Create(self, 'parent', 'Reference', false, TFhirReference, FParent.Link));
  oList.add(TFHIRProperty.Create(self, 'operationalStatus', 'code', false, TFhirEnum, FOperationalStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'color', 'code', false, TFhirEnum, FColor.Link));
  oList.add(TFHIRProperty.Create(self, 'category', 'code', false, TFhirEnum, FCategory.Link));
  oList.add(TFHIRProperty.Create(self, 'measurementPeriod', 'Timing', false, TFhirTiming, FMeasurementPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'calibration', 'BackboneElement', true, TFhirDeviceMetricCalibration, FCalibrationList.Link));
end;

function TFhirDeviceMetric.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'unit') then
  begin
    Unit_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'parent') then
  begin
    Parent := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'operationalStatus') then
  begin
    OperationalStatusElement := asEnum(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum, CODES_TFhirDeviceMetricOperationalStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'color') then
  begin
    ColorElement := asEnum(SYSTEMS_TFhirDeviceMetricColorEnum, CODES_TFhirDeviceMetricColorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryElement := asEnum(SYSTEMS_TFhirDeviceMetricCategoryEnum, CODES_TFhirDeviceMetricCategoryEnum, propValue);
    result := propValue;
  end
  else if (propName = 'measurementPeriod') then
  begin
    MeasurementPeriod := propValue as TFhirTiming;
    result := propValue;
  end
  else if (propName = 'calibration') then
  begin
    CalibrationList.add(propValue as TFhirDeviceMetricCalibration);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirDeviceMetric.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'calibration') then CalibrationList.insertItem(index, propValue as TFhirDeviceMetricCalibration)
  else inherited;
end;

function TFhirDeviceMetric.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.Create()
  else if (propName = 'unit') then result := TFhirCodeableConcept.Create()
  else if (propName = 'source') then result := TFhirReference.Create()
  else if (propName = 'parent') then result := TFhirReference.Create()
  else if (propName = 'operationalStatus') then result := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum[DeviceMetricOperationalStatusNull], CODES_TFhirDeviceMetricOperationalStatusEnum[DeviceMetricOperationalStatusNull]) 
  else if (propName = 'color') then result := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricColorEnum[DeviceMetricColorNull], CODES_TFhirDeviceMetricColorEnum[DeviceMetricColorNull]) 
  else if (propName = 'category') then result := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricCategoryEnum[DeviceMetricCategoryNull], CODES_TFhirDeviceMetricCategoryEnum[DeviceMetricCategoryNull]) 
  else if (propName = 'measurementPeriod') then result := TFhirTiming.Create()
  else if (propName = 'calibration') then result := CalibrationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirDeviceMetric.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'unit') then result := 'CodeableConcept'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'parent') then result := 'Reference'
  else if (propName = 'operationalStatus') then result := 'code'
  else if (propName = 'color') then result := 'code'
  else if (propName = 'category') then result := 'code'
  else if (propName = 'measurementPeriod') then result := 'Timing'
  else if (propName = 'calibration') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirDeviceMetric.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'unit') then Unit_Element := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'parent') then ParentElement := nil
  else if (propName = 'operationalStatus') then OperationalStatusElement := nil
  else if (propName = 'color') then ColorElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'measurementPeriod') then MeasurementPeriodElement := nil
  else if (propName = 'calibration') then deletePropertyValue('calibration', CalibrationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirDeviceMetric.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'unit') then Unit_Element := new as TFhirCodeableConcept
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else if (propName = 'parent') then ParentElement := new as TFhirReference
  else if (propName = 'operationalStatus') then OperationalStatusElement := asEnum(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum, CODES_TFhirDeviceMetricOperationalStatusEnum, new)
  else if (propName = 'color') then ColorElement := asEnum(SYSTEMS_TFhirDeviceMetricColorEnum, CODES_TFhirDeviceMetricColorEnum, new)
  else if (propName = 'category') then CategoryElement := asEnum(SYSTEMS_TFhirDeviceMetricCategoryEnum, CODES_TFhirDeviceMetricCategoryEnum, new)
  else if (propName = 'measurementPeriod') then MeasurementPeriodElement := new as TFhirTiming
  else if (propName = 'calibration') then replacePropertyValue('calibration', CalibrationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirDeviceMetric.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'calibration') then CalibrationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirDeviceMetric.fhirType : string;
begin
  result := 'DeviceMetric';
end;

function TFhirDeviceMetric.Link : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(inherited Link);
end;

function TFhirDeviceMetric.Clone : TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(inherited Clone);
end;

function TFhirDeviceMetric.equals(other : TObject) : boolean; 
var
  o : TFhirDeviceMetric;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirDeviceMetric)) then
    result := false
  else
  begin
    o := TFhirDeviceMetric(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(unit_Element, o.unit_Element, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(parentElement, o.parentElement, true) and compareDeep(operationalStatusElement, o.operationalStatusElement, true) and 
      compareDeep(colorElement, o.colorElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(measurementPeriodElement, o.measurementPeriodElement, true) and compareDeep(calibrationList, o.calibrationList, true);
  end;
end;

function TFhirDeviceMetric.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FType_) and isEmptyProp(FUnit_) and isEmptyProp(FSource) and isEmptyProp(FParent) and isEmptyProp(FOperationalStatus) and isEmptyProp(FColor) and isEmptyProp(FCategory) and isEmptyProp(FMeasurementPeriod) and isEmptyProp(FcalibrationList);
end;

procedure TFhirDeviceMetric.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('unit');
  fields.add('source');
  fields.add('parent');
  fields.add('operationalStatus');
  fields.add('color');
  fields.add('category');
  fields.add('measurementPeriod');
  fields.add('calibration');
end;

function TFhirDeviceMetric.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCalibrationList.sizeInBytes(magic));
end;

function TFhirDeviceMetric.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirDeviceMetric.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirDeviceMetric.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirDeviceMetric.SetUnit_(value : TFhirCodeableConcept);
begin
  FUnit_.free;
  FUnit_ := value;
end;

procedure TFhirDeviceMetric.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirDeviceMetric.SetParent(value : TFhirReference);
begin
  FParent.free;
  FParent := value;
end;

procedure TFhirDeviceMetric.SetOperationalStatus(value : TFhirEnum);
begin
  FOperationalStatus.free;
  FOperationalStatus := value;
end;

function TFhirDeviceMetric.GetOperationalStatusST : TFhirDeviceMetricOperationalStatusEnum;
begin
  if FOperationalStatus = nil then
    result := TFhirDeviceMetricOperationalStatusEnum(0)
  else
    result := TFhirDeviceMetricOperationalStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricOperationalStatusEnum, FOperationalStatus.value));
end;

procedure TFhirDeviceMetric.SetOperationalStatusST(value : TFhirDeviceMetricOperationalStatusEnum);
begin
  if ord(value) = 0 then
    OperationalStatusElement := nil
  else
    OperationalStatusElement := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricOperationalStatusEnum[value], CODES_TFhirDeviceMetricOperationalStatusEnum[value]);
end;

procedure TFhirDeviceMetric.SetColor(value : TFhirEnum);
begin
  FColor.free;
  FColor := value;
end;

function TFhirDeviceMetric.GetColorST : TFhirDeviceMetricColorEnum;
begin
  if FColor = nil then
    result := TFhirDeviceMetricColorEnum(0)
  else
    result := TFhirDeviceMetricColorEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricColorEnum, FColor.value));
end;

procedure TFhirDeviceMetric.SetColorST(value : TFhirDeviceMetricColorEnum);
begin
  if ord(value) = 0 then
    ColorElement := nil
  else
    ColorElement := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricColorEnum[value], CODES_TFhirDeviceMetricColorEnum[value]);
end;

procedure TFhirDeviceMetric.SetCategory(value : TFhirEnum);
begin
  FCategory.free;
  FCategory := value;
end;

function TFhirDeviceMetric.GetCategoryST : TFhirDeviceMetricCategoryEnum;
begin
  if FCategory = nil then
    result := TFhirDeviceMetricCategoryEnum(0)
  else
    result := TFhirDeviceMetricCategoryEnum(StringArrayIndexOfSensitive(CODES_TFhirDeviceMetricCategoryEnum, FCategory.value));
end;

procedure TFhirDeviceMetric.SetCategoryST(value : TFhirDeviceMetricCategoryEnum);
begin
  if ord(value) = 0 then
    CategoryElement := nil
  else
    CategoryElement := TFhirEnum.Create(SYSTEMS_TFhirDeviceMetricCategoryEnum[value], CODES_TFhirDeviceMetricCategoryEnum[value]);
end;

procedure TFhirDeviceMetric.SetMeasurementPeriod(value : TFhirTiming);
begin
  FMeasurementPeriod.free;
  FMeasurementPeriod := value;
end;

function TFhirDeviceMetric.GetCalibrationList : TFhirDeviceMetricCalibrationList;
begin
  if FCalibrationList = nil then
    FCalibrationList := TFhirDeviceMetricCalibrationList.Create;
  result := FCalibrationList;
end;

function TFhirDeviceMetric.GetHasCalibrationList : boolean;
begin
  result := (FCalibrationList <> nil) and (FCalibrationList.count > 0);
end;

{ TFhirDeviceMetricListEnumerator }

constructor TFhirDeviceMetricListEnumerator.Create(list : TFhirDeviceMetricList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirDeviceMetricListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirDeviceMetricListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirDeviceMetricListEnumerator.GetCurrent : TFhirDeviceMetric;
begin
  Result := FList[FIndex];
end;

function TFhirDeviceMetricListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirDeviceMetricList }

function TFhirDeviceMetricList.AddItem(value: TFhirDeviceMetric): TFhirDeviceMetric;
begin
  assert(value.ClassName = 'TFhirDeviceMetric', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirDeviceMetric');
  add(value);
  result := value;
end;

function TFhirDeviceMetricList.Append: TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricList.ClearItems;
begin
  Clear;
end;

function TFhirDeviceMetricList.GetEnumerator : TFhirDeviceMetricListEnumerator;
begin
  result := TFhirDeviceMetricListEnumerator.Create(self.link);
end;

function TFhirDeviceMetricList.Clone: TFhirDeviceMetricList;
begin
  result := TFhirDeviceMetricList(inherited Clone);
end;

function TFhirDeviceMetricList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirDeviceMetricList.GetItemN(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(ObjectByIndex[index]);
end;

function TFhirDeviceMetricList.ItemClass: TFslObjectClass;
begin
  result := TFhirDeviceMetric;
end;
function TFhirDeviceMetricList.IndexOf(value: TFhirDeviceMetric): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirDeviceMetricList.Insert(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirDeviceMetricList.InsertItem(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  Inherited Insert(index, value);
end;

function TFhirDeviceMetricList.Item(index: Integer): TFhirDeviceMetric;
begin
  result := TFhirDeviceMetric(ObjectByIndex[index]);
end;

function TFhirDeviceMetricList.Link: TFhirDeviceMetricList;
begin
  result := TFhirDeviceMetricList(inherited Link);
end;

procedure TFhirDeviceMetricList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirDeviceMetricList.SetItemByIndex(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  FhirDeviceMetrics[index] := value;
end;

procedure TFhirDeviceMetricList.SetItemN(index: Integer; value: TFhirDeviceMetric);
begin
  assert(value is TFhirDeviceMetric);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_DEVICEMETRIC}
{$IFDEF FHIR_ENCOUNTER}
{ TFhirEncounterStatusHistory }

constructor TFhirEncounterStatusHistory.Create;
begin
  inherited;
end;

destructor TFhirEncounterStatusHistory.Destroy;
begin
  FStatus.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterStatusHistory.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirEncounterStatusHistory(oSource).statusElement.Clone;
  period := TFhirEncounterStatusHistory(oSource).period.Clone;
end;

procedure TFhirEncounterStatusHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterStatusHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirEncounterStatusHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterStatusHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterStatusHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.Create(SYSTEMS_TFhirEncounterStatusEnum[EncounterStatusNull], CODES_TFhirEncounterStatusEnum[EncounterStatusNull]) 
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterStatusHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterStatusHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterStatusHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterStatusHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterStatusHistory.fhirType : string;
begin
  result := 'Encounter.statusHistory';
end;

function TFhirEncounterStatusHistory.Link : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(inherited Link);
end;

function TFhirEncounterStatusHistory.Clone : TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(inherited Clone);
end;

function TFhirEncounterStatusHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterStatusHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterStatusHistory)) then
    result := false
  else
  begin
    o := TFhirEncounterStatusHistory(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterStatusHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterStatusHistory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('period');
end;

function TFhirEncounterStatusHistory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEncounterStatusHistory.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEncounterStatusHistory.GetStatusST : TFhirEncounterStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterStatusEnum(0)
  else
    result := TFhirEncounterStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterStatusEnum, FStatus.value));
end;

procedure TFhirEncounterStatusHistory.SetStatusST(value : TFhirEncounterStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEncounterStatusEnum[value], CODES_TFhirEncounterStatusEnum[value]);
end;

procedure TFhirEncounterStatusHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirEncounterStatusHistoryListEnumerator }

constructor TFhirEncounterStatusHistoryListEnumerator.Create(list : TFhirEncounterStatusHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterStatusHistoryListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterStatusHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterStatusHistoryListEnumerator.GetCurrent : TFhirEncounterStatusHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterStatusHistoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterStatusHistoryList }

function TFhirEncounterStatusHistoryList.AddItem(value: TFhirEncounterStatusHistory): TFhirEncounterStatusHistory;
begin
  assert(value.ClassName = 'TFhirEncounterStatusHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterStatusHistory');
  add(value);
  result := value;
end;

function TFhirEncounterStatusHistoryList.Append: TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterStatusHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterStatusHistoryList.GetEnumerator : TFhirEncounterStatusHistoryListEnumerator;
begin
  result := TFhirEncounterStatusHistoryListEnumerator.Create(self.link);
end;

function TFhirEncounterStatusHistoryList.Clone: TFhirEncounterStatusHistoryList;
begin
  result := TFhirEncounterStatusHistoryList(inherited Clone);
end;

function TFhirEncounterStatusHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterStatusHistoryList.GetItemN(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(ObjectByIndex[index]);
end;

function TFhirEncounterStatusHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterStatusHistory;
end;
function TFhirEncounterStatusHistoryList.IndexOf(value: TFhirEncounterStatusHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterStatusHistoryList.Insert(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterStatusHistoryList.InsertItem(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  Inherited Insert(index, value);
end;

function TFhirEncounterStatusHistoryList.Item(index: Integer): TFhirEncounterStatusHistory;
begin
  result := TFhirEncounterStatusHistory(ObjectByIndex[index]);
end;

function TFhirEncounterStatusHistoryList.Link: TFhirEncounterStatusHistoryList;
begin
  result := TFhirEncounterStatusHistoryList(inherited Link);
end;

procedure TFhirEncounterStatusHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterStatusHistoryList.SetItemByIndex(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  FhirEncounterStatusHistories[index] := value;
end;

procedure TFhirEncounterStatusHistoryList.SetItemN(index: Integer; value: TFhirEncounterStatusHistory);
begin
  assert(value is TFhirEncounterStatusHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterClassHistory }

constructor TFhirEncounterClassHistory.Create;
begin
  inherited;
end;

destructor TFhirEncounterClassHistory.Destroy;
begin
  FClass_.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterClassHistory.Assign(oSource : TFslObject);
begin
  inherited;
  class_ := TFhirEncounterClassHistory(oSource).class_.Clone;
  period := TFhirEncounterClassHistory(oSource).period.Clone;
end;

procedure TFhirEncounterClassHistory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterClassHistory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'class', 'Coding', false, TFhirCoding, FClass_.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirEncounterClassHistory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterClassHistory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterClassHistory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'class') then result := TFhirCoding.Create()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterClassHistory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'class') then result := 'Coding'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterClassHistory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterClassHistory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'class') then Class_Element := new as TFhirCoding
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterClassHistory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterClassHistory.fhirType : string;
begin
  result := 'Encounter.classHistory';
end;

function TFhirEncounterClassHistory.Link : TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(inherited Link);
end;

function TFhirEncounterClassHistory.Clone : TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(inherited Clone);
end;

function TFhirEncounterClassHistory.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterClassHistory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterClassHistory)) then
    result := false
  else
  begin
    o := TFhirEncounterClassHistory(other);
    result := compareDeep(class_Element, o.class_Element, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterClassHistory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FClass_) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterClassHistory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('class');
  fields.add('period');
end;

function TFhirEncounterClassHistory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEncounterClassHistory.SetClass_(value : TFhirCoding);
begin
  FClass_.free;
  FClass_ := value;
end;

procedure TFhirEncounterClassHistory.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirEncounterClassHistoryListEnumerator }

constructor TFhirEncounterClassHistoryListEnumerator.Create(list : TFhirEncounterClassHistoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterClassHistoryListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterClassHistoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterClassHistoryListEnumerator.GetCurrent : TFhirEncounterClassHistory;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterClassHistoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterClassHistoryList }

function TFhirEncounterClassHistoryList.AddItem(value: TFhirEncounterClassHistory): TFhirEncounterClassHistory;
begin
  assert(value.ClassName = 'TFhirEncounterClassHistory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterClassHistory');
  add(value);
  result := value;
end;

function TFhirEncounterClassHistoryList.Append: TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterClassHistoryList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterClassHistoryList.GetEnumerator : TFhirEncounterClassHistoryListEnumerator;
begin
  result := TFhirEncounterClassHistoryListEnumerator.Create(self.link);
end;

function TFhirEncounterClassHistoryList.Clone: TFhirEncounterClassHistoryList;
begin
  result := TFhirEncounterClassHistoryList(inherited Clone);
end;

function TFhirEncounterClassHistoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterClassHistoryList.GetItemN(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(ObjectByIndex[index]);
end;

function TFhirEncounterClassHistoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterClassHistory;
end;
function TFhirEncounterClassHistoryList.IndexOf(value: TFhirEncounterClassHistory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterClassHistoryList.Insert(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterClassHistoryList.InsertItem(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  Inherited Insert(index, value);
end;

function TFhirEncounterClassHistoryList.Item(index: Integer): TFhirEncounterClassHistory;
begin
  result := TFhirEncounterClassHistory(ObjectByIndex[index]);
end;

function TFhirEncounterClassHistoryList.Link: TFhirEncounterClassHistoryList;
begin
  result := TFhirEncounterClassHistoryList(inherited Link);
end;

procedure TFhirEncounterClassHistoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterClassHistoryList.SetItemByIndex(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  FhirEncounterClassHistories[index] := value;
end;

procedure TFhirEncounterClassHistoryList.SetItemN(index: Integer; value: TFhirEncounterClassHistory);
begin
  assert(value is TFhirEncounterClassHistory);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterParticipant }

constructor TFhirEncounterParticipant.Create;
begin
  inherited;
end;

destructor TFhirEncounterParticipant.Destroy;
begin
  FType_List.free;
  FPeriod.free;
  FIndividual.free;
  inherited;
end;

procedure TFhirEncounterParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEncounterParticipant(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEncounterParticipant(oSource).FType_List);
  end;
  period := TFhirEncounterParticipant(oSource).period.Clone;
  individual := TFhirEncounterParticipant(oSource).individual.Clone;
end;

procedure TFhirEncounterParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'individual') Then
     list.add(self.link, 'individual', FIndividual.Link);
end;

procedure TFhirEncounterParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'individual', 'Reference', false, TFhirReference, FIndividual.Link));
end;

function TFhirEncounterParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'individual') then
  begin
    Individual := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirEncounterParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := Type_List.new()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else if (propName = 'individual') then result := TFhirReference.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'individual') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'individual') then IndividualElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'individual') then IndividualElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterParticipant.fhirType : string;
begin
  result := 'Encounter.participant';
end;

function TFhirEncounterParticipant.Link : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Link);
end;

function TFhirEncounterParticipant.Clone : TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(inherited Clone);
end;

function TFhirEncounterParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterParticipant)) then
    result := false
  else
  begin
    o := TFhirEncounterParticipant(other);
    result := compareDeep(type_List, o.type_List, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(individualElement, o.individualElement, true);
  end;
end;

function TFhirEncounterParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Ftype_List) and isEmptyProp(FPeriod) and isEmptyProp(FIndividual);
end;

procedure TFhirEncounterParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
  fields.add('individual');
end;

function TFhirEncounterParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
end;

function TFhirEncounterParticipant.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirEncounterParticipant.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirEncounterParticipant.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirEncounterParticipant.SetIndividual(value : TFhirReference);
begin
  FIndividual.free;
  FIndividual := value;
end;

{ TFhirEncounterParticipantListEnumerator }

constructor TFhirEncounterParticipantListEnumerator.Create(list : TFhirEncounterParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterParticipantListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterParticipantListEnumerator.GetCurrent : TFhirEncounterParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterParticipantList }

function TFhirEncounterParticipantList.AddItem(value: TFhirEncounterParticipant): TFhirEncounterParticipant;
begin
  assert(value.ClassName = 'TFhirEncounterParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterParticipant');
  add(value);
  result := value;
end;

function TFhirEncounterParticipantList.Append: TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterParticipantList.GetEnumerator : TFhirEncounterParticipantListEnumerator;
begin
  result := TFhirEncounterParticipantListEnumerator.Create(self.link);
end;

function TFhirEncounterParticipantList.Clone: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Clone);
end;

function TFhirEncounterParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterParticipantList.GetItemN(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterParticipant;
end;
function TFhirEncounterParticipantList.IndexOf(value: TFhirEncounterParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterParticipantList.Insert(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterParticipantList.InsertItem(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  Inherited Insert(index, value);
end;

function TFhirEncounterParticipantList.Item(index: Integer): TFhirEncounterParticipant;
begin
  result := TFhirEncounterParticipant(ObjectByIndex[index]);
end;

function TFhirEncounterParticipantList.Link: TFhirEncounterParticipantList;
begin
  result := TFhirEncounterParticipantList(inherited Link);
end;

procedure TFhirEncounterParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterParticipantList.SetItemByIndex(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  FhirEncounterParticipants[index] := value;
end;

procedure TFhirEncounterParticipantList.SetItemN(index: Integer; value: TFhirEncounterParticipant);
begin
  assert(value is TFhirEncounterParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterDiagnosis }

constructor TFhirEncounterDiagnosis.Create;
begin
  inherited;
end;

destructor TFhirEncounterDiagnosis.Destroy;
begin
  FCondition.free;
  FUse.free;
  FRank.free;
  inherited;
end;

procedure TFhirEncounterDiagnosis.Assign(oSource : TFslObject);
begin
  inherited;
  condition := TFhirEncounterDiagnosis(oSource).condition.Clone;
  use := TFhirEncounterDiagnosis(oSource).use.Clone;
  rankElement := TFhirEncounterDiagnosis(oSource).rankElement.Clone;
end;

procedure TFhirEncounterDiagnosis.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'use') Then
     list.add(self.link, 'use', FUse.Link);
  if (child_name = 'rank') Then
     list.add(self.link, 'rank', FRank.Link);
end;

procedure TFhirEncounterDiagnosis.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'condition', 'Reference', false, TFhirReference, FCondition.Link));
  oList.add(TFHIRProperty.Create(self, 'use', 'CodeableConcept', false, TFhirCodeableConcept, FUse.Link));
  oList.add(TFHIRProperty.Create(self, 'rank', 'positiveInt', false, TFhirPositiveInt, FRank.Link));
end;

function TFhirEncounterDiagnosis.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'condition') then
  begin
    Condition := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'use') then
  begin
    Use := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'rank') then
  begin
    RankElement := asPositiveInt(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterDiagnosis.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterDiagnosis.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'condition') then result := TFhirReference.Create()
  else if (propName = 'use') then result := TFhirCodeableConcept.Create()
  else if (propName = 'rank') then result := TFhirPositiveInt.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterDiagnosis.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'condition') then result := 'Reference'
  else if (propName = 'use') then result := 'CodeableConcept'
  else if (propName = 'rank') then result := 'positiveInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterDiagnosis.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'use') then UseElement := nil
  else if (propName = 'rank') then RankElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterDiagnosis.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'condition') then ConditionElement := new as TFhirReference
  else if (propName = 'use') then UseElement := new as TFhirCodeableConcept
  else if (propName = 'rank') then RankElement := asPositiveInt(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterDiagnosis.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterDiagnosis.fhirType : string;
begin
  result := 'Encounter.diagnosis';
end;

function TFhirEncounterDiagnosis.Link : TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(inherited Link);
end;

function TFhirEncounterDiagnosis.Clone : TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(inherited Clone);
end;

function TFhirEncounterDiagnosis.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterDiagnosis;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterDiagnosis)) then
    result := false
  else
  begin
    o := TFhirEncounterDiagnosis(other);
    result := compareDeep(conditionElement, o.conditionElement, true) and compareDeep(useElement, o.useElement, true) and 
      compareDeep(rankElement, o.rankElement, true);
  end;
end;

function TFhirEncounterDiagnosis.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCondition) and isEmptyProp(FUse) and isEmptyProp(FRank);
end;

procedure TFhirEncounterDiagnosis.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('condition');
  fields.add('use');
  fields.add('rank');
end;

function TFhirEncounterDiagnosis.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEncounterDiagnosis.SetCondition(value : TFhirReference);
begin
  FCondition.free;
  FCondition := value;
end;

procedure TFhirEncounterDiagnosis.SetUse(value : TFhirCodeableConcept);
begin
  FUse.free;
  FUse := value;
end;

procedure TFhirEncounterDiagnosis.SetRank(value : TFhirPositiveInt);
begin
  FRank.free;
  FRank := value;
end;

function TFhirEncounterDiagnosis.GetRankST : String;
begin
  if FRank = nil then
    result := ''
  else
    result := FRank.value;
end;

procedure TFhirEncounterDiagnosis.SetRankST(value : String);
begin
  if value <> '' then
  begin
    if FRank = nil then
      FRank := TFhirPositiveInt.Create;
    FRank.value := value
  end
  else if FRank <> nil then
    FRank.value := '';
end;

{ TFhirEncounterDiagnosisListEnumerator }

constructor TFhirEncounterDiagnosisListEnumerator.Create(list : TFhirEncounterDiagnosisList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterDiagnosisListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterDiagnosisListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterDiagnosisListEnumerator.GetCurrent : TFhirEncounterDiagnosis;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterDiagnosisListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterDiagnosisList }

function TFhirEncounterDiagnosisList.AddItem(value: TFhirEncounterDiagnosis): TFhirEncounterDiagnosis;
begin
  assert(value.ClassName = 'TFhirEncounterDiagnosis', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterDiagnosis');
  add(value);
  result := value;
end;

function TFhirEncounterDiagnosisList.Append: TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterDiagnosisList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterDiagnosisList.GetEnumerator : TFhirEncounterDiagnosisListEnumerator;
begin
  result := TFhirEncounterDiagnosisListEnumerator.Create(self.link);
end;

function TFhirEncounterDiagnosisList.Clone: TFhirEncounterDiagnosisList;
begin
  result := TFhirEncounterDiagnosisList(inherited Clone);
end;

function TFhirEncounterDiagnosisList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterDiagnosisList.GetItemN(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(ObjectByIndex[index]);
end;

function TFhirEncounterDiagnosisList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterDiagnosis;
end;
function TFhirEncounterDiagnosisList.IndexOf(value: TFhirEncounterDiagnosis): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterDiagnosisList.Insert(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterDiagnosisList.InsertItem(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  Inherited Insert(index, value);
end;

function TFhirEncounterDiagnosisList.Item(index: Integer): TFhirEncounterDiagnosis;
begin
  result := TFhirEncounterDiagnosis(ObjectByIndex[index]);
end;

function TFhirEncounterDiagnosisList.Link: TFhirEncounterDiagnosisList;
begin
  result := TFhirEncounterDiagnosisList(inherited Link);
end;

procedure TFhirEncounterDiagnosisList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterDiagnosisList.SetItemByIndex(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  FhirEncounterDiagnoses[index] := value;
end;

procedure TFhirEncounterDiagnosisList.SetItemN(index: Integer; value: TFhirEncounterDiagnosis);
begin
  assert(value is TFhirEncounterDiagnosis);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterHospitalization }

constructor TFhirEncounterHospitalization.Create;
begin
  inherited;
end;

destructor TFhirEncounterHospitalization.Destroy;
begin
  FPreAdmissionIdentifier.free;
  FOrigin.free;
  FAdmitSource.free;
  FReAdmission.free;
  FDietPreferenceList.free;
  FSpecialCourtesyList.free;
  FSpecialArrangementList.free;
  FDestination.free;
  FDischargeDisposition.free;
  inherited;
end;

procedure TFhirEncounterHospitalization.Assign(oSource : TFslObject);
begin
  inherited;
  preAdmissionIdentifier := TFhirEncounterHospitalization(oSource).preAdmissionIdentifier.Clone;
  origin := TFhirEncounterHospitalization(oSource).origin.Clone;
  admitSource := TFhirEncounterHospitalization(oSource).admitSource.Clone;
  reAdmission := TFhirEncounterHospitalization(oSource).reAdmission.Clone;
  if (TFhirEncounterHospitalization(oSource).FDietPreferenceList = nil) then
  begin
    FDietPreferenceList.free;
    FDietPreferenceList := nil;
  end
  else
  begin
    if FDietPreferenceList = nil then
      FDietPreferenceList := TFhirCodeableConceptList.Create;
    FDietPreferenceList.Assign(TFhirEncounterHospitalization(oSource).FDietPreferenceList);
  end;
  if (TFhirEncounterHospitalization(oSource).FSpecialCourtesyList = nil) then
  begin
    FSpecialCourtesyList.free;
    FSpecialCourtesyList := nil;
  end
  else
  begin
    if FSpecialCourtesyList = nil then
      FSpecialCourtesyList := TFhirCodeableConceptList.Create;
    FSpecialCourtesyList.Assign(TFhirEncounterHospitalization(oSource).FSpecialCourtesyList);
  end;
  if (TFhirEncounterHospitalization(oSource).FSpecialArrangementList = nil) then
  begin
    FSpecialArrangementList.free;
    FSpecialArrangementList := nil;
  end
  else
  begin
    if FSpecialArrangementList = nil then
      FSpecialArrangementList := TFhirCodeableConceptList.Create;
    FSpecialArrangementList.Assign(TFhirEncounterHospitalization(oSource).FSpecialArrangementList);
  end;
  destination := TFhirEncounterHospitalization(oSource).destination.Clone;
  dischargeDisposition := TFhirEncounterHospitalization(oSource).dischargeDisposition.Clone;
end;

procedure TFhirEncounterHospitalization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'preAdmissionIdentifier') Then
     list.add(self.link, 'preAdmissionIdentifier', FPreAdmissionIdentifier.Link);
  if (child_name = 'origin') Then
     list.add(self.link, 'origin', FOrigin.Link);
  if (child_name = 'admitSource') Then
     list.add(self.link, 'admitSource', FAdmitSource.Link);
  if (child_name = 'reAdmission') Then
     list.add(self.link, 'reAdmission', FReAdmission.Link);
  if (child_name = 'dietPreference') Then
    list.addAll(self, 'dietPreference', FDietPreferenceList);
  if (child_name = 'specialCourtesy') Then
    list.addAll(self, 'specialCourtesy', FSpecialCourtesyList);
  if (child_name = 'specialArrangement') Then
    list.addAll(self, 'specialArrangement', FSpecialArrangementList);
  if (child_name = 'destination') Then
     list.add(self.link, 'destination', FDestination.Link);
  if (child_name = 'dischargeDisposition') Then
     list.add(self.link, 'dischargeDisposition', FDischargeDisposition.Link);
end;

procedure TFhirEncounterHospitalization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'preAdmissionIdentifier', 'Identifier', false, TFhirIdentifier, FPreAdmissionIdentifier.Link));
  oList.add(TFHIRProperty.Create(self, 'origin', 'Reference', false, TFhirReference, FOrigin.Link));
  oList.add(TFHIRProperty.Create(self, 'admitSource', 'CodeableConcept', false, TFhirCodeableConcept, FAdmitSource.Link));
  oList.add(TFHIRProperty.Create(self, 'reAdmission', 'CodeableConcept', false, TFhirCodeableConcept, FReAdmission.Link));
  oList.add(TFHIRProperty.Create(self, 'dietPreference', 'CodeableConcept', true, TFhirCodeableConcept, FDietPreferenceList.Link));
  oList.add(TFHIRProperty.Create(self, 'specialCourtesy', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialCourtesyList.Link));
  oList.add(TFHIRProperty.Create(self, 'specialArrangement', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialArrangementList.Link));
  oList.add(TFHIRProperty.Create(self, 'destination', 'Reference', false, TFhirReference, FDestination.Link));
  oList.add(TFHIRProperty.Create(self, 'dischargeDisposition', 'CodeableConcept', false, TFhirCodeableConcept, FDischargeDisposition.Link));
end;

function TFhirEncounterHospitalization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'preAdmissionIdentifier') then
  begin
    PreAdmissionIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'origin') then
  begin
    Origin := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'admitSource') then
  begin
    AdmitSource := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reAdmission') then
  begin
    ReAdmission := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'dietPreference') then
  begin
    DietPreferenceList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialCourtesy') then
  begin
    SpecialCourtesyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialArrangement') then
  begin
    SpecialArrangementList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    Destination := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'dischargeDisposition') then
  begin
    DischargeDisposition := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterHospitalization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'dietPreference') then DietPreferenceList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialCourtesy') then SpecialCourtesyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialArrangement') then SpecialArrangementList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirEncounterHospitalization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'preAdmissionIdentifier') then result := TFhirIdentifier.Create()
  else if (propName = 'origin') then result := TFhirReference.Create()
  else if (propName = 'admitSource') then result := TFhirCodeableConcept.Create()
  else if (propName = 'reAdmission') then result := TFhirCodeableConcept.Create()
  else if (propName = 'dietPreference') then result := DietPreferenceList.new()
  else if (propName = 'specialCourtesy') then result := SpecialCourtesyList.new()
  else if (propName = 'specialArrangement') then result := SpecialArrangementList.new()
  else if (propName = 'destination') then result := TFhirReference.Create()
  else if (propName = 'dischargeDisposition') then result := TFhirCodeableConcept.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterHospitalization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'preAdmissionIdentifier') then result := 'Identifier'
  else if (propName = 'origin') then result := 'Reference'
  else if (propName = 'admitSource') then result := 'CodeableConcept'
  else if (propName = 'reAdmission') then result := 'CodeableConcept'
  else if (propName = 'dietPreference') then result := 'CodeableConcept'
  else if (propName = 'specialCourtesy') then result := 'CodeableConcept'
  else if (propName = 'specialArrangement') then result := 'CodeableConcept'
  else if (propName = 'destination') then result := 'Reference'
  else if (propName = 'dischargeDisposition') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterHospitalization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'preAdmissionIdentifier') then PreAdmissionIdentifierElement := nil
  else if (propName = 'origin') then OriginElement := nil
  else if (propName = 'admitSource') then AdmitSourceElement := nil
  else if (propName = 'reAdmission') then ReAdmissionElement := nil
  else if (propName = 'dietPreference') then deletePropertyValue('dietPreference', DietPreferenceList, value)
  else if (propName = 'specialCourtesy') then deletePropertyValue('specialCourtesy', SpecialCourtesyList, value)
  else if (propName = 'specialArrangement') then deletePropertyValue('specialArrangement', SpecialArrangementList, value)
  else if (propName = 'destination') then DestinationElement := nil
  else if (propName = 'dischargeDisposition') then DischargeDispositionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterHospitalization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'preAdmissionIdentifier') then PreAdmissionIdentifierElement := new as TFhirIdentifier
  else if (propName = 'origin') then OriginElement := new as TFhirReference
  else if (propName = 'admitSource') then AdmitSourceElement := new as TFhirCodeableConcept
  else if (propName = 'reAdmission') then ReAdmissionElement := new as TFhirCodeableConcept
  else if (propName = 'dietPreference') then replacePropertyValue('dietPreference', DietPreferenceList, existing, new)
  else if (propName = 'specialCourtesy') then replacePropertyValue('specialCourtesy', SpecialCourtesyList, existing, new)
  else if (propName = 'specialArrangement') then replacePropertyValue('specialArrangement', SpecialArrangementList, existing, new)
  else if (propName = 'destination') then DestinationElement := new as TFhirReference
  else if (propName = 'dischargeDisposition') then DischargeDispositionElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterHospitalization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'dietPreference') then DietPreferenceList.move(source, destination)
  else if (propName = 'specialCourtesy') then SpecialCourtesyList.move(source, destination)
  else if (propName = 'specialArrangement') then SpecialArrangementList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterHospitalization.fhirType : string;
begin
  result := 'Encounter.hospitalization';
end;

function TFhirEncounterHospitalization.Link : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Link);
end;

function TFhirEncounterHospitalization.Clone : TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(inherited Clone);
end;

function TFhirEncounterHospitalization.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterHospitalization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterHospitalization)) then
    result := false
  else
  begin
    o := TFhirEncounterHospitalization(other);
    result := compareDeep(preAdmissionIdentifierElement, o.preAdmissionIdentifierElement, true) and 
      compareDeep(originElement, o.originElement, true) and compareDeep(admitSourceElement, o.admitSourceElement, true) and 
      compareDeep(reAdmissionElement, o.reAdmissionElement, true) and compareDeep(dietPreferenceList, o.dietPreferenceList, true) and 
      compareDeep(specialCourtesyList, o.specialCourtesyList, true) and compareDeep(specialArrangementList, o.specialArrangementList, true) and 
      compareDeep(destinationElement, o.destinationElement, true) and compareDeep(dischargeDispositionElement, o.dischargeDispositionElement, true);
  end;
end;

function TFhirEncounterHospitalization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPreAdmissionIdentifier) and isEmptyProp(FOrigin) and isEmptyProp(FAdmitSource) and isEmptyProp(FReAdmission) and isEmptyProp(FdietPreferenceList) and isEmptyProp(FspecialCourtesyList) and isEmptyProp(FspecialArrangementList) and isEmptyProp(FDestination) and isEmptyProp(FDischargeDisposition);
end;

procedure TFhirEncounterHospitalization.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('preAdmissionIdentifier');
  fields.add('origin');
  fields.add('admitSource');
  fields.add('reAdmission');
  fields.add('dietPreference');
  fields.add('specialCourtesy');
  fields.add('specialArrangement');
  fields.add('destination');
  fields.add('dischargeDisposition');
end;

function TFhirEncounterHospitalization.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDietPreferenceList.sizeInBytes(magic));
  inc(result, FSpecialCourtesyList.sizeInBytes(magic));
  inc(result, FSpecialArrangementList.sizeInBytes(magic));
end;

procedure TFhirEncounterHospitalization.SetPreAdmissionIdentifier(value : TFhirIdentifier);
begin
  FPreAdmissionIdentifier.free;
  FPreAdmissionIdentifier := value;
end;

procedure TFhirEncounterHospitalization.SetOrigin(value : TFhirReference);
begin
  FOrigin.free;
  FOrigin := value;
end;

procedure TFhirEncounterHospitalization.SetAdmitSource(value : TFhirCodeableConcept);
begin
  FAdmitSource.free;
  FAdmitSource := value;
end;

procedure TFhirEncounterHospitalization.SetReAdmission(value : TFhirCodeableConcept);
begin
  FReAdmission.free;
  FReAdmission := value;
end;

function TFhirEncounterHospitalization.GetDietPreferenceList : TFhirCodeableConceptList;
begin
  if FDietPreferenceList = nil then
    FDietPreferenceList := TFhirCodeableConceptList.Create;
  result := FDietPreferenceList;
end;

function TFhirEncounterHospitalization.GetHasDietPreferenceList : boolean;
begin
  result := (FDietPreferenceList <> nil) and (FDietPreferenceList.count > 0);
end;

function TFhirEncounterHospitalization.GetSpecialCourtesyList : TFhirCodeableConceptList;
begin
  if FSpecialCourtesyList = nil then
    FSpecialCourtesyList := TFhirCodeableConceptList.Create;
  result := FSpecialCourtesyList;
end;

function TFhirEncounterHospitalization.GetHasSpecialCourtesyList : boolean;
begin
  result := (FSpecialCourtesyList <> nil) and (FSpecialCourtesyList.count > 0);
end;

function TFhirEncounterHospitalization.GetSpecialArrangementList : TFhirCodeableConceptList;
begin
  if FSpecialArrangementList = nil then
    FSpecialArrangementList := TFhirCodeableConceptList.Create;
  result := FSpecialArrangementList;
end;

function TFhirEncounterHospitalization.GetHasSpecialArrangementList : boolean;
begin
  result := (FSpecialArrangementList <> nil) and (FSpecialArrangementList.count > 0);
end;

procedure TFhirEncounterHospitalization.SetDestination(value : TFhirReference);
begin
  FDestination.free;
  FDestination := value;
end;

procedure TFhirEncounterHospitalization.SetDischargeDisposition(value : TFhirCodeableConcept);
begin
  FDischargeDisposition.free;
  FDischargeDisposition := value;
end;

{ TFhirEncounterHospitalizationListEnumerator }

constructor TFhirEncounterHospitalizationListEnumerator.Create(list : TFhirEncounterHospitalizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterHospitalizationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterHospitalizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterHospitalizationListEnumerator.GetCurrent : TFhirEncounterHospitalization;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterHospitalizationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterHospitalizationList }

function TFhirEncounterHospitalizationList.AddItem(value: TFhirEncounterHospitalization): TFhirEncounterHospitalization;
begin
  assert(value.ClassName = 'TFhirEncounterHospitalization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterHospitalization');
  add(value);
  result := value;
end;

function TFhirEncounterHospitalizationList.Append: TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterHospitalizationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterHospitalizationList.GetEnumerator : TFhirEncounterHospitalizationListEnumerator;
begin
  result := TFhirEncounterHospitalizationListEnumerator.Create(self.link);
end;

function TFhirEncounterHospitalizationList.Clone: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Clone);
end;

function TFhirEncounterHospitalizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterHospitalizationList.GetItemN(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterHospitalization;
end;
function TFhirEncounterHospitalizationList.IndexOf(value: TFhirEncounterHospitalization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterHospitalizationList.Insert(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterHospitalizationList.InsertItem(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  Inherited Insert(index, value);
end;

function TFhirEncounterHospitalizationList.Item(index: Integer): TFhirEncounterHospitalization;
begin
  result := TFhirEncounterHospitalization(ObjectByIndex[index]);
end;

function TFhirEncounterHospitalizationList.Link: TFhirEncounterHospitalizationList;
begin
  result := TFhirEncounterHospitalizationList(inherited Link);
end;

procedure TFhirEncounterHospitalizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterHospitalizationList.SetItemByIndex(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  FhirEncounterHospitalizations[index] := value;
end;

procedure TFhirEncounterHospitalizationList.SetItemN(index: Integer; value: TFhirEncounterHospitalization);
begin
  assert(value is TFhirEncounterHospitalization);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounterLocation }

constructor TFhirEncounterLocation.Create;
begin
  inherited;
end;

destructor TFhirEncounterLocation.Destroy;
begin
  FLocation.free;
  FStatus.free;
  FPhysicalType.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEncounterLocation.Assign(oSource : TFslObject);
begin
  inherited;
  location := TFhirEncounterLocation(oSource).location.Clone;
  statusElement := TFhirEncounterLocation(oSource).statusElement.Clone;
  physicalType := TFhirEncounterLocation(oSource).physicalType.Clone;
  period := TFhirEncounterLocation(oSource).period.Clone;
end;

procedure TFhirEncounterLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'physicalType') Then
     list.add(self.link, 'physicalType', FPhysicalType.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEncounterLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'physicalType', 'CodeableConcept', false, TFhirCodeableConcept, FPhysicalType.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirEncounterLocation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterLocationStatusEnum, CODES_TFhirEncounterLocationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'physicalType') then
  begin
    PhysicalType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounterLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEncounterLocation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'location') then result := TFhirReference.Create()
  else if (propName = 'status') then result := TFhirEnum.Create(SYSTEMS_TFhirEncounterLocationStatusEnum[EncounterLocationStatusNull], CODES_TFhirEncounterLocationStatusEnum[EncounterLocationStatusNull]) 
  else if (propName = 'physicalType') then result := TFhirCodeableConcept.Create()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounterLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'location') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'physicalType') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounterLocation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'physicalType') then PhysicalTypeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounterLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterLocationStatusEnum, CODES_TFhirEncounterLocationStatusEnum, new)
  else if (propName = 'physicalType') then PhysicalTypeElement := new as TFhirCodeableConcept
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounterLocation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounterLocation.fhirType : string;
begin
  result := 'Encounter.location';
end;

function TFhirEncounterLocation.Link : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Link);
end;

function TFhirEncounterLocation.Clone : TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(inherited Clone);
end;

function TFhirEncounterLocation.equals(other : TObject) : boolean; 
var
  o : TFhirEncounterLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounterLocation)) then
    result := false
  else
  begin
    o := TFhirEncounterLocation(other);
    result := compareDeep(locationElement, o.locationElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(physicalTypeElement, o.physicalTypeElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEncounterLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLocation) and isEmptyProp(FStatus) and isEmptyProp(FPhysicalType) and isEmptyProp(FPeriod);
end;

procedure TFhirEncounterLocation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('location');
  fields.add('status');
  fields.add('physicalType');
  fields.add('period');
end;

function TFhirEncounterLocation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEncounterLocation.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirEncounterLocation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEncounterLocation.GetStatusST : TFhirEncounterLocationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterLocationStatusEnum(0)
  else
    result := TFhirEncounterLocationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterLocationStatusEnum, FStatus.value));
end;

procedure TFhirEncounterLocation.SetStatusST(value : TFhirEncounterLocationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEncounterLocationStatusEnum[value], CODES_TFhirEncounterLocationStatusEnum[value]);
end;

procedure TFhirEncounterLocation.SetPhysicalType(value : TFhirCodeableConcept);
begin
  FPhysicalType.free;
  FPhysicalType := value;
end;

procedure TFhirEncounterLocation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirEncounterLocationListEnumerator }

constructor TFhirEncounterLocationListEnumerator.Create(list : TFhirEncounterLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterLocationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterLocationListEnumerator.GetCurrent : TFhirEncounterLocation;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterLocationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterLocationList }

function TFhirEncounterLocationList.AddItem(value: TFhirEncounterLocation): TFhirEncounterLocation;
begin
  assert(value.ClassName = 'TFhirEncounterLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounterLocation');
  add(value);
  result := value;
end;

function TFhirEncounterLocationList.Append: TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterLocationList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterLocationList.GetEnumerator : TFhirEncounterLocationListEnumerator;
begin
  result := TFhirEncounterLocationListEnumerator.Create(self.link);
end;

function TFhirEncounterLocationList.Clone: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Clone);
end;

function TFhirEncounterLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterLocationList.GetItemN(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounterLocation;
end;
function TFhirEncounterLocationList.IndexOf(value: TFhirEncounterLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterLocationList.Insert(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterLocationList.InsertItem(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  Inherited Insert(index, value);
end;

function TFhirEncounterLocationList.Item(index: Integer): TFhirEncounterLocation;
begin
  result := TFhirEncounterLocation(ObjectByIndex[index]);
end;

function TFhirEncounterLocationList.Link: TFhirEncounterLocationList;
begin
  result := TFhirEncounterLocationList(inherited Link);
end;

procedure TFhirEncounterLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterLocationList.SetItemByIndex(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  FhirEncounterLocations[index] := value;
end;

procedure TFhirEncounterLocationList.SetItemN(index: Integer; value: TFhirEncounterLocation);
begin
  assert(value is TFhirEncounterLocation);
  ObjectByIndex[index] := value;
end;

{ TFhirEncounter }

constructor TFhirEncounter.Create;
begin
  inherited;
end;

destructor TFhirEncounter.Destroy;
begin
  FIdentifierList.free;
  FStatus.free;
  FStatusHistoryList.free;
  FClass_.free;
  FClassHistoryList.free;
  FType_List.free;
  FServiceType.free;
  FPriority.free;
  FSubject.free;
  FEpisodeOfCareList.free;
  FBasedOnList.free;
  FParticipantList.free;
  FAppointmentList.free;
  FPeriod.free;
  FLength.free;
  FReasonCodeList.free;
  FReasonReferenceList.free;
  FDiagnosisList.free;
  FAccountList.free;
  FHospitalization.free;
  FLocationList.free;
  FServiceProvider.free;
  FPartOf.free;
  inherited;
end;

procedure TFhirEncounter.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEncounter(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEncounter(oSource).FIdentifierList);
  end;
  statusElement := TFhirEncounter(oSource).statusElement.Clone;
  if (TFhirEncounter(oSource).FStatusHistoryList = nil) then
  begin
    FStatusHistoryList.free;
    FStatusHistoryList := nil;
  end
  else
  begin
    if FStatusHistoryList = nil then
      FStatusHistoryList := TFhirEncounterStatusHistoryList.Create;
    FStatusHistoryList.Assign(TFhirEncounter(oSource).FStatusHistoryList);
  end;
  class_ := TFhirEncounter(oSource).class_.Clone;
  if (TFhirEncounter(oSource).FClassHistoryList = nil) then
  begin
    FClassHistoryList.free;
    FClassHistoryList := nil;
  end
  else
  begin
    if FClassHistoryList = nil then
      FClassHistoryList := TFhirEncounterClassHistoryList.Create;
    FClassHistoryList.Assign(TFhirEncounter(oSource).FClassHistoryList);
  end;
  if (TFhirEncounter(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirEncounter(oSource).FType_List);
  end;
  serviceType := TFhirEncounter(oSource).serviceType.Clone;
  priority := TFhirEncounter(oSource).priority.Clone;
  subject := TFhirEncounter(oSource).subject.Clone;
  if (TFhirEncounter(oSource).FEpisodeOfCareList = nil) then
  begin
    FEpisodeOfCareList.free;
    FEpisodeOfCareList := nil;
  end
  else
  begin
    if FEpisodeOfCareList = nil then
      FEpisodeOfCareList := TFhirReferenceList.Create;
    FEpisodeOfCareList.Assign(TFhirEncounter(oSource).FEpisodeOfCareList);
  end;
  if (TFhirEncounter(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirEncounter(oSource).FBasedOnList);
  end;
  if (TFhirEncounter(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirEncounterParticipantList.Create;
    FParticipantList.Assign(TFhirEncounter(oSource).FParticipantList);
  end;
  if (TFhirEncounter(oSource).FAppointmentList = nil) then
  begin
    FAppointmentList.free;
    FAppointmentList := nil;
  end
  else
  begin
    if FAppointmentList = nil then
      FAppointmentList := TFhirReferenceList.Create;
    FAppointmentList.Assign(TFhirEncounter(oSource).FAppointmentList);
  end;
  period := TFhirEncounter(oSource).period.Clone;
  length := TFhirEncounter(oSource).length.Clone;
  if (TFhirEncounter(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirEncounter(oSource).FReasonCodeList);
  end;
  if (TFhirEncounter(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirEncounter(oSource).FReasonReferenceList);
  end;
  if (TFhirEncounter(oSource).FDiagnosisList = nil) then
  begin
    FDiagnosisList.free;
    FDiagnosisList := nil;
  end
  else
  begin
    if FDiagnosisList = nil then
      FDiagnosisList := TFhirEncounterDiagnosisList.Create;
    FDiagnosisList.Assign(TFhirEncounter(oSource).FDiagnosisList);
  end;
  if (TFhirEncounter(oSource).FAccountList = nil) then
  begin
    FAccountList.free;
    FAccountList := nil;
  end
  else
  begin
    if FAccountList = nil then
      FAccountList := TFhirReferenceList.Create;
    FAccountList.Assign(TFhirEncounter(oSource).FAccountList);
  end;
  hospitalization := TFhirEncounter(oSource).hospitalization.Clone;
  if (TFhirEncounter(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirEncounterLocationList.Create;
    FLocationList.Assign(TFhirEncounter(oSource).FLocationList);
  end;
  serviceProvider := TFhirEncounter(oSource).serviceProvider.Clone;
  partOf := TFhirEncounter(oSource).partOf.Clone;
end;

function TFhirEncounter.GetResourceType : TFhirResourceType;
begin
  result := frtEncounter;
end;

procedure TFhirEncounter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusHistory') Then
    list.addAll(self, 'statusHistory', FStatusHistoryList);
  if (child_name = 'class') Then
     list.add(self.link, 'class', FClass_.Link);
  if (child_name = 'classHistory') Then
    list.addAll(self, 'classHistory', FClassHistoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'serviceType') Then
     list.add(self.link, 'serviceType', FServiceType.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'episodeOfCare') Then
    list.addAll(self, 'episodeOfCare', FEpisodeOfCareList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'appointment') Then
    list.addAll(self, 'appointment', FAppointmentList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'length') Then
     list.add(self.link, 'length', FLength.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'diagnosis') Then
    list.addAll(self, 'diagnosis', FDiagnosisList);
  if (child_name = 'account') Then
    list.addAll(self, 'account', FAccountList);
  if (child_name = 'hospitalization') Then
     list.add(self.link, 'hospitalization', FHospitalization.Link);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'serviceProvider') Then
     list.add(self.link, 'serviceProvider', FServiceProvider.Link);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
end;

procedure TFhirEncounter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'statusHistory', 'BackboneElement', true, TFhirEncounterStatusHistory, FStatusHistoryList.Link));
  oList.add(TFHIRProperty.Create(self, 'class', 'Coding', false, TFhirCoding, FClass_.Link));
  oList.add(TFHIRProperty.Create(self, 'classHistory', 'BackboneElement', true, TFhirEncounterClassHistory, FClassHistoryList.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.Create(self, 'serviceType', 'CodeableConcept', false, TFhirCodeableConcept, FServiceType.Link));
  oList.add(TFHIRProperty.Create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));
  oList.add(TFHIRProperty.Create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.Create(self, 'episodeOfCare', 'Reference', true, TFhirReference, FEpisodeOfCareList.Link));
  oList.add(TFHIRProperty.Create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.Create(self, 'participant', 'BackboneElement', true, TFhirEncounterParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.Create(self, 'appointment', 'Reference', true, TFhirReference, FAppointmentList.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'length', 'Duration', false, TFhirDuration, FLength.Link));
  oList.add(TFHIRProperty.Create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.Create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.Create(self, 'diagnosis', 'BackboneElement', true, TFhirEncounterDiagnosis, FDiagnosisList.Link));
  oList.add(TFHIRProperty.Create(self, 'account', 'Reference', true, TFhirReference, FAccountList.Link));
  oList.add(TFHIRProperty.Create(self, 'hospitalization', 'BackboneElement', false, TFhirEncounterHospitalization, FHospitalization.Link));
  oList.add(TFHIRProperty.Create(self, 'location', 'BackboneElement', true, TFhirEncounterLocation, FLocationList.Link));
  oList.add(TFHIRProperty.Create(self, 'serviceProvider', 'Reference', false, TFhirReference, FServiceProvider.Link));
  oList.add(TFHIRProperty.Create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link));
end;

function TFhirEncounter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusHistory') then
  begin
    StatusHistoryList.add(propValue as TFhirEncounterStatusHistory);
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_ := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'classHistory') then
  begin
    ClassHistoryList.add(propValue as TFhirEncounterClassHistory);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'episodeOfCare') then
  begin
    EpisodeOfCareList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirEncounterParticipant);
    result := propValue;
  end
  else if (propName = 'appointment') then
  begin
    AppointmentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'length') then
  begin
    Length := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'diagnosis') then
  begin
    DiagnosisList.add(propValue as TFhirEncounterDiagnosis);
    result := propValue;
  end
  else if (propName = 'account') then
  begin
    AccountList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'hospitalization') then
  begin
    Hospitalization := propValue as TFhirEncounterHospitalization;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirEncounterLocation);
    result := propValue;
  end
  else if (propName = 'serviceProvider') then
  begin
    ServiceProvider := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEncounter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'statusHistory') then StatusHistoryList.insertItem(index, propValue as TFhirEncounterStatusHistory)
  else if (propName = 'classHistory') then ClassHistoryList.insertItem(index, propValue as TFhirEncounterClassHistory)
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'episodeOfCare') then EpisodeOfCareList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirEncounterParticipant)
  else if (propName = 'appointment') then AppointmentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'diagnosis') then DiagnosisList.insertItem(index, propValue as TFhirEncounterDiagnosis)
  else if (propName = 'account') then AccountList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirEncounterLocation)
  else inherited;
end;

function TFhirEncounter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.Create(SYSTEMS_TFhirEncounterStatusEnum[EncounterStatusNull], CODES_TFhirEncounterStatusEnum[EncounterStatusNull]) 
  else if (propName = 'statusHistory') then result := StatusHistoryList.new()
  else if (propName = 'class') then result := TFhirCoding.Create()
  else if (propName = 'classHistory') then result := ClassHistoryList.new()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'serviceType') then result := TFhirCodeableConcept.Create()
  else if (propName = 'priority') then result := TFhirCodeableConcept.Create()
  else if (propName = 'subject') then result := TFhirReference.Create()
  else if (propName = 'episodeOfCare') then result := EpisodeOfCareList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'appointment') then result := AppointmentList.new()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else if (propName = 'length') then result := TFhirDuration.Create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'diagnosis') then result := DiagnosisList.new()
  else if (propName = 'account') then result := AccountList.new()
  else if (propName = 'hospitalization') then result := TFhirEncounterHospitalization.Create()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'serviceProvider') then result := TFhirReference.Create()
  else if (propName = 'partOf') then result := TFhirReference.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEncounter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusHistory') then result := 'BackboneElement'
  else if (propName = 'class') then result := 'Coding'
  else if (propName = 'classHistory') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'episodeOfCare') then result := 'Reference'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'appointment') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'length') then result := 'Duration'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'diagnosis') then result := 'BackboneElement'
  else if (propName = 'account') then result := 'Reference'
  else if (propName = 'hospitalization') then result := 'BackboneElement'
  else if (propName = 'location') then result := 'BackboneElement'
  else if (propName = 'serviceProvider') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEncounter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusHistory') then deletePropertyValue('statusHistory', StatusHistoryList, value)
  else if (propName = 'class') then Class_Element := nil
  else if (propName = 'classHistory') then deletePropertyValue('classHistory', ClassHistoryList, value)
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'serviceType') then ServiceTypeElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'episodeOfCare') then deletePropertyValue('episodeOfCare', EpisodeOfCareList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'appointment') then deletePropertyValue('appointment', AppointmentList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'length') then LengthElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'diagnosis') then deletePropertyValue('diagnosis', DiagnosisList, value)
  else if (propName = 'account') then deletePropertyValue('account', AccountList, value)
  else if (propName = 'hospitalization') then HospitalizationElement := nil
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'serviceProvider') then ServiceProviderElement := nil
  else if (propName = 'partOf') then PartOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEncounter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEncounterStatusEnum, CODES_TFhirEncounterStatusEnum, new)
  else if (propName = 'statusHistory') then replacePropertyValue('statusHistory', StatusHistoryList, existing, new)
  else if (propName = 'class') then Class_Element := new as TFhirCoding
  else if (propName = 'classHistory') then replacePropertyValue('classHistory', ClassHistoryList, existing, new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'serviceType') then ServiceTypeElement := new as TFhirCodeableConcept
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'episodeOfCare') then replacePropertyValue('episodeOfCare', EpisodeOfCareList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'appointment') then replacePropertyValue('appointment', AppointmentList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'length') then LengthElement := new as TFhirDuration
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'diagnosis') then replacePropertyValue('diagnosis', DiagnosisList, existing, new)
  else if (propName = 'account') then replacePropertyValue('account', AccountList, existing, new)
  else if (propName = 'hospitalization') then HospitalizationElement := new as TFhirEncounterHospitalization
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'serviceProvider') then ServiceProviderElement := new as TFhirReference
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEncounter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'statusHistory') then StatusHistoryList.move(source, destination)
  else if (propName = 'classHistory') then ClassHistoryList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'episodeOfCare') then EpisodeOfCareList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'appointment') then AppointmentList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'diagnosis') then DiagnosisList.move(source, destination)
  else if (propName = 'account') then AccountList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEncounter.fhirType : string;
begin
  result := 'Encounter';
end;

function TFhirEncounter.Link : TFhirEncounter;
begin
  result := TFhirEncounter(inherited Link);
end;

function TFhirEncounter.Clone : TFhirEncounter;
begin
  result := TFhirEncounter(inherited Clone);
end;

function TFhirEncounter.equals(other : TObject) : boolean; 
var
  o : TFhirEncounter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEncounter)) then
    result := false
  else
  begin
    o := TFhirEncounter(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusHistoryList, o.statusHistoryList, true) and compareDeep(class_Element, o.class_Element, true) and 
      compareDeep(classHistoryList, o.classHistoryList, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(serviceTypeElement, o.serviceTypeElement, true) and compareDeep(priorityElement, o.priorityElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(episodeOfCareList, o.episodeOfCareList, true) and 
      compareDeep(basedOnList, o.basedOnList, true) and compareDeep(participantList, o.participantList, true) and 
      compareDeep(appointmentList, o.appointmentList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(lengthElement, o.lengthElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(diagnosisList, o.diagnosisList, true) and 
      compareDeep(accountList, o.accountList, true) and compareDeep(hospitalizationElement, o.hospitalizationElement, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(serviceProviderElement, o.serviceProviderElement, true) and 
      compareDeep(partOfElement, o.partOfElement, true);
  end;
end;

function TFhirEncounter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FstatusHistoryList) and isEmptyProp(FClass_) and isEmptyProp(FclassHistoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FServiceType) and isEmptyProp(FPriority) and isEmptyProp(FSubject) and isEmptyProp(FepisodeOfCareList) and isEmptyProp(FbasedOnList) and isEmptyProp(FparticipantList) and isEmptyProp(FappointmentList) and isEmptyProp(FPeriod) and isEmptyProp(FLength) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FdiagnosisList) and isEmptyProp(FaccountList) and isEmptyProp(FHospitalization) and isEmptyProp(FlocationList) and isEmptyProp(FServiceProvider) and isEmptyProp(FPartOf);
end;

procedure TFhirEncounter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('statusHistory');
  fields.add('class');
  fields.add('classHistory');
  fields.add('type');
  fields.add('serviceType');
  fields.add('priority');
  fields.add('subject');
  fields.add('episodeOfCare');
  fields.add('basedOn');
  fields.add('participant');
  fields.add('appointment');
  fields.add('period');
  fields.add('length');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('diagnosis');
  fields.add('account');
  fields.add('hospitalization');
  fields.add('location');
  fields.add('serviceProvider');
  fields.add('partOf');
end;

function TFhirEncounter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FStatusHistoryList.sizeInBytes(magic));
  inc(result, FClassHistoryList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FEpisodeOfCareList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FAppointmentList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FDiagnosisList.sizeInBytes(magic));
  inc(result, FAccountList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
end;

function TFhirEncounter.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEncounter.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEncounter.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEncounter.GetStatusST : TFhirEncounterStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEncounterStatusEnum(0)
  else
    result := TFhirEncounterStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEncounterStatusEnum, FStatus.value));
end;

procedure TFhirEncounter.SetStatusST(value : TFhirEncounterStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEncounterStatusEnum[value], CODES_TFhirEncounterStatusEnum[value]);
end;

function TFhirEncounter.GetStatusHistoryList : TFhirEncounterStatusHistoryList;
begin
  if FStatusHistoryList = nil then
    FStatusHistoryList := TFhirEncounterStatusHistoryList.Create;
  result := FStatusHistoryList;
end;

function TFhirEncounter.GetHasStatusHistoryList : boolean;
begin
  result := (FStatusHistoryList <> nil) and (FStatusHistoryList.count > 0);
end;

procedure TFhirEncounter.SetClass_(value : TFhirCoding);
begin
  FClass_.free;
  FClass_ := value;
end;

function TFhirEncounter.GetClassHistoryList : TFhirEncounterClassHistoryList;
begin
  if FClassHistoryList = nil then
    FClassHistoryList := TFhirEncounterClassHistoryList.Create;
  result := FClassHistoryList;
end;

function TFhirEncounter.GetHasClassHistoryList : boolean;
begin
  result := (FClassHistoryList <> nil) and (FClassHistoryList.count > 0);
end;

function TFhirEncounter.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirEncounter.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirEncounter.SetServiceType(value : TFhirCodeableConcept);
begin
  FServiceType.free;
  FServiceType := value;
end;

procedure TFhirEncounter.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

procedure TFhirEncounter.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

function TFhirEncounter.GetEpisodeOfCareList : TFhirReferenceList;
begin
  if FEpisodeOfCareList = nil then
    FEpisodeOfCareList := TFhirReferenceList.Create;
  result := FEpisodeOfCareList;
end;

function TFhirEncounter.GetHasEpisodeOfCareList : boolean;
begin
  result := (FEpisodeOfCareList <> nil) and (FEpisodeOfCareList.count > 0);
end;

function TFhirEncounter.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirEncounter.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirEncounter.GetParticipantList : TFhirEncounterParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirEncounterParticipantList.Create;
  result := FParticipantList;
end;

function TFhirEncounter.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

function TFhirEncounter.GetAppointmentList : TFhirReferenceList;
begin
  if FAppointmentList = nil then
    FAppointmentList := TFhirReferenceList.Create;
  result := FAppointmentList;
end;

function TFhirEncounter.GetHasAppointmentList : boolean;
begin
  result := (FAppointmentList <> nil) and (FAppointmentList.count > 0);
end;

procedure TFhirEncounter.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirEncounter.SetLength(value : TFhirDuration);
begin
  FLength.free;
  FLength := value;
end;

function TFhirEncounter.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirEncounter.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirEncounter.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirEncounter.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirEncounter.GetDiagnosisList : TFhirEncounterDiagnosisList;
begin
  if FDiagnosisList = nil then
    FDiagnosisList := TFhirEncounterDiagnosisList.Create;
  result := FDiagnosisList;
end;

function TFhirEncounter.GetHasDiagnosisList : boolean;
begin
  result := (FDiagnosisList <> nil) and (FDiagnosisList.count > 0);
end;

function TFhirEncounter.GetAccountList : TFhirReferenceList;
begin
  if FAccountList = nil then
    FAccountList := TFhirReferenceList.Create;
  result := FAccountList;
end;

function TFhirEncounter.GetHasAccountList : boolean;
begin
  result := (FAccountList <> nil) and (FAccountList.count > 0);
end;

procedure TFhirEncounter.SetHospitalization(value : TFhirEncounterHospitalization);
begin
  FHospitalization.free;
  FHospitalization := value;
end;

function TFhirEncounter.GetLocationList : TFhirEncounterLocationList;
begin
  if FLocationList = nil then
    FLocationList := TFhirEncounterLocationList.Create;
  result := FLocationList;
end;

function TFhirEncounter.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

procedure TFhirEncounter.SetServiceProvider(value : TFhirReference);
begin
  FServiceProvider.free;
  FServiceProvider := value;
end;

procedure TFhirEncounter.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value;
end;

{ TFhirEncounterListEnumerator }

constructor TFhirEncounterListEnumerator.Create(list : TFhirEncounterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEncounterListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEncounterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEncounterListEnumerator.GetCurrent : TFhirEncounter;
begin
  Result := FList[FIndex];
end;

function TFhirEncounterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEncounterList }

function TFhirEncounterList.AddItem(value: TFhirEncounter): TFhirEncounter;
begin
  assert(value.ClassName = 'TFhirEncounter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEncounter');
  add(value);
  result := value;
end;

function TFhirEncounterList.Append: TFhirEncounter;
begin
  result := TFhirEncounter.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterList.ClearItems;
begin
  Clear;
end;

function TFhirEncounterList.GetEnumerator : TFhirEncounterListEnumerator;
begin
  result := TFhirEncounterListEnumerator.Create(self.link);
end;

function TFhirEncounterList.Clone: TFhirEncounterList;
begin
  result := TFhirEncounterList(inherited Clone);
end;

function TFhirEncounterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEncounterList.GetItemN(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter(ObjectByIndex[index]);
end;

function TFhirEncounterList.ItemClass: TFslObjectClass;
begin
  result := TFhirEncounter;
end;
function TFhirEncounterList.IndexOf(value: TFhirEncounter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEncounterList.Insert(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEncounterList.InsertItem(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  Inherited Insert(index, value);
end;

function TFhirEncounterList.Item(index: Integer): TFhirEncounter;
begin
  result := TFhirEncounter(ObjectByIndex[index]);
end;

function TFhirEncounterList.Link: TFhirEncounterList;
begin
  result := TFhirEncounterList(inherited Link);
end;

procedure TFhirEncounterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEncounterList.SetItemByIndex(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  FhirEncounters[index] := value;
end;

procedure TFhirEncounterList.SetItemN(index: Integer; value: TFhirEncounter);
begin
  assert(value is TFhirEncounter);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENCOUNTER}
{$IFDEF FHIR_ENDPOINT}
{ TFhirEndpoint }

constructor TFhirEndpoint.Create;
begin
  inherited;
end;

destructor TFhirEndpoint.Destroy;
begin
  FIdentifierList.free;
  FStatus.free;
  FConnectionType.free;
  FName.free;
  FManagingOrganization.free;
  FContactList.free;
  FPeriod.free;
  FPayloadTypeList.free;
  FPayloadMimeTypeList.free;
  FAddress.free;
  FHeaderList.free;
  inherited;
end;

procedure TFhirEndpoint.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEndpoint(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEndpoint(oSource).FIdentifierList);
  end;
  statusElement := TFhirEndpoint(oSource).statusElement.Clone;
  connectionType := TFhirEndpoint(oSource).connectionType.Clone;
  nameElement := TFhirEndpoint(oSource).nameElement.Clone;
  managingOrganization := TFhirEndpoint(oSource).managingOrganization.Clone;
  if (TFhirEndpoint(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirEndpoint(oSource).FContactList);
  end;
  period := TFhirEndpoint(oSource).period.Clone;
  if (TFhirEndpoint(oSource).FPayloadTypeList = nil) then
  begin
    FPayloadTypeList.free;
    FPayloadTypeList := nil;
  end
  else
  begin
    if FPayloadTypeList = nil then
      FPayloadTypeList := TFhirCodeableConceptList.Create;
    FPayloadTypeList.Assign(TFhirEndpoint(oSource).FPayloadTypeList);
  end;
  if (TFhirEndpoint(oSource).FPayloadMimeTypeList = nil) then
  begin
    FPayloadMimeTypeList.free;
    FPayloadMimeTypeList := nil;
  end
  else
  begin
    if FPayloadMimeTypeList = nil then
      FPayloadMimeTypeList := TFhirCodeList.Create;
    FPayloadMimeTypeList.Assign(TFhirEndpoint(oSource).FPayloadMimeTypeList);
  end;
  addressElement := TFhirEndpoint(oSource).addressElement.Clone;
  if (TFhirEndpoint(oSource).FHeaderList = nil) then
  begin
    FHeaderList.free;
    FHeaderList := nil;
  end
  else
  begin
    if FHeaderList = nil then
      FHeaderList := TFhirStringList.Create;
    FHeaderList.Assign(TFhirEndpoint(oSource).FHeaderList);
  end;
end;

function TFhirEndpoint.GetResourceType : TFhirResourceType;
begin
  result := frtEndpoint;
end;

procedure TFhirEndpoint.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'connectionType') Then
     list.add(self.link, 'connectionType', FConnectionType.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'payloadType') Then
    list.addAll(self, 'payloadType', FPayloadTypeList);
  if (child_name = 'payloadMimeType') Then
    list.addAll(self, 'payloadMimeType', FPayloadMimeTypeList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'header') Then
    list.addAll(self, 'header', FHeaderList);
end;

procedure TFhirEndpoint.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'connectionType', 'Coding', false, TFhirCoding, FConnectionType.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.Create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link));
  oList.add(TFHIRProperty.Create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'payloadType', 'CodeableConcept', true, TFhirCodeableConcept, FPayloadTypeList.Link));
  oList.add(TFHIRProperty.Create(self, 'payloadMimeType', 'code', true, TFhirCode, FPayloadMimeTypeList.Link));
  oList.add(TFHIRProperty.Create(self, 'address', 'url', false, TFhirUrl, FAddress.Link));
  oList.add(TFHIRProperty.Create(self, 'header', 'string', true, TFhirString, FHeaderList.Link));
end;

function TFhirEndpoint.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEndpointStatusEnum, CODES_TFhirEndpointStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'connectionType') then
  begin
    ConnectionType := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'payloadType') then
  begin
    PayloadTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'payloadMimeType') then
  begin
    PayloadMimeTypeList.add(asCode(propValue)){2};     result := propValue;

  end
  else if (propName = 'address') then
  begin
    AddressElement := asUrl(propValue);
    result := propValue;
  end
  else if (propName = 'header') then
  begin
    HeaderList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEndpoint.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'payloadType') then PayloadTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'payloadMimeType') then PayloadMimeTypeList.insertItem(index, asCode(propValue))
  else if (propName = 'header') then HeaderList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirEndpoint.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.Create(SYSTEMS_TFhirEndpointStatusEnum[EndpointStatusNull], CODES_TFhirEndpointStatusEnum[EndpointStatusNull]) 
  else if (propName = 'connectionType') then result := TFhirCoding.Create()
  else if (propName = 'name') then result := TFhirString.Create()
  else if (propName = 'managingOrganization') then result := TFhirReference.Create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else if (propName = 'payloadType') then result := PayloadTypeList.new()
  else if (propName = 'payloadMimeType') then result := PayloadMimeTypeList.new()
  else if (propName = 'address') then result := TFhirUrl.Create()
  else if (propName = 'header') then result := HeaderList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEndpoint.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'connectionType') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'payloadType') then result := 'CodeableConcept'
  else if (propName = 'payloadMimeType') then result := 'code'
  else if (propName = 'address') then result := 'url'
  else if (propName = 'header') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEndpoint.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'connectionType') then ConnectionTypeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'payloadType') then deletePropertyValue('payloadType', PayloadTypeList, value)
  else if (propName = 'payloadMimeType') then deletePropertyValue('payloadMimeType', PayloadMimeTypeList, value)
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'header') then deletePropertyValue('header', HeaderList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEndpoint.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEndpointStatusEnum, CODES_TFhirEndpointStatusEnum, new)
  else if (propName = 'connectionType') then ConnectionTypeElement := new as TFhirCoding
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'payloadType') then replacePropertyValue('payloadType', PayloadTypeList, existing, new)
  else if (propName = 'payloadMimeType') then replacePropertyValue('payloadMimeType', PayloadMimeTypeList, existing, new)
  else if (propName = 'address') then AddressElement := asUrl(new)
  else if (propName = 'header') then replacePropertyValue('header', HeaderList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEndpoint.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'payloadType') then PayloadTypeList.move(source, destination)
  else if (propName = 'payloadMimeType') then PayloadMimeTypeList.move(source, destination)
  else if (propName = 'header') then HeaderList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEndpoint.fhirType : string;
begin
  result := 'Endpoint';
end;

function TFhirEndpoint.Link : TFhirEndpoint;
begin
  result := TFhirEndpoint(inherited Link);
end;

function TFhirEndpoint.Clone : TFhirEndpoint;
begin
  result := TFhirEndpoint(inherited Clone);
end;

function TFhirEndpoint.equals(other : TObject) : boolean; 
var
  o : TFhirEndpoint;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEndpoint)) then
    result := false
  else
  begin
    o := TFhirEndpoint(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(connectionTypeElement, o.connectionTypeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(payloadTypeList, o.payloadTypeList, true) and compareDeep(payloadMimeTypeList, o.payloadMimeTypeList, true) and 
      compareDeep(addressElement, o.addressElement, true) and compareDeep(headerList, o.headerList, true);
  end;
end;

function TFhirEndpoint.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FConnectionType) and isEmptyProp(FName) and isEmptyProp(FManagingOrganization) and isEmptyProp(FcontactList) and isEmptyProp(FPeriod) and isEmptyProp(FpayloadTypeList) and isEmptyProp(FpayloadMimeTypeList) and isEmptyProp(FAddress) and isEmptyProp(FheaderList);
end;

procedure TFhirEndpoint.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('connectionType');
  fields.add('name');
  fields.add('managingOrganization');
  fields.add('contact');
  fields.add('period');
  fields.add('payloadType');
  fields.add('payloadMimeType');
  fields.add('address');
  fields.add('header');
end;

function TFhirEndpoint.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FPayloadTypeList.sizeInBytes(magic));
  inc(result, FPayloadMimeTypeList.sizeInBytes(magic));
  inc(result, FHeaderList.sizeInBytes(magic));
end;

function TFhirEndpoint.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEndpoint.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEndpoint.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEndpoint.GetStatusST : TFhirEndpointStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEndpointStatusEnum(0)
  else
    result := TFhirEndpointStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEndpointStatusEnum, FStatus.value));
end;

procedure TFhirEndpoint.SetStatusST(value : TFhirEndpointStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEndpointStatusEnum[value], CODES_TFhirEndpointStatusEnum[value]);
end;

procedure TFhirEndpoint.SetConnectionType(value : TFhirCoding);
begin
  FConnectionType.free;
  FConnectionType := value;
end;

procedure TFhirEndpoint.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirEndpoint.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirEndpoint.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirEndpoint.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

function TFhirEndpoint.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirEndpoint.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirEndpoint.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirEndpoint.GetPayloadTypeList : TFhirCodeableConceptList;
begin
  if FPayloadTypeList = nil then
    FPayloadTypeList := TFhirCodeableConceptList.Create;
  result := FPayloadTypeList;
end;

function TFhirEndpoint.GetHasPayloadTypeList : boolean;
begin
  result := (FPayloadTypeList <> nil) and (FPayloadTypeList.count > 0);
end;

function TFhirEndpoint.GetPayloadMimeTypeList : TFhirCodeList;
begin
  if FPayloadMimeTypeList = nil then
    FPayloadMimeTypeList := TFhirCodeList.Create;
  result := FPayloadMimeTypeList;
end;

function TFhirEndpoint.GetHasPayloadMimeTypeList : boolean;
begin
  result := (FPayloadMimeTypeList <> nil) and (FPayloadMimeTypeList.count > 0);
end;

procedure TFhirEndpoint.SetAddress(value : TFhirUrl);
begin
  FAddress.free;
  FAddress := value;
end;

function TFhirEndpoint.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

procedure TFhirEndpoint.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirUrl.Create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

function TFhirEndpoint.GetHeaderList : TFhirStringList;
begin
  if FHeaderList = nil then
    FHeaderList := TFhirStringList.Create;
  result := FHeaderList;
end;

function TFhirEndpoint.GetHasHeaderList : boolean;
begin
  result := (FHeaderList <> nil) and (FHeaderList.count > 0);
end;

{ TFhirEndpointListEnumerator }

constructor TFhirEndpointListEnumerator.Create(list : TFhirEndpointList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEndpointListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirEndpointListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEndpointListEnumerator.GetCurrent : TFhirEndpoint;
begin
  Result := FList[FIndex];
end;

function TFhirEndpointListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEndpointList }

function TFhirEndpointList.AddItem(value: TFhirEndpoint): TFhirEndpoint;
begin
  assert(value.ClassName = 'TFhirEndpoint', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEndpoint');
  add(value);
  result := value;
end;

function TFhirEndpointList.Append: TFhirEndpoint;
begin
  result := TFhirEndpoint.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEndpointList.ClearItems;
begin
  Clear;
end;

function TFhirEndpointList.GetEnumerator : TFhirEndpointListEnumerator;
begin
  result := TFhirEndpointListEnumerator.Create(self.link);
end;

function TFhirEndpointList.Clone: TFhirEndpointList;
begin
  result := TFhirEndpointList(inherited Clone);
end;

function TFhirEndpointList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEndpointList.GetItemN(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint(ObjectByIndex[index]);
end;

function TFhirEndpointList.ItemClass: TFslObjectClass;
begin
  result := TFhirEndpoint;
end;
function TFhirEndpointList.IndexOf(value: TFhirEndpoint): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEndpointList.Insert(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEndpointList.InsertItem(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  Inherited Insert(index, value);
end;

function TFhirEndpointList.Item(index: Integer): TFhirEndpoint;
begin
  result := TFhirEndpoint(ObjectByIndex[index]);
end;

function TFhirEndpointList.Link: TFhirEndpointList;
begin
  result := TFhirEndpointList(inherited Link);
end;

procedure TFhirEndpointList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEndpointList.SetItemByIndex(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  FhirEndpoints[index] := value;
end;

procedure TFhirEndpointList.SetItemN(index: Integer; value: TFhirEndpoint);
begin
  assert(value is TFhirEndpoint);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ENDPOINT}
{$IFDEF FHIR_GROUP}
{ TFhirGroupCharacteristic }

constructor TFhirGroupCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirGroupCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FExclude.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirGroupCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirGroupCharacteristic(oSource).code.Clone;
  value := TFhirGroupCharacteristic(oSource).value.Clone;
  excludeElement := TFhirGroupCharacteristic(oSource).excludeElement.Clone;
  period := TFhirGroupCharacteristic(oSource).period.Clone;
end;

procedure TFhirGroupCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirGroupCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.Create(self, 'value[x]', 'CodeableConcept|boolean|Quantity|Range|Reference', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.Create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirGroupCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroupCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGroupCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.Create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then raise EFHIRException.Create('Cannot make property Value')
  else if (propName = 'exclude') then result := TFhirBoolean.Create()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroupCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'CodeableConcept|boolean|Quantity|Range|Reference'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroupCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := nil
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroupCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Boolean', 'Quantity', 'Range', 'Reference'])) then ValueElement := new as TFhirDataType
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroupCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGroupCharacteristic.fhirType : string;
begin
  result := 'Group.characteristic';
end;

function TFhirGroupCharacteristic.Link : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Link);
end;

function TFhirGroupCharacteristic.Clone : TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(inherited Clone);
end;

function TFhirGroupCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirGroupCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroupCharacteristic)) then
    result := false
  else
  begin
    o := TFhirGroupCharacteristic(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(excludeElement, o.excludeElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirGroupCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FExclude) and isEmptyProp(FPeriod);
end;

procedure TFhirGroupCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('exclude');
  fields.add('period');
end;

function TFhirGroupCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirGroupCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirGroupCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirGroupCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

function TFhirGroupCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

procedure TFhirGroupCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.Create;
  FExclude.value := value
end;

procedure TFhirGroupCharacteristic.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirGroupCharacteristicListEnumerator }

constructor TFhirGroupCharacteristicListEnumerator.Create(list : TFhirGroupCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupCharacteristicListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirGroupCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupCharacteristicListEnumerator.GetCurrent : TFhirGroupCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirGroupCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGroupCharacteristicList }

function TFhirGroupCharacteristicList.AddItem(value: TFhirGroupCharacteristic): TFhirGroupCharacteristic;
begin
  assert(value.ClassName = 'TFhirGroupCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroupCharacteristic');
  add(value);
  result := value;
end;

function TFhirGroupCharacteristicList.Append: TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirGroupCharacteristicList.GetEnumerator : TFhirGroupCharacteristicListEnumerator;
begin
  result := TFhirGroupCharacteristicListEnumerator.Create(self.link);
end;

function TFhirGroupCharacteristicList.Clone: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Clone);
end;

function TFhirGroupCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupCharacteristicList.GetItemN(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroupCharacteristic;
end;
function TFhirGroupCharacteristicList.IndexOf(value: TFhirGroupCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupCharacteristicList.Insert(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupCharacteristicList.InsertItem(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirGroupCharacteristicList.Item(index: Integer): TFhirGroupCharacteristic;
begin
  result := TFhirGroupCharacteristic(ObjectByIndex[index]);
end;

function TFhirGroupCharacteristicList.Link: TFhirGroupCharacteristicList;
begin
  result := TFhirGroupCharacteristicList(inherited Link);
end;

procedure TFhirGroupCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupCharacteristicList.SetItemByIndex(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  FhirGroupCharacteristics[index] := value;
end;

procedure TFhirGroupCharacteristicList.SetItemN(index: Integer; value: TFhirGroupCharacteristic);
begin
  assert(value is TFhirGroupCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirGroupMember }

constructor TFhirGroupMember.Create;
begin
  inherited;
end;

destructor TFhirGroupMember.Destroy;
begin
  FEntity.free;
  FPeriod.free;
  FInactive.free;
  inherited;
end;

procedure TFhirGroupMember.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirGroupMember(oSource).entity.Clone;
  period := TFhirGroupMember(oSource).period.Clone;
  inactiveElement := TFhirGroupMember(oSource).inactiveElement.Clone;
end;

procedure TFhirGroupMember.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity') Then
     list.add(self.link, 'entity', FEntity.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'inactive') Then
     list.add(self.link, 'inactive', FInactive.Link);
end;

procedure TFhirGroupMember.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'entity', 'Reference', false, TFhirReference, FEntity.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'inactive', 'boolean', false, TFhirBoolean, FInactive.Link));
end;

function TFhirGroupMember.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'entity') then
  begin
    Entity := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'inactive') then
  begin
    InactiveElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroupMember.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirGroupMember.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'entity') then result := TFhirReference.Create()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else if (propName = 'inactive') then result := TFhirBoolean.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroupMember.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'inactive') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroupMember.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'inactive') then InactiveElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroupMember.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'entity') then EntityElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'inactive') then InactiveElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroupMember.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirGroupMember.fhirType : string;
begin
  result := 'Group.member';
end;

function TFhirGroupMember.Link : TFhirGroupMember;
begin
  result := TFhirGroupMember(inherited Link);
end;

function TFhirGroupMember.Clone : TFhirGroupMember;
begin
  result := TFhirGroupMember(inherited Clone);
end;

function TFhirGroupMember.equals(other : TObject) : boolean; 
var
  o : TFhirGroupMember;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroupMember)) then
    result := false
  else
  begin
    o := TFhirGroupMember(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(inactiveElement, o.inactiveElement, true);
  end;
end;

function TFhirGroupMember.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FPeriod) and isEmptyProp(FInactive);
end;

procedure TFhirGroupMember.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('entity');
  fields.add('period');
  fields.add('inactive');
end;

function TFhirGroupMember.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirGroupMember.SetEntity(value : TFhirReference);
begin
  FEntity.free;
  FEntity := value;
end;

procedure TFhirGroupMember.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirGroupMember.SetInactive(value : TFhirBoolean);
begin
  FInactive.free;
  FInactive := value;
end;

function TFhirGroupMember.GetInactiveST : Boolean;
begin
  if FInactive = nil then
    result := false
  else
    result := FInactive.value;
end;

procedure TFhirGroupMember.SetInactiveST(value : Boolean);
begin
  if FInactive = nil then
    FInactive := TFhirBoolean.Create;
  FInactive.value := value
end;

{ TFhirGroupMemberListEnumerator }

constructor TFhirGroupMemberListEnumerator.Create(list : TFhirGroupMemberList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupMemberListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirGroupMemberListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupMemberListEnumerator.GetCurrent : TFhirGroupMember;
begin
  Result := FList[FIndex];
end;

function TFhirGroupMemberListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGroupMemberList }

function TFhirGroupMemberList.AddItem(value: TFhirGroupMember): TFhirGroupMember;
begin
  assert(value.ClassName = 'TFhirGroupMember', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroupMember');
  add(value);
  result := value;
end;

function TFhirGroupMemberList.Append: TFhirGroupMember;
begin
  result := TFhirGroupMember.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupMemberList.ClearItems;
begin
  Clear;
end;

function TFhirGroupMemberList.GetEnumerator : TFhirGroupMemberListEnumerator;
begin
  result := TFhirGroupMemberListEnumerator.Create(self.link);
end;

function TFhirGroupMemberList.Clone: TFhirGroupMemberList;
begin
  result := TFhirGroupMemberList(inherited Clone);
end;

function TFhirGroupMemberList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupMemberList.GetItemN(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember(ObjectByIndex[index]);
end;

function TFhirGroupMemberList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroupMember;
end;
function TFhirGroupMemberList.IndexOf(value: TFhirGroupMember): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupMemberList.Insert(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupMemberList.InsertItem(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  Inherited Insert(index, value);
end;

function TFhirGroupMemberList.Item(index: Integer): TFhirGroupMember;
begin
  result := TFhirGroupMember(ObjectByIndex[index]);
end;

function TFhirGroupMemberList.Link: TFhirGroupMemberList;
begin
  result := TFhirGroupMemberList(inherited Link);
end;

procedure TFhirGroupMemberList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupMemberList.SetItemByIndex(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  FhirGroupMembers[index] := value;
end;

procedure TFhirGroupMemberList.SetItemN(index: Integer; value: TFhirGroupMember);
begin
  assert(value is TFhirGroupMember);
  ObjectByIndex[index] := value;
end;

{ TFhirGroup }

constructor TFhirGroup.Create;
begin
  inherited;
end;

destructor TFhirGroup.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FType_.free;
  FActual.free;
  FCode.free;
  FName.free;
  FQuantity.free;
  FManagingEntity.free;
  FCharacteristicList.free;
  FMemberList.free;
  inherited;
end;

procedure TFhirGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirGroup(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGroup(oSource).FIdentifierList);
  end;
  activeElement := TFhirGroup(oSource).activeElement.Clone;
  type_Element := TFhirGroup(oSource).type_Element.Clone;
  actualElement := TFhirGroup(oSource).actualElement.Clone;
  code := TFhirGroup(oSource).code.Clone;
  nameElement := TFhirGroup(oSource).nameElement.Clone;
  quantityElement := TFhirGroup(oSource).quantityElement.Clone;
  managingEntity := TFhirGroup(oSource).managingEntity.Clone;
  if (TFhirGroup(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirGroupCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirGroup(oSource).FCharacteristicList);
  end;
  if (TFhirGroup(oSource).FMemberList = nil) then
  begin
    FMemberList.free;
    FMemberList := nil;
  end
  else
  begin
    if FMemberList = nil then
      FMemberList := TFhirGroupMemberList.Create;
    FMemberList.Assign(TFhirGroup(oSource).FMemberList);
  end;
end;

function TFhirGroup.GetResourceType : TFhirResourceType;
begin
  result := frtGroup;
end;

procedure TFhirGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'actual') Then
     list.add(self.link, 'actual', FActual.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'managingEntity') Then
     list.add(self.link, 'managingEntity', FManagingEntity.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'member') Then
    list.addAll(self, 'member', FMemberList);
end;

procedure TFhirGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'actual', 'boolean', false, TFhirBoolean, FActual.Link));
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.Create(self, 'quantity', 'unsignedInt', false, TFhirUnsignedInt, FQuantity.Link));
  oList.add(TFHIRProperty.Create(self, 'managingEntity', 'Reference', false, TFhirReference, FManagingEntity.Link));
  oList.add(TFHIRProperty.Create(self, 'characteristic', 'BackboneElement', true, TFhirGroupCharacteristic, FCharacteristicList.Link));
  oList.add(TFHIRProperty.Create(self, 'member', 'BackboneElement', true, TFhirGroupMember, FMemberList.Link));
end;

function TFhirGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirGroupTypeEnum, CODES_TFhirGroupTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'actual') then
  begin
    ActualElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    QuantityElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'managingEntity') then
  begin
    ManagingEntity := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirGroupCharacteristic);
    result := propValue;
  end
  else if (propName = 'member') then
  begin
    MemberList.add(propValue as TFhirGroupMember);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirGroupCharacteristic)
  else if (propName = 'member') then MemberList.insertItem(index, propValue as TFhirGroupMember)
  else inherited;
end;

function TFhirGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'type') then result := TFhirEnum.Create(SYSTEMS_TFhirGroupTypeEnum[GroupTypeNull], CODES_TFhirGroupTypeEnum[GroupTypeNull]) 
  else if (propName = 'actual') then result := TFhirBoolean.Create()
  else if (propName = 'code') then result := TFhirCodeableConcept.Create()
  else if (propName = 'name') then result := TFhirString.Create()
  else if (propName = 'quantity') then result := TFhirUnsignedInt.Create()
  else if (propName = 'managingEntity') then result := TFhirReference.Create()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'member') then result := MemberList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'actual') then result := 'boolean'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'quantity') then result := 'unsignedInt'
  else if (propName = 'managingEntity') then result := 'Reference'
  else if (propName = 'characteristic') then result := 'BackboneElement'
  else if (propName = 'member') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'actual') then ActualElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'managingEntity') then ManagingEntityElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'member') then deletePropertyValue('member', MemberList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirGroupTypeEnum, CODES_TFhirGroupTypeEnum, new)
  else if (propName = 'actual') then ActualElement := asBoolean(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'quantity') then QuantityElement := asUnsignedInt(new)
  else if (propName = 'managingEntity') then ManagingEntityElement := new as TFhirReference
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'member') then replacePropertyValue('member', MemberList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'member') then MemberList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGroup.fhirType : string;
begin
  result := 'Group';
end;

function TFhirGroup.Link : TFhirGroup;
begin
  result := TFhirGroup(inherited Link);
end;

function TFhirGroup.Clone : TFhirGroup;
begin
  result := TFhirGroup(inherited Clone);
end;

function TFhirGroup.equals(other : TObject) : boolean; 
var
  o : TFhirGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGroup)) then
    result := false
  else
  begin
    o := TFhirGroup(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(actualElement, o.actualElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(managingEntityElement, o.managingEntityElement, true) and 
      compareDeep(characteristicList, o.characteristicList, true) and compareDeep(memberList, o.memberList, true);
  end;
end;

function TFhirGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FType_) and isEmptyProp(FActual) and isEmptyProp(FCode) and isEmptyProp(FName) and isEmptyProp(FQuantity) and isEmptyProp(FManagingEntity) and isEmptyProp(FcharacteristicList) and isEmptyProp(FmemberList);
end;

procedure TFhirGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('type');
  fields.add('actual');
  fields.add('code');
  fields.add('name');
  fields.add('quantity');
  fields.add('managingEntity');
  fields.add('characteristic');
  fields.add('member');
end;

function TFhirGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FMemberList.sizeInBytes(magic));
end;

function TFhirGroup.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirGroup.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirGroup.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirGroup.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirGroup.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

procedure TFhirGroup.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirGroup.GetType_ST : TFhirGroupTypeEnum;
begin
  if FType_ = nil then
    result := TFhirGroupTypeEnum(0)
  else
    result := TFhirGroupTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupTypeEnum, FType_.value));
end;

procedure TFhirGroup.SetType_ST(value : TFhirGroupTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.Create(SYSTEMS_TFhirGroupTypeEnum[value], CODES_TFhirGroupTypeEnum[value]);
end;

procedure TFhirGroup.SetActual(value : TFhirBoolean);
begin
  FActual.free;
  FActual := value;
end;

function TFhirGroup.GetActualST : Boolean;
begin
  if FActual = nil then
    result := false
  else
    result := FActual.value;
end;

procedure TFhirGroup.SetActualST(value : Boolean);
begin
  if FActual = nil then
    FActual := TFhirBoolean.Create;
  FActual.value := value
end;

procedure TFhirGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirGroup.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirGroup.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirGroup.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirGroup.SetQuantity(value : TFhirUnsignedInt);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirGroup.GetQuantityST : String;
begin
  if FQuantity = nil then
    result := ''
  else
    result := FQuantity.value;
end;

procedure TFhirGroup.SetQuantityST(value : String);
begin
  if value <> '' then
  begin
    if FQuantity = nil then
      FQuantity := TFhirUnsignedInt.Create;
    FQuantity.value := value
  end
  else if FQuantity <> nil then
    FQuantity.value := '';
end;

procedure TFhirGroup.SetManagingEntity(value : TFhirReference);
begin
  FManagingEntity.free;
  FManagingEntity := value;
end;

function TFhirGroup.GetCharacteristicList : TFhirGroupCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirGroupCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirGroup.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirGroup.GetMemberList : TFhirGroupMemberList;
begin
  if FMemberList = nil then
    FMemberList := TFhirGroupMemberList.Create;
  result := FMemberList;
end;

function TFhirGroup.GetHasMemberList : boolean;
begin
  result := (FMemberList <> nil) and (FMemberList.count > 0);
end;

{ TFhirGroupListEnumerator }

constructor TFhirGroupListEnumerator.Create(list : TFhirGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGroupListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGroupListEnumerator.GetCurrent : TFhirGroup;
begin
  Result := FList[FIndex];
end;

function TFhirGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGroupList }

function TFhirGroupList.AddItem(value: TFhirGroup): TFhirGroup;
begin
  assert(value.ClassName = 'TFhirGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGroup');
  add(value);
  result := value;
end;

function TFhirGroupList.Append: TFhirGroup;
begin
  result := TFhirGroup.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupList.ClearItems;
begin
  Clear;
end;

function TFhirGroupList.GetEnumerator : TFhirGroupListEnumerator;
begin
  result := TFhirGroupListEnumerator.Create(self.link);
end;

function TFhirGroupList.Clone: TFhirGroupList;
begin
  result := TFhirGroupList(inherited Clone);
end;

function TFhirGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGroupList.GetItemN(index: Integer): TFhirGroup;
begin
  result := TFhirGroup(ObjectByIndex[index]);
end;

function TFhirGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirGroup;
end;
function TFhirGroupList.IndexOf(value: TFhirGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGroupList.Insert(index: Integer): TFhirGroup;
begin
  result := TFhirGroup.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGroupList.InsertItem(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  Inherited Insert(index, value);
end;

function TFhirGroupList.Item(index: Integer): TFhirGroup;
begin
  result := TFhirGroup(ObjectByIndex[index]);
end;

function TFhirGroupList.Link: TFhirGroupList;
begin
  result := TFhirGroupList(inherited Link);
end;

procedure TFhirGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGroupList.SetItemByIndex(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  FhirGroups[index] := value;
end;

procedure TFhirGroupList.SetItemN(index: Integer; value: TFhirGroup);
begin
  assert(value is TFhirGroup);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GROUP}
{$IFDEF FHIR_HEALTHCARESERVICE}
{ TFhirHealthcareServiceEligibility }

constructor TFhirHealthcareServiceEligibility.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceEligibility.Destroy;
begin
  FCode.free;
  FComment.free;
  inherited;
end;

procedure TFhirHealthcareServiceEligibility.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirHealthcareServiceEligibility(oSource).code.Clone;
  commentElement := TFhirHealthcareServiceEligibility(oSource).commentElement.Clone;
end;

procedure TFhirHealthcareServiceEligibility.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirHealthcareServiceEligibility.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.Create(self, 'comment', 'markdown', false, TFhirMarkdown, FComment.Link));
end;

function TFhirHealthcareServiceEligibility.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceEligibility.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirHealthcareServiceEligibility.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.Create()
  else if (propName = 'comment') then result := TFhirMarkdown.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceEligibility.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'comment') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceEligibility.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceEligibility.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'comment') then CommentElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceEligibility.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceEligibility.fhirType : string;
begin
  result := 'HealthcareService.eligibility';
end;

function TFhirHealthcareServiceEligibility.Link : TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(inherited Link);
end;

function TFhirHealthcareServiceEligibility.Clone : TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(inherited Clone);
end;

function TFhirHealthcareServiceEligibility.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceEligibility;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceEligibility)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceEligibility(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirHealthcareServiceEligibility.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FComment);
end;

procedure TFhirHealthcareServiceEligibility.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('comment');
end;

function TFhirHealthcareServiceEligibility.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirHealthcareServiceEligibility.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirHealthcareServiceEligibility.SetComment(value : TFhirMarkdown);
begin
  FComment.free;
  FComment := value;
end;

function TFhirHealthcareServiceEligibility.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirHealthcareServiceEligibility.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirMarkdown.Create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirHealthcareServiceEligibilityListEnumerator }

constructor TFhirHealthcareServiceEligibilityListEnumerator.Create(list : TFhirHealthcareServiceEligibilityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceEligibilityListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirHealthcareServiceEligibilityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceEligibilityListEnumerator.GetCurrent : TFhirHealthcareServiceEligibility;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceEligibilityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceEligibilityList }

function TFhirHealthcareServiceEligibilityList.AddItem(value: TFhirHealthcareServiceEligibility): TFhirHealthcareServiceEligibility;
begin
  assert(value.ClassName = 'TFhirHealthcareServiceEligibility', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareServiceEligibility');
  add(value);
  result := value;
end;

function TFhirHealthcareServiceEligibilityList.Append: TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceEligibilityList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceEligibilityList.GetEnumerator : TFhirHealthcareServiceEligibilityListEnumerator;
begin
  result := TFhirHealthcareServiceEligibilityListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceEligibilityList.Clone: TFhirHealthcareServiceEligibilityList;
begin
  result := TFhirHealthcareServiceEligibilityList(inherited Clone);
end;

function TFhirHealthcareServiceEligibilityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceEligibilityList.GetItemN(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceEligibilityList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceEligibility;
end;
function TFhirHealthcareServiceEligibilityList.IndexOf(value: TFhirHealthcareServiceEligibility): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceEligibilityList.Insert(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceEligibilityList.InsertItem(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceEligibilityList.Item(index: Integer): TFhirHealthcareServiceEligibility;
begin
  result := TFhirHealthcareServiceEligibility(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceEligibilityList.Link: TFhirHealthcareServiceEligibilityList;
begin
  result := TFhirHealthcareServiceEligibilityList(inherited Link);
end;

procedure TFhirHealthcareServiceEligibilityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceEligibilityList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  FhirHealthcareServiceEligibilities[index] := value;
end;

procedure TFhirHealthcareServiceEligibilityList.SetItemN(index: Integer; value: TFhirHealthcareServiceEligibility);
begin
  assert(value is TFhirHealthcareServiceEligibility);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareServiceAvailableTime }

constructor TFhirHealthcareServiceAvailableTime.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceAvailableTime.Destroy;
begin
  FDaysOfWeek.free;
  FAllDay.free;
  FAvailableStartTime.free;
  FAvailableEndTime.free;
  inherited;
end;

procedure TFhirHealthcareServiceAvailableTime.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirHealthcareServiceAvailableTime(oSource).FDaysOfWeek = nil) then
  begin
    FDaysOfWeek.free;
    FDaysOfWeek := nil;
  end
  else
  begin
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDaysOfWeek.Assign(TFhirHealthcareServiceAvailableTime(oSource).FDaysOfWeek);
  end;
  allDayElement := TFhirHealthcareServiceAvailableTime(oSource).allDayElement.Clone;
  availableStartTimeElement := TFhirHealthcareServiceAvailableTime(oSource).availableStartTimeElement.Clone;
  availableEndTimeElement := TFhirHealthcareServiceAvailableTime(oSource).availableEndTimeElement.Clone;
end;

procedure TFhirHealthcareServiceAvailableTime.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'daysOfWeek') Then
     list.addAll(self, 'daysOfWeek', FDaysOfWeek);
  if (child_name = 'allDay') Then
     list.add(self.link, 'allDay', FAllDay.Link);
  if (child_name = 'availableStartTime') Then
     list.add(self.link, 'availableStartTime', FAvailableStartTime.Link);
  if (child_name = 'availableEndTime') Then
     list.add(self.link, 'availableEndTime', FAvailableEndTime.Link);
end;

procedure TFhirHealthcareServiceAvailableTime.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'daysOfWeek', 'code', true, TFhirEnum, FDaysOfWeek.Link));
  oList.add(TFHIRProperty.Create(self, 'allDay', 'boolean', false, TFhirBoolean, FAllDay.Link));
  oList.add(TFHIRProperty.Create(self, 'availableStartTime', 'time', false, TFhirTime, FAvailableStartTime.Link));
  oList.add(TFHIRProperty.Create(self, 'availableEndTime', 'time', false, TFhirTime, FAvailableEndTime.Link));
end;

function TFhirHealthcareServiceAvailableTime.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'daysOfWeek') then
  begin
    DaysOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue));
    result := propValue;
  end
  else if (propName = 'allDay') then
  begin
    AllDayElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'availableStartTime') then
  begin
    AvailableStartTimeElement := asTime(propValue);
    result := propValue;
  end
  else if (propName = 'availableEndTime') then
  begin
    AvailableEndTimeElement := asTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceAvailableTime.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue))
  else inherited;
end;

function TFhirHealthcareServiceAvailableTime.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allDay') then result := TFhirBoolean.Create()
  else if (propName = 'availableStartTime') then result := TFhirTime.Create()
  else if (propName = 'availableEndTime') then result := TFhirTime.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceAvailableTime.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'daysOfWeek') then result := 'code'
  else if (propName = 'allDay') then result := 'boolean'
  else if (propName = 'availableStartTime') then result := 'time'
  else if (propName = 'availableEndTime') then result := 'time'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceAvailableTime.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := nil
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := nil
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceAvailableTime.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := asBoolean(new)
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := asTime(new)
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := asTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceAvailableTime.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceAvailableTime.fhirType : string;
begin
  result := 'HealthcareService.availableTime';
end;

function TFhirHealthcareServiceAvailableTime.Link : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(inherited Link);
end;

function TFhirHealthcareServiceAvailableTime.Clone : TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(inherited Clone);
end;

function TFhirHealthcareServiceAvailableTime.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceAvailableTime;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceAvailableTime)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceAvailableTime(other);
    result := compareDeep(daysOfWeekList, o.daysOfWeekList, true) and compareDeep(allDayElement, o.allDayElement, true) and 
      compareDeep(availableStartTimeElement, o.availableStartTimeElement, true) and 
      compareDeep(availableEndTimeElement, o.availableEndTimeElement, true);
  end;
end;

function TFhirHealthcareServiceAvailableTime.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDaysOfWeek) and isEmptyProp(FAllDay) and isEmptyProp(FAvailableStartTime) and isEmptyProp(FAvailableEndTime);
end;

procedure TFhirHealthcareServiceAvailableTime.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('daysOfWeek');
  fields.add('allDay');
  fields.add('availableStartTime');
  fields.add('availableEndTime');
end;

function TFhirHealthcareServiceAvailableTime.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDaysOfWeek.sizeInBytes(magic));
end;

function TFhirHealthcareServiceAvailableTime.GetDaysOfWeek : TFhirEnumList;
begin
  if FDaysOfWeek = nil then
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDaysOfWeek;
end;

function TFhirHealthcareServiceAvailableTime.GetHasDaysOfWeek : boolean;
begin
  result := (FDaysOfWeek <> nil) and (FDaysOfWeek.count > 0);
end;

function TFhirHealthcareServiceAvailableTime.GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdaysOfWeek <> nil then
    for i := 0 to FdaysOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdaysOfWeek[i].value))];
end;

procedure TFhirHealthcareServiceAvailableTime.SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdaysOfWeek = nil then
    FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdaysOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdaysOfWeek = nil then
           FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdaysOfWeek.add(TFhirEnum.Create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

procedure TFhirHealthcareServiceAvailableTime.SetAllDay(value : TFhirBoolean);
begin
  FAllDay.free;
  FAllDay := value;
end;

function TFhirHealthcareServiceAvailableTime.GetAllDayST : Boolean;
begin
  if FAllDay = nil then
    result := false
  else
    result := FAllDay.value;
end;

procedure TFhirHealthcareServiceAvailableTime.SetAllDayST(value : Boolean);
begin
  if FAllDay = nil then
    FAllDay := TFhirBoolean.Create;
  FAllDay.value := value
end;

procedure TFhirHealthcareServiceAvailableTime.SetAvailableStartTime(value : TFhirTime);
begin
  FAvailableStartTime.free;
  FAvailableStartTime := value;
end;

function TFhirHealthcareServiceAvailableTime.GetAvailableStartTimeST : String;
begin
  if FAvailableStartTime = nil then
    result := ''
  else
    result := FAvailableStartTime.value;
end;

procedure TFhirHealthcareServiceAvailableTime.SetAvailableStartTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableStartTime = nil then
      FAvailableStartTime := TFhirTime.Create;
    FAvailableStartTime.value := value
  end
  else if FAvailableStartTime <> nil then
    FAvailableStartTime.value := '';
end;

procedure TFhirHealthcareServiceAvailableTime.SetAvailableEndTime(value : TFhirTime);
begin
  FAvailableEndTime.free;
  FAvailableEndTime := value;
end;

function TFhirHealthcareServiceAvailableTime.GetAvailableEndTimeST : String;
begin
  if FAvailableEndTime = nil then
    result := ''
  else
    result := FAvailableEndTime.value;
end;

procedure TFhirHealthcareServiceAvailableTime.SetAvailableEndTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableEndTime = nil then
      FAvailableEndTime := TFhirTime.Create;
    FAvailableEndTime.value := value
  end
  else if FAvailableEndTime <> nil then
    FAvailableEndTime.value := '';
end;

{ TFhirHealthcareServiceAvailableTimeListEnumerator }

constructor TFhirHealthcareServiceAvailableTimeListEnumerator.Create(list : TFhirHealthcareServiceAvailableTimeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceAvailableTimeListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirHealthcareServiceAvailableTimeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceAvailableTimeListEnumerator.GetCurrent : TFhirHealthcareServiceAvailableTime;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceAvailableTimeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceAvailableTimeList }

function TFhirHealthcareServiceAvailableTimeList.AddItem(value: TFhirHealthcareServiceAvailableTime): TFhirHealthcareServiceAvailableTime;
begin
  assert(value.ClassName = 'TFhirHealthcareServiceAvailableTime', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareServiceAvailableTime');
  add(value);
  result := value;
end;

function TFhirHealthcareServiceAvailableTimeList.Append: TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceAvailableTimeList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceAvailableTimeList.GetEnumerator : TFhirHealthcareServiceAvailableTimeListEnumerator;
begin
  result := TFhirHealthcareServiceAvailableTimeListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceAvailableTimeList.Clone: TFhirHealthcareServiceAvailableTimeList;
begin
  result := TFhirHealthcareServiceAvailableTimeList(inherited Clone);
end;

function TFhirHealthcareServiceAvailableTimeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceAvailableTimeList.GetItemN(index: Integer): TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceAvailableTimeList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceAvailableTime;
end;
function TFhirHealthcareServiceAvailableTimeList.IndexOf(value: TFhirHealthcareServiceAvailableTime): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceAvailableTimeList.Insert(index: Integer): TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceAvailableTimeList.InsertItem(index: Integer; value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value is TFhirHealthcareServiceAvailableTime);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceAvailableTimeList.Item(index: Integer): TFhirHealthcareServiceAvailableTime;
begin
  result := TFhirHealthcareServiceAvailableTime(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceAvailableTimeList.Link: TFhirHealthcareServiceAvailableTimeList;
begin
  result := TFhirHealthcareServiceAvailableTimeList(inherited Link);
end;

procedure TFhirHealthcareServiceAvailableTimeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceAvailableTimeList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value is TFhirHealthcareServiceAvailableTime);
  FhirHealthcareServiceAvailableTimes[index] := value;
end;

procedure TFhirHealthcareServiceAvailableTimeList.SetItemN(index: Integer; value: TFhirHealthcareServiceAvailableTime);
begin
  assert(value is TFhirHealthcareServiceAvailableTime);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareServiceNotAvailable }

constructor TFhirHealthcareServiceNotAvailable.Create;
begin
  inherited;
end;

destructor TFhirHealthcareServiceNotAvailable.Destroy;
begin
  FDescription.free;
  FDuring.free;
  inherited;
end;

procedure TFhirHealthcareServiceNotAvailable.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirHealthcareServiceNotAvailable(oSource).descriptionElement.Clone;
  during := TFhirHealthcareServiceNotAvailable(oSource).during.Clone;
end;

procedure TFhirHealthcareServiceNotAvailable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'during') Then
     list.add(self.link, 'during', FDuring.Link);
end;

procedure TFhirHealthcareServiceNotAvailable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.Create(self, 'during', 'Period', false, TFhirPeriod, FDuring.Link));
end;

function TFhirHealthcareServiceNotAvailable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'during') then
  begin
    During := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareServiceNotAvailable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirHealthcareServiceNotAvailable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.Create()
  else if (propName = 'during') then result := TFhirPeriod.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareServiceNotAvailable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'during') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareServiceNotAvailable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'during') then DuringElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareServiceNotAvailable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'during') then DuringElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareServiceNotAvailable.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareServiceNotAvailable.fhirType : string;
begin
  result := 'HealthcareService.notAvailable';
end;

function TFhirHealthcareServiceNotAvailable.Link : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(inherited Link);
end;

function TFhirHealthcareServiceNotAvailable.Clone : TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(inherited Clone);
end;

function TFhirHealthcareServiceNotAvailable.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareServiceNotAvailable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareServiceNotAvailable)) then
    result := false
  else
  begin
    o := TFhirHealthcareServiceNotAvailable(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(duringElement, o.duringElement, true);
  end;
end;

function TFhirHealthcareServiceNotAvailable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FDuring);
end;

procedure TFhirHealthcareServiceNotAvailable.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('during');
end;

function TFhirHealthcareServiceNotAvailable.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirHealthcareServiceNotAvailable.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirHealthcareServiceNotAvailable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirHealthcareServiceNotAvailable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.Create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirHealthcareServiceNotAvailable.SetDuring(value : TFhirPeriod);
begin
  FDuring.free;
  FDuring := value;
end;

{ TFhirHealthcareServiceNotAvailableListEnumerator }

constructor TFhirHealthcareServiceNotAvailableListEnumerator.Create(list : TFhirHealthcareServiceNotAvailableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceNotAvailableListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirHealthcareServiceNotAvailableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceNotAvailableListEnumerator.GetCurrent : TFhirHealthcareServiceNotAvailable;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceNotAvailableListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceNotAvailableList }

function TFhirHealthcareServiceNotAvailableList.AddItem(value: TFhirHealthcareServiceNotAvailable): TFhirHealthcareServiceNotAvailable;
begin
  assert(value.ClassName = 'TFhirHealthcareServiceNotAvailable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareServiceNotAvailable');
  add(value);
  result := value;
end;

function TFhirHealthcareServiceNotAvailableList.Append: TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceNotAvailableList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceNotAvailableList.GetEnumerator : TFhirHealthcareServiceNotAvailableListEnumerator;
begin
  result := TFhirHealthcareServiceNotAvailableListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceNotAvailableList.Clone: TFhirHealthcareServiceNotAvailableList;
begin
  result := TFhirHealthcareServiceNotAvailableList(inherited Clone);
end;

function TFhirHealthcareServiceNotAvailableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceNotAvailableList.GetItemN(index: Integer): TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceNotAvailableList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareServiceNotAvailable;
end;
function TFhirHealthcareServiceNotAvailableList.IndexOf(value: TFhirHealthcareServiceNotAvailable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceNotAvailableList.Insert(index: Integer): TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceNotAvailableList.InsertItem(index: Integer; value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value is TFhirHealthcareServiceNotAvailable);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceNotAvailableList.Item(index: Integer): TFhirHealthcareServiceNotAvailable;
begin
  result := TFhirHealthcareServiceNotAvailable(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceNotAvailableList.Link: TFhirHealthcareServiceNotAvailableList;
begin
  result := TFhirHealthcareServiceNotAvailableList(inherited Link);
end;

procedure TFhirHealthcareServiceNotAvailableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceNotAvailableList.SetItemByIndex(index: Integer; value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value is TFhirHealthcareServiceNotAvailable);
  FhirHealthcareServiceNotAvailables[index] := value;
end;

procedure TFhirHealthcareServiceNotAvailableList.SetItemN(index: Integer; value: TFhirHealthcareServiceNotAvailable);
begin
  assert(value is TFhirHealthcareServiceNotAvailable);
  ObjectByIndex[index] := value;
end;

{ TFhirHealthcareService }

constructor TFhirHealthcareService.Create;
begin
  inherited;
end;

destructor TFhirHealthcareService.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FProvidedBy.free;
  FCategoryList.free;
  FType_List.free;
  FSpecialtyList.free;
  FLocationList.free;
  FName.free;
  FComment.free;
  FExtraDetails.free;
  FPhoto.free;
  FTelecomList.free;
  FCoverageAreaList.free;
  FServiceProvisionCodeList.free;
  FEligibilityList.free;
  FProgram_List.free;
  FCharacteristicList.free;
  FCommunicationList.free;
  FReferralMethodList.free;
  FAppointmentRequired.free;
  FAvailableTimeList.free;
  FNotAvailableList.free;
  FAvailabilityExceptions.free;
  FEndpointList.free;
  inherited;
end;

procedure TFhirHealthcareService.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirHealthcareService(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirHealthcareService(oSource).FIdentifierList);
  end;
  activeElement := TFhirHealthcareService(oSource).activeElement.Clone;
  providedBy := TFhirHealthcareService(oSource).providedBy.Clone;
  if (TFhirHealthcareService(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirHealthcareService(oSource).FCategoryList);
  end;
  if (TFhirHealthcareService(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirHealthcareService(oSource).FType_List);
  end;
  if (TFhirHealthcareService(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirHealthcareService(oSource).FSpecialtyList);
  end;
  if (TFhirHealthcareService(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList.Create;
    FLocationList.Assign(TFhirHealthcareService(oSource).FLocationList);
  end;
  nameElement := TFhirHealthcareService(oSource).nameElement.Clone;
  commentElement := TFhirHealthcareService(oSource).commentElement.Clone;
  extraDetailsElement := TFhirHealthcareService(oSource).extraDetailsElement.Clone;
  photo := TFhirHealthcareService(oSource).photo.Clone;
  if (TFhirHealthcareService(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirHealthcareService(oSource).FTelecomList);
  end;
  if (TFhirHealthcareService(oSource).FCoverageAreaList = nil) then
  begin
    FCoverageAreaList.free;
    FCoverageAreaList := nil;
  end
  else
  begin
    if FCoverageAreaList = nil then
      FCoverageAreaList := TFhirReferenceList.Create;
    FCoverageAreaList.Assign(TFhirHealthcareService(oSource).FCoverageAreaList);
  end;
  if (TFhirHealthcareService(oSource).FServiceProvisionCodeList = nil) then
  begin
    FServiceProvisionCodeList.free;
    FServiceProvisionCodeList := nil;
  end
  else
  begin
    if FServiceProvisionCodeList = nil then
      FServiceProvisionCodeList := TFhirCodeableConceptList.Create;
    FServiceProvisionCodeList.Assign(TFhirHealthcareService(oSource).FServiceProvisionCodeList);
  end;
  if (TFhirHealthcareService(oSource).FEligibilityList = nil) then
  begin
    FEligibilityList.free;
    FEligibilityList := nil;
  end
  else
  begin
    if FEligibilityList = nil then
      FEligibilityList := TFhirHealthcareServiceEligibilityList.Create;
    FEligibilityList.Assign(TFhirHealthcareService(oSource).FEligibilityList);
  end;
  if (TFhirHealthcareService(oSource).FProgram_List = nil) then
  begin
    FProgram_List.free;
    FProgram_List := nil;
  end
  else
  begin
    if FProgram_List = nil then
      FProgram_List := TFhirCodeableConceptList.Create;
    FProgram_List.Assign(TFhirHealthcareService(oSource).FProgram_List);
  end;
  if (TFhirHealthcareService(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirCodeableConceptList.Create;
    FCharacteristicList.Assign(TFhirHealthcareService(oSource).FCharacteristicList);
  end;
  if (TFhirHealthcareService(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirCodeableConceptList.Create;
    FCommunicationList.Assign(TFhirHealthcareService(oSource).FCommunicationList);
  end;
  if (TFhirHealthcareService(oSource).FReferralMethodList = nil) then
  begin
    FReferralMethodList.free;
    FReferralMethodList := nil;
  end
  else
  begin
    if FReferralMethodList = nil then
      FReferralMethodList := TFhirCodeableConceptList.Create;
    FReferralMethodList.Assign(TFhirHealthcareService(oSource).FReferralMethodList);
  end;
  appointmentRequiredElement := TFhirHealthcareService(oSource).appointmentRequiredElement.Clone;
  if (TFhirHealthcareService(oSource).FAvailableTimeList = nil) then
  begin
    FAvailableTimeList.free;
    FAvailableTimeList := nil;
  end
  else
  begin
    if FAvailableTimeList = nil then
      FAvailableTimeList := TFhirHealthcareServiceAvailableTimeList.Create;
    FAvailableTimeList.Assign(TFhirHealthcareService(oSource).FAvailableTimeList);
  end;
  if (TFhirHealthcareService(oSource).FNotAvailableList = nil) then
  begin
    FNotAvailableList.free;
    FNotAvailableList := nil;
  end
  else
  begin
    if FNotAvailableList = nil then
      FNotAvailableList := TFhirHealthcareServiceNotAvailableList.Create;
    FNotAvailableList.Assign(TFhirHealthcareService(oSource).FNotAvailableList);
  end;
  availabilityExceptionsElement := TFhirHealthcareService(oSource).availabilityExceptionsElement.Clone;
  if (TFhirHealthcareService(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirHealthcareService(oSource).FEndpointList);
  end;
end;

function TFhirHealthcareService.GetResourceType : TFhirResourceType;
begin
  result := frtHealthcareService;
end;

procedure TFhirHealthcareService.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'providedBy') Then
     list.add(self.link, 'providedBy', FProvidedBy.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
  if (child_name = 'extraDetails') Then
     list.add(self.link, 'extraDetails', FExtraDetails.Link);
  if (child_name = 'photo') Then
     list.add(self.link, 'photo', FPhoto.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'coverageArea') Then
    list.addAll(self, 'coverageArea', FCoverageAreaList);
  if (child_name = 'serviceProvisionCode') Then
    list.addAll(self, 'serviceProvisionCode', FServiceProvisionCodeList);
  if (child_name = 'eligibility') Then
    list.addAll(self, 'eligibility', FEligibilityList);
  if (child_name = 'program') Then
    list.addAll(self, 'program', FProgram_List);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
  if (child_name = 'referralMethod') Then
    list.addAll(self, 'referralMethod', FReferralMethodList);
  if (child_name = 'appointmentRequired') Then
     list.add(self.link, 'appointmentRequired', FAppointmentRequired.Link);
  if (child_name = 'availableTime') Then
    list.addAll(self, 'availableTime', FAvailableTimeList);
  if (child_name = 'notAvailable') Then
    list.addAll(self, 'notAvailable', FNotAvailableList);
  if (child_name = 'availabilityExceptions') Then
     list.add(self.link, 'availabilityExceptions', FAvailabilityExceptions.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirHealthcareService.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'providedBy', 'Reference', false, TFhirReference, FProvidedBy.Link));
  oList.add(TFHIRProperty.Create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference', true, TFhirReference, FLocationList.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.Create(self, 'comment', 'string', false, TFhirString, FComment.Link));
  oList.add(TFHIRProperty.Create(self, 'extraDetails', 'markdown', false, TFhirMarkdown, FExtraDetails.Link));
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', false, TFhirAttachment, FPhoto.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'coverageArea', 'Reference', true, TFhirReference, FCoverageAreaList.Link));
  oList.add(TFHIRProperty.Create(self, 'serviceProvisionCode', 'CodeableConcept', true, TFhirCodeableConcept, FServiceProvisionCodeList.Link));
  oList.add(TFHIRProperty.Create(self, 'eligibility', 'BackboneElement', true, TFhirHealthcareServiceEligibility, FEligibilityList.Link));
  oList.add(TFHIRProperty.Create(self, 'program', 'CodeableConcept', true, TFhirCodeableConcept, FProgram_List.Link));
  oList.add(TFHIRProperty.Create(self, 'characteristic', 'CodeableConcept', true, TFhirCodeableConcept, FCharacteristicList.Link));
  oList.add(TFHIRProperty.Create(self, 'communication', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationList.Link));
  oList.add(TFHIRProperty.Create(self, 'referralMethod', 'CodeableConcept', true, TFhirCodeableConcept, FReferralMethodList.Link));
  oList.add(TFHIRProperty.Create(self, 'appointmentRequired', 'boolean', false, TFhirBoolean, FAppointmentRequired.Link));
  oList.add(TFHIRProperty.Create(self, 'availableTime', 'BackboneElement', true, TFhirHealthcareServiceAvailableTime, FAvailableTimeList.Link));
  oList.add(TFHIRProperty.Create(self, 'notAvailable', 'BackboneElement', true, TFhirHealthcareServiceNotAvailable, FNotAvailableList.Link));
  oList.add(TFHIRProperty.Create(self, 'availabilityExceptions', 'string', false, TFhirString, FAvailabilityExceptions.Link));
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
end;

function TFhirHealthcareService.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'providedBy') then
  begin
    ProvidedBy := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'extraDetails') then
  begin
    ExtraDetailsElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    Photo := propValue as TFhirAttachment;
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'coverageArea') then
  begin
    CoverageAreaList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'serviceProvisionCode') then
  begin
    ServiceProvisionCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'eligibility') then
  begin
    EligibilityList.add(propValue as TFhirHealthcareServiceEligibility);
    result := propValue;
  end
  else if (propName = 'program') then
  begin
    Program_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'referralMethod') then
  begin
    ReferralMethodList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'appointmentRequired') then
  begin
    AppointmentRequiredElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'availableTime') then
  begin
    AvailableTimeList.add(propValue as TFhirHealthcareServiceAvailableTime);
    result := propValue;
  end
  else if (propName = 'notAvailable') then
  begin
    NotAvailableList.add(propValue as TFhirHealthcareServiceNotAvailable);
    result := propValue;
  end
  else if (propName = 'availabilityExceptions') then
  begin
    AvailabilityExceptionsElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirHealthcareService.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'coverageArea') then CoverageAreaList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'serviceProvisionCode') then ServiceProvisionCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'eligibility') then EligibilityList.insertItem(index, propValue as TFhirHealthcareServiceEligibility)
  else if (propName = 'program') then Program_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'referralMethod') then ReferralMethodList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'availableTime') then AvailableTimeList.insertItem(index, propValue as TFhirHealthcareServiceAvailableTime)
  else if (propName = 'notAvailable') then NotAvailableList.insertItem(index, propValue as TFhirHealthcareServiceNotAvailable)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirHealthcareService.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'providedBy') then result := TFhirReference.Create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'name') then result := TFhirString.Create()
  else if (propName = 'comment') then result := TFhirString.Create()
  else if (propName = 'extraDetails') then result := TFhirMarkdown.Create()
  else if (propName = 'photo') then result := TFhirAttachment.Create()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'coverageArea') then result := CoverageAreaList.new()
  else if (propName = 'serviceProvisionCode') then result := ServiceProvisionCodeList.new()
  else if (propName = 'eligibility') then result := EligibilityList.new()
  else if (propName = 'program') then result := Program_List.new()
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'communication') then result := CommunicationList.new()
  else if (propName = 'referralMethod') then result := ReferralMethodList.new()
  else if (propName = 'appointmentRequired') then result := TFhirBoolean.Create()
  else if (propName = 'availableTime') then result := AvailableTimeList.new()
  else if (propName = 'notAvailable') then result := NotAvailableList.new()
  else if (propName = 'availabilityExceptions') then result := TFhirString.Create()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirHealthcareService.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'providedBy') then result := 'Reference'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'extraDetails') then result := 'markdown'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'coverageArea') then result := 'Reference'
  else if (propName = 'serviceProvisionCode') then result := 'CodeableConcept'
  else if (propName = 'eligibility') then result := 'BackboneElement'
  else if (propName = 'program') then result := 'CodeableConcept'
  else if (propName = 'characteristic') then result := 'CodeableConcept'
  else if (propName = 'communication') then result := 'CodeableConcept'
  else if (propName = 'referralMethod') then result := 'CodeableConcept'
  else if (propName = 'appointmentRequired') then result := 'boolean'
  else if (propName = 'availableTime') then result := 'BackboneElement'
  else if (propName = 'notAvailable') then result := 'BackboneElement'
  else if (propName = 'availabilityExceptions') then result := 'string'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirHealthcareService.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'providedBy') then ProvidedByElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else if (propName = 'extraDetails') then ExtraDetailsElement := nil
  else if (propName = 'photo') then PhotoElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'coverageArea') then deletePropertyValue('coverageArea', CoverageAreaList, value)
  else if (propName = 'serviceProvisionCode') then deletePropertyValue('serviceProvisionCode', ServiceProvisionCodeList, value)
  else if (propName = 'eligibility') then deletePropertyValue('eligibility', EligibilityList, value)
  else if (propName = 'program') then deletePropertyValue('program', Program_List, value)
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value)
  else if (propName = 'referralMethod') then deletePropertyValue('referralMethod', ReferralMethodList, value)
  else if (propName = 'appointmentRequired') then AppointmentRequiredElement := nil
  else if (propName = 'availableTime') then deletePropertyValue('availableTime', AvailableTimeList, value)
  else if (propName = 'notAvailable') then deletePropertyValue('notAvailable', NotAvailableList, value)
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirHealthcareService.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'providedBy') then ProvidedByElement := new as TFhirReference
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else if (propName = 'extraDetails') then ExtraDetailsElement := asMarkdown(new)
  else if (propName = 'photo') then PhotoElement := new as TFhirAttachment
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'coverageArea') then replacePropertyValue('coverageArea', CoverageAreaList, existing, new)
  else if (propName = 'serviceProvisionCode') then replacePropertyValue('serviceProvisionCode', ServiceProvisionCodeList, existing, new)
  else if (propName = 'eligibility') then replacePropertyValue('eligibility', EligibilityList, existing, new)
  else if (propName = 'program') then replacePropertyValue('program', Program_List, existing, new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new)
  else if (propName = 'referralMethod') then replacePropertyValue('referralMethod', ReferralMethodList, existing, new)
  else if (propName = 'appointmentRequired') then AppointmentRequiredElement := asBoolean(new)
  else if (propName = 'availableTime') then replacePropertyValue('availableTime', AvailableTimeList, existing, new)
  else if (propName = 'notAvailable') then replacePropertyValue('notAvailable', NotAvailableList, existing, new)
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := asString(new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirHealthcareService.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'coverageArea') then CoverageAreaList.move(source, destination)
  else if (propName = 'serviceProvisionCode') then ServiceProvisionCodeList.move(source, destination)
  else if (propName = 'eligibility') then EligibilityList.move(source, destination)
  else if (propName = 'program') then Program_List.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'communication') then CommunicationList.move(source, destination)
  else if (propName = 'referralMethod') then ReferralMethodList.move(source, destination)
  else if (propName = 'availableTime') then AvailableTimeList.move(source, destination)
  else if (propName = 'notAvailable') then NotAvailableList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirHealthcareService.fhirType : string;
begin
  result := 'HealthcareService';
end;

function TFhirHealthcareService.Link : TFhirHealthcareService;
begin
  result := TFhirHealthcareService(inherited Link);
end;

function TFhirHealthcareService.Clone : TFhirHealthcareService;
begin
  result := TFhirHealthcareService(inherited Clone);
end;

function TFhirHealthcareService.equals(other : TObject) : boolean; 
var
  o : TFhirHealthcareService;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirHealthcareService)) then
    result := false
  else
  begin
    o := TFhirHealthcareService(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(providedByElement, o.providedByElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(specialtyList, o.specialtyList, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(commentElement, o.commentElement, true) and compareDeep(extraDetailsElement, o.extraDetailsElement, true) and 
      compareDeep(photoElement, o.photoElement, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(coverageAreaList, o.coverageAreaList, true) and compareDeep(serviceProvisionCodeList, o.serviceProvisionCodeList, true) and 
      compareDeep(eligibilityList, o.eligibilityList, true) and compareDeep(program_List, o.program_List, true) and 
      compareDeep(characteristicList, o.characteristicList, true) and compareDeep(communicationList, o.communicationList, true) and 
      compareDeep(referralMethodList, o.referralMethodList, true) and compareDeep(appointmentRequiredElement, o.appointmentRequiredElement, true) and 
      compareDeep(availableTimeList, o.availableTimeList, true) and compareDeep(notAvailableList, o.notAvailableList, true) and 
      compareDeep(availabilityExceptionsElement, o.availabilityExceptionsElement, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirHealthcareService.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FProvidedBy) and isEmptyProp(FcategoryList) and isEmptyProp(Ftype_List) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FName) and isEmptyProp(FComment) and isEmptyProp(FExtraDetails) and isEmptyProp(FPhoto) and isEmptyProp(FtelecomList) and isEmptyProp(FcoverageAreaList) and isEmptyProp(FserviceProvisionCodeList) and isEmptyProp(FeligibilityList) and isEmptyProp(Fprogram_List) and isEmptyProp(FcharacteristicList) and isEmptyProp(FcommunicationList) and isEmptyProp(FreferralMethodList) and isEmptyProp(FAppointmentRequired) and isEmptyProp(FavailableTimeList) and isEmptyProp(FnotAvailableList) and isEmptyProp(FAvailabilityExceptions) and isEmptyProp(FendpointList);
end;

procedure TFhirHealthcareService.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('providedBy');
  fields.add('category');
  fields.add('type');
  fields.add('specialty');
  fields.add('location');
  fields.add('name');
  fields.add('comment');
  fields.add('extraDetails');
  fields.add('photo');
  fields.add('telecom');
  fields.add('coverageArea');
  fields.add('serviceProvisionCode');
  fields.add('eligibility');
  fields.add('program');
  fields.add('characteristic');
  fields.add('communication');
  fields.add('referralMethod');
  fields.add('appointmentRequired');
  fields.add('availableTime');
  fields.add('notAvailable');
  fields.add('availabilityExceptions');
  fields.add('endpoint');
end;

function TFhirHealthcareService.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FCoverageAreaList.sizeInBytes(magic));
  inc(result, FServiceProvisionCodeList.sizeInBytes(magic));
  inc(result, FEligibilityList.sizeInBytes(magic));
  inc(result, FProgram_List.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FCommunicationList.sizeInBytes(magic));
  inc(result, FReferralMethodList.sizeInBytes(magic));
  inc(result, FAvailableTimeList.sizeInBytes(magic));
  inc(result, FNotAvailableList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
end;

function TFhirHealthcareService.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirHealthcareService.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirHealthcareService.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirHealthcareService.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirHealthcareService.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

procedure TFhirHealthcareService.SetProvidedBy(value : TFhirReference);
begin
  FProvidedBy.free;
  FProvidedBy := value;
end;

function TFhirHealthcareService.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirHealthcareService.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

function TFhirHealthcareService.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirHealthcareService.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirHealthcareService.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirHealthcareService.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirHealthcareService.GetLocationList : TFhirReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList.Create;
  result := FLocationList;
end;

function TFhirHealthcareService.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

procedure TFhirHealthcareService.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirHealthcareService.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirHealthcareService.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirHealthcareService.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirHealthcareService.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirHealthcareService.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.Create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

procedure TFhirHealthcareService.SetExtraDetails(value : TFhirMarkdown);
begin
  FExtraDetails.free;
  FExtraDetails := value;
end;

function TFhirHealthcareService.GetExtraDetailsST : String;
begin
  if FExtraDetails = nil then
    result := ''
  else
    result := FExtraDetails.value;
end;

procedure TFhirHealthcareService.SetExtraDetailsST(value : String);
begin
  if value <> '' then
  begin
    if FExtraDetails = nil then
      FExtraDetails := TFhirMarkdown.Create;
    FExtraDetails.value := value
  end
  else if FExtraDetails <> nil then
    FExtraDetails.value := '';
end;

procedure TFhirHealthcareService.SetPhoto(value : TFhirAttachment);
begin
  FPhoto.free;
  FPhoto := value;
end;

function TFhirHealthcareService.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirHealthcareService.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirHealthcareService.GetCoverageAreaList : TFhirReferenceList;
begin
  if FCoverageAreaList = nil then
    FCoverageAreaList := TFhirReferenceList.Create;
  result := FCoverageAreaList;
end;

function TFhirHealthcareService.GetHasCoverageAreaList : boolean;
begin
  result := (FCoverageAreaList <> nil) and (FCoverageAreaList.count > 0);
end;

function TFhirHealthcareService.GetServiceProvisionCodeList : TFhirCodeableConceptList;
begin
  if FServiceProvisionCodeList = nil then
    FServiceProvisionCodeList := TFhirCodeableConceptList.Create;
  result := FServiceProvisionCodeList;
end;

function TFhirHealthcareService.GetHasServiceProvisionCodeList : boolean;
begin
  result := (FServiceProvisionCodeList <> nil) and (FServiceProvisionCodeList.count > 0);
end;

function TFhirHealthcareService.GetEligibilityList : TFhirHealthcareServiceEligibilityList;
begin
  if FEligibilityList = nil then
    FEligibilityList := TFhirHealthcareServiceEligibilityList.Create;
  result := FEligibilityList;
end;

function TFhirHealthcareService.GetHasEligibilityList : boolean;
begin
  result := (FEligibilityList <> nil) and (FEligibilityList.count > 0);
end;

function TFhirHealthcareService.GetProgram_List : TFhirCodeableConceptList;
begin
  if FProgram_List = nil then
    FProgram_List := TFhirCodeableConceptList.Create;
  result := FProgram_List;
end;

function TFhirHealthcareService.GetHasProgram_List : boolean;
begin
  result := (FProgram_List <> nil) and (FProgram_List.count > 0);
end;

function TFhirHealthcareService.GetCharacteristicList : TFhirCodeableConceptList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirCodeableConceptList.Create;
  result := FCharacteristicList;
end;

function TFhirHealthcareService.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirHealthcareService.GetCommunicationList : TFhirCodeableConceptList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirCodeableConceptList.Create;
  result := FCommunicationList;
end;

function TFhirHealthcareService.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

function TFhirHealthcareService.GetReferralMethodList : TFhirCodeableConceptList;
begin
  if FReferralMethodList = nil then
    FReferralMethodList := TFhirCodeableConceptList.Create;
  result := FReferralMethodList;
end;

function TFhirHealthcareService.GetHasReferralMethodList : boolean;
begin
  result := (FReferralMethodList <> nil) and (FReferralMethodList.count > 0);
end;

procedure TFhirHealthcareService.SetAppointmentRequired(value : TFhirBoolean);
begin
  FAppointmentRequired.free;
  FAppointmentRequired := value;
end;

function TFhirHealthcareService.GetAppointmentRequiredST : Boolean;
begin
  if FAppointmentRequired = nil then
    result := false
  else
    result := FAppointmentRequired.value;
end;

procedure TFhirHealthcareService.SetAppointmentRequiredST(value : Boolean);
begin
  if FAppointmentRequired = nil then
    FAppointmentRequired := TFhirBoolean.Create;
  FAppointmentRequired.value := value
end;

function TFhirHealthcareService.GetAvailableTimeList : TFhirHealthcareServiceAvailableTimeList;
begin
  if FAvailableTimeList = nil then
    FAvailableTimeList := TFhirHealthcareServiceAvailableTimeList.Create;
  result := FAvailableTimeList;
end;

function TFhirHealthcareService.GetHasAvailableTimeList : boolean;
begin
  result := (FAvailableTimeList <> nil) and (FAvailableTimeList.count > 0);
end;

function TFhirHealthcareService.GetNotAvailableList : TFhirHealthcareServiceNotAvailableList;
begin
  if FNotAvailableList = nil then
    FNotAvailableList := TFhirHealthcareServiceNotAvailableList.Create;
  result := FNotAvailableList;
end;

function TFhirHealthcareService.GetHasNotAvailableList : boolean;
begin
  result := (FNotAvailableList <> nil) and (FNotAvailableList.count > 0);
end;

procedure TFhirHealthcareService.SetAvailabilityExceptions(value : TFhirString);
begin
  FAvailabilityExceptions.free;
  FAvailabilityExceptions := value;
end;

function TFhirHealthcareService.GetAvailabilityExceptionsST : String;
begin
  if FAvailabilityExceptions = nil then
    result := ''
  else
    result := FAvailabilityExceptions.value;
end;

procedure TFhirHealthcareService.SetAvailabilityExceptionsST(value : String);
begin
  if value <> '' then
  begin
    if FAvailabilityExceptions = nil then
      FAvailabilityExceptions := TFhirString.Create;
    FAvailabilityExceptions.value := value
  end
  else if FAvailabilityExceptions <> nil then
    FAvailabilityExceptions.value := '';
end;

function TFhirHealthcareService.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirHealthcareService.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

{ TFhirHealthcareServiceListEnumerator }

constructor TFhirHealthcareServiceListEnumerator.Create(list : TFhirHealthcareServiceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirHealthcareServiceListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirHealthcareServiceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirHealthcareServiceListEnumerator.GetCurrent : TFhirHealthcareService;
begin
  Result := FList[FIndex];
end;

function TFhirHealthcareServiceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirHealthcareServiceList }

function TFhirHealthcareServiceList.AddItem(value: TFhirHealthcareService): TFhirHealthcareService;
begin
  assert(value.ClassName = 'TFhirHealthcareService', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirHealthcareService');
  add(value);
  result := value;
end;

function TFhirHealthcareServiceList.Append: TFhirHealthcareService;
begin
  result := TFhirHealthcareService.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceList.ClearItems;
begin
  Clear;
end;

function TFhirHealthcareServiceList.GetEnumerator : TFhirHealthcareServiceListEnumerator;
begin
  result := TFhirHealthcareServiceListEnumerator.Create(self.link);
end;

function TFhirHealthcareServiceList.Clone: TFhirHealthcareServiceList;
begin
  result := TFhirHealthcareServiceList(inherited Clone);
end;

function TFhirHealthcareServiceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirHealthcareServiceList.GetItemN(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceList.ItemClass: TFslObjectClass;
begin
  result := TFhirHealthcareService;
end;
function TFhirHealthcareServiceList.IndexOf(value: TFhirHealthcareService): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirHealthcareServiceList.Insert(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirHealthcareServiceList.InsertItem(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  Inherited Insert(index, value);
end;

function TFhirHealthcareServiceList.Item(index: Integer): TFhirHealthcareService;
begin
  result := TFhirHealthcareService(ObjectByIndex[index]);
end;

function TFhirHealthcareServiceList.Link: TFhirHealthcareServiceList;
begin
  result := TFhirHealthcareServiceList(inherited Link);
end;

procedure TFhirHealthcareServiceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirHealthcareServiceList.SetItemByIndex(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  FhirHealthcareServices[index] := value;
end;

procedure TFhirHealthcareServiceList.SetItemN(index: Integer; value: TFhirHealthcareService);
begin
  assert(value is TFhirHealthcareService);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_HEALTHCARESERVICE}
{$IFDEF FHIR_LOCATION}
{ TFhirLocationPosition }

constructor TFhirLocationPosition.Create;
begin
  inherited;
end;

destructor TFhirLocationPosition.Destroy;
begin
  FLongitude.free;
  FLatitude.free;
  FAltitude.free;
  inherited;
end;

procedure TFhirLocationPosition.Assign(oSource : TFslObject);
begin
  inherited;
  longitudeElement := TFhirLocationPosition(oSource).longitudeElement.Clone;
  latitudeElement := TFhirLocationPosition(oSource).latitudeElement.Clone;
  altitudeElement := TFhirLocationPosition(oSource).altitudeElement.Clone;
end;

procedure TFhirLocationPosition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'longitude') Then
     list.add(self.link, 'longitude', FLongitude.Link);
  if (child_name = 'latitude') Then
     list.add(self.link, 'latitude', FLatitude.Link);
  if (child_name = 'altitude') Then
     list.add(self.link, 'altitude', FAltitude.Link);
end;

procedure TFhirLocationPosition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'longitude', 'decimal', false, TFhirDecimal, FLongitude.Link));
  oList.add(TFHIRProperty.Create(self, 'latitude', 'decimal', false, TFhirDecimal, FLatitude.Link));
  oList.add(TFHIRProperty.Create(self, 'altitude', 'decimal', false, TFhirDecimal, FAltitude.Link));
end;

function TFhirLocationPosition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'longitude') then
  begin
    LongitudeElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'latitude') then
  begin
    LatitudeElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'altitude') then
  begin
    AltitudeElement := asDecimal(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocationPosition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirLocationPosition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'longitude') then result := TFhirDecimal.Create()
  else if (propName = 'latitude') then result := TFhirDecimal.Create()
  else if (propName = 'altitude') then result := TFhirDecimal.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocationPosition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'longitude') then result := 'decimal'
  else if (propName = 'latitude') then result := 'decimal'
  else if (propName = 'altitude') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocationPosition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'longitude') then LongitudeElement := nil
  else if (propName = 'latitude') then LatitudeElement := nil
  else if (propName = 'altitude') then AltitudeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocationPosition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'longitude') then LongitudeElement := asDecimal(new)
  else if (propName = 'latitude') then LatitudeElement := asDecimal(new)
  else if (propName = 'altitude') then AltitudeElement := asDecimal(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocationPosition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirLocationPosition.fhirType : string;
begin
  result := 'Location.position';
end;

function TFhirLocationPosition.Link : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Link);
end;

function TFhirLocationPosition.Clone : TFhirLocationPosition;
begin
  result := TFhirLocationPosition(inherited Clone);
end;

function TFhirLocationPosition.equals(other : TObject) : boolean; 
var
  o : TFhirLocationPosition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocationPosition)) then
    result := false
  else
  begin
    o := TFhirLocationPosition(other);
    result := compareDeep(longitudeElement, o.longitudeElement, true) and compareDeep(latitudeElement, o.latitudeElement, true) and 
      compareDeep(altitudeElement, o.altitudeElement, true);
  end;
end;

function TFhirLocationPosition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLongitude) and isEmptyProp(FLatitude) and isEmptyProp(FAltitude);
end;

procedure TFhirLocationPosition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('longitude');
  fields.add('latitude');
  fields.add('altitude');
end;

function TFhirLocationPosition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirLocationPosition.SetLongitude(value : TFhirDecimal);
begin
  FLongitude.free;
  FLongitude := value;
end;

function TFhirLocationPosition.GetLongitudeST : String;
begin
  if FLongitude = nil then
    result := ''
  else
    result := FLongitude.value;
end;

procedure TFhirLocationPosition.SetLongitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLongitude = nil then
      FLongitude := TFhirDecimal.Create;
    FLongitude.value := value
  end
  else if FLongitude <> nil then
    FLongitude.value := '';
end;

procedure TFhirLocationPosition.SetLatitude(value : TFhirDecimal);
begin
  FLatitude.free;
  FLatitude := value;
end;

function TFhirLocationPosition.GetLatitudeST : String;
begin
  if FLatitude = nil then
    result := ''
  else
    result := FLatitude.value;
end;

procedure TFhirLocationPosition.SetLatitudeST(value : String);
begin
  if value <> '' then
  begin
    if FLatitude = nil then
      FLatitude := TFhirDecimal.Create;
    FLatitude.value := value
  end
  else if FLatitude <> nil then
    FLatitude.value := '';
end;

procedure TFhirLocationPosition.SetAltitude(value : TFhirDecimal);
begin
  FAltitude.free;
  FAltitude := value;
end;

function TFhirLocationPosition.GetAltitudeST : String;
begin
  if FAltitude = nil then
    result := ''
  else
    result := FAltitude.value;
end;

procedure TFhirLocationPosition.SetAltitudeST(value : String);
begin
  if value <> '' then
  begin
    if FAltitude = nil then
      FAltitude := TFhirDecimal.Create;
    FAltitude.value := value
  end
  else if FAltitude <> nil then
    FAltitude.value := '';
end;

{ TFhirLocationPositionListEnumerator }

constructor TFhirLocationPositionListEnumerator.Create(list : TFhirLocationPositionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationPositionListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirLocationPositionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationPositionListEnumerator.GetCurrent : TFhirLocationPosition;
begin
  Result := FList[FIndex];
end;

function TFhirLocationPositionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLocationPositionList }

function TFhirLocationPositionList.AddItem(value: TFhirLocationPosition): TFhirLocationPosition;
begin
  assert(value.ClassName = 'TFhirLocationPosition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocationPosition');
  add(value);
  result := value;
end;

function TFhirLocationPositionList.Append: TFhirLocationPosition;
begin
  result := TFhirLocationPosition.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationPositionList.ClearItems;
begin
  Clear;
end;

function TFhirLocationPositionList.GetEnumerator : TFhirLocationPositionListEnumerator;
begin
  result := TFhirLocationPositionListEnumerator.Create(self.link);
end;

function TFhirLocationPositionList.Clone: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Clone);
end;

function TFhirLocationPositionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationPositionList.GetItemN(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocationPosition;
end;
function TFhirLocationPositionList.IndexOf(value: TFhirLocationPosition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationPositionList.Insert(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationPositionList.InsertItem(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  Inherited Insert(index, value);
end;

function TFhirLocationPositionList.Item(index: Integer): TFhirLocationPosition;
begin
  result := TFhirLocationPosition(ObjectByIndex[index]);
end;

function TFhirLocationPositionList.Link: TFhirLocationPositionList;
begin
  result := TFhirLocationPositionList(inherited Link);
end;

procedure TFhirLocationPositionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationPositionList.SetItemByIndex(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  FhirLocationPositions[index] := value;
end;

procedure TFhirLocationPositionList.SetItemN(index: Integer; value: TFhirLocationPosition);
begin
  assert(value is TFhirLocationPosition);
  ObjectByIndex[index] := value;
end;

{ TFhirLocationHoursOfOperation }

constructor TFhirLocationHoursOfOperation.Create;
begin
  inherited;
end;

destructor TFhirLocationHoursOfOperation.Destroy;
begin
  FDaysOfWeek.free;
  FAllDay.free;
  FOpeningTime.free;
  FClosingTime.free;
  inherited;
end;

procedure TFhirLocationHoursOfOperation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirLocationHoursOfOperation(oSource).FDaysOfWeek = nil) then
  begin
    FDaysOfWeek.free;
    FDaysOfWeek := nil;
  end
  else
  begin
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDaysOfWeek.Assign(TFhirLocationHoursOfOperation(oSource).FDaysOfWeek);
  end;
  allDayElement := TFhirLocationHoursOfOperation(oSource).allDayElement.Clone;
  openingTimeElement := TFhirLocationHoursOfOperation(oSource).openingTimeElement.Clone;
  closingTimeElement := TFhirLocationHoursOfOperation(oSource).closingTimeElement.Clone;
end;

procedure TFhirLocationHoursOfOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'daysOfWeek') Then
     list.addAll(self, 'daysOfWeek', FDaysOfWeek);
  if (child_name = 'allDay') Then
     list.add(self.link, 'allDay', FAllDay.Link);
  if (child_name = 'openingTime') Then
     list.add(self.link, 'openingTime', FOpeningTime.Link);
  if (child_name = 'closingTime') Then
     list.add(self.link, 'closingTime', FClosingTime.Link);
end;

procedure TFhirLocationHoursOfOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'daysOfWeek', 'code', true, TFhirEnum, FDaysOfWeek.Link));
  oList.add(TFHIRProperty.Create(self, 'allDay', 'boolean', false, TFhirBoolean, FAllDay.Link));
  oList.add(TFHIRProperty.Create(self, 'openingTime', 'time', false, TFhirTime, FOpeningTime.Link));
  oList.add(TFHIRProperty.Create(self, 'closingTime', 'time', false, TFhirTime, FClosingTime.Link));
end;

function TFhirLocationHoursOfOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'daysOfWeek') then
  begin
    DaysOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue));
    result := propValue;
  end
  else if (propName = 'allDay') then
  begin
    AllDayElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'openingTime') then
  begin
    OpeningTimeElement := asTime(propValue);
    result := propValue;
  end
  else if (propName = 'closingTime') then
  begin
    ClosingTimeElement := asTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocationHoursOfOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue))
  else inherited;
end;

function TFhirLocationHoursOfOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allDay') then result := TFhirBoolean.Create()
  else if (propName = 'openingTime') then result := TFhirTime.Create()
  else if (propName = 'closingTime') then result := TFhirTime.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocationHoursOfOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'daysOfWeek') then result := 'code'
  else if (propName = 'allDay') then result := 'boolean'
  else if (propName = 'openingTime') then result := 'time'
  else if (propName = 'closingTime') then result := 'time'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocationHoursOfOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := nil
  else if (propName = 'openingTime') then OpeningTimeElement := nil
  else if (propName = 'closingTime') then ClosingTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocationHoursOfOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := asBoolean(new)
  else if (propName = 'openingTime') then OpeningTimeElement := asTime(new)
  else if (propName = 'closingTime') then ClosingTimeElement := asTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocationHoursOfOperation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLocationHoursOfOperation.fhirType : string;
begin
  result := 'Location.hoursOfOperation';
end;

function TFhirLocationHoursOfOperation.Link : TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(inherited Link);
end;

function TFhirLocationHoursOfOperation.Clone : TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(inherited Clone);
end;

function TFhirLocationHoursOfOperation.equals(other : TObject) : boolean; 
var
  o : TFhirLocationHoursOfOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocationHoursOfOperation)) then
    result := false
  else
  begin
    o := TFhirLocationHoursOfOperation(other);
    result := compareDeep(daysOfWeekList, o.daysOfWeekList, true) and compareDeep(allDayElement, o.allDayElement, true) and 
      compareDeep(openingTimeElement, o.openingTimeElement, true) and compareDeep(closingTimeElement, o.closingTimeElement, true);
  end;
end;

function TFhirLocationHoursOfOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDaysOfWeek) and isEmptyProp(FAllDay) and isEmptyProp(FOpeningTime) and isEmptyProp(FClosingTime);
end;

procedure TFhirLocationHoursOfOperation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('daysOfWeek');
  fields.add('allDay');
  fields.add('openingTime');
  fields.add('closingTime');
end;

function TFhirLocationHoursOfOperation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDaysOfWeek.sizeInBytes(magic));
end;

function TFhirLocationHoursOfOperation.GetDaysOfWeek : TFhirEnumList;
begin
  if FDaysOfWeek = nil then
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDaysOfWeek;
end;

function TFhirLocationHoursOfOperation.GetHasDaysOfWeek : boolean;
begin
  result := (FDaysOfWeek <> nil) and (FDaysOfWeek.count > 0);
end;

function TFhirLocationHoursOfOperation.GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdaysOfWeek <> nil then
    for i := 0 to FdaysOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdaysOfWeek[i].value))];
end;

procedure TFhirLocationHoursOfOperation.SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdaysOfWeek = nil then
    FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdaysOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdaysOfWeek = nil then
           FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdaysOfWeek.add(TFhirEnum.Create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

procedure TFhirLocationHoursOfOperation.SetAllDay(value : TFhirBoolean);
begin
  FAllDay.free;
  FAllDay := value;
end;

function TFhirLocationHoursOfOperation.GetAllDayST : Boolean;
begin
  if FAllDay = nil then
    result := false
  else
    result := FAllDay.value;
end;

procedure TFhirLocationHoursOfOperation.SetAllDayST(value : Boolean);
begin
  if FAllDay = nil then
    FAllDay := TFhirBoolean.Create;
  FAllDay.value := value
end;

procedure TFhirLocationHoursOfOperation.SetOpeningTime(value : TFhirTime);
begin
  FOpeningTime.free;
  FOpeningTime := value;
end;

function TFhirLocationHoursOfOperation.GetOpeningTimeST : String;
begin
  if FOpeningTime = nil then
    result := ''
  else
    result := FOpeningTime.value;
end;

procedure TFhirLocationHoursOfOperation.SetOpeningTimeST(value : String);
begin
  if value <> '' then
  begin
    if FOpeningTime = nil then
      FOpeningTime := TFhirTime.Create;
    FOpeningTime.value := value
  end
  else if FOpeningTime <> nil then
    FOpeningTime.value := '';
end;

procedure TFhirLocationHoursOfOperation.SetClosingTime(value : TFhirTime);
begin
  FClosingTime.free;
  FClosingTime := value;
end;

function TFhirLocationHoursOfOperation.GetClosingTimeST : String;
begin
  if FClosingTime = nil then
    result := ''
  else
    result := FClosingTime.value;
end;

procedure TFhirLocationHoursOfOperation.SetClosingTimeST(value : String);
begin
  if value <> '' then
  begin
    if FClosingTime = nil then
      FClosingTime := TFhirTime.Create;
    FClosingTime.value := value
  end
  else if FClosingTime <> nil then
    FClosingTime.value := '';
end;

{ TFhirLocationHoursOfOperationListEnumerator }

constructor TFhirLocationHoursOfOperationListEnumerator.Create(list : TFhirLocationHoursOfOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationHoursOfOperationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirLocationHoursOfOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationHoursOfOperationListEnumerator.GetCurrent : TFhirLocationHoursOfOperation;
begin
  Result := FList[FIndex];
end;

function TFhirLocationHoursOfOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLocationHoursOfOperationList }

function TFhirLocationHoursOfOperationList.AddItem(value: TFhirLocationHoursOfOperation): TFhirLocationHoursOfOperation;
begin
  assert(value.ClassName = 'TFhirLocationHoursOfOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocationHoursOfOperation');
  add(value);
  result := value;
end;

function TFhirLocationHoursOfOperationList.Append: TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationHoursOfOperationList.ClearItems;
begin
  Clear;
end;

function TFhirLocationHoursOfOperationList.GetEnumerator : TFhirLocationHoursOfOperationListEnumerator;
begin
  result := TFhirLocationHoursOfOperationListEnumerator.Create(self.link);
end;

function TFhirLocationHoursOfOperationList.Clone: TFhirLocationHoursOfOperationList;
begin
  result := TFhirLocationHoursOfOperationList(inherited Clone);
end;

function TFhirLocationHoursOfOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationHoursOfOperationList.GetItemN(index: Integer): TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(ObjectByIndex[index]);
end;

function TFhirLocationHoursOfOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocationHoursOfOperation;
end;
function TFhirLocationHoursOfOperationList.IndexOf(value: TFhirLocationHoursOfOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationHoursOfOperationList.Insert(index: Integer): TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationHoursOfOperationList.InsertItem(index: Integer; value: TFhirLocationHoursOfOperation);
begin
  assert(value is TFhirLocationHoursOfOperation);
  Inherited Insert(index, value);
end;

function TFhirLocationHoursOfOperationList.Item(index: Integer): TFhirLocationHoursOfOperation;
begin
  result := TFhirLocationHoursOfOperation(ObjectByIndex[index]);
end;

function TFhirLocationHoursOfOperationList.Link: TFhirLocationHoursOfOperationList;
begin
  result := TFhirLocationHoursOfOperationList(inherited Link);
end;

procedure TFhirLocationHoursOfOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationHoursOfOperationList.SetItemByIndex(index: Integer; value: TFhirLocationHoursOfOperation);
begin
  assert(value is TFhirLocationHoursOfOperation);
  FhirLocationHoursOfOperations[index] := value;
end;

procedure TFhirLocationHoursOfOperationList.SetItemN(index: Integer; value: TFhirLocationHoursOfOperation);
begin
  assert(value is TFhirLocationHoursOfOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirLocation }

constructor TFhirLocation.Create;
begin
  inherited;
end;

destructor TFhirLocation.Destroy;
begin
  FIdentifierList.free;
  FStatus.free;
  FOperationalStatus.free;
  FName.free;
  FAliasList.free;
  FDescription.free;
  FMode.free;
  FType_List.free;
  FTelecomList.free;
  FAddress.free;
  FPhysicalType.free;
  FPosition.free;
  FManagingOrganization.free;
  FPartOf.free;
  FHoursOfOperationList.free;
  FAvailabilityExceptions.free;
  FEndpointList.free;
  inherited;
end;

procedure TFhirLocation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirLocation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirLocation(oSource).FIdentifierList);
  end;
  statusElement := TFhirLocation(oSource).statusElement.Clone;
  operationalStatus := TFhirLocation(oSource).operationalStatus.Clone;
  nameElement := TFhirLocation(oSource).nameElement.Clone;
  if (TFhirLocation(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirLocation(oSource).FAliasList);
  end;
  descriptionElement := TFhirLocation(oSource).descriptionElement.Clone;
  modeElement := TFhirLocation(oSource).modeElement.Clone;
  if (TFhirLocation(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirLocation(oSource).FType_List);
  end;
  if (TFhirLocation(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirLocation(oSource).FTelecomList);
  end;
  address := TFhirLocation(oSource).address.Clone;
  physicalType := TFhirLocation(oSource).physicalType.Clone;
  position := TFhirLocation(oSource).position.Clone;
  managingOrganization := TFhirLocation(oSource).managingOrganization.Clone;
  partOf := TFhirLocation(oSource).partOf.Clone;
  if (TFhirLocation(oSource).FHoursOfOperationList = nil) then
  begin
    FHoursOfOperationList.free;
    FHoursOfOperationList := nil;
  end
  else
  begin
    if FHoursOfOperationList = nil then
      FHoursOfOperationList := TFhirLocationHoursOfOperationList.Create;
    FHoursOfOperationList.Assign(TFhirLocation(oSource).FHoursOfOperationList);
  end;
  availabilityExceptionsElement := TFhirLocation(oSource).availabilityExceptionsElement.Clone;
  if (TFhirLocation(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirLocation(oSource).FEndpointList);
  end;
end;

function TFhirLocation.GetResourceType : TFhirResourceType;
begin
  result := frtLocation;
end;

procedure TFhirLocation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'operationalStatus') Then
     list.add(self.link, 'operationalStatus', FOperationalStatus.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'physicalType') Then
     list.add(self.link, 'physicalType', FPhysicalType.Link);
  if (child_name = 'position') Then
     list.add(self.link, 'position', FPosition.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
  if (child_name = 'hoursOfOperation') Then
    list.addAll(self, 'hoursOfOperation', FHoursOfOperationList);
  if (child_name = 'availabilityExceptions') Then
     list.add(self.link, 'availabilityExceptions', FAvailabilityExceptions.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirLocation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'operationalStatus', 'Coding', false, TFhirCoding, FOperationalStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.Create(self, 'alias', 'string', true, TFhirString, FAliasList.Link));
  oList.add(TFHIRProperty.Create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.Create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));
  oList.add(TFHIRProperty.Create(self, 'physicalType', 'CodeableConcept', false, TFhirCodeableConcept, FPhysicalType.Link));
  oList.add(TFHIRProperty.Create(self, 'position', 'BackboneElement', false, TFhirLocationPosition, FPosition.Link));
  oList.add(TFHIRProperty.Create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link));
  oList.add(TFHIRProperty.Create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link));
  oList.add(TFHIRProperty.Create(self, 'hoursOfOperation', 'BackboneElement', true, TFhirLocationHoursOfOperation, FHoursOfOperationList.Link));
  oList.add(TFHIRProperty.Create(self, 'availabilityExceptions', 'string', false, TFhirString, FAvailabilityExceptions.Link));
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
end;

function TFhirLocation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirLocationStatusEnum, CODES_TFhirLocationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'operationalStatus') then
  begin
    OperationalStatus := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirLocationModeEnum, CODES_TFhirLocationModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress;
    result := propValue;
  end
  else if (propName = 'physicalType') then
  begin
    PhysicalType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'position') then
  begin
    Position := propValue as TFhirLocationPosition;
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'hoursOfOperation') then
  begin
    HoursOfOperationList.add(propValue as TFhirLocationHoursOfOperation);
    result := propValue;
  end
  else if (propName = 'availabilityExceptions') then
  begin
    AvailabilityExceptionsElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLocation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue))
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'hoursOfOperation') then HoursOfOperationList.insertItem(index, propValue as TFhirLocationHoursOfOperation)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirLocation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.Create(SYSTEMS_TFhirLocationStatusEnum[LocationStatusNull], CODES_TFhirLocationStatusEnum[LocationStatusNull]) 
  else if (propName = 'operationalStatus') then result := TFhirCoding.Create()
  else if (propName = 'name') then result := TFhirString.Create()
  else if (propName = 'alias') then result := AliasList.new()
  else if (propName = 'description') then result := TFhirString.Create()
  else if (propName = 'mode') then result := TFhirEnum.Create(SYSTEMS_TFhirLocationModeEnum[LocationModeNull], CODES_TFhirLocationModeEnum[LocationModeNull]) 
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'address') then result := TFhirAddress.Create()
  else if (propName = 'physicalType') then result := TFhirCodeableConcept.Create()
  else if (propName = 'position') then result := TFhirLocationPosition.Create()
  else if (propName = 'managingOrganization') then result := TFhirReference.Create()
  else if (propName = 'partOf') then result := TFhirReference.Create()
  else if (propName = 'hoursOfOperation') then result := HoursOfOperationList.new()
  else if (propName = 'availabilityExceptions') then result := TFhirString.Create()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLocation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'operationalStatus') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'physicalType') then result := 'CodeableConcept'
  else if (propName = 'position') then result := 'BackboneElement'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'hoursOfOperation') then result := 'BackboneElement'
  else if (propName = 'availabilityExceptions') then result := 'string'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLocation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'operationalStatus') then OperationalStatusElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'physicalType') then PhysicalTypeElement := nil
  else if (propName = 'position') then PositionElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'partOf') then PartOfElement := nil
  else if (propName = 'hoursOfOperation') then deletePropertyValue('hoursOfOperation', HoursOfOperationList, value)
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLocation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirLocationStatusEnum, CODES_TFhirLocationStatusEnum, new)
  else if (propName = 'operationalStatus') then OperationalStatusElement := new as TFhirCoding
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirLocationModeEnum, CODES_TFhirLocationModeEnum, new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'address') then AddressElement := new as TFhirAddress
  else if (propName = 'physicalType') then PhysicalTypeElement := new as TFhirCodeableConcept
  else if (propName = 'position') then PositionElement := new as TFhirLocationPosition
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference
  else if (propName = 'hoursOfOperation') then replacePropertyValue('hoursOfOperation', HoursOfOperationList, existing, new)
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := asString(new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLocation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'alias') then AliasList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'hoursOfOperation') then HoursOfOperationList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLocation.fhirType : string;
begin
  result := 'Location';
end;

function TFhirLocation.Link : TFhirLocation;
begin
  result := TFhirLocation(inherited Link);
end;

function TFhirLocation.Clone : TFhirLocation;
begin
  result := TFhirLocation(inherited Clone);
end;

function TFhirLocation.equals(other : TObject) : boolean; 
var
  o : TFhirLocation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLocation)) then
    result := false
  else
  begin
    o := TFhirLocation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(operationalStatusElement, o.operationalStatusElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(modeElement, o.modeElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true) and 
      compareDeep(physicalTypeElement, o.physicalTypeElement, true) and compareDeep(positionElement, o.positionElement, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(partOfElement, o.partOfElement, true) and compareDeep(hoursOfOperationList, o.hoursOfOperationList, true) and 
      compareDeep(availabilityExceptionsElement, o.availabilityExceptionsElement, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirLocation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FOperationalStatus) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FDescription) and isEmptyProp(FMode) and isEmptyProp(Ftype_List) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress) and isEmptyProp(FPhysicalType) and isEmptyProp(FPosition) and isEmptyProp(FManagingOrganization) and isEmptyProp(FPartOf) and isEmptyProp(FhoursOfOperationList) and isEmptyProp(FAvailabilityExceptions) and isEmptyProp(FendpointList);
end;

procedure TFhirLocation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('operationalStatus');
  fields.add('name');
  fields.add('alias');
  fields.add('description');
  fields.add('mode');
  fields.add('type');
  fields.add('telecom');
  fields.add('address');
  fields.add('physicalType');
  fields.add('position');
  fields.add('managingOrganization');
  fields.add('partOf');
  fields.add('hoursOfOperation');
  fields.add('availabilityExceptions');
  fields.add('endpoint');
end;

function TFhirLocation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FAliasList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FHoursOfOperationList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
end;

function TFhirLocation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirLocation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirLocation.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirLocation.GetStatusST : TFhirLocationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirLocationStatusEnum(0)
  else
    result := TFhirLocationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirLocationStatusEnum, FStatus.value));
end;

procedure TFhirLocation.SetStatusST(value : TFhirLocationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirLocationStatusEnum[value], CODES_TFhirLocationStatusEnum[value]);
end;

procedure TFhirLocation.SetOperationalStatus(value : TFhirCoding);
begin
  FOperationalStatus.free;
  FOperationalStatus := value;
end;

procedure TFhirLocation.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirLocation.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirLocation.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirLocation.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirLocation.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

procedure TFhirLocation.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirLocation.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirLocation.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.Create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirLocation.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirLocation.GetModeST : TFhirLocationModeEnum;
begin
  if FMode = nil then
    result := TFhirLocationModeEnum(0)
  else
    result := TFhirLocationModeEnum(StringArrayIndexOfSensitive(CODES_TFhirLocationModeEnum, FMode.value));
end;

procedure TFhirLocation.SetModeST(value : TFhirLocationModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.Create(SYSTEMS_TFhirLocationModeEnum[value], CODES_TFhirLocationModeEnum[value]);
end;

function TFhirLocation.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirLocation.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirLocation.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirLocation.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirLocation.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

procedure TFhirLocation.SetPhysicalType(value : TFhirCodeableConcept);
begin
  FPhysicalType.free;
  FPhysicalType := value;
end;

procedure TFhirLocation.SetPosition(value : TFhirLocationPosition);
begin
  FPosition.free;
  FPosition := value;
end;

procedure TFhirLocation.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

procedure TFhirLocation.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value;
end;

function TFhirLocation.GetHoursOfOperationList : TFhirLocationHoursOfOperationList;
begin
  if FHoursOfOperationList = nil then
    FHoursOfOperationList := TFhirLocationHoursOfOperationList.Create;
  result := FHoursOfOperationList;
end;

function TFhirLocation.GetHasHoursOfOperationList : boolean;
begin
  result := (FHoursOfOperationList <> nil) and (FHoursOfOperationList.count > 0);
end;

procedure TFhirLocation.SetAvailabilityExceptions(value : TFhirString);
begin
  FAvailabilityExceptions.free;
  FAvailabilityExceptions := value;
end;

function TFhirLocation.GetAvailabilityExceptionsST : String;
begin
  if FAvailabilityExceptions = nil then
    result := ''
  else
    result := FAvailabilityExceptions.value;
end;

procedure TFhirLocation.SetAvailabilityExceptionsST(value : String);
begin
  if value <> '' then
  begin
    if FAvailabilityExceptions = nil then
      FAvailabilityExceptions := TFhirString.Create;
    FAvailabilityExceptions.value := value
  end
  else if FAvailabilityExceptions <> nil then
    FAvailabilityExceptions.value := '';
end;

function TFhirLocation.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirLocation.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

{ TFhirLocationListEnumerator }

constructor TFhirLocationListEnumerator.Create(list : TFhirLocationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLocationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirLocationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLocationListEnumerator.GetCurrent : TFhirLocation;
begin
  Result := FList[FIndex];
end;

function TFhirLocationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLocationList }

function TFhirLocationList.AddItem(value: TFhirLocation): TFhirLocation;
begin
  assert(value.ClassName = 'TFhirLocation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLocation');
  add(value);
  result := value;
end;

function TFhirLocationList.Append: TFhirLocation;
begin
  result := TFhirLocation.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationList.ClearItems;
begin
  Clear;
end;

function TFhirLocationList.GetEnumerator : TFhirLocationListEnumerator;
begin
  result := TFhirLocationListEnumerator.Create(self.link);
end;

function TFhirLocationList.Clone: TFhirLocationList;
begin
  result := TFhirLocationList(inherited Clone);
end;

function TFhirLocationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLocationList.GetItemN(index: Integer): TFhirLocation;
begin
  result := TFhirLocation(ObjectByIndex[index]);
end;

function TFhirLocationList.ItemClass: TFslObjectClass;
begin
  result := TFhirLocation;
end;
function TFhirLocationList.IndexOf(value: TFhirLocation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLocationList.Insert(index: Integer): TFhirLocation;
begin
  result := TFhirLocation.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLocationList.InsertItem(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  Inherited Insert(index, value);
end;

function TFhirLocationList.Item(index: Integer): TFhirLocation;
begin
  result := TFhirLocation(ObjectByIndex[index]);
end;

function TFhirLocationList.Link: TFhirLocationList;
begin
  result := TFhirLocationList(inherited Link);
end;

procedure TFhirLocationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLocationList.SetItemByIndex(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  FhirLocations[index] := value;
end;

procedure TFhirLocationList.SetItemN(index: Integer; value: TFhirLocation);
begin
  assert(value is TFhirLocation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LOCATION}
{$IFDEF FHIR_MEDIA}
{ TFhirMedia }

constructor TFhirMedia.Create;
begin
  inherited;
end;

destructor TFhirMedia.Destroy;
begin
  FIdentifierList.free;
  FBasedOnList.free;
  FPartOfList.free;
  FStatus.free;
  FType_.free;
  FModality.free;
  FView.free;
  FSubject.free;
  FEncounter.free;
  FCreated.free;
  FIssued.free;
  FOperator.free;
  FReasonCodeList.free;
  FBodySite.free;
  FDeviceName.free;
  FDevice.free;
  FHeight.free;
  FWidth.free;
  FFrames.free;
  FDuration.free;
  FContent.free;
  FNoteList.free;
  inherited;
end;

procedure TFhirMedia.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMedia(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMedia(oSource).FIdentifierList);
  end;
  if (TFhirMedia(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirMedia(oSource).FBasedOnList);
  end;
  if (TFhirMedia(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirMedia(oSource).FPartOfList);
  end;
  statusElement := TFhirMedia(oSource).statusElement.Clone;
  type_ := TFhirMedia(oSource).type_.Clone;
  modality := TFhirMedia(oSource).modality.Clone;
  view := TFhirMedia(oSource).view.Clone;
  subject := TFhirMedia(oSource).subject.Clone;
  encounter := TFhirMedia(oSource).encounter.Clone;
  created := TFhirMedia(oSource).created.Clone;
  issuedElement := TFhirMedia(oSource).issuedElement.Clone;
  operator := TFhirMedia(oSource).operator.Clone;
  if (TFhirMedia(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirMedia(oSource).FReasonCodeList);
  end;
  bodySite := TFhirMedia(oSource).bodySite.Clone;
  deviceNameElement := TFhirMedia(oSource).deviceNameElement.Clone;
  device := TFhirMedia(oSource).device.Clone;
  heightElement := TFhirMedia(oSource).heightElement.Clone;
  widthElement := TFhirMedia(oSource).widthElement.Clone;
  framesElement := TFhirMedia(oSource).framesElement.Clone;
  durationElement := TFhirMedia(oSource).durationElement.Clone;
  content := TFhirMedia(oSource).content.Clone;
  if (TFhirMedia(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirMedia(oSource).FNoteList);
  end;
end;

function TFhirMedia.GetResourceType : TFhirResourceType;
begin
  result := frtMedia;
end;

procedure TFhirMedia.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'modality') Then
     list.add(self.link, 'modality', FModality.Link);
  if (child_name = 'view') Then
     list.add(self.link, 'view', FView.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'created[x]') or (child_name = 'created') Then
     list.add(self.link, 'created[x]', FCreated.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'operator') Then
     list.add(self.link, 'operator', FOperator.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'bodySite') Then
     list.add(self.link, 'bodySite', FBodySite.Link);
  if (child_name = 'deviceName') Then
     list.add(self.link, 'deviceName', FDeviceName.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'height') Then
     list.add(self.link, 'height', FHeight.Link);
  if (child_name = 'width') Then
     list.add(self.link, 'width', FWidth.Link);
  if (child_name = 'frames') Then
     list.add(self.link, 'frames', FFrames.Link);
  if (child_name = 'duration') Then
     list.add(self.link, 'duration', FDuration.Link);
  if (child_name = 'content') Then
     list.add(self.link, 'content', FContent.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirMedia.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.Create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.Create(self, 'modality', 'CodeableConcept', false, TFhirCodeableConcept, FModality.Link));
  oList.add(TFHIRProperty.Create(self, 'view', 'CodeableConcept', false, TFhirCodeableConcept, FView.Link));
  oList.add(TFHIRProperty.Create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.Create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.Create(self, 'created[x]', 'dateTime|Period', false, TFhirDataType, FCreated.Link));
  oList.add(TFHIRProperty.Create(self, 'issued', 'instant', false, TFhirInstant, FIssued.Link));
  oList.add(TFHIRProperty.Create(self, 'operator', 'Reference', false, TFhirReference, FOperator.Link));
  oList.add(TFHIRProperty.Create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.Create(self, 'bodySite', 'CodeableConcept', false, TFhirCodeableConcept, FBodySite.Link));
  oList.add(TFHIRProperty.Create(self, 'deviceName', 'string', false, TFhirString, FDeviceName.Link));
  oList.add(TFHIRProperty.Create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link));
  oList.add(TFHIRProperty.Create(self, 'height', 'positiveInt', false, TFhirPositiveInt, FHeight.Link));
  oList.add(TFHIRProperty.Create(self, 'width', 'positiveInt', false, TFhirPositiveInt, FWidth.Link));
  oList.add(TFHIRProperty.Create(self, 'frames', 'positiveInt', false, TFhirPositiveInt, FFrames.Link));
  oList.add(TFHIRProperty.Create(self, 'duration', 'decimal', false, TFhirDecimal, FDuration.Link));
  oList.add(TFHIRProperty.Create(self, 'content', 'Attachment', false, TFhirAttachment, FContent.Link));
  oList.add(TFHIRProperty.Create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirMedia.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'modality') then
  begin
    Modality := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'view') then
  begin
    View := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (isMatchingName(propName, 'created', ['DateTime', 'Period'])) then
  begin
    Created := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'operator') then
  begin
    Operator := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySite := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'deviceName') then
  begin
    DeviceNameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'height') then
  begin
    HeightElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'width') then
  begin
    WidthElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'frames') then
  begin
    FramesElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'duration') then
  begin
    DurationElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'content') then
  begin
    Content := propValue as TFhirAttachment;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMedia.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirMedia.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.Create(SYSTEMS_TFhirEventStatusEnum[EventStatusNull], CODES_TFhirEventStatusEnum[EventStatusNull]) 
  else if (propName = 'type') then result := TFhirCodeableConcept.Create()
  else if (propName = 'modality') then result := TFhirCodeableConcept.Create()
  else if (propName = 'view') then result := TFhirCodeableConcept.Create()
  else if (propName = 'subject') then result := TFhirReference.Create()
  else if (propName = 'encounter') then result := TFhirReference.Create()
  else if (isMatchingName(propName, 'created', ['DateTime', 'Period'])) then raise EFHIRException.Create('Cannot make property Created')
  else if (propName = 'issued') then result := TFhirInstant.Create()
  else if (propName = 'operator') then result := TFhirReference.Create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'bodySite') then result := TFhirCodeableConcept.Create()
  else if (propName = 'deviceName') then result := TFhirString.Create()
  else if (propName = 'device') then result := TFhirReference.Create()
  else if (propName = 'height') then result := TFhirPositiveInt.Create()
  else if (propName = 'width') then result := TFhirPositiveInt.Create()
  else if (propName = 'frames') then result := TFhirPositiveInt.Create()
  else if (propName = 'duration') then result := TFhirDecimal.Create()
  else if (propName = 'content') then result := TFhirAttachment.Create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMedia.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'modality') then result := 'CodeableConcept'
  else if (propName = 'view') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'created[x]') then result := 'dateTime|Period'
  else if (propName = 'issued') then result := 'instant'
  else if (propName = 'operator') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'deviceName') then result := 'string'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'height') then result := 'positiveInt'
  else if (propName = 'width') then result := 'positiveInt'
  else if (propName = 'frames') then result := 'positiveInt'
  else if (propName = 'duration') then result := 'decimal'
  else if (propName = 'content') then result := 'Attachment'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMedia.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'modality') then ModalityElement := nil
  else if (propName = 'view') then ViewElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (isMatchingName(propName, 'created', ['DateTime', 'Period'])) then CreatedElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'operator') then OperatorElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'bodySite') then BodySiteElement := nil
  else if (propName = 'deviceName') then DeviceNameElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'height') then HeightElement := nil
  else if (propName = 'width') then WidthElement := nil
  else if (propName = 'frames') then FramesElement := nil
  else if (propName = 'duration') then DurationElement := nil
  else if (propName = 'content') then ContentElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMedia.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirEventStatusEnum, CODES_TFhirEventStatusEnum, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'modality') then ModalityElement := new as TFhirCodeableConcept
  else if (propName = 'view') then ViewElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (isMatchingName(propName, 'created', ['DateTime', 'Period'])) then CreatedElement := new as TFhirDataType
  else if (propName = 'issued') then IssuedElement := asInstant(new)
  else if (propName = 'operator') then OperatorElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'bodySite') then BodySiteElement := new as TFhirCodeableConcept
  else if (propName = 'deviceName') then DeviceNameElement := asString(new)
  else if (propName = 'device') then DeviceElement := new as TFhirReference
  else if (propName = 'height') then HeightElement := asPositiveInt(new)
  else if (propName = 'width') then WidthElement := asPositiveInt(new)
  else if (propName = 'frames') then FramesElement := asPositiveInt(new)
  else if (propName = 'duration') then DurationElement := asDecimal(new)
  else if (propName = 'content') then ContentElement := new as TFhirAttachment
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMedia.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMedia.fhirType : string;
begin
  result := 'Media';
end;

function TFhirMedia.Link : TFhirMedia;
begin
  result := TFhirMedia(inherited Link);
end;

function TFhirMedia.Clone : TFhirMedia;
begin
  result := TFhirMedia(inherited Clone);
end;

function TFhirMedia.equals(other : TObject) : boolean; 
var
  o : TFhirMedia;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMedia)) then
    result := false
  else
  begin
    o := TFhirMedia(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(modalityElement, o.modalityElement, true) and 
      compareDeep(viewElement, o.viewElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(createdElement, o.createdElement, true) and 
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(operatorElement, o.operatorElement, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(bodySiteElement, o.bodySiteElement, true) and 
      compareDeep(deviceNameElement, o.deviceNameElement, true) and compareDeep(deviceElement, o.deviceElement, true) and 
      compareDeep(heightElement, o.heightElement, true) and compareDeep(widthElement, o.widthElement, true) and 
      compareDeep(framesElement, o.framesElement, true) and compareDeep(durationElement, o.durationElement, true) and 
      compareDeep(contentElement, o.contentElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirMedia.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FModality) and isEmptyProp(FView) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FCreated) and isEmptyProp(FIssued) and isEmptyProp(FOperator) and isEmptyProp(FreasonCodeList) and isEmptyProp(FBodySite) and isEmptyProp(FDeviceName) and isEmptyProp(FDevice) and isEmptyProp(FHeight) and isEmptyProp(FWidth) and isEmptyProp(FFrames) and isEmptyProp(FDuration) and isEmptyProp(FContent) and isEmptyProp(FnoteList);
end;

procedure TFhirMedia.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('status');
  fields.add('type');
  fields.add('modality');
  fields.add('view');
  fields.add('subject');
  fields.add('encounter');
  fields.add('created[x]');
  fields.add('issued');
  fields.add('operator');
  fields.add('reasonCode');
  fields.add('bodySite');
  fields.add('deviceName');
  fields.add('device');
  fields.add('height');
  fields.add('width');
  fields.add('frames');
  fields.add('duration');
  fields.add('content');
  fields.add('note');
end;

function TFhirMedia.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirMedia.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMedia.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirMedia.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirMedia.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirMedia.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirMedia.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirMedia.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMedia.GetStatusST : TFhirEventStatusEnum;
begin
  if FStatus = nil then
    result := TFhirEventStatusEnum(0)
  else
    result := TFhirEventStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirEventStatusEnum, FStatus.value));
end;

procedure TFhirMedia.SetStatusST(value : TFhirEventStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirEventStatusEnum[value], CODES_TFhirEventStatusEnum[value]);
end;

procedure TFhirMedia.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirMedia.SetModality(value : TFhirCodeableConcept);
begin
  FModality.free;
  FModality := value;
end;

procedure TFhirMedia.SetView(value : TFhirCodeableConcept);
begin
  FView.free;
  FView := value;
end;

procedure TFhirMedia.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirMedia.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirMedia.SetCreated(value : TFhirDataType);
begin
  FCreated.free;
  FCreated := value;
end;

procedure TFhirMedia.SetIssued(value : TFhirInstant);
begin
  FIssued.free;
  FIssued := value;
end;

function TFhirMedia.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirMedia.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirInstant.Create;
  FIssued.value := value
end;

procedure TFhirMedia.SetOperator(value : TFhirReference);
begin
  FOperator.free;
  FOperator := value;
end;

function TFhirMedia.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirMedia.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

procedure TFhirMedia.SetBodySite(value : TFhirCodeableConcept);
begin
  FBodySite.free;
  FBodySite := value;
end;

procedure TFhirMedia.SetDeviceName(value : TFhirString);
begin
  FDeviceName.free;
  FDeviceName := value;
end;

function TFhirMedia.GetDeviceNameST : String;
begin
  if FDeviceName = nil then
    result := ''
  else
    result := FDeviceName.value;
end;

procedure TFhirMedia.SetDeviceNameST(value : String);
begin
  if value <> '' then
  begin
    if FDeviceName = nil then
      FDeviceName := TFhirString.Create;
    FDeviceName.value := value
  end
  else if FDeviceName <> nil then
    FDeviceName.value := '';
end;

procedure TFhirMedia.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value;
end;

procedure TFhirMedia.SetHeight(value : TFhirPositiveInt);
begin
  FHeight.free;
  FHeight := value;
end;

function TFhirMedia.GetHeightST : String;
begin
  if FHeight = nil then
    result := ''
  else
    result := FHeight.value;
end;

procedure TFhirMedia.SetHeightST(value : String);
begin
  if value <> '' then
  begin
    if FHeight = nil then
      FHeight := TFhirPositiveInt.Create;
    FHeight.value := value
  end
  else if FHeight <> nil then
    FHeight.value := '';
end;

procedure TFhirMedia.SetWidth(value : TFhirPositiveInt);
begin
  FWidth.free;
  FWidth := value;
end;

function TFhirMedia.GetWidthST : String;
begin
  if FWidth = nil then
    result := ''
  else
    result := FWidth.value;
end;

procedure TFhirMedia.SetWidthST(value : String);
begin
  if value <> '' then
  begin
    if FWidth = nil then
      FWidth := TFhirPositiveInt.Create;
    FWidth.value := value
  end
  else if FWidth <> nil then
    FWidth.value := '';
end;

procedure TFhirMedia.SetFrames(value : TFhirPositiveInt);
begin
  FFrames.free;
  FFrames := value;
end;

function TFhirMedia.GetFramesST : String;
begin
  if FFrames = nil then
    result := ''
  else
    result := FFrames.value;
end;

procedure TFhirMedia.SetFramesST(value : String);
begin
  if value <> '' then
  begin
    if FFrames = nil then
      FFrames := TFhirPositiveInt.Create;
    FFrames.value := value
  end
  else if FFrames <> nil then
    FFrames.value := '';
end;

procedure TFhirMedia.SetDuration(value : TFhirDecimal);
begin
  FDuration.free;
  FDuration := value;
end;

function TFhirMedia.GetDurationST : String;
begin
  if FDuration = nil then
    result := ''
  else
    result := FDuration.value;
end;

procedure TFhirMedia.SetDurationST(value : String);
begin
  if value <> '' then
  begin
    if FDuration = nil then
      FDuration := TFhirDecimal.Create;
    FDuration.value := value
  end
  else if FDuration <> nil then
    FDuration.value := '';
end;

procedure TFhirMedia.SetContent(value : TFhirAttachment);
begin
  FContent.free;
  FContent := value;
end;

function TFhirMedia.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirMedia.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirMediaListEnumerator }

constructor TFhirMediaListEnumerator.Create(list : TFhirMediaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMediaListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirMediaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMediaListEnumerator.GetCurrent : TFhirMedia;
begin
  Result := FList[FIndex];
end;

function TFhirMediaListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMediaList }

function TFhirMediaList.AddItem(value: TFhirMedia): TFhirMedia;
begin
  assert(value.ClassName = 'TFhirMedia', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMedia');
  add(value);
  result := value;
end;

function TFhirMediaList.Append: TFhirMedia;
begin
  result := TFhirMedia.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMediaList.ClearItems;
begin
  Clear;
end;

function TFhirMediaList.GetEnumerator : TFhirMediaListEnumerator;
begin
  result := TFhirMediaListEnumerator.Create(self.link);
end;

function TFhirMediaList.Clone: TFhirMediaList;
begin
  result := TFhirMediaList(inherited Clone);
end;

function TFhirMediaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMediaList.GetItemN(index: Integer): TFhirMedia;
begin
  result := TFhirMedia(ObjectByIndex[index]);
end;

function TFhirMediaList.ItemClass: TFslObjectClass;
begin
  result := TFhirMedia;
end;
function TFhirMediaList.IndexOf(value: TFhirMedia): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMediaList.Insert(index: Integer): TFhirMedia;
begin
  result := TFhirMedia.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMediaList.InsertItem(index: Integer; value: TFhirMedia);
begin
  assert(value is TFhirMedia);
  Inherited Insert(index, value);
end;

function TFhirMediaList.Item(index: Integer): TFhirMedia;
begin
  result := TFhirMedia(ObjectByIndex[index]);
end;

function TFhirMediaList.Link: TFhirMediaList;
begin
  result := TFhirMediaList(inherited Link);
end;

procedure TFhirMediaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMediaList.SetItemByIndex(index: Integer; value: TFhirMedia);
begin
  assert(value is TFhirMedia);
  FhirMedia[index] := value;
end;

procedure TFhirMediaList.SetItemN(index: Integer; value: TFhirMedia);
begin
  assert(value is TFhirMedia);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEDIA}
{$IFDEF FHIR_ORGANIZATION}
{ TFhirOrganizationContact }

constructor TFhirOrganizationContact.Create;
begin
  inherited;
end;

destructor TFhirOrganizationContact.Destroy;
begin
  FPurpose.free;
  FName.free;
  FTelecomList.free;
  FAddress.free;
  inherited;
end;

procedure TFhirOrganizationContact.Assign(oSource : TFslObject);
begin
  inherited;
  purpose := TFhirOrganizationContact(oSource).purpose.Clone;
  name := TFhirOrganizationContact(oSource).name.Clone;
  if (TFhirOrganizationContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOrganizationContact(oSource).FTelecomList);
  end;
  address := TFhirOrganizationContact(oSource).address.Clone;
end;

procedure TFhirOrganizationContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
end;

procedure TFhirOrganizationContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'purpose', 'CodeableConcept', false, TFhirCodeableConcept, FPurpose.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));
end;

function TFhirOrganizationContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'purpose') then
  begin
    Purpose := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName;
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganizationContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else inherited;
end;

function TFhirOrganizationContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'purpose') then result := TFhirCodeableConcept.Create()
  else if (propName = 'name') then result := TFhirHumanName.Create()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'address') then result := TFhirAddress.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganizationContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'purpose') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganizationContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'address') then AddressElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganizationContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'purpose') then PurposeElement := new as TFhirCodeableConcept
  else if (propName = 'name') then NameElement := new as TFhirHumanName
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'address') then AddressElement := new as TFhirAddress
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganizationContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'telecom') then TelecomList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganizationContact.fhirType : string;
begin
  result := 'Organization.contact';
end;

function TFhirOrganizationContact.Link : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Link);
end;

function TFhirOrganizationContact.Clone : TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(inherited Clone);
end;

function TFhirOrganizationContact.equals(other : TObject) : boolean; 
var
  o : TFhirOrganizationContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganizationContact)) then
    result := false
  else
  begin
    o := TFhirOrganizationContact(other);
    result := compareDeep(purposeElement, o.purposeElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true);
  end;
end;

function TFhirOrganizationContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPurpose) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress);
end;

procedure TFhirOrganizationContact.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('purpose');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
end;

function TFhirOrganizationContact.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTelecomList.sizeInBytes(magic));
end;

procedure TFhirOrganizationContact.SetPurpose(value : TFhirCodeableConcept);
begin
  FPurpose.free;
  FPurpose := value;
end;

procedure TFhirOrganizationContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

function TFhirOrganizationContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirOrganizationContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirOrganizationContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

{ TFhirOrganizationContactListEnumerator }

constructor TFhirOrganizationContactListEnumerator.Create(list : TFhirOrganizationContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationContactListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirOrganizationContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationContactListEnumerator.GetCurrent : TFhirOrganizationContact;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationContactListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOrganizationContactList }

function TFhirOrganizationContactList.AddItem(value: TFhirOrganizationContact): TFhirOrganizationContact;
begin
  assert(value.ClassName = 'TFhirOrganizationContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganizationContact');
  add(value);
  result := value;
end;

function TFhirOrganizationContactList.Append: TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationContactList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationContactList.GetEnumerator : TFhirOrganizationContactListEnumerator;
begin
  result := TFhirOrganizationContactListEnumerator.Create(self.link);
end;

function TFhirOrganizationContactList.Clone: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Clone);
end;

function TFhirOrganizationContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationContactList.GetItemN(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganizationContact;
end;
function TFhirOrganizationContactList.IndexOf(value: TFhirOrganizationContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationContactList.Insert(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationContactList.InsertItem(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  Inherited Insert(index, value);
end;

function TFhirOrganizationContactList.Item(index: Integer): TFhirOrganizationContact;
begin
  result := TFhirOrganizationContact(ObjectByIndex[index]);
end;

function TFhirOrganizationContactList.Link: TFhirOrganizationContactList;
begin
  result := TFhirOrganizationContactList(inherited Link);
end;

procedure TFhirOrganizationContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationContactList.SetItemByIndex(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  FhirOrganizationContacts[index] := value;
end;

procedure TFhirOrganizationContactList.SetItemN(index: Integer; value: TFhirOrganizationContact);
begin
  assert(value is TFhirOrganizationContact);
  ObjectByIndex[index] := value;
end;

{ TFhirOrganization }

constructor TFhirOrganization.Create;
begin
  inherited;
end;

destructor TFhirOrganization.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FType_List.free;
  FName.free;
  FAliasList.free;
  FTelecomList.free;
  FAddressList.free;
  FPartOf.free;
  FContactList.free;
  FEndpointList.free;
  inherited;
end;

procedure TFhirOrganization.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrganization(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrganization(oSource).FIdentifierList);
  end;
  activeElement := TFhirOrganization(oSource).activeElement.Clone;
  if (TFhirOrganization(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirOrganization(oSource).FType_List);
  end;
  nameElement := TFhirOrganization(oSource).nameElement.Clone;
  if (TFhirOrganization(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirOrganization(oSource).FAliasList);
  end;
  if (TFhirOrganization(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOrganization(oSource).FTelecomList);
  end;
  if (TFhirOrganization(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirOrganization(oSource).FAddressList);
  end;
  partOf := TFhirOrganization(oSource).partOf.Clone;
  if (TFhirOrganization(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirOrganizationContactList.Create;
    FContactList.Assign(TFhirOrganization(oSource).FContactList);
  end;
  if (TFhirOrganization(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirOrganization(oSource).FEndpointList);
  end;
end;

function TFhirOrganization.GetResourceType : TFhirResourceType;
begin
  result := frtOrganization;
end;

procedure TFhirOrganization.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'partOf') Then
     list.add(self.link, 'partOf', FPartOf.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirOrganization.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.Create(self, 'alias', 'string', true, TFhirString, FAliasList.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.Create(self, 'partOf', 'Reference', false, TFhirReference, FPartOf.Link));
  oList.add(TFHIRProperty.Create(self, 'contact', 'BackboneElement', true, TFhirOrganizationContact, FContactList.Link));
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
end;

function TFhirOrganization.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOf := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirOrganizationContact);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganization.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue))
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirOrganizationContact)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirOrganization.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'name') then result := TFhirString.Create()
  else if (propName = 'alias') then result := AliasList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'partOf') then result := TFhirReference.Create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganization.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganization.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'partOf') then PartOfElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganization.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'partOf') then PartOfElement := new as TFhirReference
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganization.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'alias') then AliasList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganization.fhirType : string;
begin
  result := 'Organization';
end;

function TFhirOrganization.Link : TFhirOrganization;
begin
  result := TFhirOrganization(inherited Link);
end;

function TFhirOrganization.Clone : TFhirOrganization;
begin
  result := TFhirOrganization(inherited Clone);
end;

function TFhirOrganization.equals(other : TObject) : boolean; 
var
  o : TFhirOrganization;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganization)) then
    result := false
  else
  begin
    o := TFhirOrganization(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(type_List, o.type_List, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(partOfElement, o.partOfElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirOrganization.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(Ftype_List) and isEmptyProp(FName) and isEmptyProp(FaliasList) and isEmptyProp(FtelecomList) and isEmptyProp(FaddressList) and isEmptyProp(FPartOf) and isEmptyProp(FcontactList) and isEmptyProp(FendpointList);
end;

procedure TFhirOrganization.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('type');
  fields.add('name');
  fields.add('alias');
  fields.add('telecom');
  fields.add('address');
  fields.add('partOf');
  fields.add('contact');
  fields.add('endpoint');
end;

function TFhirOrganization.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FAliasList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
end;

function TFhirOrganization.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirOrganization.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirOrganization.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirOrganization.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirOrganization.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

function TFhirOrganization.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirOrganization.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

procedure TFhirOrganization.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirOrganization.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirOrganization.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.Create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

function TFhirOrganization.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirOrganization.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

function TFhirOrganization.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirOrganization.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirOrganization.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirOrganization.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirOrganization.SetPartOf(value : TFhirReference);
begin
  FPartOf.free;
  FPartOf := value;
end;

function TFhirOrganization.GetContactList : TFhirOrganizationContactList;
begin
  if FContactList = nil then
    FContactList := TFhirOrganizationContactList.Create;
  result := FContactList;
end;

function TFhirOrganization.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirOrganization.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirOrganization.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

{ TFhirOrganizationListEnumerator }

constructor TFhirOrganizationListEnumerator.Create(list : TFhirOrganizationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirOrganizationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationListEnumerator.GetCurrent : TFhirOrganization;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOrganizationList }

function TFhirOrganizationList.AddItem(value: TFhirOrganization): TFhirOrganization;
begin
  assert(value.ClassName = 'TFhirOrganization', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganization');
  add(value);
  result := value;
end;

function TFhirOrganizationList.Append: TFhirOrganization;
begin
  result := TFhirOrganization.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationList.GetEnumerator : TFhirOrganizationListEnumerator;
begin
  result := TFhirOrganizationListEnumerator.Create(self.link);
end;

function TFhirOrganizationList.Clone: TFhirOrganizationList;
begin
  result := TFhirOrganizationList(inherited Clone);
end;

function TFhirOrganizationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationList.GetItemN(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization(ObjectByIndex[index]);
end;

function TFhirOrganizationList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganization;
end;
function TFhirOrganizationList.IndexOf(value: TFhirOrganization): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationList.Insert(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationList.InsertItem(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  Inherited Insert(index, value);
end;

function TFhirOrganizationList.Item(index: Integer): TFhirOrganization;
begin
  result := TFhirOrganization(ObjectByIndex[index]);
end;

function TFhirOrganizationList.Link: TFhirOrganizationList;
begin
  result := TFhirOrganizationList(inherited Link);
end;

procedure TFhirOrganizationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationList.SetItemByIndex(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  FhirOrganizations[index] := value;
end;

procedure TFhirOrganizationList.SetItemN(index: Integer; value: TFhirOrganization);
begin
  assert(value is TFhirOrganization);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORGANIZATION}
{$IFDEF FHIR_ORGANIZATIONAFFILIATION}
{ TFhirOrganizationAffiliation }

constructor TFhirOrganizationAffiliation.Create;
begin
  inherited;
end;

destructor TFhirOrganizationAffiliation.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FPeriod.free;
  FOrganization.free;
  FParticipatingOrganization.free;
  FNetworkList.free;
  FCodeList.free;
  FSpecialtyList.free;
  FLocationList.free;
  FHealthcareServiceList.free;
  FTelecomList.free;
  FEndpointList.free;
  inherited;
end;

procedure TFhirOrganizationAffiliation.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOrganizationAffiliation(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirOrganizationAffiliation(oSource).FIdentifierList);
  end;
  activeElement := TFhirOrganizationAffiliation(oSource).activeElement.Clone;
  period := TFhirOrganizationAffiliation(oSource).period.Clone;
  organization := TFhirOrganizationAffiliation(oSource).organization.Clone;
  participatingOrganization := TFhirOrganizationAffiliation(oSource).participatingOrganization.Clone;
  if (TFhirOrganizationAffiliation(oSource).FNetworkList = nil) then
  begin
    FNetworkList.free;
    FNetworkList := nil;
  end
  else
  begin
    if FNetworkList = nil then
      FNetworkList := TFhirReferenceList.Create;
    FNetworkList.Assign(TFhirOrganizationAffiliation(oSource).FNetworkList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirOrganizationAffiliation(oSource).FCodeList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirOrganizationAffiliation(oSource).FSpecialtyList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList.Create;
    FLocationList.Assign(TFhirOrganizationAffiliation(oSource).FLocationList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FHealthcareServiceList = nil) then
  begin
    FHealthcareServiceList.free;
    FHealthcareServiceList := nil;
  end
  else
  begin
    if FHealthcareServiceList = nil then
      FHealthcareServiceList := TFhirReferenceList.Create;
    FHealthcareServiceList.Assign(TFhirOrganizationAffiliation(oSource).FHealthcareServiceList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirOrganizationAffiliation(oSource).FTelecomList);
  end;
  if (TFhirOrganizationAffiliation(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirOrganizationAffiliation(oSource).FEndpointList);
  end;
end;

function TFhirOrganizationAffiliation.GetResourceType : TFhirResourceType;
begin
  result := frtOrganizationAffiliation;
end;

procedure TFhirOrganizationAffiliation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'participatingOrganization') Then
     list.add(self.link, 'participatingOrganization', FParticipatingOrganization.Link);
  if (child_name = 'network') Then
    list.addAll(self, 'network', FNetworkList);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'healthcareService') Then
    list.addAll(self, 'healthcareService', FHealthcareServiceList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirOrganizationAffiliation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.Create(self, 'participatingOrganization', 'Reference', false, TFhirReference, FParticipatingOrganization.Link));
  oList.add(TFHIRProperty.Create(self, 'network', 'Reference', true, TFhirReference, FNetworkList.Link));
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference', true, TFhirReference, FLocationList.Link));
  oList.add(TFHIRProperty.Create(self, 'healthcareService', 'Reference', true, TFhirReference, FHealthcareServiceList.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
end;

function TFhirOrganizationAffiliation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'participatingOrganization') then
  begin
    ParticipatingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    NetworkList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'healthcareService') then
  begin
    HealthcareServiceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOrganizationAffiliation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'network') then NetworkList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'healthcareService') then HealthcareServiceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirOrganizationAffiliation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else if (propName = 'organization') then result := TFhirReference.Create()
  else if (propName = 'participatingOrganization') then result := TFhirReference.Create()
  else if (propName = 'network') then result := NetworkList.new()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'healthcareService') then result := HealthcareServiceList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOrganizationAffiliation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'participatingOrganization') then result := 'Reference'
  else if (propName = 'network') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'healthcareService') then result := 'Reference'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOrganizationAffiliation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'participatingOrganization') then ParticipatingOrganizationElement := nil
  else if (propName = 'network') then deletePropertyValue('network', NetworkList, value)
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'healthcareService') then deletePropertyValue('healthcareService', HealthcareServiceList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOrganizationAffiliation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'participatingOrganization') then ParticipatingOrganizationElement := new as TFhirReference
  else if (propName = 'network') then replacePropertyValue('network', NetworkList, existing, new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'healthcareService') then replacePropertyValue('healthcareService', HealthcareServiceList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOrganizationAffiliation.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'network') then NetworkList.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'healthcareService') then HealthcareServiceList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOrganizationAffiliation.fhirType : string;
begin
  result := 'OrganizationAffiliation';
end;

function TFhirOrganizationAffiliation.Link : TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(inherited Link);
end;

function TFhirOrganizationAffiliation.Clone : TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(inherited Clone);
end;

function TFhirOrganizationAffiliation.equals(other : TObject) : boolean; 
var
  o : TFhirOrganizationAffiliation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOrganizationAffiliation)) then
    result := false
  else
  begin
    o := TFhirOrganizationAffiliation(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(participatingOrganizationElement, o.participatingOrganizationElement, true) and 
      compareDeep(networkList, o.networkList, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(healthcareServiceList, o.healthcareServiceList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirOrganizationAffiliation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPeriod) and isEmptyProp(FOrganization) and isEmptyProp(FParticipatingOrganization) and isEmptyProp(FnetworkList) and isEmptyProp(FcodeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FhealthcareServiceList) and isEmptyProp(FtelecomList) and isEmptyProp(FendpointList);
end;

procedure TFhirOrganizationAffiliation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('period');
  fields.add('organization');
  fields.add('participatingOrganization');
  fields.add('network');
  fields.add('code');
  fields.add('specialty');
  fields.add('location');
  fields.add('healthcareService');
  fields.add('telecom');
  fields.add('endpoint');
end;

function TFhirOrganizationAffiliation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNetworkList.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FHealthcareServiceList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
end;

function TFhirOrganizationAffiliation.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirOrganizationAffiliation.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirOrganizationAffiliation.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirOrganizationAffiliation.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirOrganizationAffiliation.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

procedure TFhirOrganizationAffiliation.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirOrganizationAffiliation.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

procedure TFhirOrganizationAffiliation.SetParticipatingOrganization(value : TFhirReference);
begin
  FParticipatingOrganization.free;
  FParticipatingOrganization := value;
end;

function TFhirOrganizationAffiliation.GetNetworkList : TFhirReferenceList;
begin
  if FNetworkList = nil then
    FNetworkList := TFhirReferenceList.Create;
  result := FNetworkList;
end;

function TFhirOrganizationAffiliation.GetHasNetworkList : boolean;
begin
  result := (FNetworkList <> nil) and (FNetworkList.count > 0);
end;

function TFhirOrganizationAffiliation.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirOrganizationAffiliation.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirOrganizationAffiliation.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirOrganizationAffiliation.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirOrganizationAffiliation.GetLocationList : TFhirReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList.Create;
  result := FLocationList;
end;

function TFhirOrganizationAffiliation.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirOrganizationAffiliation.GetHealthcareServiceList : TFhirReferenceList;
begin
  if FHealthcareServiceList = nil then
    FHealthcareServiceList := TFhirReferenceList.Create;
  result := FHealthcareServiceList;
end;

function TFhirOrganizationAffiliation.GetHasHealthcareServiceList : boolean;
begin
  result := (FHealthcareServiceList <> nil) and (FHealthcareServiceList.count > 0);
end;

function TFhirOrganizationAffiliation.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirOrganizationAffiliation.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirOrganizationAffiliation.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirOrganizationAffiliation.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

{ TFhirOrganizationAffiliationListEnumerator }

constructor TFhirOrganizationAffiliationListEnumerator.Create(list : TFhirOrganizationAffiliationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOrganizationAffiliationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirOrganizationAffiliationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOrganizationAffiliationListEnumerator.GetCurrent : TFhirOrganizationAffiliation;
begin
  Result := FList[FIndex];
end;

function TFhirOrganizationAffiliationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOrganizationAffiliationList }

function TFhirOrganizationAffiliationList.AddItem(value: TFhirOrganizationAffiliation): TFhirOrganizationAffiliation;
begin
  assert(value.ClassName = 'TFhirOrganizationAffiliation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOrganizationAffiliation');
  add(value);
  result := value;
end;

function TFhirOrganizationAffiliationList.Append: TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationAffiliationList.ClearItems;
begin
  Clear;
end;

function TFhirOrganizationAffiliationList.GetEnumerator : TFhirOrganizationAffiliationListEnumerator;
begin
  result := TFhirOrganizationAffiliationListEnumerator.Create(self.link);
end;

function TFhirOrganizationAffiliationList.Clone: TFhirOrganizationAffiliationList;
begin
  result := TFhirOrganizationAffiliationList(inherited Clone);
end;

function TFhirOrganizationAffiliationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOrganizationAffiliationList.GetItemN(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(ObjectByIndex[index]);
end;

function TFhirOrganizationAffiliationList.ItemClass: TFslObjectClass;
begin
  result := TFhirOrganizationAffiliation;
end;
function TFhirOrganizationAffiliationList.IndexOf(value: TFhirOrganizationAffiliation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOrganizationAffiliationList.Insert(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOrganizationAffiliationList.InsertItem(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  Inherited Insert(index, value);
end;

function TFhirOrganizationAffiliationList.Item(index: Integer): TFhirOrganizationAffiliation;
begin
  result := TFhirOrganizationAffiliation(ObjectByIndex[index]);
end;

function TFhirOrganizationAffiliationList.Link: TFhirOrganizationAffiliationList;
begin
  result := TFhirOrganizationAffiliationList(inherited Link);
end;

procedure TFhirOrganizationAffiliationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOrganizationAffiliationList.SetItemByIndex(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  FhirOrganizationAffiliations[index] := value;
end;

procedure TFhirOrganizationAffiliationList.SetItemN(index: Integer; value: TFhirOrganizationAffiliation);
begin
  assert(value is TFhirOrganizationAffiliation);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ORGANIZATIONAFFILIATION}
{$IFDEF FHIR_PATIENT}
{ TFhirPatientContact }

constructor TFhirPatientContact.Create;
begin
  inherited;
end;

destructor TFhirPatientContact.Destroy;
begin
  FRelationshipList.free;
  FName.free;
  FTelecomList.free;
  FAddress.free;
  FGender.free;
  FOrganization.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirPatientContact.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPatientContact(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirCodeableConceptList.Create;
    FRelationshipList.Assign(TFhirPatientContact(oSource).FRelationshipList);
  end;
  name := TFhirPatientContact(oSource).name.Clone;
  if (TFhirPatientContact(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPatientContact(oSource).FTelecomList);
  end;
  address := TFhirPatientContact(oSource).address.Clone;
  genderElement := TFhirPatientContact(oSource).genderElement.Clone;
  organization := TFhirPatientContact(oSource).organization.Clone;
  period := TFhirPatientContact(oSource).period.Clone;
end;

procedure TFhirPatientContact.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirPatientContact.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'relationship', 'CodeableConcept', true, TFhirCodeableConcept, FRelationshipList.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', false, TFhirHumanName, FName.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', false, TFhirAddress, FAddress.Link));
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.Create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirPatientContact.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    Name := propValue as TFhirHumanName;
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    Address := propValue as TFhirAddress;
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientContact.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else inherited;
end;

function TFhirPatientContact.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relationship') then result := RelationshipList.new()
  else if (propName = 'name') then result := TFhirHumanName.Create()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'address') then result := TFhirAddress.Create()
  else if (propName = 'gender') then result := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'organization') then result := TFhirReference.Create()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientContact.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientContact.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'address') then AddressElement := nil
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientContact.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new)
  else if (propName = 'name') then NameElement := new as TFhirHumanName
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'address') then AddressElement := new as TFhirAddress
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientContact.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'relationship') then RelationshipList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientContact.fhirType : string;
begin
  result := 'Patient.contact';
end;

function TFhirPatientContact.Link : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Link);
end;

function TFhirPatientContact.Clone : TFhirPatientContact;
begin
  result := TFhirPatientContact(inherited Clone);
end;

function TFhirPatientContact.equals(other : TObject) : boolean; 
var
  o : TFhirPatientContact;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientContact)) then
    result := false
  else
  begin
    o := TFhirPatientContact(other);
    result := compareDeep(relationshipList, o.relationshipList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(addressElement, o.addressElement, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirPatientContact.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FrelationshipList) and isEmptyProp(FName) and isEmptyProp(FtelecomList) and isEmptyProp(FAddress) and isEmptyProp(FGender) and isEmptyProp(FOrganization) and isEmptyProp(FPeriod);
end;

procedure TFhirPatientContact.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('relationship');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
  fields.add('gender');
  fields.add('organization');
  fields.add('period');
end;

function TFhirPatientContact.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRelationshipList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
end;

function TFhirPatientContact.GetRelationshipList : TFhirCodeableConceptList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirCodeableConceptList.Create;
  result := FRelationshipList;
end;

function TFhirPatientContact.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

procedure TFhirPatientContact.SetName(value : TFhirHumanName);
begin
  FName.free;
  FName := value;
end;

function TFhirPatientContact.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPatientContact.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPatientContact.SetAddress(value : TFhirAddress);
begin
  FAddress.free;
  FAddress := value;
end;

procedure TFhirPatientContact.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPatientContact.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPatientContact.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPatientContact.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

procedure TFhirPatientContact.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirPatientContactListEnumerator }

constructor TFhirPatientContactListEnumerator.Create(list : TFhirPatientContactList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientContactListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPatientContactListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientContactListEnumerator.GetCurrent : TFhirPatientContact;
begin
  Result := FList[FIndex];
end;

function TFhirPatientContactListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientContactList }

function TFhirPatientContactList.AddItem(value: TFhirPatientContact): TFhirPatientContact;
begin
  assert(value.ClassName = 'TFhirPatientContact', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientContact');
  add(value);
  result := value;
end;

function TFhirPatientContactList.Append: TFhirPatientContact;
begin
  result := TFhirPatientContact.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientContactList.ClearItems;
begin
  Clear;
end;

function TFhirPatientContactList.GetEnumerator : TFhirPatientContactListEnumerator;
begin
  result := TFhirPatientContactListEnumerator.Create(self.link);
end;

function TFhirPatientContactList.Clone: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Clone);
end;

function TFhirPatientContactList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientContactList.GetItemN(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientContact;
end;
function TFhirPatientContactList.IndexOf(value: TFhirPatientContact): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientContactList.Insert(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientContactList.InsertItem(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  Inherited Insert(index, value);
end;

function TFhirPatientContactList.Item(index: Integer): TFhirPatientContact;
begin
  result := TFhirPatientContact(ObjectByIndex[index]);
end;

function TFhirPatientContactList.Link: TFhirPatientContactList;
begin
  result := TFhirPatientContactList(inherited Link);
end;

procedure TFhirPatientContactList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientContactList.SetItemByIndex(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  FhirPatientContacts[index] := value;
end;

procedure TFhirPatientContactList.SetItemN(index: Integer; value: TFhirPatientContact);
begin
  assert(value is TFhirPatientContact);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientCommunication }

constructor TFhirPatientCommunication.Create;
begin
  inherited;
end;

destructor TFhirPatientCommunication.Destroy;
begin
  FLanguage.free;
  FPreferred.free;
  inherited;
end;

procedure TFhirPatientCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  language := TFhirPatientCommunication(oSource).language.Clone;
  preferredElement := TFhirPatientCommunication(oSource).preferredElement.Clone;
end;

procedure TFhirPatientCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
end;

procedure TFhirPatientCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
  oList.add(TFHIRProperty.Create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));
end;

function TFhirPatientCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPatientCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCodeableConcept.Create()
  else if (propName = 'preferred') then result := TFhirBoolean.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else if (propName = 'preferred') then PreferredElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientCommunication.fhirType : string;
begin
  result := 'Patient.communication';
end;

function TFhirPatientCommunication.Link : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(inherited Link);
end;

function TFhirPatientCommunication.Clone : TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(inherited Clone);
end;

function TFhirPatientCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirPatientCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientCommunication)) then
    result := false
  else
  begin
    o := TFhirPatientCommunication(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(preferredElement, o.preferredElement, true);
  end;
end;

function TFhirPatientCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FPreferred);
end;

procedure TFhirPatientCommunication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('language');
  fields.add('preferred');
end;

function TFhirPatientCommunication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPatientCommunication.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

procedure TFhirPatientCommunication.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

function TFhirPatientCommunication.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirPatientCommunication.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.Create;
  FPreferred.value := value
end;

{ TFhirPatientCommunicationListEnumerator }

constructor TFhirPatientCommunicationListEnumerator.Create(list : TFhirPatientCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientCommunicationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPatientCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientCommunicationListEnumerator.GetCurrent : TFhirPatientCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirPatientCommunicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientCommunicationList }

function TFhirPatientCommunicationList.AddItem(value: TFhirPatientCommunication): TFhirPatientCommunication;
begin
  assert(value.ClassName = 'TFhirPatientCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientCommunication');
  add(value);
  result := value;
end;

function TFhirPatientCommunicationList.Append: TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirPatientCommunicationList.GetEnumerator : TFhirPatientCommunicationListEnumerator;
begin
  result := TFhirPatientCommunicationListEnumerator.Create(self.link);
end;

function TFhirPatientCommunicationList.Clone: TFhirPatientCommunicationList;
begin
  result := TFhirPatientCommunicationList(inherited Clone);
end;

function TFhirPatientCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientCommunicationList.GetItemN(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(ObjectByIndex[index]);
end;

function TFhirPatientCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientCommunication;
end;
function TFhirPatientCommunicationList.IndexOf(value: TFhirPatientCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientCommunicationList.Insert(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientCommunicationList.InsertItem(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  Inherited Insert(index, value);
end;

function TFhirPatientCommunicationList.Item(index: Integer): TFhirPatientCommunication;
begin
  result := TFhirPatientCommunication(ObjectByIndex[index]);
end;

function TFhirPatientCommunicationList.Link: TFhirPatientCommunicationList;
begin
  result := TFhirPatientCommunicationList(inherited Link);
end;

procedure TFhirPatientCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientCommunicationList.SetItemByIndex(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  FhirPatientCommunications[index] := value;
end;

procedure TFhirPatientCommunicationList.SetItemN(index: Integer; value: TFhirPatientCommunication);
begin
  assert(value is TFhirPatientCommunication);
  ObjectByIndex[index] := value;
end;

{ TFhirPatientLink }

constructor TFhirPatientLink.Create;
begin
  inherited;
end;

destructor TFhirPatientLink.Destroy;
begin
  FOther.free;
  FType_.free;
  inherited;
end;

procedure TFhirPatientLink.Assign(oSource : TFslObject);
begin
  inherited;
  other := TFhirPatientLink(oSource).other.Clone;
  type_Element := TFhirPatientLink(oSource).type_Element.Clone;
end;

procedure TFhirPatientLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'other') Then
     list.add(self.link, 'other', FOther.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirPatientLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'other', 'Reference', false, TFhirReference, FOther.Link));
  oList.add(TFHIRProperty.Create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
end;

function TFhirPatientLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'other') then
  begin
    Other := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirLinkTypeEnum, CODES_TFhirLinkTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatientLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPatientLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'other') then result := TFhirReference.Create()
  else if (propName = 'type') then result := TFhirEnum.Create(SYSTEMS_TFhirLinkTypeEnum[LinkTypeNull], CODES_TFhirLinkTypeEnum[LinkTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatientLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'other') then result := 'Reference'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatientLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'other') then OtherElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatientLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'other') then OtherElement := new as TFhirReference
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirLinkTypeEnum, CODES_TFhirLinkTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatientLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPatientLink.fhirType : string;
begin
  result := 'Patient.link';
end;

function TFhirPatientLink.Link : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Link);
end;

function TFhirPatientLink.Clone : TFhirPatientLink;
begin
  result := TFhirPatientLink(inherited Clone);
end;

function TFhirPatientLink.equals(other : TObject) : boolean; 
var
  o : TFhirPatientLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatientLink)) then
    result := false
  else
  begin
    o := TFhirPatientLink(other);
    result := compareDeep(otherElement, o.otherElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirPatientLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOther) and isEmptyProp(FType_);
end;

procedure TFhirPatientLink.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('other');
  fields.add('type');
end;

function TFhirPatientLink.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPatientLink.SetOther(value : TFhirReference);
begin
  FOther.free;
  FOther := value;
end;

procedure TFhirPatientLink.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPatientLink.GetType_ST : TFhirLinkTypeEnum;
begin
  if FType_ = nil then
    result := TFhirLinkTypeEnum(0)
  else
    result := TFhirLinkTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirLinkTypeEnum, FType_.value));
end;

procedure TFhirPatientLink.SetType_ST(value : TFhirLinkTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.Create(SYSTEMS_TFhirLinkTypeEnum[value], CODES_TFhirLinkTypeEnum[value]);
end;

{ TFhirPatientLinkListEnumerator }

constructor TFhirPatientLinkListEnumerator.Create(list : TFhirPatientLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientLinkListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPatientLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientLinkListEnumerator.GetCurrent : TFhirPatientLink;
begin
  Result := FList[FIndex];
end;

function TFhirPatientLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientLinkList }

function TFhirPatientLinkList.AddItem(value: TFhirPatientLink): TFhirPatientLink;
begin
  assert(value.ClassName = 'TFhirPatientLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatientLink');
  add(value);
  result := value;
end;

function TFhirPatientLinkList.Append: TFhirPatientLink;
begin
  result := TFhirPatientLink.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPatientLinkList.GetEnumerator : TFhirPatientLinkListEnumerator;
begin
  result := TFhirPatientLinkListEnumerator.Create(self.link);
end;

function TFhirPatientLinkList.Clone: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Clone);
end;

function TFhirPatientLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientLinkList.GetItemN(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatientLink;
end;
function TFhirPatientLinkList.IndexOf(value: TFhirPatientLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientLinkList.Insert(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientLinkList.InsertItem(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  Inherited Insert(index, value);
end;

function TFhirPatientLinkList.Item(index: Integer): TFhirPatientLink;
begin
  result := TFhirPatientLink(ObjectByIndex[index]);
end;

function TFhirPatientLinkList.Link: TFhirPatientLinkList;
begin
  result := TFhirPatientLinkList(inherited Link);
end;

procedure TFhirPatientLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientLinkList.SetItemByIndex(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  FhirPatientLinks[index] := value;
end;

procedure TFhirPatientLinkList.SetItemN(index: Integer; value: TFhirPatientLink);
begin
  assert(value is TFhirPatientLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPatient }

constructor TFhirPatient.Create;
begin
  inherited;
end;

destructor TFhirPatient.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FNameList.free;
  FTelecomList.free;
  FGender.free;
  FBirthDate.free;
  FDeceased.free;
  FAddressList.free;
  FMaritalStatus.free;
  FMultipleBirth.free;
  FPhotoList.free;
  FContactList.free;
  FCommunicationList.free;
  FGeneralPractitionerList.free;
  FManagingOrganization.free;
  FLink_List.free;
  inherited;
end;

procedure TFhirPatient.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPatient(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPatient(oSource).FIdentifierList);
  end;
  activeElement := TFhirPatient(oSource).activeElement.Clone;
  if (TFhirPatient(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPatient(oSource).FNameList);
  end;
  if (TFhirPatient(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPatient(oSource).FTelecomList);
  end;
  genderElement := TFhirPatient(oSource).genderElement.Clone;
  birthDateElement := TFhirPatient(oSource).birthDateElement.Clone;
  deceased := TFhirPatient(oSource).deceased.Clone;
  if (TFhirPatient(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPatient(oSource).FAddressList);
  end;
  maritalStatus := TFhirPatient(oSource).maritalStatus.Clone;
  multipleBirth := TFhirPatient(oSource).multipleBirth.Clone;
  if (TFhirPatient(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirPatient(oSource).FPhotoList);
  end;
  if (TFhirPatient(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirPatientContactList.Create;
    FContactList.Assign(TFhirPatient(oSource).FContactList);
  end;
  if (TFhirPatient(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirPatientCommunicationList.Create;
    FCommunicationList.Assign(TFhirPatient(oSource).FCommunicationList);
  end;
  if (TFhirPatient(oSource).FGeneralPractitionerList = nil) then
  begin
    FGeneralPractitionerList.free;
    FGeneralPractitionerList := nil;
  end
  else
  begin
    if FGeneralPractitionerList = nil then
      FGeneralPractitionerList := TFhirReferenceList.Create;
    FGeneralPractitionerList.Assign(TFhirPatient(oSource).FGeneralPractitionerList);
  end;
  managingOrganization := TFhirPatient(oSource).managingOrganization.Clone;
  if (TFhirPatient(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirPatientLinkList.Create;
    FLink_List.Assign(TFhirPatient(oSource).FLink_List);
  end;
end;

function TFhirPatient.GetResourceType : TFhirResourceType;
begin
  result := frtPatient;
end;

procedure TFhirPatient.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'deceased[x]') or (child_name = 'deceased') Then
     list.add(self.link, 'deceased[x]', FDeceased.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'maritalStatus') Then
     list.add(self.link, 'maritalStatus', FMaritalStatus.Link);
  if (child_name = 'multipleBirth[x]') or (child_name = 'multipleBirth') Then
     list.add(self.link, 'multipleBirth[x]', FMultipleBirth.Link);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
  if (child_name = 'generalPractitioner') Then
    list.addAll(self, 'generalPractitioner', FGeneralPractitionerList);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirPatient.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.Create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));
  oList.add(TFHIRProperty.Create(self, 'deceased[x]', 'boolean|dateTime', false, TFhirDataType, FDeceased.Link));
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.Create(self, 'maritalStatus', 'CodeableConcept', false, TFhirCodeableConcept, FMaritalStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'multipleBirth[x]', 'boolean|integer', false, TFhirDataType, FMultipleBirth.Link));
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link));
  oList.add(TFHIRProperty.Create(self, 'contact', 'BackboneElement', true, TFhirPatientContact, FContactList.Link));
  oList.add(TFHIRProperty.Create(self, 'communication', 'BackboneElement', true, TFhirPatientCommunication, FCommunicationList.Link));
  oList.add(TFHIRProperty.Create(self, 'generalPractitioner', 'Reference', true, TFhirReference, FGeneralPractitionerList.Link));
  oList.add(TFHIRProperty.Create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link));
  oList.add(TFHIRProperty.Create(self, 'link', 'BackboneElement', true, TFhirPatientLink, FLink_List.Link));
end;

function TFhirPatient.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then
  begin
    Deceased := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'maritalStatus') then
  begin
    MaritalStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then
  begin
    MultipleBirth := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirPatientContact);
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirPatientCommunication);
    result := propValue;
  end
  else if (propName = 'generalPractitioner') then
  begin
    GeneralPractitionerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirPatientLink);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPatient.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirPatientContact)
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirPatientCommunication)
  else if (propName = 'generalPractitioner') then GeneralPractitionerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirPatientLink)
  else inherited;
end;

function TFhirPatient.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'gender') then result := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'birthDate') then result := TFhirDate.Create()
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then raise EFHIRException.Create('Cannot make property Deceased')
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'maritalStatus') then result := TFhirCodeableConcept.Create()
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then raise EFHIRException.Create('Cannot make property MultipleBirth')
  else if (propName = 'photo') then result := PhotoList.new()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'communication') then result := CommunicationList.new()
  else if (propName = 'generalPractitioner') then result := GeneralPractitionerList.new()
  else if (propName = 'managingOrganization') then result := TFhirReference.Create()
  else if (propName = 'link') then result := Link_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPatient.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'deceased[x]') then result := 'boolean|dateTime'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'maritalStatus') then result := 'CodeableConcept'
  else if (propName = 'multipleBirth[x]') then result := 'boolean|integer'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'contact') then result := 'BackboneElement'
  else if (propName = 'communication') then result := 'BackboneElement'
  else if (propName = 'generalPractitioner') then result := 'Reference'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'link') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPatient.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'maritalStatus') then MaritalStatusElement := nil
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then MultipleBirthElement := nil
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value)
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value)
  else if (propName = 'generalPractitioner') then deletePropertyValue('generalPractitioner', GeneralPractitionerList, value)
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPatient.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'birthDate') then BirthDateElement := asDate(new)
  else if (isMatchingName(propName, 'deceased', ['Boolean', 'DateTime'])) then DeceasedElement := new as TFhirDataType
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'maritalStatus') then MaritalStatusElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'multipleBirth', ['Boolean', 'Integer'])) then MultipleBirthElement := new as TFhirDataType
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new)
  else if (propName = 'generalPractitioner') then replacePropertyValue('generalPractitioner', GeneralPractitionerList, existing, new)
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPatient.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'photo') then PhotoList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'communication') then CommunicationList.move(source, destination)
  else if (propName = 'generalPractitioner') then GeneralPractitionerList.move(source, destination)
  else if (propName = 'link') then Link_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPatient.fhirType : string;
begin
  result := 'Patient';
end;

function TFhirPatient.Link : TFhirPatient;
begin
  result := TFhirPatient(inherited Link);
end;

function TFhirPatient.Clone : TFhirPatient;
begin
  result := TFhirPatient(inherited Clone);
end;

function TFhirPatient.equals(other : TObject) : boolean; 
var
  o : TFhirPatient;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPatient)) then
    result := false
  else
  begin
    o := TFhirPatient(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(deceasedElement, o.deceasedElement, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(maritalStatusElement, o.maritalStatusElement, true) and compareDeep(multipleBirthElement, o.multipleBirthElement, true) and 
      compareDeep(photoList, o.photoList, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(communicationList, o.communicationList, true) and compareDeep(generalPractitionerList, o.generalPractitionerList, true) and 
      compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirPatient.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FDeceased) and isEmptyProp(FaddressList) and isEmptyProp(FMaritalStatus) and isEmptyProp(FMultipleBirth) and isEmptyProp(FphotoList) and isEmptyProp(FcontactList) and isEmptyProp(FcommunicationList) and isEmptyProp(FgeneralPractitionerList) and isEmptyProp(FManagingOrganization) and isEmptyProp(Flink_List);
end;

procedure TFhirPatient.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('deceased[x]');
  fields.add('address');
  fields.add('maritalStatus');
  fields.add('multipleBirth[x]');
  fields.add('photo');
  fields.add('contact');
  fields.add('communication');
  fields.add('generalPractitioner');
  fields.add('managingOrganization');
  fields.add('link');
end;

function TFhirPatient.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FPhotoList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FCommunicationList.sizeInBytes(magic));
  inc(result, FGeneralPractitionerList.sizeInBytes(magic));
  inc(result, FLink_List.sizeInBytes(magic));
end;

function TFhirPatient.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPatient.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPatient.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirPatient.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPatient.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

function TFhirPatient.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirPatient.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirPatient.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPatient.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPatient.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPatient.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPatient.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPatient.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

function TFhirPatient.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirPatient.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.Create;
  FBirthDate.value := value
end;

procedure TFhirPatient.SetDeceased(value : TFhirDataType);
begin
  FDeceased.free;
  FDeceased := value;
end;

function TFhirPatient.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirPatient.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirPatient.SetMaritalStatus(value : TFhirCodeableConcept);
begin
  FMaritalStatus.free;
  FMaritalStatus := value;
end;

procedure TFhirPatient.SetMultipleBirth(value : TFhirDataType);
begin
  FMultipleBirth.free;
  FMultipleBirth := value;
end;

function TFhirPatient.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirPatient.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

function TFhirPatient.GetContactList : TFhirPatientContactList;
begin
  if FContactList = nil then
    FContactList := TFhirPatientContactList.Create;
  result := FContactList;
end;

function TFhirPatient.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirPatient.GetCommunicationList : TFhirPatientCommunicationList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirPatientCommunicationList.Create;
  result := FCommunicationList;
end;

function TFhirPatient.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

function TFhirPatient.GetGeneralPractitionerList : TFhirReferenceList;
begin
  if FGeneralPractitionerList = nil then
    FGeneralPractitionerList := TFhirReferenceList.Create;
  result := FGeneralPractitionerList;
end;

function TFhirPatient.GetHasGeneralPractitionerList : boolean;
begin
  result := (FGeneralPractitionerList <> nil) and (FGeneralPractitionerList.count > 0);
end;

procedure TFhirPatient.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

function TFhirPatient.GetLink_List : TFhirPatientLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirPatientLinkList.Create;
  result := FLink_List;
end;

function TFhirPatient.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

{ TFhirPatientListEnumerator }

constructor TFhirPatientListEnumerator.Create(list : TFhirPatientList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPatientListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPatientListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPatientListEnumerator.GetCurrent : TFhirPatient;
begin
  Result := FList[FIndex];
end;

function TFhirPatientListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPatientList }

function TFhirPatientList.AddItem(value: TFhirPatient): TFhirPatient;
begin
  assert(value.ClassName = 'TFhirPatient', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPatient');
  add(value);
  result := value;
end;

function TFhirPatientList.Append: TFhirPatient;
begin
  result := TFhirPatient.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientList.ClearItems;
begin
  Clear;
end;

function TFhirPatientList.GetEnumerator : TFhirPatientListEnumerator;
begin
  result := TFhirPatientListEnumerator.Create(self.link);
end;

function TFhirPatientList.Clone: TFhirPatientList;
begin
  result := TFhirPatientList(inherited Clone);
end;

function TFhirPatientList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPatientList.GetItemN(index: Integer): TFhirPatient;
begin
  result := TFhirPatient(ObjectByIndex[index]);
end;

function TFhirPatientList.ItemClass: TFslObjectClass;
begin
  result := TFhirPatient;
end;
function TFhirPatientList.IndexOf(value: TFhirPatient): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPatientList.Insert(index: Integer): TFhirPatient;
begin
  result := TFhirPatient.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPatientList.InsertItem(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  Inherited Insert(index, value);
end;

function TFhirPatientList.Item(index: Integer): TFhirPatient;
begin
  result := TFhirPatient(ObjectByIndex[index]);
end;

function TFhirPatientList.Link: TFhirPatientList;
begin
  result := TFhirPatientList(inherited Link);
end;

procedure TFhirPatientList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPatientList.SetItemByIndex(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  FhirPatients[index] := value;
end;

procedure TFhirPatientList.SetItemN(index: Integer; value: TFhirPatient);
begin
  assert(value is TFhirPatient);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PATIENT}
{$IFDEF FHIR_PERSON}
{ TFhirPersonLink }

constructor TFhirPersonLink.Create;
begin
  inherited;
end;

destructor TFhirPersonLink.Destroy;
begin
  FTarget.free;
  FAssurance.free;
  inherited;
end;

procedure TFhirPersonLink.Assign(oSource : TFslObject);
begin
  inherited;
  target := TFhirPersonLink(oSource).target.Clone;
  assuranceElement := TFhirPersonLink(oSource).assuranceElement.Clone;
end;

procedure TFhirPersonLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'assurance') Then
     list.add(self.link, 'assurance', FAssurance.Link);
end;

procedure TFhirPersonLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'target', 'Reference', false, TFhirReference, FTarget.Link));
  oList.add(TFHIRProperty.Create(self, 'assurance', 'code', false, TFhirEnum, FAssurance.Link));
end;

function TFhirPersonLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    Target := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'assurance') then
  begin
    AssuranceElement := asEnum(SYSTEMS_TFhirIdentityAssuranceLevelEnum, CODES_TFhirIdentityAssuranceLevelEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPersonLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPersonLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TFhirReference.Create()
  else if (propName = 'assurance') then result := TFhirEnum.Create(SYSTEMS_TFhirIdentityAssuranceLevelEnum[IdentityAssuranceLevelNull], CODES_TFhirIdentityAssuranceLevelEnum[IdentityAssuranceLevelNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirPersonLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'assurance') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPersonLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := nil
  else if (propName = 'assurance') then AssuranceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPersonLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then TargetElement := new as TFhirReference
  else if (propName = 'assurance') then AssuranceElement := asEnum(SYSTEMS_TFhirIdentityAssuranceLevelEnum, CODES_TFhirIdentityAssuranceLevelEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPersonLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPersonLink.fhirType : string;
begin
  result := 'Person.link';
end;

function TFhirPersonLink.Link : TFhirPersonLink;
begin
  result := TFhirPersonLink(inherited Link);
end;

function TFhirPersonLink.Clone : TFhirPersonLink;
begin
  result := TFhirPersonLink(inherited Clone);
end;

function TFhirPersonLink.equals(other : TObject) : boolean; 
var
  o : TFhirPersonLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPersonLink)) then
    result := false
  else
  begin
    o := TFhirPersonLink(other);
    result := compareDeep(targetElement, o.targetElement, true) and compareDeep(assuranceElement, o.assuranceElement, true);
  end;
end;

function TFhirPersonLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTarget) and isEmptyProp(FAssurance);
end;

procedure TFhirPersonLink.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('target');
  fields.add('assurance');
end;

function TFhirPersonLink.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPersonLink.SetTarget(value : TFhirReference);
begin
  FTarget.free;
  FTarget := value;
end;

procedure TFhirPersonLink.SetAssurance(value : TFhirEnum);
begin
  FAssurance.free;
  FAssurance := value;
end;

function TFhirPersonLink.GetAssuranceST : TFhirIdentityAssuranceLevelEnum;
begin
  if FAssurance = nil then
    result := TFhirIdentityAssuranceLevelEnum(0)
  else
    result := TFhirIdentityAssuranceLevelEnum(StringArrayIndexOfSensitive(CODES_TFhirIdentityAssuranceLevelEnum, FAssurance.value));
end;

procedure TFhirPersonLink.SetAssuranceST(value : TFhirIdentityAssuranceLevelEnum);
begin
  if ord(value) = 0 then
    AssuranceElement := nil
  else
    AssuranceElement := TFhirEnum.Create(SYSTEMS_TFhirIdentityAssuranceLevelEnum[value], CODES_TFhirIdentityAssuranceLevelEnum[value]);
end;

{ TFhirPersonLinkListEnumerator }

constructor TFhirPersonLinkListEnumerator.Create(list : TFhirPersonLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPersonLinkListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPersonLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPersonLinkListEnumerator.GetCurrent : TFhirPersonLink;
begin
  Result := FList[FIndex];
end;

function TFhirPersonLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPersonLinkList }

function TFhirPersonLinkList.AddItem(value: TFhirPersonLink): TFhirPersonLink;
begin
  assert(value.ClassName = 'TFhirPersonLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPersonLink');
  add(value);
  result := value;
end;

function TFhirPersonLinkList.Append: TFhirPersonLink;
begin
  result := TFhirPersonLink.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonLinkList.ClearItems;
begin
  Clear;
end;

function TFhirPersonLinkList.GetEnumerator : TFhirPersonLinkListEnumerator;
begin
  result := TFhirPersonLinkListEnumerator.Create(self.link);
end;

function TFhirPersonLinkList.Clone: TFhirPersonLinkList;
begin
  result := TFhirPersonLinkList(inherited Clone);
end;

function TFhirPersonLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPersonLinkList.GetItemN(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink(ObjectByIndex[index]);
end;

function TFhirPersonLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirPersonLink;
end;
function TFhirPersonLinkList.IndexOf(value: TFhirPersonLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPersonLinkList.Insert(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonLinkList.InsertItem(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  Inherited Insert(index, value);
end;

function TFhirPersonLinkList.Item(index: Integer): TFhirPersonLink;
begin
  result := TFhirPersonLink(ObjectByIndex[index]);
end;

function TFhirPersonLinkList.Link: TFhirPersonLinkList;
begin
  result := TFhirPersonLinkList(inherited Link);
end;

procedure TFhirPersonLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPersonLinkList.SetItemByIndex(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  FhirPersonLinks[index] := value;
end;

procedure TFhirPersonLinkList.SetItemN(index: Integer; value: TFhirPersonLink);
begin
  assert(value is TFhirPersonLink);
  ObjectByIndex[index] := value;
end;

{ TFhirPerson }

constructor TFhirPerson.Create;
begin
  inherited;
end;

destructor TFhirPerson.Destroy;
begin
  FIdentifierList.free;
  FNameList.free;
  FTelecomList.free;
  FGender.free;
  FBirthDate.free;
  FAddressList.free;
  FPhoto.free;
  FManagingOrganization.free;
  FActive.free;
  FLink_List.free;
  inherited;
end;

procedure TFhirPerson.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPerson(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPerson(oSource).FIdentifierList);
  end;
  if (TFhirPerson(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPerson(oSource).FNameList);
  end;
  if (TFhirPerson(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPerson(oSource).FTelecomList);
  end;
  genderElement := TFhirPerson(oSource).genderElement.Clone;
  birthDateElement := TFhirPerson(oSource).birthDateElement.Clone;
  if (TFhirPerson(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPerson(oSource).FAddressList);
  end;
  photo := TFhirPerson(oSource).photo.Clone;
  managingOrganization := TFhirPerson(oSource).managingOrganization.Clone;
  activeElement := TFhirPerson(oSource).activeElement.Clone;
  if (TFhirPerson(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirPersonLinkList.Create;
    FLink_List.Assign(TFhirPerson(oSource).FLink_List);
  end;
end;

function TFhirPerson.GetResourceType : TFhirResourceType;
begin
  result := frtPerson;
end;

procedure TFhirPerson.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'photo') Then
     list.add(self.link, 'photo', FPhoto.Link);
  if (child_name = 'managingOrganization') Then
     list.add(self.link, 'managingOrganization', FManagingOrganization.Link);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
end;

procedure TFhirPerson.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.Create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', false, TFhirAttachment, FPhoto.Link));
  oList.add(TFHIRProperty.Create(self, 'managingOrganization', 'Reference', false, TFhirReference, FManagingOrganization.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'link', 'BackboneElement', true, TFhirPersonLink, FLink_List.Link));
end;

function TFhirPerson.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    Photo := propValue as TFhirAttachment;
    result := propValue;
  end
  else if (propName = 'managingOrganization') then
  begin
    ManagingOrganization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirPersonLink);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPerson.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirPersonLink)
  else inherited;
end;

function TFhirPerson.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'gender') then result := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'birthDate') then result := TFhirDate.Create()
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'photo') then result := TFhirAttachment.Create()
  else if (propName = 'managingOrganization') then result := TFhirReference.Create()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'link') then result := Link_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPerson.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'managingOrganization') then result := 'Reference'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'link') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPerson.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'photo') then PhotoElement := nil
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := nil
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPerson.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'birthDate') then BirthDateElement := asDate(new)
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'photo') then PhotoElement := new as TFhirAttachment
  else if (propName = 'managingOrganization') then ManagingOrganizationElement := new as TFhirReference
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPerson.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'link') then Link_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPerson.fhirType : string;
begin
  result := 'Person';
end;

function TFhirPerson.Link : TFhirPerson;
begin
  result := TFhirPerson(inherited Link);
end;

function TFhirPerson.Clone : TFhirPerson;
begin
  result := TFhirPerson(inherited Clone);
end;

function TFhirPerson.equals(other : TObject) : boolean; 
var
  o : TFhirPerson;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPerson)) then
    result := false
  else
  begin
    o := TFhirPerson(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(nameList, o.nameList, true) and 
      compareDeep(telecomList, o.telecomList, true) and compareDeep(genderElement, o.genderElement, true) and 
      compareDeep(birthDateElement, o.birthDateElement, true) and compareDeep(addressList, o.addressList, true) and 
      compareDeep(photoElement, o.photoElement, true) and compareDeep(managingOrganizationElement, o.managingOrganizationElement, true) and 
      compareDeep(activeElement, o.activeElement, true) and compareDeep(link_List, o.link_List, true);
  end;
end;

function TFhirPerson.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FaddressList) and isEmptyProp(FPhoto) and isEmptyProp(FManagingOrganization) and isEmptyProp(FActive) and isEmptyProp(Flink_List);
end;

procedure TFhirPerson.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('address');
  fields.add('photo');
  fields.add('managingOrganization');
  fields.add('active');
  fields.add('link');
end;

function TFhirPerson.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FLink_List.sizeInBytes(magic));
end;

function TFhirPerson.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPerson.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirPerson.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirPerson.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirPerson.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPerson.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirPerson.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPerson.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPerson.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPerson.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

function TFhirPerson.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirPerson.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.Create;
  FBirthDate.value := value
end;

function TFhirPerson.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirPerson.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirPerson.SetPhoto(value : TFhirAttachment);
begin
  FPhoto.free;
  FPhoto := value;
end;

procedure TFhirPerson.SetManagingOrganization(value : TFhirReference);
begin
  FManagingOrganization.free;
  FManagingOrganization := value;
end;

procedure TFhirPerson.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirPerson.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPerson.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

function TFhirPerson.GetLink_List : TFhirPersonLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirPersonLinkList.Create;
  result := FLink_List;
end;

function TFhirPerson.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

{ TFhirPersonListEnumerator }

constructor TFhirPersonListEnumerator.Create(list : TFhirPersonList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPersonListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPersonListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPersonListEnumerator.GetCurrent : TFhirPerson;
begin
  Result := FList[FIndex];
end;

function TFhirPersonListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPersonList }

function TFhirPersonList.AddItem(value: TFhirPerson): TFhirPerson;
begin
  assert(value.ClassName = 'TFhirPerson', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPerson');
  add(value);
  result := value;
end;

function TFhirPersonList.Append: TFhirPerson;
begin
  result := TFhirPerson.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonList.ClearItems;
begin
  Clear;
end;

function TFhirPersonList.GetEnumerator : TFhirPersonListEnumerator;
begin
  result := TFhirPersonListEnumerator.Create(self.link);
end;

function TFhirPersonList.Clone: TFhirPersonList;
begin
  result := TFhirPersonList(inherited Clone);
end;

function TFhirPersonList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPersonList.GetItemN(index: Integer): TFhirPerson;
begin
  result := TFhirPerson(ObjectByIndex[index]);
end;

function TFhirPersonList.ItemClass: TFslObjectClass;
begin
  result := TFhirPerson;
end;
function TFhirPersonList.IndexOf(value: TFhirPerson): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPersonList.Insert(index: Integer): TFhirPerson;
begin
  result := TFhirPerson.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPersonList.InsertItem(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  Inherited Insert(index, value);
end;

function TFhirPersonList.Item(index: Integer): TFhirPerson;
begin
  result := TFhirPerson(ObjectByIndex[index]);
end;

function TFhirPersonList.Link: TFhirPersonList;
begin
  result := TFhirPersonList(inherited Link);
end;

procedure TFhirPersonList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPersonList.SetItemByIndex(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  FhirPeople[index] := value;
end;

procedure TFhirPersonList.SetItemN(index: Integer; value: TFhirPerson);
begin
  assert(value is TFhirPerson);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PERSON}
{$IFDEF FHIR_PRACTITIONER}
{ TFhirPractitionerQualification }

constructor TFhirPractitionerQualification.Create;
begin
  inherited;
end;

destructor TFhirPractitionerQualification.Destroy;
begin
  FIdentifierList.free;
  FCode.free;
  FPeriod.free;
  FIssuer.free;
  inherited;
end;

procedure TFhirPractitionerQualification.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerQualification(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitionerQualification(oSource).FIdentifierList);
  end;
  code := TFhirPractitionerQualification(oSource).code.Clone;
  period := TFhirPractitionerQualification(oSource).period.Clone;
  issuer := TFhirPractitionerQualification(oSource).issuer.Clone;
end;

procedure TFhirPractitionerQualification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'issuer') Then
     list.add(self.link, 'issuer', FIssuer.Link);
end;

procedure TFhirPractitionerQualification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'issuer', 'Reference', false, TFhirReference, FIssuer.Link));
end;

function TFhirPractitionerQualification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'issuer') then
  begin
    Issuer := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerQualification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirPractitionerQualification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'code') then result := TFhirCodeableConcept.Create()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else if (propName = 'issuer') then result := TFhirReference.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerQualification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'issuer') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerQualification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'issuer') then IssuerElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerQualification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'issuer') then IssuerElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerQualification.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerQualification.fhirType : string;
begin
  result := 'Practitioner.qualification';
end;

function TFhirPractitionerQualification.Link : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Link);
end;

function TFhirPractitionerQualification.Clone : TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(inherited Clone);
end;

function TFhirPractitionerQualification.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerQualification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerQualification)) then
    result := false
  else
  begin
    o := TFhirPractitionerQualification(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(issuerElement, o.issuerElement, true);
  end;
end;

function TFhirPractitionerQualification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FCode) and isEmptyProp(FPeriod) and isEmptyProp(FIssuer);
end;

procedure TFhirPractitionerQualification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('period');
  fields.add('issuer');
end;

function TFhirPractitionerQualification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirPractitionerQualification.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPractitionerQualification.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPractitionerQualification.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirPractitionerQualification.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirPractitionerQualification.SetIssuer(value : TFhirReference);
begin
  FIssuer.free;
  FIssuer := value;
end;

{ TFhirPractitionerQualificationListEnumerator }

constructor TFhirPractitionerQualificationListEnumerator.Create(list : TFhirPractitionerQualificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerQualificationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerQualificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerQualificationListEnumerator.GetCurrent : TFhirPractitionerQualification;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerQualificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerQualificationList }

function TFhirPractitionerQualificationList.AddItem(value: TFhirPractitionerQualification): TFhirPractitionerQualification;
begin
  assert(value.ClassName = 'TFhirPractitionerQualification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerQualification');
  add(value);
  result := value;
end;

function TFhirPractitionerQualificationList.Append: TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerQualificationList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerQualificationList.GetEnumerator : TFhirPractitionerQualificationListEnumerator;
begin
  result := TFhirPractitionerQualificationListEnumerator.Create(self.link);
end;

function TFhirPractitionerQualificationList.Clone: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Clone);
end;

function TFhirPractitionerQualificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerQualificationList.GetItemN(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerQualification;
end;
function TFhirPractitionerQualificationList.IndexOf(value: TFhirPractitionerQualification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerQualificationList.Insert(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerQualificationList.InsertItem(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  Inherited Insert(index, value);
end;

function TFhirPractitionerQualificationList.Item(index: Integer): TFhirPractitionerQualification;
begin
  result := TFhirPractitionerQualification(ObjectByIndex[index]);
end;

function TFhirPractitionerQualificationList.Link: TFhirPractitionerQualificationList;
begin
  result := TFhirPractitionerQualificationList(inherited Link);
end;

procedure TFhirPractitionerQualificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerQualificationList.SetItemByIndex(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  FhirPractitionerQualifications[index] := value;
end;

procedure TFhirPractitionerQualificationList.SetItemN(index: Integer; value: TFhirPractitionerQualification);
begin
  assert(value is TFhirPractitionerQualification);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitioner }

constructor TFhirPractitioner.Create;
begin
  inherited;
end;

destructor TFhirPractitioner.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FNameList.free;
  FTelecomList.free;
  FAddressList.free;
  FGender.free;
  FBirthDate.free;
  FPhotoList.free;
  FQualificationList.free;
  FCommunicationList.free;
  inherited;
end;

procedure TFhirPractitioner.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitioner(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitioner(oSource).FIdentifierList);
  end;
  activeElement := TFhirPractitioner(oSource).activeElement.Clone;
  if (TFhirPractitioner(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirPractitioner(oSource).FNameList);
  end;
  if (TFhirPractitioner(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPractitioner(oSource).FTelecomList);
  end;
  if (TFhirPractitioner(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirPractitioner(oSource).FAddressList);
  end;
  genderElement := TFhirPractitioner(oSource).genderElement.Clone;
  birthDateElement := TFhirPractitioner(oSource).birthDateElement.Clone;
  if (TFhirPractitioner(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirPractitioner(oSource).FPhotoList);
  end;
  if (TFhirPractitioner(oSource).FQualificationList = nil) then
  begin
    FQualificationList.free;
    FQualificationList := nil;
  end
  else
  begin
    if FQualificationList = nil then
      FQualificationList := TFhirPractitionerQualificationList.Create;
    FQualificationList.Assign(TFhirPractitioner(oSource).FQualificationList);
  end;
  if (TFhirPractitioner(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirCodeableConceptList.Create;
    FCommunicationList.Assign(TFhirPractitioner(oSource).FCommunicationList);
  end;
end;

function TFhirPractitioner.GetResourceType : TFhirResourceType;
begin
  result := frtPractitioner;
end;

procedure TFhirPractitioner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'qualification') Then
    list.addAll(self, 'qualification', FQualificationList);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
end;

procedure TFhirPractitioner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.Create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link));
  oList.add(TFHIRProperty.Create(self, 'qualification', 'BackboneElement', true, TFhirPractitionerQualification, FQualificationList.Link));
  oList.add(TFHIRProperty.Create(self, 'communication', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationList.Link));
end;

function TFhirPractitioner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else if (propName = 'qualification') then
  begin
    QualificationList.add(propValue as TFhirPractitionerQualification);
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitioner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment)
  else if (propName = 'qualification') then QualificationList.insertItem(index, propValue as TFhirPractitionerQualification)
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirPractitioner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'gender') then result := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'birthDate') then result := TFhirDate.Create()
  else if (propName = 'photo') then result := PhotoList.new()
  else if (propName = 'qualification') then result := QualificationList.new()
  else if (propName = 'communication') then result := CommunicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitioner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'qualification') then result := 'BackboneElement'
  else if (propName = 'communication') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitioner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value)
  else if (propName = 'qualification') then deletePropertyValue('qualification', QualificationList, value)
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitioner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'birthDate') then BirthDateElement := asDate(new)
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new)
  else if (propName = 'qualification') then replacePropertyValue('qualification', QualificationList, existing, new)
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitioner.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'photo') then PhotoList.move(source, destination)
  else if (propName = 'qualification') then QualificationList.move(source, destination)
  else if (propName = 'communication') then CommunicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitioner.fhirType : string;
begin
  result := 'Practitioner';
end;

function TFhirPractitioner.Link : TFhirPractitioner;
begin
  result := TFhirPractitioner(inherited Link);
end;

function TFhirPractitioner.Clone : TFhirPractitioner;
begin
  result := TFhirPractitioner(inherited Clone);
end;

function TFhirPractitioner.equals(other : TObject) : boolean; 
var
  o : TFhirPractitioner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitioner)) then
    result := false
  else
  begin
    o := TFhirPractitioner(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(genderElement, o.genderElement, true) and 
      compareDeep(birthDateElement, o.birthDateElement, true) and compareDeep(photoList, o.photoList, true) and 
      compareDeep(qualificationList, o.qualificationList, true) and compareDeep(communicationList, o.communicationList, true);
  end;
end;

function TFhirPractitioner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FaddressList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FphotoList) and isEmptyProp(FqualificationList) and isEmptyProp(FcommunicationList);
end;

procedure TFhirPractitioner.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('name');
  fields.add('telecom');
  fields.add('address');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('photo');
  fields.add('qualification');
  fields.add('communication');
end;

function TFhirPractitioner.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FPhotoList.sizeInBytes(magic));
  inc(result, FQualificationList.sizeInBytes(magic));
  inc(result, FCommunicationList.sizeInBytes(magic));
end;

function TFhirPractitioner.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPractitioner.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPractitioner.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirPractitioner.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPractitioner.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

function TFhirPractitioner.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirPractitioner.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirPractitioner.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPractitioner.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirPractitioner.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirPractitioner.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

procedure TFhirPractitioner.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirPractitioner.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirPractitioner.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirPractitioner.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

function TFhirPractitioner.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirPractitioner.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.Create;
  FBirthDate.value := value
end;

function TFhirPractitioner.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirPractitioner.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

function TFhirPractitioner.GetQualificationList : TFhirPractitionerQualificationList;
begin
  if FQualificationList = nil then
    FQualificationList := TFhirPractitionerQualificationList.Create;
  result := FQualificationList;
end;

function TFhirPractitioner.GetHasQualificationList : boolean;
begin
  result := (FQualificationList <> nil) and (FQualificationList.count > 0);
end;

function TFhirPractitioner.GetCommunicationList : TFhirCodeableConceptList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirCodeableConceptList.Create;
  result := FCommunicationList;
end;

function TFhirPractitioner.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

{ TFhirPractitionerListEnumerator }

constructor TFhirPractitionerListEnumerator.Create(list : TFhirPractitionerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerListEnumerator.GetCurrent : TFhirPractitioner;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerList }

function TFhirPractitionerList.AddItem(value: TFhirPractitioner): TFhirPractitioner;
begin
  assert(value.ClassName = 'TFhirPractitioner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitioner');
  add(value);
  result := value;
end;

function TFhirPractitionerList.Append: TFhirPractitioner;
begin
  result := TFhirPractitioner.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerList.GetEnumerator : TFhirPractitionerListEnumerator;
begin
  result := TFhirPractitionerListEnumerator.Create(self.link);
end;

function TFhirPractitionerList.Clone: TFhirPractitionerList;
begin
  result := TFhirPractitionerList(inherited Clone);
end;

function TFhirPractitionerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerList.GetItemN(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner(ObjectByIndex[index]);
end;

function TFhirPractitionerList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitioner;
end;
function TFhirPractitionerList.IndexOf(value: TFhirPractitioner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerList.Insert(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerList.InsertItem(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  Inherited Insert(index, value);
end;

function TFhirPractitionerList.Item(index: Integer): TFhirPractitioner;
begin
  result := TFhirPractitioner(ObjectByIndex[index]);
end;

function TFhirPractitionerList.Link: TFhirPractitionerList;
begin
  result := TFhirPractitionerList(inherited Link);
end;

procedure TFhirPractitionerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerList.SetItemByIndex(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  FhirPractitioners[index] := value;
end;

procedure TFhirPractitionerList.SetItemN(index: Integer; value: TFhirPractitioner);
begin
  assert(value is TFhirPractitioner);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PRACTITIONER}
{$IFDEF FHIR_PRACTITIONERROLE}
{ TFhirPractitionerRoleAvailableTime }

constructor TFhirPractitionerRoleAvailableTime.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRoleAvailableTime.Destroy;
begin
  FDaysOfWeek.free;
  FAllDay.free;
  FAvailableStartTime.free;
  FAvailableEndTime.free;
  inherited;
end;

procedure TFhirPractitionerRoleAvailableTime.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerRoleAvailableTime(oSource).FDaysOfWeek = nil) then
  begin
    FDaysOfWeek.free;
    FDaysOfWeek := nil;
  end
  else
  begin
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
    FDaysOfWeek.Assign(TFhirPractitionerRoleAvailableTime(oSource).FDaysOfWeek);
  end;
  allDayElement := TFhirPractitionerRoleAvailableTime(oSource).allDayElement.Clone;
  availableStartTimeElement := TFhirPractitionerRoleAvailableTime(oSource).availableStartTimeElement.Clone;
  availableEndTimeElement := TFhirPractitionerRoleAvailableTime(oSource).availableEndTimeElement.Clone;
end;

procedure TFhirPractitionerRoleAvailableTime.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'daysOfWeek') Then
     list.addAll(self, 'daysOfWeek', FDaysOfWeek);
  if (child_name = 'allDay') Then
     list.add(self.link, 'allDay', FAllDay.Link);
  if (child_name = 'availableStartTime') Then
     list.add(self.link, 'availableStartTime', FAvailableStartTime.Link);
  if (child_name = 'availableEndTime') Then
     list.add(self.link, 'availableEndTime', FAvailableEndTime.Link);
end;

procedure TFhirPractitionerRoleAvailableTime.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'daysOfWeek', 'code', true, TFhirEnum, FDaysOfWeek.Link));
  oList.add(TFHIRProperty.Create(self, 'allDay', 'boolean', false, TFhirBoolean, FAllDay.Link));
  oList.add(TFHIRProperty.Create(self, 'availableStartTime', 'time', false, TFhirTime, FAvailableStartTime.Link));
  oList.add(TFHIRProperty.Create(self, 'availableEndTime', 'time', false, TFhirTime, FAvailableEndTime.Link));
end;

function TFhirPractitionerRoleAvailableTime.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'daysOfWeek') then
  begin
    DaysOfWeekList.add(asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue));
    result := propValue;
  end
  else if (propName = 'allDay') then
  begin
    AllDayElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'availableStartTime') then
  begin
    AvailableStartTimeElement := asTime(propValue);
    result := propValue;
  end
  else if (propName = 'availableEndTime') then
  begin
    AvailableEndTimeElement := asTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerRoleAvailableTime.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.insertItem(index, asEnum(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum, propValue))
  else inherited;
end;

function TFhirPractitionerRoleAvailableTime.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'allDay') then result := TFhirBoolean.Create()
  else if (propName = 'availableStartTime') then result := TFhirTime.Create()
  else if (propName = 'availableEndTime') then result := TFhirTime.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRoleAvailableTime.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'daysOfWeek') then result := 'code'
  else if (propName = 'allDay') then result := 'boolean'
  else if (propName = 'availableStartTime') then result := 'time'
  else if (propName = 'availableEndTime') then result := 'time'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRoleAvailableTime.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := nil
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := nil
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRoleAvailableTime.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'allDay') then AllDayElement := asBoolean(new)
  else if (propName = 'availableStartTime') then AvailableStartTimeElement := asTime(new)
  else if (propName = 'availableEndTime') then AvailableEndTimeElement := asTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRoleAvailableTime.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'daysOfWeek') then FDaysOfWeek.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRoleAvailableTime.fhirType : string;
begin
  result := 'PractitionerRole.availableTime';
end;

function TFhirPractitionerRoleAvailableTime.Link : TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(inherited Link);
end;

function TFhirPractitionerRoleAvailableTime.Clone : TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(inherited Clone);
end;

function TFhirPractitionerRoleAvailableTime.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRoleAvailableTime;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRoleAvailableTime)) then
    result := false
  else
  begin
    o := TFhirPractitionerRoleAvailableTime(other);
    result := compareDeep(daysOfWeekList, o.daysOfWeekList, true) and compareDeep(allDayElement, o.allDayElement, true) and 
      compareDeep(availableStartTimeElement, o.availableStartTimeElement, true) and 
      compareDeep(availableEndTimeElement, o.availableEndTimeElement, true);
  end;
end;

function TFhirPractitionerRoleAvailableTime.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDaysOfWeek) and isEmptyProp(FAllDay) and isEmptyProp(FAvailableStartTime) and isEmptyProp(FAvailableEndTime);
end;

procedure TFhirPractitionerRoleAvailableTime.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('daysOfWeek');
  fields.add('allDay');
  fields.add('availableStartTime');
  fields.add('availableEndTime');
end;

function TFhirPractitionerRoleAvailableTime.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDaysOfWeek.sizeInBytes(magic));
end;

function TFhirPractitionerRoleAvailableTime.GetDaysOfWeek : TFhirEnumList;
begin
  if FDaysOfWeek = nil then
    FDaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  result := FDaysOfWeek;
end;

function TFhirPractitionerRoleAvailableTime.GetHasDaysOfWeek : boolean;
begin
  result := (FDaysOfWeek <> nil) and (FDaysOfWeek.count > 0);
end;

function TFhirPractitionerRoleAvailableTime.GetDaysOfWeekST : TFhirDaysOfWeekEnumList;
  var i : integer;
begin
  result := [];
  if FdaysOfWeek <> nil then
    for i := 0 to FdaysOfWeek.count - 1 do
      result := result + [TFhirDaysOfWeekEnum(StringArrayIndexOfSensitive(CODES_TFhirDaysOfWeekEnum, FdaysOfWeek[i].value))];
end;

procedure TFhirPractitionerRoleAvailableTime.SetDaysOfWeekST(value : TFhirDaysOfWeekEnumList);
var a : TFhirDaysOfWeekEnum;
begin
  if FdaysOfWeek = nil then
    FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
  FdaysOfWeek.clear;
  for a := low(TFhirDaysOfWeekEnum) to high(TFhirDaysOfWeekEnum) do
    if a in value then
      begin
         if FdaysOfWeek = nil then
           FdaysOfWeek := TFhirEnumList.Create(SYSTEMS_TFhirDaysOfWeekEnum, CODES_TFhirDaysOfWeekEnum);
         FdaysOfWeek.add(TFhirEnum.Create(SYSTEMS_TFhirDaysOfWeekEnum[a], CODES_TFhirDaysOfWeekEnum[a]));
      end;
end;

procedure TFhirPractitionerRoleAvailableTime.SetAllDay(value : TFhirBoolean);
begin
  FAllDay.free;
  FAllDay := value;
end;

function TFhirPractitionerRoleAvailableTime.GetAllDayST : Boolean;
begin
  if FAllDay = nil then
    result := false
  else
    result := FAllDay.value;
end;

procedure TFhirPractitionerRoleAvailableTime.SetAllDayST(value : Boolean);
begin
  if FAllDay = nil then
    FAllDay := TFhirBoolean.Create;
  FAllDay.value := value
end;

procedure TFhirPractitionerRoleAvailableTime.SetAvailableStartTime(value : TFhirTime);
begin
  FAvailableStartTime.free;
  FAvailableStartTime := value;
end;

function TFhirPractitionerRoleAvailableTime.GetAvailableStartTimeST : String;
begin
  if FAvailableStartTime = nil then
    result := ''
  else
    result := FAvailableStartTime.value;
end;

procedure TFhirPractitionerRoleAvailableTime.SetAvailableStartTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableStartTime = nil then
      FAvailableStartTime := TFhirTime.Create;
    FAvailableStartTime.value := value
  end
  else if FAvailableStartTime <> nil then
    FAvailableStartTime.value := '';
end;

procedure TFhirPractitionerRoleAvailableTime.SetAvailableEndTime(value : TFhirTime);
begin
  FAvailableEndTime.free;
  FAvailableEndTime := value;
end;

function TFhirPractitionerRoleAvailableTime.GetAvailableEndTimeST : String;
begin
  if FAvailableEndTime = nil then
    result := ''
  else
    result := FAvailableEndTime.value;
end;

procedure TFhirPractitionerRoleAvailableTime.SetAvailableEndTimeST(value : String);
begin
  if value <> '' then
  begin
    if FAvailableEndTime = nil then
      FAvailableEndTime := TFhirTime.Create;
    FAvailableEndTime.value := value
  end
  else if FAvailableEndTime <> nil then
    FAvailableEndTime.value := '';
end;

{ TFhirPractitionerRoleAvailableTimeListEnumerator }

constructor TFhirPractitionerRoleAvailableTimeListEnumerator.Create(list : TFhirPractitionerRoleAvailableTimeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleAvailableTimeListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerRoleAvailableTimeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleAvailableTimeListEnumerator.GetCurrent : TFhirPractitionerRoleAvailableTime;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleAvailableTimeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleAvailableTimeList }

function TFhirPractitionerRoleAvailableTimeList.AddItem(value: TFhirPractitionerRoleAvailableTime): TFhirPractitionerRoleAvailableTime;
begin
  assert(value.ClassName = 'TFhirPractitionerRoleAvailableTime', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerRoleAvailableTime');
  add(value);
  result := value;
end;

function TFhirPractitionerRoleAvailableTimeList.Append: TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleAvailableTimeList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleAvailableTimeList.GetEnumerator : TFhirPractitionerRoleAvailableTimeListEnumerator;
begin
  result := TFhirPractitionerRoleAvailableTimeListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleAvailableTimeList.Clone: TFhirPractitionerRoleAvailableTimeList;
begin
  result := TFhirPractitionerRoleAvailableTimeList(inherited Clone);
end;

function TFhirPractitionerRoleAvailableTimeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleAvailableTimeList.GetItemN(index: Integer): TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleAvailableTimeList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRoleAvailableTime;
end;
function TFhirPractitionerRoleAvailableTimeList.IndexOf(value: TFhirPractitionerRoleAvailableTime): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleAvailableTimeList.Insert(index: Integer): TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleAvailableTimeList.InsertItem(index: Integer; value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value is TFhirPractitionerRoleAvailableTime);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleAvailableTimeList.Item(index: Integer): TFhirPractitionerRoleAvailableTime;
begin
  result := TFhirPractitionerRoleAvailableTime(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleAvailableTimeList.Link: TFhirPractitionerRoleAvailableTimeList;
begin
  result := TFhirPractitionerRoleAvailableTimeList(inherited Link);
end;

procedure TFhirPractitionerRoleAvailableTimeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleAvailableTimeList.SetItemByIndex(index: Integer; value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value is TFhirPractitionerRoleAvailableTime);
  FhirPractitionerRoleAvailableTimes[index] := value;
end;

procedure TFhirPractitionerRoleAvailableTimeList.SetItemN(index: Integer; value: TFhirPractitionerRoleAvailableTime);
begin
  assert(value is TFhirPractitionerRoleAvailableTime);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitionerRoleNotAvailable }

constructor TFhirPractitionerRoleNotAvailable.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRoleNotAvailable.Destroy;
begin
  FDescription.free;
  FDuring.free;
  inherited;
end;

procedure TFhirPractitionerRoleNotAvailable.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirPractitionerRoleNotAvailable(oSource).descriptionElement.Clone;
  during := TFhirPractitionerRoleNotAvailable(oSource).during.Clone;
end;

procedure TFhirPractitionerRoleNotAvailable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'during') Then
     list.add(self.link, 'during', FDuring.Link);
end;

procedure TFhirPractitionerRoleNotAvailable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.Create(self, 'during', 'Period', false, TFhirPeriod, FDuring.Link));
end;

function TFhirPractitionerRoleNotAvailable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'during') then
  begin
    During := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerRoleNotAvailable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPractitionerRoleNotAvailable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.Create()
  else if (propName = 'during') then result := TFhirPeriod.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRoleNotAvailable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'during') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRoleNotAvailable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'during') then DuringElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRoleNotAvailable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'during') then DuringElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRoleNotAvailable.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRoleNotAvailable.fhirType : string;
begin
  result := 'PractitionerRole.notAvailable';
end;

function TFhirPractitionerRoleNotAvailable.Link : TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(inherited Link);
end;

function TFhirPractitionerRoleNotAvailable.Clone : TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(inherited Clone);
end;

function TFhirPractitionerRoleNotAvailable.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRoleNotAvailable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRoleNotAvailable)) then
    result := false
  else
  begin
    o := TFhirPractitionerRoleNotAvailable(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(duringElement, o.duringElement, true);
  end;
end;

function TFhirPractitionerRoleNotAvailable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FDuring);
end;

procedure TFhirPractitionerRoleNotAvailable.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('during');
end;

function TFhirPractitionerRoleNotAvailable.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPractitionerRoleNotAvailable.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirPractitionerRoleNotAvailable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPractitionerRoleNotAvailable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.Create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirPractitionerRoleNotAvailable.SetDuring(value : TFhirPeriod);
begin
  FDuring.free;
  FDuring := value;
end;

{ TFhirPractitionerRoleNotAvailableListEnumerator }

constructor TFhirPractitionerRoleNotAvailableListEnumerator.Create(list : TFhirPractitionerRoleNotAvailableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleNotAvailableListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerRoleNotAvailableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleNotAvailableListEnumerator.GetCurrent : TFhirPractitionerRoleNotAvailable;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleNotAvailableListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleNotAvailableList }

function TFhirPractitionerRoleNotAvailableList.AddItem(value: TFhirPractitionerRoleNotAvailable): TFhirPractitionerRoleNotAvailable;
begin
  assert(value.ClassName = 'TFhirPractitionerRoleNotAvailable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerRoleNotAvailable');
  add(value);
  result := value;
end;

function TFhirPractitionerRoleNotAvailableList.Append: TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleNotAvailableList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleNotAvailableList.GetEnumerator : TFhirPractitionerRoleNotAvailableListEnumerator;
begin
  result := TFhirPractitionerRoleNotAvailableListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleNotAvailableList.Clone: TFhirPractitionerRoleNotAvailableList;
begin
  result := TFhirPractitionerRoleNotAvailableList(inherited Clone);
end;

function TFhirPractitionerRoleNotAvailableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleNotAvailableList.GetItemN(index: Integer): TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleNotAvailableList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRoleNotAvailable;
end;
function TFhirPractitionerRoleNotAvailableList.IndexOf(value: TFhirPractitionerRoleNotAvailable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleNotAvailableList.Insert(index: Integer): TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleNotAvailableList.InsertItem(index: Integer; value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value is TFhirPractitionerRoleNotAvailable);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleNotAvailableList.Item(index: Integer): TFhirPractitionerRoleNotAvailable;
begin
  result := TFhirPractitionerRoleNotAvailable(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleNotAvailableList.Link: TFhirPractitionerRoleNotAvailableList;
begin
  result := TFhirPractitionerRoleNotAvailableList(inherited Link);
end;

procedure TFhirPractitionerRoleNotAvailableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleNotAvailableList.SetItemByIndex(index: Integer; value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value is TFhirPractitionerRoleNotAvailable);
  FhirPractitionerRoleNotAvailables[index] := value;
end;

procedure TFhirPractitionerRoleNotAvailableList.SetItemN(index: Integer; value: TFhirPractitionerRoleNotAvailable);
begin
  assert(value is TFhirPractitionerRoleNotAvailable);
  ObjectByIndex[index] := value;
end;

{ TFhirPractitionerRole }

constructor TFhirPractitionerRole.Create;
begin
  inherited;
end;

destructor TFhirPractitionerRole.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FPeriod.free;
  FPractitioner.free;
  FOrganization.free;
  FCodeList.free;
  FSpecialtyList.free;
  FLocationList.free;
  FHealthcareServiceList.free;
  FTelecomList.free;
  FAvailableTimeList.free;
  FNotAvailableList.free;
  FAvailabilityExceptions.free;
  FEndpointList.free;
  inherited;
end;

procedure TFhirPractitionerRole.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirPractitionerRole(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPractitionerRole(oSource).FIdentifierList);
  end;
  activeElement := TFhirPractitionerRole(oSource).activeElement.Clone;
  period := TFhirPractitionerRole(oSource).period.Clone;
  practitioner := TFhirPractitionerRole(oSource).practitioner.Clone;
  organization := TFhirPractitionerRole(oSource).organization.Clone;
  if (TFhirPractitionerRole(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirPractitionerRole(oSource).FCodeList);
  end;
  if (TFhirPractitionerRole(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirPractitionerRole(oSource).FSpecialtyList);
  end;
  if (TFhirPractitionerRole(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirReferenceList.Create;
    FLocationList.Assign(TFhirPractitionerRole(oSource).FLocationList);
  end;
  if (TFhirPractitionerRole(oSource).FHealthcareServiceList = nil) then
  begin
    FHealthcareServiceList.free;
    FHealthcareServiceList := nil;
  end
  else
  begin
    if FHealthcareServiceList = nil then
      FHealthcareServiceList := TFhirReferenceList.Create;
    FHealthcareServiceList.Assign(TFhirPractitionerRole(oSource).FHealthcareServiceList);
  end;
  if (TFhirPractitionerRole(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirPractitionerRole(oSource).FTelecomList);
  end;
  if (TFhirPractitionerRole(oSource).FAvailableTimeList = nil) then
  begin
    FAvailableTimeList.free;
    FAvailableTimeList := nil;
  end
  else
  begin
    if FAvailableTimeList = nil then
      FAvailableTimeList := TFhirPractitionerRoleAvailableTimeList.Create;
    FAvailableTimeList.Assign(TFhirPractitionerRole(oSource).FAvailableTimeList);
  end;
  if (TFhirPractitionerRole(oSource).FNotAvailableList = nil) then
  begin
    FNotAvailableList.free;
    FNotAvailableList := nil;
  end
  else
  begin
    if FNotAvailableList = nil then
      FNotAvailableList := TFhirPractitionerRoleNotAvailableList.Create;
    FNotAvailableList.Assign(TFhirPractitionerRole(oSource).FNotAvailableList);
  end;
  availabilityExceptionsElement := TFhirPractitionerRole(oSource).availabilityExceptionsElement.Clone;
  if (TFhirPractitionerRole(oSource).FEndpointList = nil) then
  begin
    FEndpointList.free;
    FEndpointList := nil;
  end
  else
  begin
    if FEndpointList = nil then
      FEndpointList := TFhirReferenceList.Create;
    FEndpointList.Assign(TFhirPractitionerRole(oSource).FEndpointList);
  end;
end;

function TFhirPractitionerRole.GetResourceType : TFhirResourceType;
begin
  result := frtPractitionerRole;
end;

procedure TFhirPractitionerRole.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'practitioner') Then
     list.add(self.link, 'practitioner', FPractitioner.Link);
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'healthcareService') Then
    list.addAll(self, 'healthcareService', FHealthcareServiceList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'availableTime') Then
    list.addAll(self, 'availableTime', FAvailableTimeList);
  if (child_name = 'notAvailable') Then
    list.addAll(self, 'notAvailable', FNotAvailableList);
  if (child_name = 'availabilityExceptions') Then
     list.add(self.link, 'availabilityExceptions', FAvailabilityExceptions.Link);
  if (child_name = 'endpoint') Then
    list.addAll(self, 'endpoint', FEndpointList);
end;

procedure TFhirPractitionerRole.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'practitioner', 'Reference', false, TFhirReference, FPractitioner.Link));
  oList.add(TFHIRProperty.Create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.Create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.Create(self, 'location', 'Reference', true, TFhirReference, FLocationList.Link));
  oList.add(TFHIRProperty.Create(self, 'healthcareService', 'Reference', true, TFhirReference, FHealthcareServiceList.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'availableTime', 'BackboneElement', true, TFhirPractitionerRoleAvailableTime, FAvailableTimeList.Link));
  oList.add(TFHIRProperty.Create(self, 'notAvailable', 'BackboneElement', true, TFhirPractitionerRoleNotAvailable, FNotAvailableList.Link));
  oList.add(TFHIRProperty.Create(self, 'availabilityExceptions', 'string', false, TFhirString, FAvailabilityExceptions.Link));
  oList.add(TFHIRProperty.Create(self, 'endpoint', 'Reference', true, TFhirReference, FEndpointList.Link));
end;

function TFhirPractitionerRole.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'practitioner') then
  begin
    Practitioner := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'healthcareService') then
  begin
    HealthcareServiceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'availableTime') then
  begin
    AvailableTimeList.add(propValue as TFhirPractitionerRoleAvailableTime);
    result := propValue;
  end
  else if (propName = 'notAvailable') then
  begin
    NotAvailableList.add(propValue as TFhirPractitionerRoleNotAvailable);
    result := propValue;
  end
  else if (propName = 'availabilityExceptions') then
  begin
    AvailabilityExceptionsElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPractitionerRole.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'healthcareService') then HealthcareServiceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'availableTime') then AvailableTimeList.insertItem(index, propValue as TFhirPractitionerRoleAvailableTime)
  else if (propName = 'notAvailable') then NotAvailableList.insertItem(index, propValue as TFhirPractitionerRoleNotAvailable)
  else if (propName = 'endpoint') then EndpointList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirPractitionerRole.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else if (propName = 'practitioner') then result := TFhirReference.Create()
  else if (propName = 'organization') then result := TFhirReference.Create()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'healthcareService') then result := HealthcareServiceList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'availableTime') then result := AvailableTimeList.new()
  else if (propName = 'notAvailable') then result := NotAvailableList.new()
  else if (propName = 'availabilityExceptions') then result := TFhirString.Create()
  else if (propName = 'endpoint') then result := EndpointList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPractitionerRole.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'practitioner') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'healthcareService') then result := 'Reference'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'availableTime') then result := 'BackboneElement'
  else if (propName = 'notAvailable') then result := 'BackboneElement'
  else if (propName = 'availabilityExceptions') then result := 'string'
  else if (propName = 'endpoint') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPractitionerRole.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'practitioner') then PractitionerElement := nil
  else if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'healthcareService') then deletePropertyValue('healthcareService', HealthcareServiceList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'availableTime') then deletePropertyValue('availableTime', AvailableTimeList, value)
  else if (propName = 'notAvailable') then deletePropertyValue('notAvailable', NotAvailableList, value)
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := nil
  else if (propName = 'endpoint') then deletePropertyValue('endpoint', EndpointList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPractitionerRole.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'practitioner') then PractitionerElement := new as TFhirReference
  else if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'healthcareService') then replacePropertyValue('healthcareService', HealthcareServiceList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'availableTime') then replacePropertyValue('availableTime', AvailableTimeList, existing, new)
  else if (propName = 'notAvailable') then replacePropertyValue('notAvailable', NotAvailableList, existing, new)
  else if (propName = 'availabilityExceptions') then AvailabilityExceptionsElement := asString(new)
  else if (propName = 'endpoint') then replacePropertyValue('endpoint', EndpointList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPractitionerRole.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'healthcareService') then HealthcareServiceList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'availableTime') then AvailableTimeList.move(source, destination)
  else if (propName = 'notAvailable') then NotAvailableList.move(source, destination)
  else if (propName = 'endpoint') then EndpointList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPractitionerRole.fhirType : string;
begin
  result := 'PractitionerRole';
end;

function TFhirPractitionerRole.Link : TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(inherited Link);
end;

function TFhirPractitionerRole.Clone : TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(inherited Clone);
end;

function TFhirPractitionerRole.equals(other : TObject) : boolean; 
var
  o : TFhirPractitionerRole;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPractitionerRole)) then
    result := false
  else
  begin
    o := TFhirPractitionerRole(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(practitionerElement, o.practitionerElement, true) and 
      compareDeep(organizationElement, o.organizationElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(healthcareServiceList, o.healthcareServiceList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(availableTimeList, o.availableTimeList, true) and compareDeep(notAvailableList, o.notAvailableList, true) and 
      compareDeep(availabilityExceptionsElement, o.availabilityExceptionsElement, true) and 
      compareDeep(endpointList, o.endpointList, true);
  end;
end;

function TFhirPractitionerRole.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPeriod) and isEmptyProp(FPractitioner) and isEmptyProp(FOrganization) and isEmptyProp(FcodeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FlocationList) and isEmptyProp(FhealthcareServiceList) and isEmptyProp(FtelecomList) and isEmptyProp(FavailableTimeList) and isEmptyProp(FnotAvailableList) and isEmptyProp(FAvailabilityExceptions) and isEmptyProp(FendpointList);
end;

procedure TFhirPractitionerRole.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('period');
  fields.add('practitioner');
  fields.add('organization');
  fields.add('code');
  fields.add('specialty');
  fields.add('location');
  fields.add('healthcareService');
  fields.add('telecom');
  fields.add('availableTime');
  fields.add('notAvailable');
  fields.add('availabilityExceptions');
  fields.add('endpoint');
end;

function TFhirPractitionerRole.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FHealthcareServiceList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAvailableTimeList.sizeInBytes(magic));
  inc(result, FNotAvailableList.sizeInBytes(magic));
  inc(result, FEndpointList.sizeInBytes(magic));
end;

function TFhirPractitionerRole.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPractitionerRole.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPractitionerRole.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirPractitionerRole.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirPractitionerRole.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

procedure TFhirPractitionerRole.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirPractitionerRole.SetPractitioner(value : TFhirReference);
begin
  FPractitioner.free;
  FPractitioner := value;
end;

procedure TFhirPractitionerRole.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

function TFhirPractitionerRole.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirPractitionerRole.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirPractitionerRole.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirPractitionerRole.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirPractitionerRole.GetLocationList : TFhirReferenceList;
begin
  if FLocationList = nil then
    FLocationList := TFhirReferenceList.Create;
  result := FLocationList;
end;

function TFhirPractitionerRole.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirPractitionerRole.GetHealthcareServiceList : TFhirReferenceList;
begin
  if FHealthcareServiceList = nil then
    FHealthcareServiceList := TFhirReferenceList.Create;
  result := FHealthcareServiceList;
end;

function TFhirPractitionerRole.GetHasHealthcareServiceList : boolean;
begin
  result := (FHealthcareServiceList <> nil) and (FHealthcareServiceList.count > 0);
end;

function TFhirPractitionerRole.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirPractitionerRole.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

function TFhirPractitionerRole.GetAvailableTimeList : TFhirPractitionerRoleAvailableTimeList;
begin
  if FAvailableTimeList = nil then
    FAvailableTimeList := TFhirPractitionerRoleAvailableTimeList.Create;
  result := FAvailableTimeList;
end;

function TFhirPractitionerRole.GetHasAvailableTimeList : boolean;
begin
  result := (FAvailableTimeList <> nil) and (FAvailableTimeList.count > 0);
end;

function TFhirPractitionerRole.GetNotAvailableList : TFhirPractitionerRoleNotAvailableList;
begin
  if FNotAvailableList = nil then
    FNotAvailableList := TFhirPractitionerRoleNotAvailableList.Create;
  result := FNotAvailableList;
end;

function TFhirPractitionerRole.GetHasNotAvailableList : boolean;
begin
  result := (FNotAvailableList <> nil) and (FNotAvailableList.count > 0);
end;

procedure TFhirPractitionerRole.SetAvailabilityExceptions(value : TFhirString);
begin
  FAvailabilityExceptions.free;
  FAvailabilityExceptions := value;
end;

function TFhirPractitionerRole.GetAvailabilityExceptionsST : String;
begin
  if FAvailabilityExceptions = nil then
    result := ''
  else
    result := FAvailabilityExceptions.value;
end;

procedure TFhirPractitionerRole.SetAvailabilityExceptionsST(value : String);
begin
  if value <> '' then
  begin
    if FAvailabilityExceptions = nil then
      FAvailabilityExceptions := TFhirString.Create;
    FAvailabilityExceptions.value := value
  end
  else if FAvailabilityExceptions <> nil then
    FAvailabilityExceptions.value := '';
end;

function TFhirPractitionerRole.GetEndpointList : TFhirReferenceList;
begin
  if FEndpointList = nil then
    FEndpointList := TFhirReferenceList.Create;
  result := FEndpointList;
end;

function TFhirPractitionerRole.GetHasEndpointList : boolean;
begin
  result := (FEndpointList <> nil) and (FEndpointList.count > 0);
end;

{ TFhirPractitionerRoleListEnumerator }

constructor TFhirPractitionerRoleListEnumerator.Create(list : TFhirPractitionerRoleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPractitionerRoleListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirPractitionerRoleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPractitionerRoleListEnumerator.GetCurrent : TFhirPractitionerRole;
begin
  Result := FList[FIndex];
end;

function TFhirPractitionerRoleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPractitionerRoleList }

function TFhirPractitionerRoleList.AddItem(value: TFhirPractitionerRole): TFhirPractitionerRole;
begin
  assert(value.ClassName = 'TFhirPractitionerRole', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPractitionerRole');
  add(value);
  result := value;
end;

function TFhirPractitionerRoleList.Append: TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleList.ClearItems;
begin
  Clear;
end;

function TFhirPractitionerRoleList.GetEnumerator : TFhirPractitionerRoleListEnumerator;
begin
  result := TFhirPractitionerRoleListEnumerator.Create(self.link);
end;

function TFhirPractitionerRoleList.Clone: TFhirPractitionerRoleList;
begin
  result := TFhirPractitionerRoleList(inherited Clone);
end;

function TFhirPractitionerRoleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPractitionerRoleList.GetItemN(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleList.ItemClass: TFslObjectClass;
begin
  result := TFhirPractitionerRole;
end;
function TFhirPractitionerRoleList.IndexOf(value: TFhirPractitionerRole): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPractitionerRoleList.Insert(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPractitionerRoleList.InsertItem(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  Inherited Insert(index, value);
end;

function TFhirPractitionerRoleList.Item(index: Integer): TFhirPractitionerRole;
begin
  result := TFhirPractitionerRole(ObjectByIndex[index]);
end;

function TFhirPractitionerRoleList.Link: TFhirPractitionerRoleList;
begin
  result := TFhirPractitionerRoleList(inherited Link);
end;

procedure TFhirPractitionerRoleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPractitionerRoleList.SetItemByIndex(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  FhirPractitionerRoles[index] := value;
end;

procedure TFhirPractitionerRoleList.SetItemN(index: Integer; value: TFhirPractitionerRole);
begin
  assert(value is TFhirPractitionerRole);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PRACTITIONERROLE}
{$IFDEF FHIR_RELATEDPERSON}
{ TFhirRelatedPersonCommunication }

constructor TFhirRelatedPersonCommunication.Create;
begin
  inherited;
end;

destructor TFhirRelatedPersonCommunication.Destroy;
begin
  FLanguage.free;
  FPreferred.free;
  inherited;
end;

procedure TFhirRelatedPersonCommunication.Assign(oSource : TFslObject);
begin
  inherited;
  language := TFhirRelatedPersonCommunication(oSource).language.Clone;
  preferredElement := TFhirRelatedPersonCommunication(oSource).preferredElement.Clone;
end;

procedure TFhirRelatedPersonCommunication.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'language') Then
     list.add(self.link, 'language', FLanguage.Link);
  if (child_name = 'preferred') Then
     list.add(self.link, 'preferred', FPreferred.Link);
end;

procedure TFhirRelatedPersonCommunication.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'language', 'CodeableConcept', false, TFhirCodeableConcept, FLanguage.Link));
  oList.add(TFHIRProperty.Create(self, 'preferred', 'boolean', false, TFhirBoolean, FPreferred.Link));
end;

function TFhirRelatedPersonCommunication.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'language') then
  begin
    Language := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'preferred') then
  begin
    PreferredElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRelatedPersonCommunication.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRelatedPersonCommunication.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'language') then result := TFhirCodeableConcept.Create()
  else if (propName = 'preferred') then result := TFhirBoolean.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRelatedPersonCommunication.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'language') then result := 'CodeableConcept'
  else if (propName = 'preferred') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRelatedPersonCommunication.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := nil
  else if (propName = 'preferred') then PreferredElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRelatedPersonCommunication.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'language') then LanguageElement := new as TFhirCodeableConcept
  else if (propName = 'preferred') then PreferredElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRelatedPersonCommunication.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRelatedPersonCommunication.fhirType : string;
begin
  result := 'RelatedPerson.communication';
end;

function TFhirRelatedPersonCommunication.Link : TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(inherited Link);
end;

function TFhirRelatedPersonCommunication.Clone : TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(inherited Clone);
end;

function TFhirRelatedPersonCommunication.equals(other : TObject) : boolean; 
var
  o : TFhirRelatedPersonCommunication;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRelatedPersonCommunication)) then
    result := false
  else
  begin
    o := TFhirRelatedPersonCommunication(other);
    result := compareDeep(languageElement, o.languageElement, true) and compareDeep(preferredElement, o.preferredElement, true);
  end;
end;

function TFhirRelatedPersonCommunication.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLanguage) and isEmptyProp(FPreferred);
end;

procedure TFhirRelatedPersonCommunication.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('language');
  fields.add('preferred');
end;

function TFhirRelatedPersonCommunication.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRelatedPersonCommunication.SetLanguage(value : TFhirCodeableConcept);
begin
  FLanguage.free;
  FLanguage := value;
end;

procedure TFhirRelatedPersonCommunication.SetPreferred(value : TFhirBoolean);
begin
  FPreferred.free;
  FPreferred := value;
end;

function TFhirRelatedPersonCommunication.GetPreferredST : Boolean;
begin
  if FPreferred = nil then
    result := false
  else
    result := FPreferred.value;
end;

procedure TFhirRelatedPersonCommunication.SetPreferredST(value : Boolean);
begin
  if FPreferred = nil then
    FPreferred := TFhirBoolean.Create;
  FPreferred.value := value
end;

{ TFhirRelatedPersonCommunicationListEnumerator }

constructor TFhirRelatedPersonCommunicationListEnumerator.Create(list : TFhirRelatedPersonCommunicationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRelatedPersonCommunicationListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirRelatedPersonCommunicationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRelatedPersonCommunicationListEnumerator.GetCurrent : TFhirRelatedPersonCommunication;
begin
  Result := FList[FIndex];
end;

function TFhirRelatedPersonCommunicationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRelatedPersonCommunicationList }

function TFhirRelatedPersonCommunicationList.AddItem(value: TFhirRelatedPersonCommunication): TFhirRelatedPersonCommunication;
begin
  assert(value.ClassName = 'TFhirRelatedPersonCommunication', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRelatedPersonCommunication');
  add(value);
  result := value;
end;

function TFhirRelatedPersonCommunicationList.Append: TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonCommunicationList.ClearItems;
begin
  Clear;
end;

function TFhirRelatedPersonCommunicationList.GetEnumerator : TFhirRelatedPersonCommunicationListEnumerator;
begin
  result := TFhirRelatedPersonCommunicationListEnumerator.Create(self.link);
end;

function TFhirRelatedPersonCommunicationList.Clone: TFhirRelatedPersonCommunicationList;
begin
  result := TFhirRelatedPersonCommunicationList(inherited Clone);
end;

function TFhirRelatedPersonCommunicationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRelatedPersonCommunicationList.GetItemN(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(ObjectByIndex[index]);
end;

function TFhirRelatedPersonCommunicationList.ItemClass: TFslObjectClass;
begin
  result := TFhirRelatedPersonCommunication;
end;
function TFhirRelatedPersonCommunicationList.IndexOf(value: TFhirRelatedPersonCommunication): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRelatedPersonCommunicationList.Insert(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonCommunicationList.InsertItem(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  Inherited Insert(index, value);
end;

function TFhirRelatedPersonCommunicationList.Item(index: Integer): TFhirRelatedPersonCommunication;
begin
  result := TFhirRelatedPersonCommunication(ObjectByIndex[index]);
end;

function TFhirRelatedPersonCommunicationList.Link: TFhirRelatedPersonCommunicationList;
begin
  result := TFhirRelatedPersonCommunicationList(inherited Link);
end;

procedure TFhirRelatedPersonCommunicationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRelatedPersonCommunicationList.SetItemByIndex(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  FhirRelatedPersonCommunications[index] := value;
end;

procedure TFhirRelatedPersonCommunicationList.SetItemN(index: Integer; value: TFhirRelatedPersonCommunication);
begin
  assert(value is TFhirRelatedPersonCommunication);
  ObjectByIndex[index] := value;
end;

{ TFhirRelatedPerson }

constructor TFhirRelatedPerson.Create;
begin
  inherited;
end;

destructor TFhirRelatedPerson.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FPatient.free;
  FRelationshipList.free;
  FNameList.free;
  FTelecomList.free;
  FGender.free;
  FBirthDate.free;
  FAddressList.free;
  FPhotoList.free;
  FPeriod.free;
  FCommunicationList.free;
  inherited;
end;

procedure TFhirRelatedPerson.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRelatedPerson(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRelatedPerson(oSource).FIdentifierList);
  end;
  activeElement := TFhirRelatedPerson(oSource).activeElement.Clone;
  patient := TFhirRelatedPerson(oSource).patient.Clone;
  if (TFhirRelatedPerson(oSource).FRelationshipList = nil) then
  begin
    FRelationshipList.free;
    FRelationshipList := nil;
  end
  else
  begin
    if FRelationshipList = nil then
      FRelationshipList := TFhirCodeableConceptList.Create;
    FRelationshipList.Assign(TFhirRelatedPerson(oSource).FRelationshipList);
  end;
  if (TFhirRelatedPerson(oSource).FNameList = nil) then
  begin
    FNameList.free;
    FNameList := nil;
  end
  else
  begin
    if FNameList = nil then
      FNameList := TFhirHumanNameList.Create;
    FNameList.Assign(TFhirRelatedPerson(oSource).FNameList);
  end;
  if (TFhirRelatedPerson(oSource).FTelecomList = nil) then
  begin
    FTelecomList.free;
    FTelecomList := nil;
  end
  else
  begin
    if FTelecomList = nil then
      FTelecomList := TFhirContactPointList.Create;
    FTelecomList.Assign(TFhirRelatedPerson(oSource).FTelecomList);
  end;
  genderElement := TFhirRelatedPerson(oSource).genderElement.Clone;
  birthDateElement := TFhirRelatedPerson(oSource).birthDateElement.Clone;
  if (TFhirRelatedPerson(oSource).FAddressList = nil) then
  begin
    FAddressList.free;
    FAddressList := nil;
  end
  else
  begin
    if FAddressList = nil then
      FAddressList := TFhirAddressList.Create;
    FAddressList.Assign(TFhirRelatedPerson(oSource).FAddressList);
  end;
  if (TFhirRelatedPerson(oSource).FPhotoList = nil) then
  begin
    FPhotoList.free;
    FPhotoList := nil;
  end
  else
  begin
    if FPhotoList = nil then
      FPhotoList := TFhirAttachmentList.Create;
    FPhotoList.Assign(TFhirRelatedPerson(oSource).FPhotoList);
  end;
  period := TFhirRelatedPerson(oSource).period.Clone;
  if (TFhirRelatedPerson(oSource).FCommunicationList = nil) then
  begin
    FCommunicationList.free;
    FCommunicationList := nil;
  end
  else
  begin
    if FCommunicationList = nil then
      FCommunicationList := TFhirRelatedPersonCommunicationList.Create;
    FCommunicationList.Assign(TFhirRelatedPerson(oSource).FCommunicationList);
  end;
end;

function TFhirRelatedPerson.GetResourceType : TFhirResourceType;
begin
  result := frtRelatedPerson;
end;

procedure TFhirRelatedPerson.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'relationship') Then
    list.addAll(self, 'relationship', FRelationshipList);
  if (child_name = 'name') Then
    list.addAll(self, 'name', FNameList);
  if (child_name = 'telecom') Then
    list.addAll(self, 'telecom', FTelecomList);
  if (child_name = 'gender') Then
     list.add(self.link, 'gender', FGender.Link);
  if (child_name = 'birthDate') Then
     list.add(self.link, 'birthDate', FBirthDate.Link);
  if (child_name = 'address') Then
    list.addAll(self, 'address', FAddressList);
  if (child_name = 'photo') Then
    list.addAll(self, 'photo', FPhotoList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'communication') Then
    list.addAll(self, 'communication', FCommunicationList);
end;

procedure TFhirRelatedPerson.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.Create(self, 'relationship', 'CodeableConcept', true, TFhirCodeableConcept, FRelationshipList.Link));
  oList.add(TFHIRProperty.Create(self, 'name', 'HumanName', true, TFhirHumanName, FNameList.Link));
  oList.add(TFHIRProperty.Create(self, 'telecom', 'ContactPoint', true, TFhirContactPoint, FTelecomList.Link));
  oList.add(TFHIRProperty.Create(self, 'gender', 'code', false, TFhirEnum, FGender.Link));
  oList.add(TFHIRProperty.Create(self, 'birthDate', 'date', false, TFhirDate, FBirthDate.Link));
  oList.add(TFHIRProperty.Create(self, 'address', 'Address', true, TFhirAddress, FAddressList.Link));
  oList.add(TFHIRProperty.Create(self, 'photo', 'Attachment', true, TFhirAttachment, FPhotoList.Link));
  oList.add(TFHIRProperty.Create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.Create(self, 'communication', 'BackboneElement', true, TFhirRelatedPersonCommunication, FCommunicationList.Link));
end;

function TFhirRelatedPerson.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameList.add(propValue as TFhirHumanName);
    result := propValue;
  end
  else if (propName = 'telecom') then
  begin
    TelecomList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'gender') then
  begin
    GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, propValue);
    result := propValue;
  end
  else if (propName = 'birthDate') then
  begin
    BirthDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'address') then
  begin
    AddressList.add(propValue as TFhirAddress);
    result := propValue;
  end
  else if (propName = 'photo') then
  begin
    PhotoList.add(propValue as TFhirAttachment);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'communication') then
  begin
    CommunicationList.add(propValue as TFhirRelatedPersonCommunication);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRelatedPerson.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'relationship') then RelationshipList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'name') then NameList.insertItem(index, propValue as TFhirHumanName)
  else if (propName = 'telecom') then TelecomList.insertItem(index, propValue as TFhirContactPoint)
  else if (propName = 'address') then AddressList.insertItem(index, propValue as TFhirAddress)
  else if (propName = 'photo') then PhotoList.insertItem(index, propValue as TFhirAttachment)
  else if (propName = 'communication') then CommunicationList.insertItem(index, propValue as TFhirRelatedPersonCommunication)
  else inherited;
end;

function TFhirRelatedPerson.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'patient') then result := TFhirReference.Create()
  else if (propName = 'relationship') then result := RelationshipList.new()
  else if (propName = 'name') then result := NameList.new()
  else if (propName = 'telecom') then result := TelecomList.new()
  else if (propName = 'gender') then result := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[AdministrativeGenderNull], CODES_TFhirAdministrativeGenderEnum[AdministrativeGenderNull]) 
  else if (propName = 'birthDate') then result := TFhirDate.Create()
  else if (propName = 'address') then result := AddressList.new()
  else if (propName = 'photo') then result := PhotoList.new()
  else if (propName = 'period') then result := TFhirPeriod.Create()
  else if (propName = 'communication') then result := CommunicationList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRelatedPerson.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'relationship') then result := 'CodeableConcept'
  else if (propName = 'name') then result := 'HumanName'
  else if (propName = 'telecom') then result := 'ContactPoint'
  else if (propName = 'gender') then result := 'code'
  else if (propName = 'birthDate') then result := 'date'
  else if (propName = 'address') then result := 'Address'
  else if (propName = 'photo') then result := 'Attachment'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'communication') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRelatedPerson.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'relationship') then deletePropertyValue('relationship', RelationshipList, value)
  else if (propName = 'name') then deletePropertyValue('name', NameList, value)
  else if (propName = 'telecom') then deletePropertyValue('telecom', TelecomList, value)
  else if (propName = 'gender') then GenderElement := nil
  else if (propName = 'birthDate') then BirthDateElement := nil
  else if (propName = 'address') then deletePropertyValue('address', AddressList, value)
  else if (propName = 'photo') then deletePropertyValue('photo', PhotoList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'communication') then deletePropertyValue('communication', CommunicationList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRelatedPerson.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'relationship') then replacePropertyValue('relationship', RelationshipList, existing, new)
  else if (propName = 'name') then replacePropertyValue('name', NameList, existing, new)
  else if (propName = 'telecom') then replacePropertyValue('telecom', TelecomList, existing, new)
  else if (propName = 'gender') then GenderElement := asEnum(SYSTEMS_TFhirAdministrativeGenderEnum, CODES_TFhirAdministrativeGenderEnum, new)
  else if (propName = 'birthDate') then BirthDateElement := asDate(new)
  else if (propName = 'address') then replacePropertyValue('address', AddressList, existing, new)
  else if (propName = 'photo') then replacePropertyValue('photo', PhotoList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'communication') then replacePropertyValue('communication', CommunicationList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRelatedPerson.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'relationship') then RelationshipList.move(source, destination)
  else if (propName = 'name') then NameList.move(source, destination)
  else if (propName = 'telecom') then TelecomList.move(source, destination)
  else if (propName = 'address') then AddressList.move(source, destination)
  else if (propName = 'photo') then PhotoList.move(source, destination)
  else if (propName = 'communication') then CommunicationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRelatedPerson.fhirType : string;
begin
  result := 'RelatedPerson';
end;

function TFhirRelatedPerson.Link : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(inherited Link);
end;

function TFhirRelatedPerson.Clone : TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(inherited Clone);
end;

function TFhirRelatedPerson.equals(other : TObject) : boolean; 
var
  o : TFhirRelatedPerson;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRelatedPerson)) then
    result := false
  else
  begin
    o := TFhirRelatedPerson(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(relationshipList, o.relationshipList, true) and 
      compareDeep(nameList, o.nameList, true) and compareDeep(telecomList, o.telecomList, true) and 
      compareDeep(genderElement, o.genderElement, true) and compareDeep(birthDateElement, o.birthDateElement, true) and 
      compareDeep(addressList, o.addressList, true) and compareDeep(photoList, o.photoList, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(communicationList, o.communicationList, true);
  end;
end;

function TFhirRelatedPerson.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FPatient) and isEmptyProp(FrelationshipList) and isEmptyProp(FnameList) and isEmptyProp(FtelecomList) and isEmptyProp(FGender) and isEmptyProp(FBirthDate) and isEmptyProp(FaddressList) and isEmptyProp(FphotoList) and isEmptyProp(FPeriod) and isEmptyProp(FcommunicationList);
end;

procedure TFhirRelatedPerson.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('patient');
  fields.add('relationship');
  fields.add('name');
  fields.add('telecom');
  fields.add('gender');
  fields.add('birthDate');
  fields.add('address');
  fields.add('photo');
  fields.add('period');
  fields.add('communication');
end;

function TFhirRelatedPerson.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRelationshipList.sizeInBytes(magic));
  inc(result, FNameList.sizeInBytes(magic));
  inc(result, FTelecomList.sizeInBytes(magic));
  inc(result, FAddressList.sizeInBytes(magic));
  inc(result, FPhotoList.sizeInBytes(magic));
  inc(result, FCommunicationList.sizeInBytes(magic));
end;

function TFhirRelatedPerson.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRelatedPerson.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirRelatedPerson.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirRelatedPerson.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirRelatedPerson.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

procedure TFhirRelatedPerson.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

function TFhirRelatedPerson.GetRelationshipList : TFhirCodeableConceptList;
begin
  if FRelationshipList = nil then
    FRelationshipList := TFhirCodeableConceptList.Create;
  result := FRelationshipList;
end;

function TFhirRelatedPerson.GetHasRelationshipList : boolean;
begin
  result := (FRelationshipList <> nil) and (FRelationshipList.count > 0);
end;

function TFhirRelatedPerson.GetNameList : TFhirHumanNameList;
begin
  if FNameList = nil then
    FNameList := TFhirHumanNameList.Create;
  result := FNameList;
end;

function TFhirRelatedPerson.GetHasNameList : boolean;
begin
  result := (FNameList <> nil) and (FNameList.count > 0);
end;

function TFhirRelatedPerson.GetTelecomList : TFhirContactPointList;
begin
  if FTelecomList = nil then
    FTelecomList := TFhirContactPointList.Create;
  result := FTelecomList;
end;

function TFhirRelatedPerson.GetHasTelecomList : boolean;
begin
  result := (FTelecomList <> nil) and (FTelecomList.count > 0);
end;

procedure TFhirRelatedPerson.SetGender(value : TFhirEnum);
begin
  FGender.free;
  FGender := value;
end;

function TFhirRelatedPerson.GetGenderST : TFhirAdministrativeGenderEnum;
begin
  if FGender = nil then
    result := TFhirAdministrativeGenderEnum(0)
  else
    result := TFhirAdministrativeGenderEnum(StringArrayIndexOfSensitive(CODES_TFhirAdministrativeGenderEnum, FGender.value));
end;

procedure TFhirRelatedPerson.SetGenderST(value : TFhirAdministrativeGenderEnum);
begin
  if ord(value) = 0 then
    GenderElement := nil
  else
    GenderElement := TFhirEnum.Create(SYSTEMS_TFhirAdministrativeGenderEnum[value], CODES_TFhirAdministrativeGenderEnum[value]);
end;

procedure TFhirRelatedPerson.SetBirthDate(value : TFhirDate);
begin
  FBirthDate.free;
  FBirthDate := value;
end;

function TFhirRelatedPerson.GetBirthDateST : TFslDateTime;
begin
  if FBirthDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FBirthDate.value;
end;

procedure TFhirRelatedPerson.SetBirthDateST(value : TFslDateTime);
begin
  if FBirthDate = nil then
    FBirthDate := TFhirDate.Create;
  FBirthDate.value := value
end;

function TFhirRelatedPerson.GetAddressList : TFhirAddressList;
begin
  if FAddressList = nil then
    FAddressList := TFhirAddressList.Create;
  result := FAddressList;
end;

function TFhirRelatedPerson.GetHasAddressList : boolean;
begin
  result := (FAddressList <> nil) and (FAddressList.count > 0);
end;

function TFhirRelatedPerson.GetPhotoList : TFhirAttachmentList;
begin
  if FPhotoList = nil then
    FPhotoList := TFhirAttachmentList.Create;
  result := FPhotoList;
end;

function TFhirRelatedPerson.GetHasPhotoList : boolean;
begin
  result := (FPhotoList <> nil) and (FPhotoList.count > 0);
end;

procedure TFhirRelatedPerson.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirRelatedPerson.GetCommunicationList : TFhirRelatedPersonCommunicationList;
begin
  if FCommunicationList = nil then
    FCommunicationList := TFhirRelatedPersonCommunicationList.Create;
  result := FCommunicationList;
end;

function TFhirRelatedPerson.GetHasCommunicationList : boolean;
begin
  result := (FCommunicationList <> nil) and (FCommunicationList.count > 0);
end;

{ TFhirRelatedPersonListEnumerator }

constructor TFhirRelatedPersonListEnumerator.Create(list : TFhirRelatedPersonList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRelatedPersonListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirRelatedPersonListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRelatedPersonListEnumerator.GetCurrent : TFhirRelatedPerson;
begin
  Result := FList[FIndex];
end;

function TFhirRelatedPersonListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRelatedPersonList }

function TFhirRelatedPersonList.AddItem(value: TFhirRelatedPerson): TFhirRelatedPerson;
begin
  assert(value.ClassName = 'TFhirRelatedPerson', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRelatedPerson');
  add(value);
  result := value;
end;

function TFhirRelatedPersonList.Append: TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonList.ClearItems;
begin
  Clear;
end;

function TFhirRelatedPersonList.GetEnumerator : TFhirRelatedPersonListEnumerator;
begin
  result := TFhirRelatedPersonListEnumerator.Create(self.link);
end;

function TFhirRelatedPersonList.Clone: TFhirRelatedPersonList;
begin
  result := TFhirRelatedPersonList(inherited Clone);
end;

function TFhirRelatedPersonList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRelatedPersonList.GetItemN(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(ObjectByIndex[index]);
end;

function TFhirRelatedPersonList.ItemClass: TFslObjectClass;
begin
  result := TFhirRelatedPerson;
end;
function TFhirRelatedPersonList.IndexOf(value: TFhirRelatedPerson): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRelatedPersonList.Insert(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRelatedPersonList.InsertItem(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  Inherited Insert(index, value);
end;

function TFhirRelatedPersonList.Item(index: Integer): TFhirRelatedPerson;
begin
  result := TFhirRelatedPerson(ObjectByIndex[index]);
end;

function TFhirRelatedPersonList.Link: TFhirRelatedPersonList;
begin
  result := TFhirRelatedPersonList(inherited Link);
end;

procedure TFhirRelatedPersonList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRelatedPersonList.SetItemByIndex(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  FhirRelatedPeople[index] := value;
end;

procedure TFhirRelatedPersonList.SetItemN(index: Integer; value: TFhirRelatedPerson);
begin
  assert(value is TFhirRelatedPerson);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RELATEDPERSON}
{$IFDEF FHIR_SCHEDULE}
{ TFhirSchedule }

constructor TFhirSchedule.Create;
begin
  inherited;
end;

destructor TFhirSchedule.Destroy;
begin
  FIdentifierList.free;
  FActive.free;
  FServiceCategoryList.free;
  FServiceTypeList.free;
  FSpecialtyList.free;
  FActorList.free;
  FPlanningHorizon.free;
  FComment.free;
  inherited;
end;

procedure TFhirSchedule.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSchedule(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSchedule(oSource).FIdentifierList);
  end;
  activeElement := TFhirSchedule(oSource).activeElement.Clone;
  if (TFhirSchedule(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirSchedule(oSource).FServiceCategoryList);
  end;
  if (TFhirSchedule(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableConceptList.Create;
    FServiceTypeList.Assign(TFhirSchedule(oSource).FServiceTypeList);
  end;
  if (TFhirSchedule(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirSchedule(oSource).FSpecialtyList);
  end;
  if (TFhirSchedule(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirReferenceList.Create;
    FActorList.Assign(TFhirSchedule(oSource).FActorList);
  end;
  planningHorizon := TFhirSchedule(oSource).planningHorizon.Clone;
  commentElement := TFhirSchedule(oSource).commentElement.Clone;
end;

function TFhirSchedule.GetResourceType : TFhirResourceType;
begin
  result := frtSchedule;
end;

procedure TFhirSchedule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'planningHorizon') Then
     list.add(self.link, 'planningHorizon', FPlanningHorizon.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirSchedule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.Create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link));
  oList.add(TFHIRProperty.Create(self, 'serviceType', 'CodeableConcept', true, TFhirCodeableConcept, FServiceTypeList.Link));
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.Create(self, 'actor', 'Reference', true, TFhirReference, FActorList.Link));
  oList.add(TFHIRProperty.Create(self, 'planningHorizon', 'Period', false, TFhirPeriod, FPlanningHorizon.Link));
  oList.add(TFHIRProperty.Create(self, 'comment', 'string', false, TFhirString, FComment.Link));
end;

function TFhirSchedule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'planningHorizon') then
  begin
    PlanningHorizon := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSchedule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSchedule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'active') then result := TFhirBoolean.Create()
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new()
  else if (propName = 'serviceType') then result := ServiceTypeList.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'actor') then result := ActorList.new()
  else if (propName = 'planningHorizon') then result := TFhirPeriod.Create()
  else if (propName = 'comment') then result := TFhirString.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSchedule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'active') then result := 'boolean'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'actor') then result := 'Reference'
  else if (propName = 'planningHorizon') then result := 'Period'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSchedule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'active') then ActiveElement := nil
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value)
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value)
  else if (propName = 'planningHorizon') then PlanningHorizonElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSchedule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new)
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new)
  else if (propName = 'planningHorizon') then PlanningHorizonElement := new as TFhirPeriod
  else if (propName = 'comment') then CommentElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSchedule.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination)
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else if (propName = 'actor') then ActorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSchedule.fhirType : string;
begin
  result := 'Schedule';
end;

function TFhirSchedule.Link : TFhirSchedule;
begin
  result := TFhirSchedule(inherited Link);
end;

function TFhirSchedule.Clone : TFhirSchedule;
begin
  result := TFhirSchedule(inherited Clone);
end;

function TFhirSchedule.equals(other : TObject) : boolean; 
var
  o : TFhirSchedule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSchedule)) then
    result := false
  else
  begin
    o := TFhirSchedule(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(activeElement, o.activeElement, true) and 
      compareDeep(serviceCategoryList, o.serviceCategoryList, true) and compareDeep(serviceTypeList, o.serviceTypeList, true) and 
      compareDeep(specialtyList, o.specialtyList, true) and compareDeep(actorList, o.actorList, true) and 
      compareDeep(planningHorizonElement, o.planningHorizonElement, true) and compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirSchedule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FActive) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FactorList) and isEmptyProp(FPlanningHorizon) and isEmptyProp(FComment);
end;

procedure TFhirSchedule.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('active');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('actor');
  fields.add('planningHorizon');
  fields.add('comment');
end;

function TFhirSchedule.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FServiceCategoryList.sizeInBytes(magic));
  inc(result, FServiceTypeList.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
  inc(result, FActorList.sizeInBytes(magic));
end;

function TFhirSchedule.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSchedule.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSchedule.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirSchedule.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirSchedule.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.Create;
  FActive.value := value
end;

function TFhirSchedule.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

function TFhirSchedule.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

function TFhirSchedule.GetServiceTypeList : TFhirCodeableConceptList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableConceptList.Create;
  result := FServiceTypeList;
end;

function TFhirSchedule.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

function TFhirSchedule.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirSchedule.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

function TFhirSchedule.GetActorList : TFhirReferenceList;
begin
  if FActorList = nil then
    FActorList := TFhirReferenceList.Create;
  result := FActorList;
end;

function TFhirSchedule.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

procedure TFhirSchedule.SetPlanningHorizon(value : TFhirPeriod);
begin
  FPlanningHorizon.free;
  FPlanningHorizon := value;
end;

procedure TFhirSchedule.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirSchedule.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirSchedule.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.Create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirScheduleListEnumerator }

constructor TFhirScheduleListEnumerator.Create(list : TFhirScheduleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirScheduleListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirScheduleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirScheduleListEnumerator.GetCurrent : TFhirSchedule;
begin
  Result := FList[FIndex];
end;

function TFhirScheduleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirScheduleList }

function TFhirScheduleList.AddItem(value: TFhirSchedule): TFhirSchedule;
begin
  assert(value.ClassName = 'TFhirSchedule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSchedule');
  add(value);
  result := value;
end;

function TFhirScheduleList.Append: TFhirSchedule;
begin
  result := TFhirSchedule.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirScheduleList.ClearItems;
begin
  Clear;
end;

function TFhirScheduleList.GetEnumerator : TFhirScheduleListEnumerator;
begin
  result := TFhirScheduleListEnumerator.Create(self.link);
end;

function TFhirScheduleList.Clone: TFhirScheduleList;
begin
  result := TFhirScheduleList(inherited Clone);
end;

function TFhirScheduleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirScheduleList.GetItemN(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule(ObjectByIndex[index]);
end;

function TFhirScheduleList.ItemClass: TFslObjectClass;
begin
  result := TFhirSchedule;
end;
function TFhirScheduleList.IndexOf(value: TFhirSchedule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirScheduleList.Insert(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirScheduleList.InsertItem(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  Inherited Insert(index, value);
end;

function TFhirScheduleList.Item(index: Integer): TFhirSchedule;
begin
  result := TFhirSchedule(ObjectByIndex[index]);
end;

function TFhirScheduleList.Link: TFhirScheduleList;
begin
  result := TFhirScheduleList(inherited Link);
end;

procedure TFhirScheduleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirScheduleList.SetItemByIndex(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  FhirSchedules[index] := value;
end;

procedure TFhirScheduleList.SetItemN(index: Integer; value: TFhirSchedule);
begin
  assert(value is TFhirSchedule);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SCHEDULE}
{$IFDEF FHIR_SLOT}
{ TFhirSlot }

constructor TFhirSlot.Create;
begin
  inherited;
end;

destructor TFhirSlot.Destroy;
begin
  FIdentifierList.free;
  FServiceCategoryList.free;
  FServiceTypeList.free;
  FSpecialtyList.free;
  FAppointmentType.free;
  FSchedule.free;
  FStatus.free;
  FStart.free;
  FEnd_.free;
  FOverbooked.free;
  FComment.free;
  inherited;
end;

procedure TFhirSlot.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirSlot(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSlot(oSource).FIdentifierList);
  end;
  if (TFhirSlot(oSource).FServiceCategoryList = nil) then
  begin
    FServiceCategoryList.free;
    FServiceCategoryList := nil;
  end
  else
  begin
    if FServiceCategoryList = nil then
      FServiceCategoryList := TFhirCodeableConceptList.Create;
    FServiceCategoryList.Assign(TFhirSlot(oSource).FServiceCategoryList);
  end;
  if (TFhirSlot(oSource).FServiceTypeList = nil) then
  begin
    FServiceTypeList.free;
    FServiceTypeList := nil;
  end
  else
  begin
    if FServiceTypeList = nil then
      FServiceTypeList := TFhirCodeableConceptList.Create;
    FServiceTypeList.Assign(TFhirSlot(oSource).FServiceTypeList);
  end;
  if (TFhirSlot(oSource).FSpecialtyList = nil) then
  begin
    FSpecialtyList.free;
    FSpecialtyList := nil;
  end
  else
  begin
    if FSpecialtyList = nil then
      FSpecialtyList := TFhirCodeableConceptList.Create;
    FSpecialtyList.Assign(TFhirSlot(oSource).FSpecialtyList);
  end;
  appointmentType := TFhirSlot(oSource).appointmentType.Clone;
  schedule := TFhirSlot(oSource).schedule.Clone;
  statusElement := TFhirSlot(oSource).statusElement.Clone;
  startElement := TFhirSlot(oSource).startElement.Clone;
  end_Element := TFhirSlot(oSource).end_Element.Clone;
  overbookedElement := TFhirSlot(oSource).overbookedElement.Clone;
  commentElement := TFhirSlot(oSource).commentElement.Clone;
end;

function TFhirSlot.GetResourceType : TFhirResourceType;
begin
  result := frtSlot;
end;

procedure TFhirSlot.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'serviceCategory') Then
    list.addAll(self, 'serviceCategory', FServiceCategoryList);
  if (child_name = 'serviceType') Then
    list.addAll(self, 'serviceType', FServiceTypeList);
  if (child_name = 'specialty') Then
    list.addAll(self, 'specialty', FSpecialtyList);
  if (child_name = 'appointmentType') Then
     list.add(self.link, 'appointmentType', FAppointmentType.Link);
  if (child_name = 'schedule') Then
     list.add(self.link, 'schedule', FSchedule.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'overbooked') Then
     list.add(self.link, 'overbooked', FOverbooked.Link);
  if (child_name = 'comment') Then
     list.add(self.link, 'comment', FComment.Link);
end;

procedure TFhirSlot.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.Create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.Create(self, 'serviceCategory', 'CodeableConcept', true, TFhirCodeableConcept, FServiceCategoryList.Link));
  oList.add(TFHIRProperty.Create(self, 'serviceType', 'CodeableConcept', true, TFhirCodeableConcept, FServiceTypeList.Link));
  oList.add(TFHIRProperty.Create(self, 'specialty', 'CodeableConcept', true, TFhirCodeableConcept, FSpecialtyList.Link));
  oList.add(TFHIRProperty.Create(self, 'appointmentType', 'CodeableConcept', false, TFhirCodeableConcept, FAppointmentType.Link));
  oList.add(TFHIRProperty.Create(self, 'schedule', 'Reference', false, TFhirReference, FSchedule.Link));
  oList.add(TFHIRProperty.Create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.Create(self, 'start', 'instant', false, TFhirInstant, FStart.Link));
  oList.add(TFHIRProperty.Create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));
  oList.add(TFHIRProperty.Create(self, 'overbooked', 'boolean', false, TFhirBoolean, FOverbooked.Link));
  oList.add(TFHIRProperty.Create(self, 'comment', 'string', false, TFhirString, FComment.Link));
end;

function TFhirSlot.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'serviceCategory') then
  begin
    ServiceCategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'serviceType') then
  begin
    ServiceTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specialty') then
  begin
    SpecialtyList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'appointmentType') then
  begin
    AppointmentType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'schedule') then
  begin
    Schedule := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSlotStatusEnum, CODES_TFhirSlotStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    StartElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'overbooked') then
  begin
    OverbookedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSlot.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'serviceCategory') then ServiceCategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'serviceType') then ServiceTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specialty') then SpecialtyList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirSlot.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'serviceCategory') then result := ServiceCategoryList.new()
  else if (propName = 'serviceType') then result := ServiceTypeList.new()
  else if (propName = 'specialty') then result := SpecialtyList.new()
  else if (propName = 'appointmentType') then result := TFhirCodeableConcept.Create()
  else if (propName = 'schedule') then result := TFhirReference.Create()
  else if (propName = 'status') then result := TFhirEnum.Create(SYSTEMS_TFhirSlotStatusEnum[SlotStatusNull], CODES_TFhirSlotStatusEnum[SlotStatusNull]) 
  else if (propName = 'start') then result := TFhirInstant.Create()
  else if (propName = 'end') then result := TFhirInstant.Create()
  else if (propName = 'overbooked') then result := TFhirBoolean.Create()
  else if (propName = 'comment') then result := TFhirString.Create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSlot.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'serviceCategory') then result := 'CodeableConcept'
  else if (propName = 'serviceType') then result := 'CodeableConcept'
  else if (propName = 'specialty') then result := 'CodeableConcept'
  else if (propName = 'appointmentType') then result := 'CodeableConcept'
  else if (propName = 'schedule') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'start') then result := 'instant'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'overbooked') then result := 'boolean'
  else if (propName = 'comment') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSlot.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'serviceCategory') then deletePropertyValue('serviceCategory', ServiceCategoryList, value)
  else if (propName = 'serviceType') then deletePropertyValue('serviceType', ServiceTypeList, value)
  else if (propName = 'specialty') then deletePropertyValue('specialty', SpecialtyList, value)
  else if (propName = 'appointmentType') then AppointmentTypeElement := nil
  else if (propName = 'schedule') then ScheduleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'overbooked') then OverbookedElement := nil
  else if (propName = 'comment') then CommentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSlot.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'serviceCategory') then replacePropertyValue('serviceCategory', ServiceCategoryList, existing, new)
  else if (propName = 'serviceType') then replacePropertyValue('serviceType', ServiceTypeList, existing, new)
  else if (propName = 'specialty') then replacePropertyValue('specialty', SpecialtyList, existing, new)
  else if (propName = 'appointmentType') then AppointmentTypeElement := new as TFhirCodeableConcept
  else if (propName = 'schedule') then ScheduleElement := new as TFhirReference
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSlotStatusEnum, CODES_TFhirSlotStatusEnum, new)
  else if (propName = 'start') then StartElement := asInstant(new)
  else if (propName = 'end') then End_Element := asInstant(new)
  else if (propName = 'overbooked') then OverbookedElement := asBoolean(new)
  else if (propName = 'comment') then CommentElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSlot.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'serviceCategory') then ServiceCategoryList.move(source, destination)
  else if (propName = 'serviceType') then ServiceTypeList.move(source, destination)
  else if (propName = 'specialty') then SpecialtyList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSlot.fhirType : string;
begin
  result := 'Slot';
end;

function TFhirSlot.Link : TFhirSlot;
begin
  result := TFhirSlot(inherited Link);
end;

function TFhirSlot.Clone : TFhirSlot;
begin
  result := TFhirSlot(inherited Clone);
end;

function TFhirSlot.equals(other : TObject) : boolean; 
var
  o : TFhirSlot;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSlot)) then
    result := false
  else
  begin
    o := TFhirSlot(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(serviceCategoryList, o.serviceCategoryList, true) and 
      compareDeep(serviceTypeList, o.serviceTypeList, true) and compareDeep(specialtyList, o.specialtyList, true) and 
      compareDeep(appointmentTypeElement, o.appointmentTypeElement, true) and compareDeep(scheduleElement, o.scheduleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(startElement, o.startElement, true) and 
      compareDeep(end_Element, o.end_Element, true) and compareDeep(overbookedElement, o.overbookedElement, true) and 
      compareDeep(commentElement, o.commentElement, true);
  end;
end;

function TFhirSlot.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FserviceCategoryList) and isEmptyProp(FserviceTypeList) and isEmptyProp(FspecialtyList) and isEmptyProp(FAppointmentType) and isEmptyProp(FSchedule) and isEmptyProp(FStatus) and isEmptyProp(FStart) and isEmptyProp(FEnd_) and isEmptyProp(FOverbooked) and isEmptyProp(FComment);
end;

procedure TFhirSlot.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('serviceCategory');
  fields.add('serviceType');
  fields.add('specialty');
  fields.add('appointmentType');
  fields.add('schedule');
  fields.add('status');
  fields.add('start');
  fields.add('end');
  fields.add('overbooked');
  fields.add('comment');
end;

function TFhirSlot.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FServiceCategoryList.sizeInBytes(magic));
  inc(result, FServiceTypeList.sizeInBytes(magic));
  inc(result, FSpecialtyList.sizeInBytes(magic));
end;

function TFhirSlot.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSlot.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirSlot.GetServiceCategoryList : TFhirCodeableConceptList;
begin
  if FServiceCategoryList = nil then
    FServiceCategoryList := TFhirCodeableConceptList.Create;
  result := FServiceCategoryList;
end;

function TFhirSlot.GetHasServiceCategoryList : boolean;
begin
  result := (FServiceCategoryList <> nil) and (FServiceCategoryList.count > 0);
end;

function TFhirSlot.GetServiceTypeList : TFhirCodeableConceptList;
begin
  if FServiceTypeList = nil then
    FServiceTypeList := TFhirCodeableConceptList.Create;
  result := FServiceTypeList;
end;

function TFhirSlot.GetHasServiceTypeList : boolean;
begin
  result := (FServiceTypeList <> nil) and (FServiceTypeList.count > 0);
end;

function TFhirSlot.GetSpecialtyList : TFhirCodeableConceptList;
begin
  if FSpecialtyList = nil then
    FSpecialtyList := TFhirCodeableConceptList.Create;
  result := FSpecialtyList;
end;

function TFhirSlot.GetHasSpecialtyList : boolean;
begin
  result := (FSpecialtyList <> nil) and (FSpecialtyList.count > 0);
end;

procedure TFhirSlot.SetAppointmentType(value : TFhirCodeableConcept);
begin
  FAppointmentType.free;
  FAppointmentType := value;
end;

procedure TFhirSlot.SetSchedule(value : TFhirReference);
begin
  FSchedule.free;
  FSchedule := value;
end;

procedure TFhirSlot.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSlot.GetStatusST : TFhirSlotStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSlotStatusEnum(0)
  else
    result := TFhirSlotStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSlotStatusEnum, FStatus.value));
end;

procedure TFhirSlot.SetStatusST(value : TFhirSlotStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.Create(SYSTEMS_TFhirSlotStatusEnum[value], CODES_TFhirSlotStatusEnum[value]);
end;

procedure TFhirSlot.SetStart(value : TFhirInstant);
begin
  FStart.free;
  FStart := value;
end;

function TFhirSlot.GetStartST : TFslDateTime;
begin
  if FStart = nil then
    result := TFslDateTime.makeNull
  else
    result := FStart.value;
end;

procedure TFhirSlot.SetStartST(value : TFslDateTime);
begin
  if FStart = nil then
    FStart := TFhirInstant.Create;
  FStart.value := value
end;

procedure TFhirSlot.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirSlot.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

procedure TFhirSlot.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.Create;
  FEnd_.value := value
end;

procedure TFhirSlot.SetOverbooked(value : TFhirBoolean);
begin
  FOverbooked.free;
  FOverbooked := value;
end;

function TFhirSlot.GetOverbookedST : Boolean;
begin
  if FOverbooked = nil then
    result := false
  else
    result := FOverbooked.value;
end;

procedure TFhirSlot.SetOverbookedST(value : Boolean);
begin
  if FOverbooked = nil then
    FOverbooked := TFhirBoolean.Create;
  FOverbooked.value := value
end;

procedure TFhirSlot.SetComment(value : TFhirString);
begin
  FComment.free;
  FComment := value;
end;

function TFhirSlot.GetCommentST : String;
begin
  if FComment = nil then
    result := ''
  else
    result := FComment.value;
end;

procedure TFhirSlot.SetCommentST(value : String);
begin
  if value <> '' then
  begin
    if FComment = nil then
      FComment := TFhirString.Create;
    FComment.value := value
  end
  else if FComment <> nil then
    FComment.value := '';
end;

{ TFhirSlotListEnumerator }

constructor TFhirSlotListEnumerator.Create(list : TFhirSlotList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSlotListEnumerator.Destroy;
begin
  FList.free;
  inherited;
end;

function TFhirSlotListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSlotListEnumerator.GetCurrent : TFhirSlot;
begin
  Result := FList[FIndex];
end;

function TFhirSlotListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSlotList }

function TFhirSlotList.AddItem(value: TFhirSlot): TFhirSlot;
begin
  assert(value.ClassName = 'TFhirSlot', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSlot');
  add(value);
  result := value;
end;

function TFhirSlotList.Append: TFhirSlot;
begin
  result := TFhirSlot.Create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSlotList.ClearItems;
begin
  Clear;
end;

function TFhirSlotList.GetEnumerator : TFhirSlotListEnumerator;
begin
  result := TFhirSlotListEnumerator.Create(self.link);
end;

function TFhirSlotList.Clone: TFhirSlotList;
begin
  result := TFhirSlotList(inherited Clone);
end;

function TFhirSlotList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSlotList.GetItemN(index: Integer): TFhirSlot;
begin
  result := TFhirSlot(ObjectByIndex[index]);
end;

function TFhirSlotList.ItemClass: TFslObjectClass;
begin
  result := TFhirSlot;
end;
function TFhirSlotList.IndexOf(value: TFhirSlot): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSlotList.Insert(index: Integer): TFhirSlot;
begin
  result := TFhirSlot.Create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSlotList.InsertItem(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  Inherited Insert(index, value);
end;

function TFhirSlotList.Item(index: Integer): TFhirSlot;
begin
  result := TFhirSlot(ObjectByIndex[index]);
end;

function TFhirSlotList.Link: TFhirSlotList;
begin
  result := TFhirSlotList(inherited Link);
end;

procedure TFhirSlotList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSlotList.SetItemByIndex(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  FhirSlots[index] := value;
end;

procedure TFhirSlotList.SetItemN(index: Integer; value: TFhirSlot);
begin
  assert(value is TFhirSlot);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SLOT}


end.

