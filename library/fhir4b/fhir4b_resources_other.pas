unit fhir4b_resources_other;

{
  Copyright (c) 2011+, HL7 and Health Intersections Pty Ltd (http://www.healthintersections.com.au)
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification, 
  are permitted provided that the following conditions are met:
  
   * Redistributions of source code must retain the above copyright notice, this 
     list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above copyright notice, 
     this list of conditions and the following disclaimer in the documentation 
     and/or other materials provided with the distribution.
   * Neither the name of HL7 nor the names of its contributors may be used to 
     endorse or promote products derived from this software without specific 
     prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
  POSSIBILITY OF SUCH DAMAGE.
  
}

{$I fhir.inc}
{$I fhir4b.inc}

interface

// Generated on Mon, Dec 27, 2021 21:46+1100 for FHIR v4.3.0



uses
  SysUtils, Classes, 
  fsl_base, fsl_utilities, fsl_stream, 
  fhir_objects, fhir_utilities,  
  fhir4b_base, fhir4b_enums, fhir4b_types, fhir4b_resources_base, fhir4b_resources_canonical;



type
{$IFDEF FHIR_ACTIVITYDEFINITION}
  TFhirActivityDefinitionParticipant = class;
  TFhirActivityDefinitionParticipantList = class;
  TFhirActivityDefinitionDynamicValue = class;
  TFhirActivityDefinitionDynamicValueList = class;
  TFhirActivityDefinition = class;
  TFhirActivityDefinitionList = class;
{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_AUDITEVENT}
  TFhirAuditEventAgent = class;
  TFhirAuditEventAgentList = class;
  TFhirAuditEventAgentNetwork = class;
  TFhirAuditEventAgentNetworkList = class;
  TFhirAuditEventSource = class;
  TFhirAuditEventSourceList = class;
  TFhirAuditEventEntity = class;
  TFhirAuditEventEntityList = class;
  TFhirAuditEventEntityDetail = class;
  TFhirAuditEventEntityDetailList = class;
  TFhirAuditEvent = class;
  TFhirAuditEventList = class;
{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BINARY}
  TFhirBinary = class;
  TFhirBinaryList = class;
{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BUNDLE}
  TFhirBundleLink = class;
  TFhirBundleLinkList = class;
  TFhirBundleEntry = class;
  TFhirBundleEntryList = class;
  TFhirBundleEntrySearch = class;
  TFhirBundleEntrySearchList = class;
  TFhirBundleEntryRequest = class;
  TFhirBundleEntryRequestList = class;
  TFhirBundleEntryResponse = class;
  TFhirBundleEntryResponseList = class;
  TFhirBundle = class;
  TFhirBundleList = class;
{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CONSENT}
  TFhirConsentPolicy = class;
  TFhirConsentPolicyList = class;
  TFhirConsentVerification = class;
  TFhirConsentVerificationList = class;
  TFhirConsentProvision = class;
  TFhirConsentProvisionList = class;
  TFhirConsentProvisionActor = class;
  TFhirConsentProvisionActorList = class;
  TFhirConsentProvisionData = class;
  TFhirConsentProvisionDataList = class;
  TFhirConsent = class;
  TFhirConsentList = class;
{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  TFhirContractContentDefinition = class;
  TFhirContractContentDefinitionList = class;
  TFhirContractTerm = class;
  TFhirContractTermList = class;
  TFhirContractTermSecurityLabel = class;
  TFhirContractTermSecurityLabelList = class;
  TFhirContractTermOffer = class;
  TFhirContractTermOfferList = class;
  TFhirContractTermOfferParty = class;
  TFhirContractTermOfferPartyList = class;
  TFhirContractTermOfferAnswer = class;
  TFhirContractTermOfferAnswerList = class;
  TFhirContractTermAsset = class;
  TFhirContractTermAssetList = class;
  TFhirContractTermAssetContext = class;
  TFhirContractTermAssetContextList = class;
  TFhirContractTermAssetValuedItem = class;
  TFhirContractTermAssetValuedItemList = class;
  TFhirContractTermAction = class;
  TFhirContractTermActionList = class;
  TFhirContractTermActionSubject = class;
  TFhirContractTermActionSubjectList = class;
  TFhirContractSigner = class;
  TFhirContractSignerList = class;
  TFhirContractFriendly = class;
  TFhirContractFriendlyList = class;
  TFhirContractLegal = class;
  TFhirContractLegalList = class;
  TFhirContractRule = class;
  TFhirContractRuleList = class;
  TFhirContract = class;
  TFhirContractList = class;
{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_EVIDENCE}
  TFhirEvidenceVariableDefinition = class;
  TFhirEvidenceVariableDefinitionList = class;
  TFhirEvidenceStatistic = class;
  TFhirEvidenceStatisticList = class;
  TFhirEvidenceStatisticSampleSize = class;
  TFhirEvidenceStatisticSampleSizeList = class;
  TFhirEvidenceStatisticAttributeEstimate = class;
  TFhirEvidenceStatisticAttributeEstimateList = class;
  TFhirEvidenceStatisticModelCharacteristic = class;
  TFhirEvidenceStatisticModelCharacteristicList = class;
  TFhirEvidenceStatisticModelCharacteristicVariable = class;
  TFhirEvidenceStatisticModelCharacteristicVariableList = class;
  TFhirEvidenceCertainty = class;
  TFhirEvidenceCertaintyList = class;
  TFhirEvidence = class;
  TFhirEvidenceList = class;
{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
  TFhirEvidenceReportSubject = class;
  TFhirEvidenceReportSubjectList = class;
  TFhirEvidenceReportSubjectCharacteristic = class;
  TFhirEvidenceReportSubjectCharacteristicList = class;
  TFhirEvidenceReportRelatesTo = class;
  TFhirEvidenceReportRelatesToList = class;
  TFhirEvidenceReportSection = class;
  TFhirEvidenceReportSectionList = class;
  TFhirEvidenceReport = class;
  TFhirEvidenceReportList = class;
{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  TFhirEvidenceVariableCharacteristic = class;
  TFhirEvidenceVariableCharacteristicList = class;
  TFhirEvidenceVariableCharacteristicTimeFromStart = class;
  TFhirEvidenceVariableCharacteristicTimeFromStartList = class;
  TFhirEvidenceVariableCategory = class;
  TFhirEvidenceVariableCategoryList = class;
  TFhirEvidenceVariable = class;
  TFhirEvidenceVariableList = class;
{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_GUIDANCERESPONSE}
  TFhirGuidanceResponse = class;
  TFhirGuidanceResponseList = class;
{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_LINKAGE}
  TFhirLinkageItem = class;
  TFhirLinkageItemList = class;
  TFhirLinkage = class;
  TFhirLinkageList = class;
{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  TFhirListEntry = class;
  TFhirListEntryList = class;
  TFhirList = class;
  TFhirListList = class;
{$ENDIF FHIR_LIST}
{$IFDEF FHIR_MEASUREREPORT}
  TFhirMeasureReportGroup = class;
  TFhirMeasureReportGroupList = class;
  TFhirMeasureReportGroupPopulation = class;
  TFhirMeasureReportGroupPopulationList = class;
  TFhirMeasureReportGroupStratifier = class;
  TFhirMeasureReportGroupStratifierList = class;
  TFhirMeasureReportGroupStratifierStratum = class;
  TFhirMeasureReportGroupStratifierStratumList = class;
  TFhirMeasureReportGroupStratifierStratumComponent = class;
  TFhirMeasureReportGroupStratifierStratumComponentList = class;
  TFhirMeasureReportGroupStratifierStratumPopulation = class;
  TFhirMeasureReportGroupStratifierStratumPopulationList = class;
  TFhirMeasureReport = class;
  TFhirMeasureReportList = class;
{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MESSAGEHEADER}
  TFhirMessageHeaderDestination = class;
  TFhirMessageHeaderDestinationList = class;
  TFhirMessageHeaderSource = class;
  TFhirMessageHeaderSourceList = class;
  TFhirMessageHeaderResponse = class;
  TFhirMessageHeaderResponseList = class;
  TFhirMessageHeader = class;
  TFhirMessageHeaderList = class;
{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_OPERATIONOUTCOME}
  TFhirOperationOutcomeIssue = class;
  TFhirOperationOutcomeIssueList = class;
  TFhirOperationOutcome = class;
  TFhirOperationOutcomeList = class;
{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_PARAMETERS}
  TFhirParametersParameter = class;
  TFhirParametersParameterList = class;
  TFhirParameters = class;
  TFhirParametersList = class;
{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PLANDEFINITION}
  TFhirPlanDefinitionGoal = class;
  TFhirPlanDefinitionGoalList = class;
  TFhirPlanDefinitionGoalTarget = class;
  TFhirPlanDefinitionGoalTargetList = class;
  TFhirPlanDefinitionAction = class;
  TFhirPlanDefinitionActionList = class;
  TFhirPlanDefinitionActionCondition = class;
  TFhirPlanDefinitionActionConditionList = class;
  TFhirPlanDefinitionActionRelatedAction = class;
  TFhirPlanDefinitionActionRelatedActionList = class;
  TFhirPlanDefinitionActionParticipant = class;
  TFhirPlanDefinitionActionParticipantList = class;
  TFhirPlanDefinitionActionDynamicValue = class;
  TFhirPlanDefinitionActionDynamicValueList = class;
  TFhirPlanDefinition = class;
  TFhirPlanDefinitionList = class;
{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PROVENANCE}
  TFhirProvenanceAgent = class;
  TFhirProvenanceAgentList = class;
  TFhirProvenanceEntity = class;
  TFhirProvenanceEntityList = class;
  TFhirProvenance = class;
  TFhirProvenanceList = class;
{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  TFhirQuestionnaireResponseItem = class;
  TFhirQuestionnaireResponseItemList = class;
  TFhirQuestionnaireResponseItemAnswer = class;
  TFhirQuestionnaireResponseItemAnswerList = class;
  TFhirQuestionnaireResponse = class;
  TFhirQuestionnaireResponseList = class;
{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REQUESTGROUP}
  TFhirRequestGroupAction = class;
  TFhirRequestGroupActionList = class;
  TFhirRequestGroupActionCondition = class;
  TFhirRequestGroupActionConditionList = class;
  TFhirRequestGroupActionRelatedAction = class;
  TFhirRequestGroupActionRelatedActionList = class;
  TFhirRequestGroup = class;
  TFhirRequestGroupList = class;
{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  TFhirResearchDefinition = class;
  TFhirResearchDefinitionList = class;
{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  TFhirResearchElementDefinitionCharacteristic = class;
  TFhirResearchElementDefinitionCharacteristicList = class;
  TFhirResearchElementDefinition = class;
  TFhirResearchElementDefinitionList = class;
{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  TFhirResearchStudyArm = class;
  TFhirResearchStudyArmList = class;
  TFhirResearchStudyObjective = class;
  TFhirResearchStudyObjectiveList = class;
  TFhirResearchStudy = class;
  TFhirResearchStudyList = class;
{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  TFhirResearchSubject = class;
  TFhirResearchSubjectList = class;
{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_SUBSCRIPTION}
  TFhirSubscriptionChannel = class;
  TFhirSubscriptionChannelList = class;
  TFhirSubscription = class;
  TFhirSubscriptionList = class;
{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
  TFhirSubscriptionStatusNotificationEvent = class;
  TFhirSubscriptionStatusNotificationEventList = class;
  TFhirSubscriptionStatus = class;
  TFhirSubscriptionStatusList = class;
{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
  TFhirSubscriptionTopicResourceTrigger = class;
  TFhirSubscriptionTopicResourceTriggerList = class;
  TFhirSubscriptionTopicResourceTriggerQueryCriteria = class;
  TFhirSubscriptionTopicResourceTriggerQueryCriteriaList = class;
  TFhirSubscriptionTopicEventTrigger = class;
  TFhirSubscriptionTopicEventTriggerList = class;
  TFhirSubscriptionTopicCanFilterBy = class;
  TFhirSubscriptionTopicCanFilterByList = class;
  TFhirSubscriptionTopicNotificationShape = class;
  TFhirSubscriptionTopicNotificationShapeList = class;
  TFhirSubscriptionTopic = class;
  TFhirSubscriptionTopicList = class;
{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_TASK}
  TFhirTaskRestriction = class;
  TFhirTaskRestrictionList = class;
  TFhirTaskInput = class;
  TFhirTaskInputList = class;
  TFhirTaskOutput = class;
  TFhirTaskOutputList = class;
  TFhirTask = class;
  TFhirTaskList = class;
{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  TFhirTestReportParticipant = class;
  TFhirTestReportParticipantList = class;
  TFhirTestReportSetup = class;
  TFhirTestReportSetupList = class;
  TFhirTestReportSetupAction = class;
  TFhirTestReportSetupActionList = class;
  TFhirTestReportSetupActionOperation = class;
  TFhirTestReportSetupActionOperationList = class;
  TFhirTestReportSetupActionAssert = class;
  TFhirTestReportSetupActionAssertList = class;
  TFhirTestReportTest = class;
  TFhirTestReportTestList = class;
  TFhirTestReportTestAction = class;
  TFhirTestReportTestActionList = class;
  TFhirTestReportTeardown = class;
  TFhirTestReportTeardownList = class;
  TFhirTestReportTeardownAction = class;
  TFhirTestReportTeardownActionList = class;
  TFhirTestReport = class;
  TFhirTestReportList = class;
{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_VERIFICATIONRESULT}
  TFhirVerificationResultPrimarySource = class;
  TFhirVerificationResultPrimarySourceList = class;
  TFhirVerificationResultAttestation = class;
  TFhirVerificationResultAttestationList = class;
  TFhirVerificationResultValidator = class;
  TFhirVerificationResultValidatorList = class;
  TFhirVerificationResult = class;
  TFhirVerificationResultList = class;
{$ENDIF FHIR_VERIFICATIONRESULT}




{$IFDEF FHIR_ACTIVITYDEFINITION}
  // Indicates who should participate in performing the action described.
  TFhirActivityDefinitionParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FRole : TFhirCodeableConcept;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirActionParticipantTypeEnum;
    procedure SetType_ST(value : TFhirActionParticipantTypeEnum);
    procedure SetRole(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirActivityDefinitionParticipant; overload;
    function Clone : TFhirActivityDefinitionParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of participant in the action.
    property type_ : TFhirActionParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The role the participant should play in performing the described action. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role the participant should play in performing the described action.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirActivityDefinitionParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirActivityDefinitionParticipantList;
    function GetCurrent : TFhirActivityDefinitionParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirActivityDefinitionParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirActivityDefinitionParticipant read GetCurrent;
  end;

  TFhirActivityDefinitionParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirActivityDefinitionParticipant;
    procedure SetItemN(index : Integer; value : TFhirActivityDefinitionParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirActivityDefinitionParticipantList; overload;
    function Clone : TFhirActivityDefinitionParticipantList; overload;
    function GetEnumerator : TFhirActivityDefinitionParticipantListEnumerator;
    
    //  Add a FhirActivityDefinitionParticipant to the end of the list.
    function Append : TFhirActivityDefinitionParticipant;
    
    // Add an already existing FhirActivityDefinitionParticipant to the end of the list.
    function AddItem(value : TFhirActivityDefinitionParticipant) : TFhirActivityDefinitionParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirActivityDefinitionParticipant) : Integer;
    
    // Insert FhirActivityDefinitionParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirActivityDefinitionParticipant;
    
    // Insert an existing FhirActivityDefinitionParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirActivityDefinitionParticipant);
    
    // Get the iIndexth FhirActivityDefinitionParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirActivityDefinitionParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirActivityDefinitionParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirActivityDefinitionParticipants[index : Integer] : TFhirActivityDefinitionParticipant read GetItemN write SetItemN; default;
  End;

  // Dynamic values that will be evaluated to produce values for elements of the resulting resource. For example, if the dosage of a medication must be computed based on the patient's weight, a dynamic value would be used to specify an expression that calculated the weight, and the path on the request resource that would contain the result.
  TFhirActivityDefinitionDynamicValue = class (TFhirBackboneElement)
  protected
    FPath : TFhirString;
    FExpression : TFhirExpression;
    procedure SetPath(value : TFhirString);
    function GetPathST : String;
    procedure SetPathST(value : String);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirActivityDefinitionDynamicValue; overload;
    function Clone : TFhirActivityDefinitionDynamicValue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property path : String read GetPathST write SetPathST;
    // The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to An expression specifying the value of the customized element. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression specifying the value of the customized element.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirActivityDefinitionDynamicValueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirActivityDefinitionDynamicValueList;
    function GetCurrent : TFhirActivityDefinitionDynamicValue;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirActivityDefinitionDynamicValueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirActivityDefinitionDynamicValue read GetCurrent;
  end;

  TFhirActivityDefinitionDynamicValueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirActivityDefinitionDynamicValue;
    procedure SetItemN(index : Integer; value : TFhirActivityDefinitionDynamicValue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirActivityDefinitionDynamicValueList; overload;
    function Clone : TFhirActivityDefinitionDynamicValueList; overload;
    function GetEnumerator : TFhirActivityDefinitionDynamicValueListEnumerator;
    
    //  Add a FhirActivityDefinitionDynamicValue to the end of the list.
    function Append : TFhirActivityDefinitionDynamicValue;
    
    // Add an already existing FhirActivityDefinitionDynamicValue to the end of the list.
    function AddItem(value : TFhirActivityDefinitionDynamicValue) : TFhirActivityDefinitionDynamicValue; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirActivityDefinitionDynamicValue) : Integer;
    
    // Insert FhirActivityDefinitionDynamicValue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirActivityDefinitionDynamicValue;
    
    // Insert an existing FhirActivityDefinitionDynamicValue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirActivityDefinitionDynamicValue);
    
    // Get the iIndexth FhirActivityDefinitionDynamicValue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirActivityDefinitionDynamicValue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirActivityDefinitionDynamicValue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirActivityDefinitionDynamicValues[index : Integer] : TFhirActivityDefinitionDynamicValue read GetItemN write SetItemN; default;
  End;

  // This resource allows for the definition of some activity to be performed, independent of a particular patient, practitioner, or other performance context.
  TFhirActivityDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FSubtitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FSubject : TFhirDataType;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirCanonicalList;
    FKind : TFhirEnum;
    FProfile : TFhirCanonical;
    FCode : TFhirCodeableConcept;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FDoNotPerform : TFhirBoolean;
    FTiming : TFhirDataType;
    FLocation : TFhirReference;
    FparticipantList : TFhirActivityDefinitionParticipantList;
    FProduct : TFhirDataType;
    FQuantity : TFhirQuantity;
    FdosageList : TFhirDosageList;
    FbodySiteList : TFhirCodeableConceptList;
    FspecimenRequirementList : TFhirReferenceList;
    FobservationRequirementList : TFhirReferenceList;
    FobservationResultRequirementList : TFhirReferenceList;
    FTransform : TFhirCanonical;
    FdynamicValueList : TFhirActivityDefinitionDynamicValueList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetSubject(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirCanonicalList;
    function GetHasLibrary_List : Boolean;
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirRequestResourceTypeEnum;
    procedure SetKindST(value : TFhirRequestResourceTypeEnum);
    procedure SetProfile(value : TFhirCanonical);
    function GetProfileST : String;
    procedure SetProfileST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetTiming(value : TFhirDataType);
    procedure SetLocation(value : TFhirReference);
    function GetParticipantList : TFhirActivityDefinitionParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetProduct(value : TFhirDataType);
    procedure SetQuantity(value : TFhirQuantity);
    function GetDosageList : TFhirDosageList;
    function GetHasDosageList : Boolean;
    function GetBodySiteList : TFhirCodeableConceptList;
    function GetHasBodySiteList : Boolean;
    function GetSpecimenRequirementList : TFhirReferenceList;
    function GetHasSpecimenRequirementList : Boolean;
    function GetObservationRequirementList : TFhirReferenceList;
    function GetHasObservationRequirementList : Boolean;
    function GetObservationResultRequirementList : TFhirReferenceList;
    function GetHasObservationResultRequirementList : Boolean;
    procedure SetTransform(value : TFhirCanonical);
    function GetTransformST : String;
    procedure SetTransformST(value : String);
    function GetDynamicValueList : TFhirActivityDefinitionDynamicValueList;
    function GetHasDynamicValueList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirActivityDefinition; overload;
    function Clone : TFhirActivityDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this activity definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this activity definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the activity definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this activity definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this activity definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the activity definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this activity definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the activity definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the activity definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the activity definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the activity definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active assets.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the activity definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the activity definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the activity definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the activity definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate title for the activity definition giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the activity definition giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this activity definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this activity definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this activity definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to A code, group definition, or canonical reference that describes  or identifies the intended subject of the activity being defined.  Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // A code, group definition, or canonical reference that describes  or identifies the intended subject of the activity being defined.  Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the activity definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the activity definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the activity definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the activity definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the activity definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the activity definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the activity definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the activity definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate activity definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the activity definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this activity definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this activity definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the activity definition is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the activity definition is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the activity definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the activity definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the activity definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the activity definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the activity definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the activity definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the activity. Topics provide a high-level categorization of the activity that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing any formal logic used by the activity definition.
    property library_List : TFhirCanonicalList read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // A description of the kind of resource the activity definition is representing. For example, a MedicationRequest, a ServiceRequest, or a CommunicationRequest. Typically, but not always, this is a Request resource.
    property kind : TFhirRequestResourceTypeEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to A profile to which the target of the activity definition is expected to conform.
    property profile : String read GetProfileST write SetProfileST;
    // A profile to which the target of the activity definition is expected to conform.
    property profileElement : TFhirCanonical read FProfile write SetProfile;

    // Typed access to Detailed description of the type of activity; e.g. What lab test, what procedure, what kind of encounter. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Detailed description of the type of activity; e.g. What lab test, what procedure, what kind of encounter.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Indicates the level of authority/intentionality associated with the activity and where the request should fit into the workflow chain.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the activity  should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to Set this to true if the definition is to indicate that a particular activity should NOT be performed. If true, this element should be interpreted to reinforce a negative coding. For example NPO as a code with a doNotPerform of true would still indicate to NOT perform the action.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // Set this to true if the definition is to indicate that a particular activity should NOT be performed. If true, this element should be interpreted to reinforce a negative coding. For example NPO as a code with a doNotPerform of true would still indicate to NOT perform the action.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to The period, timing or frequency upon which the described activity is to occur. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // The period, timing or frequency upon which the described activity is to occur.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Typed access to Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Identifies the facility where the activity will occur; e.g. home, hospital, specific clinic, etc.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Indicates who should participate in performing the action described.
    property participantList : TFhirActivityDefinitionParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to Identifies the food, drug or other product being consumed or supplied in the activity. (defined for API consistency)
    property product : TFhirDataType read FProduct write SetProduct;
    // Identifies the food, drug or other product being consumed or supplied in the activity.
    property productElement : TFhirDataType read FProduct write SetProduct;

    // Typed access to Identifies the quantity expected to be consumed at once (per dose, per meal, etc.). (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Identifies the quantity expected to be consumed at once (per dose, per meal, etc.).
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Provides detailed dosage instructions in the same way that they are described for MedicationRequest resources.
    property dosageList : TFhirDosageList read GetDosageList;
    property hasDosageList : boolean read GetHasDosageList;

    // Indicates the sites on the subject's body where the procedure should be performed (I.e. the target sites).
    property bodySiteList : TFhirCodeableConceptList read GetBodySiteList;
    property hasBodySiteList : boolean read GetHasBodySiteList;

    // Defines specimen requirements for the action to be performed, such as required specimens for a lab test.
    property specimenRequirementList : TFhirReferenceList read GetSpecimenRequirementList;
    property hasSpecimenRequirementList : boolean read GetHasSpecimenRequirementList;

    // Defines observation requirements for the action to be performed, such as body weight or surface area.
    property observationRequirementList : TFhirReferenceList read GetObservationRequirementList;
    property hasObservationRequirementList : boolean read GetHasObservationRequirementList;

    // Defines the observations that are expected to be produced by the action.
    property observationResultRequirementList : TFhirReferenceList read GetObservationResultRequirementList;
    property hasObservationResultRequirementList : boolean read GetHasObservationResultRequirementList;

    // Typed access to A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transform : String read GetTransformST write SetTransformST;
    // A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transformElement : TFhirCanonical read FTransform write SetTransform;

    // Dynamic values that will be evaluated to produce values for elements of the resulting resource. For example, if the dosage of a medication must be computed based on the patient's weight, a dynamic value would be used to specify an expression that calculated the weight, and the path on the request resource that would contain the result.
    property dynamicValueList : TFhirActivityDefinitionDynamicValueList read GetDynamicValueList;
    property hasDynamicValueList : boolean read GetHasDynamicValueList;

  end;

  TFhirActivityDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirActivityDefinitionList;
    function GetCurrent : TFhirActivityDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirActivityDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirActivityDefinition read GetCurrent;
  end;

  TFhirActivityDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirActivityDefinition;
    procedure SetItemN(index : Integer; value : TFhirActivityDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirActivityDefinitionList; overload;
    function Clone : TFhirActivityDefinitionList; overload;
    function GetEnumerator : TFhirActivityDefinitionListEnumerator;
    
    //  Add a FhirActivityDefinition to the end of the list.
    function Append : TFhirActivityDefinition;
    
    // Add an already existing FhirActivityDefinition to the end of the list.
    function AddItem(value : TFhirActivityDefinition) : TFhirActivityDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirActivityDefinition) : Integer;
    
    // Insert FhirActivityDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirActivityDefinition;
    
    // Insert an existing FhirActivityDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirActivityDefinition);
    
    // Get the iIndexth FhirActivityDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirActivityDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirActivityDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirActivityDefinitions[index : Integer] : TFhirActivityDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_AUDITEVENT}
  // An actor taking an active role in the event or activity that is logged.
  TFhirAuditEventAgent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FroleList : TFhirCodeableConceptList;
    FWho : TFhirReference;
    FAltId : TFhirString;
    FName : TFhirString;
    FRequestor : TFhirBoolean;
    FLocation : TFhirReference;
    FpolicyList : TFhirUriList;
    FMedia : TFhirCoding;
    FNetwork : TFhirAuditEventAgentNetwork;
    FpurposeOfUseList : TFhirCodeableConceptList;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    procedure SetWho(value : TFhirReference);
    procedure SetAltId(value : TFhirString);
    function GetAltIdST : String;
    procedure SetAltIdST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetRequestor(value : TFhirBoolean);
    function GetRequestorST : Boolean;
    procedure SetRequestorST(value : Boolean);
    procedure SetLocation(value : TFhirReference);
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    procedure SetMedia(value : TFhirCoding);
    procedure SetNetwork(value : TFhirAuditEventAgentNetwork);
    function GetPurposeOfUseList : TFhirCodeableConceptList;
    function GetHasPurposeOfUseList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventAgent; overload;
    function Clone : TFhirAuditEventAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specification of the participation type the user plays when performing the event. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specification of the participation type the user plays when performing the event.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The security role that the user was acting under, that come from local codes defined by the access control security system (e.g. RBAC, ABAC) used in the local context.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to Reference to who this agent is that was involved in the event. (defined for API consistency)
    property who : TFhirReference read FWho write SetWho;
    // Reference to who this agent is that was involved in the event.
    property whoElement : TFhirReference read FWho write SetWho;

    // Typed access to Alternative agent Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g. single sign-on), if available.
    property altId : String read GetAltIdST write SetAltIdST;
    // Alternative agent Identifier. For a human, this should be a user identifier text string from authentication system. This identifier would be one known to a common authentication system (e.g. single sign-on), if available.
    property altIdElement : TFhirString read FAltId write SetAltId;

    // Typed access to Human-meaningful name for the agent.
    property name : String read GetNameST write SetNameST;
    // Human-meaningful name for the agent.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestor : Boolean read GetRequestorST write SetRequestorST;
    // Indicator that the user is or is not the requestor, or initiator, for the event being audited.
    property requestorElement : TFhirBoolean read FRequestor write SetRequestor;

    // Typed access to Where the event occurred. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Where the event occurred.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // The policy or plan that authorized the activity being recorded. Typically, a single activity may have multiple applicable policies, such as patient consent, guarantor funding, etc. The policy would also indicate the security token used.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to Type of media involved. Used when the event is about exporting/importing onto media. (defined for API consistency)
    property media : TFhirCoding read FMedia write SetMedia;
    // Type of media involved. Used when the event is about exporting/importing onto media.
    property mediaElement : TFhirCoding read FMedia write SetMedia;

    // Typed access to Logical network location for application activity, if the activity has a network location. (defined for API consistency)
    property network : TFhirAuditEventAgentNetwork read FNetwork write SetNetwork;
    // Logical network location for application activity, if the activity has a network location.
    property networkElement : TFhirAuditEventAgentNetwork read FNetwork write SetNetwork;

    // The reason (purpose of use), specific to this agent, that was used during the event being recorded.
    property purposeOfUseList : TFhirCodeableConceptList read GetPurposeOfUseList;
    property hasPurposeOfUseList : boolean read GetHasPurposeOfUseList;

  end;

  TFhirAuditEventAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventAgentList;
    function GetCurrent : TFhirAuditEventAgent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventAgent read GetCurrent;
  end;

  TFhirAuditEventAgentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventAgent;
    procedure SetItemN(index : Integer; value : TFhirAuditEventAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventAgentList; overload;
    function Clone : TFhirAuditEventAgentList; overload;
    function GetEnumerator : TFhirAuditEventAgentListEnumerator;
    
    //  Add a FhirAuditEventAgent to the end of the list.
    function Append : TFhirAuditEventAgent;
    
    // Add an already existing FhirAuditEventAgent to the end of the list.
    function AddItem(value : TFhirAuditEventAgent) : TFhirAuditEventAgent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventAgent) : Integer;
    
    // Insert FhirAuditEventAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventAgent;
    
    // Insert an existing FhirAuditEventAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventAgent);
    
    // Get the iIndexth FhirAuditEventAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventAgent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventAgent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventAgents[index : Integer] : TFhirAuditEventAgent read GetItemN write SetItemN; default;
  End;

  // Logical network location for application activity, if the activity has a network location.
  TFhirAuditEventAgentNetwork = class (TFhirBackboneElement)
  protected
    FAddress : TFhirString;
    FType_ : TFhirEnum;
    procedure SetAddress(value : TFhirString);
    function GetAddressST : String;
    procedure SetAddressST(value : String);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirAuditEventAgentNetworkTypeEnum;
    procedure SetType_ST(value : TFhirAuditEventAgentNetworkTypeEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventAgentNetwork; overload;
    function Clone : TFhirAuditEventAgentNetwork; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An identifier for the network access point of the user device for the audit event.
    property address : String read GetAddressST write SetAddressST;
    // An identifier for the network access point of the user device for the audit event.
    property addressElement : TFhirString read FAddress write SetAddress;

    // An identifier for the type of network access point that originated the audit event.
    property type_ : TFhirAuditEventAgentNetworkTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

  end;

  TFhirAuditEventAgentNetworkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventAgentNetworkList;
    function GetCurrent : TFhirAuditEventAgentNetwork;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventAgentNetworkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventAgentNetwork read GetCurrent;
  end;

  TFhirAuditEventAgentNetworkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventAgentNetwork;
    procedure SetItemN(index : Integer; value : TFhirAuditEventAgentNetwork);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventAgentNetworkList; overload;
    function Clone : TFhirAuditEventAgentNetworkList; overload;
    function GetEnumerator : TFhirAuditEventAgentNetworkListEnumerator;
    
    //  Add a FhirAuditEventAgentNetwork to the end of the list.
    function Append : TFhirAuditEventAgentNetwork;
    
    // Add an already existing FhirAuditEventAgentNetwork to the end of the list.
    function AddItem(value : TFhirAuditEventAgentNetwork) : TFhirAuditEventAgentNetwork; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventAgentNetwork) : Integer;
    
    // Insert FhirAuditEventAgentNetwork before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventAgentNetwork;
    
    // Insert an existing FhirAuditEventAgentNetwork before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventAgentNetwork);
    
    // Get the iIndexth FhirAuditEventAgentNetwork. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventAgentNetwork);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventAgentNetwork;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventAgentNetworks[index : Integer] : TFhirAuditEventAgentNetwork read GetItemN write SetItemN; default;
  End;

  // The system that is reporting the event.
  TFhirAuditEventSource = class (TFhirBackboneElement)
  protected
    FSite : TFhirString;
    FObserver : TFhirReference;
    Ftype_List : TFhirCodingList;
    procedure SetSite(value : TFhirString);
    function GetSiteST : String;
    procedure SetSiteST(value : String);
    procedure SetObserver(value : TFhirReference);
    function GetType_List : TFhirCodingList;
    function GetHasType_List : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventSource; overload;
    function Clone : TFhirAuditEventSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group.
    property site : String read GetSiteST write SetSiteST;
    // Logical source location within the healthcare enterprise network.  For example, a hospital or other provider location within a multi-entity provider group.
    property siteElement : TFhirString read FSite write SetSite;

    // Typed access to Identifier of the source where the event was detected. (defined for API consistency)
    property observer : TFhirReference read FObserver write SetObserver;
    // Identifier of the source where the event was detected.
    property observerElement : TFhirReference read FObserver write SetObserver;

    // Code specifying the type of source where event originated.
    property type_List : TFhirCodingList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

  end;

  TFhirAuditEventSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventSourceList;
    function GetCurrent : TFhirAuditEventSource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventSource read GetCurrent;
  end;

  TFhirAuditEventSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventSource;
    procedure SetItemN(index : Integer; value : TFhirAuditEventSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventSourceList; overload;
    function Clone : TFhirAuditEventSourceList; overload;
    function GetEnumerator : TFhirAuditEventSourceListEnumerator;
    
    //  Add a FhirAuditEventSource to the end of the list.
    function Append : TFhirAuditEventSource;
    
    // Add an already existing FhirAuditEventSource to the end of the list.
    function AddItem(value : TFhirAuditEventSource) : TFhirAuditEventSource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventSource) : Integer;
    
    // Insert FhirAuditEventSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventSource;
    
    // Insert an existing FhirAuditEventSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventSource);
    
    // Get the iIndexth FhirAuditEventSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventSource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventSource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventSources[index : Integer] : TFhirAuditEventSource read GetItemN write SetItemN; default;
  End;

  // Specific instances of data or objects that have been accessed.
  TFhirAuditEventEntity = class (TFhirBackboneElement)
  protected
    FWhat : TFhirReference;
    FType_ : TFhirCoding;
    FRole : TFhirCoding;
    FLifecycle : TFhirCoding;
    FsecurityLabelList : TFhirCodingList;
    FName : TFhirString;
    FDescription : TFhirString;
    FQuery : TFhirBase64Binary;
    FdetailList : TFhirAuditEventEntityDetailList;
    procedure SetWhat(value : TFhirReference);
    procedure SetType_(value : TFhirCoding);
    procedure SetRole(value : TFhirCoding);
    procedure SetLifecycle(value : TFhirCoding);
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetQuery(value : TFhirBase64Binary);
    function GetQueryST : TBytes;
    procedure SetQueryST(value : TBytes);
    function GetDetailList : TFhirAuditEventEntityDetailList;
    function GetHasDetailList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventEntity; overload;
    function Clone : TFhirAuditEventEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifies a specific instance of the entity. The reference should be version specific. (defined for API consistency)
    property what : TFhirReference read FWhat write SetWhat;
    // Identifies a specific instance of the entity. The reference should be version specific.
    property whatElement : TFhirReference read FWhat write SetWhat;

    // Typed access to The type of the object that was involved in this audit event. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // The type of the object that was involved in this audit event.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Code representing the role the entity played in the event being audited. (defined for API consistency)
    property role : TFhirCoding read FRole write SetRole;
    // Code representing the role the entity played in the event being audited.
    property roleElement : TFhirCoding read FRole write SetRole;

    // Typed access to Identifier for the data life-cycle stage for the entity. (defined for API consistency)
    property lifecycle : TFhirCoding read FLifecycle write SetLifecycle;
    // Identifier for the data life-cycle stage for the entity.
    property lifecycleElement : TFhirCoding read FLifecycle write SetLifecycle;

    // Security labels for the identified entity.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // Typed access to A name of the entity in the audit event.
    property name : String read GetNameST write SetNameST;
    // A name of the entity in the audit event.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Text that describes the entity in more detail.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Text that describes the entity in more detail.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The query parameters for a query-type entities.
    property query : TBytes read GetQueryST write SetQueryST;
    // The query parameters for a query-type entities.
    property queryElement : TFhirBase64Binary read FQuery write SetQuery;

    // Tagged value pairs for conveying additional information about the entity.
    property detailList : TFhirAuditEventEntityDetailList read GetDetailList;
    property hasDetailList : boolean read GetHasDetailList;

  end;

  TFhirAuditEventEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventEntityList;
    function GetCurrent : TFhirAuditEventEntity;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventEntity read GetCurrent;
  end;

  TFhirAuditEventEntityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventEntity;
    procedure SetItemN(index : Integer; value : TFhirAuditEventEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventEntityList; overload;
    function Clone : TFhirAuditEventEntityList; overload;
    function GetEnumerator : TFhirAuditEventEntityListEnumerator;
    
    //  Add a FhirAuditEventEntity to the end of the list.
    function Append : TFhirAuditEventEntity;
    
    // Add an already existing FhirAuditEventEntity to the end of the list.
    function AddItem(value : TFhirAuditEventEntity) : TFhirAuditEventEntity; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventEntity) : Integer;
    
    // Insert FhirAuditEventEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventEntity;
    
    // Insert an existing FhirAuditEventEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventEntity);
    
    // Get the iIndexth FhirAuditEventEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventEntity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventEntity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventEntities[index : Integer] : TFhirAuditEventEntity read GetItemN write SetItemN; default;
  End;

  // Tagged value pairs for conveying additional information about the entity.
  TFhirAuditEventEntityDetail = class (TFhirBackboneElement)
  protected
    FType_ : TFhirString;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirString);
    function GetType_ST : String;
    procedure SetType_ST(value : String);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEventEntityDetail; overload;
    function Clone : TFhirAuditEventEntityDetail; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of extra detail provided in the value.
    property type_ : String read GetType_ST write SetType_ST;
    // The type of extra detail provided in the value.
    property type_Element : TFhirString read FType_ write SetType_;

    // Typed access to The  value of the extra detail. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The  value of the extra detail.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirAuditEventEntityDetailListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventEntityDetailList;
    function GetCurrent : TFhirAuditEventEntityDetail;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventEntityDetailList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEventEntityDetail read GetCurrent;
  end;

  TFhirAuditEventEntityDetailList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEventEntityDetail;
    procedure SetItemN(index : Integer; value : TFhirAuditEventEntityDetail);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventEntityDetailList; overload;
    function Clone : TFhirAuditEventEntityDetailList; overload;
    function GetEnumerator : TFhirAuditEventEntityDetailListEnumerator;
    
    //  Add a FhirAuditEventEntityDetail to the end of the list.
    function Append : TFhirAuditEventEntityDetail;
    
    // Add an already existing FhirAuditEventEntityDetail to the end of the list.
    function AddItem(value : TFhirAuditEventEntityDetail) : TFhirAuditEventEntityDetail; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEventEntityDetail) : Integer;
    
    // Insert FhirAuditEventEntityDetail before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEventEntityDetail;
    
    // Insert an existing FhirAuditEventEntityDetail before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEventEntityDetail);
    
    // Get the iIndexth FhirAuditEventEntityDetail. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEventEntityDetail);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEventEntityDetail;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEventEntityDetails[index : Integer] : TFhirAuditEventEntityDetail read GetItemN write SetItemN; default;
  End;

  // A record of an event made for purposes of maintaining a security log. Typical uses include detection of intrusion attempts and monitoring for inappropriate usage.
  TFhirAuditEvent = class (TFhirDomainResource)
  protected
    FType_ : TFhirCoding;
    FsubtypeList : TFhirCodingList;
    FAction : TFhirEnum;
    FPeriod : TFhirPeriod;
    FRecorded : TFhirInstant;
    FOutcome : TFhirEnum;
    FOutcomeDesc : TFhirString;
    FpurposeOfEventList : TFhirCodeableConceptList;
    FagentList : TFhirAuditEventAgentList;
    FSource : TFhirAuditEventSource;
    FentityList : TFhirAuditEventEntityList;
    procedure SetType_(value : TFhirCoding);
    function GetSubtypeList : TFhirCodingList;
    function GetHasSubtypeList : Boolean;
    procedure SetAction(value : TFhirEnum);
    function GetActionST : TFhirAuditEventActionEnum;
    procedure SetActionST(value : TFhirAuditEventActionEnum);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetRecorded(value : TFhirInstant);
    function GetRecordedST : TFslDateTime;
    procedure SetRecordedST(value : TFslDateTime);
    procedure SetOutcome(value : TFhirEnum);
    function GetOutcomeST : TFhirAuditEventOutcomeEnum;
    procedure SetOutcomeST(value : TFhirAuditEventOutcomeEnum);
    procedure SetOutcomeDesc(value : TFhirString);
    function GetOutcomeDescST : String;
    procedure SetOutcomeDescST(value : String);
    function GetPurposeOfEventList : TFhirCodeableConceptList;
    function GetHasPurposeOfEventList : Boolean;
    function GetAgentList : TFhirAuditEventAgentList;
    function GetHasAgentList : Boolean;
    procedure SetSource(value : TFhirAuditEventSource);
    function GetEntityList : TFhirAuditEventEntityList;
    function GetHasEntityList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirAuditEvent; overload;
    function Clone : TFhirAuditEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier for a family of the event.  For example, a menu item, program, rule, policy, function code, application name or URL. It identifies the performed function. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Identifier for a family of the event.  For example, a menu item, program, rule, policy, function code, application name or URL. It identifies the performed function.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Identifier for the category of event.
    property subtypeList : TFhirCodingList read GetSubtypeList;
    property hasSubtypeList : boolean read GetHasSubtypeList;

    // Indicator for type of action performed during the event that generated the audit.
    property action : TFhirAuditEventActionEnum read GetActionST write SetActionST;
    property actionElement : TFhirEnum read FAction write SetAction;

    // Typed access to The period during which the activity occurred. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The period during which the activity occurred.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to The time when the event was recorded.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The time when the event was recorded.
    property recordedElement : TFhirInstant read FRecorded write SetRecorded;

    // Indicates whether the event succeeded or failed.
    property outcome : TFhirAuditEventOutcomeEnum read GetOutcomeST write SetOutcomeST;
    property outcomeElement : TFhirEnum read FOutcome write SetOutcome;

    // Typed access to A free text description of the outcome of the event.
    property outcomeDesc : String read GetOutcomeDescST write SetOutcomeDescST;
    // A free text description of the outcome of the event.
    property outcomeDescElement : TFhirString read FOutcomeDesc write SetOutcomeDesc;

    // The purposeOfUse (reason) that was used during the event being recorded.
    property purposeOfEventList : TFhirCodeableConceptList read GetPurposeOfEventList;
    property hasPurposeOfEventList : boolean read GetHasPurposeOfEventList;

    // An actor taking an active role in the event or activity that is logged.
    property agentList : TFhirAuditEventAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // Typed access to The system that is reporting the event. (defined for API consistency)
    property source : TFhirAuditEventSource read FSource write SetSource;
    // The system that is reporting the event.
    property sourceElement : TFhirAuditEventSource read FSource write SetSource;

    // Specific instances of data or objects that have been accessed.
    property entityList : TFhirAuditEventEntityList read GetEntityList;
    property hasEntityList : boolean read GetHasEntityList;

  end;

  TFhirAuditEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirAuditEventList;
    function GetCurrent : TFhirAuditEvent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirAuditEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirAuditEvent read GetCurrent;
  end;

  TFhirAuditEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirAuditEvent;
    procedure SetItemN(index : Integer; value : TFhirAuditEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirAuditEventList; overload;
    function Clone : TFhirAuditEventList; overload;
    function GetEnumerator : TFhirAuditEventListEnumerator;
    
    //  Add a FhirAuditEvent to the end of the list.
    function Append : TFhirAuditEvent;
    
    // Add an already existing FhirAuditEvent to the end of the list.
    function AddItem(value : TFhirAuditEvent) : TFhirAuditEvent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirAuditEvent) : Integer;
    
    // Insert FhirAuditEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirAuditEvent;
    
    // Insert an existing FhirAuditEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirAuditEvent);
    
    // Get the iIndexth FhirAuditEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirAuditEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirAuditEvent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirAuditEvents[index : Integer] : TFhirAuditEvent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BINARY}
  // A resource that represents the data of a single raw artifact as digital content accessible in its native format.  A Binary resource can contain any content, whether text, image, pdf, zip archive, etc.
  TFhirBinary = class (TFhirResource)
  protected
    FContentType : TFhirCode;
    FSecurityContext : TFhirReference;
    FData : TFhirBase64Binary;
    procedure SetContentType(value : TFhirCode);
    function GetContentTypeST : String;
    procedure SetContentTypeST(value : String);
    procedure SetSecurityContext(value : TFhirReference);
    procedure SetData(value : TFhirBase64Binary);
    function GetDataST : TBytes;
    procedure SetDataST(value : TBytes);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBinary; overload;
    function Clone : TFhirBinary; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentType : String read GetContentTypeST write SetContentTypeST;
    // MimeType of the binary content represented as a standard MimeType (BCP 13).
    property contentTypeElement : TFhirCode read FContentType write SetContentType;

    // Typed access to This element identifies another resource that can be used as a proxy of the security sensitivity to use when deciding and enforcing access control rules for the Binary resource. Given that the Binary resource contains very few elements that can be used to determine the sensitivity of the data and relationships to individuals, the referenced resource stands in as a proxy equivalent for this purpose. This referenced resource may be related to the Binary (e.g. Media, DocumentReference), or may be some non-related Resource purely as a security proxy. E.g. to identify that the binary resource relates to a patient, and access should only be granted to applications that have access to the patient. (defined for API consistency)
    property securityContext : TFhirReference read FSecurityContext write SetSecurityContext;
    // This element identifies another resource that can be used as a proxy of the security sensitivity to use when deciding and enforcing access control rules for the Binary resource. Given that the Binary resource contains very few elements that can be used to determine the sensitivity of the data and relationships to individuals, the referenced resource stands in as a proxy equivalent for this purpose. This referenced resource may be related to the Binary (e.g. Media, DocumentReference), or may be some non-related Resource purely as a security proxy. E.g. to identify that the binary resource relates to a patient, and access should only be granted to applications that have access to the patient.
    property securityContextElement : TFhirReference read FSecurityContext write SetSecurityContext;

    // Typed access to The actual content, base64 encoded.
    property data : TBytes read GetDataST write SetDataST;
    // The actual content, base64 encoded.
    property dataElement : TFhirBase64Binary read FData write SetData;

  end;

  TFhirBinaryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBinaryList;
    function GetCurrent : TFhirBinary;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBinaryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBinary read GetCurrent;
  end;

  TFhirBinaryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBinary;
    procedure SetItemN(index : Integer; value : TFhirBinary);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBinaryList; overload;
    function Clone : TFhirBinaryList; overload;
    function GetEnumerator : TFhirBinaryListEnumerator;
    
    //  Add a FhirBinary to the end of the list.
    function Append : TFhirBinary;
    
    // Add an already existing FhirBinary to the end of the list.
    function AddItem(value : TFhirBinary) : TFhirBinary; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBinary) : Integer;
    
    // Insert FhirBinary before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBinary;
    
    // Insert an existing FhirBinary before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBinary);
    
    // Get the iIndexth FhirBinary. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBinary);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBinary;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBinaries[index : Integer] : TFhirBinary read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BUNDLE}
  // A series of links that provide context to this bundle.
  TFhirBundleLink = class (TFhirBackboneElement)
  protected
    FRelation : TFhirString;
    FUrl : TFhirUri;
    procedure SetRelation(value : TFhirString);
    function GetRelationST : String;
    procedure SetRelationST(value : String);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleLink; overload;
    function Clone : TFhirBundleLink; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
    property relation : String read GetRelationST write SetRelationST;
    // A name which details the functional use for this link - see [http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1](http://www.iana.org/assignments/link-relations/link-relations.xhtml#link-relations-1).
    property relationElement : TFhirString read FRelation write SetRelation;

    // Typed access to The reference details for the link.
    property url : String read GetUrlST write SetUrlST;
    // The reference details for the link.
    property urlElement : TFhirUri read FUrl write SetUrl;

  end;

  TFhirBundleLinkListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleLinkList;
    function GetCurrent : TFhirBundleLink;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleLinkList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleLink read GetCurrent;
  end;

  TFhirBundleLinkList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleLink;
    procedure SetItemN(index : Integer; value : TFhirBundleLink);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleLinkList; overload;
    function Clone : TFhirBundleLinkList; overload;
    function GetEnumerator : TFhirBundleLinkListEnumerator;
    
    //  Add a FhirBundleLink to the end of the list.
    function Append : TFhirBundleLink;
    
    // Add an already existing FhirBundleLink to the end of the list.
    function AddItem(value : TFhirBundleLink) : TFhirBundleLink; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleLink) : Integer;
    
    // Insert FhirBundleLink before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleLink;
    
    // Insert an existing FhirBundleLink before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleLink);
    
    // Get the iIndexth FhirBundleLink. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleLink);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleLink;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleLinks[index : Integer] : TFhirBundleLink read GetItemN write SetItemN; default;
  End;

  // An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
  TFhirBundleEntry = class (TFhirBackboneElement)
  protected
    Flink_List : TFhirBundleLinkList;
    FFullUrl : TFhirUri;
    FResource : TFhirResource;
    FSearch : TFhirBundleEntrySearch;
    FRequest : TFhirBundleEntryRequest;
    FResponse : TFhirBundleEntryResponse;
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    procedure SetFullUrl(value : TFhirUri);
    function GetFullUrlST : String;
    procedure SetFullUrlST(value : String);
    procedure SetResource(value : TFhirResource);
    procedure SetSearch(value : TFhirBundleEntrySearch);
    procedure SetRequest(value : TFhirBundleEntryRequest);
    procedure SetResponse(value : TFhirBundleEntryResponse);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntry; overload;
    function Clone : TFhirBundleEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A series of links that provide context to this entry.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // Typed access to The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be version-independent URL consistent with the Resource.id. The fullUrl is a version independent reference to the resource. The fullUrl element SHALL have a value except that:  * fullUrl can be empty on a POST (although it does not need to when specifying a temporary id for reference in the bundle) * Results from operations might involve resources that are not identified.
    property fullUrl : String read GetFullUrlST write SetFullUrlST;
    // The Absolute URL for the resource.  The fullUrl SHALL NOT disagree with the id in the resource - i.e. if the fullUrl is not a urn:uuid, the URL shall be version-independent URL consistent with the Resource.id. The fullUrl is a version independent reference to the resource. The fullUrl element SHALL have a value except that:  * fullUrl can be empty on a POST (although it does not need to when specifying a temporary id for reference in the bundle) * Results from operations might involve resources that are not identified.
    property fullUrlElement : TFhirUri read FFullUrl write SetFullUrl;

    // Typed access to The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // The Resource for the entry. The purpose/meaning of the resource is determined by the Bundle.type.
    property resourceElement : TFhirResource read FResource write SetResource;

    // Typed access to Information about the search process that lead to the creation of this entry. (defined for API consistency)
    property search : TFhirBundleEntrySearch read FSearch write SetSearch;
    // Information about the search process that lead to the creation of this entry.
    property searchElement : TFhirBundleEntrySearch read FSearch write SetSearch;

    // Typed access to Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry. (defined for API consistency)
    property request : TFhirBundleEntryRequest read FRequest write SetRequest;
    // Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
    property requestElement : TFhirBundleEntryRequest read FRequest write SetRequest;

    // Typed access to Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history. (defined for API consistency)
    property response : TFhirBundleEntryResponse read FResponse write SetResponse;
    // Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
    property responseElement : TFhirBundleEntryResponse read FResponse write SetResponse;

  end;

  TFhirBundleEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryList;
    function GetCurrent : TFhirBundleEntry;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntry read GetCurrent;
  end;

  TFhirBundleEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleEntry;
    procedure SetItemN(index : Integer; value : TFhirBundleEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleEntryList; overload;
    function Clone : TFhirBundleEntryList; overload;
    function GetEnumerator : TFhirBundleEntryListEnumerator;
    
    //  Add a FhirBundleEntry to the end of the list.
    function Append : TFhirBundleEntry;
    
    // Add an already existing FhirBundleEntry to the end of the list.
    function AddItem(value : TFhirBundleEntry) : TFhirBundleEntry; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntry) : Integer;
    
    // Insert FhirBundleEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntry;
    
    // Insert an existing FhirBundleEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntry);
    
    // Get the iIndexth FhirBundleEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleEntries[index : Integer] : TFhirBundleEntry read GetItemN write SetItemN; default;
  End;

  // Information about the search process that lead to the creation of this entry.
  TFhirBundleEntrySearch = class (TFhirBackboneElement)
  protected
    FMode : TFhirEnum;
    FScore : TFhirDecimal;
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirSearchEntryModeEnum;
    procedure SetModeST(value : TFhirSearchEntryModeEnum);
    procedure SetScore(value : TFhirDecimal);
    function GetScoreST : String;
    procedure SetScoreST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntrySearch; overload;
    function Clone : TFhirBundleEntrySearch; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Why this entry is in the result set - whether it's included as a match or because of an _include requirement, or to convey information or warning information about the search process.
    property mode : TFhirSearchEntryModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to When searching, the server's search ranking score for the entry.
    property score : String read GetScoreST write SetScoreST;
    // When searching, the server's search ranking score for the entry.
    property scoreElement : TFhirDecimal read FScore write SetScore;

  end;

  TFhirBundleEntrySearchListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntrySearchList;
    function GetCurrent : TFhirBundleEntrySearch;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntrySearchList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntrySearch read GetCurrent;
  end;

  TFhirBundleEntrySearchList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleEntrySearch;
    procedure SetItemN(index : Integer; value : TFhirBundleEntrySearch);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleEntrySearchList; overload;
    function Clone : TFhirBundleEntrySearchList; overload;
    function GetEnumerator : TFhirBundleEntrySearchListEnumerator;
    
    //  Add a FhirBundleEntrySearch to the end of the list.
    function Append : TFhirBundleEntrySearch;
    
    // Add an already existing FhirBundleEntrySearch to the end of the list.
    function AddItem(value : TFhirBundleEntrySearch) : TFhirBundleEntrySearch; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntrySearch) : Integer;
    
    // Insert FhirBundleEntrySearch before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntrySearch;
    
    // Insert an existing FhirBundleEntrySearch before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntrySearch);
    
    // Get the iIndexth FhirBundleEntrySearch. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntrySearch);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntrySearch;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleEntrySearches[index : Integer] : TFhirBundleEntrySearch read GetItemN write SetItemN; default;
  End;

  // Additional information about how this entry should be processed as part of a transaction or batch.  For history, it shows how the entry was processed to create the version contained in the entry.
  TFhirBundleEntryRequest = class (TFhirBackboneElement)
  protected
    FMethod : TFhirEnum;
    FUrl : TFhirUri;
    FIfNoneMatch : TFhirString;
    FIfModifiedSince : TFhirInstant;
    FIfMatch : TFhirString;
    FIfNoneExist : TFhirString;
    procedure SetMethod(value : TFhirEnum);
    function GetMethodST : TFhirHTTPVerbEnum;
    procedure SetMethodST(value : TFhirHTTPVerbEnum);
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetIfNoneMatch(value : TFhirString);
    function GetIfNoneMatchST : String;
    procedure SetIfNoneMatchST(value : String);
    procedure SetIfModifiedSince(value : TFhirInstant);
    function GetIfModifiedSinceST : TFslDateTime;
    procedure SetIfModifiedSinceST(value : TFslDateTime);
    procedure SetIfMatch(value : TFhirString);
    function GetIfMatchST : String;
    procedure SetIfMatchST(value : String);
    procedure SetIfNoneExist(value : TFhirString);
    function GetIfNoneExistST : String;
    procedure SetIfNoneExistST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryRequest; overload;
    function Clone : TFhirBundleEntryRequest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // In a transaction or batch, this is the HTTP action to be executed for this entry. In a history bundle, this indicates the HTTP action that occurred.
    property method : TFhirHTTPVerbEnum read GetMethodST write SetMethodST;
    property methodElement : TFhirEnum read FMethod write SetMethod;

    // Typed access to The URL for this entry, relative to the root (the address to which the request is posted).
    property url : String read GetUrlST write SetUrlST;
    // The URL for this entry, relative to the root (the address to which the request is posted).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatch : String read GetIfNoneMatchST write SetIfNoneMatchST;
    // If the ETag values match, return a 304 Not Modified status. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifNoneMatchElement : TFhirString read FIfNoneMatch write SetIfNoneMatch;

    // Typed access to Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSince : TFslDateTime read GetIfModifiedSinceST write SetIfModifiedSinceST;
    // Only perform the operation if the last updated date matches. See the API documentation for ["Conditional Read"](http.html#cread).
    property ifModifiedSinceElement : TFhirInstant read FIfModifiedSince write SetIfModifiedSince;

    // Typed access to Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatch : String read GetIfMatchST write SetIfMatchST;
    // Only perform the operation if the Etag value matches. For more information, see the API section ["Managing Resource Contention"](http.html#concurrency).
    property ifMatchElement : TFhirString read FIfMatch write SetIfMatch;

    // Typed access to Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExist : String read GetIfNoneExistST write SetIfNoneExistST;
    // Instruct the server not to perform the create if a specified resource already exists. For further information, see the API documentation for ["Conditional Create"](http.html#ccreate). This is just the query portion of the URL - what follows the "?" (not including the "?").
    property ifNoneExistElement : TFhirString read FIfNoneExist write SetIfNoneExist;

  end;

  TFhirBundleEntryRequestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryRequestList;
    function GetCurrent : TFhirBundleEntryRequest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryRequestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryRequest read GetCurrent;
  end;

  TFhirBundleEntryRequestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleEntryRequest;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryRequest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleEntryRequestList; overload;
    function Clone : TFhirBundleEntryRequestList; overload;
    function GetEnumerator : TFhirBundleEntryRequestListEnumerator;
    
    //  Add a FhirBundleEntryRequest to the end of the list.
    function Append : TFhirBundleEntryRequest;
    
    // Add an already existing FhirBundleEntryRequest to the end of the list.
    function AddItem(value : TFhirBundleEntryRequest) : TFhirBundleEntryRequest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryRequest) : Integer;
    
    // Insert FhirBundleEntryRequest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryRequest;
    
    // Insert an existing FhirBundleEntryRequest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryRequest);
    
    // Get the iIndexth FhirBundleEntryRequest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryRequest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryRequest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleEntryRequests[index : Integer] : TFhirBundleEntryRequest read GetItemN write SetItemN; default;
  End;

  // Indicates the results of processing the corresponding 'request' entry in the batch or transaction being responded to or what the results of an operation where when returning history.
  TFhirBundleEntryResponse = class (TFhirBackboneElement)
  protected
    FStatus : TFhirString;
    FLocation : TFhirUri;
    FEtag : TFhirString;
    FLastModified : TFhirInstant;
    FOutcome : TFhirResource;
    procedure SetStatus(value : TFhirString);
    function GetStatusST : String;
    procedure SetStatusST(value : String);
    procedure SetLocation(value : TFhirUri);
    function GetLocationST : String;
    procedure SetLocationST(value : String);
    procedure SetEtag(value : TFhirString);
    function GetEtagST : String;
    procedure SetEtagST(value : String);
    procedure SetLastModified(value : TFhirInstant);
    function GetLastModifiedST : TFslDateTime;
    procedure SetLastModifiedST(value : TFslDateTime);
    procedure SetOutcome(value : TFhirResource);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundleEntryResponse; overload;
    function Clone : TFhirBundleEntryResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
    property status : String read GetStatusST write SetStatusST;
    // The status code returned by processing this entry. The status SHALL start with a 3 digit HTTP code (e.g. 404) and may contain the standard HTTP description associated with the status code.
    property statusElement : TFhirString read FStatus write SetStatus;

    // Typed access to The location header created by processing this operation, populated if the operation returns a location.
    property location : String read GetLocationST write SetLocationST;
    // The location header created by processing this operation, populated if the operation returns a location.
    property locationElement : TFhirUri read FLocation write SetLocation;

    // Typed access to The Etag for the resource, if the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](http.html#versioning) and [Managing Resource Contention](http.html#concurrency)).
    property etag : String read GetEtagST write SetEtagST;
    // The Etag for the resource, if the operation for the entry produced a versioned resource (see [Resource Metadata and Versioning](http.html#versioning) and [Managing Resource Contention](http.html#concurrency)).
    property etagElement : TFhirString read FEtag write SetEtag;

    // Typed access to The date/time that the resource was modified on the server.
    property lastModified : TFslDateTime read GetLastModifiedST write SetLastModifiedST;
    // The date/time that the resource was modified on the server.
    property lastModifiedElement : TFhirInstant read FLastModified write SetLastModified;

    // Typed access to An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction. (defined for API consistency)
    property outcome : TFhirResource read FOutcome write SetOutcome;
    // An OperationOutcome containing hints and warnings produced as part of processing this entry in a batch or transaction.
    property outcomeElement : TFhirResource read FOutcome write SetOutcome;

  end;

  TFhirBundleEntryResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleEntryResponseList;
    function GetCurrent : TFhirBundleEntryResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleEntryResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundleEntryResponse read GetCurrent;
  end;

  TFhirBundleEntryResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundleEntryResponse;
    procedure SetItemN(index : Integer; value : TFhirBundleEntryResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleEntryResponseList; overload;
    function Clone : TFhirBundleEntryResponseList; overload;
    function GetEnumerator : TFhirBundleEntryResponseListEnumerator;
    
    //  Add a FhirBundleEntryResponse to the end of the list.
    function Append : TFhirBundleEntryResponse;
    
    // Add an already existing FhirBundleEntryResponse to the end of the list.
    function AddItem(value : TFhirBundleEntryResponse) : TFhirBundleEntryResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundleEntryResponse) : Integer;
    
    // Insert FhirBundleEntryResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundleEntryResponse;
    
    // Insert an existing FhirBundleEntryResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundleEntryResponse);
    
    // Get the iIndexth FhirBundleEntryResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundleEntryResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundleEntryResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundleEntryResponses[index : Integer] : TFhirBundleEntryResponse read GetItemN write SetItemN; default;
  End;

  // A container for a collection of resources.
  TFhirBundle = class (TFhirResource)
  protected
    FIdentifier : TFhirIdentifier;
    FType_ : TFhirEnum;
    FTimestamp : TFhirInstant;
    FTotal : TFhirUnsignedInt;
    Flink_List : TFhirBundleLinkList;
    FentryList : TFhirBundleEntryList;
    FSignature : TFhirSignature;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirBundleTypeEnum;
    procedure SetType_ST(value : TFhirBundleTypeEnum);
    procedure SetTimestamp(value : TFhirInstant);
    function GetTimestampST : TFslDateTime;
    procedure SetTimestampST(value : TFslDateTime);
    procedure SetTotal(value : TFhirUnsignedInt);
    function GetTotalST : String;
    procedure SetTotalST(value : String);
    function GetLink_List : TFhirBundleLinkList;
    function GetHasLink_List : Boolean;
    function GetEntryList : TFhirBundleEntryList;
    function GetHasEntryList : Boolean;
    procedure SetSignature(value : TFhirSignature);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirBundle; overload;
    function Clone : TFhirBundle; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A persistent identifier for the bundle that won't change as a bundle is copied from server to server. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A persistent identifier for the bundle that won't change as a bundle is copied from server to server.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Indicates the purpose of this bundle - how it is intended to be used.
    property type_ : TFhirBundleTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The date/time that the bundle was assembled - i.e. when the resources were placed in the bundle.
    property timestampElement : TFhirInstant read FTimestamp write SetTimestamp;

    // Typed access to If a set of search matches, this is the total number of entries of type 'match' across all pages in the search.  It does not include search.mode = 'include' or 'outcome' entries and it does not provide a count of the number of entries in the Bundle.
    property total : String read GetTotalST write SetTotalST;
    // If a set of search matches, this is the total number of entries of type 'match' across all pages in the search.  It does not include search.mode = 'include' or 'outcome' entries and it does not provide a count of the number of entries in the Bundle.
    property totalElement : TFhirUnsignedInt read FTotal write SetTotal;

    // A series of links that provide context to this bundle.
    property link_List : TFhirBundleLinkList read GetLink_List;
    property hasLink_List : boolean read GetHasLink_List;

    // An entry in a bundle resource - will either contain a resource or information about a resource (transactions and history only).
    property entryList : TFhirBundleEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to Digital Signature - base64 encoded. XML-DSig or a JWT. (defined for API consistency)
    property signature : TFhirSignature read FSignature write SetSignature;
    // Digital Signature - base64 encoded. XML-DSig or a JWT.
    property signatureElement : TFhirSignature read FSignature write SetSignature;

  end;

  TFhirBundleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirBundleList;
    function GetCurrent : TFhirBundle;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirBundleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirBundle read GetCurrent;
  end;

  TFhirBundleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirBundle;
    procedure SetItemN(index : Integer; value : TFhirBundle);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirBundleList; overload;
    function Clone : TFhirBundleList; overload;
    function GetEnumerator : TFhirBundleListEnumerator;
    
    //  Add a FhirBundle to the end of the list.
    function Append : TFhirBundle;
    
    // Add an already existing FhirBundle to the end of the list.
    function AddItem(value : TFhirBundle) : TFhirBundle; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirBundle) : Integer;
    
    // Insert FhirBundle before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirBundle;
    
    // Insert an existing FhirBundle before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirBundle);
    
    // Get the iIndexth FhirBundle. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirBundle);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirBundle;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirBundles[index : Integer] : TFhirBundle read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CONSENT}
  // The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
  TFhirConsentPolicy = class (TFhirBackboneElement)
  protected
    FAuthority : TFhirUri;
    FUri : TFhirUri;
    procedure SetAuthority(value : TFhirUri);
    function GetAuthorityST : String;
    procedure SetAuthorityST(value : String);
    procedure SetUri(value : TFhirUri);
    function GetUriST : String;
    procedure SetUriST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentPolicy; overload;
    function Clone : TFhirConsentPolicy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Entity or Organization having regulatory jurisdiction or accountability for  enforcing policies pertaining to Consent Directives.
    property authority : String read GetAuthorityST write SetAuthorityST;
    // Entity or Organization having regulatory jurisdiction or accountability for  enforcing policies pertaining to Consent Directives.
    property authorityElement : TFhirUri read FAuthority write SetAuthority;

    // Typed access to The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
    property uri : String read GetUriST write SetUriST;
    // The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
    property uriElement : TFhirUri read FUri write SetUri;

  end;

  TFhirConsentPolicyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentPolicyList;
    function GetCurrent : TFhirConsentPolicy;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentPolicyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentPolicy read GetCurrent;
  end;

  TFhirConsentPolicyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentPolicy;
    procedure SetItemN(index : Integer; value : TFhirConsentPolicy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentPolicyList; overload;
    function Clone : TFhirConsentPolicyList; overload;
    function GetEnumerator : TFhirConsentPolicyListEnumerator;
    
    //  Add a FhirConsentPolicy to the end of the list.
    function Append : TFhirConsentPolicy;
    
    // Add an already existing FhirConsentPolicy to the end of the list.
    function AddItem(value : TFhirConsentPolicy) : TFhirConsentPolicy; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentPolicy) : Integer;
    
    // Insert FhirConsentPolicy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentPolicy;
    
    // Insert an existing FhirConsentPolicy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentPolicy);
    
    // Get the iIndexth FhirConsentPolicy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentPolicy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentPolicy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentPolicies[index : Integer] : TFhirConsentPolicy read GetItemN write SetItemN; default;
  End;

  // Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
  TFhirConsentVerification = class (TFhirBackboneElement)
  protected
    FVerified : TFhirBoolean;
    FVerifiedWith : TFhirReference;
    FVerificationDate : TFhirDateTime;
    procedure SetVerified(value : TFhirBoolean);
    function GetVerifiedST : Boolean;
    procedure SetVerifiedST(value : Boolean);
    procedure SetVerifiedWith(value : TFhirReference);
    procedure SetVerificationDate(value : TFhirDateTime);
    function GetVerificationDateST : TFslDateTime;
    procedure SetVerificationDateST(value : TFslDateTime);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentVerification; overload;
    function Clone : TFhirConsentVerification; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Has the instruction been verified.
    property verified : Boolean read GetVerifiedST write SetVerifiedST;
    // Has the instruction been verified.
    property verifiedElement : TFhirBoolean read FVerified write SetVerified;

    // Typed access to Who verified the instruction (Patient, Relative or other Authorized Person). (defined for API consistency)
    property verifiedWith : TFhirReference read FVerifiedWith write SetVerifiedWith;
    // Who verified the instruction (Patient, Relative or other Authorized Person).
    property verifiedWithElement : TFhirReference read FVerifiedWith write SetVerifiedWith;

    // Typed access to Date verification was collected.
    property verificationDate : TFslDateTime read GetVerificationDateST write SetVerificationDateST;
    // Date verification was collected.
    property verificationDateElement : TFhirDateTime read FVerificationDate write SetVerificationDate;

  end;

  TFhirConsentVerificationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentVerificationList;
    function GetCurrent : TFhirConsentVerification;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentVerificationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentVerification read GetCurrent;
  end;

  TFhirConsentVerificationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentVerification;
    procedure SetItemN(index : Integer; value : TFhirConsentVerification);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentVerificationList; overload;
    function Clone : TFhirConsentVerificationList; overload;
    function GetEnumerator : TFhirConsentVerificationListEnumerator;
    
    //  Add a FhirConsentVerification to the end of the list.
    function Append : TFhirConsentVerification;
    
    // Add an already existing FhirConsentVerification to the end of the list.
    function AddItem(value : TFhirConsentVerification) : TFhirConsentVerification; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentVerification) : Integer;
    
    // Insert FhirConsentVerification before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentVerification;
    
    // Insert an existing FhirConsentVerification before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentVerification);
    
    // Get the iIndexth FhirConsentVerification. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentVerification);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentVerification;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentVerifications[index : Integer] : TFhirConsentVerification read GetItemN write SetItemN; default;
  End;

  // An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
  TFhirConsentProvision = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FPeriod : TFhirPeriod;
    FactorList : TFhirConsentProvisionActorList;
    FactionList : TFhirCodeableConceptList;
    FsecurityLabelList : TFhirCodingList;
    FpurposeList : TFhirCodingList;
    Fclass_List : TFhirCodingList;
    FcodeList : TFhirCodeableConceptList;
    FDataPeriod : TFhirPeriod;
    FdataList : TFhirConsentProvisionDataList;
    FprovisionList : TFhirConsentProvisionList;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirConsentProvisionTypeEnum;
    procedure SetType_ST(value : TFhirConsentProvisionTypeEnum);
    procedure SetPeriod(value : TFhirPeriod);
    function GetActorList : TFhirConsentProvisionActorList;
    function GetHasActorList : Boolean;
    function GetActionList : TFhirCodeableConceptList;
    function GetHasActionList : Boolean;
    function GetSecurityLabelList : TFhirCodingList;
    function GetHasSecurityLabelList : Boolean;
    function GetPurposeList : TFhirCodingList;
    function GetHasPurposeList : Boolean;
    function GetClass_List : TFhirCodingList;
    function GetHasClass_List : Boolean;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    procedure SetDataPeriod(value : TFhirPeriod);
    function GetDataList : TFhirConsentProvisionDataList;
    function GetHasDataList : Boolean;
    function GetProvisionList : TFhirConsentProvisionList;
    function GetHasProvisionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentProvision; overload;
    function Clone : TFhirConsentProvision; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Action  to take - permit or deny - when the rule conditions are met.  Not permitted in root rule, required in all nested rules.
    property type_ : TFhirConsentProvisionTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The timeframe in this rule is valid. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The timeframe in this rule is valid.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property actorList : TFhirConsentProvisionActorList read GetActorList;
    property hasActorList : boolean read GetHasActorList;

    // Actions controlled by this Rule.
    property actionList : TFhirCodeableConceptList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // A security label, comprised of 0..* security label fields (Privacy tags), which define which resources are controlled by this exception.
    property securityLabelList : TFhirCodingList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // The context of the activities a user is taking - why the user is accessing the data - that are controlled by this rule.
    property purposeList : TFhirCodingList read GetPurposeList;
    property hasPurposeList : boolean read GetHasPurposeList;

    // The class of information covered by this rule. The type can be a FHIR resource type, a profile on a type, or a CDA document, or some other type that indicates what sort of information the consent relates to.
    property class_List : TFhirCodingList read GetClass_List;
    property hasClass_List : boolean read GetHasClass_List;

    // If this code is found in an instance, then the rule applies.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to Clinical or Operational Relevant period of time that bounds the data controlled by this rule. (defined for API consistency)
    property dataPeriod : TFhirPeriod read FDataPeriod write SetDataPeriod;
    // Clinical or Operational Relevant period of time that bounds the data controlled by this rule.
    property dataPeriodElement : TFhirPeriod read FDataPeriod write SetDataPeriod;

    // The resources controlled by this rule if specific resources are referenced.
    property dataList : TFhirConsentProvisionDataList read GetDataList;
    property hasDataList : boolean read GetHasDataList;

    // Rules which provide exceptions to the base rule or subrules.
    property provisionList : TFhirConsentProvisionList read GetProvisionList;
    property hasProvisionList : boolean read GetHasProvisionList;

  end;

  TFhirConsentProvisionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentProvisionList;
    function GetCurrent : TFhirConsentProvision;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentProvisionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentProvision read GetCurrent;
  end;

  TFhirConsentProvisionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentProvision;
    procedure SetItemN(index : Integer; value : TFhirConsentProvision);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentProvisionList; overload;
    function Clone : TFhirConsentProvisionList; overload;
    function GetEnumerator : TFhirConsentProvisionListEnumerator;
    
    //  Add a FhirConsentProvision to the end of the list.
    function Append : TFhirConsentProvision;
    
    // Add an already existing FhirConsentProvision to the end of the list.
    function AddItem(value : TFhirConsentProvision) : TFhirConsentProvision; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentProvision) : Integer;
    
    // Insert FhirConsentProvision before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentProvision;
    
    // Insert an existing FhirConsentProvision before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentProvision);
    
    // Get the iIndexth FhirConsentProvision. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentProvision);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentProvision;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentProvisions[index : Integer] : TFhirConsentProvision read GetItemN write SetItemN; default;
  End;

  // Who or what is controlled by this rule. Use group to identify a set of actors by some property they share (e.g. 'admitting officers').
  TFhirConsentProvisionActor = class (TFhirBackboneElement)
  protected
    FRole : TFhirCodeableConcept;
    FReference : TFhirReference;
    procedure SetRole(value : TFhirCodeableConcept);
    procedure SetReference(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentProvisionActor; overload;
    function Clone : TFhirConsentProvisionActor; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to How the individual is involved in the resources content that is described in the exception. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // How the individual is involved in the resources content that is described in the exception.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

    // Typed access to The resource that identifies the actor. To identify actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers'). (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // The resource that identifies the actor. To identify actors by type, use group to identify a set of actors by some property they share (e.g. 'admitting officers').
    property referenceElement : TFhirReference read FReference write SetReference;

  end;

  TFhirConsentProvisionActorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentProvisionActorList;
    function GetCurrent : TFhirConsentProvisionActor;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentProvisionActorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentProvisionActor read GetCurrent;
  end;

  TFhirConsentProvisionActorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentProvisionActor;
    procedure SetItemN(index : Integer; value : TFhirConsentProvisionActor);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentProvisionActorList; overload;
    function Clone : TFhirConsentProvisionActorList; overload;
    function GetEnumerator : TFhirConsentProvisionActorListEnumerator;
    
    //  Add a FhirConsentProvisionActor to the end of the list.
    function Append : TFhirConsentProvisionActor;
    
    // Add an already existing FhirConsentProvisionActor to the end of the list.
    function AddItem(value : TFhirConsentProvisionActor) : TFhirConsentProvisionActor; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentProvisionActor) : Integer;
    
    // Insert FhirConsentProvisionActor before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentProvisionActor;
    
    // Insert an existing FhirConsentProvisionActor before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentProvisionActor);
    
    // Get the iIndexth FhirConsentProvisionActor. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentProvisionActor);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentProvisionActor;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentProvisionActors[index : Integer] : TFhirConsentProvisionActor read GetItemN write SetItemN; default;
  End;

  // The resources controlled by this rule if specific resources are referenced.
  TFhirConsentProvisionData = class (TFhirBackboneElement)
  protected
    FMeaning : TFhirEnum;
    FReference : TFhirReference;
    procedure SetMeaning(value : TFhirEnum);
    function GetMeaningST : TFhirConsentDataMeaningEnum;
    procedure SetMeaningST(value : TFhirConsentDataMeaningEnum);
    procedure SetReference(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsentProvisionData; overload;
    function Clone : TFhirConsentProvisionData; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // How the resource reference is interpreted when testing consent restrictions.
    property meaning : TFhirConsentDataMeaningEnum read GetMeaningST write SetMeaningST;
    property meaningElement : TFhirEnum read FMeaning write SetMeaning;

    // Typed access to A reference to a specific resource that defines which resources are covered by this consent. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // A reference to a specific resource that defines which resources are covered by this consent.
    property referenceElement : TFhirReference read FReference write SetReference;

  end;

  TFhirConsentProvisionDataListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentProvisionDataList;
    function GetCurrent : TFhirConsentProvisionData;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentProvisionDataList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsentProvisionData read GetCurrent;
  end;

  TFhirConsentProvisionDataList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsentProvisionData;
    procedure SetItemN(index : Integer; value : TFhirConsentProvisionData);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentProvisionDataList; overload;
    function Clone : TFhirConsentProvisionDataList; overload;
    function GetEnumerator : TFhirConsentProvisionDataListEnumerator;
    
    //  Add a FhirConsentProvisionData to the end of the list.
    function Append : TFhirConsentProvisionData;
    
    // Add an already existing FhirConsentProvisionData to the end of the list.
    function AddItem(value : TFhirConsentProvisionData) : TFhirConsentProvisionData; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsentProvisionData) : Integer;
    
    // Insert FhirConsentProvisionData before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsentProvisionData;
    
    // Insert an existing FhirConsentProvisionData before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsentProvisionData);
    
    // Get the iIndexth FhirConsentProvisionData. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsentProvisionData);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsentProvisionData;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsentProvisionData[index : Integer] : TFhirConsentProvisionData read GetItemN write SetItemN; default;
  End;

  // A record of a healthcare consumers  choices, which permits or denies identified recipient(s) or recipient role(s) to perform one or more actions within a given policy context, for specific purposes and periods of time.
  TFhirConsent = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FScope : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FPatient : TFhirReference;
    FDateTime : TFhirDateTime;
    FperformerList : TFhirReferenceList;
    ForganizationList : TFhirReferenceList;
    FSource : TFhirDataType;
    FpolicyList : TFhirConsentPolicyList;
    FPolicyRule : TFhirCodeableConcept;
    FverificationList : TFhirConsentVerificationList;
    FProvision : TFhirConsentProvision;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirConsentStateEnum;
    procedure SetStatusST(value : TFhirConsentStateEnum);
    procedure SetScope(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    procedure SetPatient(value : TFhirReference);
    procedure SetDateTime(value : TFhirDateTime);
    function GetDateTimeST : TFslDateTime;
    procedure SetDateTimeST(value : TFslDateTime);
    function GetPerformerList : TFhirReferenceList;
    function GetHasPerformerList : Boolean;
    function GetOrganizationList : TFhirReferenceList;
    function GetHasOrganizationList : Boolean;
    procedure SetSource(value : TFhirDataType);
    function GetPolicyList : TFhirConsentPolicyList;
    function GetHasPolicyList : Boolean;
    procedure SetPolicyRule(value : TFhirCodeableConcept);
    function GetVerificationList : TFhirConsentVerificationList;
    function GetHasVerificationList : Boolean;
    procedure SetProvision(value : TFhirConsentProvision);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirConsent; overload;
    function Clone : TFhirConsent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier for this copy of the Consent Statement.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of this consent.
    property status : TFhirConsentStateEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A selector of the type of consent being presented: ADR, Privacy, Treatment, Research.  This list is now extensible. (defined for API consistency)
    property scope : TFhirCodeableConcept read FScope write SetScope;
    // A selector of the type of consent being presented: ADR, Privacy, Treatment, Research.  This list is now extensible.
    property scopeElement : TFhirCodeableConcept read FScope write SetScope;

    // A classification of the type of consents found in the statement. This element supports indexing and retrieval of consent statements.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Typed access to The patient/healthcare consumer to whom this consent applies. (defined for API consistency)
    property patient : TFhirReference read FPatient write SetPatient;
    // The patient/healthcare consumer to whom this consent applies.
    property patientElement : TFhirReference read FPatient write SetPatient;

    // Typed access to When this  Consent was issued / created / indexed.
    property dateTime : TFslDateTime read GetDateTimeST write SetDateTimeST;
    // When this  Consent was issued / created / indexed.
    property dateTimeElement : TFhirDateTime read FDateTime write SetDateTime;

    // Either the Grantor, which is the entity responsible for granting the rights listed in a Consent Directive or the Grantee, which is the entity responsible for complying with the Consent Directive, including any obligations or limitations on authorizations and enforcement of prohibitions.
    property performerList : TFhirReferenceList read GetPerformerList;
    property hasPerformerList : boolean read GetHasPerformerList;

    // The organization that manages the consent, and the framework within which it is executed.
    property organizationList : TFhirReferenceList read GetOrganizationList;
    property hasOrganizationList : boolean read GetHasOrganizationList;

    // Typed access to The source on which this consent statement is based. The source might be a scanned original paper form, or a reference to a consent that links back to such a source, a reference to a document repository (e.g. XDS) that stores the original consent document. (defined for API consistency)
    property source : TFhirDataType read FSource write SetSource;
    // The source on which this consent statement is based. The source might be a scanned original paper form, or a reference to a consent that links back to such a source, a reference to a document repository (e.g. XDS) that stores the original consent document.
    property sourceElement : TFhirDataType read FSource write SetSource;

    // The references to the policies that are included in this consent scope. Policies may be organizational, but are often defined jurisdictionally, or in law.
    property policyList : TFhirConsentPolicyList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to A reference to the specific base computable regulation or policy. (defined for API consistency)
    property policyRule : TFhirCodeableConcept read FPolicyRule write SetPolicyRule;
    // A reference to the specific base computable regulation or policy.
    property policyRuleElement : TFhirCodeableConcept read FPolicyRule write SetPolicyRule;

    // Whether a treatment instruction (e.g. artificial respiration yes or no) was verified with the patient, his/her family or another authorized person.
    property verificationList : TFhirConsentVerificationList read GetVerificationList;
    property hasVerificationList : boolean read GetHasVerificationList;

    // Typed access to An exception to the base policy of this consent. An exception can be an addition or removal of access permissions. (defined for API consistency)
    property provision : TFhirConsentProvision read FProvision write SetProvision;
    // An exception to the base policy of this consent. An exception can be an addition or removal of access permissions.
    property provisionElement : TFhirConsentProvision read FProvision write SetProvision;

  end;

  TFhirConsentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirConsentList;
    function GetCurrent : TFhirConsent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirConsentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirConsent read GetCurrent;
  end;

  TFhirConsentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirConsent;
    procedure SetItemN(index : Integer; value : TFhirConsent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirConsentList; overload;
    function Clone : TFhirConsentList; overload;
    function GetEnumerator : TFhirConsentListEnumerator;
    
    //  Add a FhirConsent to the end of the list.
    function Append : TFhirConsent;
    
    // Add an already existing FhirConsent to the end of the list.
    function AddItem(value : TFhirConsent) : TFhirConsent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirConsent) : Integer;
    
    // Insert FhirConsent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirConsent;
    
    // Insert an existing FhirConsent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirConsent);
    
    // Get the iIndexth FhirConsent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirConsent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirConsent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirConsents[index : Integer] : TFhirConsent read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
  // Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
  TFhirContractContentDefinition = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FPublisher : TFhirReference;
    FPublicationDate : TFhirDateTime;
    FPublicationStatus : TFhirEnum;
    FCopyright : TFhirMarkdown;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetPublisher(value : TFhirReference);
    procedure SetPublicationDate(value : TFhirDateTime);
    function GetPublicationDateST : TFslDateTime;
    procedure SetPublicationDateST(value : TFslDateTime);
    procedure SetPublicationStatus(value : TFhirEnum);
    function GetPublicationStatusST : TFhirContractResourcePublicationStatusCodesEnum;
    procedure SetPublicationStatusST(value : TFhirContractResourcePublicationStatusCodesEnum);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractContentDefinition; overload;
    function Clone : TFhirContractContentDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Precusory content structure and use, i.e., a boilerplate, template, application for a contract such as an insurance policy or benefits under a program, e.g., workers compensation. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Precusory content structure and use, i.e., a boilerplate, template, application for a contract such as an insurance policy or benefits under a program, e.g., workers compensation.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Detailed Precusory content type. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // Detailed Precusory content type.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // Typed access to The  individual or organization that published the Contract precursor content. (defined for API consistency)
    property publisher : TFhirReference read FPublisher write SetPublisher;
    // The  individual or organization that published the Contract precursor content.
    property publisherElement : TFhirReference read FPublisher write SetPublisher;

    // Typed access to The date (and optionally time) when the contract was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the contract changes.
    property publicationDate : TFslDateTime read GetPublicationDateST write SetPublicationDateST;
    // The date (and optionally time) when the contract was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the contract changes.
    property publicationDateElement : TFhirDateTime read FPublicationDate write SetPublicationDate;

    // amended | appended | cancelled | disputed | entered-in-error | executable | executed | negotiable | offered | policy | rejected | renewed | revoked | resolved | terminated.
    property publicationStatus : TFhirContractResourcePublicationStatusCodesEnum read GetPublicationStatusST write SetPublicationStatusST;
    property publicationStatusElement : TFhirEnum read FPublicationStatus write SetPublicationStatus;

    // Typed access to A copyright statement relating to Contract precursor content. Copyright statements are generally legal restrictions on the use and publishing of the Contract precursor content.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to Contract precursor content. Copyright statements are generally legal restrictions on the use and publishing of the Contract precursor content.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

  end;

  TFhirContractContentDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractContentDefinitionList;
    function GetCurrent : TFhirContractContentDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractContentDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractContentDefinition read GetCurrent;
  end;

  TFhirContractContentDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractContentDefinition;
    procedure SetItemN(index : Integer; value : TFhirContractContentDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractContentDefinitionList; overload;
    function Clone : TFhirContractContentDefinitionList; overload;
    function GetEnumerator : TFhirContractContentDefinitionListEnumerator;
    
    //  Add a FhirContractContentDefinition to the end of the list.
    function Append : TFhirContractContentDefinition;
    
    // Add an already existing FhirContractContentDefinition to the end of the list.
    function AddItem(value : TFhirContractContentDefinition) : TFhirContractContentDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractContentDefinition) : Integer;
    
    // Insert FhirContractContentDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractContentDefinition;
    
    // Insert an existing FhirContractContentDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractContentDefinition);
    
    // Get the iIndexth FhirContractContentDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractContentDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractContentDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractContentDefinitions[index : Integer] : TFhirContractContentDefinition read GetItemN write SetItemN; default;
  End;

  // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
  TFhirContractTerm = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirIdentifier;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FTopic : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    FSubType : TFhirCodeableConcept;
    FText : TFhirString;
    FsecurityLabelList : TFhirContractTermSecurityLabelList;
    FOffer : TFhirContractTermOffer;
    FassetList : TFhirContractTermAssetList;
    FactionList : TFhirContractTermActionList;
    FgroupList : TFhirContractTermList;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetIssued(value : TFhirDateTime);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    procedure SetApplies(value : TFhirPeriod);
    procedure SetTopic(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetSubType(value : TFhirCodeableConcept);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    function GetSecurityLabelList : TFhirContractTermSecurityLabelList;
    function GetHasSecurityLabelList : Boolean;
    procedure SetOffer(value : TFhirContractTermOffer);
    function GetAssetList : TFhirContractTermAssetList;
    function GetHasAssetList : Boolean;
    function GetActionList : TFhirContractTermActionList;
    function GetHasActionList : Boolean;
    function GetGroupList : TFhirContractTermList;
    function GetHasGroupList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTerm; overload;
    function Clone : TFhirContractTerm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Unique identifier for this particular Contract Provision. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Unique identifier for this particular Contract Provision.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to When this Contract Provision was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this Contract Provision was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract Provision is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract Provision is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // Typed access to The entity that the term applies to. (defined for API consistency)
    property topic : TFhirDataType read FTopic write SetTopic;
    // The entity that the term applies to.
    property topicElement : TFhirDataType read FTopic write SetTopic;

    // Typed access to A legal clause or condition contained within a contract that requires one or both parties to perform a particular requirement by some specified time or prevents one or both parties from performing a particular requirement by some specified time. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A legal clause or condition contained within a contract that requires one or both parties to perform a particular requirement by some specified time or prevents one or both parties from performing a particular requirement by some specified time.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A specialized legal clause or condition based on overarching contract type. (defined for API consistency)
    property subType : TFhirCodeableConcept read FSubType write SetSubType;
    // A specialized legal clause or condition based on overarching contract type.
    property subTypeElement : TFhirCodeableConcept read FSubType write SetSubType;

    // Typed access to Statement of a provision in a policy or a contract.
    property text : String read GetTextST write SetTextST;
    // Statement of a provision in a policy or a contract.
    property textElement : TFhirString read FText write SetText;

    // Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
    property securityLabelList : TFhirContractTermSecurityLabelList read GetSecurityLabelList;
    property hasSecurityLabelList : boolean read GetHasSecurityLabelList;

    // Typed access to The matter of concern in the context of this provision of the agrement. (defined for API consistency)
    property offer : TFhirContractTermOffer read FOffer write SetOffer;
    // The matter of concern in the context of this provision of the agrement.
    property offerElement : TFhirContractTermOffer read FOffer write SetOffer;

    // Contract Term Asset List.
    property assetList : TFhirContractTermAssetList read GetAssetList;
    property hasAssetList : boolean read GetHasAssetList;

    // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
    property actionList : TFhirContractTermActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

    // Nested group of Contract Provisions.
    property groupList : TFhirContractTermList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

  end;

  TFhirContractTermListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermList;
    function GetCurrent : TFhirContractTerm;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTerm read GetCurrent;
  end;

  TFhirContractTermList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTerm;
    procedure SetItemN(index : Integer; value : TFhirContractTerm);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermList; overload;
    function Clone : TFhirContractTermList; overload;
    function GetEnumerator : TFhirContractTermListEnumerator;
    
    //  Add a FhirContractTerm to the end of the list.
    function Append : TFhirContractTerm;
    
    // Add an already existing FhirContractTerm to the end of the list.
    function AddItem(value : TFhirContractTerm) : TFhirContractTerm; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTerm) : Integer;
    
    // Insert FhirContractTerm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTerm;
    
    // Insert an existing FhirContractTerm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTerm);
    
    // Get the iIndexth FhirContractTerm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTerm);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTerm;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTerms[index : Integer] : TFhirContractTerm read GetItemN write SetItemN; default;
  End;

  // Security labels that protect the handling of information about the term and its elements, which may be specifically identified..
  TFhirContractTermSecurityLabel = class (TFhirBackboneElement)
  protected
    FnumberList : TFhirUnsignedIntList;
    FClassification : TFhirCoding;
    FcategoryList : TFhirCodingList;
    FcontrolList : TFhirCodingList;
    function GetNumberList : TFhirUnsignedIntList;
    function GetHasNumberList : Boolean;
    procedure SetClassification(value : TFhirCoding);
    function GetCategoryList : TFhirCodingList;
    function GetHasCategoryList : Boolean;
    function GetControlList : TFhirCodingList;
    function GetHasControlList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermSecurityLabel; overload;
    function Clone : TFhirContractTermSecurityLabel; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Number used to link this term or term element to the applicable Security Label.
    property numberList : TFhirUnsignedIntList read GetNumberList;
    property hasNumberList : boolean read GetHasNumberList;

    // Typed access to Security label privacy tag that species the level of confidentiality protection required for this term and/or term elements. (defined for API consistency)
    property classification : TFhirCoding read FClassification write SetClassification;
    // Security label privacy tag that species the level of confidentiality protection required for this term and/or term elements.
    property classificationElement : TFhirCoding read FClassification write SetClassification;

    // Security label privacy tag that species the applicable privacy and security policies governing this term and/or term elements.
    property categoryList : TFhirCodingList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // Security label privacy tag that species the manner in which term and/or term elements are to be protected.
    property controlList : TFhirCodingList read GetControlList;
    property hasControlList : boolean read GetHasControlList;

  end;

  TFhirContractTermSecurityLabelListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermSecurityLabelList;
    function GetCurrent : TFhirContractTermSecurityLabel;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermSecurityLabelList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermSecurityLabel read GetCurrent;
  end;

  TFhirContractTermSecurityLabelList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermSecurityLabel;
    procedure SetItemN(index : Integer; value : TFhirContractTermSecurityLabel);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermSecurityLabelList; overload;
    function Clone : TFhirContractTermSecurityLabelList; overload;
    function GetEnumerator : TFhirContractTermSecurityLabelListEnumerator;
    
    //  Add a FhirContractTermSecurityLabel to the end of the list.
    function Append : TFhirContractTermSecurityLabel;
    
    // Add an already existing FhirContractTermSecurityLabel to the end of the list.
    function AddItem(value : TFhirContractTermSecurityLabel) : TFhirContractTermSecurityLabel; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermSecurityLabel) : Integer;
    
    // Insert FhirContractTermSecurityLabel before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermSecurityLabel;
    
    // Insert an existing FhirContractTermSecurityLabel before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermSecurityLabel);
    
    // Get the iIndexth FhirContractTermSecurityLabel. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermSecurityLabel);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermSecurityLabel;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermSecurityLabels[index : Integer] : TFhirContractTermSecurityLabel read GetItemN write SetItemN; default;
  End;

  // The matter of concern in the context of this provision of the agrement.
  TFhirContractTermOffer = class (TFhirBackboneElement)
  protected
    FidentifierList : TFhirIdentifierList;
    FpartyList : TFhirContractTermOfferPartyList;
    FTopic : TFhirReference;
    FType_ : TFhirCodeableConcept;
    FDecision : TFhirCodeableConcept;
    FdecisionModeList : TFhirCodeableConceptList;
    FanswerList : TFhirContractTermOfferAnswerList;
    FText : TFhirString;
    FlinkIdList : TFhirStringList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetPartyList : TFhirContractTermOfferPartyList;
    function GetHasPartyList : Boolean;
    procedure SetTopic(value : TFhirReference);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDecision(value : TFhirCodeableConcept);
    function GetDecisionModeList : TFhirCodeableConceptList;
    function GetHasDecisionModeList : Boolean;
    function GetAnswerList : TFhirContractTermOfferAnswerList;
    function GetHasAnswerList : Boolean;
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermOffer; overload;
    function Clone : TFhirContractTermOffer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier for this particular Contract Provision.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Offer Recipient.
    property partyList : TFhirContractTermOfferPartyList read GetPartyList;
    property hasPartyList : boolean read GetHasPartyList;

    // Typed access to The owner of an asset has the residual control rights over the asset: the right to decide all usages of the asset in any way not inconsistent with a prior contract, custom, or law (Hart, 1995, p. 30). (defined for API consistency)
    property topic : TFhirReference read FTopic write SetTopic;
    // The owner of an asset has the residual control rights over the asset: the right to decide all usages of the asset in any way not inconsistent with a prior contract, custom, or law (Hart, 1995, p. 30).
    property topicElement : TFhirReference read FTopic write SetTopic;

    // Typed access to Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Type of Contract Provision such as specific requirements, purposes for actions, obligations, prohibitions, e.g. life time maximum benefit.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Type of choice made by accepting party with respect to an offer made by an offeror/ grantee. (defined for API consistency)
    property decision : TFhirCodeableConcept read FDecision write SetDecision;
    // Type of choice made by accepting party with respect to an offer made by an offeror/ grantee.
    property decisionElement : TFhirCodeableConcept read FDecision write SetDecision;

    // How the decision about a Contract was conveyed.
    property decisionModeList : TFhirCodeableConceptList read GetDecisionModeList;
    property hasDecisionModeList : boolean read GetHasDecisionModeList;

    // Response to offer text.
    property answerList : TFhirContractTermOfferAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

    // Typed access to Human readable form of this Contract Offer.
    property text : String read GetTextST write SetTextST;
    // Human readable form of this Contract Offer.
    property textElement : TFhirString read FText write SetText;

    // The id of the clause or question text of the offer in the referenced questionnaire/response.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // Security labels that protects the offer.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

  end;

  TFhirContractTermOfferListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermOfferList;
    function GetCurrent : TFhirContractTermOffer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermOfferList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermOffer read GetCurrent;
  end;

  TFhirContractTermOfferList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermOffer;
    procedure SetItemN(index : Integer; value : TFhirContractTermOffer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermOfferList; overload;
    function Clone : TFhirContractTermOfferList; overload;
    function GetEnumerator : TFhirContractTermOfferListEnumerator;
    
    //  Add a FhirContractTermOffer to the end of the list.
    function Append : TFhirContractTermOffer;
    
    // Add an already existing FhirContractTermOffer to the end of the list.
    function AddItem(value : TFhirContractTermOffer) : TFhirContractTermOffer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermOffer) : Integer;
    
    // Insert FhirContractTermOffer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermOffer;
    
    // Insert an existing FhirContractTermOffer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermOffer);
    
    // Get the iIndexth FhirContractTermOffer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermOffer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermOffer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermOffers[index : Integer] : TFhirContractTermOffer read GetItemN write SetItemN; default;
  End;

  // Offer Recipient.
  TFhirContractTermOfferParty = class (TFhirBackboneElement)
  protected
    FreferenceList : TFhirReferenceList;
    FRole : TFhirCodeableConcept;
    function GetReferenceList : TFhirReferenceList;
    function GetHasReferenceList : Boolean;
    procedure SetRole(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermOfferParty; overload;
    function Clone : TFhirContractTermOfferParty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Participant in the offer.
    property referenceList : TFhirReferenceList read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

    // Typed access to How the party participates in the offer. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // How the party participates in the offer.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirContractTermOfferPartyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermOfferPartyList;
    function GetCurrent : TFhirContractTermOfferParty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermOfferPartyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermOfferParty read GetCurrent;
  end;

  TFhirContractTermOfferPartyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermOfferParty;
    procedure SetItemN(index : Integer; value : TFhirContractTermOfferParty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermOfferPartyList; overload;
    function Clone : TFhirContractTermOfferPartyList; overload;
    function GetEnumerator : TFhirContractTermOfferPartyListEnumerator;
    
    //  Add a FhirContractTermOfferParty to the end of the list.
    function Append : TFhirContractTermOfferParty;
    
    // Add an already existing FhirContractTermOfferParty to the end of the list.
    function AddItem(value : TFhirContractTermOfferParty) : TFhirContractTermOfferParty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermOfferParty) : Integer;
    
    // Insert FhirContractTermOfferParty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermOfferParty;
    
    // Insert an existing FhirContractTermOfferParty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermOfferParty);
    
    // Get the iIndexth FhirContractTermOfferParty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermOfferParty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermOfferParty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermOfferParties[index : Integer] : TFhirContractTermOfferParty read GetItemN write SetItemN; default;
  End;

  // Response to offer text.
  TFhirContractTermOfferAnswer = class (TFhirBackboneElement)
  protected
    FValue : TFhirDataType;
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermOfferAnswer; overload;
    function Clone : TFhirContractTermOfferAnswer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Response to an offer clause or question text,  which enables selection of values to be agreed to, e.g., the period of participation, the date of occupancy of a rental, warrently duration, or whether biospecimen may be used for further research.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirContractTermOfferAnswerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermOfferAnswerList;
    function GetCurrent : TFhirContractTermOfferAnswer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermOfferAnswerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermOfferAnswer read GetCurrent;
  end;

  TFhirContractTermOfferAnswerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermOfferAnswer;
    procedure SetItemN(index : Integer; value : TFhirContractTermOfferAnswer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermOfferAnswerList; overload;
    function Clone : TFhirContractTermOfferAnswerList; overload;
    function GetEnumerator : TFhirContractTermOfferAnswerListEnumerator;
    
    //  Add a FhirContractTermOfferAnswer to the end of the list.
    function Append : TFhirContractTermOfferAnswer;
    
    // Add an already existing FhirContractTermOfferAnswer to the end of the list.
    function AddItem(value : TFhirContractTermOfferAnswer) : TFhirContractTermOfferAnswer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermOfferAnswer) : Integer;
    
    // Insert FhirContractTermOfferAnswer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermOfferAnswer;
    
    // Insert an existing FhirContractTermOfferAnswer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermOfferAnswer);
    
    // Get the iIndexth FhirContractTermOfferAnswer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermOfferAnswer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermOfferAnswer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermOfferAnswers[index : Integer] : TFhirContractTermOfferAnswer read GetItemN write SetItemN; default;
  End;

  // Contract Term Asset List.
  TFhirContractTermAsset = class (TFhirBackboneElement)
  protected
    FScope : TFhirCodeableConcept;
    Ftype_List : TFhirCodeableConceptList;
    FtypeReferenceList : TFhirReferenceList;
    FsubtypeList : TFhirCodeableConceptList;
    FRelationship : TFhirCoding;
    FcontextList : TFhirContractTermAssetContextList;
    FCondition : TFhirString;
    FperiodTypeList : TFhirCodeableConceptList;
    FperiodList : TFhirPeriodList;
    FusePeriodList : TFhirPeriodList;
    FText : TFhirString;
    FlinkIdList : TFhirStringList;
    FanswerList : TFhirContractTermOfferAnswerList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    FvaluedItemList : TFhirContractTermAssetValuedItemList;
    procedure SetScope(value : TFhirCodeableConcept);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetTypeReferenceList : TFhirReferenceList;
    function GetHasTypeReferenceList : Boolean;
    function GetSubtypeList : TFhirCodeableConceptList;
    function GetHasSubtypeList : Boolean;
    procedure SetRelationship(value : TFhirCoding);
    function GetContextList : TFhirContractTermAssetContextList;
    function GetHasContextList : Boolean;
    procedure SetCondition(value : TFhirString);
    function GetConditionST : String;
    procedure SetConditionST(value : String);
    function GetPeriodTypeList : TFhirCodeableConceptList;
    function GetHasPeriodTypeList : Boolean;
    function GetPeriodList : TFhirPeriodList;
    function GetHasPeriodList : Boolean;
    function GetUsePeriodList : TFhirPeriodList;
    function GetHasUsePeriodList : Boolean;
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    function GetAnswerList : TFhirContractTermOfferAnswerList;
    function GetHasAnswerList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
    function GetValuedItemList : TFhirContractTermAssetValuedItemList;
    function GetHasValuedItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAsset; overload;
    function Clone : TFhirContractTermAsset; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Differentiates the kind of the asset . (defined for API consistency)
    property scope : TFhirCodeableConcept read FScope write SetScope;
    // Differentiates the kind of the asset .
    property scopeElement : TFhirCodeableConcept read FScope write SetScope;

    // Target entity type about which the term may be concerned.
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Associated entities.
    property typeReferenceList : TFhirReferenceList read GetTypeReferenceList;
    property hasTypeReferenceList : boolean read GetHasTypeReferenceList;

    // May be a subtype or part of an offered asset.
    property subtypeList : TFhirCodeableConceptList read GetSubtypeList;
    property hasSubtypeList : boolean read GetHasSubtypeList;

    // Typed access to Specifies the applicability of the term to an asset resource instance, and instances it refers to orinstances that refer to it, and/or are owned by the offeree. (defined for API consistency)
    property relationship : TFhirCoding read FRelationship write SetRelationship;
    // Specifies the applicability of the term to an asset resource instance, and instances it refers to orinstances that refer to it, and/or are owned by the offeree.
    property relationshipElement : TFhirCoding read FRelationship write SetRelationship;

    // Circumstance of the asset.
    property contextList : TFhirContractTermAssetContextList read GetContextList;
    property hasContextList : boolean read GetHasContextList;

    // Typed access to Description of the quality and completeness of the asset that imay be a factor in its valuation.
    property condition : String read GetConditionST write SetConditionST;
    // Description of the quality and completeness of the asset that imay be a factor in its valuation.
    property conditionElement : TFhirString read FCondition write SetCondition;

    // Type of Asset availability for use or ownership.
    property periodTypeList : TFhirCodeableConceptList read GetPeriodTypeList;
    property hasPeriodTypeList : boolean read GetHasPeriodTypeList;

    // Asset relevant contractual time period.
    property periodList : TFhirPeriodList read GetPeriodList;
    property hasPeriodList : boolean read GetHasPeriodList;

    // Time period of asset use.
    property usePeriodList : TFhirPeriodList read GetUsePeriodList;
    property hasUsePeriodList : boolean read GetHasUsePeriodList;

    // Typed access to Clause or question text (Prose Object) concerning the asset in a linked form, such as a QuestionnaireResponse used in the formation of the contract.
    property text : String read GetTextST write SetTextST;
    // Clause or question text (Prose Object) concerning the asset in a linked form, such as a QuestionnaireResponse used in the formation of the contract.
    property textElement : TFhirString read FText write SetText;

    // Id [identifier??] of the clause or question text about the asset in the referenced form or QuestionnaireResponse.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // Response to assets.
    property answerList : TFhirContractTermOfferAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

    // Security labels that protects the asset.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

    // Contract Valued Item List.
    property valuedItemList : TFhirContractTermAssetValuedItemList read GetValuedItemList;
    property hasValuedItemList : boolean read GetHasValuedItemList;

  end;

  TFhirContractTermAssetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAssetList;
    function GetCurrent : TFhirContractTermAsset;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAssetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAsset read GetCurrent;
  end;

  TFhirContractTermAssetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermAsset;
    procedure SetItemN(index : Integer; value : TFhirContractTermAsset);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermAssetList; overload;
    function Clone : TFhirContractTermAssetList; overload;
    function GetEnumerator : TFhirContractTermAssetListEnumerator;
    
    //  Add a FhirContractTermAsset to the end of the list.
    function Append : TFhirContractTermAsset;
    
    // Add an already existing FhirContractTermAsset to the end of the list.
    function AddItem(value : TFhirContractTermAsset) : TFhirContractTermAsset; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAsset) : Integer;
    
    // Insert FhirContractTermAsset before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAsset;
    
    // Insert an existing FhirContractTermAsset before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAsset);
    
    // Get the iIndexth FhirContractTermAsset. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAsset);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAsset;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermAssets[index : Integer] : TFhirContractTermAsset read GetItemN write SetItemN; default;
  End;

  // Circumstance of the asset.
  TFhirContractTermAssetContext = class (TFhirBackboneElement)
  protected
    FReference : TFhirReference;
    FcodeList : TFhirCodeableConceptList;
    FText : TFhirString;
    procedure SetReference(value : TFhirReference);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAssetContext; overload;
    function Clone : TFhirContractTermAssetContext; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Asset context reference may include the creator, custodian, or owning Person or Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction. (defined for API consistency)
    property reference : TFhirReference read FReference write SetReference;
    // Asset context reference may include the creator, custodian, or owning Person or Organization (e.g., bank, repository),  location held, e.g., building,  jurisdiction.
    property referenceElement : TFhirReference read FReference write SetReference;

    // Coded representation of the context generally or of the Referenced entity, such as the asset holder type or location.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Typed access to Context description.
    property text : String read GetTextST write SetTextST;
    // Context description.
    property textElement : TFhirString read FText write SetText;

  end;

  TFhirContractTermAssetContextListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAssetContextList;
    function GetCurrent : TFhirContractTermAssetContext;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAssetContextList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAssetContext read GetCurrent;
  end;

  TFhirContractTermAssetContextList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermAssetContext;
    procedure SetItemN(index : Integer; value : TFhirContractTermAssetContext);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermAssetContextList; overload;
    function Clone : TFhirContractTermAssetContextList; overload;
    function GetEnumerator : TFhirContractTermAssetContextListEnumerator;
    
    //  Add a FhirContractTermAssetContext to the end of the list.
    function Append : TFhirContractTermAssetContext;
    
    // Add an already existing FhirContractTermAssetContext to the end of the list.
    function AddItem(value : TFhirContractTermAssetContext) : TFhirContractTermAssetContext; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAssetContext) : Integer;
    
    // Insert FhirContractTermAssetContext before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAssetContext;
    
    // Insert an existing FhirContractTermAssetContext before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAssetContext);
    
    // Get the iIndexth FhirContractTermAssetContext. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAssetContext);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAssetContext;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermAssetContexts[index : Integer] : TFhirContractTermAssetContext read GetItemN write SetItemN; default;
  End;

  // Contract Valued Item List.
  TFhirContractTermAssetValuedItem = class (TFhirBackboneElement)
  protected
    FEntity : TFhirDataType;
    FIdentifier : TFhirIdentifier;
    FEffectiveTime : TFhirDateTime;
    FQuantity : TFhirQuantity;
    FUnitPrice : TFhirMoney;
    FFactor : TFhirDecimal;
    FPoints : TFhirDecimal;
    FNet : TFhirMoney;
    FPayment : TFhirString;
    FPaymentDate : TFhirDateTime;
    FResponsible : TFhirReference;
    FRecipient : TFhirReference;
    FlinkIdList : TFhirStringList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    procedure SetEntity(value : TFhirDataType);
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetEffectiveTime(value : TFhirDateTime);
    function GetEffectiveTimeST : TFslDateTime;
    procedure SetEffectiveTimeST(value : TFslDateTime);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetUnitPrice(value : TFhirMoney);
    procedure SetFactor(value : TFhirDecimal);
    function GetFactorST : String;
    procedure SetFactorST(value : String);
    procedure SetPoints(value : TFhirDecimal);
    function GetPointsST : String;
    procedure SetPointsST(value : String);
    procedure SetNet(value : TFhirMoney);
    procedure SetPayment(value : TFhirString);
    function GetPaymentST : String;
    procedure SetPaymentST(value : String);
    procedure SetPaymentDate(value : TFhirDateTime);
    function GetPaymentDateST : TFslDateTime;
    procedure SetPaymentDateST(value : TFslDateTime);
    procedure SetResponsible(value : TFhirReference);
    procedure SetRecipient(value : TFhirReference);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAssetValuedItem; overload;
    function Clone : TFhirContractTermAssetValuedItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Specific type of Contract Valued Item that may be priced. (defined for API consistency)
    property entity : TFhirDataType read FEntity write SetEntity;
    // Specific type of Contract Valued Item that may be priced.
    property entityElement : TFhirDataType read FEntity write SetEntity;

    // Typed access to Identifies a Contract Valued Item instance. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifies a Contract Valued Item instance.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTime : TFslDateTime read GetEffectiveTimeST write SetEffectiveTimeST;
    // Indicates the time during which this Contract ValuedItem information is effective.
    property effectiveTimeElement : TFhirDateTime read FEffectiveTime write SetEffectiveTime;

    // Typed access to Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Specifies the units by which the Contract Valued Item is measured or counted, and quantifies the countable or measurable Contract Valued Item instances.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to A Contract Valued Item unit valuation measure. (defined for API consistency)
    property unitPrice : TFhirMoney read FUnitPrice write SetUnitPrice;
    // A Contract Valued Item unit valuation measure.
    property unitPriceElement : TFhirMoney read FUnitPrice write SetUnitPrice;

    // Typed access to A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factor : String read GetFactorST write SetFactorST;
    // A real number that represents a multiplier used in determining the overall value of the Contract Valued Item delivered. The concept of a Factor allows for a discount or surcharge multiplier to be applied to a monetary amount.
    property factorElement : TFhirDecimal read FFactor write SetFactor;

    // Typed access to An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property points : String read GetPointsST write SetPointsST;
    // An amount that expresses the weighting (based on difficulty, cost and/or resource intensiveness) associated with the Contract Valued Item delivered. The concept of Points allows for assignment of point values for a Contract Valued Item, such that a monetary amount can be assigned to each point.
    property pointsElement : TFhirDecimal read FPoints write SetPoints;

    // Typed access to Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied. (defined for API consistency)
    property net : TFhirMoney read FNet write SetNet;
    // Expresses the product of the Contract Valued Item unitQuantity and the unitPriceAmt. For example, the formula: unit Quantity * unit Price (Cost per Point) * factor Number  * points = net Amount. Quantity, factor and points are assumed to be 1 if not supplied.
    property netElement : TFhirMoney read FNet write SetNet;

    // Typed access to Terms of valuation.
    property payment : String read GetPaymentST write SetPaymentST;
    // Terms of valuation.
    property paymentElement : TFhirString read FPayment write SetPayment;

    // Typed access to When payment is due.
    property paymentDate : TFslDateTime read GetPaymentDateST write SetPaymentDateST;
    // When payment is due.
    property paymentDateElement : TFhirDateTime read FPaymentDate write SetPaymentDate;

    // Typed access to Who will make payment. (defined for API consistency)
    property responsible : TFhirReference read FResponsible write SetResponsible;
    // Who will make payment.
    property responsibleElement : TFhirReference read FResponsible write SetResponsible;

    // Typed access to Who will receive payment. (defined for API consistency)
    property recipient : TFhirReference read FRecipient write SetRecipient;
    // Who will receive payment.
    property recipientElement : TFhirReference read FRecipient write SetRecipient;

    // Id  of the clause or question text related to the context of this valuedItem in the referenced form or QuestionnaireResponse.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // A set of security labels that define which terms are controlled by this condition.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

  end;

  TFhirContractTermAssetValuedItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermAssetValuedItemList;
    function GetCurrent : TFhirContractTermAssetValuedItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermAssetValuedItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAssetValuedItem read GetCurrent;
  end;

  TFhirContractTermAssetValuedItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermAssetValuedItem;
    procedure SetItemN(index : Integer; value : TFhirContractTermAssetValuedItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermAssetValuedItemList; overload;
    function Clone : TFhirContractTermAssetValuedItemList; overload;
    function GetEnumerator : TFhirContractTermAssetValuedItemListEnumerator;
    
    //  Add a FhirContractTermAssetValuedItem to the end of the list.
    function Append : TFhirContractTermAssetValuedItem;
    
    // Add an already existing FhirContractTermAssetValuedItem to the end of the list.
    function AddItem(value : TFhirContractTermAssetValuedItem) : TFhirContractTermAssetValuedItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAssetValuedItem) : Integer;
    
    // Insert FhirContractTermAssetValuedItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAssetValuedItem;
    
    // Insert an existing FhirContractTermAssetValuedItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAssetValuedItem);
    
    // Get the iIndexth FhirContractTermAssetValuedItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAssetValuedItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAssetValuedItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermAssetValuedItems[index : Integer] : TFhirContractTermAssetValuedItem read GetItemN write SetItemN; default;
  End;

  // An actor taking a role in an activity for which it can be assigned some degree of responsibility for the activity taking place.
  TFhirContractTermAction = class (TFhirBackboneElement)
  protected
    FDoNotPerform : TFhirBoolean;
    FType_ : TFhirCodeableConcept;
    FsubjectList : TFhirContractTermActionSubjectList;
    FIntent : TFhirCodeableConcept;
    FlinkIdList : TFhirStringList;
    FStatus : TFhirCodeableConcept;
    FContext : TFhirReference;
    FcontextLinkIdList : TFhirStringList;
    FOccurrence : TFhirDataType;
    FrequesterList : TFhirReferenceList;
    FrequesterLinkIdList : TFhirStringList;
    FperformerTypeList : TFhirCodeableConceptList;
    FPerformerRole : TFhirCodeableConcept;
    FPerformer : TFhirReference;
    FperformerLinkIdList : TFhirStringList;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FreasonList : TFhirStringList;
    FreasonLinkIdList : TFhirStringList;
    FnoteList : TFhirAnnotationList;
    FsecurityLabelNumberList : TFhirUnsignedIntList;
    procedure SetDoNotPerform(value : TFhirBoolean);
    function GetDoNotPerformST : Boolean;
    procedure SetDoNotPerformST(value : Boolean);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetSubjectList : TFhirContractTermActionSubjectList;
    function GetHasSubjectList : Boolean;
    procedure SetIntent(value : TFhirCodeableConcept);
    function GetLinkIdList : TFhirStringList;
    function GetHasLinkIdList : Boolean;
    procedure SetStatus(value : TFhirCodeableConcept);
    procedure SetContext(value : TFhirReference);
    function GetContextLinkIdList : TFhirStringList;
    function GetHasContextLinkIdList : Boolean;
    procedure SetOccurrence(value : TFhirDataType);
    function GetRequesterList : TFhirReferenceList;
    function GetHasRequesterList : Boolean;
    function GetRequesterLinkIdList : TFhirStringList;
    function GetHasRequesterLinkIdList : Boolean;
    function GetPerformerTypeList : TFhirCodeableConceptList;
    function GetHasPerformerTypeList : Boolean;
    procedure SetPerformerRole(value : TFhirCodeableConcept);
    procedure SetPerformer(value : TFhirReference);
    function GetPerformerLinkIdList : TFhirStringList;
    function GetHasPerformerLinkIdList : Boolean;
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetReasonList : TFhirStringList;
    function GetHasReasonList : Boolean;
    function GetReasonLinkIdList : TFhirStringList;
    function GetHasReasonLinkIdList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetSecurityLabelNumberList : TFhirUnsignedIntList;
    function GetHasSecurityLabelNumberList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermAction; overload;
    function Clone : TFhirContractTermAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to True if the term prohibits the  action.
    property doNotPerform : Boolean read GetDoNotPerformST write SetDoNotPerformST;
    // True if the term prohibits the  action.
    property doNotPerformElement : TFhirBoolean read FDoNotPerform write SetDoNotPerform;

    // Typed access to Activity or service obligation to be done or not done, performed or not performed, effectuated or not by this Contract term. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Activity or service obligation to be done or not done, performed or not performed, effectuated or not by this Contract term.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Entity of the action.
    property subjectList : TFhirContractTermActionSubjectList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // Typed access to Reason or purpose for the action stipulated by this Contract Provision. (defined for API consistency)
    property intent : TFhirCodeableConcept read FIntent write SetIntent;
    // Reason or purpose for the action stipulated by this Contract Provision.
    property intentElement : TFhirCodeableConcept read FIntent write SetIntent;

    // Id [identifier??] of the clause or question text related to this action in the referenced form or QuestionnaireResponse.
    property linkIdList : TFhirStringList read GetLinkIdList;
    property hasLinkIdList : boolean read GetHasLinkIdList;

    // Typed access to Current state of the term action. (defined for API consistency)
    property status : TFhirCodeableConcept read FStatus write SetStatus;
    // Current state of the term action.
    property statusElement : TFhirCodeableConcept read FStatus write SetStatus;

    // Typed access to Encounter or Episode with primary association to specified term activity. (defined for API consistency)
    property context : TFhirReference read FContext write SetContext;
    // Encounter or Episode with primary association to specified term activity.
    property contextElement : TFhirReference read FContext write SetContext;

    // Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
    property contextLinkIdList : TFhirStringList read GetContextLinkIdList;
    property hasContextLinkIdList : boolean read GetHasContextLinkIdList;

    // Typed access to When action happens. (defined for API consistency)
    property occurrence : TFhirDataType read FOccurrence write SetOccurrence;
    // When action happens.
    property occurrenceElement : TFhirDataType read FOccurrence write SetOccurrence;

    // Who or what initiated the action and has responsibility for its activation.
    property requesterList : TFhirReferenceList read GetRequesterList;
    property hasRequesterList : boolean read GetHasRequesterList;

    // Id [identifier??] of the clause or question text related to the requester of this action in the referenced form or QuestionnaireResponse.
    property requesterLinkIdList : TFhirStringList read GetRequesterLinkIdList;
    property hasRequesterLinkIdList : boolean read GetHasRequesterLinkIdList;

    // The type of individual that is desired or required to perform or not perform the action.
    property performerTypeList : TFhirCodeableConceptList read GetPerformerTypeList;
    property hasPerformerTypeList : boolean read GetHasPerformerTypeList;

    // Typed access to The type of role or competency of an individual desired or required to perform or not perform the action. (defined for API consistency)
    property performerRole : TFhirCodeableConcept read FPerformerRole write SetPerformerRole;
    // The type of role or competency of an individual desired or required to perform or not perform the action.
    property performerRoleElement : TFhirCodeableConcept read FPerformerRole write SetPerformerRole;

    // Typed access to Indicates who or what is being asked to perform (or not perform) the ction. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // Indicates who or what is being asked to perform (or not perform) the ction.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
    property performerLinkIdList : TFhirStringList read GetPerformerLinkIdList;
    property hasPerformerLinkIdList : boolean read GetHasPerformerLinkIdList;

    // Rationale for the action to be performed or not performed. Describes why the action is permitted or prohibited.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies permitting or not permitting this action.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Describes why the action is to be performed or not performed in textual form.
    property reasonList : TFhirStringList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Id [identifier??] of the clause or question text related to the reason type or reference of this  action in the referenced form or QuestionnaireResponse.
    property reasonLinkIdList : TFhirStringList read GetReasonLinkIdList;
    property hasReasonLinkIdList : boolean read GetHasReasonLinkIdList;

    // Comments made about the term action made by the requester, performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Security labels that protects the action.
    property securityLabelNumberList : TFhirUnsignedIntList read GetSecurityLabelNumberList;
    property hasSecurityLabelNumberList : boolean read GetHasSecurityLabelNumberList;

  end;

  TFhirContractTermActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermActionList;
    function GetCurrent : TFhirContractTermAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermAction read GetCurrent;
  end;

  TFhirContractTermActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermAction;
    procedure SetItemN(index : Integer; value : TFhirContractTermAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermActionList; overload;
    function Clone : TFhirContractTermActionList; overload;
    function GetEnumerator : TFhirContractTermActionListEnumerator;
    
    //  Add a FhirContractTermAction to the end of the list.
    function Append : TFhirContractTermAction;
    
    // Add an already existing FhirContractTermAction to the end of the list.
    function AddItem(value : TFhirContractTermAction) : TFhirContractTermAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermAction) : Integer;
    
    // Insert FhirContractTermAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermAction;
    
    // Insert an existing FhirContractTermAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermAction);
    
    // Get the iIndexth FhirContractTermAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermActions[index : Integer] : TFhirContractTermAction read GetItemN write SetItemN; default;
  End;

  // Entity of the action.
  TFhirContractTermActionSubject = class (TFhirBackboneElement)
  protected
    FreferenceList : TFhirReferenceList;
    FRole : TFhirCodeableConcept;
    function GetReferenceList : TFhirReferenceList;
    function GetHasReferenceList : Boolean;
    procedure SetRole(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractTermActionSubject; overload;
    function Clone : TFhirContractTermActionSubject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The entity the action is performed or not performed on or for.
    property referenceList : TFhirReferenceList read GetReferenceList;
    property hasReferenceList : boolean read GetHasReferenceList;

    // Typed access to Role type of agent assigned roles in this Contract. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // Role type of agent assigned roles in this Contract.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirContractTermActionSubjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractTermActionSubjectList;
    function GetCurrent : TFhirContractTermActionSubject;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractTermActionSubjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractTermActionSubject read GetCurrent;
  end;

  TFhirContractTermActionSubjectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractTermActionSubject;
    procedure SetItemN(index : Integer; value : TFhirContractTermActionSubject);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractTermActionSubjectList; overload;
    function Clone : TFhirContractTermActionSubjectList; overload;
    function GetEnumerator : TFhirContractTermActionSubjectListEnumerator;
    
    //  Add a FhirContractTermActionSubject to the end of the list.
    function Append : TFhirContractTermActionSubject;
    
    // Add an already existing FhirContractTermActionSubject to the end of the list.
    function AddItem(value : TFhirContractTermActionSubject) : TFhirContractTermActionSubject; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractTermActionSubject) : Integer;
    
    // Insert FhirContractTermActionSubject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractTermActionSubject;
    
    // Insert an existing FhirContractTermActionSubject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractTermActionSubject);
    
    // Get the iIndexth FhirContractTermActionSubject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractTermActionSubject);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractTermActionSubject;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractTermActionSubjects[index : Integer] : TFhirContractTermActionSubject read GetItemN write SetItemN; default;
  End;

  // Parties with legal standing in the Contract, including the principal parties, the grantor(s) and grantee(s), which are any person or organization bound by the contract, and any ancillary parties, which facilitate the execution of the contract such as a notary or witness.
  TFhirContractSigner = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCoding;
    FParty : TFhirReference;
    FsignatureList : TFhirSignatureList;
    procedure SetType_(value : TFhirCoding);
    procedure SetParty(value : TFhirReference);
    function GetSignatureList : TFhirSignatureList;
    function GetHasSignatureList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractSigner; overload;
    function Clone : TFhirContractSigner; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Role of this Contract signer, e.g. notary, grantee. (defined for API consistency)
    property type_ : TFhirCoding read FType_ write SetType_;
    // Role of this Contract signer, e.g. notary, grantee.
    property type_Element : TFhirCoding read FType_ write SetType_;

    // Typed access to Party which is a signator to this Contract. (defined for API consistency)
    property party : TFhirReference read FParty write SetParty;
    // Party which is a signator to this Contract.
    property partyElement : TFhirReference read FParty write SetParty;

    // Legally binding Contract DSIG signature contents in Base64.
    property signatureList : TFhirSignatureList read GetSignatureList;
    property hasSignatureList : boolean read GetHasSignatureList;

  end;

  TFhirContractSignerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractSignerList;
    function GetCurrent : TFhirContractSigner;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractSignerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractSigner read GetCurrent;
  end;

  TFhirContractSignerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractSigner;
    procedure SetItemN(index : Integer; value : TFhirContractSigner);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractSignerList; overload;
    function Clone : TFhirContractSignerList; overload;
    function GetEnumerator : TFhirContractSignerListEnumerator;
    
    //  Add a FhirContractSigner to the end of the list.
    function Append : TFhirContractSigner;
    
    // Add an already existing FhirContractSigner to the end of the list.
    function AddItem(value : TFhirContractSigner) : TFhirContractSigner; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractSigner) : Integer;
    
    // Insert FhirContractSigner before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractSigner;
    
    // Insert an existing FhirContractSigner before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractSigner);
    
    // Get the iIndexth FhirContractSigner. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractSigner);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractSigner;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractSigners[index : Integer] : TFhirContractSigner read GetItemN write SetItemN; default;
  End;

  // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
  TFhirContractFriendly = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractFriendly; overload;
    function Clone : TFhirContractFriendly; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability. (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // Human readable rendering of this Contract in a format and representation intended to enhance comprehension and ensure understandability.
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirContractFriendlyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractFriendlyList;
    function GetCurrent : TFhirContractFriendly;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractFriendlyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractFriendly read GetCurrent;
  end;

  TFhirContractFriendlyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractFriendly;
    procedure SetItemN(index : Integer; value : TFhirContractFriendly);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractFriendlyList; overload;
    function Clone : TFhirContractFriendlyList; overload;
    function GetEnumerator : TFhirContractFriendlyListEnumerator;
    
    //  Add a FhirContractFriendly to the end of the list.
    function Append : TFhirContractFriendly;
    
    // Add an already existing FhirContractFriendly to the end of the list.
    function AddItem(value : TFhirContractFriendly) : TFhirContractFriendly; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractFriendly) : Integer;
    
    // Insert FhirContractFriendly before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractFriendly;
    
    // Insert an existing FhirContractFriendly before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractFriendly);
    
    // Get the iIndexth FhirContractFriendly. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractFriendly);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractFriendly;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractFriendlies[index : Integer] : TFhirContractFriendly read GetItemN write SetItemN; default;
  End;

  // List of Legal expressions or representations of this Contract.
  TFhirContractLegal = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractLegal; overload;
    function Clone : TFhirContractLegal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Contract legal text in human renderable form. (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // Contract legal text in human renderable form.
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirContractLegalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractLegalList;
    function GetCurrent : TFhirContractLegal;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractLegalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractLegal read GetCurrent;
  end;

  TFhirContractLegalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractLegal;
    procedure SetItemN(index : Integer; value : TFhirContractLegal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractLegalList; overload;
    function Clone : TFhirContractLegalList; overload;
    function GetEnumerator : TFhirContractLegalListEnumerator;
    
    //  Add a FhirContractLegal to the end of the list.
    function Append : TFhirContractLegal;
    
    // Add an already existing FhirContractLegal to the end of the list.
    function AddItem(value : TFhirContractLegal) : TFhirContractLegal; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractLegal) : Integer;
    
    // Insert FhirContractLegal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractLegal;
    
    // Insert an existing FhirContractLegal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractLegal);
    
    // Get the iIndexth FhirContractLegal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractLegal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractLegal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractLegals[index : Integer] : TFhirContractLegal read GetItemN write SetItemN; default;
  End;

  // List of Computable Policy Rule Language Representations of this Contract.
  TFhirContractRule = class (TFhirBackboneElement)
  protected
    FContent : TFhirDataType;
    procedure SetContent(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContractRule; overload;
    function Clone : TFhirContractRule; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal). (defined for API consistency)
    property content : TFhirDataType read FContent write SetContent;
    // Computable Contract conveyed using a policy rule language (e.g. XACML, DKAL, SecPal).
    property contentElement : TFhirDataType read FContent write SetContent;

  end;

  TFhirContractRuleListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractRuleList;
    function GetCurrent : TFhirContractRule;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractRuleList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContractRule read GetCurrent;
  end;

  TFhirContractRuleList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContractRule;
    procedure SetItemN(index : Integer; value : TFhirContractRule);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractRuleList; overload;
    function Clone : TFhirContractRuleList; overload;
    function GetEnumerator : TFhirContractRuleListEnumerator;
    
    //  Add a FhirContractRule to the end of the list.
    function Append : TFhirContractRule;
    
    // Add an already existing FhirContractRule to the end of the list.
    function AddItem(value : TFhirContractRule) : TFhirContractRule; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContractRule) : Integer;
    
    // Insert FhirContractRule before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContractRule;
    
    // Insert an existing FhirContractRule before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContractRule);
    
    // Get the iIndexth FhirContractRule. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContractRule);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContractRule;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContractRules[index : Integer] : TFhirContractRule read GetItemN write SetItemN; default;
  End;

  // Legally enforceable, formally recorded unilateral or bilateral directive i.e., a policy or agreement.
  TFhirContract = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FUrl : TFhirUri;
    FVersion : TFhirString;
    FStatus : TFhirEnum;
    FLegalState : TFhirCodeableConcept;
    FInstantiatesCanonical : TFhirReference;
    FInstantiatesUri : TFhirUri;
    FContentDerivative : TFhirCodeableConcept;
    FIssued : TFhirDateTime;
    FApplies : TFhirPeriod;
    FExpirationType : TFhirCodeableConcept;
    FsubjectList : TFhirReferenceList;
    FauthorityList : TFhirReferenceList;
    FdomainList : TFhirReferenceList;
    FsiteList : TFhirReferenceList;
    FName : TFhirString;
    FTitle : TFhirString;
    FSubtitle : TFhirString;
    FaliasList : TFhirStringList;
    FAuthor : TFhirReference;
    FScope : TFhirCodeableConcept;
    FTopic : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    FsubTypeList : TFhirCodeableConceptList;
    FContentDefinition : TFhirContractContentDefinition;
    FtermList : TFhirContractTermList;
    FsupportingInfoList : TFhirReferenceList;
    FrelevantHistoryList : TFhirReferenceList;
    FsignerList : TFhirContractSignerList;
    FfriendlyList : TFhirContractFriendlyList;
    FlegalList : TFhirContractLegalList;
    FruleList : TFhirContractRuleList;
    FLegallyBinding : TFhirDataType;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirContractResourceStatusCodesEnum;
    procedure SetStatusST(value : TFhirContractResourceStatusCodesEnum);
    procedure SetLegalState(value : TFhirCodeableConcept);
    procedure SetInstantiatesCanonical(value : TFhirReference);
    procedure SetInstantiatesUri(value : TFhirUri);
    function GetInstantiatesUriST : String;
    procedure SetInstantiatesUriST(value : String);
    procedure SetContentDerivative(value : TFhirCodeableConcept);
    procedure SetIssued(value : TFhirDateTime);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    procedure SetApplies(value : TFhirPeriod);
    procedure SetExpirationType(value : TFhirCodeableConcept);
    function GetSubjectList : TFhirReferenceList;
    function GetHasSubjectList : Boolean;
    function GetAuthorityList : TFhirReferenceList;
    function GetHasAuthorityList : Boolean;
    function GetDomainList : TFhirReferenceList;
    function GetHasDomainList : Boolean;
    function GetSiteList : TFhirReferenceList;
    function GetHasSiteList : Boolean;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    function GetAliasList : TFhirStringList;
    function GetHasAliasList : Boolean;
    procedure SetAuthor(value : TFhirReference);
    procedure SetScope(value : TFhirCodeableConcept);
    procedure SetTopic(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetSubTypeList : TFhirCodeableConceptList;
    function GetHasSubTypeList : Boolean;
    procedure SetContentDefinition(value : TFhirContractContentDefinition);
    function GetTermList : TFhirContractTermList;
    function GetHasTermList : Boolean;
    function GetSupportingInfoList : TFhirReferenceList;
    function GetHasSupportingInfoList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList;
    function GetHasRelevantHistoryList : Boolean;
    function GetSignerList : TFhirContractSignerList;
    function GetHasSignerList : Boolean;
    function GetFriendlyList : TFhirContractFriendlyList;
    function GetHasFriendlyList : Boolean;
    function GetLegalList : TFhirContractLegalList;
    function GetHasLegalList : Boolean;
    function GetRuleList : TFhirContractRuleList;
    function GetHasRuleList : Boolean;
    procedure SetLegallyBinding(value : TFhirDataType);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirContract; overload;
    function Clone : TFhirContract; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Unique identifier for this Contract or a derivative that references a Source Contract.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to Canonical identifier for this contract, represented as a URI (globally unique).
    property url : String read GetUrlST write SetUrlST;
    // Canonical identifier for this contract, represented as a URI (globally unique).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Typed access to An edition identifier used for business purposes to label business significant variants.
    property version : String read GetVersionST write SetVersionST;
    // An edition identifier used for business purposes to label business significant variants.
    property versionElement : TFhirString read FVersion write SetVersion;

    // The status of the resource instance.
    property status : TFhirContractResourceStatusCodesEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Legal states of the formation of a legal instrument, which is a formally executed written document that can be formally attributed to its author, records and formally expresses a legally enforceable act, process, or contractual duty, obligation, or right, and therefore evidences that act, process, or agreement. (defined for API consistency)
    property legalState : TFhirCodeableConcept read FLegalState write SetLegalState;
    // Legal states of the formation of a legal instrument, which is a formally executed written document that can be formally attributed to its author, records and formally expresses a legally enforceable act, process, or contractual duty, obligation, or right, and therefore evidences that act, process, or agreement.
    property legalStateElement : TFhirCodeableConcept read FLegalState write SetLegalState;

    // Typed access to The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract. (defined for API consistency)
    property instantiatesCanonical : TFhirReference read FInstantiatesCanonical write SetInstantiatesCanonical;
    // The URL pointing to a FHIR-defined Contract Definition that is adhered to in whole or part by this Contract.
    property instantiatesCanonicalElement : TFhirReference read FInstantiatesCanonical write SetInstantiatesCanonical;

    // Typed access to The URL pointing to an externally maintained definition that is adhered to in whole or in part by this Contract.
    property instantiatesUri : String read GetInstantiatesUriST write SetInstantiatesUriST;
    // The URL pointing to an externally maintained definition that is adhered to in whole or in part by this Contract.
    property instantiatesUriElement : TFhirUri read FInstantiatesUri write SetInstantiatesUri;

    // Typed access to The minimal content derived from the basal information source at a specific stage in its lifecycle. (defined for API consistency)
    property contentDerivative : TFhirCodeableConcept read FContentDerivative write SetContentDerivative;
    // The minimal content derived from the basal information source at a specific stage in its lifecycle.
    property contentDerivativeElement : TFhirCodeableConcept read FContentDerivative write SetContentDerivative;

    // Typed access to When this  Contract was issued.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When this  Contract was issued.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // Typed access to Relevant time or time-period when this Contract is applicable. (defined for API consistency)
    property applies : TFhirPeriod read FApplies write SetApplies;
    // Relevant time or time-period when this Contract is applicable.
    property appliesElement : TFhirPeriod read FApplies write SetApplies;

    // Typed access to Event resulting in discontinuation or termination of this Contract instance by one or more parties to the contract. (defined for API consistency)
    property expirationType : TFhirCodeableConcept read FExpirationType write SetExpirationType;
    // Event resulting in discontinuation or termination of this Contract instance by one or more parties to the contract.
    property expirationTypeElement : TFhirCodeableConcept read FExpirationType write SetExpirationType;

    // The target entity impacted by or of interest to parties to the agreement.
    property subjectList : TFhirReferenceList read GetSubjectList;
    property hasSubjectList : boolean read GetHasSubjectList;

    // A formally or informally recognized grouping of people, principals, organizations, or jurisdictions formed for the purpose of achieving some form of collective action such as the promulgation, administration and enforcement of contracts and policies.
    property authorityList : TFhirReferenceList read GetAuthorityList;
    property hasAuthorityList : boolean read GetHasAuthorityList;

    // Recognized governance framework or system operating with a circumscribed scope in accordance with specified principles, policies, processes or procedures for managing rights, actions, or behaviors of parties or principals relative to resources.
    property domainList : TFhirReferenceList read GetDomainList;
    property hasDomainList : boolean read GetHasDomainList;

    // Sites in which the contract is complied with,  exercised, or in force.
    property siteList : TFhirReferenceList read GetSiteList;
    property hasSiteList : boolean read GetHasSiteList;

    // Typed access to A natural language name identifying this Contract definition, derivative, or instance in any legal state. Provides additional information about its content. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying this Contract definition, derivative, or instance in any legal state. Provides additional information about its content. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate user-friendly title for this Contract definition, derivative, or instance in any legal state.t giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // Alternative representation of the title for this Contract definition, derivative, or instance in any legal state., e.g., a domain specific contract number related to legislation.
    property aliasList : TFhirStringList read GetAliasList;
    property hasAliasList : boolean read GetHasAliasList;

    // Typed access to The individual or organization that authored the Contract definition, derivative, or instance in any legal state. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // The individual or organization that authored the Contract definition, derivative, or instance in any legal state.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Typed access to A selector of legal concerns for this Contract definition, derivative, or instance in any legal state. (defined for API consistency)
    property scope : TFhirCodeableConcept read FScope write SetScope;
    // A selector of legal concerns for this Contract definition, derivative, or instance in any legal state.
    property scopeElement : TFhirCodeableConcept read FScope write SetScope;

    // Typed access to Narrows the range of legal concerns to focus on the achievement of specific contractual objectives. (defined for API consistency)
    property topic : TFhirDataType read FTopic write SetTopic;
    // Narrows the range of legal concerns to focus on the achievement of specific contractual objectives.
    property topicElement : TFhirDataType read FTopic write SetTopic;

    // Typed access to A high-level category for the legal instrument, whether constructed as a Contract definition, derivative, or instance in any legal state.  Provides additional information about its content within the context of the Contract's scope to distinguish the kinds of systems that would be interested in the contract. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A high-level category for the legal instrument, whether constructed as a Contract definition, derivative, or instance in any legal state.  Provides additional information about its content within the context of the Contract's scope to distinguish the kinds of systems that would be interested in the contract.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Sub-category for the Contract that distinguishes the kinds of systems that would be interested in the Contract within the context of the Contract's scope.
    property subTypeList : TFhirCodeableConceptList read GetSubTypeList;
    property hasSubTypeList : boolean read GetHasSubTypeList;

    // Typed access to Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract. (defined for API consistency)
    property contentDefinition : TFhirContractContentDefinition read FContentDefinition write SetContentDefinition;
    // Precusory content developed with a focus and intent of supporting the formation a Contract instance, which may be associated with and transformable into a Contract.
    property contentDefinitionElement : TFhirContractContentDefinition read FContentDefinition write SetContentDefinition;

    // One or more Contract Provisions, which may be related and conveyed as a group, and may contain nested groups.
    property termList : TFhirContractTermList read GetTermList;
    property hasTermList : boolean read GetHasTermList;

    // Information that may be needed by/relevant to the performer in their execution of this term action.
    property supportingInfoList : TFhirReferenceList read GetSupportingInfoList;
    property hasSupportingInfoList : boolean read GetHasSupportingInfoList;

    // Links to Provenance records for past versions of this Contract definition, derivative, or instance, which identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the Contract.  The Provence.entity indicates the target that was changed in the update. http://build.fhir.org/provenance-definitions.html#Provenance.entity.
    property relevantHistoryList : TFhirReferenceList read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

    // Parties with legal standing in the Contract, including the principal parties, the grantor(s) and grantee(s), which are any person or organization bound by the contract, and any ancillary parties, which facilitate the execution of the contract such as a notary or witness.
    property signerList : TFhirContractSignerList read GetSignerList;
    property hasSignerList : boolean read GetHasSignerList;

    // The "patient friendly language" versionof the Contract in whole or in parts. "Patient friendly language" means the representation of the Contract and Contract Provisions in a manner that is readily accessible and understandable by a layperson in accordance with best practices for communication styles that ensure that those agreeing to or signing the Contract understand the roles, actions, obligations, responsibilities, and implication of the agreement.
    property friendlyList : TFhirContractFriendlyList read GetFriendlyList;
    property hasFriendlyList : boolean read GetHasFriendlyList;

    // List of Legal expressions or representations of this Contract.
    property legalList : TFhirContractLegalList read GetLegalList;
    property hasLegalList : boolean read GetHasLegalList;

    // List of Computable Policy Rule Language Representations of this Contract.
    property ruleList : TFhirContractRuleList read GetRuleList;
    property hasRuleList : boolean read GetHasRuleList;

    // Typed access to Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract. (defined for API consistency)
    property legallyBinding : TFhirDataType read FLegallyBinding write SetLegallyBinding;
    // Legally binding Contract: This is the signed and legally recognized representation of the Contract, which is considered the "source of truth" and which would be the basis for legal action related to enforcement of this Contract.
    property legallyBindingElement : TFhirDataType read FLegallyBinding write SetLegallyBinding;

  end;

  TFhirContractListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirContractList;
    function GetCurrent : TFhirContract;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirContractList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirContract read GetCurrent;
  end;

  TFhirContractList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirContract;
    procedure SetItemN(index : Integer; value : TFhirContract);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirContractList; overload;
    function Clone : TFhirContractList; overload;
    function GetEnumerator : TFhirContractListEnumerator;
    
    //  Add a FhirContract to the end of the list.
    function Append : TFhirContract;
    
    // Add an already existing FhirContract to the end of the list.
    function AddItem(value : TFhirContract) : TFhirContract; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirContract) : Integer;
    
    // Insert FhirContract before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirContract;
    
    // Insert an existing FhirContract before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirContract);
    
    // Get the iIndexth FhirContract. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirContract);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirContract;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirContracts[index : Integer] : TFhirContract read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_EVIDENCE}
  // Evidence variable such as population, exposure, or outcome.
  TFhirEvidenceVariableDefinition = class (TFhirBackboneElement)
  protected
    FDescription : TFhirMarkdown;
    FnoteList : TFhirAnnotationList;
    FVariableRole : TFhirCodeableConcept;
    FObserved : TFhirReference;
    FIntended : TFhirReference;
    FDirectnessMatch : TFhirCodeableConcept;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetVariableRole(value : TFhirCodeableConcept);
    procedure SetObserved(value : TFhirReference);
    procedure SetIntended(value : TFhirReference);
    procedure SetDirectnessMatch(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableDefinition; overload;
    function Clone : TFhirEvidenceVariableDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A text description or summary of the variable.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A text description or summary of the variable.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Footnotes and/or explanatory notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to population | subpopulation | exposure | referenceExposure | measuredVariable | confounder. (defined for API consistency)
    property variableRole : TFhirCodeableConcept read FVariableRole write SetVariableRole;
    // population | subpopulation | exposure | referenceExposure | measuredVariable | confounder.
    property variableRoleElement : TFhirCodeableConcept read FVariableRole write SetVariableRole;

    // Typed access to Definition of the actual variable related to the statistic(s). (defined for API consistency)
    property observed : TFhirReference read FObserved write SetObserved;
    // Definition of the actual variable related to the statistic(s).
    property observedElement : TFhirReference read FObserved write SetObserved;

    // Typed access to Definition of the intended variable related to the Evidence. (defined for API consistency)
    property intended : TFhirReference read FIntended write SetIntended;
    // Definition of the intended variable related to the Evidence.
    property intendedElement : TFhirReference read FIntended write SetIntended;

    // Typed access to Indication of quality of match between intended variable to actual variable. (defined for API consistency)
    property directnessMatch : TFhirCodeableConcept read FDirectnessMatch write SetDirectnessMatch;
    // Indication of quality of match between intended variable to actual variable.
    property directnessMatchElement : TFhirCodeableConcept read FDirectnessMatch write SetDirectnessMatch;

  end;

  TFhirEvidenceVariableDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableDefinitionList;
    function GetCurrent : TFhirEvidenceVariableDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableDefinition read GetCurrent;
  end;

  TFhirEvidenceVariableDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableDefinition;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableDefinitionList; overload;
    function Clone : TFhirEvidenceVariableDefinitionList; overload;
    function GetEnumerator : TFhirEvidenceVariableDefinitionListEnumerator;
    
    //  Add a FhirEvidenceVariableDefinition to the end of the list.
    function Append : TFhirEvidenceVariableDefinition;
    
    // Add an already existing FhirEvidenceVariableDefinition to the end of the list.
    function AddItem(value : TFhirEvidenceVariableDefinition) : TFhirEvidenceVariableDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableDefinition) : Integer;
    
    // Insert FhirEvidenceVariableDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableDefinition;
    
    // Insert an existing FhirEvidenceVariableDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableDefinition);
    
    // Get the iIndexth FhirEvidenceVariableDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableDefinitions[index : Integer] : TFhirEvidenceVariableDefinition read GetItemN write SetItemN; default;
  End;

  // Values and parameters for a single statistic.
  TFhirEvidenceStatistic = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FStatisticType : TFhirCodeableConcept;
    FCategory : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FNumberOfEvents : TFhirUnsignedInt;
    FNumberAffected : TFhirUnsignedInt;
    FSampleSize : TFhirEvidenceStatisticSampleSize;
    FattributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    FmodelCharacteristicList : TFhirEvidenceStatisticModelCharacteristicList;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetStatisticType(value : TFhirCodeableConcept);
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetNumberOfEvents(value : TFhirUnsignedInt);
    function GetNumberOfEventsST : String;
    procedure SetNumberOfEventsST(value : String);
    procedure SetNumberAffected(value : TFhirUnsignedInt);
    function GetNumberAffectedST : String;
    procedure SetNumberAffectedST(value : String);
    procedure SetSampleSize(value : TFhirEvidenceStatisticSampleSize);
    function GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    function GetHasAttributeEstimateList : Boolean;
    function GetModelCharacteristicList : TFhirEvidenceStatisticModelCharacteristicList;
    function GetHasModelCharacteristicList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatistic; overload;
    function Clone : TFhirEvidenceStatistic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A description of the content value of the statistic.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A description of the content value of the statistic.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Footnotes and/or explanatory notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Type of statistic, eg relative risk. (defined for API consistency)
    property statisticType : TFhirCodeableConcept read FStatisticType write SetStatisticType;
    // Type of statistic, eg relative risk.
    property statisticTypeElement : TFhirCodeableConcept read FStatisticType write SetStatisticType;

    // Typed access to When the measured variable is handled categorically, the category element is used to define which category the statistic is reporting. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // When the measured variable is handled categorically, the category element is used to define which category the statistic is reporting.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Statistic value. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Statistic value.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to The number of events associated with the statistic, where the unit of analysis is different from numberAffected, sampleSize.knownDataCount and sampleSize.numberOfParticipants.
    property numberOfEvents : String read GetNumberOfEventsST write SetNumberOfEventsST;
    // The number of events associated with the statistic, where the unit of analysis is different from numberAffected, sampleSize.knownDataCount and sampleSize.numberOfParticipants.
    property numberOfEventsElement : TFhirUnsignedInt read FNumberOfEvents write SetNumberOfEvents;

    // Typed access to The number of participants affected where the unit of analysis is the same as sampleSize.knownDataCount and sampleSize.numberOfParticipants.
    property numberAffected : String read GetNumberAffectedST write SetNumberAffectedST;
    // The number of participants affected where the unit of analysis is the same as sampleSize.knownDataCount and sampleSize.numberOfParticipants.
    property numberAffectedElement : TFhirUnsignedInt read FNumberAffected write SetNumberAffected;

    // Typed access to Number of samples in the statistic. (defined for API consistency)
    property sampleSize : TFhirEvidenceStatisticSampleSize read FSampleSize write SetSampleSize;
    // Number of samples in the statistic.
    property sampleSizeElement : TFhirEvidenceStatisticSampleSize read FSampleSize write SetSampleSize;

    // A statistical attribute of the statistic such as a measure of heterogeneity.
    property attributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList read GetAttributeEstimateList;
    property hasAttributeEstimateList : boolean read GetHasAttributeEstimateList;

    // A component of the method to generate the statistic.
    property modelCharacteristicList : TFhirEvidenceStatisticModelCharacteristicList read GetModelCharacteristicList;
    property hasModelCharacteristicList : boolean read GetHasModelCharacteristicList;

  end;

  TFhirEvidenceStatisticListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticList;
    function GetCurrent : TFhirEvidenceStatistic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatistic read GetCurrent;
  end;

  TFhirEvidenceStatisticList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatistic;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatistic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticList; overload;
    function Clone : TFhirEvidenceStatisticList; overload;
    function GetEnumerator : TFhirEvidenceStatisticListEnumerator;
    
    //  Add a FhirEvidenceStatistic to the end of the list.
    function Append : TFhirEvidenceStatistic;
    
    // Add an already existing FhirEvidenceStatistic to the end of the list.
    function AddItem(value : TFhirEvidenceStatistic) : TFhirEvidenceStatistic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatistic) : Integer;
    
    // Insert FhirEvidenceStatistic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatistic;
    
    // Insert an existing FhirEvidenceStatistic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatistic);
    
    // Get the iIndexth FhirEvidenceStatistic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatistic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatistic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatistics[index : Integer] : TFhirEvidenceStatistic read GetItemN write SetItemN; default;
  End;

  // Number of samples in the statistic.
  TFhirEvidenceStatisticSampleSize = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FNumberOfStudies : TFhirUnsignedInt;
    FNumberOfParticipants : TFhirUnsignedInt;
    FKnownDataCount : TFhirUnsignedInt;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetNumberOfStudies(value : TFhirUnsignedInt);
    function GetNumberOfStudiesST : String;
    procedure SetNumberOfStudiesST(value : String);
    procedure SetNumberOfParticipants(value : TFhirUnsignedInt);
    function GetNumberOfParticipantsST : String;
    procedure SetNumberOfParticipantsST(value : String);
    procedure SetKnownDataCount(value : TFhirUnsignedInt);
    function GetKnownDataCountST : String;
    procedure SetKnownDataCountST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatisticSampleSize; overload;
    function Clone : TFhirEvidenceStatisticSampleSize; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable summary of population sample size.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable summary of population sample size.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Footnote or explanatory note about the sample size.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Number of participants in the population.
    property numberOfStudies : String read GetNumberOfStudiesST write SetNumberOfStudiesST;
    // Number of participants in the population.
    property numberOfStudiesElement : TFhirUnsignedInt read FNumberOfStudies write SetNumberOfStudies;

    // Typed access to A human-readable string to clarify or explain concepts about the sample size.
    property numberOfParticipants : String read GetNumberOfParticipantsST write SetNumberOfParticipantsST;
    // A human-readable string to clarify or explain concepts about the sample size.
    property numberOfParticipantsElement : TFhirUnsignedInt read FNumberOfParticipants write SetNumberOfParticipants;

    // Typed access to Number of participants with known results for measured variables.
    property knownDataCount : String read GetKnownDataCountST write SetKnownDataCountST;
    // Number of participants with known results for measured variables.
    property knownDataCountElement : TFhirUnsignedInt read FKnownDataCount write SetKnownDataCount;

  end;

  TFhirEvidenceStatisticSampleSizeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticSampleSizeList;
    function GetCurrent : TFhirEvidenceStatisticSampleSize;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticSampleSizeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatisticSampleSize read GetCurrent;
  end;

  TFhirEvidenceStatisticSampleSizeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatisticSampleSize;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatisticSampleSize);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticSampleSizeList; overload;
    function Clone : TFhirEvidenceStatisticSampleSizeList; overload;
    function GetEnumerator : TFhirEvidenceStatisticSampleSizeListEnumerator;
    
    //  Add a FhirEvidenceStatisticSampleSize to the end of the list.
    function Append : TFhirEvidenceStatisticSampleSize;
    
    // Add an already existing FhirEvidenceStatisticSampleSize to the end of the list.
    function AddItem(value : TFhirEvidenceStatisticSampleSize) : TFhirEvidenceStatisticSampleSize; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatisticSampleSize) : Integer;
    
    // Insert FhirEvidenceStatisticSampleSize before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatisticSampleSize;
    
    // Insert an existing FhirEvidenceStatisticSampleSize before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatisticSampleSize);
    
    // Get the iIndexth FhirEvidenceStatisticSampleSize. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatisticSampleSize);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatisticSampleSize;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatisticSampleSizes[index : Integer] : TFhirEvidenceStatisticSampleSize read GetItemN write SetItemN; default;
  End;

  // A statistical attribute of the statistic such as a measure of heterogeneity.
  TFhirEvidenceStatisticAttributeEstimate = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FType_ : TFhirCodeableConcept;
    FQuantity : TFhirQuantity;
    FLevel : TFhirDecimal;
    FRange : TFhirRange;
    FattributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetLevel(value : TFhirDecimal);
    function GetLevelST : String;
    procedure SetLevelST(value : String);
    procedure SetRange(value : TFhirRange);
    function GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    function GetHasAttributeEstimateList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatisticAttributeEstimate; overload;
    function Clone : TFhirEvidenceStatisticAttributeEstimate; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable summary of the estimate.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Human-readable summary of the estimate.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Footnote or explanatory note about the estimate.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to The type of attribute estimate, eg confidence interval or p value. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of attribute estimate, eg confidence interval or p value.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The singular quantity of the attribute estimate, for attribute estimates represented as single values; also used to report unit of measure. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // The singular quantity of the attribute estimate, for attribute estimates represented as single values; also used to report unit of measure.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Use 95 for a 95% confidence interval.
    property level : String read GetLevelST write SetLevelST;
    // Use 95 for a 95% confidence interval.
    property levelElement : TFhirDecimal read FLevel write SetLevel;

    // Typed access to Lower bound of confidence interval. (defined for API consistency)
    property range : TFhirRange read FRange write SetRange;
    // Lower bound of confidence interval.
    property rangeElement : TFhirRange read FRange write SetRange;

    // A nested attribute estimate; which is the attribute estimate of an attribute estimate.
    property attributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList read GetAttributeEstimateList;
    property hasAttributeEstimateList : boolean read GetHasAttributeEstimateList;

  end;

  TFhirEvidenceStatisticAttributeEstimateListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticAttributeEstimateList;
    function GetCurrent : TFhirEvidenceStatisticAttributeEstimate;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticAttributeEstimateList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatisticAttributeEstimate read GetCurrent;
  end;

  TFhirEvidenceStatisticAttributeEstimateList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatisticAttributeEstimate;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatisticAttributeEstimate);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticAttributeEstimateList; overload;
    function Clone : TFhirEvidenceStatisticAttributeEstimateList; overload;
    function GetEnumerator : TFhirEvidenceStatisticAttributeEstimateListEnumerator;
    
    //  Add a FhirEvidenceStatisticAttributeEstimate to the end of the list.
    function Append : TFhirEvidenceStatisticAttributeEstimate;
    
    // Add an already existing FhirEvidenceStatisticAttributeEstimate to the end of the list.
    function AddItem(value : TFhirEvidenceStatisticAttributeEstimate) : TFhirEvidenceStatisticAttributeEstimate; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatisticAttributeEstimate) : Integer;
    
    // Insert FhirEvidenceStatisticAttributeEstimate before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatisticAttributeEstimate;
    
    // Insert an existing FhirEvidenceStatisticAttributeEstimate before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatisticAttributeEstimate);
    
    // Get the iIndexth FhirEvidenceStatisticAttributeEstimate. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatisticAttributeEstimate);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatisticAttributeEstimate;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatisticAttributeEstimates[index : Integer] : TFhirEvidenceStatisticAttributeEstimate read GetItemN write SetItemN; default;
  End;

  // A component of the method to generate the statistic.
  TFhirEvidenceStatisticModelCharacteristic = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirQuantity;
    FvariableList : TFhirEvidenceStatisticModelCharacteristicVariableList;
    FattributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirQuantity);
    function GetVariableList : TFhirEvidenceStatisticModelCharacteristicVariableList;
    function GetHasVariableList : Boolean;
    function GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
    function GetHasAttributeEstimateList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatisticModelCharacteristic; overload;
    function Clone : TFhirEvidenceStatisticModelCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of a component of the method to generate the statistic. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Description of a component of the method to generate the statistic.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Further specification of the quantified value of the component of the method to generate the statistic. (defined for API consistency)
    property value : TFhirQuantity read FValue write SetValue;
    // Further specification of the quantified value of the component of the method to generate the statistic.
    property valueElement : TFhirQuantity read FValue write SetValue;

    // A variable adjusted for in the adjusted analysis.
    property variableList : TFhirEvidenceStatisticModelCharacteristicVariableList read GetVariableList;
    property hasVariableList : boolean read GetHasVariableList;

    // An attribute of the statistic used as a model characteristic.
    property attributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList read GetAttributeEstimateList;
    property hasAttributeEstimateList : boolean read GetHasAttributeEstimateList;

  end;

  TFhirEvidenceStatisticModelCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticModelCharacteristicList;
    function GetCurrent : TFhirEvidenceStatisticModelCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticModelCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatisticModelCharacteristic read GetCurrent;
  end;

  TFhirEvidenceStatisticModelCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatisticModelCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatisticModelCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticModelCharacteristicList; overload;
    function Clone : TFhirEvidenceStatisticModelCharacteristicList; overload;
    function GetEnumerator : TFhirEvidenceStatisticModelCharacteristicListEnumerator;
    
    //  Add a FhirEvidenceStatisticModelCharacteristic to the end of the list.
    function Append : TFhirEvidenceStatisticModelCharacteristic;
    
    // Add an already existing FhirEvidenceStatisticModelCharacteristic to the end of the list.
    function AddItem(value : TFhirEvidenceStatisticModelCharacteristic) : TFhirEvidenceStatisticModelCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatisticModelCharacteristic) : Integer;
    
    // Insert FhirEvidenceStatisticModelCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatisticModelCharacteristic;
    
    // Insert an existing FhirEvidenceStatisticModelCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatisticModelCharacteristic);
    
    // Get the iIndexth FhirEvidenceStatisticModelCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatisticModelCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatisticModelCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatisticModelCharacteristics[index : Integer] : TFhirEvidenceStatisticModelCharacteristic read GetItemN write SetItemN; default;
  End;

  // A variable adjusted for in the adjusted analysis.
  TFhirEvidenceStatisticModelCharacteristicVariable = class (TFhirBackboneElement)
  protected
    FVariableDefinition : TFhirReference;
    FHandling : TFhirEnum;
    FvalueCategoryList : TFhirCodeableConceptList;
    FvalueQuantityList : TFhirQuantityList;
    FvalueRangeList : TFhirRangeList;
    procedure SetVariableDefinition(value : TFhirReference);
    procedure SetHandling(value : TFhirEnum);
    function GetHandlingST : TFhirEvidenceVariableHandlingEnum;
    procedure SetHandlingST(value : TFhirEvidenceVariableHandlingEnum);
    function GetValueCategoryList : TFhirCodeableConceptList;
    function GetHasValueCategoryList : Boolean;
    function GetValueQuantityList : TFhirQuantityList;
    function GetHasValueQuantityList : Boolean;
    function GetValueRangeList : TFhirRangeList;
    function GetHasValueRangeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceStatisticModelCharacteristicVariable; overload;
    function Clone : TFhirEvidenceStatisticModelCharacteristicVariable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of the variable. (defined for API consistency)
    property variableDefinition : TFhirReference read FVariableDefinition write SetVariableDefinition;
    // Description of the variable.
    property variableDefinitionElement : TFhirReference read FVariableDefinition write SetVariableDefinition;

    // How the variable is classified for use in adjusted analysis.
    property handling : TFhirEvidenceVariableHandlingEnum read GetHandlingST write SetHandlingST;
    property handlingElement : TFhirEnum read FHandling write SetHandling;

    // Description for grouping of ordinal or polychotomous variables.
    property valueCategoryList : TFhirCodeableConceptList read GetValueCategoryList;
    property hasValueCategoryList : boolean read GetHasValueCategoryList;

    // Discrete value for grouping of ordinal or polychotomous variables.
    property valueQuantityList : TFhirQuantityList read GetValueQuantityList;
    property hasValueQuantityList : boolean read GetHasValueQuantityList;

    // Range of values for grouping of ordinal or polychotomous variables.
    property valueRangeList : TFhirRangeList read GetValueRangeList;
    property hasValueRangeList : boolean read GetHasValueRangeList;

  end;

  TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceStatisticModelCharacteristicVariableList;
    function GetCurrent : TFhirEvidenceStatisticModelCharacteristicVariable;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceStatisticModelCharacteristicVariableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceStatisticModelCharacteristicVariable read GetCurrent;
  end;

  TFhirEvidenceStatisticModelCharacteristicVariableList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceStatisticModelCharacteristicVariable;
    procedure SetItemN(index : Integer; value : TFhirEvidenceStatisticModelCharacteristicVariable);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceStatisticModelCharacteristicVariableList; overload;
    function Clone : TFhirEvidenceStatisticModelCharacteristicVariableList; overload;
    function GetEnumerator : TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator;
    
    //  Add a FhirEvidenceStatisticModelCharacteristicVariable to the end of the list.
    function Append : TFhirEvidenceStatisticModelCharacteristicVariable;
    
    // Add an already existing FhirEvidenceStatisticModelCharacteristicVariable to the end of the list.
    function AddItem(value : TFhirEvidenceStatisticModelCharacteristicVariable) : TFhirEvidenceStatisticModelCharacteristicVariable; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceStatisticModelCharacteristicVariable) : Integer;
    
    // Insert FhirEvidenceStatisticModelCharacteristicVariable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceStatisticModelCharacteristicVariable;
    
    // Insert an existing FhirEvidenceStatisticModelCharacteristicVariable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceStatisticModelCharacteristicVariable);
    
    // Get the iIndexth FhirEvidenceStatisticModelCharacteristicVariable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceStatisticModelCharacteristicVariable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceStatisticModelCharacteristicVariable;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceStatisticModelCharacteristicVariables[index : Integer] : TFhirEvidenceStatisticModelCharacteristicVariable read GetItemN write SetItemN; default;
  End;

  // Assessment of certainty, confidence in the estimates, or quality of the evidence.
  TFhirEvidenceCertainty = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FnoteList : TFhirAnnotationList;
    FType_ : TFhirCodeableConcept;
    FRating : TFhirCodeableConcept;
    FRater : TFhirString;
    FsubcomponentList : TFhirEvidenceCertaintyList;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetRating(value : TFhirCodeableConcept);
    procedure SetRater(value : TFhirString);
    function GetRaterST : String;
    procedure SetRaterST(value : String);
    function GetSubcomponentList : TFhirEvidenceCertaintyList;
    function GetHasSubcomponentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceCertainty; overload;
    function Clone : TFhirEvidenceCertainty; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Textual description of certainty.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Textual description of certainty.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Footnotes and/or explanatory notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Typed access to Aspect of certainty being rated. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Aspect of certainty being rated.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to Assessment or judgement of the aspect. (defined for API consistency)
    property rating : TFhirCodeableConcept read FRating write SetRating;
    // Assessment or judgement of the aspect.
    property ratingElement : TFhirCodeableConcept read FRating write SetRating;

    // Typed access to Individual or group who did the rating.
    property rater : String read GetRaterST write SetRaterST;
    // Individual or group who did the rating.
    property raterElement : TFhirString read FRater write SetRater;

    // A domain or subdomain of certainty.
    property subcomponentList : TFhirEvidenceCertaintyList read GetSubcomponentList;
    property hasSubcomponentList : boolean read GetHasSubcomponentList;

  end;

  TFhirEvidenceCertaintyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceCertaintyList;
    function GetCurrent : TFhirEvidenceCertainty;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceCertaintyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceCertainty read GetCurrent;
  end;

  TFhirEvidenceCertaintyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceCertainty;
    procedure SetItemN(index : Integer; value : TFhirEvidenceCertainty);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceCertaintyList; overload;
    function Clone : TFhirEvidenceCertaintyList; overload;
    function GetEnumerator : TFhirEvidenceCertaintyListEnumerator;
    
    //  Add a FhirEvidenceCertainty to the end of the list.
    function Append : TFhirEvidenceCertainty;
    
    // Add an already existing FhirEvidenceCertainty to the end of the list.
    function AddItem(value : TFhirEvidenceCertainty) : TFhirEvidenceCertainty; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceCertainty) : Integer;
    
    // Insert FhirEvidenceCertainty before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceCertainty;
    
    // Insert an existing FhirEvidenceCertainty before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceCertainty);
    
    // Get the iIndexth FhirEvidenceCertainty. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceCertainty);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceCertainty;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceCertainties[index : Integer] : TFhirEvidenceCertainty read GetItemN write SetItemN; default;
  End;

  // The Evidence Resource provides a machine-interpretable expression of an evidence concept including the evidence variables (eg population, exposures/interventions, comparators, outcomes, measured variables, confounding variables), the statistics, and the certainty of this evidence.
  TFhirEvidence = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FTitle : TFhirString;
    FCiteAs : TFhirDataType;
    FStatus : TFhirEnum;
    FDate : TFhirDateTime;
    FuseContextList : TFhirUsageContextList;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FDescription : TFhirMarkdown;
    FAssertion : TFhirMarkdown;
    FnoteList : TFhirAnnotationList;
    FvariableDefinitionList : TFhirEvidenceVariableDefinitionList;
    FSynthesisType : TFhirCodeableConcept;
    FStudyType : TFhirCodeableConcept;
    FstatisticList : TFhirEvidenceStatisticList;
    FcertaintyList : TFhirEvidenceCertaintyList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetCiteAs(value : TFhirDataType);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetAssertion(value : TFhirMarkdown);
    function GetAssertionST : String;
    procedure SetAssertionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetVariableDefinitionList : TFhirEvidenceVariableDefinitionList;
    function GetHasVariableDefinitionList : Boolean;
    procedure SetSynthesisType(value : TFhirCodeableConcept);
    procedure SetStudyType(value : TFhirCodeableConcept);
    function GetStatisticList : TFhirEvidenceStatisticList;
    function GetHasStatisticList : Boolean;
    function GetCertaintyList : TFhirEvidenceCertaintyList;
    function GetHasCertaintyList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidence; overload;
    function Clone : TFhirEvidence; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this evidence when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this evidence when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this summary when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the summary when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the summary author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the summary when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the summary author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A short, descriptive, user-friendly title for the summary.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the summary.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to Citation Resource or display of suggested citation for this evidence. (defined for API consistency)
    property citeAs : TFhirDataType read FCiteAs write SetCiteAs;
    // Citation Resource or display of suggested citation for this evidence.
    property citeAsElement : TFhirDataType read FCiteAs write SetCiteAs;

    // The status of this summary. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date  (and optionally time) when the summary was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the summary changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the summary was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the summary changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate evidence instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The name of the organization or individual that published the evidence.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the evidence.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // An individiual, organization, or device primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individiual, organization, or device primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individiual, organization, or device primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individiual, organization, or device responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Link or citation to artifact associated with the summary.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to A free text natural language description of the evidence from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the evidence from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to Declarative description of the Evidence.
    property assertion : String read GetAssertionST write SetAssertionST;
    // Declarative description of the Evidence.
    property assertionElement : TFhirMarkdown read FAssertion write SetAssertion;

    // Footnotes and/or explanatory notes.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Evidence variable such as population, exposure, or outcome.
    property variableDefinitionList : TFhirEvidenceVariableDefinitionList read GetVariableDefinitionList;
    property hasVariableDefinitionList : boolean read GetHasVariableDefinitionList;

    // Typed access to The method to combine studies. (defined for API consistency)
    property synthesisType : TFhirCodeableConcept read FSynthesisType write SetSynthesisType;
    // The method to combine studies.
    property synthesisTypeElement : TFhirCodeableConcept read FSynthesisType write SetSynthesisType;

    // Typed access to The type of study that produced this evidence. (defined for API consistency)
    property studyType : TFhirCodeableConcept read FStudyType write SetStudyType;
    // The type of study that produced this evidence.
    property studyTypeElement : TFhirCodeableConcept read FStudyType write SetStudyType;

    // Values and parameters for a single statistic.
    property statisticList : TFhirEvidenceStatisticList read GetStatisticList;
    property hasStatisticList : boolean read GetHasStatisticList;

    // Assessment of certainty, confidence in the estimates, or quality of the evidence.
    property certaintyList : TFhirEvidenceCertaintyList read GetCertaintyList;
    property hasCertaintyList : boolean read GetHasCertaintyList;

  end;

  TFhirEvidenceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceList;
    function GetCurrent : TFhirEvidence;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidence read GetCurrent;
  end;

  TFhirEvidenceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidence;
    procedure SetItemN(index : Integer; value : TFhirEvidence);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceList; overload;
    function Clone : TFhirEvidenceList; overload;
    function GetEnumerator : TFhirEvidenceListEnumerator;
    
    //  Add a FhirEvidence to the end of the list.
    function Append : TFhirEvidence;
    
    // Add an already existing FhirEvidence to the end of the list.
    function AddItem(value : TFhirEvidence) : TFhirEvidence; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidence) : Integer;
    
    // Insert FhirEvidence before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidence;
    
    // Insert an existing FhirEvidence before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidence);
    
    // Get the iIndexth FhirEvidence. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidence);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidence;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidences[index : Integer] : TFhirEvidence read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
  // Specifies the subject or focus of the report. Answers "What is this report about?".
  TFhirEvidenceReportSubject = class (TFhirBackboneElement)
  protected
    FcharacteristicList : TFhirEvidenceReportSubjectCharacteristicList;
    FnoteList : TFhirAnnotationList;
    function GetCharacteristicList : TFhirEvidenceReportSubjectCharacteristicList;
    function GetHasCharacteristicList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReportSubject; overload;
    function Clone : TFhirEvidenceReportSubject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Characteristic.
    property characteristicList : TFhirEvidenceReportSubjectCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Used for general notes and annotations not coded elsewhere.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirEvidenceReportSubjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportSubjectList;
    function GetCurrent : TFhirEvidenceReportSubject;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportSubjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReportSubject read GetCurrent;
  end;

  TFhirEvidenceReportSubjectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReportSubject;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReportSubject);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportSubjectList; overload;
    function Clone : TFhirEvidenceReportSubjectList; overload;
    function GetEnumerator : TFhirEvidenceReportSubjectListEnumerator;
    
    //  Add a FhirEvidenceReportSubject to the end of the list.
    function Append : TFhirEvidenceReportSubject;
    
    // Add an already existing FhirEvidenceReportSubject to the end of the list.
    function AddItem(value : TFhirEvidenceReportSubject) : TFhirEvidenceReportSubject; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReportSubject) : Integer;
    
    // Insert FhirEvidenceReportSubject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReportSubject;
    
    // Insert an existing FhirEvidenceReportSubject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReportSubject);
    
    // Get the iIndexth FhirEvidenceReportSubject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReportSubject);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReportSubject;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReportSubjects[index : Integer] : TFhirEvidenceReportSubject read GetItemN write SetItemN; default;
  End;

  // Characteristic.
  TFhirEvidenceReportSubjectCharacteristic = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirDataType;
    FExclude : TFhirBoolean;
    FPeriod : TFhirPeriod;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
    procedure SetExclude(value : TFhirBoolean);
    function GetExcludeST : Boolean;
    procedure SetExcludeST(value : Boolean);
    procedure SetPeriod(value : TFhirPeriod);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReportSubjectCharacteristic; overload;
    function Clone : TFhirEvidenceReportSubjectCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Characteristic code. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // Characteristic code.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to Characteristic value. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Characteristic value.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to Is used to express not the characteristic.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // Is used to express not the characteristic.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to Timeframe for the characteristic. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Timeframe for the characteristic.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

  end;

  TFhirEvidenceReportSubjectCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportSubjectCharacteristicList;
    function GetCurrent : TFhirEvidenceReportSubjectCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportSubjectCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReportSubjectCharacteristic read GetCurrent;
  end;

  TFhirEvidenceReportSubjectCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReportSubjectCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReportSubjectCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportSubjectCharacteristicList; overload;
    function Clone : TFhirEvidenceReportSubjectCharacteristicList; overload;
    function GetEnumerator : TFhirEvidenceReportSubjectCharacteristicListEnumerator;
    
    //  Add a FhirEvidenceReportSubjectCharacteristic to the end of the list.
    function Append : TFhirEvidenceReportSubjectCharacteristic;
    
    // Add an already existing FhirEvidenceReportSubjectCharacteristic to the end of the list.
    function AddItem(value : TFhirEvidenceReportSubjectCharacteristic) : TFhirEvidenceReportSubjectCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReportSubjectCharacteristic) : Integer;
    
    // Insert FhirEvidenceReportSubjectCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReportSubjectCharacteristic;
    
    // Insert an existing FhirEvidenceReportSubjectCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReportSubjectCharacteristic);
    
    // Get the iIndexth FhirEvidenceReportSubjectCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReportSubjectCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReportSubjectCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReportSubjectCharacteristics[index : Integer] : TFhirEvidenceReportSubjectCharacteristic read GetItemN write SetItemN; default;
  End;

  // Relationships that this composition has with other compositions or documents that already exist.
  TFhirEvidenceReportRelatesTo = class (TFhirBackboneElement)
  protected
    FCode : TFhirEnum;
    FTarget : TFhirDataType;
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirReportRelationshipTypeEnum;
    procedure SetCodeST(value : TFhirReportRelationshipTypeEnum);
    procedure SetTarget(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReportRelatesTo; overload;
    function Clone : TFhirEvidenceReportRelatesTo; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of relationship that this composition has with anther composition or document.
    property code : TFhirReportRelationshipTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to The target composition/document of this relationship. (defined for API consistency)
    property target : TFhirDataType read FTarget write SetTarget;
    // The target composition/document of this relationship.
    property targetElement : TFhirDataType read FTarget write SetTarget;

  end;

  TFhirEvidenceReportRelatesToListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportRelatesToList;
    function GetCurrent : TFhirEvidenceReportRelatesTo;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportRelatesToList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReportRelatesTo read GetCurrent;
  end;

  TFhirEvidenceReportRelatesToList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReportRelatesTo;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReportRelatesTo);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportRelatesToList; overload;
    function Clone : TFhirEvidenceReportRelatesToList; overload;
    function GetEnumerator : TFhirEvidenceReportRelatesToListEnumerator;
    
    //  Add a FhirEvidenceReportRelatesTo to the end of the list.
    function Append : TFhirEvidenceReportRelatesTo;
    
    // Add an already existing FhirEvidenceReportRelatesTo to the end of the list.
    function AddItem(value : TFhirEvidenceReportRelatesTo) : TFhirEvidenceReportRelatesTo; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReportRelatesTo) : Integer;
    
    // Insert FhirEvidenceReportRelatesTo before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReportRelatesTo;
    
    // Insert an existing FhirEvidenceReportRelatesTo before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReportRelatesTo);
    
    // Get the iIndexth FhirEvidenceReportRelatesTo. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReportRelatesTo);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReportRelatesTo;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReportRelatesTos[index : Integer] : TFhirEvidenceReportRelatesTo read GetItemN write SetItemN; default;
  End;

  // The root of the sections that make up the composition.
  TFhirEvidenceReportSection = class (TFhirBackboneElement)
  protected
    FTitle : TFhirString;
    FFocus : TFhirCodeableConcept;
    FFocusReference : TFhirReference;
    FauthorList : TFhirReferenceList;
    FText : TFhirNarrative;
    FMode : TFhirEnum;
    FOrderedBy : TFhirCodeableConcept;
    FentryClassifierList : TFhirCodeableConceptList;
    FentryReferenceList : TFhirReferenceList;
    FentryQuantityList : TFhirQuantityList;
    FEmptyReason : TFhirCodeableConcept;
    FsectionList : TFhirEvidenceReportSectionList;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetFocus(value : TFhirCodeableConcept);
    procedure SetFocusReference(value : TFhirReference);
    function GetAuthorList : TFhirReferenceList;
    function GetHasAuthorList : Boolean;
    procedure SetText(value : TFhirNarrative);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirListModeEnum;
    procedure SetModeST(value : TFhirListModeEnum);
    procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetEntryClassifierList : TFhirCodeableConceptList;
    function GetHasEntryClassifierList : Boolean;
    function GetEntryReferenceList : TFhirReferenceList;
    function GetHasEntryReferenceList : Boolean;
    function GetEntryQuantityList : TFhirQuantityList;
    function GetHasEntryQuantityList : Boolean;
    procedure SetEmptyReason(value : TFhirCodeableConcept);
    function GetSectionList : TFhirEvidenceReportSectionList;
    function GetHasSectionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReportSection; overload;
    function Clone : TFhirEvidenceReportSection; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property title : String read GetTitleST write SetTitleST;
    // The label for this particular section.  This will be part of the rendered content for the document, and is often used to build a table of contents.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A code identifying the kind of content contained within the section. This should be consistent with the section title. (defined for API consistency)
    property focus : TFhirCodeableConcept read FFocus write SetFocus;
    // A code identifying the kind of content contained within the section. This should be consistent with the section title.
    property focusElement : TFhirCodeableConcept read FFocus write SetFocus;

    // Typed access to A definitional Resource identifying the kind of content contained within the section. This should be consistent with the section title. (defined for API consistency)
    property focusReference : TFhirReference read FFocusReference write SetFocusReference;
    // A definitional Resource identifying the kind of content contained within the section. This should be consistent with the section title.
    property focusReferenceElement : TFhirReference read FFocusReference write SetFocusReference;

    // Identifies who is responsible for the information in this section, not necessarily who typed it in.
    property authorList : TFhirReferenceList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // Typed access to A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is peferred to contain sufficient detail to make it acceptable for a human to just read the narrative. (defined for API consistency)
    property text : TFhirNarrative read FText write SetText;
    // A human-readable narrative that contains the attested content of the section, used to represent the content of the resource to a human. The narrative need not encode all the structured data, but is peferred to contain sufficient detail to make it acceptable for a human to just read the narrative.
    property textElement : TFhirNarrative read FText write SetText;

    // How the entry list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to Specifies the order applied to the items in the section entries. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // Specifies the order applied to the items in the section entries.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // Specifies any type of classification of the evidence report.
    property entryClassifierList : TFhirCodeableConceptList read GetEntryClassifierList;
    property hasEntryClassifierList : boolean read GetHasEntryClassifierList;

    // A reference to the actual resource from which the narrative in the section is derived.
    property entryReferenceList : TFhirReferenceList read GetEntryReferenceList;
    property hasEntryReferenceList : boolean read GetHasEntryReferenceList;

    // Quantity as content.
    property entryQuantityList : TFhirQuantityList read GetEntryQuantityList;
    property hasEntryQuantityList : boolean read GetHasEntryQuantityList;

    // Typed access to If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the section is empty, why the list is empty. An empty section typically has some text explaining the empty reason.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

    // A nested sub-section within this section.
    property sectionList : TFhirEvidenceReportSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirEvidenceReportSectionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportSectionList;
    function GetCurrent : TFhirEvidenceReportSection;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportSectionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReportSection read GetCurrent;
  end;

  TFhirEvidenceReportSectionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReportSection;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReportSection);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportSectionList; overload;
    function Clone : TFhirEvidenceReportSectionList; overload;
    function GetEnumerator : TFhirEvidenceReportSectionListEnumerator;
    
    //  Add a FhirEvidenceReportSection to the end of the list.
    function Append : TFhirEvidenceReportSection;
    
    // Add an already existing FhirEvidenceReportSection to the end of the list.
    function AddItem(value : TFhirEvidenceReportSection) : TFhirEvidenceReportSection; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReportSection) : Integer;
    
    // Insert FhirEvidenceReportSection before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReportSection;
    
    // Insert an existing FhirEvidenceReportSection before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReportSection);
    
    // Get the iIndexth FhirEvidenceReportSection. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReportSection);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReportSection;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReportSections[index : Integer] : TFhirEvidenceReportSection read GetItemN write SetItemN; default;
  End;

  // The EvidenceReport Resource is a specialized container for a collection of resources and codable concepts, adapted to support compositions of Evidence, EvidenceVariable, and Citation resources and related concepts.
  TFhirEvidenceReport = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FStatus : TFhirEnum;
    FuseContextList : TFhirUsageContextList;
    FidentifierList : TFhirIdentifierList;
    FrelatedIdentifierList : TFhirIdentifierList;
    FCiteAs : TFhirDataType;
    FType_ : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FSubject : TFhirEvidenceReportSubject;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatesToList : TFhirEvidenceReportRelatesToList;
    FsectionList : TFhirEvidenceReportSectionList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetRelatedIdentifierList : TFhirIdentifierList;
    function GetHasRelatedIdentifierList : Boolean;
    procedure SetCiteAs(value : TFhirDataType);
    procedure SetType_(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    procedure SetSubject(value : TFhirEvidenceReportSubject);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatesToList : TFhirEvidenceReportRelatesToList;
    function GetHasRelatesToList : Boolean;
    function GetSectionList : TFhirEvidenceReportSectionList;
    function GetHasSectionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceReport; overload;
    function Clone : TFhirEvidenceReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this EvidenceReport when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this EvidenceReport when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this summary is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the summary is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // The status of this summary. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate evidence report instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A formal identifier that is used to identify this EvidenceReport when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A formal identifier that is used to identify things closely related to this EvidenceReport.
    property relatedIdentifierList : TFhirIdentifierList read GetRelatedIdentifierList;
    property hasRelatedIdentifierList : boolean read GetHasRelatedIdentifierList;

    // Typed access to Citation Resource or display of suggested citation for this report. (defined for API consistency)
    property citeAs : TFhirDataType read FCiteAs write SetCiteAs;
    // Citation Resource or display of suggested citation for this report.
    property citeAsElement : TFhirDataType read FCiteAs write SetCiteAs;

    // Typed access to Specifies the kind of report, such as grouping of classifiers, search results, or human-compiled expression. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Specifies the kind of report, such as grouping of classifiers, search results, or human-compiled expression.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Used for footnotes and annotations.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Link, description or reference to artifact associated with the report.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to Specifies the subject or focus of the report. Answers "What is this report about?". (defined for API consistency)
    property subject : TFhirEvidenceReportSubject read FSubject write SetSubject;
    // Specifies the subject or focus of the report. Answers "What is this report about?".
    property subjectElement : TFhirEvidenceReportSubject read FSubject write SetSubject;

    // Typed access to The name of the organization or individual that published the evidence report.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the evidence report.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // An individiual, organization, or device primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individiual, organization, or device primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individiual, organization, or device primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individiual, organization, or device responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Relationships that this composition has with other compositions or documents that already exist.
    property relatesToList : TFhirEvidenceReportRelatesToList read GetRelatesToList;
    property hasRelatesToList : boolean read GetHasRelatesToList;

    // The root of the sections that make up the composition.
    property sectionList : TFhirEvidenceReportSectionList read GetSectionList;
    property hasSectionList : boolean read GetHasSectionList;

  end;

  TFhirEvidenceReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceReportList;
    function GetCurrent : TFhirEvidenceReport;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceReport read GetCurrent;
  end;

  TFhirEvidenceReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceReport;
    procedure SetItemN(index : Integer; value : TFhirEvidenceReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceReportList; overload;
    function Clone : TFhirEvidenceReportList; overload;
    function GetEnumerator : TFhirEvidenceReportListEnumerator;
    
    //  Add a FhirEvidenceReport to the end of the list.
    function Append : TFhirEvidenceReport;
    
    // Add an already existing FhirEvidenceReport to the end of the list.
    function AddItem(value : TFhirEvidenceReport) : TFhirEvidenceReport; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceReport) : Integer;
    
    // Insert FhirEvidenceReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceReport;
    
    // Insert an existing FhirEvidenceReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceReport);
    
    // Get the iIndexth FhirEvidenceReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceReport;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceReports[index : Integer] : TFhirEvidenceReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
  // A characteristic that defines the members of the evidence element. Multiple characteristics are applied with "and" semantics.
  TFhirEvidenceVariableCharacteristic = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FDefinition : TFhirDataType;
    FMethod : TFhirCodeableConcept;
    FDevice : TFhirReference;
    FExclude : TFhirBoolean;
    FTimeFromStart : TFhirEvidenceVariableCharacteristicTimeFromStart;
    FGroupMeasure : TFhirEnum;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetDefinition(value : TFhirDataType);
    procedure SetMethod(value : TFhirCodeableConcept);
    procedure SetDevice(value : TFhirReference);
    procedure SetExclude(value : TFhirBoolean);
    function GetExcludeST : Boolean;
    procedure SetExcludeST(value : Boolean);
    procedure SetTimeFromStart(value : TFhirEvidenceVariableCharacteristicTimeFromStart);
    procedure SetGroupMeasure(value : TFhirEnum);
    function GetGroupMeasureST : TFhirGroupMeasureEnum;
    procedure SetGroupMeasureST(value : TFhirGroupMeasureEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableCharacteristic; overload;
    function Clone : TFhirEvidenceVariableCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A short, natural language description of the characteristic that could be used to communicate the criteria to an end-user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short, natural language description of the characteristic that could be used to communicate the criteria to an end-user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Define members of the evidence element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year). (defined for API consistency)
    property definition : TFhirDataType read FDefinition write SetDefinition;
    // Define members of the evidence element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year).
    property definitionElement : TFhirDataType read FDefinition write SetDefinition;

    // Typed access to Method used for describing characteristic. (defined for API consistency)
    property method : TFhirCodeableConcept read FMethod write SetMethod;
    // Method used for describing characteristic.
    property methodElement : TFhirCodeableConcept read FMethod write SetMethod;

    // Typed access to Device used for determining characteristic. (defined for API consistency)
    property device : TFhirReference read FDevice write SetDevice;
    // Device used for determining characteristic.
    property deviceElement : TFhirReference read FDevice write SetDevice;

    // Typed access to When true, members with this characteristic are excluded from the element.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // When true, members with this characteristic are excluded from the element.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to Indicates duration, period, or point of observation from the participant's study entry. (defined for API consistency)
    property timeFromStart : TFhirEvidenceVariableCharacteristicTimeFromStart read FTimeFromStart write SetTimeFromStart;
    // Indicates duration, period, or point of observation from the participant's study entry.
    property timeFromStartElement : TFhirEvidenceVariableCharacteristicTimeFromStart read FTimeFromStart write SetTimeFromStart;

    // Indicates how elements are aggregated within the study effective period.
    property groupMeasure : TFhirGroupMeasureEnum read GetGroupMeasureST write SetGroupMeasureST;
    property groupMeasureElement : TFhirEnum read FGroupMeasure write SetGroupMeasure;

  end;

  TFhirEvidenceVariableCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableCharacteristicList;
    function GetCurrent : TFhirEvidenceVariableCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableCharacteristic read GetCurrent;
  end;

  TFhirEvidenceVariableCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableCharacteristicList; overload;
    function Clone : TFhirEvidenceVariableCharacteristicList; overload;
    function GetEnumerator : TFhirEvidenceVariableCharacteristicListEnumerator;
    
    //  Add a FhirEvidenceVariableCharacteristic to the end of the list.
    function Append : TFhirEvidenceVariableCharacteristic;
    
    // Add an already existing FhirEvidenceVariableCharacteristic to the end of the list.
    function AddItem(value : TFhirEvidenceVariableCharacteristic) : TFhirEvidenceVariableCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableCharacteristic) : Integer;
    
    // Insert FhirEvidenceVariableCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableCharacteristic;
    
    // Insert an existing FhirEvidenceVariableCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableCharacteristic);
    
    // Get the iIndexth FhirEvidenceVariableCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableCharacteristics[index : Integer] : TFhirEvidenceVariableCharacteristic read GetItemN write SetItemN; default;
  End;

  // Indicates duration, period, or point of observation from the participant's study entry.
  TFhirEvidenceVariableCharacteristicTimeFromStart = class (TFhirBackboneElement)
  protected
    FDescription : TFhirString;
    FQuantity : TFhirQuantity;
    FRange : TFhirRange;
    FnoteList : TFhirAnnotationList;
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetQuantity(value : TFhirQuantity);
    procedure SetRange(value : TFhirRange);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableCharacteristicTimeFromStart; overload;
    function Clone : TFhirEvidenceVariableCharacteristicTimeFromStart; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A short, natural language description.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short, natural language description.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to Used to express the observation at a defined amount of time after the study start. (defined for API consistency)
    property quantity : TFhirQuantity read FQuantity write SetQuantity;
    // Used to express the observation at a defined amount of time after the study start.
    property quantityElement : TFhirQuantity read FQuantity write SetQuantity;

    // Typed access to Used to express the observation within a period after the study start. (defined for API consistency)
    property range : TFhirRange read FRange write SetRange;
    // Used to express the observation within a period after the study start.
    property rangeElement : TFhirRange read FRange write SetRange;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

  end;

  TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableCharacteristicTimeFromStartList;
    function GetCurrent : TFhirEvidenceVariableCharacteristicTimeFromStart;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableCharacteristicTimeFromStartList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableCharacteristicTimeFromStart read GetCurrent;
  end;

  TFhirEvidenceVariableCharacteristicTimeFromStartList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableCharacteristicTimeFromStart;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableCharacteristicTimeFromStart);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableCharacteristicTimeFromStartList; overload;
    function Clone : TFhirEvidenceVariableCharacteristicTimeFromStartList; overload;
    function GetEnumerator : TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator;
    
    //  Add a FhirEvidenceVariableCharacteristicTimeFromStart to the end of the list.
    function Append : TFhirEvidenceVariableCharacteristicTimeFromStart;
    
    // Add an already existing FhirEvidenceVariableCharacteristicTimeFromStart to the end of the list.
    function AddItem(value : TFhirEvidenceVariableCharacteristicTimeFromStart) : TFhirEvidenceVariableCharacteristicTimeFromStart; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableCharacteristicTimeFromStart) : Integer;
    
    // Insert FhirEvidenceVariableCharacteristicTimeFromStart before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableCharacteristicTimeFromStart;
    
    // Insert an existing FhirEvidenceVariableCharacteristicTimeFromStart before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableCharacteristicTimeFromStart);
    
    // Get the iIndexth FhirEvidenceVariableCharacteristicTimeFromStart. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableCharacteristicTimeFromStart);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableCharacteristicTimeFromStart;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableCharacteristicTimeFromStarts[index : Integer] : TFhirEvidenceVariableCharacteristicTimeFromStart read GetItemN write SetItemN; default;
  End;

  // A grouping (or set of values) described along with other groupings to specify the set of groupings allowed for the variable.
  TFhirEvidenceVariableCategory = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirDataType;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariableCategory; overload;
    function Clone : TFhirEvidenceVariableCategory; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A human-readable title or representation of the grouping.
    property name : String read GetNameST write SetNameST;
    // A human-readable title or representation of the grouping.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Value or set of values that define the grouping. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Value or set of values that define the grouping.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirEvidenceVariableCategoryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableCategoryList;
    function GetCurrent : TFhirEvidenceVariableCategory;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableCategoryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariableCategory read GetCurrent;
  end;

  TFhirEvidenceVariableCategoryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariableCategory;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariableCategory);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableCategoryList; overload;
    function Clone : TFhirEvidenceVariableCategoryList; overload;
    function GetEnumerator : TFhirEvidenceVariableCategoryListEnumerator;
    
    //  Add a FhirEvidenceVariableCategory to the end of the list.
    function Append : TFhirEvidenceVariableCategory;
    
    // Add an already existing FhirEvidenceVariableCategory to the end of the list.
    function AddItem(value : TFhirEvidenceVariableCategory) : TFhirEvidenceVariableCategory; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariableCategory) : Integer;
    
    // Insert FhirEvidenceVariableCategory before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariableCategory;
    
    // Insert an existing FhirEvidenceVariableCategory before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariableCategory);
    
    // Get the iIndexth FhirEvidenceVariableCategory. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariableCategory);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariableCategory;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariableCategories[index : Integer] : TFhirEvidenceVariableCategory read GetItemN write SetItemN; default;
  End;

  // The EvidenceVariable resource describes an element that knowledge (Evidence) is about.
  TFhirEvidenceVariable = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FShortTitle : TFhirString;
    FSubtitle : TFhirString;
    FStatus : TFhirEnum;
    FDate : TFhirDateTime;
    FDescription : TFhirMarkdown;
    FnoteList : TFhirAnnotationList;
    FuseContextList : TFhirUsageContextList;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FActual : TFhirBoolean;
    FCharacteristicCombination : TFhirEnum;
    FcharacteristicList : TFhirEvidenceVariableCharacteristicList;
    FHandling : TFhirEnum;
    FcategoryList : TFhirEvidenceVariableCategoryList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetShortTitle(value : TFhirString);
    function GetShortTitleST : String;
    procedure SetShortTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    procedure SetActual(value : TFhirBoolean);
    function GetActualST : Boolean;
    procedure SetActualST(value : Boolean);
    procedure SetCharacteristicCombination(value : TFhirEnum);
    function GetCharacteristicCombinationST : TFhirCharacteristicCombinationEnum;
    procedure SetCharacteristicCombinationST(value : TFhirCharacteristicCombinationEnum);
    function GetCharacteristicList : TFhirEvidenceVariableCharacteristicList;
    function GetHasCharacteristicList : Boolean;
    procedure SetHandling(value : TFhirEnum);
    function GetHandlingST : TFhirEvidenceVariableHandlingEnum;
    procedure SetHandlingST(value : TFhirEvidenceVariableHandlingEnum);
    function GetCategoryList : TFhirEvidenceVariableCategoryList;
    function GetHasCategoryList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirEvidenceVariable; overload;
    function Clone : TFhirEvidenceVariable; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this evidence variable when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this evidence variable is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the evidence variable is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this evidence variable when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this evidence variable is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the evidence variable is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this evidence variable when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the evidence variable when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the evidence variable author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the evidence variable when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the evidence variable author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the evidence variable. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the evidence variable. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the evidence variable.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the evidence variable.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitle : String read GetShortTitleST write SetShortTitleST;
    // The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitleElement : TFhirString read FShortTitle write SetShortTitle;

    // Typed access to An explanatory or alternate title for the EvidenceVariable giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the EvidenceVariable giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this evidence variable. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The date  (and optionally time) when the evidence variable was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the evidence variable changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the evidence variable was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the evidence variable changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A free text natural language description of the evidence variable from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the evidence variable from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate evidence variable instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // Typed access to The name of the organization or individual that published the evidence variable.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the evidence variable.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Typed access to True if the actual variable measured, false if a conceptual representation of the intended variable.
    property actual : Boolean read GetActualST write SetActualST;
    // True if the actual variable measured, false if a conceptual representation of the intended variable.
    property actualElement : TFhirBoolean read FActual write SetActual;

    // Used to specify if two or more characteristics are combined with OR or AND.
    property characteristicCombination : TFhirCharacteristicCombinationEnum read GetCharacteristicCombinationST write SetCharacteristicCombinationST;
    property characteristicCombinationElement : TFhirEnum read FCharacteristicCombination write SetCharacteristicCombination;

    // A characteristic that defines the members of the evidence element. Multiple characteristics are applied with "and" semantics.
    property characteristicList : TFhirEvidenceVariableCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

    // Used for an outcome to classify.
    property handling : TFhirEvidenceVariableHandlingEnum read GetHandlingST write SetHandlingST;
    property handlingElement : TFhirEnum read FHandling write SetHandling;

    // A grouping (or set of values) described along with other groupings to specify the set of groupings allowed for the variable.
    property categoryList : TFhirEvidenceVariableCategoryList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

  end;

  TFhirEvidenceVariableListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirEvidenceVariableList;
    function GetCurrent : TFhirEvidenceVariable;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirEvidenceVariableList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirEvidenceVariable read GetCurrent;
  end;

  TFhirEvidenceVariableList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirEvidenceVariable;
    procedure SetItemN(index : Integer; value : TFhirEvidenceVariable);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirEvidenceVariableList; overload;
    function Clone : TFhirEvidenceVariableList; overload;
    function GetEnumerator : TFhirEvidenceVariableListEnumerator;
    
    //  Add a FhirEvidenceVariable to the end of the list.
    function Append : TFhirEvidenceVariable;
    
    // Add an already existing FhirEvidenceVariable to the end of the list.
    function AddItem(value : TFhirEvidenceVariable) : TFhirEvidenceVariable; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirEvidenceVariable) : Integer;
    
    // Insert FhirEvidenceVariable before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirEvidenceVariable;
    
    // Insert an existing FhirEvidenceVariable before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirEvidenceVariable);
    
    // Get the iIndexth FhirEvidenceVariable. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirEvidenceVariable);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirEvidenceVariable;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirEvidenceVariables[index : Integer] : TFhirEvidenceVariable read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_GUIDANCERESPONSE}
  // A guidance response is the formal response to a guidance request, including any output parameters returned by the evaluation, as well as the description of any proposed actions to be taken.
  TFhirGuidanceResponse = class (TFhirDomainResource)
  protected
    FRequestIdentifier : TFhirIdentifier;
    FidentifierList : TFhirIdentifierList;
    FModule : TFhirDataType;
    FStatus : TFhirEnum;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FOccurrenceDateTime : TFhirDateTime;
    FPerformer : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FevaluationMessageList : TFhirReferenceList;
    FOutputParameters : TFhirReference;
    FResult : TFhirReference;
    FdataRequirementList : TFhirDataRequirementList;
    procedure SetRequestIdentifier(value : TFhirIdentifier);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetModule(value : TFhirDataType);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirGuidanceResponseStatusEnum;
    procedure SetStatusST(value : TFhirGuidanceResponseStatusEnum);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetOccurrenceDateTime(value : TFhirDateTime);
    function GetOccurrenceDateTimeST : TFslDateTime;
    procedure SetOccurrenceDateTimeST(value : TFslDateTime);
    procedure SetPerformer(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetEvaluationMessageList : TFhirReferenceList;
    function GetHasEvaluationMessageList : Boolean;
    procedure SetOutputParameters(value : TFhirReference);
    procedure SetResult(value : TFhirReference);
    function GetDataRequirementList : TFhirDataRequirementList;
    function GetHasDataRequirementList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirGuidanceResponse; overload;
    function Clone : TFhirGuidanceResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The identifier of the request associated with this response. If an identifier was given as part of the request, it will be reproduced here to enable the requester to more easily identify the response in a multi-request scenario. (defined for API consistency)
    property requestIdentifier : TFhirIdentifier read FRequestIdentifier write SetRequestIdentifier;
    // The identifier of the request associated with this response. If an identifier was given as part of the request, it will be reproduced here to enable the requester to more easily identify the response in a multi-request scenario.
    property requestIdentifierElement : TFhirIdentifier read FRequestIdentifier write SetRequestIdentifier;

    // Allows a service to provide  unique, business identifiers for the response.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to An identifier, CodeableConcept or canonical reference to the guidance that was requested. (defined for API consistency)
    property module : TFhirDataType read FModule write SetModule;
    // An identifier, CodeableConcept or canonical reference to the guidance that was requested.
    property moduleElement : TFhirDataType read FModule write SetModule;

    // The status of the response. If the evaluation is completed successfully, the status will indicate success. However, in order to complete the evaluation, the engine may require more information. In this case, the status will be data-required, and the response will contain a description of the additional required information. If the evaluation completed successfully, but the engine determines that a potentially more accurate response could be provided if more data was available, the status will be data-requested, and the response will contain a description of the additional requested information.
    property status : TFhirGuidanceResponseStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The patient for which the request was processed. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The patient for which the request was processed.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter during which this response was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter during which this response was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Indicates when the guidance response was processed.
    property occurrenceDateTime : TFslDateTime read GetOccurrenceDateTimeST write SetOccurrenceDateTimeST;
    // Indicates when the guidance response was processed.
    property occurrenceDateTimeElement : TFhirDateTime read FOccurrenceDateTime write SetOccurrenceDateTime;

    // Typed access to Provides a reference to the device that performed the guidance. (defined for API consistency)
    property performer : TFhirReference read FPerformer write SetPerformer;
    // Provides a reference to the device that performed the guidance.
    property performerElement : TFhirReference read FPerformer write SetPerformer;

    // Describes the reason for the guidance response in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates the reason the request was initiated. This is typically provided as a parameter to the evaluation and echoed by the service, although for some use cases, such as subscription- or event-based scenarios, it may provide an indication of the cause for the response.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Provides a mechanism to communicate additional information about the response.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Messages resulting from the evaluation of the artifact or artifacts. As part of evaluating the request, the engine may produce informational or warning messages. These messages will be provided by this element.
    property evaluationMessageList : TFhirReferenceList read GetEvaluationMessageList;
    property hasEvaluationMessageList : boolean read GetHasEvaluationMessageList;

    // Typed access to The output parameters of the evaluation, if any. Many modules will result in the return of specific resources such as procedure or communication requests that are returned as part of the operation result. However, modules may define specific outputs that would be returned as the result of the evaluation, and these would be returned in this element. (defined for API consistency)
    property outputParameters : TFhirReference read FOutputParameters write SetOutputParameters;
    // The output parameters of the evaluation, if any. Many modules will result in the return of specific resources such as procedure or communication requests that are returned as part of the operation result. However, modules may define specific outputs that would be returned as the result of the evaluation, and these would be returned in this element.
    property outputParametersElement : TFhirReference read FOutputParameters write SetOutputParameters;

    // Typed access to The actions, if any, produced by the evaluation of the artifact. (defined for API consistency)
    property result : TFhirReference read FResult write SetResult;
    // The actions, if any, produced by the evaluation of the artifact.
    property resultElement : TFhirReference read FResult write SetResult;

    // If the evaluation could not be completed due to lack of information, or additional information would potentially result in a more accurate response, this element will a description of the data required in order to proceed with the evaluation. A subsequent request to the service should include this data.
    property dataRequirementList : TFhirDataRequirementList read GetDataRequirementList;
    property hasDataRequirementList : boolean read GetHasDataRequirementList;

  end;

  TFhirGuidanceResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirGuidanceResponseList;
    function GetCurrent : TFhirGuidanceResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirGuidanceResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirGuidanceResponse read GetCurrent;
  end;

  TFhirGuidanceResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirGuidanceResponse;
    procedure SetItemN(index : Integer; value : TFhirGuidanceResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirGuidanceResponseList; overload;
    function Clone : TFhirGuidanceResponseList; overload;
    function GetEnumerator : TFhirGuidanceResponseListEnumerator;
    
    //  Add a FhirGuidanceResponse to the end of the list.
    function Append : TFhirGuidanceResponse;
    
    // Add an already existing FhirGuidanceResponse to the end of the list.
    function AddItem(value : TFhirGuidanceResponse) : TFhirGuidanceResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirGuidanceResponse) : Integer;
    
    // Insert FhirGuidanceResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirGuidanceResponse;
    
    // Insert an existing FhirGuidanceResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirGuidanceResponse);
    
    // Get the iIndexth FhirGuidanceResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirGuidanceResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirGuidanceResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirGuidanceResponses[index : Integer] : TFhirGuidanceResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_LINKAGE}
  // Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
  TFhirLinkageItem = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FResource : TFhirReference;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirLinkageTypeEnum;
    procedure SetType_ST(value : TFhirLinkageTypeEnum);
    procedure SetResource(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLinkageItem; overload;
    function Clone : TFhirLinkageItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Distinguishes which item is "source of truth" (if any) and which items are no longer considered to be current representations.
    property type_ : TFhirLinkageTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The resource instance being linked as part of the group. (defined for API consistency)
    property resource : TFhirReference read FResource write SetResource;
    // The resource instance being linked as part of the group.
    property resourceElement : TFhirReference read FResource write SetResource;

  end;

  TFhirLinkageItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLinkageItemList;
    function GetCurrent : TFhirLinkageItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLinkageItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLinkageItem read GetCurrent;
  end;

  TFhirLinkageItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLinkageItem;
    procedure SetItemN(index : Integer; value : TFhirLinkageItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLinkageItemList; overload;
    function Clone : TFhirLinkageItemList; overload;
    function GetEnumerator : TFhirLinkageItemListEnumerator;
    
    //  Add a FhirLinkageItem to the end of the list.
    function Append : TFhirLinkageItem;
    
    // Add an already existing FhirLinkageItem to the end of the list.
    function AddItem(value : TFhirLinkageItem) : TFhirLinkageItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLinkageItem) : Integer;
    
    // Insert FhirLinkageItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLinkageItem;
    
    // Insert an existing FhirLinkageItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLinkageItem);
    
    // Get the iIndexth FhirLinkageItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLinkageItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLinkageItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLinkageItems[index : Integer] : TFhirLinkageItem read GetItemN write SetItemN; default;
  End;

  // Identifies two or more records (resource instances) that refer to the same real-world "occurrence".
  TFhirLinkage = class (TFhirDomainResource)
  protected
    FActive : TFhirBoolean;
    FAuthor : TFhirReference;
    FitemList : TFhirLinkageItemList;
    procedure SetActive(value : TFhirBoolean);
    function GetActiveST : Boolean;
    procedure SetActiveST(value : Boolean);
    procedure SetAuthor(value : TFhirReference);
    function GetItemList : TFhirLinkageItemList;
    function GetHasItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirLinkage; overload;
    function Clone : TFhirLinkage; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates whether the asserted set of linkages are considered to be "in effect".
    property active : Boolean read GetActiveST write SetActiveST;
    // Indicates whether the asserted set of linkages are considered to be "in effect".
    property activeElement : TFhirBoolean read FActive write SetActive;

    // Typed access to Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Identifies the user or organization responsible for asserting the linkages as well as the user or organization who establishes the context in which the nature of each linkage is evaluated.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Identifies which record considered as the reference to the same real-world occurrence as well as how the items should be evaluated within the collection of linked items.
    property itemList : TFhirLinkageItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirLinkageListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirLinkageList;
    function GetCurrent : TFhirLinkage;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirLinkageList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirLinkage read GetCurrent;
  end;

  TFhirLinkageList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirLinkage;
    procedure SetItemN(index : Integer; value : TFhirLinkage);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirLinkageList; overload;
    function Clone : TFhirLinkageList; overload;
    function GetEnumerator : TFhirLinkageListEnumerator;
    
    //  Add a FhirLinkage to the end of the list.
    function Append : TFhirLinkage;
    
    // Add an already existing FhirLinkage to the end of the list.
    function AddItem(value : TFhirLinkage) : TFhirLinkage; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirLinkage) : Integer;
    
    // Insert FhirLinkage before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirLinkage;
    
    // Insert an existing FhirLinkage before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirLinkage);
    
    // Get the iIndexth FhirLinkage. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirLinkage);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirLinkage;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLinkages[index : Integer] : TFhirLinkage read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
  // Entries in this list.
  TFhirListEntry = class (TFhirBackboneElement)
  protected
    FFlag : TFhirCodeableConcept;
    FDeleted : TFhirBoolean;
    FDate : TFhirDateTime;
    FItem : TFhirReference;
    procedure SetFlag(value : TFhirCodeableConcept);
    procedure SetDeleted(value : TFhirBoolean);
    function GetDeletedST : Boolean;
    procedure SetDeletedST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetItem(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirListEntry; overload;
    function Clone : TFhirListEntry; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The flag allows the system constructing the list to indicate the role and significance of the item in the list. (defined for API consistency)
    property flag : TFhirCodeableConcept read FFlag write SetFlag;
    // The flag allows the system constructing the list to indicate the role and significance of the item in the list.
    property flagElement : TFhirCodeableConcept read FFlag write SetFlag;

    // Typed access to True if this item is marked as deleted in the list.
    property deleted : Boolean read GetDeletedST write SetDeletedST;
    // True if this item is marked as deleted in the list.
    property deletedElement : TFhirBoolean read FDeleted write SetDeleted;

    // Typed access to When this item was added to the list.
    property date : TFslDateTime read GetDateST write SetDateST;
    // When this item was added to the list.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to A reference to the actual resource from which data was derived. (defined for API consistency)
    property item : TFhirReference read FItem write SetItem;
    // A reference to the actual resource from which data was derived.
    property itemElement : TFhirReference read FItem write SetItem;

  end;

  TFhirListEntryListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListEntryList;
    function GetCurrent : TFhirListEntry;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirListEntryList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirListEntry read GetCurrent;
  end;

  TFhirListEntryList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirListEntry;
    procedure SetItemN(index : Integer; value : TFhirListEntry);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirListEntryList; overload;
    function Clone : TFhirListEntryList; overload;
    function GetEnumerator : TFhirListEntryListEnumerator;
    
    //  Add a FhirListEntry to the end of the list.
    function Append : TFhirListEntry;
    
    // Add an already existing FhirListEntry to the end of the list.
    function AddItem(value : TFhirListEntry) : TFhirListEntry; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirListEntry) : Integer;
    
    // Insert FhirListEntry before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirListEntry;
    
    // Insert an existing FhirListEntry before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirListEntry);
    
    // Get the iIndexth FhirListEntry. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirListEntry);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirListEntry;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirListEntries[index : Integer] : TFhirListEntry read GetItemN write SetItemN; default;
  End;

  // A list is a curated collection of resources.
  TFhirList = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FMode : TFhirEnum;
    FTitle : TFhirString;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FDate : TFhirDateTime;
    FSource : TFhirReference;
    FOrderedBy : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FentryList : TFhirListEntryList;
    FEmptyReason : TFhirCodeableConcept;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirListStatusEnum;
    procedure SetStatusST(value : TFhirListStatusEnum);
    procedure SetMode(value : TFhirEnum);
    function GetModeST : TFhirListModeEnum;
    procedure SetModeST(value : TFhirListModeEnum);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetSource(value : TFhirReference);
    procedure SetOrderedBy(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetEntryList : TFhirListEntryList;
    function GetHasEntryList : Boolean;
    procedure SetEmptyReason(value : TFhirCodeableConcept);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirList; overload;
    function Clone : TFhirList; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifier for the List assigned for business purposes outside the context of FHIR.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Indicates the current state of this list.
    property status : TFhirListStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // How this list was prepared - whether it is a working list that is suitable for being maintained on an ongoing basis, or if it represents a snapshot of a list of items from another source, or whether it is a prepared list where items may be marked as added, modified or deleted.
    property mode : TFhirListModeEnum read GetModeST write SetModeST;
    property modeElement : TFhirEnum read FMode write SetMode;

    // Typed access to A label for the list assigned by the author.
    property title : String read GetTitleST write SetTitleST;
    // A label for the list assigned by the author.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to This code defines the purpose of the list - why it was created. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // This code defines the purpose of the list - why it was created.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The common subject (or patient) of the resources that are in the list if there is one. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The common subject (or patient) of the resources that are in the list if there is one.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The encounter that is the context in which this list was created. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The encounter that is the context in which this list was created.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date that the list was prepared.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date that the list was prepared.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // The entity responsible for deciding what the contents of the list were. Where the list was created by a human, this is the same as the author of the list.
    property sourceElement : TFhirReference read FSource write SetSource;

    // Typed access to What order applies to the items in the list. (defined for API consistency)
    property orderedBy : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;
    // What order applies to the items in the list.
    property orderedByElement : TFhirCodeableConcept read FOrderedBy write SetOrderedBy;

    // Comments that apply to the overall list.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Entries in this list.
    property entryList : TFhirListEntryList read GetEntryList;
    property hasEntryList : boolean read GetHasEntryList;

    // Typed access to If the list is empty, why the list is empty. (defined for API consistency)
    property emptyReason : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;
    // If the list is empty, why the list is empty.
    property emptyReasonElement : TFhirCodeableConcept read FEmptyReason write SetEmptyReason;

  end;

  TFhirListListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirListList;
    function GetCurrent : TFhirList;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirListList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirList read GetCurrent;
  end;

  TFhirListList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirList;
    procedure SetItemN(index : Integer; value : TFhirList);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirListList; overload;
    function Clone : TFhirListList; overload;
    function GetEnumerator : TFhirListListEnumerator;
    
    //  Add a FhirList to the end of the list.
    function Append : TFhirList;
    
    // Add an already existing FhirList to the end of the list.
    function AddItem(value : TFhirList) : TFhirList; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirList) : Integer;
    
    // Insert FhirList before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirList;
    
    // Insert an existing FhirList before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirList);
    
    // Get the iIndexth FhirList. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirList);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirList;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirLists[index : Integer] : TFhirList read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_MEASUREREPORT}
  // The results of the calculation, one for each population group in the measure.
  TFhirMeasureReportGroup = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FpopulationList : TFhirMeasureReportGroupPopulationList;
    FMeasureScore : TFhirQuantity;
    FstratifierList : TFhirMeasureReportGroupStratifierList;
    procedure SetCode(value : TFhirCodeableConcept);
    function GetPopulationList : TFhirMeasureReportGroupPopulationList;
    function GetHasPopulationList : Boolean;
    procedure SetMeasureScore(value : TFhirQuantity);
    function GetStratifierList : TFhirMeasureReportGroupStratifierList;
    function GetHasStratifierList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroup; overload;
    function Clone : TFhirMeasureReportGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The meaning of the population group as defined in the measure definition. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The meaning of the population group as defined in the measure definition.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // The populations that make up the population group, one for each type of population appropriate for the measure.
    property populationList : TFhirMeasureReportGroupPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group. (defined for API consistency)
    property measureScore : TFhirQuantity read FMeasureScore write SetMeasureScore;
    // The measure score for this population group, calculated as appropriate for the measure type and scoring method, and based on the contents of the populations defined in the group.
    property measureScoreElement : TFhirQuantity read FMeasureScore write SetMeasureScore;

    // When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
    property stratifierList : TFhirMeasureReportGroupStratifierList read GetStratifierList;
    property hasStratifierList : boolean read GetHasStratifierList;

  end;

  TFhirMeasureReportGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupList;
    function GetCurrent : TFhirMeasureReportGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroup read GetCurrent;
  end;

  TFhirMeasureReportGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroup;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupList; overload;
    function Clone : TFhirMeasureReportGroupList; overload;
    function GetEnumerator : TFhirMeasureReportGroupListEnumerator;
    
    //  Add a FhirMeasureReportGroup to the end of the list.
    function Append : TFhirMeasureReportGroup;
    
    // Add an already existing FhirMeasureReportGroup to the end of the list.
    function AddItem(value : TFhirMeasureReportGroup) : TFhirMeasureReportGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroup) : Integer;
    
    // Insert FhirMeasureReportGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroup;
    
    // Insert an existing FhirMeasureReportGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroup);
    
    // Get the iIndexth FhirMeasureReportGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroups[index : Integer] : TFhirMeasureReportGroup read GetItemN write SetItemN; default;
  End;

  // The populations that make up the population group, one for each type of population appropriate for the measure.
  TFhirMeasureReportGroupPopulation = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FCount : TFhirInteger;
    FSubjectResults : TFhirReference;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetCount(value : TFhirInteger);
    function GetCountST : String;
    procedure SetCountST(value : String);
    procedure SetSubjectResults(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupPopulation; overload;
    function Clone : TFhirMeasureReportGroupPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the population. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the population.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The number of members of the population.
    property count : String read GetCountST write SetCountST;
    // The number of members of the population.
    property countElement : TFhirInteger read FCount write SetCount;

    // Typed access to This element refers to a List of subject level MeasureReport resources, one for each subject in this population. (defined for API consistency)
    property subjectResults : TFhirReference read FSubjectResults write SetSubjectResults;
    // This element refers to a List of subject level MeasureReport resources, one for each subject in this population.
    property subjectResultsElement : TFhirReference read FSubjectResults write SetSubjectResults;

  end;

  TFhirMeasureReportGroupPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupPopulationList;
    function GetCurrent : TFhirMeasureReportGroupPopulation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupPopulation read GetCurrent;
  end;

  TFhirMeasureReportGroupPopulationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupPopulationList; overload;
    function Clone : TFhirMeasureReportGroupPopulationList; overload;
    function GetEnumerator : TFhirMeasureReportGroupPopulationListEnumerator;
    
    //  Add a FhirMeasureReportGroupPopulation to the end of the list.
    function Append : TFhirMeasureReportGroupPopulation;
    
    // Add an already existing FhirMeasureReportGroupPopulation to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupPopulation) : TFhirMeasureReportGroupPopulation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupPopulation) : Integer;
    
    // Insert FhirMeasureReportGroupPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupPopulation;
    
    // Insert an existing FhirMeasureReportGroupPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupPopulation);
    
    // Get the iIndexth FhirMeasureReportGroupPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupPopulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupPopulation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupPopulations[index : Integer] : TFhirMeasureReportGroupPopulation read GetItemN write SetItemN; default;
  End;

  // When a measure includes multiple stratifiers, there will be a stratifier group for each stratifier defined by the measure.
  TFhirMeasureReportGroupStratifier = class (TFhirBackboneElement)
  protected
    FcodeList : TFhirCodeableConceptList;
    FstratumList : TFhirMeasureReportGroupStratifierStratumList;
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetStratumList : TFhirMeasureReportGroupStratifierStratumList;
    function GetHasStratumList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifier; overload;
    function Clone : TFhirMeasureReportGroupStratifier; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The meaning of this stratifier, as defined in the measure definition.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
    property stratumList : TFhirMeasureReportGroupStratifierStratumList read GetStratumList;
    property hasStratumList : boolean read GetHasStratumList;

  end;

  TFhirMeasureReportGroupStratifierListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierList;
    function GetCurrent : TFhirMeasureReportGroupStratifier;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifier read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifier;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifier);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupStratifierList; overload;
    function Clone : TFhirMeasureReportGroupStratifierList; overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierListEnumerator;
    
    //  Add a FhirMeasureReportGroupStratifier to the end of the list.
    function Append : TFhirMeasureReportGroupStratifier;
    
    // Add an already existing FhirMeasureReportGroupStratifier to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupStratifier) : TFhirMeasureReportGroupStratifier; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifier) : Integer;
    
    // Insert FhirMeasureReportGroupStratifier before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifier;
    
    // Insert an existing FhirMeasureReportGroupStratifier before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifier);
    
    // Get the iIndexth FhirMeasureReportGroupStratifier. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifier);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifier;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupStratifiers[index : Integer] : TFhirMeasureReportGroupStratifier read GetItemN write SetItemN; default;
  End;

  // This element contains the results for a single stratum within the stratifier. For example, when stratifying on administrative gender, there will be four strata, one for each possible gender value.
  TFhirMeasureReportGroupStratifierStratum = class (TFhirBackboneElement)
  protected
    FValue : TFhirCodeableConcept;
    FcomponentList : TFhirMeasureReportGroupStratifierStratumComponentList;
    FpopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    FMeasureScore : TFhirQuantity;
    procedure SetValue(value : TFhirCodeableConcept);
    function GetComponentList : TFhirMeasureReportGroupStratifierStratumComponentList;
    function GetHasComponentList : Boolean;
    function GetPopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    function GetHasPopulationList : Boolean;
    procedure SetMeasureScore(value : TFhirQuantity);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratum; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratum; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The value for this stratum, expressed as a CodeableConcept. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique. (defined for API consistency)
    property value : TFhirCodeableConcept read FValue write SetValue;
    // The value for this stratum, expressed as a CodeableConcept. When defining stratifiers on complex values, the value must be rendered such that the value for each stratum within the stratifier is unique.
    property valueElement : TFhirCodeableConcept read FValue write SetValue;

    // A stratifier component value.
    property componentList : TFhirMeasureReportGroupStratifierStratumComponentList read GetComponentList;
    property hasComponentList : boolean read GetHasComponentList;

    // The populations that make up the stratum, one for each type of population appropriate to the measure.
    property populationList : TFhirMeasureReportGroupStratifierStratumPopulationList read GetPopulationList;
    property hasPopulationList : boolean read GetHasPopulationList;

    // Typed access to The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum. (defined for API consistency)
    property measureScore : TFhirQuantity read FMeasureScore write SetMeasureScore;
    // The measure score for this stratum, calculated as appropriate for the measure type and scoring method, and based on only the members of this stratum.
    property measureScoreElement : TFhirQuantity read FMeasureScore write SetMeasureScore;

  end;

  TFhirMeasureReportGroupStratifierStratumListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratum;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratum read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupStratifierStratumList; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumList; overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumListEnumerator;
    
    //  Add a FhirMeasureReportGroupStratifierStratum to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratum;
    
    // Add an already existing FhirMeasureReportGroupStratifierStratum to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupStratifierStratum) : TFhirMeasureReportGroupStratifierStratum; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratum) : Integer;
    
    // Insert FhirMeasureReportGroupStratifierStratum before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    
    // Insert an existing FhirMeasureReportGroupStratifierStratum before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
    
    // Get the iIndexth FhirMeasureReportGroupStratifierStratum. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratum);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratum;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupStratifierStrata[index : Integer] : TFhirMeasureReportGroupStratifierStratum read GetItemN write SetItemN; default;
  End;

  // A stratifier component value.
  TFhirMeasureReportGroupStratifierStratumComponent = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FValue : TFhirCodeableConcept;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratumComponent; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumComponent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The code for the stratum component value. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The code for the stratum component value.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The stratum component value. (defined for API consistency)
    property value : TFhirCodeableConcept read FValue write SetValue;
    // The stratum component value.
    property valueElement : TFhirCodeableConcept read FValue write SetValue;

  end;

  TFhirMeasureReportGroupStratifierStratumComponentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumComponentList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratumComponent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumComponentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratumComponent read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumComponentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratumComponent;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratumComponent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupStratifierStratumComponentList; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumComponentList; overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumComponentListEnumerator;
    
    //  Add a FhirMeasureReportGroupStratifierStratumComponent to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratumComponent;
    
    // Add an already existing FhirMeasureReportGroupStratifierStratumComponent to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupStratifierStratumComponent) : TFhirMeasureReportGroupStratifierStratumComponent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratumComponent) : Integer;
    
    // Insert FhirMeasureReportGroupStratifierStratumComponent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratumComponent;
    
    // Insert an existing FhirMeasureReportGroupStratifierStratumComponent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratumComponent);
    
    // Get the iIndexth FhirMeasureReportGroupStratifierStratumComponent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratumComponent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratumComponent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupStratifierStratumComponents[index : Integer] : TFhirMeasureReportGroupStratifierStratumComponent read GetItemN write SetItemN; default;
  End;

  // The populations that make up the stratum, one for each type of population appropriate to the measure.
  TFhirMeasureReportGroupStratifierStratumPopulation = class (TFhirBackboneElement)
  protected
    FCode : TFhirCodeableConcept;
    FCount : TFhirInteger;
    FSubjectResults : TFhirReference;
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetCount(value : TFhirInteger);
    function GetCountST : String;
    procedure SetCountST(value : String);
    procedure SetSubjectResults(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The type of the population. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // The type of the population.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The number of members of the population in this stratum.
    property count : String read GetCountST write SetCountST;
    // The number of members of the population in this stratum.
    property countElement : TFhirInteger read FCount write SetCount;

    // Typed access to This element refers to a List of subject level MeasureReport resources, one for each subject in this population in this stratum. (defined for API consistency)
    property subjectResults : TFhirReference read FSubjectResults write SetSubjectResults;
    // This element refers to a List of subject level MeasureReport resources, one for each subject in this population in this stratum.
    property subjectResultsElement : TFhirReference read FSubjectResults write SetSubjectResults;

  end;

  TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportGroupStratifierStratumPopulationList;
    function GetCurrent : TFhirMeasureReportGroupStratifierStratumPopulation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportGroupStratifierStratumPopulationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReportGroupStratifierStratumPopulation read GetCurrent;
  end;

  TFhirMeasureReportGroupStratifierStratumPopulationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    procedure SetItemN(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportGroupStratifierStratumPopulationList; overload;
    function Clone : TFhirMeasureReportGroupStratifierStratumPopulationList; overload;
    function GetEnumerator : TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator;
    
    //  Add a FhirMeasureReportGroupStratifierStratumPopulation to the end of the list.
    function Append : TFhirMeasureReportGroupStratifierStratumPopulation;
    
    // Add an already existing FhirMeasureReportGroupStratifierStratumPopulation to the end of the list.
    function AddItem(value : TFhirMeasureReportGroupStratifierStratumPopulation) : TFhirMeasureReportGroupStratifierStratumPopulation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReportGroupStratifierStratumPopulation) : Integer;
    
    // Insert FhirMeasureReportGroupStratifierStratumPopulation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    
    // Insert an existing FhirMeasureReportGroupStratifierStratumPopulation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
    
    // Get the iIndexth FhirMeasureReportGroupStratifierStratumPopulation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReportGroupStratifierStratumPopulation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReportGroupStratifierStratumPopulation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReportGroupStratifierStratumPopulations[index : Integer] : TFhirMeasureReportGroupStratifierStratumPopulation read GetItemN write SetItemN; default;
  End;

  // The MeasureReport resource contains the results of the calculation of a measure; and optionally a reference to the resources involved in that calculation.
  TFhirMeasureReport = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FType_ : TFhirEnum;
    FMeasure : TFhirCanonical;
    FSubject : TFhirReference;
    FDate : TFhirDateTime;
    FReporter : TFhirReference;
    FPeriod : TFhirPeriod;
    FImprovementNotation : TFhirCodeableConcept;
    FgroupList : TFhirMeasureReportGroupList;
    FevaluatedResourceList : TFhirReferenceList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirMeasureReportStatusEnum;
    procedure SetStatusST(value : TFhirMeasureReportStatusEnum);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirMeasureReportTypeEnum;
    procedure SetType_ST(value : TFhirMeasureReportTypeEnum);
    procedure SetMeasure(value : TFhirCanonical);
    function GetMeasureST : String;
    procedure SetMeasureST(value : String);
    procedure SetSubject(value : TFhirReference);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetReporter(value : TFhirReference);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetImprovementNotation(value : TFhirCodeableConcept);
    function GetGroupList : TFhirMeasureReportGroupList;
    function GetHasGroupList : Boolean;
    function GetEvaluatedResourceList : TFhirReferenceList;
    function GetHasEvaluatedResourceList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMeasureReport; overload;
    function Clone : TFhirMeasureReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A formal identifier that is used to identify this MeasureReport when it is represented in other formats or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The MeasureReport status. No data will be available until the MeasureReport status is complete.
    property status : TFhirMeasureReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The type of measure report. This may be an individual report, which provides the score for the measure for an individual member of the population; a subject-listing, which returns the list of members that meet the various criteria in the measure; a summary report, which returns a population count for each of the criteria in the measure; or a data-collection, which enables the MeasureReport to be used to exchange the data-of-interest for a quality measure.
    property type_ : TFhirMeasureReportTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to A reference to the Measure that was calculated to produce this report.
    property measure : String read GetMeasureST write SetMeasureST;
    // A reference to the Measure that was calculated to produce this report.
    property measureElement : TFhirCanonical read FMeasure write SetMeasure;

    // Typed access to Optional subject identifying the individual or individuals the report is for. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // Optional subject identifying the individual or individuals the report is for.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The date this measure report was generated.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date this measure report was generated.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The individual, location, or organization that is reporting the data. (defined for API consistency)
    property reporter : TFhirReference read FReporter write SetReporter;
    // The individual, location, or organization that is reporting the data.
    property reporterElement : TFhirReference read FReporter write SetReporter;

    // Typed access to The reporting period for which the report was calculated. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The reporting period for which the report was calculated.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Whether improvement in the measure is noted by an increase or decrease in the measure score. (defined for API consistency)
    property improvementNotation : TFhirCodeableConcept read FImprovementNotation write SetImprovementNotation;
    // Whether improvement in the measure is noted by an increase or decrease in the measure score.
    property improvementNotationElement : TFhirCodeableConcept read FImprovementNotation write SetImprovementNotation;

    // The results of the calculation, one for each population group in the measure.
    property groupList : TFhirMeasureReportGroupList read GetGroupList;
    property hasGroupList : boolean read GetHasGroupList;

    // A reference to a Bundle containing the Resources that were used in the calculation of this measure.
    property evaluatedResourceList : TFhirReferenceList read GetEvaluatedResourceList;
    property hasEvaluatedResourceList : boolean read GetHasEvaluatedResourceList;

  end;

  TFhirMeasureReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMeasureReportList;
    function GetCurrent : TFhirMeasureReport;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMeasureReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMeasureReport read GetCurrent;
  end;

  TFhirMeasureReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMeasureReport;
    procedure SetItemN(index : Integer; value : TFhirMeasureReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMeasureReportList; overload;
    function Clone : TFhirMeasureReportList; overload;
    function GetEnumerator : TFhirMeasureReportListEnumerator;
    
    //  Add a FhirMeasureReport to the end of the list.
    function Append : TFhirMeasureReport;
    
    // Add an already existing FhirMeasureReport to the end of the list.
    function AddItem(value : TFhirMeasureReport) : TFhirMeasureReport; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMeasureReport) : Integer;
    
    // Insert FhirMeasureReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMeasureReport;
    
    // Insert an existing FhirMeasureReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMeasureReport);
    
    // Get the iIndexth FhirMeasureReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMeasureReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMeasureReport;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMeasureReports[index : Integer] : TFhirMeasureReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MESSAGEHEADER}
  // The destination application which the message is intended for.
  TFhirMessageHeaderDestination = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FTarget : TFhirReference;
    FEndpoint : TFhirUrl;
    FReceiver : TFhirReference;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTarget(value : TFhirReference);
    procedure SetEndpoint(value : TFhirUrl);
    function GetEndpointST : String;
    procedure SetEndpointST(value : String);
    procedure SetReceiver(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderDestination; overload;
    function Clone : TFhirMessageHeaderDestination; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable name for the target system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the target system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Identifies the target end system in situations where the initial message transmission is to an intermediary system. (defined for API consistency)
    property target : TFhirReference read FTarget write SetTarget;
    // Identifies the target end system in situations where the initial message transmission is to an intermediary system.
    property targetElement : TFhirReference read FTarget write SetTarget;

    // Typed access to Indicates where the message should be routed to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Indicates where the message should be routed to.
    property endpointElement : TFhirUrl read FEndpoint write SetEndpoint;

    // Typed access to Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient. (defined for API consistency)
    property receiver : TFhirReference read FReceiver write SetReceiver;
    // Allows data conveyed by a message to be addressed to a particular person or department when routing to a specific application isn't sufficient.
    property receiverElement : TFhirReference read FReceiver write SetReceiver;

  end;

  TFhirMessageHeaderDestinationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderDestinationList;
    function GetCurrent : TFhirMessageHeaderDestination;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderDestinationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderDestination read GetCurrent;
  end;

  TFhirMessageHeaderDestinationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderDestination;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderDestination);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageHeaderDestinationList; overload;
    function Clone : TFhirMessageHeaderDestinationList; overload;
    function GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
    
    //  Add a FhirMessageHeaderDestination to the end of the list.
    function Append : TFhirMessageHeaderDestination;
    
    // Add an already existing FhirMessageHeaderDestination to the end of the list.
    function AddItem(value : TFhirMessageHeaderDestination) : TFhirMessageHeaderDestination; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderDestination) : Integer;
    
    // Insert FhirMessageHeaderDestination before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderDestination;
    
    // Insert an existing FhirMessageHeaderDestination before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderDestination);
    
    // Get the iIndexth FhirMessageHeaderDestination. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderDestination);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderDestination;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageHeaderDestinations[index : Integer] : TFhirMessageHeaderDestination read GetItemN write SetItemN; default;
  End;

  // The source application from which this message originated.
  TFhirMessageHeaderSource = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FSoftware : TFhirString;
    FVersion : TFhirString;
    FContact : TFhirContactPoint;
    FEndpoint : TFhirUrl;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetSoftware(value : TFhirString);
    function GetSoftwareST : String;
    procedure SetSoftwareST(value : String);
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetContact(value : TFhirContactPoint);
    procedure SetEndpoint(value : TFhirUrl);
    function GetEndpointST : String;
    procedure SetEndpointST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderSource; overload;
    function Clone : TFhirMessageHeaderSource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Human-readable name for the source system.
    property name : String read GetNameST write SetNameST;
    // Human-readable name for the source system.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to May include configuration or other information useful in debugging.
    property software : String read GetSoftwareST write SetSoftwareST;
    // May include configuration or other information useful in debugging.
    property softwareElement : TFhirString read FSoftware write SetSoftware;

    // Typed access to Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property version : String read GetVersionST write SetVersionST;
    // Can convey versions of multiple systems in situations where a message passes through multiple hands.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to An e-mail, phone, website or other contact point to use to resolve issues with message communications. (defined for API consistency)
    property contact : TFhirContactPoint read FContact write SetContact;
    // An e-mail, phone, website or other contact point to use to resolve issues with message communications.
    property contactElement : TFhirContactPoint read FContact write SetContact;

    // Typed access to Identifies the routing target to send acknowledgements to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // Identifies the routing target to send acknowledgements to.
    property endpointElement : TFhirUrl read FEndpoint write SetEndpoint;

  end;

  TFhirMessageHeaderSourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderSourceList;
    function GetCurrent : TFhirMessageHeaderSource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderSourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderSource read GetCurrent;
  end;

  TFhirMessageHeaderSourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderSource;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderSource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageHeaderSourceList; overload;
    function Clone : TFhirMessageHeaderSourceList; overload;
    function GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
    
    //  Add a FhirMessageHeaderSource to the end of the list.
    function Append : TFhirMessageHeaderSource;
    
    // Add an already existing FhirMessageHeaderSource to the end of the list.
    function AddItem(value : TFhirMessageHeaderSource) : TFhirMessageHeaderSource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderSource) : Integer;
    
    // Insert FhirMessageHeaderSource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderSource;
    
    // Insert an existing FhirMessageHeaderSource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderSource);
    
    // Get the iIndexth FhirMessageHeaderSource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderSource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderSource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageHeaderSources[index : Integer] : TFhirMessageHeaderSource read GetItemN write SetItemN; default;
  End;

  // Information about the message that this message is a response to.  Only present if this message is a response.
  TFhirMessageHeaderResponse = class (TFhirBackboneElement)
  protected
    FIdentifier : TFhirId;
    FCode : TFhirEnum;
    FDetails : TFhirReference;
    procedure SetIdentifier(value : TFhirId);
    function GetIdentifierST : String;
    procedure SetIdentifierST(value : String);
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirResponseTypeEnum;
    procedure SetCodeST(value : TFhirResponseTypeEnum);
    procedure SetDetails(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeaderResponse; overload;
    function Clone : TFhirMessageHeaderResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The MessageHeader.id of the message to which this message is a response.
    property identifier : String read GetIdentifierST write SetIdentifierST;
    // The MessageHeader.id of the message to which this message is a response.
    property identifierElement : TFhirId read FIdentifier write SetIdentifier;

    // Code that identifies the type of response to the message - whether it was successful or not, and whether it should be resent or not.
    property code : TFhirResponseTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Full details of any issues found in the message. (defined for API consistency)
    property details : TFhirReference read FDetails write SetDetails;
    // Full details of any issues found in the message.
    property detailsElement : TFhirReference read FDetails write SetDetails;

  end;

  TFhirMessageHeaderResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderResponseList;
    function GetCurrent : TFhirMessageHeaderResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeaderResponse read GetCurrent;
  end;

  TFhirMessageHeaderResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeaderResponse;
    procedure SetItemN(index : Integer; value : TFhirMessageHeaderResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageHeaderResponseList; overload;
    function Clone : TFhirMessageHeaderResponseList; overload;
    function GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
    
    //  Add a FhirMessageHeaderResponse to the end of the list.
    function Append : TFhirMessageHeaderResponse;
    
    // Add an already existing FhirMessageHeaderResponse to the end of the list.
    function AddItem(value : TFhirMessageHeaderResponse) : TFhirMessageHeaderResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeaderResponse) : Integer;
    
    // Insert FhirMessageHeaderResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeaderResponse;
    
    // Insert an existing FhirMessageHeaderResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeaderResponse);
    
    // Get the iIndexth FhirMessageHeaderResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeaderResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeaderResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageHeaderResponses[index : Integer] : TFhirMessageHeaderResponse read GetItemN write SetItemN; default;
  End;

  // The header for a message exchange that is either requesting or responding to an action.  The reference(s) that are the subject of the action as well as other information related to the action are typically transmitted in a bundle in which the MessageHeader resource instance is the first resource in the bundle.
  TFhirMessageHeader = class (TFhirDomainResource)
  protected
    FEvent : TFhirDataType;
    FdestinationList : TFhirMessageHeaderDestinationList;
    FSender : TFhirReference;
    FEnterer : TFhirReference;
    FAuthor : TFhirReference;
    FSource : TFhirMessageHeaderSource;
    FResponsible : TFhirReference;
    FReason : TFhirCodeableConcept;
    FResponse : TFhirMessageHeaderResponse;
    FfocusList : TFhirReferenceList;
    FDefinition : TFhirCanonical;
    procedure SetEvent(value : TFhirDataType);
    function GetDestinationList : TFhirMessageHeaderDestinationList;
    function GetHasDestinationList : Boolean;
    procedure SetSender(value : TFhirReference);
    procedure SetEnterer(value : TFhirReference);
    procedure SetAuthor(value : TFhirReference);
    procedure SetSource(value : TFhirMessageHeaderSource);
    procedure SetResponsible(value : TFhirReference);
    procedure SetReason(value : TFhirCodeableConcept);
    procedure SetResponse(value : TFhirMessageHeaderResponse);
    function GetFocusList : TFhirReferenceList;
    function GetHasFocusList : Boolean;
    procedure SetDefinition(value : TFhirCanonical);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirMessageHeader; overload;
    function Clone : TFhirMessageHeader; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://terminology.hl7.org/CodeSystem/message-events".  Alternatively uri to the EventDefinition. (defined for API consistency)
    property event : TFhirDataType read FEvent write SetEvent;
    // Code that identifies the event this message represents and connects it with its definition. Events defined as part of the FHIR specification have the system value "http://terminology.hl7.org/CodeSystem/message-events".  Alternatively uri to the EventDefinition.
    property eventElement : TFhirDataType read FEvent write SetEvent;

    // The destination application which the message is intended for.
    property destinationList : TFhirMessageHeaderDestinationList read GetDestinationList;
    property hasDestinationList : boolean read GetHasDestinationList;

    // Typed access to Identifies the sending system to allow the use of a trust relationship. (defined for API consistency)
    property sender : TFhirReference read FSender write SetSender;
    // Identifies the sending system to allow the use of a trust relationship.
    property senderElement : TFhirReference read FSender write SetSender;

    // Typed access to The person or device that performed the data entry leading to this message. When there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions. (defined for API consistency)
    property enterer : TFhirReference read FEnterer write SetEnterer;
    // The person or device that performed the data entry leading to this message. When there is more than one candidate, pick the most proximal to the message. Can provide other enterers in extensions.
    property entererElement : TFhirReference read FEnterer write SetEnterer;

    // Typed access to The logical author of the message - the person or device that decided the described event should happen. When there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // The logical author of the message - the person or device that decided the described event should happen. When there is more than one candidate, pick the most proximal to the MessageHeader. Can provide other authors in extensions.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Typed access to The source application from which this message originated. (defined for API consistency)
    property source : TFhirMessageHeaderSource read FSource write SetSource;
    // The source application from which this message originated.
    property sourceElement : TFhirMessageHeaderSource read FSource write SetSource;

    // Typed access to The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party. (defined for API consistency)
    property responsible : TFhirReference read FResponsible write SetResponsible;
    // The person or organization that accepts overall responsibility for the contents of the message. The implication is that the message event happened under the policies of the responsible party.
    property responsibleElement : TFhirReference read FResponsible write SetResponsible;

    // Typed access to Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message. (defined for API consistency)
    property reason : TFhirCodeableConcept read FReason write SetReason;
    // Coded indication of the cause for the event - indicates  a reason for the occurrence of the event that is a focus of this message.
    property reasonElement : TFhirCodeableConcept read FReason write SetReason;

    // Typed access to Information about the message that this message is a response to.  Only present if this message is a response. (defined for API consistency)
    property response : TFhirMessageHeaderResponse read FResponse write SetResponse;
    // Information about the message that this message is a response to.  Only present if this message is a response.
    property responseElement : TFhirMessageHeaderResponse read FResponse write SetResponse;

    // The actual data of the message - a reference to the root/focus class of the event.
    property focusList : TFhirReferenceList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // Typed access to Permanent link to the MessageDefinition for this message.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // Permanent link to the MessageDefinition for this message.
    property definitionElement : TFhirCanonical read FDefinition write SetDefinition;

  end;

  TFhirMessageHeaderListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirMessageHeaderList;
    function GetCurrent : TFhirMessageHeader;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirMessageHeaderList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirMessageHeader read GetCurrent;
  end;

  TFhirMessageHeaderList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirMessageHeader;
    procedure SetItemN(index : Integer; value : TFhirMessageHeader);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirMessageHeaderList; overload;
    function Clone : TFhirMessageHeaderList; overload;
    function GetEnumerator : TFhirMessageHeaderListEnumerator;
    
    //  Add a FhirMessageHeader to the end of the list.
    function Append : TFhirMessageHeader;
    
    // Add an already existing FhirMessageHeader to the end of the list.
    function AddItem(value : TFhirMessageHeader) : TFhirMessageHeader; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirMessageHeader) : Integer;
    
    // Insert FhirMessageHeader before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirMessageHeader;
    
    // Insert an existing FhirMessageHeader before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirMessageHeader);
    
    // Get the iIndexth FhirMessageHeader. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirMessageHeader);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirMessageHeader;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirMessageHeaders[index : Integer] : TFhirMessageHeader read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_OPERATIONOUTCOME}
  // An error, warning, or information message that results from a system action.
  TFhirOperationOutcomeIssue = class (TFhirBackboneElement)
  protected
    FSeverity : TFhirEnum;
    FCode : TFhirEnum;
    FDetails : TFhirCodeableConcept;
    FDiagnostics : TFhirString;
    FlocationList : TFhirStringList;
    FexpressionList : TFhirStringList;
    procedure SetSeverity(value : TFhirEnum);
    function GetSeverityST : TFhirIssueSeverityEnum;
    procedure SetSeverityST(value : TFhirIssueSeverityEnum);
    procedure SetCode(value : TFhirEnum);
    function GetCodeST : TFhirIssueTypeEnum;
    procedure SetCodeST(value : TFhirIssueTypeEnum);
    procedure SetDetails(value : TFhirCodeableConcept);
    procedure SetDiagnostics(value : TFhirString);
    function GetDiagnosticsST : String;
    procedure SetDiagnosticsST(value : String);
    function GetLocationList : TFhirStringList;
    function GetHasLocationList : Boolean;
    function GetExpressionList : TFhirStringList;
    function GetHasExpressionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcomeIssue; overload;
    function Clone : TFhirOperationOutcomeIssue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Indicates whether the issue indicates a variation from successful processing.
    property severity : TFhirIssueSeverityEnum read GetSeverityST write SetSeverityST;
    property severityElement : TFhirEnum read FSeverity write SetSeverity;

    // Describes the type of the issue. The system that creates an OperationOutcome SHALL choose the most applicable code from the IssueType value set, and may additional provide its own code for the error in the details element.
    property code : TFhirIssueTypeEnum read GetCodeST write SetCodeST;
    property codeElement : TFhirEnum read FCode write SetCode;

    // Typed access to Additional details about the error. This may be a text description of the error or a system code that identifies the error. (defined for API consistency)
    property details : TFhirCodeableConcept read FDetails write SetDetails;
    // Additional details about the error. This may be a text description of the error or a system code that identifies the error.
    property detailsElement : TFhirCodeableConcept read FDetails write SetDetails;

    // Typed access to Additional diagnostic information about the issue.
    property diagnostics : String read GetDiagnosticsST write SetDiagnosticsST;
    // Additional diagnostic information about the issue.
    property diagnosticsElement : TFhirString read FDiagnostics write SetDiagnostics;

    // This element is deprecated because it is XML specific. It is replaced by issue.expression, which is format independent, and simpler to parse.   For resource issues, this will be a simple XPath limited to element names, repetition indicators and the default child accessor that identifies one of the elements in the resource that caused this issue to be raised.  For HTTP errors, will be "http." + the parameter name.
    property locationList : TFhirStringList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // A [simple subset of FHIRPath](fhirpath.html#simple) limited to element names, repetition indicators and the default child accessor that identifies one of the elements in the resource that caused this issue to be raised.
    property expressionList : TFhirStringList read GetExpressionList;
    property hasExpressionList : boolean read GetHasExpressionList;

  end;

  TFhirOperationOutcomeIssueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeIssueList;
    function GetCurrent : TFhirOperationOutcomeIssue;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeIssueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcomeIssue read GetCurrent;
  end;

  TFhirOperationOutcomeIssueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationOutcomeIssue;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcomeIssue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOperationOutcomeIssueList; overload;
    function Clone : TFhirOperationOutcomeIssueList; overload;
    function GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
    
    //  Add a FhirOperationOutcomeIssue to the end of the list.
    function Append : TFhirOperationOutcomeIssue;
    
    // Add an already existing FhirOperationOutcomeIssue to the end of the list.
    function AddItem(value : TFhirOperationOutcomeIssue) : TFhirOperationOutcomeIssue; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcomeIssue) : Integer;
    
    // Insert FhirOperationOutcomeIssue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcomeIssue;
    
    // Insert an existing FhirOperationOutcomeIssue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcomeIssue);
    
    // Get the iIndexth FhirOperationOutcomeIssue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcomeIssue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcomeIssue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOperationOutcomeIssues[index : Integer] : TFhirOperationOutcomeIssue read GetItemN write SetItemN; default;
  End;

  // A collection of error, warning, or information messages that result from a system action.
  TFhirOperationOutcome = class (TFhirDomainResource)
  protected
    FissueList : TFhirOperationOutcomeIssueList;
    function GetIssueList : TFhirOperationOutcomeIssueList;
    function GetHasIssueList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirOperationOutcome; overload;
    function Clone : TFhirOperationOutcome; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // An error, warning, or information message that results from a system action.
    property issueList : TFhirOperationOutcomeIssueList read GetIssueList;
    property hasIssueList : boolean read GetHasIssueList;

  end;

  TFhirOperationOutcomeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirOperationOutcomeList;
    function GetCurrent : TFhirOperationOutcome;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirOperationOutcomeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirOperationOutcome read GetCurrent;
  end;

  TFhirOperationOutcomeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirOperationOutcome;
    procedure SetItemN(index : Integer; value : TFhirOperationOutcome);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirOperationOutcomeList; overload;
    function Clone : TFhirOperationOutcomeList; overload;
    function GetEnumerator : TFhirOperationOutcomeListEnumerator;
    
    //  Add a FhirOperationOutcome to the end of the list.
    function Append : TFhirOperationOutcome;
    
    // Add an already existing FhirOperationOutcome to the end of the list.
    function AddItem(value : TFhirOperationOutcome) : TFhirOperationOutcome; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirOperationOutcome) : Integer;
    
    // Insert FhirOperationOutcome before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirOperationOutcome;
    
    // Insert an existing FhirOperationOutcome before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirOperationOutcome);
    
    // Get the iIndexth FhirOperationOutcome. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirOperationOutcome);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirOperationOutcome;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirOperationOutcomes[index : Integer] : TFhirOperationOutcome read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_PARAMETERS}
  // A parameter passed to or received from the operation.
  TFhirParametersParameter = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FValue : TFhirDataType;
    FResource : TFhirResource;
    FpartList : TFhirParametersParameterList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetValue(value : TFhirDataType);
    procedure SetResource(value : TFhirResource);
    function GetPartList : TFhirParametersParameterList;
    function GetHasPartList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParametersParameter; overload;
    function Clone : TFhirParametersParameter; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the parameter (reference to the operation definition).
    property name : String read GetNameST write SetNameST;
    // The name of the parameter (reference to the operation definition).
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Conveys the content if the parameter is a data type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // Conveys the content if the parameter is a data type.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Typed access to If the parameter is a whole resource. (defined for API consistency)
    property resource : TFhirResource read FResource write SetResource;
    // If the parameter is a whole resource.
    property resourceElement : TFhirResource read FResource write SetResource;

    // A named part of a multi-part parameter.
    property partList : TFhirParametersParameterList read GetPartList;
    property hasPartList : boolean read GetHasPartList;

  end;

  TFhirParametersParameterListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersParameterList;
    function GetCurrent : TFhirParametersParameter;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirParametersParameterList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParametersParameter read GetCurrent;
  end;

  TFhirParametersParameterList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirParametersParameter;
    procedure SetItemN(index : Integer; value : TFhirParametersParameter);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirParametersParameterList; overload;
    function Clone : TFhirParametersParameterList; overload;
    function GetEnumerator : TFhirParametersParameterListEnumerator;
    
    //  Add a FhirParametersParameter to the end of the list.
    function Append : TFhirParametersParameter;
    
    // Add an already existing FhirParametersParameter to the end of the list.
    function AddItem(value : TFhirParametersParameter) : TFhirParametersParameter; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParametersParameter) : Integer;
    
    // Insert FhirParametersParameter before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParametersParameter;
    
    // Insert an existing FhirParametersParameter before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParametersParameter);
    
    // Get the iIndexth FhirParametersParameter. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParametersParameter);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirParametersParameter;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirParametersParameters[index : Integer] : TFhirParametersParameter read GetItemN write SetItemN; default;
  End;

  // This resource is a non-persisted resource used to pass information into and back from an [operation](operations.html). It has no other use, and there is no RESTful endpoint associated with it.
  TFhirParameters = class (TFhirResource)
  protected
    FparameterList : TFhirParametersParameterList;
    function GetParameterList : TFhirParametersParameterList;
    function GetHasParameterList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirParameters; overload;
    function Clone : TFhirParameters; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A parameter passed to or received from the operation.
    property parameterList : TFhirParametersParameterList read GetParameterList;
    property hasParameterList : boolean read GetHasParameterList;

  end;

  TFhirParametersListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirParametersList;
    function GetCurrent : TFhirParameters;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirParametersList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirParameters read GetCurrent;
  end;

  TFhirParametersList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirParameters;
    procedure SetItemN(index : Integer; value : TFhirParameters);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirParametersList; overload;
    function Clone : TFhirParametersList; overload;
    function GetEnumerator : TFhirParametersListEnumerator;
    
    //  Add a FhirParameters to the end of the list.
    function Append : TFhirParameters;
    
    // Add an already existing FhirParameters to the end of the list.
    function AddItem(value : TFhirParameters) : TFhirParameters; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirParameters) : Integer;
    
    // Insert FhirParameters before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirParameters;
    
    // Insert an existing FhirParameters before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirParameters);
    
    // Get the iIndexth FhirParameters. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirParameters);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirParameters;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirParameters[index : Integer] : TFhirParameters read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PLANDEFINITION}
  // A goal describes an expected outcome that activities within the plan are intended to achieve. For example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, meeting the acceptance criteria for a test as specified by a quality specification, etc.
  TFhirPlanDefinitionGoal = class (TFhirBackboneElement)
  protected
    FCategory : TFhirCodeableConcept;
    FDescription : TFhirCodeableConcept;
    FPriority : TFhirCodeableConcept;
    FStart : TFhirCodeableConcept;
    FaddressesList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FtargetList : TFhirPlanDefinitionGoalTargetList;
    procedure SetCategory(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirCodeableConcept);
    procedure SetPriority(value : TFhirCodeableConcept);
    procedure SetStart(value : TFhirCodeableConcept);
    function GetAddressesList : TFhirCodeableConceptList;
    function GetHasAddressesList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetTargetList : TFhirPlanDefinitionGoalTargetList;
    function GetHasTargetList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionGoal; overload;
    function Clone : TFhirPlanDefinitionGoal; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates a category the goal falls within. (defined for API consistency)
    property category : TFhirCodeableConcept read FCategory write SetCategory;
    // Indicates a category the goal falls within.
    property categoryElement : TFhirCodeableConcept read FCategory write SetCategory;

    // Typed access to Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding". (defined for API consistency)
    property description : TFhirCodeableConcept read FDescription write SetDescription;
    // Human-readable and/or coded description of a specific desired objective of care, such as "control blood pressure" or "negotiate an obstacle course" or "dance with child at wedding".
    property descriptionElement : TFhirCodeableConcept read FDescription write SetDescription;

    // Typed access to Identifies the expected level of importance associated with reaching/sustaining the defined goal. (defined for API consistency)
    property priority : TFhirCodeableConcept read FPriority write SetPriority;
    // Identifies the expected level of importance associated with reaching/sustaining the defined goal.
    property priorityElement : TFhirCodeableConcept read FPriority write SetPriority;

    // Typed access to The event after which the goal should begin being pursued. (defined for API consistency)
    property start : TFhirCodeableConcept read FStart write SetStart;
    // The event after which the goal should begin being pursued.
    property startElement : TFhirCodeableConcept read FStart write SetStart;

    // Identifies problems, conditions, issues, or concerns the goal is intended to address.
    property addressesList : TFhirCodeableConceptList read GetAddressesList;
    property hasAddressesList : boolean read GetHasAddressesList;

    // Didactic or other informational resources associated with the goal that provide further supporting information about the goal. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // Indicates what should be done and within what timeframe.
    property targetList : TFhirPlanDefinitionGoalTargetList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

  end;

  TFhirPlanDefinitionGoalListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionGoalList;
    function GetCurrent : TFhirPlanDefinitionGoal;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionGoalList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionGoal read GetCurrent;
  end;

  TFhirPlanDefinitionGoalList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionGoal;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionGoal);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionGoalList; overload;
    function Clone : TFhirPlanDefinitionGoalList; overload;
    function GetEnumerator : TFhirPlanDefinitionGoalListEnumerator;
    
    //  Add a FhirPlanDefinitionGoal to the end of the list.
    function Append : TFhirPlanDefinitionGoal;
    
    // Add an already existing FhirPlanDefinitionGoal to the end of the list.
    function AddItem(value : TFhirPlanDefinitionGoal) : TFhirPlanDefinitionGoal; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionGoal) : Integer;
    
    // Insert FhirPlanDefinitionGoal before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionGoal;
    
    // Insert an existing FhirPlanDefinitionGoal before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionGoal);
    
    // Get the iIndexth FhirPlanDefinitionGoal. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionGoal);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionGoal;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionGoals[index : Integer] : TFhirPlanDefinitionGoal read GetItemN write SetItemN; default;
  End;

  // Indicates what should be done and within what timeframe.
  TFhirPlanDefinitionGoalTarget = class (TFhirBackboneElement)
  protected
    FMeasure : TFhirCodeableConcept;
    FDetail : TFhirDataType;
    FDue : TFhirDuration;
    procedure SetMeasure(value : TFhirCodeableConcept);
    procedure SetDetail(value : TFhirDataType);
    procedure SetDue(value : TFhirDuration);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionGoalTarget; overload;
    function Clone : TFhirPlanDefinitionGoalTarget; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The parameter whose value is to be tracked, e.g. body weight, blood pressure, or hemoglobin A1c level. (defined for API consistency)
    property measure : TFhirCodeableConcept read FMeasure write SetMeasure;
    // The parameter whose value is to be tracked, e.g. body weight, blood pressure, or hemoglobin A1c level.
    property measureElement : TFhirCodeableConcept read FMeasure write SetMeasure;

    // Typed access to The target value of the measure to be achieved to signify fulfillment of the goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT 0.6%, Clear solution, etc. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any value at or above the low value. (defined for API consistency)
    property detail : TFhirDataType read FDetail write SetDetail;
    // The target value of the measure to be achieved to signify fulfillment of the goal, e.g. 150 pounds or 7.0%, or in the case of pharmaceutical quality - NMT 0.6%, Clear solution, etc. Either the high or low or both values of the range can be specified. When a low value is missing, it indicates that the goal is achieved at any value at or below the high value. Similarly, if the high value is missing, it indicates that the goal is achieved at any value at or above the low value.
    property detailElement : TFhirDataType read FDetail write SetDetail;

    // Typed access to Indicates the timeframe after the start of the goal in which the goal should be met. (defined for API consistency)
    property due : TFhirDuration read FDue write SetDue;
    // Indicates the timeframe after the start of the goal in which the goal should be met.
    property dueElement : TFhirDuration read FDue write SetDue;

  end;

  TFhirPlanDefinitionGoalTargetListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionGoalTargetList;
    function GetCurrent : TFhirPlanDefinitionGoalTarget;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionGoalTargetList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionGoalTarget read GetCurrent;
  end;

  TFhirPlanDefinitionGoalTargetList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionGoalTarget;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionGoalTarget);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionGoalTargetList; overload;
    function Clone : TFhirPlanDefinitionGoalTargetList; overload;
    function GetEnumerator : TFhirPlanDefinitionGoalTargetListEnumerator;
    
    //  Add a FhirPlanDefinitionGoalTarget to the end of the list.
    function Append : TFhirPlanDefinitionGoalTarget;
    
    // Add an already existing FhirPlanDefinitionGoalTarget to the end of the list.
    function AddItem(value : TFhirPlanDefinitionGoalTarget) : TFhirPlanDefinitionGoalTarget; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionGoalTarget) : Integer;
    
    // Insert FhirPlanDefinitionGoalTarget before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionGoalTarget;
    
    // Insert an existing FhirPlanDefinitionGoalTarget before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionGoalTarget);
    
    // Get the iIndexth FhirPlanDefinitionGoalTarget. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionGoalTarget);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionGoalTarget;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionGoalTargets[index : Integer] : TFhirPlanDefinitionGoalTarget read GetItemN write SetItemN; default;
  End;

  // An action or group of actions to be taken as part of the plan. For example, in clinical care, an action would be to prescribe a particular indicated medication, or perform a particular test as appropriate. In pharmaceutical quality, an action would be the test that needs to be performed on a drug product as defined in the quality specification.
  TFhirPlanDefinitionAction = class (TFhirBackboneElement)
  protected
    FPrefix : TFhirString;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FTextEquivalent : TFhirString;
    FPriority : TFhirEnum;
    FcodeList : TFhirCodeableConceptList;
    FreasonList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FgoalIdList : TFhirIdList;
    FSubject : TFhirDataType;
    FtriggerList : TFhirTriggerDefinitionList;
    FconditionList : TFhirPlanDefinitionActionConditionList;
    FinputList : TFhirDataRequirementList;
    FoutputList : TFhirDataRequirementList;
    FrelatedActionList : TFhirPlanDefinitionActionRelatedActionList;
    FTiming : TFhirDataType;
    FparticipantList : TFhirPlanDefinitionActionParticipantList;
    FType_ : TFhirCodeableConcept;
    FGroupingBehavior : TFhirEnum;
    FSelectionBehavior : TFhirEnum;
    FRequiredBehavior : TFhirEnum;
    FPrecheckBehavior : TFhirEnum;
    FCardinalityBehavior : TFhirEnum;
    FDefinition : TFhirDataType;
    FTransform : TFhirCanonical;
    FdynamicValueList : TFhirPlanDefinitionActionDynamicValueList;
    FactionList : TFhirPlanDefinitionActionList;
    procedure SetPrefix(value : TFhirString);
    function GetPrefixST : String;
    procedure SetPrefixST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetTextEquivalent(value : TFhirString);
    function GetTextEquivalentST : String;
    procedure SetTextEquivalentST(value : String);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetGoalIdList : TFhirIdList;
    function GetHasGoalIdList : Boolean;
    procedure SetSubject(value : TFhirDataType);
    function GetTriggerList : TFhirTriggerDefinitionList;
    function GetHasTriggerList : Boolean;
    function GetConditionList : TFhirPlanDefinitionActionConditionList;
    function GetHasConditionList : Boolean;
    function GetInputList : TFhirDataRequirementList;
    function GetHasInputList : Boolean;
    function GetOutputList : TFhirDataRequirementList;
    function GetHasOutputList : Boolean;
    function GetRelatedActionList : TFhirPlanDefinitionActionRelatedActionList;
    function GetHasRelatedActionList : Boolean;
    procedure SetTiming(value : TFhirDataType);
    function GetParticipantList : TFhirPlanDefinitionActionParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetGroupingBehavior(value : TFhirEnum);
    function GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
    procedure SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
    procedure SetSelectionBehavior(value : TFhirEnum);
    function GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
    procedure SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
    procedure SetRequiredBehavior(value : TFhirEnum);
    function GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
    procedure SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
    procedure SetPrecheckBehavior(value : TFhirEnum);
    function GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
    procedure SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
    procedure SetCardinalityBehavior(value : TFhirEnum);
    function GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
    procedure SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
    procedure SetDefinition(value : TFhirDataType);
    procedure SetTransform(value : TFhirCanonical);
    function GetTransformST : String;
    procedure SetTransformST(value : String);
    function GetDynamicValueList : TFhirPlanDefinitionActionDynamicValueList;
    function GetHasDynamicValueList : Boolean;
    function GetActionList : TFhirPlanDefinitionActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionAction; overload;
    function Clone : TFhirPlanDefinitionAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A user-visible prefix for the action.
    property prefix : String read GetPrefixST write SetPrefixST;
    // A user-visible prefix for the action.
    property prefixElement : TFhirString read FPrefix write SetPrefix;

    // Typed access to The textual description of the action displayed to a user. For example, when the action is a test to be performed, the title would be the title of the test such as Assay by HPLC.
    property title : String read GetTitleST write SetTitleST;
    // The textual description of the action displayed to a user. For example, when the action is a test to be performed, the title would be the title of the test such as Assay by HPLC.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A brief description of the action used to provide a summary to display to the user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A brief description of the action used to provide a summary to display to the user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalent : String read GetTextEquivalentST write SetTextEquivalentST;
    // A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalentElement : TFhirString read FTextEquivalent write SetTextEquivalent;

    // Indicates how quickly the action should be addressed with respect to other actions.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // A code that provides a meaning, grouping, or classification for the action or action group. For example, a section may have a LOINC code for the section of a documentation template. In pharmaceutical quality, an action (Test) such as pH could be classified as a physical property.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // A description of why this action is necessary or appropriate.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // Identifies goals that this action supports. The reference must be to a goal element defined within this plan definition. In pharmaceutical quality, a goal represents acceptance criteria (Goal) for a given action (Test), so the goalId would be the unique id of a defined goal element establishing the acceptance criteria for the action.
    property goalIdList : TFhirIdList read GetGoalIdList;
    property hasGoalIdList : boolean read GetHasGoalIdList;

    // Typed access to A code, group definition, or canonical reference that describes the intended subject of the action and its children, if any. Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // A code, group definition, or canonical reference that describes the intended subject of the action and its children, if any. Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // A description of when the action should be triggered.
    property triggerList : TFhirTriggerDefinitionList read GetTriggerList;
    property hasTriggerList : boolean read GetHasTriggerList;

    // An expression that describes applicability criteria or start/stop conditions for the action.
    property conditionList : TFhirPlanDefinitionActionConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // Defines input data requirements for the action.
    property inputList : TFhirDataRequirementList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Defines the outputs of the action, if any.
    property outputList : TFhirDataRequirementList read GetOutputList;
    property hasOutputList : boolean read GetHasOutputList;

    // A relationship to another action such as "before" or "30-60 minutes after start of".
    property relatedActionList : TFhirPlanDefinitionActionRelatedActionList read GetRelatedActionList;
    property hasRelatedActionList : boolean read GetHasRelatedActionList;

    // Typed access to An optional value describing when the action should be performed. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // An optional value describing when the action should be performed.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // Indicates who should participate in performing the action described.
    property participantList : TFhirPlanDefinitionActionParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The type of action to perform (create, update, remove). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of action to perform (create, update, remove).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Defines the grouping behavior for the action and its children.
    property groupingBehavior : TFhirActionGroupingBehaviorEnum read GetGroupingBehaviorST write SetGroupingBehaviorST;
    property groupingBehaviorElement : TFhirEnum read FGroupingBehavior write SetGroupingBehavior;

    // Defines the selection behavior for the action and its children.
    property selectionBehavior : TFhirActionSelectionBehaviorEnum read GetSelectionBehaviorST write SetSelectionBehaviorST;
    property selectionBehaviorElement : TFhirEnum read FSelectionBehavior write SetSelectionBehavior;

    // Defines the required behavior for the action.
    property requiredBehavior : TFhirActionRequiredBehaviorEnum read GetRequiredBehaviorST write SetRequiredBehaviorST;
    property requiredBehaviorElement : TFhirEnum read FRequiredBehavior write SetRequiredBehavior;

    // Defines whether the action should usually be preselected.
    property precheckBehavior : TFhirActionPrecheckBehaviorEnum read GetPrecheckBehaviorST write SetPrecheckBehaviorST;
    property precheckBehaviorElement : TFhirEnum read FPrecheckBehavior write SetPrecheckBehavior;

    // Defines whether the action can be selected multiple times.
    property cardinalityBehavior : TFhirActionCardinalityBehaviorEnum read GetCardinalityBehaviorST write SetCardinalityBehaviorST;
    property cardinalityBehaviorElement : TFhirEnum read FCardinalityBehavior write SetCardinalityBehavior;

    // Typed access to A reference to an ActivityDefinition that describes the action to be taken in detail, or a PlanDefinition that describes a series of actions to be taken. (defined for API consistency)
    property definition : TFhirDataType read FDefinition write SetDefinition;
    // A reference to an ActivityDefinition that describes the action to be taken in detail, or a PlanDefinition that describes a series of actions to be taken.
    property definitionElement : TFhirDataType read FDefinition write SetDefinition;

    // Typed access to A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transform : String read GetTransformST write SetTransformST;
    // A reference to a StructureMap resource that defines a transform that can be executed to produce the intent resource using the ActivityDefinition instance as the input.
    property transformElement : TFhirCanonical read FTransform write SetTransform;

    // Customizations that should be applied to the statically defined resource. For example, if the dosage of a medication must be computed based on the patient's weight, a customization would be used to specify an expression that calculated the weight, and the path on the resource that would contain the result.
    property dynamicValueList : TFhirPlanDefinitionActionDynamicValueList read GetDynamicValueList;
    property hasDynamicValueList : boolean read GetHasDynamicValueList;

    // Sub actions that are contained within the action. The behavior of this action determines the functionality of the sub-actions. For example, a selection behavior of at-most-one indicates that of the sub-actions, at most one may be chosen as part of realizing the action definition.
    property actionList : TFhirPlanDefinitionActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirPlanDefinitionActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionList;
    function GetCurrent : TFhirPlanDefinitionAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionAction read GetCurrent;
  end;

  TFhirPlanDefinitionActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionAction;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionList; overload;
    function Clone : TFhirPlanDefinitionActionList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionListEnumerator;
    
    //  Add a FhirPlanDefinitionAction to the end of the list.
    function Append : TFhirPlanDefinitionAction;
    
    // Add an already existing FhirPlanDefinitionAction to the end of the list.
    function AddItem(value : TFhirPlanDefinitionAction) : TFhirPlanDefinitionAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionAction) : Integer;
    
    // Insert FhirPlanDefinitionAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionAction;
    
    // Insert an existing FhirPlanDefinitionAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionAction);
    
    // Get the iIndexth FhirPlanDefinitionAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActions[index : Integer] : TFhirPlanDefinitionAction read GetItemN write SetItemN; default;
  End;

  // An expression that describes applicability criteria or start/stop conditions for the action.
  TFhirPlanDefinitionActionCondition = class (TFhirBackboneElement)
  protected
    FKind : TFhirEnum;
    FExpression : TFhirExpression;
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirActionConditionKindEnum;
    procedure SetKindST(value : TFhirActionConditionKindEnum);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionCondition; overload;
    function Clone : TFhirPlanDefinitionActionCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The kind of condition.
    property kind : TFhirActionConditionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to An expression that returns true or false, indicating whether the condition is satisfied. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression that returns true or false, indicating whether the condition is satisfied.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirPlanDefinitionActionConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionConditionList;
    function GetCurrent : TFhirPlanDefinitionActionCondition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionCondition read GetCurrent;
  end;

  TFhirPlanDefinitionActionConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionCondition;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionConditionList; overload;
    function Clone : TFhirPlanDefinitionActionConditionList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionConditionListEnumerator;
    
    //  Add a FhirPlanDefinitionActionCondition to the end of the list.
    function Append : TFhirPlanDefinitionActionCondition;
    
    // Add an already existing FhirPlanDefinitionActionCondition to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionCondition) : TFhirPlanDefinitionActionCondition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionCondition) : Integer;
    
    // Insert FhirPlanDefinitionActionCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionCondition;
    
    // Insert an existing FhirPlanDefinitionActionCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionCondition);
    
    // Get the iIndexth FhirPlanDefinitionActionCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionCondition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionConditions[index : Integer] : TFhirPlanDefinitionActionCondition read GetItemN write SetItemN; default;
  End;

  // A relationship to another action such as "before" or "30-60 minutes after start of".
  TFhirPlanDefinitionActionRelatedAction = class (TFhirBackboneElement)
  protected
    FActionId : TFhirId;
    FRelationship : TFhirEnum;
    FOffset : TFhirDataType;
    procedure SetActionId(value : TFhirId);
    function GetActionIdST : String;
    procedure SetActionIdST(value : String);
    procedure SetRelationship(value : TFhirEnum);
    function GetRelationshipST : TFhirActionRelationshipTypeEnum;
    procedure SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
    procedure SetOffset(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionRelatedAction; overload;
    function Clone : TFhirPlanDefinitionActionRelatedAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The element id of the related action.
    property actionId : String read GetActionIdST write SetActionIdST;
    // The element id of the related action.
    property actionIdElement : TFhirId read FActionId write SetActionId;

    // The relationship of this action to the related action.
    property relationship : TFhirActionRelationshipTypeEnum read GetRelationshipST write SetRelationshipST;
    property relationshipElement : TFhirEnum read FRelationship write SetRelationship;

    // Typed access to A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. (defined for API consistency)
    property offset : TFhirDataType read FOffset write SetOffset;
    // A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
    property offsetElement : TFhirDataType read FOffset write SetOffset;

  end;

  TFhirPlanDefinitionActionRelatedActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionRelatedActionList;
    function GetCurrent : TFhirPlanDefinitionActionRelatedAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionRelatedActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionRelatedAction read GetCurrent;
  end;

  TFhirPlanDefinitionActionRelatedActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionRelatedAction;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionRelatedAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionRelatedActionList; overload;
    function Clone : TFhirPlanDefinitionActionRelatedActionList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionRelatedActionListEnumerator;
    
    //  Add a FhirPlanDefinitionActionRelatedAction to the end of the list.
    function Append : TFhirPlanDefinitionActionRelatedAction;
    
    // Add an already existing FhirPlanDefinitionActionRelatedAction to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionRelatedAction) : TFhirPlanDefinitionActionRelatedAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionRelatedAction) : Integer;
    
    // Insert FhirPlanDefinitionActionRelatedAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionRelatedAction;
    
    // Insert an existing FhirPlanDefinitionActionRelatedAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionRelatedAction);
    
    // Get the iIndexth FhirPlanDefinitionActionRelatedAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionRelatedAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionRelatedAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionRelatedActions[index : Integer] : TFhirPlanDefinitionActionRelatedAction read GetItemN write SetItemN; default;
  End;

  // Indicates who should participate in performing the action described.
  TFhirPlanDefinitionActionParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FRole : TFhirCodeableConcept;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirActionParticipantTypeEnum;
    procedure SetType_ST(value : TFhirActionParticipantTypeEnum);
    procedure SetRole(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionParticipant; overload;
    function Clone : TFhirPlanDefinitionActionParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of participant in the action.
    property type_ : TFhirActionParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The role the participant should play in performing the described action. (defined for API consistency)
    property role : TFhirCodeableConcept read FRole write SetRole;
    // The role the participant should play in performing the described action.
    property roleElement : TFhirCodeableConcept read FRole write SetRole;

  end;

  TFhirPlanDefinitionActionParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionParticipantList;
    function GetCurrent : TFhirPlanDefinitionActionParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionParticipant read GetCurrent;
  end;

  TFhirPlanDefinitionActionParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionParticipant;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionParticipantList; overload;
    function Clone : TFhirPlanDefinitionActionParticipantList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionParticipantListEnumerator;
    
    //  Add a FhirPlanDefinitionActionParticipant to the end of the list.
    function Append : TFhirPlanDefinitionActionParticipant;
    
    // Add an already existing FhirPlanDefinitionActionParticipant to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionParticipant) : TFhirPlanDefinitionActionParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionParticipant) : Integer;
    
    // Insert FhirPlanDefinitionActionParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionParticipant;
    
    // Insert an existing FhirPlanDefinitionActionParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionParticipant);
    
    // Get the iIndexth FhirPlanDefinitionActionParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionParticipants[index : Integer] : TFhirPlanDefinitionActionParticipant read GetItemN write SetItemN; default;
  End;

  // Customizations that should be applied to the statically defined resource. For example, if the dosage of a medication must be computed based on the patient's weight, a customization would be used to specify an expression that calculated the weight, and the path on the resource that would contain the result.
  TFhirPlanDefinitionActionDynamicValue = class (TFhirBackboneElement)
  protected
    FPath : TFhirString;
    FExpression : TFhirExpression;
    procedure SetPath(value : TFhirString);
    function GetPathST : String;
    procedure SetPathST(value : String);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinitionActionDynamicValue; overload;
    function Clone : TFhirPlanDefinitionActionDynamicValue; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property path : String read GetPathST write SetPathST;
    // The path to the element to be customized. This is the path on the resource that will hold the result of the calculation defined by the expression. The specified path SHALL be a FHIRPath resolveable on the specified target type of the ActivityDefinition, and SHALL consist only of identifiers, constant indexers, and a restricted subset of functions. The path is allowed to contain qualifiers (.) to traverse sub-elements, as well as indexers ([x]) to traverse multiple-cardinality sub-elements (see the [Simple FHIRPath Profile](fhirpath.html#simple) for full details).
    property pathElement : TFhirString read FPath write SetPath;

    // Typed access to An expression specifying the value of the customized element. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression specifying the value of the customized element.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirPlanDefinitionActionDynamicValueListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionActionDynamicValueList;
    function GetCurrent : TFhirPlanDefinitionActionDynamicValue;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionActionDynamicValueList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinitionActionDynamicValue read GetCurrent;
  end;

  TFhirPlanDefinitionActionDynamicValueList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinitionActionDynamicValue;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinitionActionDynamicValue);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionActionDynamicValueList; overload;
    function Clone : TFhirPlanDefinitionActionDynamicValueList; overload;
    function GetEnumerator : TFhirPlanDefinitionActionDynamicValueListEnumerator;
    
    //  Add a FhirPlanDefinitionActionDynamicValue to the end of the list.
    function Append : TFhirPlanDefinitionActionDynamicValue;
    
    // Add an already existing FhirPlanDefinitionActionDynamicValue to the end of the list.
    function AddItem(value : TFhirPlanDefinitionActionDynamicValue) : TFhirPlanDefinitionActionDynamicValue; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinitionActionDynamicValue) : Integer;
    
    // Insert FhirPlanDefinitionActionDynamicValue before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinitionActionDynamicValue;
    
    // Insert an existing FhirPlanDefinitionActionDynamicValue before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinitionActionDynamicValue);
    
    // Get the iIndexth FhirPlanDefinitionActionDynamicValue. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinitionActionDynamicValue);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinitionActionDynamicValue;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitionActionDynamicValues[index : Integer] : TFhirPlanDefinitionActionDynamicValue read GetItemN write SetItemN; default;
  End;

  // This resource allows for the definition of various types of plans as a sharable, consumable, and executable artifact. The resource is general enough to support the description of a broad range of clinical and non-clinical artifacts such as clinical decision support rules, order sets, protocols, and drug quality specifications.
  TFhirPlanDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FSubtitle : TFhirString;
    FType_ : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FSubject : TFhirDataType;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirCanonicalList;
    FgoalList : TFhirPlanDefinitionGoalList;
    FactionList : TFhirPlanDefinitionActionList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetSubject(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirCanonicalList;
    function GetHasLibrary_List : Boolean;
    function GetGoalList : TFhirPlanDefinitionGoalList;
    function GetHasGoalList : Boolean;
    function GetActionList : TFhirPlanDefinitionActionList;
    function GetHasActionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirPlanDefinition; overload;
    function Clone : TFhirPlanDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this plan definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this plan definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the plan definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this plan definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this plan definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the plan definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this plan definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the plan definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the plan definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the plan definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the plan definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the plan definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the plan definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the plan definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the plan definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to An explanatory or alternate title for the plan definition giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the plan definition giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // Typed access to A high-level category for the plan definition that distinguishes the kinds of systems that would be interested in the plan definition. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A high-level category for the plan definition that distinguishes the kinds of systems that would be interested in the plan definition.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The status of this plan definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this plan definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this plan definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to A code, group definition, or canonical reference that describes  or identifies the intended subject of the plan definition. Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // A code, group definition, or canonical reference that describes  or identifies the intended subject of the plan definition. Canonical references are allowed to support the definition of protocols for drug and substance quality specifications, and is allowed to reference a MedicinalProductDefinition, SubstanceDefinition, AdministrableProductDefinition, ManufacturedItemDefinition, or PackagedProductDefinition resource.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the plan definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the plan definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the plan definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the plan definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the plan definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the plan definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the plan definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the plan definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate plan definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the plan definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this plan definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this plan definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description of how the plan definition is used from a clinical perspective.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description of how the plan definition is used from a clinical perspective.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the plan definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the plan definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the plan definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the plan definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the plan definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the plan definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the plan definition. Topics provide a high-level categorization of the definition that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing any formal logic used by the plan definition.
    property library_List : TFhirCanonicalList read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // A goal describes an expected outcome that activities within the plan are intended to achieve. For example, weight loss, restoring an activity of daily living, obtaining herd immunity via immunization, meeting a process improvement objective, meeting the acceptance criteria for a test as specified by a quality specification, etc.
    property goalList : TFhirPlanDefinitionGoalList read GetGoalList;
    property hasGoalList : boolean read GetHasGoalList;

    // An action or group of actions to be taken as part of the plan. For example, in clinical care, an action would be to prescribe a particular indicated medication, or perform a particular test as appropriate. In pharmaceutical quality, an action would be the test that needs to be performed on a drug product as defined in the quality specification.
    property actionList : TFhirPlanDefinitionActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirPlanDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirPlanDefinitionList;
    function GetCurrent : TFhirPlanDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirPlanDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirPlanDefinition read GetCurrent;
  end;

  TFhirPlanDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirPlanDefinition;
    procedure SetItemN(index : Integer; value : TFhirPlanDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirPlanDefinitionList; overload;
    function Clone : TFhirPlanDefinitionList; overload;
    function GetEnumerator : TFhirPlanDefinitionListEnumerator;
    
    //  Add a FhirPlanDefinition to the end of the list.
    function Append : TFhirPlanDefinition;
    
    // Add an already existing FhirPlanDefinition to the end of the list.
    function AddItem(value : TFhirPlanDefinition) : TFhirPlanDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirPlanDefinition) : Integer;
    
    // Insert FhirPlanDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirPlanDefinition;
    
    // Insert an existing FhirPlanDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirPlanDefinition);
    
    // Get the iIndexth FhirPlanDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirPlanDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirPlanDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirPlanDefinitions[index : Integer] : TFhirPlanDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PROVENANCE}
  // An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
  TFhirProvenanceAgent = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FroleList : TFhirCodeableConceptList;
    FWho : TFhirReference;
    FOnBehalfOf : TFhirReference;
    procedure SetType_(value : TFhirCodeableConcept);
    function GetRoleList : TFhirCodeableConceptList;
    function GetHasRoleList : Boolean;
    procedure SetWho(value : TFhirReference);
    procedure SetOnBehalfOf(value : TFhirReference);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceAgent; overload;
    function Clone : TFhirProvenanceAgent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The participation the agent had with respect to the activity. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The participation the agent had with respect to the activity.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // The function of the agent with respect to the activity. The security role enabling the agent with respect to the activity.
    property roleList : TFhirCodeableConceptList read GetRoleList;
    property hasRoleList : boolean read GetHasRoleList;

    // Typed access to The individual, device or organization that participated in the event. (defined for API consistency)
    property who : TFhirReference read FWho write SetWho;
    // The individual, device or organization that participated in the event.
    property whoElement : TFhirReference read FWho write SetWho;

    // Typed access to The individual, device, or organization for whom the change was made. (defined for API consistency)
    property onBehalfOf : TFhirReference read FOnBehalfOf write SetOnBehalfOf;
    // The individual, device, or organization for whom the change was made.
    property onBehalfOfElement : TFhirReference read FOnBehalfOf write SetOnBehalfOf;

  end;

  TFhirProvenanceAgentListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceAgentList;
    function GetCurrent : TFhirProvenanceAgent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceAgentList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceAgent read GetCurrent;
  end;

  TFhirProvenanceAgentList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceAgent;
    procedure SetItemN(index : Integer; value : TFhirProvenanceAgent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProvenanceAgentList; overload;
    function Clone : TFhirProvenanceAgentList; overload;
    function GetEnumerator : TFhirProvenanceAgentListEnumerator;
    
    //  Add a FhirProvenanceAgent to the end of the list.
    function Append : TFhirProvenanceAgent;
    
    // Add an already existing FhirProvenanceAgent to the end of the list.
    function AddItem(value : TFhirProvenanceAgent) : TFhirProvenanceAgent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceAgent) : Integer;
    
    // Insert FhirProvenanceAgent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceAgent;
    
    // Insert an existing FhirProvenanceAgent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceAgent);
    
    // Get the iIndexth FhirProvenanceAgent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceAgent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceAgent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProvenanceAgents[index : Integer] : TFhirProvenanceAgent read GetItemN write SetItemN; default;
  End;

  // An entity used in this activity.
  TFhirProvenanceEntity = class (TFhirBackboneElement)
  protected
    FRole : TFhirEnum;
    FWhat : TFhirReference;
    FagentList : TFhirProvenanceAgentList;
    procedure SetRole(value : TFhirEnum);
    function GetRoleST : TFhirProvenanceEntityRoleEnum;
    procedure SetRoleST(value : TFhirProvenanceEntityRoleEnum);
    procedure SetWhat(value : TFhirReference);
    function GetAgentList : TFhirProvenanceAgentList;
    function GetHasAgentList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenanceEntity; overload;
    function Clone : TFhirProvenanceEntity; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // How the entity was used during the activity.
    property role : TFhirProvenanceEntityRoleEnum read GetRoleST write SetRoleST;
    property roleElement : TFhirEnum read FRole write SetRole;

    // Typed access to Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative. (defined for API consistency)
    property what : TFhirReference read FWhat write SetWhat;
    // Identity of the  Entity used. May be a logical or physical uri and maybe absolute or relative.
    property whatElement : TFhirReference read FWhat write SetWhat;

    // The entity is attributed to an agent to express the agent's responsibility for that entity, possibly along with other agents. This description can be understood as shorthand for saying that the agent was responsible for the activity which generated the entity.
    property agentList : TFhirProvenanceAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

  end;

  TFhirProvenanceEntityListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceEntityList;
    function GetCurrent : TFhirProvenanceEntity;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceEntityList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenanceEntity read GetCurrent;
  end;

  TFhirProvenanceEntityList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenanceEntity;
    procedure SetItemN(index : Integer; value : TFhirProvenanceEntity);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProvenanceEntityList; overload;
    function Clone : TFhirProvenanceEntityList; overload;
    function GetEnumerator : TFhirProvenanceEntityListEnumerator;
    
    //  Add a FhirProvenanceEntity to the end of the list.
    function Append : TFhirProvenanceEntity;
    
    // Add an already existing FhirProvenanceEntity to the end of the list.
    function AddItem(value : TFhirProvenanceEntity) : TFhirProvenanceEntity; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenanceEntity) : Integer;
    
    // Insert FhirProvenanceEntity before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenanceEntity;
    
    // Insert an existing FhirProvenanceEntity before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenanceEntity);
    
    // Get the iIndexth FhirProvenanceEntity. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenanceEntity);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenanceEntity;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProvenanceEntities[index : Integer] : TFhirProvenanceEntity read GetItemN write SetItemN; default;
  End;

  // Provenance of a resource is a record that describes entities and processes involved in producing and delivering or otherwise influencing that resource. Provenance provides a critical foundation for assessing authenticity, enabling trust, and allowing reproducibility. Provenance assertions are a form of contextual metadata and can themselves become important records with their own provenance. Provenance statement indicates clinical significance in terms of confidence in authenticity, reliability, and trustworthiness, integrity, and stage in lifecycle (e.g. Document Completion - has the artifact been legally authenticated), all of which may impact security, privacy, and trust policies.
  TFhirProvenance = class (TFhirDomainResource)
  protected
    FtargetList : TFhirReferenceList;
    FOccurred : TFhirDataType;
    FRecorded : TFhirInstant;
    FpolicyList : TFhirUriList;
    FLocation : TFhirReference;
    FreasonList : TFhirCodeableConceptList;
    FActivity : TFhirCodeableConcept;
    FagentList : TFhirProvenanceAgentList;
    FentityList : TFhirProvenanceEntityList;
    FsignatureList : TFhirSignatureList;
    function GetTargetList : TFhirReferenceList;
    function GetHasTargetList : Boolean;
    procedure SetOccurred(value : TFhirDataType);
    procedure SetRecorded(value : TFhirInstant);
    function GetRecordedST : TFslDateTime;
    procedure SetRecordedST(value : TFslDateTime);
    function GetPolicyList : TFhirUriList;
    function GetHasPolicyList : Boolean;
    procedure SetLocation(value : TFhirReference);
    function GetReasonList : TFhirCodeableConceptList;
    function GetHasReasonList : Boolean;
    procedure SetActivity(value : TFhirCodeableConcept);
    function GetAgentList : TFhirProvenanceAgentList;
    function GetHasAgentList : Boolean;
    function GetEntityList : TFhirProvenanceEntityList;
    function GetHasEntityList : Boolean;
    function GetSignatureList : TFhirSignatureList;
    function GetHasSignatureList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirProvenance; overload;
    function Clone : TFhirProvenance; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The Reference(s) that were generated or updated by  the activity described in this resource. A provenance can point to more than one target if multiple resources were created/updated by the same activity.
    property targetList : TFhirReferenceList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // Typed access to The period during which the activity occurred. (defined for API consistency)
    property occurred : TFhirDataType read FOccurred write SetOccurred;
    // The period during which the activity occurred.
    property occurredElement : TFhirDataType read FOccurred write SetOccurred;

    // Typed access to The instant of time at which the activity was recorded.
    property recorded : TFslDateTime read GetRecordedST write SetRecordedST;
    // The instant of time at which the activity was recorded.
    property recordedElement : TFhirInstant read FRecorded write SetRecorded;

    // Policy or plan the activity was defined by. Typically, a single activity may have multiple applicable policy documents, such as patient consent, guarantor funding, etc.
    property policyList : TFhirUriList read GetPolicyList;
    property hasPolicyList : boolean read GetHasPolicyList;

    // Typed access to Where the activity occurred, if relevant. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Where the activity occurred, if relevant.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // The reason that the activity was taking place.
    property reasonList : TFhirCodeableConceptList read GetReasonList;
    property hasReasonList : boolean read GetHasReasonList;

    // Typed access to An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities. (defined for API consistency)
    property activity : TFhirCodeableConcept read FActivity write SetActivity;
    // An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities.
    property activityElement : TFhirCodeableConcept read FActivity write SetActivity;

    // An actor taking a role in an activity  for which it can be assigned some degree of responsibility for the activity taking place.
    property agentList : TFhirProvenanceAgentList read GetAgentList;
    property hasAgentList : boolean read GetHasAgentList;

    // An entity used in this activity.
    property entityList : TFhirProvenanceEntityList read GetEntityList;
    property hasEntityList : boolean read GetHasEntityList;

    // A digital signature on the target Reference(s). The signer should match a Provenance.agent. The purpose of the signature is indicated.
    property signatureList : TFhirSignatureList read GetSignatureList;
    property hasSignatureList : boolean read GetHasSignatureList;

  end;

  TFhirProvenanceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirProvenanceList;
    function GetCurrent : TFhirProvenance;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirProvenanceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirProvenance read GetCurrent;
  end;

  TFhirProvenanceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirProvenance;
    procedure SetItemN(index : Integer; value : TFhirProvenance);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirProvenanceList; overload;
    function Clone : TFhirProvenanceList; overload;
    function GetEnumerator : TFhirProvenanceListEnumerator;
    
    //  Add a FhirProvenance to the end of the list.
    function Append : TFhirProvenance;
    
    // Add an already existing FhirProvenance to the end of the list.
    function AddItem(value : TFhirProvenance) : TFhirProvenance; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirProvenance) : Integer;
    
    // Insert FhirProvenance before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirProvenance;
    
    // Insert an existing FhirProvenance before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirProvenance);
    
    // Get the iIndexth FhirProvenance. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirProvenance);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirProvenance;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirProvenances[index : Integer] : TFhirProvenance read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
  // A group or question item from the original questionnaire for which answers are provided.
  TFhirQuestionnaireResponseItem = class (TFhirBackboneElement)
  protected
    FLinkId : TFhirString;
    FDefinition : TFhirUri;
    FText : TFhirString;
    FanswerList : TFhirQuestionnaireResponseItemAnswerList;
    FitemList : TFhirQuestionnaireResponseItemList;
    procedure SetLinkId(value : TFhirString);
    function GetLinkIdST : String;
    procedure SetLinkIdST(value : String);
    procedure SetDefinition(value : TFhirUri);
    function GetDefinitionST : String;
    procedure SetDefinitionST(value : String);
    procedure SetText(value : TFhirString);
    function GetTextST : String;
    procedure SetTextST(value : String);
    function GetAnswerList : TFhirQuestionnaireResponseItemAnswerList;
    function GetHasAnswerList : Boolean;
    function GetItemList : TFhirQuestionnaireResponseItemList;
    function GetHasItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponseItem; overload;
    function Clone : TFhirQuestionnaireResponseItem; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The item from the Questionnaire that corresponds to this item in the QuestionnaireResponse resource.
    property linkId : String read GetLinkIdST write SetLinkIdST;
    // The item from the Questionnaire that corresponds to this item in the QuestionnaireResponse resource.
    property linkIdElement : TFhirString read FLinkId write SetLinkId;

    // Typed access to A reference to an [ElementDefinition](elementdefinition.html) that provides the details for the item.
    property definition : String read GetDefinitionST write SetDefinitionST;
    // A reference to an [ElementDefinition](elementdefinition.html) that provides the details for the item.
    property definitionElement : TFhirUri read FDefinition write SetDefinition;

    // Typed access to Text that is displayed above the contents of the group or as the text of the question being answered.
    property text : String read GetTextST write SetTextST;
    // Text that is displayed above the contents of the group or as the text of the question being answered.
    property textElement : TFhirString read FText write SetText;

    // The respondent's answer(s) to the question.
    property answerList : TFhirQuestionnaireResponseItemAnswerList read GetAnswerList;
    property hasAnswerList : boolean read GetHasAnswerList;

    // Questions or sub-groups nested beneath a question or group.
    property itemList : TFhirQuestionnaireResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireResponseItemListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseItemList;
    function GetCurrent : TFhirQuestionnaireResponseItem;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseItemList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponseItem read GetCurrent;
  end;

  TFhirQuestionnaireResponseItemList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireResponseItem;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponseItem);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireResponseItemList; overload;
    function Clone : TFhirQuestionnaireResponseItemList; overload;
    function GetEnumerator : TFhirQuestionnaireResponseItemListEnumerator;
    
    //  Add a FhirQuestionnaireResponseItem to the end of the list.
    function Append : TFhirQuestionnaireResponseItem;
    
    // Add an already existing FhirQuestionnaireResponseItem to the end of the list.
    function AddItem(value : TFhirQuestionnaireResponseItem) : TFhirQuestionnaireResponseItem; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponseItem) : Integer;
    
    // Insert FhirQuestionnaireResponseItem before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponseItem;
    
    // Insert an existing FhirQuestionnaireResponseItem before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponseItem);
    
    // Get the iIndexth FhirQuestionnaireResponseItem. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponseItem);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponseItem;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireResponseItems[index : Integer] : TFhirQuestionnaireResponseItem read GetItemN write SetItemN; default;
  End;

  // The respondent's answer(s) to the question.
  TFhirQuestionnaireResponseItemAnswer = class (TFhirBackboneElement)
  protected
    FValue : TFhirDataType;
    FitemList : TFhirQuestionnaireResponseItemList;
    procedure SetValue(value : TFhirDataType);
    function GetItemList : TFhirQuestionnaireResponseItemList;
    function GetHasItemList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponseItemAnswer; overload;
    function Clone : TFhirQuestionnaireResponseItemAnswer; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The answer (or one of the answers) provided by the respondent to the question. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The answer (or one of the answers) provided by the respondent to the question.
    property valueElement : TFhirDataType read FValue write SetValue;

    // Nested groups and/or questions found within this particular answer.
    property itemList : TFhirQuestionnaireResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireResponseItemAnswerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseItemAnswerList;
    function GetCurrent : TFhirQuestionnaireResponseItemAnswer;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseItemAnswerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponseItemAnswer read GetCurrent;
  end;

  TFhirQuestionnaireResponseItemAnswerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireResponseItemAnswer;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponseItemAnswer);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireResponseItemAnswerList; overload;
    function Clone : TFhirQuestionnaireResponseItemAnswerList; overload;
    function GetEnumerator : TFhirQuestionnaireResponseItemAnswerListEnumerator;
    
    //  Add a FhirQuestionnaireResponseItemAnswer to the end of the list.
    function Append : TFhirQuestionnaireResponseItemAnswer;
    
    // Add an already existing FhirQuestionnaireResponseItemAnswer to the end of the list.
    function AddItem(value : TFhirQuestionnaireResponseItemAnswer) : TFhirQuestionnaireResponseItemAnswer; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponseItemAnswer) : Integer;
    
    // Insert FhirQuestionnaireResponseItemAnswer before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponseItemAnswer;
    
    // Insert an existing FhirQuestionnaireResponseItemAnswer before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponseItemAnswer);
    
    // Get the iIndexth FhirQuestionnaireResponseItemAnswer. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponseItemAnswer);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponseItemAnswer;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireResponseItemAnswers[index : Integer] : TFhirQuestionnaireResponseItemAnswer read GetItemN write SetItemN; default;
  End;

  // A structured set of questions and their answers. The questions are ordered and grouped into coherent subsets, corresponding to the structure of the grouping of the questionnaire being responded to.
  TFhirQuestionnaireResponse = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FbasedOnList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FQuestionnaire : TFhirCanonical;
    FStatus : TFhirEnum;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FAuthored : TFhirDateTime;
    FAuthor : TFhirReference;
    FSource : TFhirReference;
    FitemList : TFhirQuestionnaireResponseItemList;
    procedure SetIdentifier(value : TFhirIdentifier);
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetQuestionnaire(value : TFhirCanonical);
    function GetQuestionnaireST : String;
    procedure SetQuestionnaireST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirQuestionnaireResponseStatusEnum;
    procedure SetStatusST(value : TFhirQuestionnaireResponseStatusEnum);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetAuthored(value : TFhirDateTime);
    function GetAuthoredST : TFslDateTime;
    procedure SetAuthoredST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
    procedure SetSource(value : TFhirReference);
    function GetItemList : TFhirQuestionnaireResponseItemList;
    function GetHasItemList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirQuestionnaireResponse; overload;
    function Clone : TFhirQuestionnaireResponse; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A business identifier assigned to a particular completed (or partially completed) questionnaire. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // A business identifier assigned to a particular completed (or partially completed) questionnaire.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // The order, proposal or plan that is fulfilled in whole or in part by this QuestionnaireResponse.  For example, a ServiceRequest seeking an intake assessment or a decision support recommendation to assess for post-partum depression.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // A procedure or observation that this questionnaire was performed as part of the execution of.  For example, the surgery a checklist was executed as part of.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // Typed access to The Questionnaire that defines and organizes the questions for which answers are being provided.
    property questionnaire : String read GetQuestionnaireST write SetQuestionnaireST;
    // The Questionnaire that defines and organizes the questions for which answers are being provided.
    property questionnaireElement : TFhirCanonical read FQuestionnaire write SetQuestionnaire;

    // The position of the questionnaire response within its overall lifecycle.
    property status : TFhirQuestionnaireResponseStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The subject of the questionnaire response.  This could be a patient, organization, practitioner, device, etc.  This is who/what the answers apply to, but is not necessarily the source of information. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The subject of the questionnaire response.  This could be a patient, organization, practitioner, device, etc.  This is who/what the answers apply to, but is not necessarily the source of information.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to The Encounter during which this questionnaire response was created or to which the creation of this record is tightly associated. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The Encounter during which this questionnaire response was created or to which the creation of this record is tightly associated.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to The date and/or time that this set of answers were last changed.
    property authored : TFslDateTime read GetAuthoredST write SetAuthoredST;
    // The date and/or time that this set of answers were last changed.
    property authoredElement : TFhirDateTime read FAuthored write SetAuthored;

    // Typed access to Person who received the answers to the questions in the QuestionnaireResponse and recorded them in the system. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Person who received the answers to the questions in the QuestionnaireResponse and recorded them in the system.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Typed access to The person who answered the questions about the subject. (defined for API consistency)
    property source : TFhirReference read FSource write SetSource;
    // The person who answered the questions about the subject.
    property sourceElement : TFhirReference read FSource write SetSource;

    // A group or question item from the original questionnaire for which answers are provided.
    property itemList : TFhirQuestionnaireResponseItemList read GetItemList;
    property hasItemList : boolean read GetHasItemList;

  end;

  TFhirQuestionnaireResponseListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirQuestionnaireResponseList;
    function GetCurrent : TFhirQuestionnaireResponse;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirQuestionnaireResponseList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirQuestionnaireResponse read GetCurrent;
  end;

  TFhirQuestionnaireResponseList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirQuestionnaireResponse;
    procedure SetItemN(index : Integer; value : TFhirQuestionnaireResponse);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirQuestionnaireResponseList; overload;
    function Clone : TFhirQuestionnaireResponseList; overload;
    function GetEnumerator : TFhirQuestionnaireResponseListEnumerator;
    
    //  Add a FhirQuestionnaireResponse to the end of the list.
    function Append : TFhirQuestionnaireResponse;
    
    // Add an already existing FhirQuestionnaireResponse to the end of the list.
    function AddItem(value : TFhirQuestionnaireResponse) : TFhirQuestionnaireResponse; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirQuestionnaireResponse) : Integer;
    
    // Insert FhirQuestionnaireResponse before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirQuestionnaireResponse;
    
    // Insert an existing FhirQuestionnaireResponse before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirQuestionnaireResponse);
    
    // Get the iIndexth FhirQuestionnaireResponse. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirQuestionnaireResponse);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirQuestionnaireResponse;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirQuestionnaireResponses[index : Integer] : TFhirQuestionnaireResponse read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REQUESTGROUP}
  // The actions, if any, produced by the evaluation of the artifact.
  TFhirRequestGroupAction = class (TFhirBackboneElement)
  protected
    FPrefix : TFhirString;
    FTitle : TFhirString;
    FDescription : TFhirString;
    FTextEquivalent : TFhirString;
    FPriority : TFhirEnum;
    FcodeList : TFhirCodeableConceptList;
    FdocumentationList : TFhirRelatedArtifactList;
    FconditionList : TFhirRequestGroupActionConditionList;
    FrelatedActionList : TFhirRequestGroupActionRelatedActionList;
    FTiming : TFhirDataType;
    FparticipantList : TFhirReferenceList;
    FType_ : TFhirCodeableConcept;
    FGroupingBehavior : TFhirEnum;
    FSelectionBehavior : TFhirEnum;
    FRequiredBehavior : TFhirEnum;
    FPrecheckBehavior : TFhirEnum;
    FCardinalityBehavior : TFhirEnum;
    FResource : TFhirReference;
    FactionList : TFhirRequestGroupActionList;
    procedure SetPrefix(value : TFhirString);
    function GetPrefixST : String;
    procedure SetPrefixST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetTextEquivalent(value : TFhirString);
    function GetTextEquivalentST : String;
    procedure SetTextEquivalentST(value : String);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    function GetCodeList : TFhirCodeableConceptList;
    function GetHasCodeList : Boolean;
    function GetDocumentationList : TFhirRelatedArtifactList;
    function GetHasDocumentationList : Boolean;
    function GetConditionList : TFhirRequestGroupActionConditionList;
    function GetHasConditionList : Boolean;
    function GetRelatedActionList : TFhirRequestGroupActionRelatedActionList;
    function GetHasRelatedActionList : Boolean;
    procedure SetTiming(value : TFhirDataType);
    function GetParticipantList : TFhirReferenceList;
    function GetHasParticipantList : Boolean;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetGroupingBehavior(value : TFhirEnum);
    function GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
    procedure SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
    procedure SetSelectionBehavior(value : TFhirEnum);
    function GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
    procedure SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
    procedure SetRequiredBehavior(value : TFhirEnum);
    function GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
    procedure SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
    procedure SetPrecheckBehavior(value : TFhirEnum);
    function GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
    procedure SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
    procedure SetCardinalityBehavior(value : TFhirEnum);
    function GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
    procedure SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
    procedure SetResource(value : TFhirReference);
    function GetActionList : TFhirRequestGroupActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupAction; overload;
    function Clone : TFhirRequestGroupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A user-visible prefix for the action.
    property prefix : String read GetPrefixST write SetPrefixST;
    // A user-visible prefix for the action.
    property prefixElement : TFhirString read FPrefix write SetPrefix;

    // Typed access to The title of the action displayed to a user.
    property title : String read GetTitleST write SetTitleST;
    // The title of the action displayed to a user.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to A short description of the action used to provide a summary to display to the user.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the action used to provide a summary to display to the user.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalent : String read GetTextEquivalentST write SetTextEquivalentST;
    // A text equivalent of the action to be performed. This provides a human-interpretable description of the action when the definition is consumed by a system that might not be capable of interpreting it dynamically.
    property textEquivalentElement : TFhirString read FTextEquivalent write SetTextEquivalent;

    // Indicates how quickly the action should be addressed with respect to other actions.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // A code that provides meaning for the action or action group. For example, a section may have a LOINC code for a section of a documentation template.
    property codeList : TFhirCodeableConceptList read GetCodeList;
    property hasCodeList : boolean read GetHasCodeList;

    // Didactic or other informational resources associated with the action that can be provided to the CDS recipient. Information resources can include inline text commentary and links to web resources.
    property documentationList : TFhirRelatedArtifactList read GetDocumentationList;
    property hasDocumentationList : boolean read GetHasDocumentationList;

    // An expression that describes applicability criteria, or start/stop conditions for the action.
    property conditionList : TFhirRequestGroupActionConditionList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // A relationship to another action such as "before" or "30-60 minutes after start of".
    property relatedActionList : TFhirRequestGroupActionRelatedActionList read GetRelatedActionList;
    property hasRelatedActionList : boolean read GetHasRelatedActionList;

    // Typed access to An optional value describing when the action should be performed. (defined for API consistency)
    property timing : TFhirDataType read FTiming write SetTiming;
    // An optional value describing when the action should be performed.
    property timingElement : TFhirDataType read FTiming write SetTiming;

    // The participant that should perform or be responsible for this action.
    property participantList : TFhirReferenceList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The type of action to perform (create, update, remove). (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The type of action to perform (create, update, remove).
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Defines the grouping behavior for the action and its children.
    property groupingBehavior : TFhirActionGroupingBehaviorEnum read GetGroupingBehaviorST write SetGroupingBehaviorST;
    property groupingBehaviorElement : TFhirEnum read FGroupingBehavior write SetGroupingBehavior;

    // Defines the selection behavior for the action and its children.
    property selectionBehavior : TFhirActionSelectionBehaviorEnum read GetSelectionBehaviorST write SetSelectionBehaviorST;
    property selectionBehaviorElement : TFhirEnum read FSelectionBehavior write SetSelectionBehavior;

    // Defines expectations around whether an action is required.
    property requiredBehavior : TFhirActionRequiredBehaviorEnum read GetRequiredBehaviorST write SetRequiredBehaviorST;
    property requiredBehaviorElement : TFhirEnum read FRequiredBehavior write SetRequiredBehavior;

    // Defines whether the action should usually be preselected.
    property precheckBehavior : TFhirActionPrecheckBehaviorEnum read GetPrecheckBehaviorST write SetPrecheckBehaviorST;
    property precheckBehaviorElement : TFhirEnum read FPrecheckBehavior write SetPrecheckBehavior;

    // Defines whether the action can be selected multiple times.
    property cardinalityBehavior : TFhirActionCardinalityBehaviorEnum read GetCardinalityBehaviorST write SetCardinalityBehaviorST;
    property cardinalityBehaviorElement : TFhirEnum read FCardinalityBehavior write SetCardinalityBehavior;

    // Typed access to The resource that is the target of the action (e.g. CommunicationRequest). (defined for API consistency)
    property resource : TFhirReference read FResource write SetResource;
    // The resource that is the target of the action (e.g. CommunicationRequest).
    property resourceElement : TFhirReference read FResource write SetResource;

    // Sub actions.
    property actionList : TFhirRequestGroupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestGroupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionList;
    function GetCurrent : TFhirRequestGroupAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupAction read GetCurrent;
  end;

  TFhirRequestGroupActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestGroupAction;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestGroupActionList; overload;
    function Clone : TFhirRequestGroupActionList; overload;
    function GetEnumerator : TFhirRequestGroupActionListEnumerator;
    
    //  Add a FhirRequestGroupAction to the end of the list.
    function Append : TFhirRequestGroupAction;
    
    // Add an already existing FhirRequestGroupAction to the end of the list.
    function AddItem(value : TFhirRequestGroupAction) : TFhirRequestGroupAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupAction) : Integer;
    
    // Insert FhirRequestGroupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupAction;
    
    // Insert an existing FhirRequestGroupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupAction);
    
    // Get the iIndexth FhirRequestGroupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestGroupActions[index : Integer] : TFhirRequestGroupAction read GetItemN write SetItemN; default;
  End;

  // An expression that describes applicability criteria, or start/stop conditions for the action.
  TFhirRequestGroupActionCondition = class (TFhirBackboneElement)
  protected
    FKind : TFhirEnum;
    FExpression : TFhirExpression;
    procedure SetKind(value : TFhirEnum);
    function GetKindST : TFhirActionConditionKindEnum;
    procedure SetKindST(value : TFhirActionConditionKindEnum);
    procedure SetExpression(value : TFhirExpression);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupActionCondition; overload;
    function Clone : TFhirRequestGroupActionCondition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The kind of condition.
    property kind : TFhirActionConditionKindEnum read GetKindST write SetKindST;
    property kindElement : TFhirEnum read FKind write SetKind;

    // Typed access to An expression that returns true or false, indicating whether or not the condition is satisfied. (defined for API consistency)
    property expression : TFhirExpression read FExpression write SetExpression;
    // An expression that returns true or false, indicating whether or not the condition is satisfied.
    property expressionElement : TFhirExpression read FExpression write SetExpression;

  end;

  TFhirRequestGroupActionConditionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionConditionList;
    function GetCurrent : TFhirRequestGroupActionCondition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionConditionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupActionCondition read GetCurrent;
  end;

  TFhirRequestGroupActionConditionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestGroupActionCondition;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupActionCondition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestGroupActionConditionList; overload;
    function Clone : TFhirRequestGroupActionConditionList; overload;
    function GetEnumerator : TFhirRequestGroupActionConditionListEnumerator;
    
    //  Add a FhirRequestGroupActionCondition to the end of the list.
    function Append : TFhirRequestGroupActionCondition;
    
    // Add an already existing FhirRequestGroupActionCondition to the end of the list.
    function AddItem(value : TFhirRequestGroupActionCondition) : TFhirRequestGroupActionCondition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupActionCondition) : Integer;
    
    // Insert FhirRequestGroupActionCondition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupActionCondition;
    
    // Insert an existing FhirRequestGroupActionCondition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupActionCondition);
    
    // Get the iIndexth FhirRequestGroupActionCondition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupActionCondition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupActionCondition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestGroupActionConditions[index : Integer] : TFhirRequestGroupActionCondition read GetItemN write SetItemN; default;
  End;

  // A relationship to another action such as "before" or "30-60 minutes after start of".
  TFhirRequestGroupActionRelatedAction = class (TFhirBackboneElement)
  protected
    FActionId : TFhirId;
    FRelationship : TFhirEnum;
    FOffset : TFhirDataType;
    procedure SetActionId(value : TFhirId);
    function GetActionIdST : String;
    procedure SetActionIdST(value : String);
    procedure SetRelationship(value : TFhirEnum);
    function GetRelationshipST : TFhirActionRelationshipTypeEnum;
    procedure SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
    procedure SetOffset(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroupActionRelatedAction; overload;
    function Clone : TFhirRequestGroupActionRelatedAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The element id of the action this is related to.
    property actionId : String read GetActionIdST write SetActionIdST;
    // The element id of the action this is related to.
    property actionIdElement : TFhirId read FActionId write SetActionId;

    // The relationship of this action to the related action.
    property relationship : TFhirActionRelationshipTypeEnum read GetRelationshipST write SetRelationshipST;
    property relationshipElement : TFhirEnum read FRelationship write SetRelationship;

    // Typed access to A duration or range of durations to apply to the relationship. For example, 30-60 minutes before. (defined for API consistency)
    property offset : TFhirDataType read FOffset write SetOffset;
    // A duration or range of durations to apply to the relationship. For example, 30-60 minutes before.
    property offsetElement : TFhirDataType read FOffset write SetOffset;

  end;

  TFhirRequestGroupActionRelatedActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupActionRelatedActionList;
    function GetCurrent : TFhirRequestGroupActionRelatedAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupActionRelatedActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroupActionRelatedAction read GetCurrent;
  end;

  TFhirRequestGroupActionRelatedActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestGroupActionRelatedAction;
    procedure SetItemN(index : Integer; value : TFhirRequestGroupActionRelatedAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestGroupActionRelatedActionList; overload;
    function Clone : TFhirRequestGroupActionRelatedActionList; overload;
    function GetEnumerator : TFhirRequestGroupActionRelatedActionListEnumerator;
    
    //  Add a FhirRequestGroupActionRelatedAction to the end of the list.
    function Append : TFhirRequestGroupActionRelatedAction;
    
    // Add an already existing FhirRequestGroupActionRelatedAction to the end of the list.
    function AddItem(value : TFhirRequestGroupActionRelatedAction) : TFhirRequestGroupActionRelatedAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroupActionRelatedAction) : Integer;
    
    // Insert FhirRequestGroupActionRelatedAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroupActionRelatedAction;
    
    // Insert an existing FhirRequestGroupActionRelatedAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroupActionRelatedAction);
    
    // Get the iIndexth FhirRequestGroupActionRelatedAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroupActionRelatedAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroupActionRelatedAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestGroupActionRelatedActions[index : Integer] : TFhirRequestGroupActionRelatedAction read GetItemN write SetItemN; default;
  End;

  // A group of related requests that can be used to capture intended activities that have inter-dependencies such as "give this medication after that one".
  TFhirRequestGroup = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FinstantiatesCanonicalList : TFhirCanonicalList;
    FinstantiatesUriList : TFhirUriList;
    FbasedOnList : TFhirReferenceList;
    FreplacesList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FStatus : TFhirEnum;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FSubject : TFhirReference;
    FEncounter : TFhirReference;
    FAuthoredOn : TFhirDateTime;
    FAuthor : TFhirReference;
    FreasonCodeList : TFhirCodeableConceptList;
    FreasonReferenceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FactionList : TFhirRequestGroupActionList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    function GetInstantiatesCanonicalList : TFhirCanonicalList;
    function GetHasInstantiatesCanonicalList : Boolean;
    function GetInstantiatesUriList : TFhirUriList;
    function GetHasInstantiatesUriList : Boolean;
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    function GetReplacesList : TFhirReferenceList;
    function GetHasReplacesList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirRequestStatusEnum;
    procedure SetStatusST(value : TFhirRequestStatusEnum);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirRequestIntentEnum;
    procedure SetIntentST(value : TFhirRequestIntentEnum);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetSubject(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetAuthor(value : TFhirReference);
    function GetReasonCodeList : TFhirCodeableConceptList;
    function GetHasReasonCodeList : Boolean;
    function GetReasonReferenceList : TFhirReferenceList;
    function GetHasReasonReferenceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetActionList : TFhirRequestGroupActionList;
    function GetHasActionList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirRequestGroup; overload;
    function Clone : TFhirRequestGroup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Allows a service to provide a unique, business identifier for the request.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // A canonical URL referencing a FHIR-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property instantiatesCanonicalList : TFhirCanonicalList read GetInstantiatesCanonicalList;
    property hasInstantiatesCanonicalList : boolean read GetHasInstantiatesCanonicalList;

    // A URL referencing an externally defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this request.
    property instantiatesUriList : TFhirUriList read GetInstantiatesUriList;
    property hasInstantiatesUriList : boolean read GetHasInstantiatesUriList;

    // A plan, proposal or order that is fulfilled in whole or in part by this request.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Completed or terminated request(s) whose function is taken by this new request.
    property replacesList : TFhirReferenceList read GetReplacesList;
    property hasReplacesList : boolean read GetHasReplacesList;

    // Typed access to A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // A shared identifier common to all requests that were authorized more or less simultaneously by a single author, representing the identifier of the requisition, prescription or similar form.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // The current state of the request. For request groups, the status reflects the status of all the requests in the group.
    property status : TFhirRequestStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Indicates the level of authority/intentionality associated with the request and where the request fits into the workflow chain.
    property intent : TFhirRequestIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the request should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to A code that identifies what the overall request group is. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A code that identifies what the overall request group is.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to The subject for which the request group was created. (defined for API consistency)
    property subject : TFhirReference read FSubject write SetSubject;
    // The subject for which the request group was created.
    property subjectElement : TFhirReference read FSubject write SetSubject;

    // Typed access to Describes the context of the request group, if any. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // Describes the context of the request group, if any.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Indicates when the request group was created.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // Indicates when the request group was created.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to Provides a reference to the author of the request group. (defined for API consistency)
    property author : TFhirReference read FAuthor write SetAuthor;
    // Provides a reference to the author of the request group.
    property authorElement : TFhirReference read FAuthor write SetAuthor;

    // Describes the reason for the request group in coded or textual form.
    property reasonCodeList : TFhirCodeableConceptList read GetReasonCodeList;
    property hasReasonCodeList : boolean read GetHasReasonCodeList;

    // Indicates another resource whose existence justifies this request group.
    property reasonReferenceList : TFhirReferenceList read GetReasonReferenceList;
    property hasReasonReferenceList : boolean read GetHasReasonReferenceList;

    // Provides a mechanism to communicate additional information about the response.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // The actions, if any, produced by the evaluation of the artifact.
    property actionList : TFhirRequestGroupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirRequestGroupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirRequestGroupList;
    function GetCurrent : TFhirRequestGroup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirRequestGroupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirRequestGroup read GetCurrent;
  end;

  TFhirRequestGroupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirRequestGroup;
    procedure SetItemN(index : Integer; value : TFhirRequestGroup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirRequestGroupList; overload;
    function Clone : TFhirRequestGroupList; overload;
    function GetEnumerator : TFhirRequestGroupListEnumerator;
    
    //  Add a FhirRequestGroup to the end of the list.
    function Append : TFhirRequestGroup;
    
    // Add an already existing FhirRequestGroup to the end of the list.
    function AddItem(value : TFhirRequestGroup) : TFhirRequestGroup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirRequestGroup) : Integer;
    
    // Insert FhirRequestGroup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirRequestGroup;
    
    // Insert an existing FhirRequestGroup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirRequestGroup);
    
    // Get the iIndexth FhirRequestGroup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirRequestGroup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirRequestGroup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirRequestGroups[index : Integer] : TFhirRequestGroup read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
  // The ResearchDefinition resource describes the conditional state (population and any exposures being compared within the population) and outcome (if specified) that the knowledge (evidence, assertion, recommendation) is about.
  TFhirResearchDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FShortTitle : TFhirString;
    FSubtitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FSubject : TFhirDataType;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FcommentList : TFhirStringList;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirCanonicalList;
    FPopulation : TFhirReference;
    FExposure : TFhirReference;
    FExposureAlternative : TFhirReference;
    FOutcome : TFhirReference;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetShortTitle(value : TFhirString);
    function GetShortTitleST : String;
    procedure SetShortTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetSubject(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetCommentList : TFhirStringList;
    function GetHasCommentList : Boolean;
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirCanonicalList;
    function GetHasLibrary_List : Boolean;
    procedure SetPopulation(value : TFhirReference);
    procedure SetExposure(value : TFhirReference);
    procedure SetExposureAlternative(value : TFhirReference);
    procedure SetOutcome(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchDefinition; overload;
    function Clone : TFhirResearchDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this research definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this research definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the research definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this research definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this research definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the research definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this research definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the research definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the research definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the research definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the research definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the research definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the research definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the research definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the research definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitle : String read GetShortTitleST write SetShortTitleST;
    // The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitleElement : TFhirString read FShortTitle write SetShortTitle;

    // Typed access to An explanatory or alternate title for the ResearchDefinition giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the ResearchDefinition giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this research definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this research definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this research definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The intended subjects for the ResearchDefinition. If this element is not provided, a Patient subject is assumed, but the subject of the ResearchDefinition can be anything. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // The intended subjects for the ResearchDefinition. If this element is not provided, a Patient subject is assumed, but the subject of the ResearchDefinition can be anything.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the research definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the research definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the research definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the research definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the research definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the research definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the research definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the research definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property commentList : TFhirStringList read GetCommentList;
    property hasCommentList : boolean read GetHasCommentList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate research definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the research definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this research definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this research definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description, from a clinical perspective, of how the ResearchDefinition is used.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description, from a clinical perspective, of how the ResearchDefinition is used.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the research definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the research definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the research definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the research definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the research definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the research definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the ResearchDefinition. Topics provide a high-level categorization grouping types of ResearchDefinitions that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing the formal logic used by the ResearchDefinition.
    property library_List : TFhirCanonicalList read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // Typed access to A reference to a ResearchElementDefinition resource that defines the population for the research. (defined for API consistency)
    property population : TFhirReference read FPopulation write SetPopulation;
    // A reference to a ResearchElementDefinition resource that defines the population for the research.
    property populationElement : TFhirReference read FPopulation write SetPopulation;

    // Typed access to A reference to a ResearchElementDefinition resource that defines the exposure for the research. (defined for API consistency)
    property exposure : TFhirReference read FExposure write SetExposure;
    // A reference to a ResearchElementDefinition resource that defines the exposure for the research.
    property exposureElement : TFhirReference read FExposure write SetExposure;

    // Typed access to A reference to a ResearchElementDefinition resource that defines the exposureAlternative for the research. (defined for API consistency)
    property exposureAlternative : TFhirReference read FExposureAlternative write SetExposureAlternative;
    // A reference to a ResearchElementDefinition resource that defines the exposureAlternative for the research.
    property exposureAlternativeElement : TFhirReference read FExposureAlternative write SetExposureAlternative;

    // Typed access to A reference to a ResearchElementDefinition resomece that defines the outcome for the research. (defined for API consistency)
    property outcome : TFhirReference read FOutcome write SetOutcome;
    // A reference to a ResearchElementDefinition resomece that defines the outcome for the research.
    property outcomeElement : TFhirReference read FOutcome write SetOutcome;

  end;

  TFhirResearchDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchDefinitionList;
    function GetCurrent : TFhirResearchDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchDefinition read GetCurrent;
  end;

  TFhirResearchDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchDefinition;
    procedure SetItemN(index : Integer; value : TFhirResearchDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchDefinitionList; overload;
    function Clone : TFhirResearchDefinitionList; overload;
    function GetEnumerator : TFhirResearchDefinitionListEnumerator;
    
    //  Add a FhirResearchDefinition to the end of the list.
    function Append : TFhirResearchDefinition;
    
    // Add an already existing FhirResearchDefinition to the end of the list.
    function AddItem(value : TFhirResearchDefinition) : TFhirResearchDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchDefinition) : Integer;
    
    // Insert FhirResearchDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchDefinition;
    
    // Insert an existing FhirResearchDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchDefinition);
    
    // Get the iIndexth FhirResearchDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchDefinitions[index : Integer] : TFhirResearchDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
  // A characteristic that defines the members of the research element. Multiple characteristics are applied with "and" semantics.
  TFhirResearchElementDefinitionCharacteristic = class (TFhirBackboneElement)
  protected
    FDefinition : TFhirDataType;
    FusageContextList : TFhirUsageContextList;
    FExclude : TFhirBoolean;
    FUnitOfMeasure : TFhirCodeableConcept;
    FStudyEffectiveDescription : TFhirString;
    FStudyEffective : TFhirDataType;
    FStudyEffectiveTimeFromStart : TFhirDuration;
    FStudyEffectiveGroupMeasure : TFhirEnum;
    FParticipantEffectiveDescription : TFhirString;
    FParticipantEffective : TFhirDataType;
    FParticipantEffectiveTimeFromStart : TFhirDuration;
    FParticipantEffectiveGroupMeasure : TFhirEnum;
    procedure SetDefinition(value : TFhirDataType);
    function GetUsageContextList : TFhirUsageContextList;
    function GetHasUsageContextList : Boolean;
    procedure SetExclude(value : TFhirBoolean);
    function GetExcludeST : Boolean;
    procedure SetExcludeST(value : Boolean);
    procedure SetUnitOfMeasure(value : TFhirCodeableConcept);
    procedure SetStudyEffectiveDescription(value : TFhirString);
    function GetStudyEffectiveDescriptionST : String;
    procedure SetStudyEffectiveDescriptionST(value : String);
    procedure SetStudyEffective(value : TFhirDataType);
    procedure SetStudyEffectiveTimeFromStart(value : TFhirDuration);
    procedure SetStudyEffectiveGroupMeasure(value : TFhirEnum);
    function GetStudyEffectiveGroupMeasureST : TFhirGroupMeasureEnum;
    procedure SetStudyEffectiveGroupMeasureST(value : TFhirGroupMeasureEnum);
    procedure SetParticipantEffectiveDescription(value : TFhirString);
    function GetParticipantEffectiveDescriptionST : String;
    procedure SetParticipantEffectiveDescriptionST(value : String);
    procedure SetParticipantEffective(value : TFhirDataType);
    procedure SetParticipantEffectiveTimeFromStart(value : TFhirDuration);
    procedure SetParticipantEffectiveGroupMeasure(value : TFhirEnum);
    function GetParticipantEffectiveGroupMeasureST : TFhirGroupMeasureEnum;
    procedure SetParticipantEffectiveGroupMeasureST(value : TFhirGroupMeasureEnum);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchElementDefinitionCharacteristic; overload;
    function Clone : TFhirResearchElementDefinitionCharacteristic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Define members of the research element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year). (defined for API consistency)
    property definition : TFhirDataType read FDefinition write SetDefinition;
    // Define members of the research element using Codes (such as condition, medication, or observation), Expressions ( using an expression language such as FHIRPath or CQL) or DataRequirements (such as Diabetes diagnosis onset in the last year).
    property definitionElement : TFhirDataType read FDefinition write SetDefinition;

    // Use UsageContext to define the members of the population, such as Age Ranges, Genders, Settings.
    property usageContextList : TFhirUsageContextList read GetUsageContextList;
    property hasUsageContextList : boolean read GetHasUsageContextList;

    // Typed access to When true, members with this characteristic are excluded from the element.
    property exclude : Boolean read GetExcludeST write SetExcludeST;
    // When true, members with this characteristic are excluded from the element.
    property excludeElement : TFhirBoolean read FExclude write SetExclude;

    // Typed access to Specifies the UCUM unit for the outcome. (defined for API consistency)
    property unitOfMeasure : TFhirCodeableConcept read FUnitOfMeasure write SetUnitOfMeasure;
    // Specifies the UCUM unit for the outcome.
    property unitOfMeasureElement : TFhirCodeableConcept read FUnitOfMeasure write SetUnitOfMeasure;

    // Typed access to A narrative description of the time period the study covers.
    property studyEffectiveDescription : String read GetStudyEffectiveDescriptionST write SetStudyEffectiveDescriptionST;
    // A narrative description of the time period the study covers.
    property studyEffectiveDescriptionElement : TFhirString read FStudyEffectiveDescription write SetStudyEffectiveDescription;

    // Typed access to Indicates what effective period the study covers. (defined for API consistency)
    property studyEffective : TFhirDataType read FStudyEffective write SetStudyEffective;
    // Indicates what effective period the study covers.
    property studyEffectiveElement : TFhirDataType read FStudyEffective write SetStudyEffective;

    // Typed access to Indicates duration from the study initiation. (defined for API consistency)
    property studyEffectiveTimeFromStart : TFhirDuration read FStudyEffectiveTimeFromStart write SetStudyEffectiveTimeFromStart;
    // Indicates duration from the study initiation.
    property studyEffectiveTimeFromStartElement : TFhirDuration read FStudyEffectiveTimeFromStart write SetStudyEffectiveTimeFromStart;

    // Indicates how elements are aggregated within the study effective period.
    property studyEffectiveGroupMeasure : TFhirGroupMeasureEnum read GetStudyEffectiveGroupMeasureST write SetStudyEffectiveGroupMeasureST;
    property studyEffectiveGroupMeasureElement : TFhirEnum read FStudyEffectiveGroupMeasure write SetStudyEffectiveGroupMeasure;

    // Typed access to A narrative description of the time period the study covers.
    property participantEffectiveDescription : String read GetParticipantEffectiveDescriptionST write SetParticipantEffectiveDescriptionST;
    // A narrative description of the time period the study covers.
    property participantEffectiveDescriptionElement : TFhirString read FParticipantEffectiveDescription write SetParticipantEffectiveDescription;

    // Typed access to Indicates what effective period the study covers. (defined for API consistency)
    property participantEffective : TFhirDataType read FParticipantEffective write SetParticipantEffective;
    // Indicates what effective period the study covers.
    property participantEffectiveElement : TFhirDataType read FParticipantEffective write SetParticipantEffective;

    // Typed access to Indicates duration from the participant's study entry. (defined for API consistency)
    property participantEffectiveTimeFromStart : TFhirDuration read FParticipantEffectiveTimeFromStart write SetParticipantEffectiveTimeFromStart;
    // Indicates duration from the participant's study entry.
    property participantEffectiveTimeFromStartElement : TFhirDuration read FParticipantEffectiveTimeFromStart write SetParticipantEffectiveTimeFromStart;

    // Indicates how elements are aggregated within the study effective period.
    property participantEffectiveGroupMeasure : TFhirGroupMeasureEnum read GetParticipantEffectiveGroupMeasureST write SetParticipantEffectiveGroupMeasureST;
    property participantEffectiveGroupMeasureElement : TFhirEnum read FParticipantEffectiveGroupMeasure write SetParticipantEffectiveGroupMeasure;

  end;

  TFhirResearchElementDefinitionCharacteristicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchElementDefinitionCharacteristicList;
    function GetCurrent : TFhirResearchElementDefinitionCharacteristic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchElementDefinitionCharacteristicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchElementDefinitionCharacteristic read GetCurrent;
  end;

  TFhirResearchElementDefinitionCharacteristicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchElementDefinitionCharacteristic;
    procedure SetItemN(index : Integer; value : TFhirResearchElementDefinitionCharacteristic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchElementDefinitionCharacteristicList; overload;
    function Clone : TFhirResearchElementDefinitionCharacteristicList; overload;
    function GetEnumerator : TFhirResearchElementDefinitionCharacteristicListEnumerator;
    
    //  Add a FhirResearchElementDefinitionCharacteristic to the end of the list.
    function Append : TFhirResearchElementDefinitionCharacteristic;
    
    // Add an already existing FhirResearchElementDefinitionCharacteristic to the end of the list.
    function AddItem(value : TFhirResearchElementDefinitionCharacteristic) : TFhirResearchElementDefinitionCharacteristic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchElementDefinitionCharacteristic) : Integer;
    
    // Insert FhirResearchElementDefinitionCharacteristic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchElementDefinitionCharacteristic;
    
    // Insert an existing FhirResearchElementDefinitionCharacteristic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchElementDefinitionCharacteristic);
    
    // Get the iIndexth FhirResearchElementDefinitionCharacteristic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchElementDefinitionCharacteristic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchElementDefinitionCharacteristic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchElementDefinitionCharacteristics[index : Integer] : TFhirResearchElementDefinitionCharacteristic read GetItemN write SetItemN; default;
  End;

  // The ResearchElementDefinition resource describes a "PICO" element that knowledge (evidence, assertion, recommendation) is about.
  TFhirResearchElementDefinition = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FName : TFhirString;
    FTitle : TFhirString;
    FShortTitle : TFhirString;
    FSubtitle : TFhirString;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FSubject : TFhirDataType;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FcommentList : TFhirStringList;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FUsage : TFhirString;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FtopicList : TFhirCodeableConceptList;
    FauthorList : TFhirContactDetailList;
    FeditorList : TFhirContactDetailList;
    FreviewerList : TFhirContactDetailList;
    FendorserList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    Flibrary_List : TFhirCanonicalList;
    FType_ : TFhirEnum;
    FVariableType : TFhirEnum;
    FcharacteristicList : TFhirResearchElementDefinitionCharacteristicList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    procedure SetShortTitle(value : TFhirString);
    function GetShortTitleST : String;
    procedure SetShortTitleST(value : String);
    procedure SetSubtitle(value : TFhirString);
    function GetSubtitleST : String;
    procedure SetSubtitleST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetSubject(value : TFhirDataType);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetCommentList : TFhirStringList;
    function GetHasCommentList : Boolean;
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetUsage(value : TFhirString);
    function GetUsageST : String;
    procedure SetUsageST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetTopicList : TFhirCodeableConceptList;
    function GetHasTopicList : Boolean;
    function GetAuthorList : TFhirContactDetailList;
    function GetHasAuthorList : Boolean;
    function GetEditorList : TFhirContactDetailList;
    function GetHasEditorList : Boolean;
    function GetReviewerList : TFhirContactDetailList;
    function GetHasReviewerList : Boolean;
    function GetEndorserList : TFhirContactDetailList;
    function GetHasEndorserList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetLibrary_List : TFhirCanonicalList;
    function GetHasLibrary_List : Boolean;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirResearchElementTypeEnum;
    procedure SetType_ST(value : TFhirResearchElementTypeEnum);
    procedure SetVariableType(value : TFhirEnum);
    function GetVariableTypeST : TFhirVariableTypeEnum;
    procedure SetVariableTypeST(value : TFhirVariableTypeEnum);
    function GetCharacteristicList : TFhirResearchElementDefinitionCharacteristicList;
    function GetHasCharacteristicList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchElementDefinition; overload;
    function Clone : TFhirResearchElementDefinition; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URI that is used to identify this research element definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this research element definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the research element definition is stored on different servers.
    property url : String read GetUrlST write SetUrlST;
    // An absolute URI that is used to identify this research element definition when it is referenced in a specification, model, design or an instance; also called its canonical identifier. This SHOULD be globally unique and SHOULD be a literal address at which at which an authoritative instance of this research element definition is (or will be) published. This URL can be the target of a canonical reference. It SHALL remain the same when the research element definition is stored on different servers.
    property urlElement : TFhirUri read FUrl write SetUrl;

    // A formal identifier that is used to identify this research element definition when it is represented in other formats, or referenced in a specification, model, design or an instance.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the research element definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the research element definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the research element definition when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the research element definition author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions can be placed in a lexicographical sequence. To provide a version consistent with the Decision Support Service specification, use the format Major.Minor.Revision (e.g. 1.0.0). For more information on versioning knowledge assets, refer to the Decision Support Service specification. Note that a version is required for non-experimental active artifacts.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A natural language name identifying the research element definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property name : String read GetNameST write SetNameST;
    // A natural language name identifying the research element definition. This name should be usable as an identifier for the module by machine processing applications such as code generation.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short, descriptive, user-friendly title for the research element definition.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the research element definition.
    property titleElement : TFhirString read FTitle write SetTitle;

    // Typed access to The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitle : String read GetShortTitleST write SetShortTitleST;
    // The short title provides an alternate title for use in informal descriptive contexts where the full, formal title is not necessary.
    property shortTitleElement : TFhirString read FShortTitle write SetShortTitle;

    // Typed access to An explanatory or alternate title for the ResearchElementDefinition giving additional information about its content.
    property subtitle : String read GetSubtitleST write SetSubtitleST;
    // An explanatory or alternate title for the ResearchElementDefinition giving additional information about its content.
    property subtitleElement : TFhirString read FSubtitle write SetSubtitle;

    // The status of this research element definition. Enables tracking the life-cycle of the content.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A Boolean value to indicate that this research element definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A Boolean value to indicate that this research element definition is authored for testing purposes (or education/evaluation/marketing) and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to The intended subjects for the ResearchElementDefinition. If this element is not provided, a Patient subject is assumed, but the subject of the ResearchElementDefinition can be anything. (defined for API consistency)
    property subject : TFhirDataType read FSubject write SetSubject;
    // The intended subjects for the ResearchElementDefinition. If this element is not provided, a Patient subject is assumed, but the subject of the ResearchElementDefinition can be anything.
    property subjectElement : TFhirDataType read FSubject write SetSubject;

    // Typed access to The date  (and optionally time) when the research element definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the research element definition changes.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date  (and optionally time) when the research element definition was published. The date must change when the business version changes and it must change if the status code changes. In addition, it should change when the substantive content of the research element definition changes.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to The name of the organization or individual that published the research element definition.
    property publisher : String read GetPublisherST write SetPublisherST;
    // The name of the organization or individual that published the research element definition.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the research element definition from a consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the research element definition from a consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // A human-readable string to clarify or explain concepts about the resource.
    property commentList : TFhirStringList read GetCommentList;
    property hasCommentList : boolean read GetHasCommentList;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These contexts may be general categories (gender, age, ...) or may be references to specific programs (insurance plans, studies, ...) and may be used to assist with indexing and searching for appropriate research element definition instances.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A legal or geographic region in which the research element definition is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explanation of why this research element definition is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explanation of why this research element definition is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A detailed description, from a clinical perspective, of how the ResearchElementDefinition is used.
    property usage : String read GetUsageST write SetUsageST;
    // A detailed description, from a clinical perspective, of how the ResearchElementDefinition is used.
    property usageElement : TFhirString read FUsage write SetUsage;

    // Typed access to A copyright statement relating to the research element definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the research element definition.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the research element definition and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the research element definition.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the resource content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the resource content was last reviewed. Review happens periodically after approval but does not change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the research element definition content was or is planned to be in active use. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the research element definition content was or is planned to be in active use.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // Descriptive topics related to the content of the ResearchElementDefinition. Topics provide a high-level categorization grouping types of ResearchElementDefinitions that can be useful for filtering and searching.
    property topicList : TFhirCodeableConceptList read GetTopicList;
    property hasTopicList : boolean read GetHasTopicList;

    // An individiual or organization primarily involved in the creation and maintenance of the content.
    property authorList : TFhirContactDetailList read GetAuthorList;
    property hasAuthorList : boolean read GetHasAuthorList;

    // An individual or organization primarily responsible for internal coherence of the content.
    property editorList : TFhirContactDetailList read GetEditorList;
    property hasEditorList : boolean read GetHasEditorList;

    // An individual or organization primarily responsible for review of some aspect of the content.
    property reviewerList : TFhirContactDetailList read GetReviewerList;
    property hasReviewerList : boolean read GetHasReviewerList;

    // An individual or organization responsible for officially endorsing the content for use in some setting.
    property endorserList : TFhirContactDetailList read GetEndorserList;
    property hasEndorserList : boolean read GetHasEndorserList;

    // Related artifacts such as additional documentation, justification, or bibliographic references.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // A reference to a Library resource containing the formal logic used by the ResearchElementDefinition.
    property library_List : TFhirCanonicalList read GetLibrary_List;
    property hasLibrary_List : boolean read GetHasLibrary_List;

    // The type of research element, a population, an exposure, or an outcome.
    property type_ : TFhirResearchElementTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // The type of the outcome (e.g. Dichotomous, Continuous, or Descriptive).
    property variableType : TFhirVariableTypeEnum read GetVariableTypeST write SetVariableTypeST;
    property variableTypeElement : TFhirEnum read FVariableType write SetVariableType;

    // A characteristic that defines the members of the research element. Multiple characteristics are applied with "and" semantics.
    property characteristicList : TFhirResearchElementDefinitionCharacteristicList read GetCharacteristicList;
    property hasCharacteristicList : boolean read GetHasCharacteristicList;

  end;

  TFhirResearchElementDefinitionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchElementDefinitionList;
    function GetCurrent : TFhirResearchElementDefinition;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchElementDefinitionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchElementDefinition read GetCurrent;
  end;

  TFhirResearchElementDefinitionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchElementDefinition;
    procedure SetItemN(index : Integer; value : TFhirResearchElementDefinition);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchElementDefinitionList; overload;
    function Clone : TFhirResearchElementDefinitionList; overload;
    function GetEnumerator : TFhirResearchElementDefinitionListEnumerator;
    
    //  Add a FhirResearchElementDefinition to the end of the list.
    function Append : TFhirResearchElementDefinition;
    
    // Add an already existing FhirResearchElementDefinition to the end of the list.
    function AddItem(value : TFhirResearchElementDefinition) : TFhirResearchElementDefinition; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchElementDefinition) : Integer;
    
    // Insert FhirResearchElementDefinition before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchElementDefinition;
    
    // Insert an existing FhirResearchElementDefinition before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchElementDefinition);
    
    // Get the iIndexth FhirResearchElementDefinition. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchElementDefinition);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchElementDefinition;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchElementDefinitions[index : Integer] : TFhirResearchElementDefinition read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
  // Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
  TFhirResearchStudyArm = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    FDescription : TFhirString;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyArm; overload;
    function Clone : TFhirResearchStudyArm; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Unique, human-readable label for this arm of the study.
    property name : String read GetNameST write SetNameST;
    // Unique, human-readable label for this arm of the study.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to Categorization of study arm, e.g. experimental, active comparator, placebo comparater. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // Categorization of study arm, e.g. experimental, active comparator, placebo comparater.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to A succinct description of the path through the study that would be followed by a subject adhering to this arm.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A succinct description of the path through the study that would be followed by a subject adhering to this arm.
    property descriptionElement : TFhirString read FDescription write SetDescription;

  end;

  TFhirResearchStudyArmListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyArmList;
    function GetCurrent : TFhirResearchStudyArm;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyArmList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyArm read GetCurrent;
  end;

  TFhirResearchStudyArmList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyArm;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyArm);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyArmList; overload;
    function Clone : TFhirResearchStudyArmList; overload;
    function GetEnumerator : TFhirResearchStudyArmListEnumerator;
    
    //  Add a FhirResearchStudyArm to the end of the list.
    function Append : TFhirResearchStudyArm;
    
    // Add an already existing FhirResearchStudyArm to the end of the list.
    function AddItem(value : TFhirResearchStudyArm) : TFhirResearchStudyArm; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyArm) : Integer;
    
    // Insert FhirResearchStudyArm before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyArm;
    
    // Insert an existing FhirResearchStudyArm before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyArm);
    
    // Get the iIndexth FhirResearchStudyArm. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyArm);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyArm;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyArms[index : Integer] : TFhirResearchStudyArm read GetItemN write SetItemN; default;
  End;

  // A goal that the study is aiming to achieve in terms of a scientific question to be answered by the analysis of data collected during the study.
  TFhirResearchStudyObjective = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FType_ : TFhirCodeableConcept;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetType_(value : TFhirCodeableConcept);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudyObjective; overload;
    function Clone : TFhirResearchStudyObjective; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Unique, human-readable label for this objective of the study.
    property name : String read GetNameST write SetNameST;
    // Unique, human-readable label for this objective of the study.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to The kind of study objective. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The kind of study objective.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

  end;

  TFhirResearchStudyObjectiveListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyObjectiveList;
    function GetCurrent : TFhirResearchStudyObjective;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyObjectiveList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudyObjective read GetCurrent;
  end;

  TFhirResearchStudyObjectiveList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudyObjective;
    procedure SetItemN(index : Integer; value : TFhirResearchStudyObjective);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyObjectiveList; overload;
    function Clone : TFhirResearchStudyObjectiveList; overload;
    function GetEnumerator : TFhirResearchStudyObjectiveListEnumerator;
    
    //  Add a FhirResearchStudyObjective to the end of the list.
    function Append : TFhirResearchStudyObjective;
    
    // Add an already existing FhirResearchStudyObjective to the end of the list.
    function AddItem(value : TFhirResearchStudyObjective) : TFhirResearchStudyObjective; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudyObjective) : Integer;
    
    // Insert FhirResearchStudyObjective before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudyObjective;
    
    // Insert an existing FhirResearchStudyObjective before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudyObjective);
    
    // Get the iIndexth FhirResearchStudyObjective. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudyObjective);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudyObjective;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudyObjectives[index : Integer] : TFhirResearchStudyObjective read GetItemN write SetItemN; default;
  End;

  // A process where a researcher or organization plans and then executes a series of steps intended to increase the field of healthcare-related knowledge.  This includes studies of safety, efficacy, comparative effectiveness and other information about medications, devices, therapies and other interventional and investigative techniques.  A ResearchStudy involves the gathering of information about human or animal subjects.
  TFhirResearchStudy = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FTitle : TFhirString;
    FprotocolList : TFhirReferenceList;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FPrimaryPurposeType : TFhirCodeableConcept;
    FPhase : TFhirCodeableConcept;
    FcategoryList : TFhirCodeableConceptList;
    FfocusList : TFhirCodeableConceptList;
    FconditionList : TFhirCodeableConceptList;
    FcontactList : TFhirContactDetailList;
    FrelatedArtifactList : TFhirRelatedArtifactList;
    FkeywordList : TFhirCodeableConceptList;
    FlocationList : TFhirCodeableConceptList;
    FDescription : TFhirMarkdown;
    FenrollmentList : TFhirReferenceList;
    FPeriod : TFhirPeriod;
    FSponsor : TFhirReference;
    FPrincipalInvestigator : TFhirReference;
    FsiteList : TFhirReferenceList;
    FReasonStopped : TFhirCodeableConcept;
    FnoteList : TFhirAnnotationList;
    FarmList : TFhirResearchStudyArmList;
    FobjectiveList : TFhirResearchStudyObjectiveList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    function GetProtocolList : TFhirReferenceList;
    function GetHasProtocolList : Boolean;
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirResearchStudyStatusEnum;
    procedure SetStatusST(value : TFhirResearchStudyStatusEnum);
    procedure SetPrimaryPurposeType(value : TFhirCodeableConcept);
    procedure SetPhase(value : TFhirCodeableConcept);
    function GetCategoryList : TFhirCodeableConceptList;
    function GetHasCategoryList : Boolean;
    function GetFocusList : TFhirCodeableConceptList;
    function GetHasFocusList : Boolean;
    function GetConditionList : TFhirCodeableConceptList;
    function GetHasConditionList : Boolean;
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    function GetRelatedArtifactList : TFhirRelatedArtifactList;
    function GetHasRelatedArtifactList : Boolean;
    function GetKeywordList : TFhirCodeableConceptList;
    function GetHasKeywordList : Boolean;
    function GetLocationList : TFhirCodeableConceptList;
    function GetHasLocationList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetEnrollmentList : TFhirReferenceList;
    function GetHasEnrollmentList : Boolean;
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetSponsor(value : TFhirReference);
    procedure SetPrincipalInvestigator(value : TFhirReference);
    function GetSiteList : TFhirReferenceList;
    function GetHasSiteList : Boolean;
    procedure SetReasonStopped(value : TFhirCodeableConcept);
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetArmList : TFhirResearchStudyArmList;
    function GetHasArmList : Boolean;
    function GetObjectiveList : TFhirResearchStudyObjectiveList;
    function GetHasObjectiveList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchStudy; overload;
    function Clone : TFhirResearchStudy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this research study by the sponsor or other systems.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to A short, descriptive user-friendly label for the study.
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive user-friendly label for the study.
    property titleElement : TFhirString read FTitle write SetTitle;

    // The set of steps expected to be performed as part of the execution of the study.
    property protocolList : TFhirReferenceList read GetProtocolList;
    property hasProtocolList : boolean read GetHasProtocolList;

    // A larger research study of which this particular study is a component or step.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The current state of the study.
    property status : TFhirResearchStudyStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The type of study based upon the intent of the study's activities. A classification of the intent of the study. (defined for API consistency)
    property primaryPurposeType : TFhirCodeableConcept read FPrimaryPurposeType write SetPrimaryPurposeType;
    // The type of study based upon the intent of the study's activities. A classification of the intent of the study.
    property primaryPurposeTypeElement : TFhirCodeableConcept read FPrimaryPurposeType write SetPrimaryPurposeType;

    // Typed access to The stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation. (defined for API consistency)
    property phase : TFhirCodeableConcept read FPhase write SetPhase;
    // The stage in the progression of a therapy from initial experimental use in humans in clinical trials to post-market evaluation.
    property phaseElement : TFhirCodeableConcept read FPhase write SetPhase;

    // Codes categorizing the type of study such as investigational vs. observational, type of blinding, type of randomization, safety vs. efficacy, etc.
    property categoryList : TFhirCodeableConceptList read GetCategoryList;
    property hasCategoryList : boolean read GetHasCategoryList;

    // The medication(s), food(s), therapy(ies), device(s) or other concerns or interventions that the study is seeking to gain more information about.
    property focusList : TFhirCodeableConceptList read GetFocusList;
    property hasFocusList : boolean read GetHasFocusList;

    // The condition that is the focus of the study.  For example, In a study to examine risk factors for Lupus, might have as an inclusion criterion "healthy volunteer", but the target condition code would be a Lupus SNOMED code.
    property conditionList : TFhirCodeableConceptList read GetConditionList;
    property hasConditionList : boolean read GetHasConditionList;

    // Contact details to assist a user in learning more about or engaging with the study.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Citations, references and other related documents.
    property relatedArtifactList : TFhirRelatedArtifactList read GetRelatedArtifactList;
    property hasRelatedArtifactList : boolean read GetHasRelatedArtifactList;

    // Key terms to aid in searching for or filtering the study.
    property keywordList : TFhirCodeableConceptList read GetKeywordList;
    property hasKeywordList : boolean read GetHasKeywordList;

    // Indicates a country, state or other region where the study is taking place.
    property locationList : TFhirCodeableConceptList read GetLocationList;
    property hasLocationList : boolean read GetHasLocationList;

    // Typed access to A full description of how the study is being conducted.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A full description of how the study is being conducted.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Reference to a Group that defines the criteria for and quantity of subjects participating in the study.  E.g. " 200 female Europeans between the ages of 20 and 45 with early onset diabetes".
    property enrollmentList : TFhirReferenceList read GetEnrollmentList;
    property hasEnrollmentList : boolean read GetHasEnrollmentList;

    // Typed access to Identifies the start date and the expected (or actual, depending on status) end date for the study. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Identifies the start date and the expected (or actual, depending on status) end date for the study.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to An organization that initiates the investigation and is legally responsible for the study. (defined for API consistency)
    property sponsor : TFhirReference read FSponsor write SetSponsor;
    // An organization that initiates the investigation and is legally responsible for the study.
    property sponsorElement : TFhirReference read FSponsor write SetSponsor;

    // Typed access to A researcher in a study who oversees multiple aspects of the study, such as concept development, protocol writing, protocol submission for IRB approval, participant recruitment, informed consent, data collection, analysis, interpretation and presentation. (defined for API consistency)
    property principalInvestigator : TFhirReference read FPrincipalInvestigator write SetPrincipalInvestigator;
    // A researcher in a study who oversees multiple aspects of the study, such as concept development, protocol writing, protocol submission for IRB approval, participant recruitment, informed consent, data collection, analysis, interpretation and presentation.
    property principalInvestigatorElement : TFhirReference read FPrincipalInvestigator write SetPrincipalInvestigator;

    // A facility in which study activities are conducted.
    property siteList : TFhirReferenceList read GetSiteList;
    property hasSiteList : boolean read GetHasSiteList;

    // Typed access to A description and/or code explaining the premature termination of the study. (defined for API consistency)
    property reasonStopped : TFhirCodeableConcept read FReasonStopped write SetReasonStopped;
    // A description and/or code explaining the premature termination of the study.
    property reasonStoppedElement : TFhirCodeableConcept read FReasonStopped write SetReasonStopped;

    // Comments made about the study by the performer, subject or other participants.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Describes an expected sequence of events for one of the participants of a study.  E.g. Exposure to drug A, wash-out, exposure to drug B, wash-out, follow-up.
    property armList : TFhirResearchStudyArmList read GetArmList;
    property hasArmList : boolean read GetHasArmList;

    // A goal that the study is aiming to achieve in terms of a scientific question to be answered by the analysis of data collected during the study.
    property objectiveList : TFhirResearchStudyObjectiveList read GetObjectiveList;
    property hasObjectiveList : boolean read GetHasObjectiveList;

  end;

  TFhirResearchStudyListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchStudyList;
    function GetCurrent : TFhirResearchStudy;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchStudyList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchStudy read GetCurrent;
  end;

  TFhirResearchStudyList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchStudy;
    procedure SetItemN(index : Integer; value : TFhirResearchStudy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchStudyList; overload;
    function Clone : TFhirResearchStudyList; overload;
    function GetEnumerator : TFhirResearchStudyListEnumerator;
    
    //  Add a FhirResearchStudy to the end of the list.
    function Append : TFhirResearchStudy;
    
    // Add an already existing FhirResearchStudy to the end of the list.
    function AddItem(value : TFhirResearchStudy) : TFhirResearchStudy; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchStudy) : Integer;
    
    // Insert FhirResearchStudy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchStudy;
    
    // Insert an existing FhirResearchStudy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchStudy);
    
    // Get the iIndexth FhirResearchStudy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchStudy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchStudy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchStudies[index : Integer] : TFhirResearchStudy read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
  // A physical entity which is the primary unit of operational and/or administrative interest in a study.
  TFhirResearchSubject = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FStatus : TFhirEnum;
    FPeriod : TFhirPeriod;
    FStudy : TFhirReference;
    FIndividual : TFhirReference;
    FAssignedArm : TFhirString;
    FActualArm : TFhirString;
    FConsent : TFhirReference;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirResearchSubjectStatusEnum;
    procedure SetStatusST(value : TFhirResearchSubjectStatusEnum);
    procedure SetPeriod(value : TFhirPeriod);
    procedure SetStudy(value : TFhirReference);
    procedure SetIndividual(value : TFhirReference);
    procedure SetAssignedArm(value : TFhirString);
    function GetAssignedArmST : String;
    procedure SetAssignedArmST(value : String);
    procedure SetActualArm(value : TFhirString);
    function GetActualArmST : String;
    procedure SetActualArmST(value : String);
    procedure SetConsent(value : TFhirReference);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirResearchSubject; overload;
    function Clone : TFhirResearchSubject; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Identifiers assigned to this research subject for a study.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // The current state of the subject.
    property status : TFhirResearchSubjectStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to The dates the subject began and ended their participation in the study. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // The dates the subject began and ended their participation in the study.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // Typed access to Reference to the study the subject is participating in. (defined for API consistency)
    property study : TFhirReference read FStudy write SetStudy;
    // Reference to the study the subject is participating in.
    property studyElement : TFhirReference read FStudy write SetStudy;

    // Typed access to The record of the person or animal who is involved in the study. (defined for API consistency)
    property individual : TFhirReference read FIndividual write SetIndividual;
    // The record of the person or animal who is involved in the study.
    property individualElement : TFhirReference read FIndividual write SetIndividual;

    // Typed access to The name of the arm in the study the subject is expected to follow as part of this study.
    property assignedArm : String read GetAssignedArmST write SetAssignedArmST;
    // The name of the arm in the study the subject is expected to follow as part of this study.
    property assignedArmElement : TFhirString read FAssignedArm write SetAssignedArm;

    // Typed access to The name of the arm in the study the subject actually followed as part of this study.
    property actualArm : String read GetActualArmST write SetActualArmST;
    // The name of the arm in the study the subject actually followed as part of this study.
    property actualArmElement : TFhirString read FActualArm write SetActualArm;

    // Typed access to A record of the patient's informed agreement to participate in the study. (defined for API consistency)
    property consent : TFhirReference read FConsent write SetConsent;
    // A record of the patient's informed agreement to participate in the study.
    property consentElement : TFhirReference read FConsent write SetConsent;

  end;

  TFhirResearchSubjectListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirResearchSubjectList;
    function GetCurrent : TFhirResearchSubject;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirResearchSubjectList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirResearchSubject read GetCurrent;
  end;

  TFhirResearchSubjectList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirResearchSubject;
    procedure SetItemN(index : Integer; value : TFhirResearchSubject);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirResearchSubjectList; overload;
    function Clone : TFhirResearchSubjectList; overload;
    function GetEnumerator : TFhirResearchSubjectListEnumerator;
    
    //  Add a FhirResearchSubject to the end of the list.
    function Append : TFhirResearchSubject;
    
    // Add an already existing FhirResearchSubject to the end of the list.
    function AddItem(value : TFhirResearchSubject) : TFhirResearchSubject; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirResearchSubject) : Integer;
    
    // Insert FhirResearchSubject before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirResearchSubject;
    
    // Insert an existing FhirResearchSubject before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirResearchSubject);
    
    // Get the iIndexth FhirResearchSubject. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirResearchSubject);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirResearchSubject;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirResearchSubjects[index : Integer] : TFhirResearchSubject read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_SUBSCRIPTION}
  // Details where to send notifications when resources are received that meet the criteria.
  TFhirSubscriptionChannel = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FEndpoint : TFhirUrl;
    FPayload : TFhirCode;
    FheaderList : TFhirStringList;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirSubscriptionChannelTypeEnum;
    procedure SetType_ST(value : TFhirSubscriptionChannelTypeEnum);
    procedure SetEndpoint(value : TFhirUrl);
    function GetEndpointST : String;
    procedure SetEndpointST(value : String);
    procedure SetPayload(value : TFhirCode);
    function GetPayloadST : String;
    procedure SetPayloadST(value : String);
    function GetHeaderList : TFhirStringList;
    function GetHasHeaderList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionChannel; overload;
    function Clone : TFhirSubscriptionChannel; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of channel to send notifications on.
    property type_ : TFhirSubscriptionChannelTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The url that describes the actual end-point to send messages to.
    property endpoint : String read GetEndpointST write SetEndpointST;
    // The url that describes the actual end-point to send messages to.
    property endpointElement : TFhirUrl read FEndpoint write SetEndpoint;

    // Typed access to The mime type to send the payload in - either application/fhir+xml, or application/fhir+json. If the payload is not present, then there is no payload in the notification, just a notification. The mime type "text/plain" may also be used for Email and SMS subscriptions.
    property payload : String read GetPayloadST write SetPayloadST;
    // The mime type to send the payload in - either application/fhir+xml, or application/fhir+json. If the payload is not present, then there is no payload in the notification, just a notification. The mime type "text/plain" may also be used for Email and SMS subscriptions.
    property payloadElement : TFhirCode read FPayload write SetPayload;

    // Additional headers / information to send as part of the notification.
    property headerList : TFhirStringList read GetHeaderList;
    property hasHeaderList : boolean read GetHasHeaderList;

  end;

  TFhirSubscriptionChannelListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionChannelList;
    function GetCurrent : TFhirSubscriptionChannel;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionChannelList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionChannel read GetCurrent;
  end;

  TFhirSubscriptionChannelList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionChannel;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionChannel);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionChannelList; overload;
    function Clone : TFhirSubscriptionChannelList; overload;
    function GetEnumerator : TFhirSubscriptionChannelListEnumerator;
    
    //  Add a FhirSubscriptionChannel to the end of the list.
    function Append : TFhirSubscriptionChannel;
    
    // Add an already existing FhirSubscriptionChannel to the end of the list.
    function AddItem(value : TFhirSubscriptionChannel) : TFhirSubscriptionChannel; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionChannel) : Integer;
    
    // Insert FhirSubscriptionChannel before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionChannel;
    
    // Insert an existing FhirSubscriptionChannel before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionChannel);
    
    // Get the iIndexth FhirSubscriptionChannel. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionChannel);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionChannel;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionChannels[index : Integer] : TFhirSubscriptionChannel read GetItemN write SetItemN; default;
  End;

  // The subscription resource is used to define a push-based subscription from a server to another system. Once a subscription is registered with the server, the server checks every resource that is created or updated, and if the resource matches the given criteria, it sends a message on the defined "channel" so that another system can take an appropriate action.
  TFhirSubscription = class (TFhirDomainResource)
  protected
    FStatus : TFhirEnum;
    FcontactList : TFhirContactPointList;
    FEnd_ : TFhirInstant;
    FReason : TFhirString;
    FCriteria : TFhirString;
    FError : TFhirString;
    FChannel : TFhirSubscriptionChannel;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSubscriptionStatusEnum;
    procedure SetStatusST(value : TFhirSubscriptionStatusEnum);
    function GetContactList : TFhirContactPointList;
    function GetHasContactList : Boolean;
    procedure SetEnd_(value : TFhirInstant);
    function GetEnd_ST : TFslDateTime;
    procedure SetEnd_ST(value : TFslDateTime);
    procedure SetReason(value : TFhirString);
    function GetReasonST : String;
    procedure SetReasonST(value : String);
    procedure SetCriteria(value : TFhirString);
    function GetCriteriaST : String;
    procedure SetCriteriaST(value : String);
    procedure SetError(value : TFhirString);
    function GetErrorST : String;
    procedure SetErrorST(value : String);
    procedure SetChannel(value : TFhirSubscriptionChannel);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscription; overload;
    function Clone : TFhirSubscription; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The status of the subscription, which marks the server state for managing the subscription.
    property status : TFhirSubscriptionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Contact details for a human to contact about the subscription. The primary use of this for system administrator troubleshooting.
    property contactList : TFhirContactPointList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to The time for the server to turn the subscription off.
    property end_ : TFslDateTime read GetEnd_ST write SetEnd_ST;
    // The time for the server to turn the subscription off.
    property end_Element : TFhirInstant read FEnd_ write SetEnd_;

    // Typed access to A description of why this subscription is defined.
    property reason : String read GetReasonST write SetReasonST;
    // A description of why this subscription is defined.
    property reasonElement : TFhirString read FReason write SetReason;

    // Typed access to The rules that the server should use to determine when to generate notifications for this subscription.
    property criteria : String read GetCriteriaST write SetCriteriaST;
    // The rules that the server should use to determine when to generate notifications for this subscription.
    property criteriaElement : TFhirString read FCriteria write SetCriteria;

    // Typed access to A record of the last error that occurred when the server processed a notification.
    property error : String read GetErrorST write SetErrorST;
    // A record of the last error that occurred when the server processed a notification.
    property errorElement : TFhirString read FError write SetError;

    // Typed access to Details where to send notifications when resources are received that meet the criteria. (defined for API consistency)
    property channel : TFhirSubscriptionChannel read FChannel write SetChannel;
    // Details where to send notifications when resources are received that meet the criteria.
    property channelElement : TFhirSubscriptionChannel read FChannel write SetChannel;

  end;

  TFhirSubscriptionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionList;
    function GetCurrent : TFhirSubscription;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscription read GetCurrent;
  end;

  TFhirSubscriptionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscription;
    procedure SetItemN(index : Integer; value : TFhirSubscription);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionList; overload;
    function Clone : TFhirSubscriptionList; overload;
    function GetEnumerator : TFhirSubscriptionListEnumerator;
    
    //  Add a FhirSubscription to the end of the list.
    function Append : TFhirSubscription;
    
    // Add an already existing FhirSubscription to the end of the list.
    function AddItem(value : TFhirSubscription) : TFhirSubscription; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscription) : Integer;
    
    // Insert FhirSubscription before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscription;
    
    // Insert an existing FhirSubscription before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscription);
    
    // Get the iIndexth FhirSubscription. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscription);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscription;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptions[index : Integer] : TFhirSubscription read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
  // Detailed information about events relevant to this subscription notification.
  TFhirSubscriptionStatusNotificationEvent = class (TFhirBackboneElement)
  protected
    FEventNumber : TFhirString;
    FTimestamp : TFhirInstant;
    FFocus : TFhirReference;
    FadditionalContextList : TFhirReferenceList;
    procedure SetEventNumber(value : TFhirString);
    function GetEventNumberST : String;
    procedure SetEventNumberST(value : String);
    procedure SetTimestamp(value : TFhirInstant);
    function GetTimestampST : TFslDateTime;
    procedure SetTimestampST(value : TFslDateTime);
    procedure SetFocus(value : TFhirReference);
    function GetAdditionalContextList : TFhirReferenceList;
    function GetHasAdditionalContextList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionStatusNotificationEvent; overload;
    function Clone : TFhirSubscriptionStatusNotificationEvent; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The sequential number of this event in this subscription context. Note that this value is a 64-bit integer value, encoded as a string.
    property eventNumber : String read GetEventNumberST write SetEventNumberST;
    // The sequential number of this event in this subscription context. Note that this value is a 64-bit integer value, encoded as a string.
    property eventNumberElement : TFhirString read FEventNumber write SetEventNumber;

    // Typed access to The actual time this event occured on the server.
    property timestamp : TFslDateTime read GetTimestampST write SetTimestampST;
    // The actual time this event occured on the server.
    property timestampElement : TFhirInstant read FTimestamp write SetTimestamp;

    // Typed access to The focus of this event. While this will usually be a reference to the focus resource of the event, it MAY contain a reference to a non-FHIR object. (defined for API consistency)
    property focus : TFhirReference read FFocus write SetFocus;
    // The focus of this event. While this will usually be a reference to the focus resource of the event, it MAY contain a reference to a non-FHIR object.
    property focusElement : TFhirReference read FFocus write SetFocus;

    // Additional context information for this event. Generally, this will contain references to additional resources included with the event (e.g., the Patient relevant to an Encounter), however it MAY refer to non-FHIR objects.
    property additionalContextList : TFhirReferenceList read GetAdditionalContextList;
    property hasAdditionalContextList : boolean read GetHasAdditionalContextList;

  end;

  TFhirSubscriptionStatusNotificationEventListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionStatusNotificationEventList;
    function GetCurrent : TFhirSubscriptionStatusNotificationEvent;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionStatusNotificationEventList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionStatusNotificationEvent read GetCurrent;
  end;

  TFhirSubscriptionStatusNotificationEventList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionStatusNotificationEvent;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionStatusNotificationEvent);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionStatusNotificationEventList; overload;
    function Clone : TFhirSubscriptionStatusNotificationEventList; overload;
    function GetEnumerator : TFhirSubscriptionStatusNotificationEventListEnumerator;
    
    //  Add a FhirSubscriptionStatusNotificationEvent to the end of the list.
    function Append : TFhirSubscriptionStatusNotificationEvent;
    
    // Add an already existing FhirSubscriptionStatusNotificationEvent to the end of the list.
    function AddItem(value : TFhirSubscriptionStatusNotificationEvent) : TFhirSubscriptionStatusNotificationEvent; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionStatusNotificationEvent) : Integer;
    
    // Insert FhirSubscriptionStatusNotificationEvent before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionStatusNotificationEvent;
    
    // Insert an existing FhirSubscriptionStatusNotificationEvent before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionStatusNotificationEvent);
    
    // Get the iIndexth FhirSubscriptionStatusNotificationEvent. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionStatusNotificationEvent);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionStatusNotificationEvent;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionStatusNotificationEvents[index : Integer] : TFhirSubscriptionStatusNotificationEvent read GetItemN write SetItemN; default;
  End;

  // The SubscriptionStatus resource describes the state of a Subscription during notifications.
  TFhirSubscriptionStatus = class (TFhirDomainResource)
  protected
    FStatus : TFhirEnum;
    FType_ : TFhirEnum;
    FEventsSinceSubscriptionStart : TFhirString;
    FEventsInNotification : TFhirInteger;
    FnotificationEventList : TFhirSubscriptionStatusNotificationEventList;
    FSubscription : TFhirReference;
    FTopic : TFhirCanonical;
    FerrorList : TFhirCodeableConceptList;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirSubscriptionStatusEnum;
    procedure SetStatusST(value : TFhirSubscriptionStatusEnum);
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirSubscriptionNotificationTypeEnum;
    procedure SetType_ST(value : TFhirSubscriptionNotificationTypeEnum);
    procedure SetEventsSinceSubscriptionStart(value : TFhirString);
    function GetEventsSinceSubscriptionStartST : String;
    procedure SetEventsSinceSubscriptionStartST(value : String);
    procedure SetEventsInNotification(value : TFhirInteger);
    function GetEventsInNotificationST : String;
    procedure SetEventsInNotificationST(value : String);
    function GetNotificationEventList : TFhirSubscriptionStatusNotificationEventList;
    function GetHasNotificationEventList : Boolean;
    procedure SetSubscription(value : TFhirReference);
    procedure SetTopic(value : TFhirCanonical);
    function GetTopicST : String;
    procedure SetTopicST(value : String);
    function GetErrorList : TFhirCodeableConceptList;
    function GetHasErrorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionStatus; overload;
    function Clone : TFhirSubscriptionStatus; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The status of the subscription, which marks the server state for managing the subscription.
    property status : TFhirSubscriptionStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // The type of event being conveyed with this notificaiton.
    property type_ : TFhirSubscriptionNotificationTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The total number of actual events which have been generated since the Subscription was created (inclusive of this notification) - regardless of how many have been successfully communicated.  This number is NOT incremented for handshake and heartbeat notifications.
    property eventsSinceSubscriptionStart : String read GetEventsSinceSubscriptionStartST write SetEventsSinceSubscriptionStartST;
    // The total number of actual events which have been generated since the Subscription was created (inclusive of this notification) - regardless of how many have been successfully communicated.  This number is NOT incremented for handshake and heartbeat notifications.
    property eventsSinceSubscriptionStartElement : TFhirString read FEventsSinceSubscriptionStart write SetEventsSinceSubscriptionStart;

    // Typed access to The total number of actual events represented within this notification.  For handshake and heartbeat notifications, this will be zero or not present.  For event-notifications, this number may be one or more, depending on server batching.
    property eventsInNotification : String read GetEventsInNotificationST write SetEventsInNotificationST;
    // The total number of actual events represented within this notification.  For handshake and heartbeat notifications, this will be zero or not present.  For event-notifications, this number may be one or more, depending on server batching.
    property eventsInNotificationElement : TFhirInteger read FEventsInNotification write SetEventsInNotification;

    // Detailed information about events relevant to this subscription notification.
    property notificationEventList : TFhirSubscriptionStatusNotificationEventList read GetNotificationEventList;
    property hasNotificationEventList : boolean read GetHasNotificationEventList;

    // Typed access to The reference to the Subscription which generated this notification. (defined for API consistency)
    property subscription : TFhirReference read FSubscription write SetSubscription;
    // The reference to the Subscription which generated this notification.
    property subscriptionElement : TFhirReference read FSubscription write SetSubscription;

    // Typed access to The reference to the SubscriptionTopic for the Subscription which generated this notification.
    property topic : String read GetTopicST write SetTopicST;
    // The reference to the SubscriptionTopic for the Subscription which generated this notification.
    property topicElement : TFhirCanonical read FTopic write SetTopic;

    // A record of errors that occurred when the server processed a notification.
    property errorList : TFhirCodeableConceptList read GetErrorList;
    property hasErrorList : boolean read GetHasErrorList;

  end;

  TFhirSubscriptionStatusListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionStatusList;
    function GetCurrent : TFhirSubscriptionStatus;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionStatusList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionStatus read GetCurrent;
  end;

  TFhirSubscriptionStatusList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionStatus;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionStatus);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionStatusList; overload;
    function Clone : TFhirSubscriptionStatusList; overload;
    function GetEnumerator : TFhirSubscriptionStatusListEnumerator;
    
    //  Add a FhirSubscriptionStatus to the end of the list.
    function Append : TFhirSubscriptionStatus;
    
    // Add an already existing FhirSubscriptionStatus to the end of the list.
    function AddItem(value : TFhirSubscriptionStatus) : TFhirSubscriptionStatus; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionStatus) : Integer;
    
    // Insert FhirSubscriptionStatus before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionStatus;
    
    // Insert an existing FhirSubscriptionStatus before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionStatus);
    
    // Get the iIndexth FhirSubscriptionStatus. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionStatus);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionStatus;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionStatuses[index : Integer] : TFhirSubscriptionStatus read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
  // A definition of a resource-based event that triggers a notification based on the SubscriptionTopic. The criteria may be just a human readable description and/or a full FHIR search string or FHIRPath expression. Multiple triggers are considered OR joined (e.g., a resource update matching ANY of the definitions will trigger a notification).
  TFhirSubscriptionTopicResourceTrigger = class (TFhirBackboneElement)
  protected
    FDescription : TFhirMarkdown;
    FResource : TFhirUri;
    FSupportedInteraction : TFhirEnumList;
    FQueryCriteria : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    FFhirPathCriteria : TFhirString;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetResource(value : TFhirUri);
    function GetResourceST : String;
    procedure SetResourceST(value : String);
    function GetSupportedInteraction : TFhirEnumList;
    function GetHasSupportedInteraction : Boolean;
    function GetSupportedInteractionST : TFhirInteractionTriggerEnumList;
    procedure SetSupportedInteractionST(value : TFhirInteractionTriggerEnumList);
    procedure SetQueryCriteria(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
    procedure SetFhirPathCriteria(value : TFhirString);
    function GetFhirPathCriteriaST : String;
    procedure SetFhirPathCriteriaST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicResourceTrigger; overload;
    function Clone : TFhirSubscriptionTopicResourceTrigger; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The human readable description of this resource trigger for the SubscriptionTopic -  for example, "An Encounter enters the 'in-progress' state".
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of this resource trigger for the SubscriptionTopic -  for example, "An Encounter enters the 'in-progress' state".
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to URL of the Resource that is the type used in this resource trigger.  Relative URLs are relative to the StructureDefinition root of the implemented FHIR version (e.g., http://hl7.org/fhir/StructureDefinition). For example, "Patient" maps to http://hl7.org/fhir/StructureDefinition/Patient.  For more information, see <a href="elementdefinition-definitions.html#ElementDefinition.type.code">ElementDefinition.type.code</a>.
    property resource : String read GetResourceST write SetResourceST;
    // URL of the Resource that is the type used in this resource trigger.  Relative URLs are relative to the StructureDefinition root of the implemented FHIR version (e.g., http://hl7.org/fhir/StructureDefinition). For example, "Patient" maps to http://hl7.org/fhir/StructureDefinition/Patient.  For more information, see <a href="elementdefinition-definitions.html#ElementDefinition.type.code">ElementDefinition.type.code</a>.
    property resourceElement : TFhirUri read FResource write SetResource;

    // The FHIR RESTful interaction which can be used to trigger a notification for the SubscriptionTopic. Multiple values are considered OR joined (e.g., CREATE or UPDATE).
    property supportedInteraction : TFhirInteractionTriggerEnumList read GetSupportedInteractionST write SetSupportedInteractionST;
    property supportedInteractionList : TFhirEnumList read GetSupportedInteraction;
    property hasSupportedInteraction : boolean read GetHasSupportedInteraction;
    // Typed access to The FHIR query based rules that the server should use to determine when to trigger a notification for this subscription topic. (defined for API consistency)
    property queryCriteria : TFhirSubscriptionTopicResourceTriggerQueryCriteria read FQueryCriteria write SetQueryCriteria;
    // The FHIR query based rules that the server should use to determine when to trigger a notification for this subscription topic.
    property queryCriteriaElement : TFhirSubscriptionTopicResourceTriggerQueryCriteria read FQueryCriteria write SetQueryCriteria;

    // Typed access to The FHIRPath based rules that the server should use to determine when to trigger a notification for this topic.
    property fhirPathCriteria : String read GetFhirPathCriteriaST write SetFhirPathCriteriaST;
    // The FHIRPath based rules that the server should use to determine when to trigger a notification for this topic.
    property fhirPathCriteriaElement : TFhirString read FFhirPathCriteria write SetFhirPathCriteria;

  end;

  TFhirSubscriptionTopicResourceTriggerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicResourceTriggerList;
    function GetCurrent : TFhirSubscriptionTopicResourceTrigger;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicResourceTriggerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicResourceTrigger read GetCurrent;
  end;

  TFhirSubscriptionTopicResourceTriggerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicResourceTrigger;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicResourceTrigger);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicResourceTriggerList; overload;
    function Clone : TFhirSubscriptionTopicResourceTriggerList; overload;
    function GetEnumerator : TFhirSubscriptionTopicResourceTriggerListEnumerator;
    
    //  Add a FhirSubscriptionTopicResourceTrigger to the end of the list.
    function Append : TFhirSubscriptionTopicResourceTrigger;
    
    // Add an already existing FhirSubscriptionTopicResourceTrigger to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicResourceTrigger) : TFhirSubscriptionTopicResourceTrigger; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicResourceTrigger) : Integer;
    
    // Insert FhirSubscriptionTopicResourceTrigger before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicResourceTrigger;
    
    // Insert an existing FhirSubscriptionTopicResourceTrigger before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicResourceTrigger);
    
    // Get the iIndexth FhirSubscriptionTopicResourceTrigger. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicResourceTrigger);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicResourceTrigger;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicResourceTriggers[index : Integer] : TFhirSubscriptionTopicResourceTrigger read GetItemN write SetItemN; default;
  End;

  // The FHIR query based rules that the server should use to determine when to trigger a notification for this subscription topic.
  TFhirSubscriptionTopicResourceTriggerQueryCriteria = class (TFhirBackboneElement)
  protected
    FPrevious : TFhirString;
    FResultForCreate : TFhirEnum;
    FCurrent : TFhirString;
    FResultForDelete : TFhirEnum;
    FRequireBoth : TFhirBoolean;
    procedure SetPrevious(value : TFhirString);
    function GetPreviousST : String;
    procedure SetPreviousST(value : String);
    procedure SetResultForCreate(value : TFhirEnum);
    function GetResultForCreateST : TFhirCriteriaNotExistsBehaviorEnum;
    procedure SetResultForCreateST(value : TFhirCriteriaNotExistsBehaviorEnum);
    procedure SetCurrent(value : TFhirString);
    function GetCurrentST : String;
    procedure SetCurrentST(value : String);
    procedure SetResultForDelete(value : TFhirEnum);
    function GetResultForDeleteST : TFhirCriteriaNotExistsBehaviorEnum;
    procedure SetResultForDeleteST(value : TFhirCriteriaNotExistsBehaviorEnum);
    procedure SetRequireBoth(value : TFhirBoolean);
    function GetRequireBothST : Boolean;
    procedure SetRequireBothST(value : Boolean);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicResourceTriggerQueryCriteria; overload;
    function Clone : TFhirSubscriptionTopicResourceTriggerQueryCriteria; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The FHIR query based rules are applied to the previous resource state (e.g., state before an update).
    property previous : String read GetPreviousST write SetPreviousST;
    // The FHIR query based rules are applied to the previous resource state (e.g., state before an update).
    property previousElement : TFhirString read FPrevious write SetPrevious;

    // What behavior a server will exhibit if the previous state of a resource does NOT exist (e.g., prior to a create).
    property resultForCreate : TFhirCriteriaNotExistsBehaviorEnum read GetResultForCreateST write SetResultForCreateST;
    property resultForCreateElement : TFhirEnum read FResultForCreate write SetResultForCreate;

    // Typed access to The FHIR query based rules are applied to the current resource state (e.g., state after an update).
    property current : String read GetCurrentST write SetCurrentST;
    // The FHIR query based rules are applied to the current resource state (e.g., state after an update).
    property currentElement : TFhirString read FCurrent write SetCurrent;

    // What behavior a server will exhibit if the current state of a resource does NOT exist (e.g., after a DELETE).
    property resultForDelete : TFhirCriteriaNotExistsBehaviorEnum read GetResultForDeleteST write SetResultForDeleteST;
    property resultForDeleteElement : TFhirEnum read FResultForDelete write SetResultForDelete;

    // Typed access to If set to true, both current and previous criteria must evaluate true to  trigger a notification for this topic.  Otherwise a notification for this topic will be triggered if either one evaluates to true.
    property requireBoth : Boolean read GetRequireBothST write SetRequireBothST;
    // If set to true, both current and previous criteria must evaluate true to  trigger a notification for this topic.  Otherwise a notification for this topic will be triggered if either one evaluates to true.
    property requireBothElement : TFhirBoolean read FRequireBoth write SetRequireBoth;

  end;

  TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList;
    function GetCurrent : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicResourceTriggerQueryCriteria read GetCurrent;
  end;

  TFhirSubscriptionTopicResourceTriggerQueryCriteriaList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList; overload;
    function Clone : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList; overload;
    function GetEnumerator : TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator;
    
    //  Add a FhirSubscriptionTopicResourceTriggerQueryCriteria to the end of the list.
    function Append : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    
    // Add an already existing FhirSubscriptionTopicResourceTriggerQueryCriteria to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria) : TFhirSubscriptionTopicResourceTriggerQueryCriteria; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria) : Integer;
    
    // Insert FhirSubscriptionTopicResourceTriggerQueryCriteria before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    
    // Insert an existing FhirSubscriptionTopicResourceTriggerQueryCriteria before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
    
    // Get the iIndexth FhirSubscriptionTopicResourceTriggerQueryCriteria. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicResourceTriggerQueryCriteria[index : Integer] : TFhirSubscriptionTopicResourceTriggerQueryCriteria read GetItemN write SetItemN; default;
  End;

  // Event definition which can be used to trigger the SubscriptionTopic.
  TFhirSubscriptionTopicEventTrigger = class (TFhirBackboneElement)
  protected
    FDescription : TFhirMarkdown;
    FEvent : TFhirCodeableConcept;
    FResource : TFhirUri;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetEvent(value : TFhirCodeableConcept);
    procedure SetResource(value : TFhirUri);
    function GetResourceST : String;
    procedure SetResourceST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicEventTrigger; overload;
    function Clone : TFhirSubscriptionTopicEventTrigger; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The human readable description of an event to trigger a notification for the SubscriptionTopic - for example, "Patient Admission, as defined in HL7v2 via message ADT^A01". Multiple values are considered OR joined (e.g., matching any single event listed).
    property description : String read GetDescriptionST write SetDescriptionST;
    // The human readable description of an event to trigger a notification for the SubscriptionTopic - for example, "Patient Admission, as defined in HL7v2 via message ADT^A01". Multiple values are considered OR joined (e.g., matching any single event listed).
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to A well-defined event which can be used to trigger notifications from the SubscriptionTopic. (defined for API consistency)
    property event : TFhirCodeableConcept read FEvent write SetEvent;
    // A well-defined event which can be used to trigger notifications from the SubscriptionTopic.
    property eventElement : TFhirCodeableConcept read FEvent write SetEvent;

    // Typed access to URL of the Resource that is the focus type used in this event trigger.  Relative URLs are relative to the StructureDefinition root of the implemented FHIR version (e.g., http://hl7.org/fhir/StructureDefinition). For example, "Patient" maps to http://hl7.org/fhir/StructureDefinition/Patient.  For more information, see <a href="elementdefinition-definitions.html#ElementDefinition.type.code">ElementDefinition.type.code</a>.
    property resource : String read GetResourceST write SetResourceST;
    // URL of the Resource that is the focus type used in this event trigger.  Relative URLs are relative to the StructureDefinition root of the implemented FHIR version (e.g., http://hl7.org/fhir/StructureDefinition). For example, "Patient" maps to http://hl7.org/fhir/StructureDefinition/Patient.  For more information, see <a href="elementdefinition-definitions.html#ElementDefinition.type.code">ElementDefinition.type.code</a>.
    property resourceElement : TFhirUri read FResource write SetResource;

  end;

  TFhirSubscriptionTopicEventTriggerListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicEventTriggerList;
    function GetCurrent : TFhirSubscriptionTopicEventTrigger;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicEventTriggerList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicEventTrigger read GetCurrent;
  end;

  TFhirSubscriptionTopicEventTriggerList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicEventTrigger;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicEventTrigger);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicEventTriggerList; overload;
    function Clone : TFhirSubscriptionTopicEventTriggerList; overload;
    function GetEnumerator : TFhirSubscriptionTopicEventTriggerListEnumerator;
    
    //  Add a FhirSubscriptionTopicEventTrigger to the end of the list.
    function Append : TFhirSubscriptionTopicEventTrigger;
    
    // Add an already existing FhirSubscriptionTopicEventTrigger to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicEventTrigger) : TFhirSubscriptionTopicEventTrigger; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicEventTrigger) : Integer;
    
    // Insert FhirSubscriptionTopicEventTrigger before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicEventTrigger;
    
    // Insert an existing FhirSubscriptionTopicEventTrigger before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicEventTrigger);
    
    // Get the iIndexth FhirSubscriptionTopicEventTrigger. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicEventTrigger);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicEventTrigger;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicEventTriggers[index : Integer] : TFhirSubscriptionTopicEventTrigger read GetItemN write SetItemN; default;
  End;

  // List of properties by which Subscriptions on the SubscriptionTopic can be filtered. May be defined Search Parameters (e.g., Encounter.patient) or parameters defined within this SubscriptionTopic context (e.g., hub.event).
  TFhirSubscriptionTopicCanFilterBy = class (TFhirBackboneElement)
  protected
    FDescription : TFhirMarkdown;
    FResource : TFhirUri;
    FFilterParameter : TFhirString;
    FModifier : TFhirEnumList;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetResource(value : TFhirUri);
    function GetResourceST : String;
    procedure SetResourceST(value : String);
    procedure SetFilterParameter(value : TFhirString);
    function GetFilterParameterST : String;
    procedure SetFilterParameterST(value : String);
    function GetModifier : TFhirEnumList;
    function GetHasModifier : Boolean;
    function GetModifierST : TFhirSubscriptionSearchModifierEnumList;
    procedure SetModifierST(value : TFhirSubscriptionSearchModifierEnumList);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicCanFilterBy; overload;
    function Clone : TFhirSubscriptionTopicCanFilterBy; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Description of how this filtering parameter is intended to be used.
    property description : String read GetDescriptionST write SetDescriptionST;
    // Description of how this filtering parameter is intended to be used.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // Typed access to URL of the Resource that is the type used in this filter. This is the "focus" of the topic (or one of them if there are more than one). It will be the same, a generality, or a specificity of SubscriptionTopic.resourceTrigger.resource or SubscriptionTopic.eventTrigger.resource when they are present.
    property resource : String read GetResourceST write SetResourceST;
    // URL of the Resource that is the type used in this filter. This is the "focus" of the topic (or one of them if there are more than one). It will be the same, a generality, or a specificity of SubscriptionTopic.resourceTrigger.resource or SubscriptionTopic.eventTrigger.resource when they are present.
    property resourceElement : TFhirUri read FResource write SetResource;

    // Typed access to Either the canonical URL to a search parameter (like "http://hl7.org/fhir/SearchParameter/encounter-patient") or topic-defined parameter (like "hub.event") which is a label for the filter.
    property filterParameter : String read GetFilterParameterST write SetFilterParameterST;
    // Either the canonical URL to a search parameter (like "http://hl7.org/fhir/SearchParameter/encounter-patient") or topic-defined parameter (like "hub.event") which is a label for the filter.
    property filterParameterElement : TFhirString read FFilterParameter write SetFilterParameter;

    // Allowable operators to apply when determining matches (Search Modifiers).
    property modifier : TFhirSubscriptionSearchModifierEnumList read GetModifierST write SetModifierST;
    property modifierList : TFhirEnumList read GetModifier;
    property hasModifier : boolean read GetHasModifier;
  end;

  TFhirSubscriptionTopicCanFilterByListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicCanFilterByList;
    function GetCurrent : TFhirSubscriptionTopicCanFilterBy;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicCanFilterByList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicCanFilterBy read GetCurrent;
  end;

  TFhirSubscriptionTopicCanFilterByList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicCanFilterBy;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicCanFilterBy);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicCanFilterByList; overload;
    function Clone : TFhirSubscriptionTopicCanFilterByList; overload;
    function GetEnumerator : TFhirSubscriptionTopicCanFilterByListEnumerator;
    
    //  Add a FhirSubscriptionTopicCanFilterBy to the end of the list.
    function Append : TFhirSubscriptionTopicCanFilterBy;
    
    // Add an already existing FhirSubscriptionTopicCanFilterBy to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicCanFilterBy) : TFhirSubscriptionTopicCanFilterBy; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicCanFilterBy) : Integer;
    
    // Insert FhirSubscriptionTopicCanFilterBy before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicCanFilterBy;
    
    // Insert an existing FhirSubscriptionTopicCanFilterBy before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicCanFilterBy);
    
    // Get the iIndexth FhirSubscriptionTopicCanFilterBy. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicCanFilterBy);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicCanFilterBy;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicCanFilterBies[index : Integer] : TFhirSubscriptionTopicCanFilterBy read GetItemN write SetItemN; default;
  End;

  // List of properties to describe the shape (e.g., resources) included in notifications from this Subscription Topic.
  TFhirSubscriptionTopicNotificationShape = class (TFhirBackboneElement)
  protected
    FResource : TFhirUri;
    FincludeList : TFhirStringList;
    FrevIncludeList : TFhirStringList;
    procedure SetResource(value : TFhirUri);
    function GetResourceST : String;
    procedure SetResourceST(value : String);
    function GetIncludeList : TFhirStringList;
    function GetHasIncludeList : Boolean;
    function GetRevIncludeList : TFhirStringList;
    function GetHasRevIncludeList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopicNotificationShape; overload;
    function Clone : TFhirSubscriptionTopicNotificationShape; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to URL of the Resource that is the type used in this shape. This is the "focus" of the topic (or one of them if there are more than one) and the root resource for this shape definition. It will be the same, a generality, or a specificity of SubscriptionTopic.resourceTrigger.resource or SubscriptionTopic.eventTrigger.resource when they are present.
    property resource : String read GetResourceST write SetResourceST;
    // URL of the Resource that is the type used in this shape. This is the "focus" of the topic (or one of them if there are more than one) and the root resource for this shape definition. It will be the same, a generality, or a specificity of SubscriptionTopic.resourceTrigger.resource or SubscriptionTopic.eventTrigger.resource when they are present.
    property resourceElement : TFhirUri read FResource write SetResource;

    // Search-style _include directives, rooted in the resource for this shape. Servers SHOULD include resources listed here, if they exist and the user is authorized to receive them.  Clients SHOULD be prepared to receive these additional resources, but SHALL function properly without them.
    property includeList : TFhirStringList read GetIncludeList;
    property hasIncludeList : boolean read GetHasIncludeList;

    // Search-style _revinclude directives, rooted in the resource for this shape. Servers SHOULD include resources listed here, if they exist and the user is authorized to receive them.  Clients SHOULD be prepared to receive these additional resources, but SHALL function properly without them.
    property revIncludeList : TFhirStringList read GetRevIncludeList;
    property hasRevIncludeList : boolean read GetHasRevIncludeList;

  end;

  TFhirSubscriptionTopicNotificationShapeListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicNotificationShapeList;
    function GetCurrent : TFhirSubscriptionTopicNotificationShape;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicNotificationShapeList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopicNotificationShape read GetCurrent;
  end;

  TFhirSubscriptionTopicNotificationShapeList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopicNotificationShape;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopicNotificationShape);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicNotificationShapeList; overload;
    function Clone : TFhirSubscriptionTopicNotificationShapeList; overload;
    function GetEnumerator : TFhirSubscriptionTopicNotificationShapeListEnumerator;
    
    //  Add a FhirSubscriptionTopicNotificationShape to the end of the list.
    function Append : TFhirSubscriptionTopicNotificationShape;
    
    // Add an already existing FhirSubscriptionTopicNotificationShape to the end of the list.
    function AddItem(value : TFhirSubscriptionTopicNotificationShape) : TFhirSubscriptionTopicNotificationShape; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopicNotificationShape) : Integer;
    
    // Insert FhirSubscriptionTopicNotificationShape before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopicNotificationShape;
    
    // Insert an existing FhirSubscriptionTopicNotificationShape before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopicNotificationShape);
    
    // Get the iIndexth FhirSubscriptionTopicNotificationShape. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopicNotificationShape);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopicNotificationShape;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopicNotificationShapes[index : Integer] : TFhirSubscriptionTopicNotificationShape read GetItemN write SetItemN; default;
  End;

  // Describes a stream of resource state changes or events and annotated with labels useful to filter projections from this topic.
  TFhirSubscriptionTopic = class (TFhirDomainResource)
  protected
    FUrl : TFhirUri;
    FidentifierList : TFhirIdentifierList;
    FVersion : TFhirString;
    FTitle : TFhirString;
    FderivedFromList : TFhirCanonicalList;
    FStatus : TFhirEnum;
    FExperimental : TFhirBoolean;
    FDate : TFhirDateTime;
    FPublisher : TFhirString;
    FcontactList : TFhirContactDetailList;
    FDescription : TFhirMarkdown;
    FuseContextList : TFhirUsageContextList;
    FjurisdictionList : TFhirCodeableConceptList;
    FPurpose : TFhirMarkdown;
    FCopyright : TFhirMarkdown;
    FApprovalDate : TFhirDate;
    FLastReviewDate : TFhirDate;
    FEffectivePeriod : TFhirPeriod;
    FresourceTriggerList : TFhirSubscriptionTopicResourceTriggerList;
    FeventTriggerList : TFhirSubscriptionTopicEventTriggerList;
    FcanFilterByList : TFhirSubscriptionTopicCanFilterByList;
    FnotificationShapeList : TFhirSubscriptionTopicNotificationShapeList;
    procedure SetUrl(value : TFhirUri);
    function GetUrlST : String;
    procedure SetUrlST(value : String);
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetVersion(value : TFhirString);
    function GetVersionST : String;
    procedure SetVersionST(value : String);
    procedure SetTitle(value : TFhirString);
    function GetTitleST : String;
    procedure SetTitleST(value : String);
    function GetDerivedFromList : TFhirCanonicalList;
    function GetHasDerivedFromList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirPublicationStatusEnum;
    procedure SetStatusST(value : TFhirPublicationStatusEnum);
    procedure SetExperimental(value : TFhirBoolean);
    function GetExperimentalST : Boolean;
    procedure SetExperimentalST(value : Boolean);
    procedure SetDate(value : TFhirDateTime);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetPublisher(value : TFhirString);
    function GetPublisherST : String;
    procedure SetPublisherST(value : String);
    function GetContactList : TFhirContactDetailList;
    function GetHasContactList : Boolean;
    procedure SetDescription(value : TFhirMarkdown);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetUseContextList : TFhirUsageContextList;
    function GetHasUseContextList : Boolean;
    function GetJurisdictionList : TFhirCodeableConceptList;
    function GetHasJurisdictionList : Boolean;
    procedure SetPurpose(value : TFhirMarkdown);
    function GetPurposeST : String;
    procedure SetPurposeST(value : String);
    procedure SetCopyright(value : TFhirMarkdown);
    function GetCopyrightST : String;
    procedure SetCopyrightST(value : String);
    procedure SetApprovalDate(value : TFhirDate);
    function GetApprovalDateST : TFslDateTime;
    procedure SetApprovalDateST(value : TFslDateTime);
    procedure SetLastReviewDate(value : TFhirDate);
    function GetLastReviewDateST : TFslDateTime;
    procedure SetLastReviewDateST(value : TFslDateTime);
    procedure SetEffectivePeriod(value : TFhirPeriod);
    function GetResourceTriggerList : TFhirSubscriptionTopicResourceTriggerList;
    function GetHasResourceTriggerList : Boolean;
    function GetEventTriggerList : TFhirSubscriptionTopicEventTriggerList;
    function GetHasEventTriggerList : Boolean;
    function GetCanFilterByList : TFhirSubscriptionTopicCanFilterByList;
    function GetHasCanFilterByList : Boolean;
    function GetNotificationShapeList : TFhirSubscriptionTopicNotificationShapeList;
    function GetHasNotificationShapeList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirSubscriptionTopic; overload;
    function Clone : TFhirSubscriptionTopic; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An absolute URL that is used to identify this SubscriptionTopic when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this Topic is (or will be) published. The URL SHOULD include the major version of the Topic. For more information see [Technical and Business Versions](resource.html#versions).
    property url : String read GetUrlST write SetUrlST;
    // An absolute URL that is used to identify this SubscriptionTopic when it is referenced in a specification, model, design or an instance. This SHALL be a URL, SHOULD be globally unique, and SHOULD be an address at which this Topic is (or will be) published. The URL SHOULD include the major version of the Topic. For more information see [Technical and Business Versions](resource.html#versions).
    property urlElement : TFhirUri read FUrl write SetUrl;

    // Business identifiers assigned to this SubscriptionTopic by the performer and/or other systems.  These identifiers remain constant as the resource is updated and propagates from server to server.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The identifier that is used to identify this version of the SubscriptionTopic when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the Topic author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions are orderable.
    property version : String read GetVersionST write SetVersionST;
    // The identifier that is used to identify this version of the SubscriptionTopic when it is referenced in a specification, model, design or instance. This is an arbitrary value managed by the Topic author and is not expected to be globally unique. For example, it might be a timestamp (e.g. yyyymmdd) if a managed version is not available. There is also no expectation that versions are orderable.
    property versionElement : TFhirString read FVersion write SetVersion;

    // Typed access to A short, descriptive, user-friendly title for the SubscriptionTopic, for example, "admission".
    property title : String read GetTitleST write SetTitleST;
    // A short, descriptive, user-friendly title for the SubscriptionTopic, for example, "admission".
    property titleElement : TFhirString read FTitle write SetTitle;

    // The canonical URL pointing to another FHIR-defined SubscriptionTopic that is adhered to in whole or in part by this SubscriptionTopic.
    property derivedFromList : TFhirCanonicalList read GetDerivedFromList;
    property hasDerivedFromList : boolean read GetHasDerivedFromList;

    // The current state of the SubscriptionTopic.
    property status : TFhirPublicationStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to A flag to indicate that this TopSubscriptionTopicic is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimental : Boolean read GetExperimentalST write SetExperimentalST;
    // A flag to indicate that this TopSubscriptionTopicic is authored for testing purposes (or education/evaluation/marketing), and is not intended to be used for genuine usage.
    property experimentalElement : TFhirBoolean read FExperimental write SetExperimental;

    // Typed access to For draft definitions, indicates the date of initial creation.  For active definitions, represents the date of activation.  For withdrawn definitions, indicates the date of withdrawal.
    property date : TFslDateTime read GetDateST write SetDateST;
    // For draft definitions, indicates the date of initial creation.  For active definitions, represents the date of activation.  For withdrawn definitions, indicates the date of withdrawal.
    property dateElement : TFhirDateTime read FDate write SetDate;

    // Typed access to Helps establish the "authority/credibility" of the SubscriptionTopic.  May also allow for contact.
    property publisher : String read GetPublisherST write SetPublisherST;
    // Helps establish the "authority/credibility" of the SubscriptionTopic.  May also allow for contact.
    property publisherElement : TFhirString read FPublisher write SetPublisher;

    // Contact details to assist a user in finding and communicating with the publisher.
    property contactList : TFhirContactDetailList read GetContactList;
    property hasContactList : boolean read GetHasContactList;

    // Typed access to A free text natural language description of the Topic from the consumer's perspective.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free text natural language description of the Topic from the consumer's perspective.
    property descriptionElement : TFhirMarkdown read FDescription write SetDescription;

    // The content was developed with a focus and intent of supporting the contexts that are listed. These terms may be used to assist with indexing and searching of code system definitions.
    property useContextList : TFhirUsageContextList read GetUseContextList;
    property hasUseContextList : boolean read GetHasUseContextList;

    // A jurisdiction in which the Topic is intended to be used.
    property jurisdictionList : TFhirCodeableConceptList read GetJurisdictionList;
    property hasJurisdictionList : boolean read GetHasJurisdictionList;

    // Typed access to Explains why this Topic is needed and why it has been designed as it has.
    property purpose : String read GetPurposeST write SetPurposeST;
    // Explains why this Topic is needed and why it has been designed as it has.
    property purposeElement : TFhirMarkdown read FPurpose write SetPurpose;

    // Typed access to A copyright statement relating to the SubscriptionTopic and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the SubscriptionTopic.
    property copyright : String read GetCopyrightST write SetCopyrightST;
    // A copyright statement relating to the SubscriptionTopic and/or its contents. Copyright statements are generally legal restrictions on the use and publishing of the SubscriptionTopic.
    property copyrightElement : TFhirMarkdown read FCopyright write SetCopyright;

    // Typed access to The date on which the asset content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDate : TFslDateTime read GetApprovalDateST write SetApprovalDateST;
    // The date on which the asset content was approved by the publisher. Approval happens once when the content is officially approved for usage.
    property approvalDateElement : TFhirDate read FApprovalDate write SetApprovalDate;

    // Typed access to The date on which the asset content was last reviewed. Review happens periodically after that, but doesn't change the original approval date.
    property lastReviewDate : TFslDateTime read GetLastReviewDateST write SetLastReviewDateST;
    // The date on which the asset content was last reviewed. Review happens periodically after that, but doesn't change the original approval date.
    property lastReviewDateElement : TFhirDate read FLastReviewDate write SetLastReviewDate;

    // Typed access to The period during which the SubscriptionTopic content was or is planned to be effective. (defined for API consistency)
    property effectivePeriod : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;
    // The period during which the SubscriptionTopic content was or is planned to be effective.
    property effectivePeriodElement : TFhirPeriod read FEffectivePeriod write SetEffectivePeriod;

    // A definition of a resource-based event that triggers a notification based on the SubscriptionTopic. The criteria may be just a human readable description and/or a full FHIR search string or FHIRPath expression. Multiple triggers are considered OR joined (e.g., a resource update matching ANY of the definitions will trigger a notification).
    property resourceTriggerList : TFhirSubscriptionTopicResourceTriggerList read GetResourceTriggerList;
    property hasResourceTriggerList : boolean read GetHasResourceTriggerList;

    // Event definition which can be used to trigger the SubscriptionTopic.
    property eventTriggerList : TFhirSubscriptionTopicEventTriggerList read GetEventTriggerList;
    property hasEventTriggerList : boolean read GetHasEventTriggerList;

    // List of properties by which Subscriptions on the SubscriptionTopic can be filtered. May be defined Search Parameters (e.g., Encounter.patient) or parameters defined within this SubscriptionTopic context (e.g., hub.event).
    property canFilterByList : TFhirSubscriptionTopicCanFilterByList read GetCanFilterByList;
    property hasCanFilterByList : boolean read GetHasCanFilterByList;

    // List of properties to describe the shape (e.g., resources) included in notifications from this Subscription Topic.
    property notificationShapeList : TFhirSubscriptionTopicNotificationShapeList read GetNotificationShapeList;
    property hasNotificationShapeList : boolean read GetHasNotificationShapeList;

  end;

  TFhirSubscriptionTopicListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirSubscriptionTopicList;
    function GetCurrent : TFhirSubscriptionTopic;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirSubscriptionTopicList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirSubscriptionTopic read GetCurrent;
  end;

  TFhirSubscriptionTopicList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirSubscriptionTopic;
    procedure SetItemN(index : Integer; value : TFhirSubscriptionTopic);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirSubscriptionTopicList; overload;
    function Clone : TFhirSubscriptionTopicList; overload;
    function GetEnumerator : TFhirSubscriptionTopicListEnumerator;
    
    //  Add a FhirSubscriptionTopic to the end of the list.
    function Append : TFhirSubscriptionTopic;
    
    // Add an already existing FhirSubscriptionTopic to the end of the list.
    function AddItem(value : TFhirSubscriptionTopic) : TFhirSubscriptionTopic; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirSubscriptionTopic) : Integer;
    
    // Insert FhirSubscriptionTopic before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirSubscriptionTopic;
    
    // Insert an existing FhirSubscriptionTopic before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirSubscriptionTopic);
    
    // Get the iIndexth FhirSubscriptionTopic. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirSubscriptionTopic);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirSubscriptionTopic;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirSubscriptionTopics[index : Integer] : TFhirSubscriptionTopic read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_TASK}
  // If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
  TFhirTaskRestriction = class (TFhirBackboneElement)
  protected
    FRepetitions : TFhirPositiveInt;
    FPeriod : TFhirPeriod;
    FrecipientList : TFhirReferenceList;
    procedure SetRepetitions(value : TFhirPositiveInt);
    function GetRepetitionsST : String;
    procedure SetRepetitionsST(value : String);
    procedure SetPeriod(value : TFhirPeriod);
    function GetRecipientList : TFhirReferenceList;
    function GetHasRecipientList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskRestriction; overload;
    function Clone : TFhirTaskRestriction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Indicates the number of times the requested action should occur.
    property repetitions : String read GetRepetitionsST write SetRepetitionsST;
    // Indicates the number of times the requested action should occur.
    property repetitionsElement : TFhirPositiveInt read FRepetitions write SetRepetitions;

    // Typed access to Over what time-period is fulfillment sought. (defined for API consistency)
    property period : TFhirPeriod read FPeriod write SetPeriod;
    // Over what time-period is fulfillment sought.
    property periodElement : TFhirPeriod read FPeriod write SetPeriod;

    // For requests that are targeted to more than on potential recipient/target, for whom is fulfillment sought?
    property recipientList : TFhirReferenceList read GetRecipientList;
    property hasRecipientList : boolean read GetHasRecipientList;

  end;

  TFhirTaskRestrictionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskRestrictionList;
    function GetCurrent : TFhirTaskRestriction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTaskRestrictionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskRestriction read GetCurrent;
  end;

  TFhirTaskRestrictionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTaskRestriction;
    procedure SetItemN(index : Integer; value : TFhirTaskRestriction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTaskRestrictionList; overload;
    function Clone : TFhirTaskRestrictionList; overload;
    function GetEnumerator : TFhirTaskRestrictionListEnumerator;
    
    //  Add a FhirTaskRestriction to the end of the list.
    function Append : TFhirTaskRestriction;
    
    // Add an already existing FhirTaskRestriction to the end of the list.
    function AddItem(value : TFhirTaskRestriction) : TFhirTaskRestriction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskRestriction) : Integer;
    
    // Insert FhirTaskRestriction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskRestriction;
    
    // Insert an existing FhirTaskRestriction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskRestriction);
    
    // Get the iIndexth FhirTaskRestriction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskRestriction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskRestriction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTaskRestrictions[index : Integer] : TFhirTaskRestriction read GetItemN write SetItemN; default;
  End;

  // Additional information that may be needed in the execution of the task.
  TFhirTaskInput = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskInput; overload;
    function Clone : TFhirTaskInput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to A code or description indicating how the input is intended to be used as part of the task execution. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // A code or description indicating how the input is intended to be used as part of the task execution.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The value of the input parameter as a basic type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the input parameter as a basic type.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirTaskInputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskInputList;
    function GetCurrent : TFhirTaskInput;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTaskInputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskInput read GetCurrent;
  end;

  TFhirTaskInputList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTaskInput;
    procedure SetItemN(index : Integer; value : TFhirTaskInput);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTaskInputList; overload;
    function Clone : TFhirTaskInputList; overload;
    function GetEnumerator : TFhirTaskInputListEnumerator;
    
    //  Add a FhirTaskInput to the end of the list.
    function Append : TFhirTaskInput;
    
    // Add an already existing FhirTaskInput to the end of the list.
    function AddItem(value : TFhirTaskInput) : TFhirTaskInput; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskInput) : Integer;
    
    // Insert FhirTaskInput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskInput;
    
    // Insert an existing FhirTaskInput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskInput);
    
    // Get the iIndexth FhirTaskInput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskInput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskInput;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTaskInputs[index : Integer] : TFhirTaskInput read GetItemN write SetItemN; default;
  End;

  // Outputs produced by the Task.
  TFhirTaskOutput = class (TFhirBackboneElement)
  protected
    FType_ : TFhirCodeableConcept;
    FValue : TFhirDataType;
    procedure SetType_(value : TFhirCodeableConcept);
    procedure SetValue(value : TFhirDataType);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTaskOutput; overload;
    function Clone : TFhirTaskOutput; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of the Output parameter. (defined for API consistency)
    property type_ : TFhirCodeableConcept read FType_ write SetType_;
    // The name of the Output parameter.
    property type_Element : TFhirCodeableConcept read FType_ write SetType_;

    // Typed access to The value of the Output parameter as a basic type. (defined for API consistency)
    property value : TFhirDataType read FValue write SetValue;
    // The value of the Output parameter as a basic type.
    property valueElement : TFhirDataType read FValue write SetValue;

  end;

  TFhirTaskOutputListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskOutputList;
    function GetCurrent : TFhirTaskOutput;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTaskOutputList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTaskOutput read GetCurrent;
  end;

  TFhirTaskOutputList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTaskOutput;
    procedure SetItemN(index : Integer; value : TFhirTaskOutput);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTaskOutputList; overload;
    function Clone : TFhirTaskOutputList; overload;
    function GetEnumerator : TFhirTaskOutputListEnumerator;
    
    //  Add a FhirTaskOutput to the end of the list.
    function Append : TFhirTaskOutput;
    
    // Add an already existing FhirTaskOutput to the end of the list.
    function AddItem(value : TFhirTaskOutput) : TFhirTaskOutput; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTaskOutput) : Integer;
    
    // Insert FhirTaskOutput before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTaskOutput;
    
    // Insert an existing FhirTaskOutput before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTaskOutput);
    
    // Get the iIndexth FhirTaskOutput. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTaskOutput);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTaskOutput;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTaskOutputs[index : Integer] : TFhirTaskOutput read GetItemN write SetItemN; default;
  End;

  // A task to be performed.
  TFhirTask = class (TFhirDomainResource)
  protected
    FidentifierList : TFhirIdentifierList;
    FInstantiatesCanonical : TFhirCanonical;
    FInstantiatesUri : TFhirUri;
    FbasedOnList : TFhirReferenceList;
    FGroupIdentifier : TFhirIdentifier;
    FpartOfList : TFhirReferenceList;
    FStatus : TFhirEnum;
    FStatusReason : TFhirCodeableConcept;
    FBusinessStatus : TFhirCodeableConcept;
    FIntent : TFhirEnum;
    FPriority : TFhirEnum;
    FCode : TFhirCodeableConcept;
    FDescription : TFhirString;
    FFocus : TFhirReference;
    FFor_ : TFhirReference;
    FEncounter : TFhirReference;
    FExecutionPeriod : TFhirPeriod;
    FAuthoredOn : TFhirDateTime;
    FLastModified : TFhirDateTime;
    FRequester : TFhirReference;
    FperformerTypeList : TFhirCodeableConceptList;
    FOwner : TFhirReference;
    FLocation : TFhirReference;
    FReasonCode : TFhirCodeableConcept;
    FReasonReference : TFhirReference;
    FinsuranceList : TFhirReferenceList;
    FnoteList : TFhirAnnotationList;
    FrelevantHistoryList : TFhirReferenceList;
    FRestriction : TFhirTaskRestriction;
    FinputList : TFhirTaskInputList;
    FoutputList : TFhirTaskOutputList;
    function GetIdentifierList : TFhirIdentifierList;
    function GetHasIdentifierList : Boolean;
    procedure SetInstantiatesCanonical(value : TFhirCanonical);
    function GetInstantiatesCanonicalST : String;
    procedure SetInstantiatesCanonicalST(value : String);
    procedure SetInstantiatesUri(value : TFhirUri);
    function GetInstantiatesUriST : String;
    procedure SetInstantiatesUriST(value : String);
    function GetBasedOnList : TFhirReferenceList;
    function GetHasBasedOnList : Boolean;
    procedure SetGroupIdentifier(value : TFhirIdentifier);
    function GetPartOfList : TFhirReferenceList;
    function GetHasPartOfList : Boolean;
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirTaskStatusEnum;
    procedure SetStatusST(value : TFhirTaskStatusEnum);
    procedure SetStatusReason(value : TFhirCodeableConcept);
    procedure SetBusinessStatus(value : TFhirCodeableConcept);
    procedure SetIntent(value : TFhirEnum);
    function GetIntentST : TFhirTaskIntentEnum;
    procedure SetIntentST(value : TFhirTaskIntentEnum);
    procedure SetPriority(value : TFhirEnum);
    function GetPriorityST : TFhirRequestPriorityEnum;
    procedure SetPriorityST(value : TFhirRequestPriorityEnum);
    procedure SetCode(value : TFhirCodeableConcept);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    procedure SetFocus(value : TFhirReference);
    procedure SetFor_(value : TFhirReference);
    procedure SetEncounter(value : TFhirReference);
    procedure SetExecutionPeriod(value : TFhirPeriod);
    procedure SetAuthoredOn(value : TFhirDateTime);
    function GetAuthoredOnST : TFslDateTime;
    procedure SetAuthoredOnST(value : TFslDateTime);
    procedure SetLastModified(value : TFhirDateTime);
    function GetLastModifiedST : TFslDateTime;
    procedure SetLastModifiedST(value : TFslDateTime);
    procedure SetRequester(value : TFhirReference);
    function GetPerformerTypeList : TFhirCodeableConceptList;
    function GetHasPerformerTypeList : Boolean;
    procedure SetOwner(value : TFhirReference);
    procedure SetLocation(value : TFhirReference);
    procedure SetReasonCode(value : TFhirCodeableConcept);
    procedure SetReasonReference(value : TFhirReference);
    function GetInsuranceList : TFhirReferenceList;
    function GetHasInsuranceList : Boolean;
    function GetNoteList : TFhirAnnotationList;
    function GetHasNoteList : Boolean;
    function GetRelevantHistoryList : TFhirReferenceList;
    function GetHasRelevantHistoryList : Boolean;
    procedure SetRestriction(value : TFhirTaskRestriction);
    function GetInputList : TFhirTaskInputList;
    function GetHasInputList : Boolean;
    function GetOutputList : TFhirTaskOutputList;
    function GetHasOutputList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTask; overload;
    function Clone : TFhirTask; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The business identifier for this task.
    property identifierList : TFhirIdentifierList read GetIdentifierList;
    property hasIdentifierList : boolean read GetHasIdentifierList;

    // Typed access to The URL pointing to a *FHIR*-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesCanonical : String read GetInstantiatesCanonicalST write SetInstantiatesCanonicalST;
    // The URL pointing to a *FHIR*-defined protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesCanonicalElement : TFhirCanonical read FInstantiatesCanonical write SetInstantiatesCanonical;

    // Typed access to The URL pointing to an *externally* maintained  protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesUri : String read GetInstantiatesUriST write SetInstantiatesUriST;
    // The URL pointing to an *externally* maintained  protocol, guideline, orderset or other definition that is adhered to in whole or in part by this Task.
    property instantiatesUriElement : TFhirUri read FInstantiatesUri write SetInstantiatesUri;

    // BasedOn refers to a higher-level authorization that triggered the creation of the task.  It references a "request" resource such as a ServiceRequest, MedicationRequest, ServiceRequest, CarePlan, etc. which is distinct from the "request" resource the task is seeking to fulfill.  This latter resource is referenced by FocusOn.  For example, based on a ServiceRequest (= BasedOn), a task is created to fulfill a procedureRequest ( = FocusOn ) to collect a specimen from a patient.
    property basedOnList : TFhirReferenceList read GetBasedOnList;
    property hasBasedOnList : boolean read GetHasBasedOnList;

    // Typed access to An identifier that links together multiple tasks and other requests that were created in the same context. (defined for API consistency)
    property groupIdentifier : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;
    // An identifier that links together multiple tasks and other requests that were created in the same context.
    property groupIdentifierElement : TFhirIdentifier read FGroupIdentifier write SetGroupIdentifier;

    // Task that this particular task is part of.
    property partOfList : TFhirReferenceList read GetPartOfList;
    property hasPartOfList : boolean read GetHasPartOfList;

    // The current status of the task.
    property status : TFhirTaskStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to An explanation as to why this task is held, failed, was refused, etc. (defined for API consistency)
    property statusReason : TFhirCodeableConcept read FStatusReason write SetStatusReason;
    // An explanation as to why this task is held, failed, was refused, etc.
    property statusReasonElement : TFhirCodeableConcept read FStatusReason write SetStatusReason;

    // Typed access to Contains business-specific nuances of the business state. (defined for API consistency)
    property businessStatus : TFhirCodeableConcept read FBusinessStatus write SetBusinessStatus;
    // Contains business-specific nuances of the business state.
    property businessStatusElement : TFhirCodeableConcept read FBusinessStatus write SetBusinessStatus;

    // Indicates the "level" of actionability associated with the Task, i.e. i+R[9]Cs this a proposed task, a planned task, an actionable task, etc.
    property intent : TFhirTaskIntentEnum read GetIntentST write SetIntentST;
    property intentElement : TFhirEnum read FIntent write SetIntent;

    // Indicates how quickly the Task should be addressed with respect to other requests.
    property priority : TFhirRequestPriorityEnum read GetPriorityST write SetPriorityST;
    property priorityElement : TFhirEnum read FPriority write SetPriority;

    // Typed access to A name or code (or both) briefly describing what the task involves. (defined for API consistency)
    property code : TFhirCodeableConcept read FCode write SetCode;
    // A name or code (or both) briefly describing what the task involves.
    property codeElement : TFhirCodeableConcept read FCode write SetCode;

    // Typed access to A free-text description of what is to be performed.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A free-text description of what is to be performed.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Typed access to The request being actioned or the resource being manipulated by this task. (defined for API consistency)
    property focus : TFhirReference read FFocus write SetFocus;
    // The request being actioned or the resource being manipulated by this task.
    property focusElement : TFhirReference read FFocus write SetFocus;

    // Typed access to The entity who benefits from the performance of the service specified in the task (e.g., the patient). (defined for API consistency)
    property for_ : TFhirReference read FFor_ write SetFor_;
    // The entity who benefits from the performance of the service specified in the task (e.g., the patient).
    property for_Element : TFhirReference read FFor_ write SetFor_;

    // Typed access to The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created. (defined for API consistency)
    property encounter : TFhirReference read FEncounter write SetEncounter;
    // The healthcare event  (e.g. a patient and healthcare provider interaction) during which this task was created.
    property encounterElement : TFhirReference read FEncounter write SetEncounter;

    // Typed access to Identifies the time action was first taken against the task (start) and/or the time final action was taken against the task prior to marking it as completed (end). (defined for API consistency)
    property executionPeriod : TFhirPeriod read FExecutionPeriod write SetExecutionPeriod;
    // Identifies the time action was first taken against the task (start) and/or the time final action was taken against the task prior to marking it as completed (end).
    property executionPeriodElement : TFhirPeriod read FExecutionPeriod write SetExecutionPeriod;

    // Typed access to The date and time this task was created.
    property authoredOn : TFslDateTime read GetAuthoredOnST write SetAuthoredOnST;
    // The date and time this task was created.
    property authoredOnElement : TFhirDateTime read FAuthoredOn write SetAuthoredOn;

    // Typed access to The date and time of last modification to this task.
    property lastModified : TFslDateTime read GetLastModifiedST write SetLastModifiedST;
    // The date and time of last modification to this task.
    property lastModifiedElement : TFhirDateTime read FLastModified write SetLastModified;

    // Typed access to The creator of the task. (defined for API consistency)
    property requester : TFhirReference read FRequester write SetRequester;
    // The creator of the task.
    property requesterElement : TFhirReference read FRequester write SetRequester;

    // The kind of participant that should perform the task.
    property performerTypeList : TFhirCodeableConceptList read GetPerformerTypeList;
    property hasPerformerTypeList : boolean read GetHasPerformerTypeList;

    // Typed access to Individual organization or Device currently responsible for task execution. (defined for API consistency)
    property owner : TFhirReference read FOwner write SetOwner;
    // Individual organization or Device currently responsible for task execution.
    property ownerElement : TFhirReference read FOwner write SetOwner;

    // Typed access to Principal physical location where the this task is performed. (defined for API consistency)
    property location : TFhirReference read FLocation write SetLocation;
    // Principal physical location where the this task is performed.
    property locationElement : TFhirReference read FLocation write SetLocation;

    // Typed access to A description or code indicating why this task needs to be performed. (defined for API consistency)
    property reasonCode : TFhirCodeableConcept read FReasonCode write SetReasonCode;
    // A description or code indicating why this task needs to be performed.
    property reasonCodeElement : TFhirCodeableConcept read FReasonCode write SetReasonCode;

    // Typed access to A resource reference indicating why this task needs to be performed. (defined for API consistency)
    property reasonReference : TFhirReference read FReasonReference write SetReasonReference;
    // A resource reference indicating why this task needs to be performed.
    property reasonReferenceElement : TFhirReference read FReasonReference write SetReasonReference;

    // Insurance plans, coverage extensions, pre-authorizations and/or pre-determinations that may be relevant to the Task.
    property insuranceList : TFhirReferenceList read GetInsuranceList;
    property hasInsuranceList : boolean read GetHasInsuranceList;

    // Free-text information captured about the task as it progresses.
    property noteList : TFhirAnnotationList read GetNoteList;
    property hasNoteList : boolean read GetHasNoteList;

    // Links to Provenance records for past versions of this Task that identify key state transitions or updates that are likely to be relevant to a user looking at the current version of the task.
    property relevantHistoryList : TFhirReferenceList read GetRelevantHistoryList;
    property hasRelevantHistoryList : boolean read GetHasRelevantHistoryList;

    // Typed access to If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned. (defined for API consistency)
    property restriction : TFhirTaskRestriction read FRestriction write SetRestriction;
    // If the Task.focus is a request resource and the task is seeking fulfillment (i.e. is asking for the request to be actioned), this element identifies any limitations on what parts of the referenced request should be actioned.
    property restrictionElement : TFhirTaskRestriction read FRestriction write SetRestriction;

    // Additional information that may be needed in the execution of the task.
    property inputList : TFhirTaskInputList read GetInputList;
    property hasInputList : boolean read GetHasInputList;

    // Outputs produced by the Task.
    property outputList : TFhirTaskOutputList read GetOutputList;
    property hasOutputList : boolean read GetHasOutputList;

  end;

  TFhirTaskListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTaskList;
    function GetCurrent : TFhirTask;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTaskList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTask read GetCurrent;
  end;

  TFhirTaskList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTask;
    procedure SetItemN(index : Integer; value : TFhirTask);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTaskList; overload;
    function Clone : TFhirTaskList; overload;
    function GetEnumerator : TFhirTaskListEnumerator;
    
    //  Add a FhirTask to the end of the list.
    function Append : TFhirTask;
    
    // Add an already existing FhirTask to the end of the list.
    function AddItem(value : TFhirTask) : TFhirTask; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTask) : Integer;
    
    // Insert FhirTask before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTask;
    
    // Insert an existing FhirTask before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTask);
    
    // Get the iIndexth FhirTask. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTask);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTask;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTasks[index : Integer] : TFhirTask read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
  // A participant in the test execution, either the execution engine, a client, or a server.
  TFhirTestReportParticipant = class (TFhirBackboneElement)
  protected
    FType_ : TFhirEnum;
    FUri : TFhirUri;
    FDisplay : TFhirString;
    procedure SetType_(value : TFhirEnum);
    function GetType_ST : TFhirTestReportParticipantTypeEnum;
    procedure SetType_ST(value : TFhirTestReportParticipantTypeEnum);
    procedure SetUri(value : TFhirUri);
    function GetUriST : String;
    procedure SetUriST(value : String);
    procedure SetDisplay(value : TFhirString);
    function GetDisplayST : String;
    procedure SetDisplayST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportParticipant; overload;
    function Clone : TFhirTestReportParticipant; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The type of participant.
    property type_ : TFhirTestReportParticipantTypeEnum read GetType_ST write SetType_ST;
    property type_Element : TFhirEnum read FType_ write SetType_;

    // Typed access to The uri of the participant. An absolute URL is preferred.
    property uri : String read GetUriST write SetUriST;
    // The uri of the participant. An absolute URL is preferred.
    property uriElement : TFhirUri read FUri write SetUri;

    // Typed access to The display name of the participant.
    property display : String read GetDisplayST write SetDisplayST;
    // The display name of the participant.
    property displayElement : TFhirString read FDisplay write SetDisplay;

  end;

  TFhirTestReportParticipantListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportParticipantList;
    function GetCurrent : TFhirTestReportParticipant;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportParticipantList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportParticipant read GetCurrent;
  end;

  TFhirTestReportParticipantList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportParticipant;
    procedure SetItemN(index : Integer; value : TFhirTestReportParticipant);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportParticipantList; overload;
    function Clone : TFhirTestReportParticipantList; overload;
    function GetEnumerator : TFhirTestReportParticipantListEnumerator;
    
    //  Add a FhirTestReportParticipant to the end of the list.
    function Append : TFhirTestReportParticipant;
    
    // Add an already existing FhirTestReportParticipant to the end of the list.
    function AddItem(value : TFhirTestReportParticipant) : TFhirTestReportParticipant; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportParticipant) : Integer;
    
    // Insert FhirTestReportParticipant before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportParticipant;
    
    // Insert an existing FhirTestReportParticipant before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportParticipant);
    
    // Get the iIndexth FhirTestReportParticipant. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportParticipant);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportParticipant;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportParticipants[index : Integer] : TFhirTestReportParticipant read GetItemN write SetItemN; default;
  End;

  // The results of the series of required setup operations before the tests were executed.
  TFhirTestReportSetup = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestReportSetupActionList;
    function GetActionList : TFhirTestReportSetupActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetup; overload;
    function Clone : TFhirTestReportSetup; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestReportSetupActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportSetupListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupList;
    function GetCurrent : TFhirTestReportSetup;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetup read GetCurrent;
  end;

  TFhirTestReportSetupList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportSetup;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetup);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportSetupList; overload;
    function Clone : TFhirTestReportSetupList; overload;
    function GetEnumerator : TFhirTestReportSetupListEnumerator;
    
    //  Add a FhirTestReportSetup to the end of the list.
    function Append : TFhirTestReportSetup;
    
    // Add an already existing FhirTestReportSetup to the end of the list.
    function AddItem(value : TFhirTestReportSetup) : TFhirTestReportSetup; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetup) : Integer;
    
    // Insert FhirTestReportSetup before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetup;
    
    // Insert an existing FhirTestReportSetup before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetup);
    
    // Get the iIndexth FhirTestReportSetup. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetup);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetup;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportSetups[index : Integer] : TFhirTestReportSetup read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestReportSetupAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    FAssert : TFhirTestReportSetupActionAssert;
    procedure SetOperation(value : TFhirTestReportSetupActionOperation);
    procedure SetAssert(value : TFhirTestReportSetupActionAssert);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupAction; overload;
    function Clone : TFhirTestReportSetupAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The operation performed. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // The operation performed.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

    // Typed access to The results of the assertion performed on the previous operations. (defined for API consistency)
    property assert : TFhirTestReportSetupActionAssert read FAssert write SetAssert;
    // The results of the assertion performed on the previous operations.
    property assertElement : TFhirTestReportSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestReportSetupActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionList;
    function GetCurrent : TFhirTestReportSetupAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupAction read GetCurrent;
  end;

  TFhirTestReportSetupActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportSetupAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportSetupActionList; overload;
    function Clone : TFhirTestReportSetupActionList; overload;
    function GetEnumerator : TFhirTestReportSetupActionListEnumerator;
    
    //  Add a FhirTestReportSetupAction to the end of the list.
    function Append : TFhirTestReportSetupAction;
    
    // Add an already existing FhirTestReportSetupAction to the end of the list.
    function AddItem(value : TFhirTestReportSetupAction) : TFhirTestReportSetupAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupAction) : Integer;
    
    // Insert FhirTestReportSetupAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupAction;
    
    // Insert an existing FhirTestReportSetupAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupAction);
    
    // Get the iIndexth FhirTestReportSetupAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportSetupActions[index : Integer] : TFhirTestReportSetupAction read GetItemN write SetItemN; default;
  End;

  // The operation performed.
  TFhirTestReportSetupActionOperation = class (TFhirBackboneElement)
  protected
    FResult : TFhirEnum;
    FMessage : TFhirMarkdown;
    FDetail : TFhirUri;
    procedure SetResult(value : TFhirEnum);
    function GetResultST : TFhirTestReportActionResultEnum;
    procedure SetResultST(value : TFhirTestReportActionResultEnum);
    procedure SetMessage(value : TFhirMarkdown);
    function GetMessageST : String;
    procedure SetMessageST(value : String);
    procedure SetDetail(value : TFhirUri);
    function GetDetailST : String;
    procedure SetDetailST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupActionOperation; overload;
    function Clone : TFhirTestReportSetupActionOperation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The result of this operation.
    property result : TFhirTestReportActionResultEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to An explanatory message associated with the result.
    property message : String read GetMessageST write SetMessageST;
    // An explanatory message associated with the result.
    property messageElement : TFhirMarkdown read FMessage write SetMessage;

    // Typed access to A link to further details on the result.
    property detail : String read GetDetailST write SetDetailST;
    // A link to further details on the result.
    property detailElement : TFhirUri read FDetail write SetDetail;

  end;

  TFhirTestReportSetupActionOperationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionOperationList;
    function GetCurrent : TFhirTestReportSetupActionOperation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionOperationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupActionOperation read GetCurrent;
  end;

  TFhirTestReportSetupActionOperationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportSetupActionOperation;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupActionOperation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportSetupActionOperationList; overload;
    function Clone : TFhirTestReportSetupActionOperationList; overload;
    function GetEnumerator : TFhirTestReportSetupActionOperationListEnumerator;
    
    //  Add a FhirTestReportSetupActionOperation to the end of the list.
    function Append : TFhirTestReportSetupActionOperation;
    
    // Add an already existing FhirTestReportSetupActionOperation to the end of the list.
    function AddItem(value : TFhirTestReportSetupActionOperation) : TFhirTestReportSetupActionOperation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupActionOperation) : Integer;
    
    // Insert FhirTestReportSetupActionOperation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupActionOperation;
    
    // Insert an existing FhirTestReportSetupActionOperation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupActionOperation);
    
    // Get the iIndexth FhirTestReportSetupActionOperation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupActionOperation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupActionOperation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportSetupActionOperations[index : Integer] : TFhirTestReportSetupActionOperation read GetItemN write SetItemN; default;
  End;

  // The results of the assertion performed on the previous operations.
  TFhirTestReportSetupActionAssert = class (TFhirBackboneElement)
  protected
    FResult : TFhirEnum;
    FMessage : TFhirMarkdown;
    FDetail : TFhirString;
    procedure SetResult(value : TFhirEnum);
    function GetResultST : TFhirTestReportActionResultEnum;
    procedure SetResultST(value : TFhirTestReportActionResultEnum);
    procedure SetMessage(value : TFhirMarkdown);
    function GetMessageST : String;
    procedure SetMessageST(value : String);
    procedure SetDetail(value : TFhirString);
    function GetDetailST : String;
    procedure SetDetailST(value : String);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportSetupActionAssert; overload;
    function Clone : TFhirTestReportSetupActionAssert; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The result of this assertion.
    property result : TFhirTestReportActionResultEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to An explanatory message associated with the result.
    property message : String read GetMessageST write SetMessageST;
    // An explanatory message associated with the result.
    property messageElement : TFhirMarkdown read FMessage write SetMessage;

    // Typed access to A link to further details on the result.
    property detail : String read GetDetailST write SetDetailST;
    // A link to further details on the result.
    property detailElement : TFhirString read FDetail write SetDetail;

  end;

  TFhirTestReportSetupActionAssertListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportSetupActionAssertList;
    function GetCurrent : TFhirTestReportSetupActionAssert;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportSetupActionAssertList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportSetupActionAssert read GetCurrent;
  end;

  TFhirTestReportSetupActionAssertList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportSetupActionAssert;
    procedure SetItemN(index : Integer; value : TFhirTestReportSetupActionAssert);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportSetupActionAssertList; overload;
    function Clone : TFhirTestReportSetupActionAssertList; overload;
    function GetEnumerator : TFhirTestReportSetupActionAssertListEnumerator;
    
    //  Add a FhirTestReportSetupActionAssert to the end of the list.
    function Append : TFhirTestReportSetupActionAssert;
    
    // Add an already existing FhirTestReportSetupActionAssert to the end of the list.
    function AddItem(value : TFhirTestReportSetupActionAssert) : TFhirTestReportSetupActionAssert; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportSetupActionAssert) : Integer;
    
    // Insert FhirTestReportSetupActionAssert before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportSetupActionAssert;
    
    // Insert an existing FhirTestReportSetupActionAssert before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportSetupActionAssert);
    
    // Get the iIndexth FhirTestReportSetupActionAssert. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportSetupActionAssert);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportSetupActionAssert;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportSetupActionAsserts[index : Integer] : TFhirTestReportSetupActionAssert read GetItemN write SetItemN; default;
  End;

  // A test executed from the test script.
  TFhirTestReportTest = class (TFhirBackboneElement)
  protected
    FName : TFhirString;
    FDescription : TFhirString;
    FactionList : TFhirTestReportTestActionList;
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetDescription(value : TFhirString);
    function GetDescriptionST : String;
    procedure SetDescriptionST(value : String);
    function GetActionList : TFhirTestReportTestActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTest; overload;
    function Clone : TFhirTestReportTest; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The name of this test used for tracking/logging purposes by test engines.
    property name : String read GetNameST write SetNameST;
    // The name of this test used for tracking/logging purposes by test engines.
    property nameElement : TFhirString read FName write SetName;

    // Typed access to A short description of the test used by test engines for tracking and reporting purposes.
    property description : String read GetDescriptionST write SetDescriptionST;
    // A short description of the test used by test engines for tracking and reporting purposes.
    property descriptionElement : TFhirString read FDescription write SetDescription;

    // Action would contain either an operation or an assertion.
    property actionList : TFhirTestReportTestActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportTestListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTestList;
    function GetCurrent : TFhirTestReportTest;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTestList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTest read GetCurrent;
  end;

  TFhirTestReportTestList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportTest;
    procedure SetItemN(index : Integer; value : TFhirTestReportTest);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportTestList; overload;
    function Clone : TFhirTestReportTestList; overload;
    function GetEnumerator : TFhirTestReportTestListEnumerator;
    
    //  Add a FhirTestReportTest to the end of the list.
    function Append : TFhirTestReportTest;
    
    // Add an already existing FhirTestReportTest to the end of the list.
    function AddItem(value : TFhirTestReportTest) : TFhirTestReportTest; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTest) : Integer;
    
    // Insert FhirTestReportTest before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTest;
    
    // Insert an existing FhirTestReportTest before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTest);
    
    // Get the iIndexth FhirTestReportTest. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTest);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTest;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportTests[index : Integer] : TFhirTestReportTest read GetItemN write SetItemN; default;
  End;

  // Action would contain either an operation or an assertion.
  TFhirTestReportTestAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    FAssert : TFhirTestReportSetupActionAssert;
    procedure SetOperation(value : TFhirTestReportSetupActionOperation);
    procedure SetAssert(value : TFhirTestReportSetupActionAssert);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTestAction; overload;
    function Clone : TFhirTestReportTestAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

    // Typed access to The results of the assertion performed on the previous operations. (defined for API consistency)
    property assert : TFhirTestReportSetupActionAssert read FAssert write SetAssert;
    // The results of the assertion performed on the previous operations.
    property assertElement : TFhirTestReportSetupActionAssert read FAssert write SetAssert;

  end;

  TFhirTestReportTestActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTestActionList;
    function GetCurrent : TFhirTestReportTestAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTestActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTestAction read GetCurrent;
  end;

  TFhirTestReportTestActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportTestAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportTestAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportTestActionList; overload;
    function Clone : TFhirTestReportTestActionList; overload;
    function GetEnumerator : TFhirTestReportTestActionListEnumerator;
    
    //  Add a FhirTestReportTestAction to the end of the list.
    function Append : TFhirTestReportTestAction;
    
    // Add an already existing FhirTestReportTestAction to the end of the list.
    function AddItem(value : TFhirTestReportTestAction) : TFhirTestReportTestAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTestAction) : Integer;
    
    // Insert FhirTestReportTestAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTestAction;
    
    // Insert an existing FhirTestReportTestAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTestAction);
    
    // Get the iIndexth FhirTestReportTestAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTestAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTestAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportTestActions[index : Integer] : TFhirTestReportTestAction read GetItemN write SetItemN; default;
  End;

  // The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
  TFhirTestReportTeardown = class (TFhirBackboneElement)
  protected
    FactionList : TFhirTestReportTeardownActionList;
    function GetActionList : TFhirTestReportTeardownActionList;
    function GetHasActionList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTeardown; overload;
    function Clone : TFhirTestReportTeardown; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // The teardown action will only contain an operation.
    property actionList : TFhirTestReportTeardownActionList read GetActionList;
    property hasActionList : boolean read GetHasActionList;

  end;

  TFhirTestReportTeardownListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTeardownList;
    function GetCurrent : TFhirTestReportTeardown;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTeardownList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTeardown read GetCurrent;
  end;

  TFhirTestReportTeardownList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportTeardown;
    procedure SetItemN(index : Integer; value : TFhirTestReportTeardown);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportTeardownList; overload;
    function Clone : TFhirTestReportTeardownList; overload;
    function GetEnumerator : TFhirTestReportTeardownListEnumerator;
    
    //  Add a FhirTestReportTeardown to the end of the list.
    function Append : TFhirTestReportTeardown;
    
    // Add an already existing FhirTestReportTeardown to the end of the list.
    function AddItem(value : TFhirTestReportTeardown) : TFhirTestReportTeardown; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTeardown) : Integer;
    
    // Insert FhirTestReportTeardown before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTeardown;
    
    // Insert an existing FhirTestReportTeardown before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTeardown);
    
    // Get the iIndexth FhirTestReportTeardown. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTeardown);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTeardown;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportTeardowns[index : Integer] : TFhirTestReportTeardown read GetItemN write SetItemN; default;
  End;

  // The teardown action will only contain an operation.
  TFhirTestReportTeardownAction = class (TFhirBackboneElement)
  protected
    FOperation : TFhirTestReportSetupActionOperation;
    procedure SetOperation(value : TFhirTestReportSetupActionOperation);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReportTeardownAction; overload;
    function Clone : TFhirTestReportTeardownAction; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to An operation would involve a REST request to a server. (defined for API consistency)
    property operation : TFhirTestReportSetupActionOperation read FOperation write SetOperation;
    // An operation would involve a REST request to a server.
    property operationElement : TFhirTestReportSetupActionOperation read FOperation write SetOperation;

  end;

  TFhirTestReportTeardownActionListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportTeardownActionList;
    function GetCurrent : TFhirTestReportTeardownAction;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportTeardownActionList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReportTeardownAction read GetCurrent;
  end;

  TFhirTestReportTeardownActionList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReportTeardownAction;
    procedure SetItemN(index : Integer; value : TFhirTestReportTeardownAction);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportTeardownActionList; overload;
    function Clone : TFhirTestReportTeardownActionList; overload;
    function GetEnumerator : TFhirTestReportTeardownActionListEnumerator;
    
    //  Add a FhirTestReportTeardownAction to the end of the list.
    function Append : TFhirTestReportTeardownAction;
    
    // Add an already existing FhirTestReportTeardownAction to the end of the list.
    function AddItem(value : TFhirTestReportTeardownAction) : TFhirTestReportTeardownAction; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReportTeardownAction) : Integer;
    
    // Insert FhirTestReportTeardownAction before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReportTeardownAction;
    
    // Insert an existing FhirTestReportTeardownAction before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReportTeardownAction);
    
    // Get the iIndexth FhirTestReportTeardownAction. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReportTeardownAction);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReportTeardownAction;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReportTeardownActions[index : Integer] : TFhirTestReportTeardownAction read GetItemN write SetItemN; default;
  End;

  // A summary of information based on the results of executing a TestScript.
  TFhirTestReport = class (TFhirDomainResource)
  protected
    FIdentifier : TFhirIdentifier;
    FName : TFhirString;
    FStatus : TFhirEnum;
    FTestScript : TFhirReference;
    FResult : TFhirEnum;
    FScore : TFhirDecimal;
    FTester : TFhirString;
    FIssued : TFhirDateTime;
    FparticipantList : TFhirTestReportParticipantList;
    FSetup : TFhirTestReportSetup;
    FtestList : TFhirTestReportTestList;
    FTeardown : TFhirTestReportTeardown;
    procedure SetIdentifier(value : TFhirIdentifier);
    procedure SetName(value : TFhirString);
    function GetNameST : String;
    procedure SetNameST(value : String);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirTestReportStatusEnum;
    procedure SetStatusST(value : TFhirTestReportStatusEnum);
    procedure SetTestScript(value : TFhirReference);
    procedure SetResult(value : TFhirEnum);
    function GetResultST : TFhirTestReportResultEnum;
    procedure SetResultST(value : TFhirTestReportResultEnum);
    procedure SetScore(value : TFhirDecimal);
    function GetScoreST : String;
    procedure SetScoreST(value : String);
    procedure SetTester(value : TFhirString);
    function GetTesterST : String;
    procedure SetTesterST(value : String);
    procedure SetIssued(value : TFhirDateTime);
    function GetIssuedST : TFslDateTime;
    procedure SetIssuedST(value : TFslDateTime);
    function GetParticipantList : TFhirTestReportParticipantList;
    function GetHasParticipantList : Boolean;
    procedure SetSetup(value : TFhirTestReportSetup);
    function GetTestList : TFhirTestReportTestList;
    function GetHasTestList : Boolean;
    procedure SetTeardown(value : TFhirTestReportTeardown);
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirTestReport; overload;
    function Clone : TFhirTestReport; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Identifier for the TestScript assigned for external purposes outside the context of FHIR. (defined for API consistency)
    property identifier : TFhirIdentifier read FIdentifier write SetIdentifier;
    // Identifier for the TestScript assigned for external purposes outside the context of FHIR.
    property identifierElement : TFhirIdentifier read FIdentifier write SetIdentifier;

    // Typed access to A free text natural language name identifying the executed TestScript.
    property name : String read GetNameST write SetNameST;
    // A free text natural language name identifying the executed TestScript.
    property nameElement : TFhirString read FName write SetName;

    // The current state of this test report.
    property status : TFhirTestReportStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`. (defined for API consistency)
    property testScript : TFhirReference read FTestScript write SetTestScript;
    // Ideally this is an absolute URL that is used to identify the version-specific TestScript that was executed, matching the `TestScript.url`.
    property testScriptElement : TFhirReference read FTestScript write SetTestScript;

    // The overall result from the execution of the TestScript.
    property result : TFhirTestReportResultEnum read GetResultST write SetResultST;
    property resultElement : TFhirEnum read FResult write SetResult;

    // Typed access to The final score (percentage of tests passed) resulting from the execution of the TestScript.
    property score : String read GetScoreST write SetScoreST;
    // The final score (percentage of tests passed) resulting from the execution of the TestScript.
    property scoreElement : TFhirDecimal read FScore write SetScore;

    // Typed access to Name of the tester producing this report (Organization or individual).
    property tester : String read GetTesterST write SetTesterST;
    // Name of the tester producing this report (Organization or individual).
    property testerElement : TFhirString read FTester write SetTester;

    // Typed access to When the TestScript was executed and this TestReport was generated.
    property issued : TFslDateTime read GetIssuedST write SetIssuedST;
    // When the TestScript was executed and this TestReport was generated.
    property issuedElement : TFhirDateTime read FIssued write SetIssued;

    // A participant in the test execution, either the execution engine, a client, or a server.
    property participantList : TFhirTestReportParticipantList read GetParticipantList;
    property hasParticipantList : boolean read GetHasParticipantList;

    // Typed access to The results of the series of required setup operations before the tests were executed. (defined for API consistency)
    property setup : TFhirTestReportSetup read FSetup write SetSetup;
    // The results of the series of required setup operations before the tests were executed.
    property setupElement : TFhirTestReportSetup read FSetup write SetSetup;

    // A test executed from the test script.
    property testList : TFhirTestReportTestList read GetTestList;
    property hasTestList : boolean read GetHasTestList;

    // Typed access to The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise). (defined for API consistency)
    property teardown : TFhirTestReportTeardown read FTeardown write SetTeardown;
    // The results of the series of operations required to clean up after all the tests were executed (successfully or otherwise).
    property teardownElement : TFhirTestReportTeardown read FTeardown write SetTeardown;

  end;

  TFhirTestReportListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirTestReportList;
    function GetCurrent : TFhirTestReport;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirTestReportList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirTestReport read GetCurrent;
  end;

  TFhirTestReportList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirTestReport;
    procedure SetItemN(index : Integer; value : TFhirTestReport);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirTestReportList; overload;
    function Clone : TFhirTestReportList; overload;
    function GetEnumerator : TFhirTestReportListEnumerator;
    
    //  Add a FhirTestReport to the end of the list.
    function Append : TFhirTestReport;
    
    // Add an already existing FhirTestReport to the end of the list.
    function AddItem(value : TFhirTestReport) : TFhirTestReport; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirTestReport) : Integer;
    
    // Insert FhirTestReport before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirTestReport;
    
    // Insert an existing FhirTestReport before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirTestReport);
    
    // Get the iIndexth FhirTestReport. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirTestReport);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirTestReport;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirTestReports[index : Integer] : TFhirTestReport read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_VERIFICATIONRESULT}
  // Information about the primary source(s) involved in validation.
  TFhirVerificationResultPrimarySource = class (TFhirBackboneElement)
  protected
    FWho : TFhirReference;
    Ftype_List : TFhirCodeableConceptList;
    FcommunicationMethodList : TFhirCodeableConceptList;
    FValidationStatus : TFhirCodeableConcept;
    FValidationDate : TFhirDateTime;
    FCanPushUpdates : TFhirCodeableConcept;
    FpushTypeAvailableList : TFhirCodeableConceptList;
    procedure SetWho(value : TFhirReference);
    function GetType_List : TFhirCodeableConceptList;
    function GetHasType_List : Boolean;
    function GetCommunicationMethodList : TFhirCodeableConceptList;
    function GetHasCommunicationMethodList : Boolean;
    procedure SetValidationStatus(value : TFhirCodeableConcept);
    procedure SetValidationDate(value : TFhirDateTime);
    function GetValidationDateST : TFslDateTime;
    procedure SetValidationDateST(value : TFslDateTime);
    procedure SetCanPushUpdates(value : TFhirCodeableConcept);
    function GetPushTypeAvailableList : TFhirCodeableConceptList;
    function GetHasPushTypeAvailableList : Boolean;
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResultPrimarySource; overload;
    function Clone : TFhirVerificationResultPrimarySource; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to the primary source. (defined for API consistency)
    property who : TFhirReference read FWho write SetWho;
    // Reference to the primary source.
    property whoElement : TFhirReference read FWho write SetWho;

    // Type of primary source (License Board; Primary Education; Continuing Education; Postal Service; Relationship owner; Registration Authority; legal source; issuing source; authoritative source).
    property type_List : TFhirCodeableConceptList read GetType_List;
    property hasType_List : boolean read GetHasType_List;

    // Method for communicating with the primary source (manual; API; Push).
    property communicationMethodList : TFhirCodeableConceptList read GetCommunicationMethodList;
    property hasCommunicationMethodList : boolean read GetHasCommunicationMethodList;

    // Typed access to Status of the validation of the target against the primary source (successful; failed; unknown). (defined for API consistency)
    property validationStatus : TFhirCodeableConcept read FValidationStatus write SetValidationStatus;
    // Status of the validation of the target against the primary source (successful; failed; unknown).
    property validationStatusElement : TFhirCodeableConcept read FValidationStatus write SetValidationStatus;

    // Typed access to When the target was validated against the primary source.
    property validationDate : TFslDateTime read GetValidationDateST write SetValidationDateST;
    // When the target was validated against the primary source.
    property validationDateElement : TFhirDateTime read FValidationDate write SetValidationDate;

    // Typed access to Ability of the primary source to push updates/alerts (yes; no; undetermined). (defined for API consistency)
    property canPushUpdates : TFhirCodeableConcept read FCanPushUpdates write SetCanPushUpdates;
    // Ability of the primary source to push updates/alerts (yes; no; undetermined).
    property canPushUpdatesElement : TFhirCodeableConcept read FCanPushUpdates write SetCanPushUpdates;

    // Type of alerts/updates the primary source can send (specific requested changes; any changes; as defined by source).
    property pushTypeAvailableList : TFhirCodeableConceptList read GetPushTypeAvailableList;
    property hasPushTypeAvailableList : boolean read GetHasPushTypeAvailableList;

  end;

  TFhirVerificationResultPrimarySourceListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultPrimarySourceList;
    function GetCurrent : TFhirVerificationResultPrimarySource;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultPrimarySourceList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResultPrimarySource read GetCurrent;
  end;

  TFhirVerificationResultPrimarySourceList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVerificationResultPrimarySource;
    procedure SetItemN(index : Integer; value : TFhirVerificationResultPrimarySource);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVerificationResultPrimarySourceList; overload;
    function Clone : TFhirVerificationResultPrimarySourceList; overload;
    function GetEnumerator : TFhirVerificationResultPrimarySourceListEnumerator;
    
    //  Add a FhirVerificationResultPrimarySource to the end of the list.
    function Append : TFhirVerificationResultPrimarySource;
    
    // Add an already existing FhirVerificationResultPrimarySource to the end of the list.
    function AddItem(value : TFhirVerificationResultPrimarySource) : TFhirVerificationResultPrimarySource; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResultPrimarySource) : Integer;
    
    // Insert FhirVerificationResultPrimarySource before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResultPrimarySource;
    
    // Insert an existing FhirVerificationResultPrimarySource before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResultPrimarySource);
    
    // Get the iIndexth FhirVerificationResultPrimarySource. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResultPrimarySource);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResultPrimarySource;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVerificationResultPrimarySources[index : Integer] : TFhirVerificationResultPrimarySource read GetItemN write SetItemN; default;
  End;

  // Information about the entity attesting to information.
  TFhirVerificationResultAttestation = class (TFhirBackboneElement)
  protected
    FWho : TFhirReference;
    FOnBehalfOf : TFhirReference;
    FCommunicationMethod : TFhirCodeableConcept;
    FDate : TFhirDate;
    FSourceIdentityCertificate : TFhirString;
    FProxyIdentityCertificate : TFhirString;
    FProxySignature : TFhirSignature;
    FSourceSignature : TFhirSignature;
    procedure SetWho(value : TFhirReference);
    procedure SetOnBehalfOf(value : TFhirReference);
    procedure SetCommunicationMethod(value : TFhirCodeableConcept);
    procedure SetDate(value : TFhirDate);
    function GetDateST : TFslDateTime;
    procedure SetDateST(value : TFslDateTime);
    procedure SetSourceIdentityCertificate(value : TFhirString);
    function GetSourceIdentityCertificateST : String;
    procedure SetSourceIdentityCertificateST(value : String);
    procedure SetProxyIdentityCertificate(value : TFhirString);
    function GetProxyIdentityCertificateST : String;
    procedure SetProxyIdentityCertificateST(value : String);
    procedure SetProxySignature(value : TFhirSignature);
    procedure SetSourceSignature(value : TFhirSignature);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResultAttestation; overload;
    function Clone : TFhirVerificationResultAttestation; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to The individual or organization attesting to information. (defined for API consistency)
    property who : TFhirReference read FWho write SetWho;
    // The individual or organization attesting to information.
    property whoElement : TFhirReference read FWho write SetWho;

    // Typed access to When the who is asserting on behalf of another (organization or individual). (defined for API consistency)
    property onBehalfOf : TFhirReference read FOnBehalfOf write SetOnBehalfOf;
    // When the who is asserting on behalf of another (organization or individual).
    property onBehalfOfElement : TFhirReference read FOnBehalfOf write SetOnBehalfOf;

    // Typed access to The method by which attested information was submitted/retrieved (manual; API; Push). (defined for API consistency)
    property communicationMethod : TFhirCodeableConcept read FCommunicationMethod write SetCommunicationMethod;
    // The method by which attested information was submitted/retrieved (manual; API; Push).
    property communicationMethodElement : TFhirCodeableConcept read FCommunicationMethod write SetCommunicationMethod;

    // Typed access to The date the information was attested to.
    property date : TFslDateTime read GetDateST write SetDateST;
    // The date the information was attested to.
    property dateElement : TFhirDate read FDate write SetDate;

    // Typed access to A digital identity certificate associated with the attestation source.
    property sourceIdentityCertificate : String read GetSourceIdentityCertificateST write SetSourceIdentityCertificateST;
    // A digital identity certificate associated with the attestation source.
    property sourceIdentityCertificateElement : TFhirString read FSourceIdentityCertificate write SetSourceIdentityCertificate;

    // Typed access to A digital identity certificate associated with the proxy entity submitting attested information on behalf of the attestation source.
    property proxyIdentityCertificate : String read GetProxyIdentityCertificateST write SetProxyIdentityCertificateST;
    // A digital identity certificate associated with the proxy entity submitting attested information on behalf of the attestation source.
    property proxyIdentityCertificateElement : TFhirString read FProxyIdentityCertificate write SetProxyIdentityCertificate;

    // Typed access to Signed assertion by the proxy entity indicating that they have the right to submit attested information on behalf of the attestation source. (defined for API consistency)
    property proxySignature : TFhirSignature read FProxySignature write SetProxySignature;
    // Signed assertion by the proxy entity indicating that they have the right to submit attested information on behalf of the attestation source.
    property proxySignatureElement : TFhirSignature read FProxySignature write SetProxySignature;

    // Typed access to Signed assertion by the attestation source that they have attested to the information. (defined for API consistency)
    property sourceSignature : TFhirSignature read FSourceSignature write SetSourceSignature;
    // Signed assertion by the attestation source that they have attested to the information.
    property sourceSignatureElement : TFhirSignature read FSourceSignature write SetSourceSignature;

  end;

  TFhirVerificationResultAttestationListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultAttestationList;
    function GetCurrent : TFhirVerificationResultAttestation;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultAttestationList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResultAttestation read GetCurrent;
  end;

  TFhirVerificationResultAttestationList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVerificationResultAttestation;
    procedure SetItemN(index : Integer; value : TFhirVerificationResultAttestation);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVerificationResultAttestationList; overload;
    function Clone : TFhirVerificationResultAttestationList; overload;
    function GetEnumerator : TFhirVerificationResultAttestationListEnumerator;
    
    //  Add a FhirVerificationResultAttestation to the end of the list.
    function Append : TFhirVerificationResultAttestation;
    
    // Add an already existing FhirVerificationResultAttestation to the end of the list.
    function AddItem(value : TFhirVerificationResultAttestation) : TFhirVerificationResultAttestation; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResultAttestation) : Integer;
    
    // Insert FhirVerificationResultAttestation before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResultAttestation;
    
    // Insert an existing FhirVerificationResultAttestation before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResultAttestation);
    
    // Get the iIndexth FhirVerificationResultAttestation. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResultAttestation);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResultAttestation;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVerificationResultAttestations[index : Integer] : TFhirVerificationResultAttestation read GetItemN write SetItemN; default;
  End;

  // Information about the entity validating information.
  TFhirVerificationResultValidator = class (TFhirBackboneElement)
  protected
    FOrganization : TFhirReference;
    FIdentityCertificate : TFhirString;
    FAttestationSignature : TFhirSignature;
    procedure SetOrganization(value : TFhirReference);
    procedure SetIdentityCertificate(value : TFhirString);
    function GetIdentityCertificateST : String;
    procedure SetIdentityCertificateST(value : String);
    procedure SetAttestationSignature(value : TFhirSignature);
  
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResultValidator; overload;
    function Clone : TFhirVerificationResultValidator; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // Typed access to Reference to the organization validating information. (defined for API consistency)
    property organization : TFhirReference read FOrganization write SetOrganization;
    // Reference to the organization validating information.
    property organizationElement : TFhirReference read FOrganization write SetOrganization;

    // Typed access to A digital identity certificate associated with the validator.
    property identityCertificate : String read GetIdentityCertificateST write SetIdentityCertificateST;
    // A digital identity certificate associated with the validator.
    property identityCertificateElement : TFhirString read FIdentityCertificate write SetIdentityCertificate;

    // Typed access to Signed assertion by the validator that they have validated the information. (defined for API consistency)
    property attestationSignature : TFhirSignature read FAttestationSignature write SetAttestationSignature;
    // Signed assertion by the validator that they have validated the information.
    property attestationSignatureElement : TFhirSignature read FAttestationSignature write SetAttestationSignature;

  end;

  TFhirVerificationResultValidatorListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultValidatorList;
    function GetCurrent : TFhirVerificationResultValidator;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultValidatorList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResultValidator read GetCurrent;
  end;

  TFhirVerificationResultValidatorList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVerificationResultValidator;
    procedure SetItemN(index : Integer; value : TFhirVerificationResultValidator);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVerificationResultValidatorList; overload;
    function Clone : TFhirVerificationResultValidatorList; overload;
    function GetEnumerator : TFhirVerificationResultValidatorListEnumerator;
    
    //  Add a FhirVerificationResultValidator to the end of the list.
    function Append : TFhirVerificationResultValidator;
    
    // Add an already existing FhirVerificationResultValidator to the end of the list.
    function AddItem(value : TFhirVerificationResultValidator) : TFhirVerificationResultValidator; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResultValidator) : Integer;
    
    // Insert FhirVerificationResultValidator before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResultValidator;
    
    // Insert an existing FhirVerificationResultValidator before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResultValidator);
    
    // Get the iIndexth FhirVerificationResultValidator. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResultValidator);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResultValidator;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVerificationResultValidators[index : Integer] : TFhirVerificationResultValidator read GetItemN write SetItemN; default;
  End;

  // Describes validation requirements, source(s), status and dates for one or more elements.
  TFhirVerificationResult = class (TFhirDomainResource)
  protected
    FtargetList : TFhirReferenceList;
    FtargetLocationList : TFhirStringList;
    FNeed : TFhirCodeableConcept;
    FStatus : TFhirEnum;
    FStatusDate : TFhirDateTime;
    FValidationType : TFhirCodeableConcept;
    FvalidationProcessList : TFhirCodeableConceptList;
    FFrequency : TFhirTiming;
    FLastPerformed : TFhirDateTime;
    FNextScheduled : TFhirDate;
    FFailureAction : TFhirCodeableConcept;
    FprimarySourceList : TFhirVerificationResultPrimarySourceList;
    FAttestation : TFhirVerificationResultAttestation;
    FvalidatorList : TFhirVerificationResultValidatorList;
    function GetTargetList : TFhirReferenceList;
    function GetHasTargetList : Boolean;
    function GetTargetLocationList : TFhirStringList;
    function GetHasTargetLocationList : Boolean;
    procedure SetNeed(value : TFhirCodeableConcept);
    procedure SetStatus(value : TFhirEnum);
    function GetStatusST : TFhirStatusEnum;
    procedure SetStatusST(value : TFhirStatusEnum);
    procedure SetStatusDate(value : TFhirDateTime);
    function GetStatusDateST : TFslDateTime;
    procedure SetStatusDateST(value : TFslDateTime);
    procedure SetValidationType(value : TFhirCodeableConcept);
    function GetValidationProcessList : TFhirCodeableConceptList;
    function GetHasValidationProcessList : Boolean;
    procedure SetFrequency(value : TFhirTiming);
    procedure SetLastPerformed(value : TFhirDateTime);
    function GetLastPerformedST : TFslDateTime;
    procedure SetLastPerformedST(value : TFslDateTime);
    procedure SetNextScheduled(value : TFhirDate);
    function GetNextScheduledST : TFslDateTime;
    procedure SetNextScheduledST(value : TFslDateTime);
    procedure SetFailureAction(value : TFhirCodeableConcept);
    function GetPrimarySourceList : TFhirVerificationResultPrimarySourceList;
    function GetHasPrimarySourceList : Boolean;
    procedure SetAttestation(value : TFhirVerificationResultAttestation);
    function GetValidatorList : TFhirVerificationResultValidatorList;
    function GetHasValidatorList : Boolean;
  
    function GetResourceType : TFhirResourceType; override;
    procedure GetChildrenByName(child_name : string; list : TFHIRSelectionList); override;
    procedure ListProperties(oList : TFHIRPropertyList; bInheritedProperties, bPrimitiveValues : Boolean); override;
    procedure listFieldsInOrder(fields : TStringList); override;
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Assign(oSource : TFslObject); override;
    function Link : TFhirVerificationResult; overload;
    function Clone : TFhirVerificationResult; overload;
    function setProperty(propName : string; propValue : TFHIRObject) : TFHIRObject; override;
    procedure insertProperty(propName : string; propValue : TFHIRObject; index : integer); override;
    function createPropertyValue(propName : string) : TFHIRObject; override;
    function getTypesForProperty(propName : string): String; override;
    procedure deleteProperty(propName : string; value : TFHIRObject); override;
    procedure replaceProperty(propName : string; existing, new : TFHIRObject); override;
    procedure reorderProperty(propName : string; source, destination : integer); override;
    function fhirType : string; override;
    function Equals(other : TObject) : boolean; override;
    function isEmpty : boolean; override;
  {$IFNDEF FPC}published{$ENDIF}
    // A resource that was validated.
    property targetList : TFhirReferenceList read GetTargetList;
    property hasTargetList : boolean read GetHasTargetList;

    // The fhirpath location(s) within the resource that was validated.
    property targetLocationList : TFhirStringList read GetTargetLocationList;
    property hasTargetLocationList : boolean read GetHasTargetLocationList;

    // Typed access to The frequency with which the target must be validated (none; initial; periodic). (defined for API consistency)
    property need : TFhirCodeableConcept read FNeed write SetNeed;
    // The frequency with which the target must be validated (none; initial; periodic).
    property needElement : TFhirCodeableConcept read FNeed write SetNeed;

    // The validation status of the target (attested; validated; in process; requires revalidation; validation failed; revalidation failed).
    property status : TFhirStatusEnum read GetStatusST write SetStatusST;
    property statusElement : TFhirEnum read FStatus write SetStatus;

    // Typed access to When the validation status was updated.
    property statusDate : TFslDateTime read GetStatusDateST write SetStatusDateST;
    // When the validation status was updated.
    property statusDateElement : TFhirDateTime read FStatusDate write SetStatusDate;

    // Typed access to What the target is validated against (nothing; primary source; multiple sources). (defined for API consistency)
    property validationType : TFhirCodeableConcept read FValidationType write SetValidationType;
    // What the target is validated against (nothing; primary source; multiple sources).
    property validationTypeElement : TFhirCodeableConcept read FValidationType write SetValidationType;

    // The primary process by which the target is validated (edit check; value set; primary source; multiple sources; standalone; in context).
    property validationProcessList : TFhirCodeableConceptList read GetValidationProcessList;
    property hasValidationProcessList : boolean read GetHasValidationProcessList;

    // Typed access to Frequency of revalidation. (defined for API consistency)
    property frequency : TFhirTiming read FFrequency write SetFrequency;
    // Frequency of revalidation.
    property frequencyElement : TFhirTiming read FFrequency write SetFrequency;

    // Typed access to The date/time validation was last completed (including failed validations).
    property lastPerformed : TFslDateTime read GetLastPerformedST write SetLastPerformedST;
    // The date/time validation was last completed (including failed validations).
    property lastPerformedElement : TFhirDateTime read FLastPerformed write SetLastPerformed;

    // Typed access to The date when target is next validated, if appropriate.
    property nextScheduled : TFslDateTime read GetNextScheduledST write SetNextScheduledST;
    // The date when target is next validated, if appropriate.
    property nextScheduledElement : TFhirDate read FNextScheduled write SetNextScheduled;

    // Typed access to The result if validation fails (fatal; warning; record only; none). (defined for API consistency)
    property failureAction : TFhirCodeableConcept read FFailureAction write SetFailureAction;
    // The result if validation fails (fatal; warning; record only; none).
    property failureActionElement : TFhirCodeableConcept read FFailureAction write SetFailureAction;

    // Information about the primary source(s) involved in validation.
    property primarySourceList : TFhirVerificationResultPrimarySourceList read GetPrimarySourceList;
    property hasPrimarySourceList : boolean read GetHasPrimarySourceList;

    // Typed access to Information about the entity attesting to information. (defined for API consistency)
    property attestation : TFhirVerificationResultAttestation read FAttestation write SetAttestation;
    // Information about the entity attesting to information.
    property attestationElement : TFhirVerificationResultAttestation read FAttestation write SetAttestation;

    // Information about the entity validating information.
    property validatorList : TFhirVerificationResultValidatorList read GetValidatorList;
    property hasValidatorList : boolean read GetHasValidatorList;

  end;

  TFhirVerificationResultListEnumerator = class (TFslObject)
  private
    FIndex : integer;
    FList : TFhirVerificationResultList;
    function GetCurrent : TFhirVerificationResult;
  protected
    function sizeInBytesV(magic : integer) : cardinal; override;
  public
    constructor Create(list : TFhirVerificationResultList);
    destructor Destroy; override;
    function MoveNext : boolean;
    property Current : TFhirVerificationResult read GetCurrent;
  end;

  TFhirVerificationResultList = class (TFHIRObjectList)
  private
    function GetItemN(index : Integer) : TFhirVerificationResult;
    procedure SetItemN(index : Integer; value : TFhirVerificationResult);
  protected
    function ItemClass : TFslObjectClass; override;
  public
    function Link : TFhirVerificationResultList; overload;
    function Clone : TFhirVerificationResultList; overload;
    function GetEnumerator : TFhirVerificationResultListEnumerator;
    
    //  Add a FhirVerificationResult to the end of the list.
    function Append : TFhirVerificationResult;
    
    // Add an already existing FhirVerificationResult to the end of the list.
    function AddItem(value : TFhirVerificationResult) : TFhirVerificationResult; overload;
    
    // See if an item is already in the list. returns -1 if not in the list
    function IndexOf(value : TFhirVerificationResult) : Integer;
    
    // Insert FhirVerificationResult before the designated index (0 = first item)
    function Insert(index : Integer) : TFhirVerificationResult;
    
    // Insert an existing FhirVerificationResult before the designated index (0 = first item)
    procedure InsertItem(index : Integer; value : TFhirVerificationResult);
    
    // Get the iIndexth FhirVerificationResult. (0 = first item)
    procedure SetItemByIndex(index : Integer; value : TFhirVerificationResult);
    
    // The number of items in the collection
    function Item(index : Integer) : TFhirVerificationResult;
    
    // The number of items in the collection
    function Count : Integer; overload;
    
    // Remove the indexth item. The first item is index 0.
    procedure Remove(index : Integer);
    
    // Remove All Items from the list
    procedure ClearItems;
    
    property FhirVerificationResults[index : Integer] : TFhirVerificationResult read GetItemN write SetItemN; default;
  End;

{$ENDIF FHIR_VERIFICATIONRESULT}



implementation

uses
  fhir4b_utilities;



{$IFDEF FHIR_ACTIVITYDEFINITION}
{ TFhirActivityDefinitionParticipant }

constructor TFhirActivityDefinitionParticipant.Create;
begin
  inherited;
end;

destructor TFhirActivityDefinitionParticipant.Destroy;
begin
  FType_.free;
  FRole.free;
  inherited;
end;

procedure TFhirActivityDefinitionParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirActivityDefinitionParticipant(oSource).type_Element.Clone;
  role := TFhirActivityDefinitionParticipant(oSource).role.Clone;
end;

procedure TFhirActivityDefinitionParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirActivityDefinitionParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
end;

function TFhirActivityDefinitionParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirActivityDefinitionParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirActivityDefinitionParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull], CODES_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull]) 
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirActivityDefinitionParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirActivityDefinitionParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirActivityDefinitionParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirActivityDefinitionParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirActivityDefinitionParticipant.fhirType : string;
begin
  result := 'ActivityDefinition.participant';
end;

function TFhirActivityDefinitionParticipant.Link : TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(inherited Link);
end;

function TFhirActivityDefinitionParticipant.Clone : TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(inherited Clone);
end;

function TFhirActivityDefinitionParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirActivityDefinitionParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirActivityDefinitionParticipant)) then
    result := false
  else
  begin
    o := TFhirActivityDefinitionParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirActivityDefinitionParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRole);
end;

procedure TFhirActivityDefinitionParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
end;

function TFhirActivityDefinitionParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirActivityDefinitionParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirActivityDefinitionParticipant.GetType_ST : TFhirActionParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirActionParticipantTypeEnum(0)
  else
    result := TFhirActionParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionParticipantTypeEnum, FType_.value));
end;

procedure TFhirActivityDefinitionParticipant.SetType_ST(value : TFhirActionParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[value], CODES_TFhirActionParticipantTypeEnum[value]);
end;

procedure TFhirActivityDefinitionParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

{ TFhirActivityDefinitionParticipantListEnumerator }

constructor TFhirActivityDefinitionParticipantListEnumerator.Create(list : TFhirActivityDefinitionParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirActivityDefinitionParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirActivityDefinitionParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirActivityDefinitionParticipantListEnumerator.GetCurrent : TFhirActivityDefinitionParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirActivityDefinitionParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirActivityDefinitionParticipantList }

function TFhirActivityDefinitionParticipantList.AddItem(value: TFhirActivityDefinitionParticipant): TFhirActivityDefinitionParticipant;
begin
  assert(value.ClassName = 'TFhirActivityDefinitionParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirActivityDefinitionParticipant');
  add(value);
  result := value;
end;

function TFhirActivityDefinitionParticipantList.Append: TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirActivityDefinitionParticipantList.GetEnumerator : TFhirActivityDefinitionParticipantListEnumerator;
begin
  result := TFhirActivityDefinitionParticipantListEnumerator.Create(self.link);
end;

function TFhirActivityDefinitionParticipantList.Clone: TFhirActivityDefinitionParticipantList;
begin
  result := TFhirActivityDefinitionParticipantList(inherited Clone);
end;

function TFhirActivityDefinitionParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirActivityDefinitionParticipantList.GetItemN(index: Integer): TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirActivityDefinitionParticipant;
end;
function TFhirActivityDefinitionParticipantList.IndexOf(value: TFhirActivityDefinitionParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirActivityDefinitionParticipantList.Insert(index: Integer): TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionParticipantList.InsertItem(index: Integer; value: TFhirActivityDefinitionParticipant);
begin
  assert(value is TFhirActivityDefinitionParticipant);
  Inherited Insert(index, value);
end;

function TFhirActivityDefinitionParticipantList.Item(index: Integer): TFhirActivityDefinitionParticipant;
begin
  result := TFhirActivityDefinitionParticipant(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionParticipantList.Link: TFhirActivityDefinitionParticipantList;
begin
  result := TFhirActivityDefinitionParticipantList(inherited Link);
end;

procedure TFhirActivityDefinitionParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirActivityDefinitionParticipantList.SetItemByIndex(index: Integer; value: TFhirActivityDefinitionParticipant);
begin
  assert(value is TFhirActivityDefinitionParticipant);
  FhirActivityDefinitionParticipants[index] := value;
end;

procedure TFhirActivityDefinitionParticipantList.SetItemN(index: Integer; value: TFhirActivityDefinitionParticipant);
begin
  assert(value is TFhirActivityDefinitionParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirActivityDefinitionDynamicValue }

constructor TFhirActivityDefinitionDynamicValue.Create;
begin
  inherited;
end;

destructor TFhirActivityDefinitionDynamicValue.Destroy;
begin
  FPath.free;
  FExpression.free;
  inherited;
end;

procedure TFhirActivityDefinitionDynamicValue.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirActivityDefinitionDynamicValue(oSource).pathElement.Clone;
  expression := TFhirActivityDefinitionDynamicValue(oSource).expression.Clone;
end;

procedure TFhirActivityDefinitionDynamicValue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirActivityDefinitionDynamicValue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirActivityDefinitionDynamicValue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirActivityDefinitionDynamicValue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirActivityDefinitionDynamicValue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create()
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirActivityDefinitionDynamicValue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirActivityDefinitionDynamicValue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirActivityDefinitionDynamicValue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirActivityDefinitionDynamicValue.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirActivityDefinitionDynamicValue.fhirType : string;
begin
  result := 'ActivityDefinition.dynamicValue';
end;

function TFhirActivityDefinitionDynamicValue.Link : TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(inherited Link);
end;

function TFhirActivityDefinitionDynamicValue.Clone : TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(inherited Clone);
end;

function TFhirActivityDefinitionDynamicValue.equals(other : TObject) : boolean; 
var
  o : TFhirActivityDefinitionDynamicValue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirActivityDefinitionDynamicValue)) then
    result := false
  else
  begin
    o := TFhirActivityDefinitionDynamicValue(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirActivityDefinitionDynamicValue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FExpression);
end;

procedure TFhirActivityDefinitionDynamicValue.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('path');
  fields.add('expression');
end;

function TFhirActivityDefinitionDynamicValue.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirActivityDefinitionDynamicValue.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

function TFhirActivityDefinitionDynamicValue.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

procedure TFhirActivityDefinitionDynamicValue.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

procedure TFhirActivityDefinitionDynamicValue.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirActivityDefinitionDynamicValueListEnumerator }

constructor TFhirActivityDefinitionDynamicValueListEnumerator.Create(list : TFhirActivityDefinitionDynamicValueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirActivityDefinitionDynamicValueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirActivityDefinitionDynamicValueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirActivityDefinitionDynamicValueListEnumerator.GetCurrent : TFhirActivityDefinitionDynamicValue;
begin
  Result := FList[FIndex];
end;

function TFhirActivityDefinitionDynamicValueListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirActivityDefinitionDynamicValueList }

function TFhirActivityDefinitionDynamicValueList.AddItem(value: TFhirActivityDefinitionDynamicValue): TFhirActivityDefinitionDynamicValue;
begin
  assert(value.ClassName = 'TFhirActivityDefinitionDynamicValue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirActivityDefinitionDynamicValue');
  add(value);
  result := value;
end;

function TFhirActivityDefinitionDynamicValueList.Append: TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionDynamicValueList.ClearItems;
begin
  Clear;
end;

function TFhirActivityDefinitionDynamicValueList.GetEnumerator : TFhirActivityDefinitionDynamicValueListEnumerator;
begin
  result := TFhirActivityDefinitionDynamicValueListEnumerator.Create(self.link);
end;

function TFhirActivityDefinitionDynamicValueList.Clone: TFhirActivityDefinitionDynamicValueList;
begin
  result := TFhirActivityDefinitionDynamicValueList(inherited Clone);
end;

function TFhirActivityDefinitionDynamicValueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirActivityDefinitionDynamicValueList.GetItemN(index: Integer): TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionDynamicValueList.ItemClass: TFslObjectClass;
begin
  result := TFhirActivityDefinitionDynamicValue;
end;
function TFhirActivityDefinitionDynamicValueList.IndexOf(value: TFhirActivityDefinitionDynamicValue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirActivityDefinitionDynamicValueList.Insert(index: Integer): TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionDynamicValueList.InsertItem(index: Integer; value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value is TFhirActivityDefinitionDynamicValue);
  Inherited Insert(index, value);
end;

function TFhirActivityDefinitionDynamicValueList.Item(index: Integer): TFhirActivityDefinitionDynamicValue;
begin
  result := TFhirActivityDefinitionDynamicValue(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionDynamicValueList.Link: TFhirActivityDefinitionDynamicValueList;
begin
  result := TFhirActivityDefinitionDynamicValueList(inherited Link);
end;

procedure TFhirActivityDefinitionDynamicValueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirActivityDefinitionDynamicValueList.SetItemByIndex(index: Integer; value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value is TFhirActivityDefinitionDynamicValue);
  FhirActivityDefinitionDynamicValues[index] := value;
end;

procedure TFhirActivityDefinitionDynamicValueList.SetItemN(index: Integer; value: TFhirActivityDefinitionDynamicValue);
begin
  assert(value is TFhirActivityDefinitionDynamicValue);
  ObjectByIndex[index] := value;
end;

{ TFhirActivityDefinition }

constructor TFhirActivityDefinition.Create;
begin
  inherited;
end;

destructor TFhirActivityDefinition.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FSubtitle.free;
  FStatus.free;
  FExperimental.free;
  FSubject.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FUsage.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FKind.free;
  FProfile.free;
  FCode.free;
  FIntent.free;
  FPriority.free;
  FDoNotPerform.free;
  FTiming.free;
  FLocation.free;
  FParticipantList.Free;
  FProduct.free;
  FQuantity.free;
  FDosageList.Free;
  FBodySiteList.Free;
  FSpecimenRequirementList.Free;
  FObservationRequirementList.Free;
  FObservationResultRequirementList.Free;
  FTransform.free;
  FDynamicValueList.Free;
  inherited;
end;

procedure TFhirActivityDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirActivityDefinition(oSource).urlElement.Clone;
  if (TFhirActivityDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirActivityDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirActivityDefinition(oSource).versionElement.Clone;
  nameElement := TFhirActivityDefinition(oSource).nameElement.Clone;
  titleElement := TFhirActivityDefinition(oSource).titleElement.Clone;
  subtitleElement := TFhirActivityDefinition(oSource).subtitleElement.Clone;
  statusElement := TFhirActivityDefinition(oSource).statusElement.Clone;
  experimentalElement := TFhirActivityDefinition(oSource).experimentalElement.Clone;
  subject := TFhirActivityDefinition(oSource).subject.Clone;
  dateElement := TFhirActivityDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirActivityDefinition(oSource).publisherElement.Clone;
  if (TFhirActivityDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirActivityDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirActivityDefinition(oSource).descriptionElement.Clone;
  if (TFhirActivityDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirActivityDefinition(oSource).FUseContextList);
  end;
  if (TFhirActivityDefinition(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirActivityDefinition(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirActivityDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirActivityDefinition(oSource).usageElement.Clone;
  copyrightElement := TFhirActivityDefinition(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirActivityDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirActivityDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirActivityDefinition(oSource).effectivePeriod.Clone;
  if (TFhirActivityDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirActivityDefinition(oSource).FTopicList);
  end;
  if (TFhirActivityDefinition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirActivityDefinition(oSource).FAuthorList);
  end;
  if (TFhirActivityDefinition(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirActivityDefinition(oSource).FEditorList);
  end;
  if (TFhirActivityDefinition(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirActivityDefinition(oSource).FReviewerList);
  end;
  if (TFhirActivityDefinition(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirActivityDefinition(oSource).FEndorserList);
  end;
  if (TFhirActivityDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirActivityDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirActivityDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirCanonicalList.Create;
    FLibrary_List.Assign(TFhirActivityDefinition(oSource).FLibrary_List);
  end;
  kindElement := TFhirActivityDefinition(oSource).kindElement.Clone;
  profileElement := TFhirActivityDefinition(oSource).profileElement.Clone;
  code := TFhirActivityDefinition(oSource).code.Clone;
  intentElement := TFhirActivityDefinition(oSource).intentElement.Clone;
  priorityElement := TFhirActivityDefinition(oSource).priorityElement.Clone;
  doNotPerformElement := TFhirActivityDefinition(oSource).doNotPerformElement.Clone;
  timing := TFhirActivityDefinition(oSource).timing.Clone;
  location := TFhirActivityDefinition(oSource).location.Clone;
  if (TFhirActivityDefinition(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirActivityDefinitionParticipantList.Create;
    FParticipantList.Assign(TFhirActivityDefinition(oSource).FParticipantList);
  end;
  product := TFhirActivityDefinition(oSource).product.Clone;
  quantity := TFhirActivityDefinition(oSource).quantity.Clone;
  if (TFhirActivityDefinition(oSource).FDosageList = nil) then
  begin
    FDosageList.free;
    FDosageList := nil;
  end
  else
  begin
    if FDosageList = nil then
      FDosageList := TFhirDosageList.Create;
    FDosageList.Assign(TFhirActivityDefinition(oSource).FDosageList);
  end;
  if (TFhirActivityDefinition(oSource).FBodySiteList = nil) then
  begin
    FBodySiteList.free;
    FBodySiteList := nil;
  end
  else
  begin
    if FBodySiteList = nil then
      FBodySiteList := TFhirCodeableConceptList.Create;
    FBodySiteList.Assign(TFhirActivityDefinition(oSource).FBodySiteList);
  end;
  if (TFhirActivityDefinition(oSource).FSpecimenRequirementList = nil) then
  begin
    FSpecimenRequirementList.free;
    FSpecimenRequirementList := nil;
  end
  else
  begin
    if FSpecimenRequirementList = nil then
      FSpecimenRequirementList := TFhirReferenceList.Create;
    FSpecimenRequirementList.Assign(TFhirActivityDefinition(oSource).FSpecimenRequirementList);
  end;
  if (TFhirActivityDefinition(oSource).FObservationRequirementList = nil) then
  begin
    FObservationRequirementList.free;
    FObservationRequirementList := nil;
  end
  else
  begin
    if FObservationRequirementList = nil then
      FObservationRequirementList := TFhirReferenceList.Create;
    FObservationRequirementList.Assign(TFhirActivityDefinition(oSource).FObservationRequirementList);
  end;
  if (TFhirActivityDefinition(oSource).FObservationResultRequirementList = nil) then
  begin
    FObservationResultRequirementList.free;
    FObservationResultRequirementList := nil;
  end
  else
  begin
    if FObservationResultRequirementList = nil then
      FObservationResultRequirementList := TFhirReferenceList.Create;
    FObservationResultRequirementList.Assign(TFhirActivityDefinition(oSource).FObservationResultRequirementList);
  end;
  transformElement := TFhirActivityDefinition(oSource).transformElement.Clone;
  if (TFhirActivityDefinition(oSource).FDynamicValueList = nil) then
  begin
    FDynamicValueList.free;
    FDynamicValueList := nil;
  end
  else
  begin
    if FDynamicValueList = nil then
      FDynamicValueList := TFhirActivityDefinitionDynamicValueList.Create;
    FDynamicValueList.Assign(TFhirActivityDefinition(oSource).FDynamicValueList);
  end;
end;

function TFhirActivityDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtActivityDefinition;
end;

procedure TFhirActivityDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'profile') Then
     list.add(self.link, 'profile', FProfile.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'product[x]') or (child_name = 'product') Then
     list.add(self.link, 'product[x]', FProduct.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'dosage') Then
    list.addAll(self, 'dosage', FDosageList);
  if (child_name = 'bodySite') Then
    list.addAll(self, 'bodySite', FBodySiteList);
  if (child_name = 'specimenRequirement') Then
    list.addAll(self, 'specimenRequirement', FSpecimenRequirementList);
  if (child_name = 'observationRequirement') Then
    list.addAll(self, 'observationRequirement', FObservationRequirementList);
  if (child_name = 'observationResultRequirement') Then
    list.addAll(self, 'observationResultRequirement', FObservationResultRequirementList);
  if (child_name = 'transform') Then
     list.add(self.link, 'transform', FTransform.Link);
  if (child_name = 'dynamicValue') Then
    list.addAll(self, 'dynamicValue', FDynamicValueList);
end;

procedure TFhirActivityDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference|canonical', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'library', 'canonical', true, TFhirCanonical, FLibrary_List.Link));
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'profile', 'canonical', false, TFhirCanonical, FProfile.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'Timing|dateTime|Age|Period|Range|Duration', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirActivityDefinitionParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'product[x]', 'Reference|CodeableConcept', false, TFhirDataType, FProduct.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'dosage', 'Dosage', true, TFhirDosage, FDosageList.Link));
  oList.add(TFHIRProperty.create(self, 'bodySite', 'CodeableConcept', true, TFhirCodeableConcept, FBodySiteList.Link));
  oList.add(TFHIRProperty.create(self, 'specimenRequirement', 'Reference', true, TFhirReference, FSpecimenRequirementList.Link));
  oList.add(TFHIRProperty.create(self, 'observationRequirement', 'Reference', true, TFhirReference, FObservationRequirementList.Link));
  oList.add(TFHIRProperty.create(self, 'observationResultRequirement', 'Reference', true, TFhirReference, FObservationResultRequirementList.Link));
  oList.add(TFHIRProperty.create(self, 'transform', 'canonical', false, TFhirCanonical, FTransform.Link));
  oList.add(TFHIRProperty.create(self, 'dynamicValue', 'BackboneElement', true, TFhirActivityDefinitionDynamicValue, FDynamicValueList.Link));
end;

function TFhirActivityDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirRequestResourceTypeEnum, CODES_TFhirRequestResourceTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'profile') then
  begin
    ProfileElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['Timing', 'DateTime', 'Age', 'Period', 'Range', 'Duration'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirActivityDefinitionParticipant);
    result := propValue;
  end
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then
  begin
    Product := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'dosage') then
  begin
    DosageList.add(propValue as TFhirDosage);
    result := propValue;
  end
  else if (propName = 'bodySite') then
  begin
    BodySiteList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'specimenRequirement') then
  begin
    SpecimenRequirementList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'observationRequirement') then
  begin
    ObservationRequirementList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'observationResultRequirement') then
  begin
    ObservationResultRequirementList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'transform') then
  begin
    TransformElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'dynamicValue') then
  begin
    DynamicValueList.add(propValue as TFhirActivityDefinitionDynamicValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirActivityDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'library') then Library_List.insertItem(index, asCanonical(propValue))
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirActivityDefinitionParticipant)
  else if (propName = 'dosage') then DosageList.insertItem(index, propValue as TFhirDosage)
  else if (propName = 'bodySite') then BodySiteList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'specimenRequirement') then SpecimenRequirementList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'observationRequirement') then ObservationRequirementList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'observationResultRequirement') then ObservationResultRequirementList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'dynamicValue') then DynamicValueList.insertItem(index, propValue as TFhirActivityDefinitionDynamicValue)
  else inherited;
end;

function TFhirActivityDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'topic') then result := TopicList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'library') then result := Library_List.new()
  else if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirRequestResourceTypeEnum[RequestResourceTypeNull], CODES_TFhirRequestResourceTypeEnum[RequestResourceTypeNull]) 
  else if (propName = 'profile') then result := TFhirCanonical.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull]) 
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'doNotPerform') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'timing', ['Timing', 'DateTime', 'Age', 'Period', 'Range', 'Duration'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Product')
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'dosage') then result := DosageList.new()
  else if (propName = 'bodySite') then result := BodySiteList.new()
  else if (propName = 'specimenRequirement') then result := SpecimenRequirementList.new()
  else if (propName = 'observationRequirement') then result := ObservationRequirementList.new()
  else if (propName = 'observationResultRequirement') then result := ObservationResultRequirementList.new()
  else if (propName = 'transform') then result := TFhirCanonical.create()
  else if (propName = 'dynamicValue') then result := DynamicValueList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirActivityDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference|canonical'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'canonical'
  else if (propName = 'kind') then result := 'code'
  else if (propName = 'profile') then result := 'canonical'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'timing[x]') then result := 'Timing|dateTime|Age|Period|Range|Duration'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'product[x]') then result := 'Reference|CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'dosage') then result := 'Dosage'
  else if (propName = 'bodySite') then result := 'CodeableConcept'
  else if (propName = 'specimenRequirement') then result := 'Reference'
  else if (propName = 'observationRequirement') then result := 'Reference'
  else if (propName = 'observationResultRequirement') then result := 'Reference'
  else if (propName = 'transform') then result := 'canonical'
  else if (propName = 'dynamicValue') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirActivityDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value)
  else if (propName = 'kind') then KindElement := nil
  else if (propName = 'profile') then ProfileElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (isMatchingName(propName, 'timing', ['Timing', 'DateTime', 'Age', 'Period', 'Range', 'Duration'])) then TimingElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'dosage') then deletePropertyValue('dosage', DosageList, value)
  else if (propName = 'bodySite') then deletePropertyValue('bodySite', BodySiteList, value)
  else if (propName = 'specimenRequirement') then deletePropertyValue('specimenRequirement', SpecimenRequirementList, value)
  else if (propName = 'observationRequirement') then deletePropertyValue('observationRequirement', ObservationRequirementList, value)
  else if (propName = 'observationResultRequirement') then deletePropertyValue('observationResultRequirement', ObservationResultRequirementList, value)
  else if (propName = 'transform') then TransformElement := nil
  else if (propName = 'dynamicValue') then deletePropertyValue('dynamicValue', DynamicValueList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirActivityDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new)
  else if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirRequestResourceTypeEnum, CODES_TFhirRequestResourceTypeEnum, new)
  else if (propName = 'profile') then ProfileElement := asCanonical(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new)
  else if (isMatchingName(propName, 'timing', ['Timing', 'DateTime', 'Age', 'Period', 'Range', 'Duration'])) then TimingElement := new as TFhirDataType
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (isMatchingName(propName, 'product', ['Reference', 'CodeableConcept'])) then ProductElement := new as TFhirDataType
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'dosage') then replacePropertyValue('dosage', DosageList, existing, new)
  else if (propName = 'bodySite') then replacePropertyValue('bodySite', BodySiteList, existing, new)
  else if (propName = 'specimenRequirement') then replacePropertyValue('specimenRequirement', SpecimenRequirementList, existing, new)
  else if (propName = 'observationRequirement') then replacePropertyValue('observationRequirement', ObservationRequirementList, existing, new)
  else if (propName = 'observationResultRequirement') then replacePropertyValue('observationResultRequirement', ObservationResultRequirementList, existing, new)
  else if (propName = 'transform') then TransformElement := asCanonical(new)
  else if (propName = 'dynamicValue') then replacePropertyValue('dynamicValue', DynamicValueList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirActivityDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'topic') then TopicList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'library') then Library_List.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'dosage') then DosageList.move(source, destination)
  else if (propName = 'bodySite') then BodySiteList.move(source, destination)
  else if (propName = 'specimenRequirement') then SpecimenRequirementList.move(source, destination)
  else if (propName = 'observationRequirement') then ObservationRequirementList.move(source, destination)
  else if (propName = 'observationResultRequirement') then ObservationResultRequirementList.move(source, destination)
  else if (propName = 'dynamicValue') then DynamicValueList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirActivityDefinition.fhirType : string;
begin
  result := 'ActivityDefinition';
end;

function TFhirActivityDefinition.Link : TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(inherited Link);
end;

function TFhirActivityDefinition.Clone : TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(inherited Clone);
end;

function TFhirActivityDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirActivityDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirActivityDefinition)) then
    result := false
  else
  begin
    o := TFhirActivityDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(subtitleElement, o.subtitleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(experimentalElement, o.experimentalElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(usageElement, o.usageElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and 
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(topicList, o.topicList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(library_List, o.library_List, true) and 
      compareDeep(kindElement, o.kindElement, true) and compareDeep(profileElement, o.profileElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(doNotPerformElement, o.doNotPerformElement, true) and 
      compareDeep(timingElement, o.timingElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(productElement, o.productElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(dosageList, o.dosageList, true) and 
      compareDeep(bodySiteList, o.bodySiteList, true) and compareDeep(specimenRequirementList, o.specimenRequirementList, true) and 
      compareDeep(observationRequirementList, o.observationRequirementList, true) and 
      compareDeep(observationResultRequirementList, o.observationResultRequirementList, true) and 
      compareDeep(transformElement, o.transformElement, true) and compareDeep(dynamicValueList, o.dynamicValueList, true);
  end;
end;

function TFhirActivityDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FKind) and isEmptyProp(FProfile) and isEmptyProp(FCode) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FDoNotPerform)
       and isEmptyProp(FTiming) and isEmptyProp(FLocation) and isEmptyProp(FparticipantList) and isEmptyProp(FProduct) and isEmptyProp(FQuantity) and isEmptyProp(FdosageList) and isEmptyProp(FbodySiteList) and isEmptyProp(FspecimenRequirementList) and isEmptyProp(FobservationRequirementList) and isEmptyProp(FobservationResultRequirementList) and isEmptyProp(FTransform) and isEmptyProp(FdynamicValueList);
end;

procedure TFhirActivityDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('kind');
  fields.add('profile');
  fields.add('code');
  fields.add('intent');
  fields.add('priority');
  fields.add('doNotPerform');
  fields.add('timing[x]');
  fields.add('location');
  fields.add('participant');
  fields.add('product[x]');
  fields.add('quantity');
  fields.add('dosage');
  fields.add('bodySite');
  fields.add('specimenRequirement');
  fields.add('observationRequirement');
  fields.add('observationResultRequirement');
  fields.add('transform');
  fields.add('dynamicValue');
end;

function TFhirActivityDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FTopicList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FLibrary_List.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FDosageList.sizeInBytes(magic));
  inc(result, FBodySiteList.sizeInBytes(magic));
  inc(result, FSpecimenRequirementList.sizeInBytes(magic));
  inc(result, FObservationRequirementList.sizeInBytes(magic));
  inc(result, FObservationResultRequirementList.sizeInBytes(magic));
  inc(result, FDynamicValueList.sizeInBytes(magic));
end;

procedure TFhirActivityDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirActivityDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirActivityDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirActivityDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirActivityDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirActivityDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirActivityDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirActivityDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirActivityDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirActivityDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirActivityDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirActivityDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirActivityDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirActivityDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirActivityDefinition.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirActivityDefinition.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirActivityDefinition.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirActivityDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirActivityDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirActivityDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirActivityDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirActivityDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirActivityDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirActivityDefinition.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirActivityDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirActivityDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirActivityDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirActivityDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirActivityDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirActivityDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirActivityDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirActivityDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirActivityDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirActivityDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirActivityDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirActivityDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirActivityDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirActivityDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirActivityDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirActivityDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirActivityDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirActivityDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirActivityDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirActivityDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirActivityDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

procedure TFhirActivityDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirActivityDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirActivityDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirActivityDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirActivityDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirActivityDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirActivityDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirActivityDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirActivityDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirActivityDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirActivityDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

function TFhirActivityDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

function TFhirActivityDefinition.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirActivityDefinition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirActivityDefinition.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirActivityDefinition.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirActivityDefinition.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirActivityDefinition.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirActivityDefinition.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirActivityDefinition.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirActivityDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirActivityDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirActivityDefinition.GetLibrary_List : TFhirCanonicalList;
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirCanonicalList.Create;
  result := FLibrary_List;
end;

function TFhirActivityDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

procedure TFhirActivityDefinition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirActivityDefinition.GetKindST : TFhirRequestResourceTypeEnum;
begin
  if FKind = nil then
    result := TFhirRequestResourceTypeEnum(0)
  else
    result := TFhirRequestResourceTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestResourceTypeEnum, FKind.value));
end;

procedure TFhirActivityDefinition.SetKindST(value : TFhirRequestResourceTypeEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirRequestResourceTypeEnum[value], CODES_TFhirRequestResourceTypeEnum[value]);
end;

procedure TFhirActivityDefinition.SetProfile(value : TFhirCanonical);
begin
  FProfile.free;
  FProfile := value;
end;

function TFhirActivityDefinition.GetProfileST : String;
begin
  if FProfile = nil then
    result := ''
  else
    result := FProfile.value;
end;

procedure TFhirActivityDefinition.SetProfileST(value : String);
begin
  if value <> '' then
  begin
    if FProfile = nil then
      FProfile := TFhirCanonical.create;
    FProfile.value := value
  end
  else if FProfile <> nil then
    FProfile.value := '';
end;

procedure TFhirActivityDefinition.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirActivityDefinition.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirActivityDefinition.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirActivityDefinition.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

procedure TFhirActivityDefinition.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirActivityDefinition.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirActivityDefinition.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirActivityDefinition.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

function TFhirActivityDefinition.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirActivityDefinition.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirActivityDefinition.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

procedure TFhirActivityDefinition.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirActivityDefinition.GetParticipantList : TFhirActivityDefinitionParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirActivityDefinitionParticipantList.Create;
  result := FParticipantList;
end;

function TFhirActivityDefinition.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirActivityDefinition.SetProduct(value : TFhirDataType);
begin
  FProduct.free;
  FProduct := value;
end;

procedure TFhirActivityDefinition.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

function TFhirActivityDefinition.GetDosageList : TFhirDosageList;
begin
  if FDosageList = nil then
    FDosageList := TFhirDosageList.Create;
  result := FDosageList;
end;

function TFhirActivityDefinition.GetHasDosageList : boolean;
begin
  result := (FDosageList <> nil) and (FDosageList.count > 0);
end;

function TFhirActivityDefinition.GetBodySiteList : TFhirCodeableConceptList;
begin
  if FBodySiteList = nil then
    FBodySiteList := TFhirCodeableConceptList.Create;
  result := FBodySiteList;
end;

function TFhirActivityDefinition.GetHasBodySiteList : boolean;
begin
  result := (FBodySiteList <> nil) and (FBodySiteList.count > 0);
end;

function TFhirActivityDefinition.GetSpecimenRequirementList : TFhirReferenceList;
begin
  if FSpecimenRequirementList = nil then
    FSpecimenRequirementList := TFhirReferenceList.Create;
  result := FSpecimenRequirementList;
end;

function TFhirActivityDefinition.GetHasSpecimenRequirementList : boolean;
begin
  result := (FSpecimenRequirementList <> nil) and (FSpecimenRequirementList.count > 0);
end;

function TFhirActivityDefinition.GetObservationRequirementList : TFhirReferenceList;
begin
  if FObservationRequirementList = nil then
    FObservationRequirementList := TFhirReferenceList.Create;
  result := FObservationRequirementList;
end;

function TFhirActivityDefinition.GetHasObservationRequirementList : boolean;
begin
  result := (FObservationRequirementList <> nil) and (FObservationRequirementList.count > 0);
end;

function TFhirActivityDefinition.GetObservationResultRequirementList : TFhirReferenceList;
begin
  if FObservationResultRequirementList = nil then
    FObservationResultRequirementList := TFhirReferenceList.Create;
  result := FObservationResultRequirementList;
end;

function TFhirActivityDefinition.GetHasObservationResultRequirementList : boolean;
begin
  result := (FObservationResultRequirementList <> nil) and (FObservationResultRequirementList.count > 0);
end;

procedure TFhirActivityDefinition.SetTransform(value : TFhirCanonical);
begin
  FTransform.free;
  FTransform := value;
end;

function TFhirActivityDefinition.GetTransformST : String;
begin
  if FTransform = nil then
    result := ''
  else
    result := FTransform.value;
end;

procedure TFhirActivityDefinition.SetTransformST(value : String);
begin
  if value <> '' then
  begin
    if FTransform = nil then
      FTransform := TFhirCanonical.create;
    FTransform.value := value
  end
  else if FTransform <> nil then
    FTransform.value := '';
end;

function TFhirActivityDefinition.GetDynamicValueList : TFhirActivityDefinitionDynamicValueList;
begin
  if FDynamicValueList = nil then
    FDynamicValueList := TFhirActivityDefinitionDynamicValueList.Create;
  result := FDynamicValueList;
end;

function TFhirActivityDefinition.GetHasDynamicValueList : boolean;
begin
  result := (FDynamicValueList <> nil) and (FDynamicValueList.count > 0);
end;

{ TFhirActivityDefinitionListEnumerator }

constructor TFhirActivityDefinitionListEnumerator.Create(list : TFhirActivityDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirActivityDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirActivityDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirActivityDefinitionListEnumerator.GetCurrent : TFhirActivityDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirActivityDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirActivityDefinitionList }

function TFhirActivityDefinitionList.AddItem(value: TFhirActivityDefinition): TFhirActivityDefinition;
begin
  assert(value.ClassName = 'TFhirActivityDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirActivityDefinition');
  add(value);
  result := value;
end;

function TFhirActivityDefinitionList.Append: TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirActivityDefinitionList.GetEnumerator : TFhirActivityDefinitionListEnumerator;
begin
  result := TFhirActivityDefinitionListEnumerator.Create(self.link);
end;

function TFhirActivityDefinitionList.Clone: TFhirActivityDefinitionList;
begin
  result := TFhirActivityDefinitionList(inherited Clone);
end;

function TFhirActivityDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirActivityDefinitionList.GetItemN(index: Integer): TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirActivityDefinition;
end;
function TFhirActivityDefinitionList.IndexOf(value: TFhirActivityDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirActivityDefinitionList.Insert(index: Integer): TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirActivityDefinitionList.InsertItem(index: Integer; value: TFhirActivityDefinition);
begin
  assert(value is TFhirActivityDefinition);
  Inherited Insert(index, value);
end;

function TFhirActivityDefinitionList.Item(index: Integer): TFhirActivityDefinition;
begin
  result := TFhirActivityDefinition(ObjectByIndex[index]);
end;

function TFhirActivityDefinitionList.Link: TFhirActivityDefinitionList;
begin
  result := TFhirActivityDefinitionList(inherited Link);
end;

procedure TFhirActivityDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirActivityDefinitionList.SetItemByIndex(index: Integer; value: TFhirActivityDefinition);
begin
  assert(value is TFhirActivityDefinition);
  FhirActivityDefinitions[index] := value;
end;

procedure TFhirActivityDefinitionList.SetItemN(index: Integer; value: TFhirActivityDefinition);
begin
  assert(value is TFhirActivityDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_ACTIVITYDEFINITION}
{$IFDEF FHIR_AUDITEVENT}
{ TFhirAuditEventAgent }

constructor TFhirAuditEventAgent.Create;
begin
  inherited;
end;

destructor TFhirAuditEventAgent.Destroy;
begin
  FType_.free;
  FRoleList.Free;
  FWho.free;
  FAltId.free;
  FName.free;
  FRequestor.free;
  FLocation.free;
  FPolicyList.Free;
  FMedia.free;
  FNetwork.free;
  FPurposeOfUseList.Free;
  inherited;
end;

procedure TFhirAuditEventAgent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAuditEventAgent(oSource).type_.Clone;
  if (TFhirAuditEventAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirAuditEventAgent(oSource).FRoleList);
  end;
  who := TFhirAuditEventAgent(oSource).who.Clone;
  altIdElement := TFhirAuditEventAgent(oSource).altIdElement.Clone;
  nameElement := TFhirAuditEventAgent(oSource).nameElement.Clone;
  requestorElement := TFhirAuditEventAgent(oSource).requestorElement.Clone;
  location := TFhirAuditEventAgent(oSource).location.Clone;
  if (TFhirAuditEventAgent(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirAuditEventAgent(oSource).FPolicyList);
  end;
  media := TFhirAuditEventAgent(oSource).media.Clone;
  network := TFhirAuditEventAgent(oSource).network.Clone;
  if (TFhirAuditEventAgent(oSource).FPurposeOfUseList = nil) then
  begin
    FPurposeOfUseList.free;
    FPurposeOfUseList := nil;
  end
  else
  begin
    if FPurposeOfUseList = nil then
      FPurposeOfUseList := TFhirCodeableConceptList.Create;
    FPurposeOfUseList.Assign(TFhirAuditEventAgent(oSource).FPurposeOfUseList);
  end;
end;

procedure TFhirAuditEventAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'altId') Then
     list.add(self.link, 'altId', FAltId.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'requestor') Then
     list.add(self.link, 'requestor', FRequestor.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'media') Then
     list.add(self.link, 'media', FMedia.Link);
  if (child_name = 'network') Then
     list.add(self.link, 'network', FNetwork.Link);
  if (child_name = 'purposeOfUse') Then
    list.addAll(self, 'purposeOfUse', FPurposeOfUseList);
end;

procedure TFhirAuditEventAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link));
  oList.add(TFHIRProperty.create(self, 'who', 'Reference', false, TFhirReference, FWho.Link));
  oList.add(TFHIRProperty.create(self, 'altId', 'string', false, TFhirString, FAltId.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'requestor', 'boolean', false, TFhirBoolean, FRequestor.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link));
  oList.add(TFHIRProperty.create(self, 'media', 'Coding', false, TFhirCoding, FMedia.Link));
  oList.add(TFHIRProperty.create(self, 'network', 'BackboneElement', false, TFhirAuditEventAgentNetwork, FNetwork.Link));
  oList.add(TFHIRProperty.create(self, 'purposeOfUse', 'CodeableConcept', true, TFhirCodeableConcept, FPurposeOfUseList.Link));
end;

function TFhirAuditEventAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'who') then
  begin
    Who := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'altId') then
  begin
    AltIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'requestor') then
  begin
    RequestorElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'media') then
  begin
    Media := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'network') then
  begin
    Network := propValue as TFhirAuditEventAgentNetwork;
    result := propValue;
  end
  else if (propName = 'purposeOfUse') then
  begin
    PurposeOfUseList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue))
  else if (propName = 'purposeOfUse') then PurposeOfUseList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirAuditEventAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'role') then result := RoleList.new()
  else if (propName = 'who') then result := TFhirReference.create()
  else if (propName = 'altId') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'requestor') then result := TFhirBoolean.create()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'policy') then result := PolicyList.new()
  else if (propName = 'media') then result := TFhirCoding.create()
  else if (propName = 'network') then result := TFhirAuditEventAgentNetwork.create()
  else if (propName = 'purposeOfUse') then result := PurposeOfUseList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'who') then result := 'Reference'
  else if (propName = 'altId') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'requestor') then result := 'boolean'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'media') then result := 'Coding'
  else if (propName = 'network') then result := 'BackboneElement'
  else if (propName = 'purposeOfUse') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value)
  else if (propName = 'who') then WhoElement := nil
  else if (propName = 'altId') then AltIdElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'requestor') then RequestorElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value)
  else if (propName = 'media') then MediaElement := nil
  else if (propName = 'network') then NetworkElement := nil
  else if (propName = 'purposeOfUse') then deletePropertyValue('purposeOfUse', PurposeOfUseList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new)
  else if (propName = 'who') then WhoElement := new as TFhirReference
  else if (propName = 'altId') then AltIdElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'requestor') then RequestorElement := asBoolean(new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new)
  else if (propName = 'media') then MediaElement := new as TFhirCoding
  else if (propName = 'network') then NetworkElement := new as TFhirAuditEventAgentNetwork
  else if (propName = 'purposeOfUse') then replacePropertyValue('purposeOfUse', PurposeOfUseList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination)
  else if (propName = 'policy') then PolicyList.move(source, destination)
  else if (propName = 'purposeOfUse') then PurposeOfUseList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventAgent.fhirType : string;
begin
  result := 'AuditEvent.agent';
end;

function TFhirAuditEventAgent.Link : TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(inherited Link);
end;

function TFhirAuditEventAgent.Clone : TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(inherited Clone);
end;

function TFhirAuditEventAgent.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventAgent)) then
    result := false
  else
  begin
    o := TFhirAuditEventAgent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleList, o.roleList, true) and 
      compareDeep(whoElement, o.whoElement, true) and compareDeep(altIdElement, o.altIdElement, true) and 
      compareDeep(nameElement, o.nameElement, true) and compareDeep(requestorElement, o.requestorElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(policyList, o.policyList, true) and 
      compareDeep(mediaElement, o.mediaElement, true) and compareDeep(networkElement, o.networkElement, true) and 
      compareDeep(purposeOfUseList, o.purposeOfUseList, true);
  end;
end;

function TFhirAuditEventAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FroleList) and isEmptyProp(FWho) and isEmptyProp(FAltId) and isEmptyProp(FName) and isEmptyProp(FRequestor) and isEmptyProp(FLocation) and isEmptyProp(FpolicyList) and isEmptyProp(FMedia) and isEmptyProp(FNetwork) and isEmptyProp(FpurposeOfUseList);
end;

procedure TFhirAuditEventAgent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
  fields.add('who');
  fields.add('altId');
  fields.add('name');
  fields.add('requestor');
  fields.add('location');
  fields.add('policy');
  fields.add('media');
  fields.add('network');
  fields.add('purposeOfUse');
end;

function TFhirAuditEventAgent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRoleList.sizeInBytes(magic));
  inc(result, FPolicyList.sizeInBytes(magic));
  inc(result, FPurposeOfUseList.sizeInBytes(magic));
end;

procedure TFhirAuditEventAgent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirAuditEventAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

function TFhirAuditEventAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

procedure TFhirAuditEventAgent.SetWho(value : TFhirReference);
begin
  FWho.free;
  FWho := value;
end;

procedure TFhirAuditEventAgent.SetAltId(value : TFhirString);
begin
  FAltId.free;
  FAltId := value;
end;

function TFhirAuditEventAgent.GetAltIdST : String;
begin
  if FAltId = nil then
    result := ''
  else
    result := FAltId.value;
end;

procedure TFhirAuditEventAgent.SetAltIdST(value : String);
begin
  if value <> '' then
  begin
    if FAltId = nil then
      FAltId := TFhirString.create;
    FAltId.value := value
  end
  else if FAltId <> nil then
    FAltId.value := '';
end;

procedure TFhirAuditEventAgent.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirAuditEventAgent.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirAuditEventAgent.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirAuditEventAgent.SetRequestor(value : TFhirBoolean);
begin
  FRequestor.free;
  FRequestor := value;
end;

function TFhirAuditEventAgent.GetRequestorST : Boolean;
begin
  if FRequestor = nil then
    result := false
  else
    result := FRequestor.value;
end;

procedure TFhirAuditEventAgent.SetRequestorST(value : Boolean);
begin
  if FRequestor = nil then
    FRequestor := TFhirBoolean.create;
  FRequestor.value := value
end;

procedure TFhirAuditEventAgent.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirAuditEventAgent.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

function TFhirAuditEventAgent.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

procedure TFhirAuditEventAgent.SetMedia(value : TFhirCoding);
begin
  FMedia.free;
  FMedia := value;
end;

procedure TFhirAuditEventAgent.SetNetwork(value : TFhirAuditEventAgentNetwork);
begin
  FNetwork.free;
  FNetwork := value;
end;

function TFhirAuditEventAgent.GetPurposeOfUseList : TFhirCodeableConceptList;
begin
  if FPurposeOfUseList = nil then
    FPurposeOfUseList := TFhirCodeableConceptList.Create;
  result := FPurposeOfUseList;
end;

function TFhirAuditEventAgent.GetHasPurposeOfUseList : boolean;
begin
  result := (FPurposeOfUseList <> nil) and (FPurposeOfUseList.count > 0);
end;

{ TFhirAuditEventAgentListEnumerator }

constructor TFhirAuditEventAgentListEnumerator.Create(list : TFhirAuditEventAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventAgentListEnumerator.GetCurrent : TFhirAuditEventAgent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventAgentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventAgentList }

function TFhirAuditEventAgentList.AddItem(value: TFhirAuditEventAgent): TFhirAuditEventAgent;
begin
  assert(value.ClassName = 'TFhirAuditEventAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventAgent');
  add(value);
  result := value;
end;

function TFhirAuditEventAgentList.Append: TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventAgentList.GetEnumerator : TFhirAuditEventAgentListEnumerator;
begin
  result := TFhirAuditEventAgentListEnumerator.Create(self.link);
end;

function TFhirAuditEventAgentList.Clone: TFhirAuditEventAgentList;
begin
  result := TFhirAuditEventAgentList(inherited Clone);
end;

function TFhirAuditEventAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventAgentList.GetItemN(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventAgent;
end;
function TFhirAuditEventAgentList.IndexOf(value: TFhirAuditEventAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventAgentList.Insert(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentList.InsertItem(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventAgentList.Item(index: Integer): TFhirAuditEventAgent;
begin
  result := TFhirAuditEventAgent(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentList.Link: TFhirAuditEventAgentList;
begin
  result := TFhirAuditEventAgentList(inherited Link);
end;

procedure TFhirAuditEventAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventAgentList.SetItemByIndex(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  FhirAuditEventAgents[index] := value;
end;

procedure TFhirAuditEventAgentList.SetItemN(index: Integer; value: TFhirAuditEventAgent);
begin
  assert(value is TFhirAuditEventAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventAgentNetwork }

constructor TFhirAuditEventAgentNetwork.Create;
begin
  inherited;
end;

destructor TFhirAuditEventAgentNetwork.Destroy;
begin
  FAddress.free;
  FType_.free;
  inherited;
end;

procedure TFhirAuditEventAgentNetwork.Assign(oSource : TFslObject);
begin
  inherited;
  addressElement := TFhirAuditEventAgentNetwork(oSource).addressElement.Clone;
  type_Element := TFhirAuditEventAgentNetwork(oSource).type_Element.Clone;
end;

procedure TFhirAuditEventAgentNetwork.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'address') Then
     list.add(self.link, 'address', FAddress.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirAuditEventAgentNetwork.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'address', 'string', false, TFhirString, FAddress.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
end;

function TFhirAuditEventAgentNetwork.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'address') then
  begin
    AddressElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirAuditEventAgentNetworkTypeEnum, CODES_TFhirAuditEventAgentNetworkTypeEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventAgentNetwork.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAuditEventAgentNetwork.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'address') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirAuditEventAgentNetworkTypeEnum[AuditEventAgentNetworkTypeNull], CODES_TFhirAuditEventAgentNetworkTypeEnum[AuditEventAgentNetworkTypeNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventAgentNetwork.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'address') then result := 'string'
  else if (propName = 'type') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventAgentNetwork.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'address') then AddressElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventAgentNetwork.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'address') then AddressElement := asString(new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirAuditEventAgentNetworkTypeEnum, CODES_TFhirAuditEventAgentNetworkTypeEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventAgentNetwork.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventAgentNetwork.fhirType : string;
begin
  result := 'AuditEvent.agent.network';
end;

function TFhirAuditEventAgentNetwork.Link : TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(inherited Link);
end;

function TFhirAuditEventAgentNetwork.Clone : TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(inherited Clone);
end;

function TFhirAuditEventAgentNetwork.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventAgentNetwork;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventAgentNetwork)) then
    result := false
  else
  begin
    o := TFhirAuditEventAgentNetwork(other);
    result := compareDeep(addressElement, o.addressElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirAuditEventAgentNetwork.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAddress) and isEmptyProp(FType_);
end;

procedure TFhirAuditEventAgentNetwork.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('address');
  fields.add('type');
end;

function TFhirAuditEventAgentNetwork.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAuditEventAgentNetwork.SetAddress(value : TFhirString);
begin
  FAddress.free;
  FAddress := value;
end;

function TFhirAuditEventAgentNetwork.GetAddressST : String;
begin
  if FAddress = nil then
    result := ''
  else
    result := FAddress.value;
end;

procedure TFhirAuditEventAgentNetwork.SetAddressST(value : String);
begin
  if value <> '' then
  begin
    if FAddress = nil then
      FAddress := TFhirString.create;
    FAddress.value := value
  end
  else if FAddress <> nil then
    FAddress.value := '';
end;

procedure TFhirAuditEventAgentNetwork.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirAuditEventAgentNetwork.GetType_ST : TFhirAuditEventAgentNetworkTypeEnum;
begin
  if FType_ = nil then
    result := TFhirAuditEventAgentNetworkTypeEnum(0)
  else
    result := TFhirAuditEventAgentNetworkTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventAgentNetworkTypeEnum, FType_.value));
end;

procedure TFhirAuditEventAgentNetwork.SetType_ST(value : TFhirAuditEventAgentNetworkTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirAuditEventAgentNetworkTypeEnum[value], CODES_TFhirAuditEventAgentNetworkTypeEnum[value]);
end;

{ TFhirAuditEventAgentNetworkListEnumerator }

constructor TFhirAuditEventAgentNetworkListEnumerator.Create(list : TFhirAuditEventAgentNetworkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventAgentNetworkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventAgentNetworkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventAgentNetworkListEnumerator.GetCurrent : TFhirAuditEventAgentNetwork;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventAgentNetworkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventAgentNetworkList }

function TFhirAuditEventAgentNetworkList.AddItem(value: TFhirAuditEventAgentNetwork): TFhirAuditEventAgentNetwork;
begin
  assert(value.ClassName = 'TFhirAuditEventAgentNetwork', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventAgentNetwork');
  add(value);
  result := value;
end;

function TFhirAuditEventAgentNetworkList.Append: TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentNetworkList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventAgentNetworkList.GetEnumerator : TFhirAuditEventAgentNetworkListEnumerator;
begin
  result := TFhirAuditEventAgentNetworkListEnumerator.Create(self.link);
end;

function TFhirAuditEventAgentNetworkList.Clone: TFhirAuditEventAgentNetworkList;
begin
  result := TFhirAuditEventAgentNetworkList(inherited Clone);
end;

function TFhirAuditEventAgentNetworkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventAgentNetworkList.GetItemN(index: Integer): TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentNetworkList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventAgentNetwork;
end;
function TFhirAuditEventAgentNetworkList.IndexOf(value: TFhirAuditEventAgentNetwork): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventAgentNetworkList.Insert(index: Integer): TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventAgentNetworkList.InsertItem(index: Integer; value: TFhirAuditEventAgentNetwork);
begin
  assert(value is TFhirAuditEventAgentNetwork);
  Inherited Insert(index, value);
end;

function TFhirAuditEventAgentNetworkList.Item(index: Integer): TFhirAuditEventAgentNetwork;
begin
  result := TFhirAuditEventAgentNetwork(ObjectByIndex[index]);
end;

function TFhirAuditEventAgentNetworkList.Link: TFhirAuditEventAgentNetworkList;
begin
  result := TFhirAuditEventAgentNetworkList(inherited Link);
end;

procedure TFhirAuditEventAgentNetworkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventAgentNetworkList.SetItemByIndex(index: Integer; value: TFhirAuditEventAgentNetwork);
begin
  assert(value is TFhirAuditEventAgentNetwork);
  FhirAuditEventAgentNetworks[index] := value;
end;

procedure TFhirAuditEventAgentNetworkList.SetItemN(index: Integer; value: TFhirAuditEventAgentNetwork);
begin
  assert(value is TFhirAuditEventAgentNetwork);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventSource }

constructor TFhirAuditEventSource.Create;
begin
  inherited;
end;

destructor TFhirAuditEventSource.Destroy;
begin
  FSite.free;
  FObserver.free;
  FType_List.Free;
  inherited;
end;

procedure TFhirAuditEventSource.Assign(oSource : TFslObject);
begin
  inherited;
  siteElement := TFhirAuditEventSource(oSource).siteElement.Clone;
  observer := TFhirAuditEventSource(oSource).observer.Clone;
  if (TFhirAuditEventSource(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodingList.Create;
    FType_List.Assign(TFhirAuditEventSource(oSource).FType_List);
  end;
end;

procedure TFhirAuditEventSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'site') Then
     list.add(self.link, 'site', FSite.Link);
  if (child_name = 'observer') Then
     list.add(self.link, 'observer', FObserver.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
end;

procedure TFhirAuditEventSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'site', 'string', false, TFhirString, FSite.Link));
  oList.add(TFHIRProperty.create(self, 'observer', 'Reference', false, TFhirReference, FObserver.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', true, TFhirCoding, FType_List.Link));
end;

function TFhirAuditEventSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'site') then
  begin
    SiteElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'observer') then
  begin
    Observer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCoding);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCoding)
  else inherited;
end;

function TFhirAuditEventSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'site') then result := TFhirString.create()
  else if (propName = 'observer') then result := TFhirReference.create()
  else if (propName = 'type') then result := Type_List.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'site') then result := 'string'
  else if (propName = 'observer') then result := 'Reference'
  else if (propName = 'type') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := nil
  else if (propName = 'observer') then ObserverElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'site') then SiteElement := asString(new)
  else if (propName = 'observer') then ObserverElement := new as TFhirReference
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventSource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventSource.fhirType : string;
begin
  result := 'AuditEvent.source';
end;

function TFhirAuditEventSource.Link : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Link);
end;

function TFhirAuditEventSource.Clone : TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(inherited Clone);
end;

function TFhirAuditEventSource.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventSource)) then
    result := false
  else
  begin
    o := TFhirAuditEventSource(other);
    result := compareDeep(siteElement, o.siteElement, true) and compareDeep(observerElement, o.observerElement, true) and 
      compareDeep(type_List, o.type_List, true);
  end;
end;

function TFhirAuditEventSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSite) and isEmptyProp(FObserver) and isEmptyProp(Ftype_List);
end;

procedure TFhirAuditEventSource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('site');
  fields.add('observer');
  fields.add('type');
end;

function TFhirAuditEventSource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
end;

procedure TFhirAuditEventSource.SetSite(value : TFhirString);
begin
  FSite.free;
  FSite := value;
end;

function TFhirAuditEventSource.GetSiteST : String;
begin
  if FSite = nil then
    result := ''
  else
    result := FSite.value;
end;

procedure TFhirAuditEventSource.SetSiteST(value : String);
begin
  if value <> '' then
  begin
    if FSite = nil then
      FSite := TFhirString.create;
    FSite.value := value
  end
  else if FSite <> nil then
    FSite.value := '';
end;

procedure TFhirAuditEventSource.SetObserver(value : TFhirReference);
begin
  FObserver.free;
  FObserver := value;
end;

function TFhirAuditEventSource.GetType_List : TFhirCodingList;
begin
  if FType_List = nil then
    FType_List := TFhirCodingList.Create;
  result := FType_List;
end;

function TFhirAuditEventSource.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

{ TFhirAuditEventSourceListEnumerator }

constructor TFhirAuditEventSourceListEnumerator.Create(list : TFhirAuditEventSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventSourceListEnumerator.GetCurrent : TFhirAuditEventSource;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventSourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventSourceList }

function TFhirAuditEventSourceList.AddItem(value: TFhirAuditEventSource): TFhirAuditEventSource;
begin
  assert(value.ClassName = 'TFhirAuditEventSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventSource');
  add(value);
  result := value;
end;

function TFhirAuditEventSourceList.Append: TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventSourceList.GetEnumerator : TFhirAuditEventSourceListEnumerator;
begin
  result := TFhirAuditEventSourceListEnumerator.Create(self.link);
end;

function TFhirAuditEventSourceList.Clone: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Clone);
end;

function TFhirAuditEventSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventSourceList.GetItemN(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventSource;
end;
function TFhirAuditEventSourceList.IndexOf(value: TFhirAuditEventSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventSourceList.Insert(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventSourceList.InsertItem(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  Inherited Insert(index, value);
end;

function TFhirAuditEventSourceList.Item(index: Integer): TFhirAuditEventSource;
begin
  result := TFhirAuditEventSource(ObjectByIndex[index]);
end;

function TFhirAuditEventSourceList.Link: TFhirAuditEventSourceList;
begin
  result := TFhirAuditEventSourceList(inherited Link);
end;

procedure TFhirAuditEventSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventSourceList.SetItemByIndex(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  FhirAuditEventSources[index] := value;
end;

procedure TFhirAuditEventSourceList.SetItemN(index: Integer; value: TFhirAuditEventSource);
begin
  assert(value is TFhirAuditEventSource);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventEntity }

constructor TFhirAuditEventEntity.Create;
begin
  inherited;
end;

destructor TFhirAuditEventEntity.Destroy;
begin
  FWhat.free;
  FType_.free;
  FRole.free;
  FLifecycle.free;
  FSecurityLabelList.Free;
  FName.free;
  FDescription.free;
  FQuery.free;
  FDetailList.Free;
  inherited;
end;

procedure TFhirAuditEventEntity.Assign(oSource : TFslObject);
begin
  inherited;
  what := TFhirAuditEventEntity(oSource).what.Clone;
  type_ := TFhirAuditEventEntity(oSource).type_.Clone;
  role := TFhirAuditEventEntity(oSource).role.Clone;
  lifecycle := TFhirAuditEventEntity(oSource).lifecycle.Clone;
  if (TFhirAuditEventEntity(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirAuditEventEntity(oSource).FSecurityLabelList);
  end;
  nameElement := TFhirAuditEventEntity(oSource).nameElement.Clone;
  descriptionElement := TFhirAuditEventEntity(oSource).descriptionElement.Clone;
  queryElement := TFhirAuditEventEntity(oSource).queryElement.Clone;
  if (TFhirAuditEventEntity(oSource).FDetailList = nil) then
  begin
    FDetailList.free;
    FDetailList := nil;
  end
  else
  begin
    if FDetailList = nil then
      FDetailList := TFhirAuditEventEntityDetailList.Create;
    FDetailList.Assign(TFhirAuditEventEntity(oSource).FDetailList);
  end;
end;

procedure TFhirAuditEventEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'what') Then
     list.add(self.link, 'what', FWhat.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'lifecycle') Then
     list.add(self.link, 'lifecycle', FLifecycle.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'query') Then
     list.add(self.link, 'query', FQuery.Link);
  if (child_name = 'detail') Then
    list.addAll(self, 'detail', FDetailList);
end;

procedure TFhirAuditEventEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'what', 'Reference', false, TFhirReference, FWhat.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'Coding', false, TFhirCoding, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'lifecycle', 'Coding', false, TFhirCoding, FLifecycle.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'query', 'base64Binary', false, TFhirBase64Binary, FQuery.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'BackboneElement', true, TFhirAuditEventEntityDetail, FDetailList.Link));
end;

function TFhirAuditEventEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'what') then
  begin
    What := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'lifecycle') then
  begin
    Lifecycle := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'query') then
  begin
    QueryElement := asBase64Binary(propValue);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailList.add(propValue as TFhirAuditEventEntityDetail);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'detail') then DetailList.insertItem(index, propValue as TFhirAuditEventEntityDetail)
  else inherited;
end;

function TFhirAuditEventEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'what') then result := TFhirReference.create()
  else if (propName = 'type') then result := TFhirCoding.create()
  else if (propName = 'role') then result := TFhirCoding.create()
  else if (propName = 'lifecycle') then result := TFhirCoding.create()
  else if (propName = 'securityLabel') then result := SecurityLabelList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'query') then result := TFhirBase64Binary.create()
  else if (propName = 'detail') then result := DetailList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'what') then result := 'Reference'
  else if (propName = 'type') then result := 'Coding'
  else if (propName = 'role') then result := 'Coding'
  else if (propName = 'lifecycle') then result := 'Coding'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'query') then result := 'base64Binary'
  else if (propName = 'detail') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'what') then WhatElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then RoleElement := nil
  else if (propName = 'lifecycle') then LifecycleElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'query') then QueryElement := nil
  else if (propName = 'detail') then deletePropertyValue('detail', DetailList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'what') then WhatElement := new as TFhirReference
  else if (propName = 'type') then Type_Element := new as TFhirCoding
  else if (propName = 'role') then RoleElement := new as TFhirCoding
  else if (propName = 'lifecycle') then LifecycleElement := new as TFhirCoding
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'query') then QueryElement := asBase64Binary(new)
  else if (propName = 'detail') then replacePropertyValue('detail', DetailList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventEntity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.move(source, destination)
  else if (propName = 'detail') then DetailList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventEntity.fhirType : string;
begin
  result := 'AuditEvent.entity';
end;

function TFhirAuditEventEntity.Link : TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(inherited Link);
end;

function TFhirAuditEventEntity.Clone : TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(inherited Clone);
end;

function TFhirAuditEventEntity.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventEntity)) then
    result := false
  else
  begin
    o := TFhirAuditEventEntity(other);
    result := compareDeep(whatElement, o.whatElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(roleElement, o.roleElement, true) and compareDeep(lifecycleElement, o.lifecycleElement, true) and 
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(queryElement, o.queryElement, true) and 
      compareDeep(detailList, o.detailList, true);
  end;
end;

function TFhirAuditEventEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWhat) and isEmptyProp(FType_) and isEmptyProp(FRole) and isEmptyProp(FLifecycle) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FQuery) and isEmptyProp(FdetailList);
end;

procedure TFhirAuditEventEntity.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('what');
  fields.add('type');
  fields.add('role');
  fields.add('lifecycle');
  fields.add('securityLabel');
  fields.add('name');
  fields.add('description');
  fields.add('query');
  fields.add('detail');
end;

function TFhirAuditEventEntity.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSecurityLabelList.sizeInBytes(magic));
  inc(result, FDetailList.sizeInBytes(magic));
end;

procedure TFhirAuditEventEntity.SetWhat(value : TFhirReference);
begin
  FWhat.free;
  FWhat := value;
end;

procedure TFhirAuditEventEntity.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirAuditEventEntity.SetRole(value : TFhirCoding);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirAuditEventEntity.SetLifecycle(value : TFhirCoding);
begin
  FLifecycle.free;
  FLifecycle := value;
end;

function TFhirAuditEventEntity.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

function TFhirAuditEventEntity.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

procedure TFhirAuditEventEntity.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirAuditEventEntity.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirAuditEventEntity.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirAuditEventEntity.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirAuditEventEntity.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirAuditEventEntity.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirAuditEventEntity.SetQuery(value : TFhirBase64Binary);
begin
  FQuery.free;
  FQuery := value;
end;

function TFhirAuditEventEntity.GetQueryST : TBytes;
begin
  if FQuery = nil then
    result := nil
  else
    result := FQuery.value;
end;

procedure TFhirAuditEventEntity.SetQueryST(value : TBytes);
begin
  if value <> nil then
  begin
    if FQuery = nil then
      FQuery := TFhirBase64Binary.create;
    FQuery.value := value
  end
  else if FQuery <> nil then
    FQuery.value := nil;
end;

function TFhirAuditEventEntity.GetDetailList : TFhirAuditEventEntityDetailList;
begin
  if FDetailList = nil then
    FDetailList := TFhirAuditEventEntityDetailList.Create;
  result := FDetailList;
end;

function TFhirAuditEventEntity.GetHasDetailList : boolean;
begin
  result := (FDetailList <> nil) and (FDetailList.count > 0);
end;

{ TFhirAuditEventEntityListEnumerator }

constructor TFhirAuditEventEntityListEnumerator.Create(list : TFhirAuditEventEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventEntityListEnumerator.GetCurrent : TFhirAuditEventEntity;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventEntityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventEntityList }

function TFhirAuditEventEntityList.AddItem(value: TFhirAuditEventEntity): TFhirAuditEventEntity;
begin
  assert(value.ClassName = 'TFhirAuditEventEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventEntity');
  add(value);
  result := value;
end;

function TFhirAuditEventEntityList.Append: TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventEntityList.GetEnumerator : TFhirAuditEventEntityListEnumerator;
begin
  result := TFhirAuditEventEntityListEnumerator.Create(self.link);
end;

function TFhirAuditEventEntityList.Clone: TFhirAuditEventEntityList;
begin
  result := TFhirAuditEventEntityList(inherited Clone);
end;

function TFhirAuditEventEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventEntityList.GetItemN(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventEntity;
end;
function TFhirAuditEventEntityList.IndexOf(value: TFhirAuditEventEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventEntityList.Insert(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityList.InsertItem(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  Inherited Insert(index, value);
end;

function TFhirAuditEventEntityList.Item(index: Integer): TFhirAuditEventEntity;
begin
  result := TFhirAuditEventEntity(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityList.Link: TFhirAuditEventEntityList;
begin
  result := TFhirAuditEventEntityList(inherited Link);
end;

procedure TFhirAuditEventEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventEntityList.SetItemByIndex(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  FhirAuditEventEntities[index] := value;
end;

procedure TFhirAuditEventEntityList.SetItemN(index: Integer; value: TFhirAuditEventEntity);
begin
  assert(value is TFhirAuditEventEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEventEntityDetail }

constructor TFhirAuditEventEntityDetail.Create;
begin
  inherited;
end;

destructor TFhirAuditEventEntityDetail.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirAuditEventEntityDetail.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirAuditEventEntityDetail(oSource).type_Element.Clone;
  value := TFhirAuditEventEntityDetail(oSource).value.Clone;
end;

procedure TFhirAuditEventEntityDetail.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirAuditEventEntityDetail.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'string', false, TFhirString, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'string|base64Binary', false, TFhirDataType, FValue.Link));
end;

function TFhirAuditEventEntityDetail.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['String', 'Base64Binary'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEventEntityDetail.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirAuditEventEntityDetail.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirString.create()
  else if (isMatchingName(propName, 'value', ['String', 'Base64Binary'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEventEntityDetail.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'string'
  else if (propName = 'value[x]') then result := 'string|base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEventEntityDetail.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['String', 'Base64Binary'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEventEntityDetail.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asString(new)
  else if (isMatchingName(propName, 'value', ['String', 'Base64Binary'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEventEntityDetail.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEventEntityDetail.fhirType : string;
begin
  result := 'AuditEvent.entity.detail';
end;

function TFhirAuditEventEntityDetail.Link : TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(inherited Link);
end;

function TFhirAuditEventEntityDetail.Clone : TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(inherited Clone);
end;

function TFhirAuditEventEntityDetail.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEventEntityDetail;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEventEntityDetail)) then
    result := false
  else
  begin
    o := TFhirAuditEventEntityDetail(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirAuditEventEntityDetail.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirAuditEventEntityDetail.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirAuditEventEntityDetail.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirAuditEventEntityDetail.SetType_(value : TFhirString);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirAuditEventEntityDetail.GetType_ST : String;
begin
  if FType_ = nil then
    result := ''
  else
    result := FType_.value;
end;

procedure TFhirAuditEventEntityDetail.SetType_ST(value : String);
begin
  if value <> '' then
  begin
    if FType_ = nil then
      FType_ := TFhirString.create;
    FType_.value := value
  end
  else if FType_ <> nil then
    FType_.value := '';
end;

procedure TFhirAuditEventEntityDetail.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirAuditEventEntityDetailListEnumerator }

constructor TFhirAuditEventEntityDetailListEnumerator.Create(list : TFhirAuditEventEntityDetailList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventEntityDetailListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventEntityDetailListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventEntityDetailListEnumerator.GetCurrent : TFhirAuditEventEntityDetail;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventEntityDetailListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventEntityDetailList }

function TFhirAuditEventEntityDetailList.AddItem(value: TFhirAuditEventEntityDetail): TFhirAuditEventEntityDetail;
begin
  assert(value.ClassName = 'TFhirAuditEventEntityDetail', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEventEntityDetail');
  add(value);
  result := value;
end;

function TFhirAuditEventEntityDetailList.Append: TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityDetailList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventEntityDetailList.GetEnumerator : TFhirAuditEventEntityDetailListEnumerator;
begin
  result := TFhirAuditEventEntityDetailListEnumerator.Create(self.link);
end;

function TFhirAuditEventEntityDetailList.Clone: TFhirAuditEventEntityDetailList;
begin
  result := TFhirAuditEventEntityDetailList(inherited Clone);
end;

function TFhirAuditEventEntityDetailList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventEntityDetailList.GetItemN(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityDetailList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEventEntityDetail;
end;
function TFhirAuditEventEntityDetailList.IndexOf(value: TFhirAuditEventEntityDetail): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventEntityDetailList.Insert(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventEntityDetailList.InsertItem(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  Inherited Insert(index, value);
end;

function TFhirAuditEventEntityDetailList.Item(index: Integer): TFhirAuditEventEntityDetail;
begin
  result := TFhirAuditEventEntityDetail(ObjectByIndex[index]);
end;

function TFhirAuditEventEntityDetailList.Link: TFhirAuditEventEntityDetailList;
begin
  result := TFhirAuditEventEntityDetailList(inherited Link);
end;

procedure TFhirAuditEventEntityDetailList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventEntityDetailList.SetItemByIndex(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  FhirAuditEventEntityDetails[index] := value;
end;

procedure TFhirAuditEventEntityDetailList.SetItemN(index: Integer; value: TFhirAuditEventEntityDetail);
begin
  assert(value is TFhirAuditEventEntityDetail);
  ObjectByIndex[index] := value;
end;

{ TFhirAuditEvent }

constructor TFhirAuditEvent.Create;
begin
  inherited;
end;

destructor TFhirAuditEvent.Destroy;
begin
  FType_.free;
  FSubtypeList.Free;
  FAction.free;
  FPeriod.free;
  FRecorded.free;
  FOutcome.free;
  FOutcomeDesc.free;
  FPurposeOfEventList.Free;
  FAgentList.Free;
  FSource.free;
  FEntityList.Free;
  inherited;
end;

procedure TFhirAuditEvent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirAuditEvent(oSource).type_.Clone;
  if (TFhirAuditEvent(oSource).FSubtypeList = nil) then
  begin
    FSubtypeList.free;
    FSubtypeList := nil;
  end
  else
  begin
    if FSubtypeList = nil then
      FSubtypeList := TFhirCodingList.Create;
    FSubtypeList.Assign(TFhirAuditEvent(oSource).FSubtypeList);
  end;
  actionElement := TFhirAuditEvent(oSource).actionElement.Clone;
  period := TFhirAuditEvent(oSource).period.Clone;
  recordedElement := TFhirAuditEvent(oSource).recordedElement.Clone;
  outcomeElement := TFhirAuditEvent(oSource).outcomeElement.Clone;
  outcomeDescElement := TFhirAuditEvent(oSource).outcomeDescElement.Clone;
  if (TFhirAuditEvent(oSource).FPurposeOfEventList = nil) then
  begin
    FPurposeOfEventList.free;
    FPurposeOfEventList := nil;
  end
  else
  begin
    if FPurposeOfEventList = nil then
      FPurposeOfEventList := TFhirCodeableConceptList.Create;
    FPurposeOfEventList.Assign(TFhirAuditEvent(oSource).FPurposeOfEventList);
  end;
  if (TFhirAuditEvent(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirAuditEventAgentList.Create;
    FAgentList.Assign(TFhirAuditEvent(oSource).FAgentList);
  end;
  source := TFhirAuditEvent(oSource).source.Clone;
  if (TFhirAuditEvent(oSource).FEntityList = nil) then
  begin
    FEntityList.free;
    FEntityList := nil;
  end
  else
  begin
    if FEntityList = nil then
      FEntityList := TFhirAuditEventEntityList.Create;
    FEntityList.Assign(TFhirAuditEvent(oSource).FEntityList);
  end;
end;

function TFhirAuditEvent.GetResourceType : TFhirResourceType;
begin
  result := frtAuditEvent;
end;

procedure TFhirAuditEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subtype') Then
    list.addAll(self, 'subtype', FSubtypeList);
  if (child_name = 'action') Then
     list.add(self.link, 'action', FAction.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
  if (child_name = 'outcomeDesc') Then
     list.add(self.link, 'outcomeDesc', FOutcomeDesc.Link);
  if (child_name = 'purposeOfEvent') Then
    list.addAll(self, 'purposeOfEvent', FPurposeOfEventList);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'entity') Then
    list.addAll(self, 'entity', FEntityList);
end;

procedure TFhirAuditEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subtype', 'Coding', true, TFhirCoding, FSubtypeList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'code', false, TFhirEnum, FAction.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'recorded', 'instant', false, TFhirInstant, FRecorded.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'code', false, TFhirEnum, FOutcome.Link));
  oList.add(TFHIRProperty.create(self, 'outcomeDesc', 'string', false, TFhirString, FOutcomeDesc.Link));
  oList.add(TFHIRProperty.create(self, 'purposeOfEvent', 'CodeableConcept', true, TFhirCodeableConcept, FPurposeOfEventList.Link));
  oList.add(TFHIRProperty.create(self, 'agent', 'BackboneElement', true, TFhirAuditEventAgent, FAgentList.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'BackboneElement', false, TFhirAuditEventSource, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'entity', 'BackboneElement', true, TFhirAuditEventEntity, FEntityList.Link));
end;

function TFhirAuditEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'subtype') then
  begin
    SubtypeList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    OutcomeElement := asEnum(SYSTEMS_TFhirAuditEventOutcomeEnum, CODES_TFhirAuditEventOutcomeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'outcomeDesc') then
  begin
    OutcomeDescElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'purposeOfEvent') then
  begin
    PurposeOfEventList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirAuditEventAgent);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirAuditEventSource;
    result := propValue;
  end
  else if (propName = 'entity') then
  begin
    EntityList.add(propValue as TFhirAuditEventEntity);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirAuditEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subtype') then SubtypeList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'purposeOfEvent') then PurposeOfEventList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirAuditEventAgent)
  else if (propName = 'entity') then EntityList.insertItem(index, propValue as TFhirAuditEventEntity)
  else inherited;
end;

function TFhirAuditEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create()
  else if (propName = 'subtype') then result := SubtypeList.new()
  else if (propName = 'action') then result := TFhirEnum.create(SYSTEMS_TFhirAuditEventActionEnum[AuditEventActionNull], CODES_TFhirAuditEventActionEnum[AuditEventActionNull]) 
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'recorded') then result := TFhirInstant.create()
  else if (propName = 'outcome') then result := TFhirEnum.create(SYSTEMS_TFhirAuditEventOutcomeEnum[AuditEventOutcomeNull], CODES_TFhirAuditEventOutcomeEnum[AuditEventOutcomeNull]) 
  else if (propName = 'outcomeDesc') then result := TFhirString.create()
  else if (propName = 'purposeOfEvent') then result := PurposeOfEventList.new()
  else if (propName = 'agent') then result := AgentList.new()
  else if (propName = 'source') then result := TFhirAuditEventSource.create()
  else if (propName = 'entity') then result := EntityList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirAuditEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'subtype') then result := 'Coding'
  else if (propName = 'action') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'recorded') then result := 'instant'
  else if (propName = 'outcome') then result := 'code'
  else if (propName = 'outcomeDesc') then result := 'string'
  else if (propName = 'purposeOfEvent') then result := 'CodeableConcept'
  else if (propName = 'agent') then result := 'BackboneElement'
  else if (propName = 'source') then result := 'BackboneElement'
  else if (propName = 'entity') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirAuditEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'subtype') then deletePropertyValue('subtype', SubtypeList, value)
  else if (propName = 'action') then ActionElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else if (propName = 'outcomeDesc') then OutcomeDescElement := nil
  else if (propName = 'purposeOfEvent') then deletePropertyValue('purposeOfEvent', PurposeOfEventList, value)
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value)
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'entity') then deletePropertyValue('entity', EntityList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirAuditEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding
  else if (propName = 'subtype') then replacePropertyValue('subtype', SubtypeList, existing, new)
  else if (propName = 'action') then ActionElement := asEnum(SYSTEMS_TFhirAuditEventActionEnum, CODES_TFhirAuditEventActionEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'recorded') then RecordedElement := asInstant(new)
  else if (propName = 'outcome') then OutcomeElement := asEnum(SYSTEMS_TFhirAuditEventOutcomeEnum, CODES_TFhirAuditEventOutcomeEnum, new)
  else if (propName = 'outcomeDesc') then OutcomeDescElement := asString(new)
  else if (propName = 'purposeOfEvent') then replacePropertyValue('purposeOfEvent', PurposeOfEventList, existing, new)
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new)
  else if (propName = 'source') then SourceElement := new as TFhirAuditEventSource
  else if (propName = 'entity') then replacePropertyValue('entity', EntityList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirAuditEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subtype') then SubtypeList.move(source, destination)
  else if (propName = 'purposeOfEvent') then PurposeOfEventList.move(source, destination)
  else if (propName = 'agent') then AgentList.move(source, destination)
  else if (propName = 'entity') then EntityList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirAuditEvent.fhirType : string;
begin
  result := 'AuditEvent';
end;

function TFhirAuditEvent.Link : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Link);
end;

function TFhirAuditEvent.Clone : TFhirAuditEvent;
begin
  result := TFhirAuditEvent(inherited Clone);
end;

function TFhirAuditEvent.equals(other : TObject) : boolean; 
var
  o : TFhirAuditEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirAuditEvent)) then
    result := false
  else
  begin
    o := TFhirAuditEvent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(subtypeList, o.subtypeList, true) and 
      compareDeep(actionElement, o.actionElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(recordedElement, o.recordedElement, true) and compareDeep(outcomeElement, o.outcomeElement, true) and 
      compareDeep(outcomeDescElement, o.outcomeDescElement, true) and compareDeep(purposeOfEventList, o.purposeOfEventList, true) and 
      compareDeep(agentList, o.agentList, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(entityList, o.entityList, true);
  end;
end;

function TFhirAuditEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FsubtypeList) and isEmptyProp(FAction) and isEmptyProp(FPeriod) and isEmptyProp(FRecorded) and isEmptyProp(FOutcome) and isEmptyProp(FOutcomeDesc) and isEmptyProp(FpurposeOfEventList) and isEmptyProp(FagentList) and isEmptyProp(FSource) and isEmptyProp(FentityList);
end;

procedure TFhirAuditEvent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('subtype');
  fields.add('action');
  fields.add('period');
  fields.add('recorded');
  fields.add('outcome');
  fields.add('outcomeDesc');
  fields.add('purposeOfEvent');
  fields.add('agent');
  fields.add('source');
  fields.add('entity');
end;

function TFhirAuditEvent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSubtypeList.sizeInBytes(magic));
  inc(result, FPurposeOfEventList.sizeInBytes(magic));
  inc(result, FAgentList.sizeInBytes(magic));
  inc(result, FEntityList.sizeInBytes(magic));
end;

procedure TFhirAuditEvent.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirAuditEvent.GetSubtypeList : TFhirCodingList;
begin
  if FSubtypeList = nil then
    FSubtypeList := TFhirCodingList.Create;
  result := FSubtypeList;
end;

function TFhirAuditEvent.GetHasSubtypeList : boolean;
begin
  result := (FSubtypeList <> nil) and (FSubtypeList.count > 0);
end;

procedure TFhirAuditEvent.SetAction(value : TFhirEnum);
begin
  FAction.free;
  FAction := value;
end;

function TFhirAuditEvent.GetActionST : TFhirAuditEventActionEnum;
begin
  if FAction = nil then
    result := TFhirAuditEventActionEnum(0)
  else
    result := TFhirAuditEventActionEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventActionEnum, FAction.value));
end;

procedure TFhirAuditEvent.SetActionST(value : TFhirAuditEventActionEnum);
begin
  if ord(value) = 0 then
    ActionElement := nil
  else
    ActionElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventActionEnum[value], CODES_TFhirAuditEventActionEnum[value]);
end;

procedure TFhirAuditEvent.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirAuditEvent.SetRecorded(value : TFhirInstant);
begin
  FRecorded.free;
  FRecorded := value;
end;

function TFhirAuditEvent.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

procedure TFhirAuditEvent.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirInstant.create;
  FRecorded.value := value
end;

procedure TFhirAuditEvent.SetOutcome(value : TFhirEnum);
begin
  FOutcome.free;
  FOutcome := value;
end;

function TFhirAuditEvent.GetOutcomeST : TFhirAuditEventOutcomeEnum;
begin
  if FOutcome = nil then
    result := TFhirAuditEventOutcomeEnum(0)
  else
    result := TFhirAuditEventOutcomeEnum(StringArrayIndexOfSensitive(CODES_TFhirAuditEventOutcomeEnum, FOutcome.value));
end;

procedure TFhirAuditEvent.SetOutcomeST(value : TFhirAuditEventOutcomeEnum);
begin
  if ord(value) = 0 then
    OutcomeElement := nil
  else
    OutcomeElement := TFhirEnum.create(SYSTEMS_TFhirAuditEventOutcomeEnum[value], CODES_TFhirAuditEventOutcomeEnum[value]);
end;

procedure TFhirAuditEvent.SetOutcomeDesc(value : TFhirString);
begin
  FOutcomeDesc.free;
  FOutcomeDesc := value;
end;

function TFhirAuditEvent.GetOutcomeDescST : String;
begin
  if FOutcomeDesc = nil then
    result := ''
  else
    result := FOutcomeDesc.value;
end;

procedure TFhirAuditEvent.SetOutcomeDescST(value : String);
begin
  if value <> '' then
  begin
    if FOutcomeDesc = nil then
      FOutcomeDesc := TFhirString.create;
    FOutcomeDesc.value := value
  end
  else if FOutcomeDesc <> nil then
    FOutcomeDesc.value := '';
end;

function TFhirAuditEvent.GetPurposeOfEventList : TFhirCodeableConceptList;
begin
  if FPurposeOfEventList = nil then
    FPurposeOfEventList := TFhirCodeableConceptList.Create;
  result := FPurposeOfEventList;
end;

function TFhirAuditEvent.GetHasPurposeOfEventList : boolean;
begin
  result := (FPurposeOfEventList <> nil) and (FPurposeOfEventList.count > 0);
end;

function TFhirAuditEvent.GetAgentList : TFhirAuditEventAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirAuditEventAgentList.Create;
  result := FAgentList;
end;

function TFhirAuditEvent.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

procedure TFhirAuditEvent.SetSource(value : TFhirAuditEventSource);
begin
  FSource.free;
  FSource := value;
end;

function TFhirAuditEvent.GetEntityList : TFhirAuditEventEntityList;
begin
  if FEntityList = nil then
    FEntityList := TFhirAuditEventEntityList.Create;
  result := FEntityList;
end;

function TFhirAuditEvent.GetHasEntityList : boolean;
begin
  result := (FEntityList <> nil) and (FEntityList.count > 0);
end;

{ TFhirAuditEventListEnumerator }

constructor TFhirAuditEventListEnumerator.Create(list : TFhirAuditEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirAuditEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirAuditEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirAuditEventListEnumerator.GetCurrent : TFhirAuditEvent;
begin
  Result := FList[FIndex];
end;

function TFhirAuditEventListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirAuditEventList }

function TFhirAuditEventList.AddItem(value: TFhirAuditEvent): TFhirAuditEvent;
begin
  assert(value.ClassName = 'TFhirAuditEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirAuditEvent');
  add(value);
  result := value;
end;

function TFhirAuditEventList.Append: TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.ClearItems;
begin
  Clear;
end;

function TFhirAuditEventList.GetEnumerator : TFhirAuditEventListEnumerator;
begin
  result := TFhirAuditEventListEnumerator.Create(self.link);
end;

function TFhirAuditEventList.Clone: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Clone);
end;

function TFhirAuditEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirAuditEventList.GetItemN(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirAuditEvent;
end;
function TFhirAuditEventList.IndexOf(value: TFhirAuditEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirAuditEventList.Insert(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirAuditEventList.InsertItem(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  Inherited Insert(index, value);
end;

function TFhirAuditEventList.Item(index: Integer): TFhirAuditEvent;
begin
  result := TFhirAuditEvent(ObjectByIndex[index]);
end;

function TFhirAuditEventList.Link: TFhirAuditEventList;
begin
  result := TFhirAuditEventList(inherited Link);
end;

procedure TFhirAuditEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirAuditEventList.SetItemByIndex(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  FhirAuditEvents[index] := value;
end;

procedure TFhirAuditEventList.SetItemN(index: Integer; value: TFhirAuditEvent);
begin
  assert(value is TFhirAuditEvent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_AUDITEVENT}
{$IFDEF FHIR_BINARY}
{ TFhirBinary }

constructor TFhirBinary.Create;
begin
  inherited;
end;

destructor TFhirBinary.Destroy;
begin
  FContentType.free;
  FSecurityContext.free;
  FData.free;
  inherited;
end;

procedure TFhirBinary.Assign(oSource : TFslObject);
begin
  inherited;
  contentTypeElement := TFhirBinary(oSource).contentTypeElement.Clone;
  securityContext := TFhirBinary(oSource).securityContext.Clone;
  dataElement := TFhirBinary(oSource).dataElement.Clone;
end;

function TFhirBinary.GetResourceType : TFhirResourceType;
begin
  result := frtBinary;
end;

procedure TFhirBinary.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'contentType') Then
     list.add(self.link, 'contentType', FContentType.Link);
  if (child_name = 'securityContext') Then
     list.add(self.link, 'securityContext', FSecurityContext.Link);
  if (child_name = 'data') Then
     list.add(self.link, 'data', FData.Link);
end;

procedure TFhirBinary.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'contentType', 'code', false, TFhirCode, FContentType.Link));
  oList.add(TFHIRProperty.create(self, 'securityContext', 'Reference', false, TFhirReference, FSecurityContext.Link));
  oList.add(TFHIRProperty.create(self, 'data', 'base64Binary', false, TFhirBase64Binary, FData.Link));
end;

function TFhirBinary.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'contentType') then
  begin
    ContentTypeElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'securityContext') then
  begin
    SecurityContext := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataElement := asBase64Binary(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBinary.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBinary.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'contentType') then result := TFhirCode.create()
  else if (propName = 'securityContext') then result := TFhirReference.create()
  else if (propName = 'data') then result := TFhirBase64Binary.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBinary.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'contentType') then result := 'code'
  else if (propName = 'securityContext') then result := 'Reference'
  else if (propName = 'data') then result := 'base64Binary'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBinary.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := nil
  else if (propName = 'securityContext') then SecurityContextElement := nil
  else if (propName = 'data') then DataElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBinary.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'contentType') then ContentTypeElement := asCode(new)
  else if (propName = 'securityContext') then SecurityContextElement := new as TFhirReference
  else if (propName = 'data') then DataElement := asBase64Binary(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBinary.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBinary.fhirType : string;
begin
  result := 'Binary';
end;

function TFhirBinary.Link : TFhirBinary;
begin
  result := TFhirBinary(inherited Link);
end;

function TFhirBinary.Clone : TFhirBinary;
begin
  result := TFhirBinary(inherited Clone);
end;

function TFhirBinary.equals(other : TObject) : boolean; 
var
  o : TFhirBinary;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBinary)) then
    result := false
  else
  begin
    o := TFhirBinary(other);
    result := compareDeep(contentTypeElement, o.contentTypeElement, true) and compareDeep(securityContextElement, o.securityContextElement, true) and 
      compareDeep(dataElement, o.dataElement, true);
  end;
end;

function TFhirBinary.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContentType) and isEmptyProp(FSecurityContext) and isEmptyProp(FData);
end;

procedure TFhirBinary.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('contentType');
  fields.add('securityContext');
  fields.add('data');
end;

function TFhirBinary.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBinary.SetContentType(value : TFhirCode);
begin
  FContentType.free;
  FContentType := value;
end;

function TFhirBinary.GetContentTypeST : String;
begin
  if FContentType = nil then
    result := ''
  else
    result := FContentType.value;
end;

procedure TFhirBinary.SetContentTypeST(value : String);
begin
  if value <> '' then
  begin
    if FContentType = nil then
      FContentType := TFhirCode.create;
    FContentType.value := value
  end
  else if FContentType <> nil then
    FContentType.value := '';
end;

procedure TFhirBinary.SetSecurityContext(value : TFhirReference);
begin
  FSecurityContext.free;
  FSecurityContext := value;
end;

procedure TFhirBinary.SetData(value : TFhirBase64Binary);
begin
  FData.free;
  FData := value;
end;

function TFhirBinary.GetDataST : TBytes;
begin
  if FData = nil then
    result := nil
  else
    result := FData.value;
end;

procedure TFhirBinary.SetDataST(value : TBytes);
begin
  if value <> nil then
  begin
    if FData = nil then
      FData := TFhirBase64Binary.create;
    FData.value := value
  end
  else if FData <> nil then
    FData.value := nil;
end;

{ TFhirBinaryListEnumerator }

constructor TFhirBinaryListEnumerator.Create(list : TFhirBinaryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBinaryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBinaryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBinaryListEnumerator.GetCurrent : TFhirBinary;
begin
  Result := FList[FIndex];
end;

function TFhirBinaryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBinaryList }

function TFhirBinaryList.AddItem(value: TFhirBinary): TFhirBinary;
begin
  assert(value.ClassName = 'TFhirBinary', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBinary');
  add(value);
  result := value;
end;

function TFhirBinaryList.Append: TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.ClearItems;
begin
  Clear;
end;

function TFhirBinaryList.GetEnumerator : TFhirBinaryListEnumerator;
begin
  result := TFhirBinaryListEnumerator.Create(self.link);
end;

function TFhirBinaryList.Clone: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Clone);
end;

function TFhirBinaryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBinaryList.GetItemN(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBinary;
end;
function TFhirBinaryList.IndexOf(value: TFhirBinary): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBinaryList.Insert(index: Integer): TFhirBinary;
begin
  result := TFhirBinary.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBinaryList.InsertItem(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  Inherited Insert(index, value);
end;

function TFhirBinaryList.Item(index: Integer): TFhirBinary;
begin
  result := TFhirBinary(ObjectByIndex[index]);
end;

function TFhirBinaryList.Link: TFhirBinaryList;
begin
  result := TFhirBinaryList(inherited Link);
end;

procedure TFhirBinaryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBinaryList.SetItemByIndex(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  FhirBinaries[index] := value;
end;

procedure TFhirBinaryList.SetItemN(index: Integer; value: TFhirBinary);
begin
  assert(value is TFhirBinary);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BINARY}
{$IFDEF FHIR_BUNDLE}
{ TFhirBundleLink }

constructor TFhirBundleLink.Create;
begin
  inherited;
end;

destructor TFhirBundleLink.Destroy;
begin
  FRelation.free;
  FUrl.free;
  inherited;
end;

procedure TFhirBundleLink.Assign(oSource : TFslObject);
begin
  inherited;
  relationElement := TFhirBundleLink(oSource).relationElement.Clone;
  urlElement := TFhirBundleLink(oSource).urlElement.Clone;
end;

procedure TFhirBundleLink.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'relation') Then
     list.add(self.link, 'relation', FRelation.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
end;

procedure TFhirBundleLink.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'relation', 'string', false, TFhirString, FRelation.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
end;

function TFhirBundleLink.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'relation') then
  begin
    RelationElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleLink.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleLink.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'relation') then result := TFhirString.create()
  else if (propName = 'url') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleLink.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'relation') then result := 'string'
  else if (propName = 'url') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleLink.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := nil
  else if (propName = 'url') then UrlElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleLink.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'relation') then RelationElement := asString(new)
  else if (propName = 'url') then UrlElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleLink.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleLink.fhirType : string;
begin
  result := 'Bundle.link';
end;

function TFhirBundleLink.Link : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Link);
end;

function TFhirBundleLink.Clone : TFhirBundleLink;
begin
  result := TFhirBundleLink(inherited Clone);
end;

function TFhirBundleLink.equals(other : TObject) : boolean; 
var
  o : TFhirBundleLink;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleLink)) then
    result := false
  else
  begin
    o := TFhirBundleLink(other);
    result := compareDeep(relationElement, o.relationElement, true) and compareDeep(urlElement, o.urlElement, true);
  end;
end;

function TFhirBundleLink.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRelation) and isEmptyProp(FUrl);
end;

procedure TFhirBundleLink.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('relation');
  fields.add('url');
end;

function TFhirBundleLink.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBundleLink.SetRelation(value : TFhirString);
begin
  FRelation.free;
  FRelation := value;
end;

function TFhirBundleLink.GetRelationST : String;
begin
  if FRelation = nil then
    result := ''
  else
    result := FRelation.value;
end;

procedure TFhirBundleLink.SetRelationST(value : String);
begin
  if value <> '' then
  begin
    if FRelation = nil then
      FRelation := TFhirString.create;
    FRelation.value := value
  end
  else if FRelation <> nil then
    FRelation.value := '';
end;

procedure TFhirBundleLink.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirBundleLink.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirBundleLink.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

{ TFhirBundleLinkListEnumerator }

constructor TFhirBundleLinkListEnumerator.Create(list : TFhirBundleLinkList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleLinkListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleLinkListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleLinkListEnumerator.GetCurrent : TFhirBundleLink;
begin
  Result := FList[FIndex];
end;

function TFhirBundleLinkListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleLinkList }

function TFhirBundleLinkList.AddItem(value: TFhirBundleLink): TFhirBundleLink;
begin
  assert(value.ClassName = 'TFhirBundleLink', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleLink');
  add(value);
  result := value;
end;

function TFhirBundleLinkList.Append: TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.ClearItems;
begin
  Clear;
end;

function TFhirBundleLinkList.GetEnumerator : TFhirBundleLinkListEnumerator;
begin
  result := TFhirBundleLinkListEnumerator.Create(self.link);
end;

function TFhirBundleLinkList.Clone: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Clone);
end;

function TFhirBundleLinkList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleLinkList.GetItemN(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleLink;
end;
function TFhirBundleLinkList.IndexOf(value: TFhirBundleLink): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleLinkList.Insert(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleLinkList.InsertItem(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  Inherited Insert(index, value);
end;

function TFhirBundleLinkList.Item(index: Integer): TFhirBundleLink;
begin
  result := TFhirBundleLink(ObjectByIndex[index]);
end;

function TFhirBundleLinkList.Link: TFhirBundleLinkList;
begin
  result := TFhirBundleLinkList(inherited Link);
end;

procedure TFhirBundleLinkList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleLinkList.SetItemByIndex(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  FhirBundleLinks[index] := value;
end;

procedure TFhirBundleLinkList.SetItemN(index: Integer; value: TFhirBundleLink);
begin
  assert(value is TFhirBundleLink);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntry }

constructor TFhirBundleEntry.Create;
begin
  inherited;
end;

destructor TFhirBundleEntry.Destroy;
begin
  FLink_List.Free;
  FFullUrl.free;
  FResource.free;
  FSearch.free;
  FRequest.free;
  FResponse.free;
  inherited;
end;

procedure TFhirBundleEntry.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirBundleEntry(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundleEntry(oSource).FLink_List);
  end;
  fullUrlElement := TFhirBundleEntry(oSource).fullUrlElement.Clone;
  resource := TFhirBundleEntry(oSource).resource.Clone;
  search := TFhirBundleEntry(oSource).search.Clone;
  request := TFhirBundleEntry(oSource).request.Clone;
  response := TFhirBundleEntry(oSource).response.Clone;
end;

procedure TFhirBundleEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'fullUrl') Then
     list.add(self.link, 'fullUrl', FFullUrl.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'search') Then
     list.add(self.link, 'search', FSearch.Link);
  if (child_name = 'request') Then
     list.add(self.link, 'request', FRequest.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
end;

procedure TFhirBundleEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'link', '', true, TFhirBundleLink, FLink_List.Link));
  oList.add(TFHIRProperty.create(self, 'fullUrl', 'uri', false, TFhirUri, FFullUrl.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'search', 'BackboneElement', false, TFhirBundleEntrySearch, FSearch.Link));
  oList.add(TFHIRProperty.create(self, 'request', 'BackboneElement', false, TFhirBundleEntryRequest, FRequest.Link));
  oList.add(TFHIRProperty.create(self, 'response', 'BackboneElement', false, TFhirBundleEntryResponse, FResponse.Link));
end;

function TFhirBundleEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink);
    result := propValue;
  end
  else if (propName = 'fullUrl') then
  begin
    FullUrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource;
    result := propValue;
  end
  else if (propName = 'search') then
  begin
    Search := propValue as TFhirBundleEntrySearch;
    result := propValue;
  end
  else if (propName = 'request') then
  begin
    Request := propValue as TFhirBundleEntryRequest;
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirBundleEntryResponse;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink)
  else inherited;
end;

function TFhirBundleEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'link') then result := Link_List.new()
  else if (propName = 'fullUrl') then result := TFhirUri.create()
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'search') then result := TFhirBundleEntrySearch.create()
  else if (propName = 'request') then result := TFhirBundleEntryRequest.create()
  else if (propName = 'response') then result := TFhirBundleEntryResponse.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'link') then result := ''
  else if (propName = 'fullUrl') then result := 'uri'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'search') then result := 'BackboneElement'
  else if (propName = 'request') then result := 'BackboneElement'
  else if (propName = 'response') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else if (propName = 'fullUrl') then FullUrlElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'search') then SearchElement := nil
  else if (propName = 'request') then RequestElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else if (propName = 'fullUrl') then FullUrlElement := asUri(new)
  else if (propName = 'resource') then ResourceElement := new as TFhirResource
  else if (propName = 'search') then SearchElement := new as TFhirBundleEntrySearch
  else if (propName = 'request') then RequestElement := new as TFhirBundleEntryRequest
  else if (propName = 'response') then ResponseElement := new as TFhirBundleEntryResponse
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntry.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntry.fhirType : string;
begin
  result := 'Bundle.entry';
end;

function TFhirBundleEntry.Link : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Link);
end;

function TFhirBundleEntry.Clone : TFhirBundleEntry;
begin
  result := TFhirBundleEntry(inherited Clone);
end;

function TFhirBundleEntry.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntry)) then
    result := false
  else
  begin
    o := TFhirBundleEntry(other);
    result := compareDeep(link_List, o.link_List, true) and compareDeep(fullUrlElement, o.fullUrlElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(searchElement, o.searchElement, true) and 
      compareDeep(requestElement, o.requestElement, true) and compareDeep(responseElement, o.responseElement, true);
  end;
end;

function TFhirBundleEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(Flink_List) and isEmptyProp(FFullUrl) and isEmptyProp(FResource) and isEmptyProp(FSearch) and isEmptyProp(FRequest) and isEmptyProp(FResponse);
end;

procedure TFhirBundleEntry.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('link');
  fields.add('fullUrl');
  fields.add('resource');
  fields.add('search');
  fields.add('request');
  fields.add('response');
end;

function TFhirBundleEntry.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLink_List.sizeInBytes(magic));
end;

function TFhirBundleEntry.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

function TFhirBundleEntry.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

procedure TFhirBundleEntry.SetFullUrl(value : TFhirUri);
begin
  FFullUrl.free;
  FFullUrl := value;
end;

function TFhirBundleEntry.GetFullUrlST : String;
begin
  if FFullUrl = nil then
    result := ''
  else
    result := FFullUrl.value;
end;

procedure TFhirBundleEntry.SetFullUrlST(value : String);
begin
  if value <> '' then
  begin
    if FFullUrl = nil then
      FFullUrl := TFhirUri.create;
    FFullUrl.value := value
  end
  else if FFullUrl <> nil then
    FFullUrl.value := '';
end;

procedure TFhirBundleEntry.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

procedure TFhirBundleEntry.SetSearch(value : TFhirBundleEntrySearch);
begin
  FSearch.free;
  FSearch := value;
end;

procedure TFhirBundleEntry.SetRequest(value : TFhirBundleEntryRequest);
begin
  FRequest.free;
  FRequest := value;
end;

procedure TFhirBundleEntry.SetResponse(value : TFhirBundleEntryResponse);
begin
  FResponse.free;
  FResponse := value;
end;

{ TFhirBundleEntryListEnumerator }

constructor TFhirBundleEntryListEnumerator.Create(list : TFhirBundleEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryListEnumerator.GetCurrent : TFhirBundleEntry;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleEntryList }

function TFhirBundleEntryList.AddItem(value: TFhirBundleEntry): TFhirBundleEntry;
begin
  assert(value.ClassName = 'TFhirBundleEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntry');
  add(value);
  result := value;
end;

function TFhirBundleEntryList.Append: TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryList.GetEnumerator : TFhirBundleEntryListEnumerator;
begin
  result := TFhirBundleEntryListEnumerator.Create(self.link);
end;

function TFhirBundleEntryList.Clone: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Clone);
end;

function TFhirBundleEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryList.GetItemN(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntry;
end;
function TFhirBundleEntryList.IndexOf(value: TFhirBundleEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryList.Insert(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryList.InsertItem(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryList.Item(index: Integer): TFhirBundleEntry;
begin
  result := TFhirBundleEntry(ObjectByIndex[index]);
end;

function TFhirBundleEntryList.Link: TFhirBundleEntryList;
begin
  result := TFhirBundleEntryList(inherited Link);
end;

procedure TFhirBundleEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryList.SetItemByIndex(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  FhirBundleEntries[index] := value;
end;

procedure TFhirBundleEntryList.SetItemN(index: Integer; value: TFhirBundleEntry);
begin
  assert(value is TFhirBundleEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntrySearch }

constructor TFhirBundleEntrySearch.Create;
begin
  inherited;
end;

destructor TFhirBundleEntrySearch.Destroy;
begin
  FMode.free;
  FScore.free;
  inherited;
end;

procedure TFhirBundleEntrySearch.Assign(oSource : TFslObject);
begin
  inherited;
  modeElement := TFhirBundleEntrySearch(oSource).modeElement.Clone;
  scoreElement := TFhirBundleEntrySearch(oSource).scoreElement.Clone;
end;

procedure TFhirBundleEntrySearch.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
end;

procedure TFhirBundleEntrySearch.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'score', 'decimal', false, TFhirDecimal, FScore.Link));
end;

function TFhirBundleEntrySearch.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'score') then
  begin
    ScoreElement := asDecimal(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntrySearch.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntrySearch.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirSearchEntryModeEnum[SearchEntryModeNull], CODES_TFhirSearchEntryModeEnum[SearchEntryModeNull]) 
  else if (propName = 'score') then result := TFhirDecimal.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntrySearch.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'mode') then result := 'code'
  else if (propName = 'score') then result := 'decimal'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntrySearch.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := nil
  else if (propName = 'score') then ScoreElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntrySearch.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirSearchEntryModeEnum, CODES_TFhirSearchEntryModeEnum, new)
  else if (propName = 'score') then ScoreElement := asDecimal(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntrySearch.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntrySearch.fhirType : string;
begin
  result := 'Bundle.entry.search';
end;

function TFhirBundleEntrySearch.Link : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Link);
end;

function TFhirBundleEntrySearch.Clone : TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(inherited Clone);
end;

function TFhirBundleEntrySearch.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntrySearch;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntrySearch)) then
    result := false
  else
  begin
    o := TFhirBundleEntrySearch(other);
    result := compareDeep(modeElement, o.modeElement, true) and compareDeep(scoreElement, o.scoreElement, true);
  end;
end;

function TFhirBundleEntrySearch.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMode) and isEmptyProp(FScore);
end;

procedure TFhirBundleEntrySearch.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('mode');
  fields.add('score');
end;

function TFhirBundleEntrySearch.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBundleEntrySearch.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirBundleEntrySearch.GetModeST : TFhirSearchEntryModeEnum;
begin
  if FMode = nil then
    result := TFhirSearchEntryModeEnum(0)
  else
    result := TFhirSearchEntryModeEnum(StringArrayIndexOfSensitive(CODES_TFhirSearchEntryModeEnum, FMode.value));
end;

procedure TFhirBundleEntrySearch.SetModeST(value : TFhirSearchEntryModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirSearchEntryModeEnum[value], CODES_TFhirSearchEntryModeEnum[value]);
end;

procedure TFhirBundleEntrySearch.SetScore(value : TFhirDecimal);
begin
  FScore.free;
  FScore := value;
end;

function TFhirBundleEntrySearch.GetScoreST : String;
begin
  if FScore = nil then
    result := ''
  else
    result := FScore.value;
end;

procedure TFhirBundleEntrySearch.SetScoreST(value : String);
begin
  if value <> '' then
  begin
    if FScore = nil then
      FScore := TFhirDecimal.create;
    FScore.value := value
  end
  else if FScore <> nil then
    FScore.value := '';
end;

{ TFhirBundleEntrySearchListEnumerator }

constructor TFhirBundleEntrySearchListEnumerator.Create(list : TFhirBundleEntrySearchList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntrySearchListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntrySearchListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntrySearchListEnumerator.GetCurrent : TFhirBundleEntrySearch;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntrySearchListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleEntrySearchList }

function TFhirBundleEntrySearchList.AddItem(value: TFhirBundleEntrySearch): TFhirBundleEntrySearch;
begin
  assert(value.ClassName = 'TFhirBundleEntrySearch', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntrySearch');
  add(value);
  result := value;
end;

function TFhirBundleEntrySearchList.Append: TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntrySearchList.GetEnumerator : TFhirBundleEntrySearchListEnumerator;
begin
  result := TFhirBundleEntrySearchListEnumerator.Create(self.link);
end;

function TFhirBundleEntrySearchList.Clone: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Clone);
end;

function TFhirBundleEntrySearchList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntrySearchList.GetItemN(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntrySearch;
end;
function TFhirBundleEntrySearchList.IndexOf(value: TFhirBundleEntrySearch): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntrySearchList.Insert(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntrySearchList.InsertItem(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  Inherited Insert(index, value);
end;

function TFhirBundleEntrySearchList.Item(index: Integer): TFhirBundleEntrySearch;
begin
  result := TFhirBundleEntrySearch(ObjectByIndex[index]);
end;

function TFhirBundleEntrySearchList.Link: TFhirBundleEntrySearchList;
begin
  result := TFhirBundleEntrySearchList(inherited Link);
end;

procedure TFhirBundleEntrySearchList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntrySearchList.SetItemByIndex(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  FhirBundleEntrySearches[index] := value;
end;

procedure TFhirBundleEntrySearchList.SetItemN(index: Integer; value: TFhirBundleEntrySearch);
begin
  assert(value is TFhirBundleEntrySearch);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryRequest }

constructor TFhirBundleEntryRequest.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryRequest.Destroy;
begin
  FMethod.free;
  FUrl.free;
  FIfNoneMatch.free;
  FIfModifiedSince.free;
  FIfMatch.free;
  FIfNoneExist.free;
  inherited;
end;

procedure TFhirBundleEntryRequest.Assign(oSource : TFslObject);
begin
  inherited;
  methodElement := TFhirBundleEntryRequest(oSource).methodElement.Clone;
  urlElement := TFhirBundleEntryRequest(oSource).urlElement.Clone;
  ifNoneMatchElement := TFhirBundleEntryRequest(oSource).ifNoneMatchElement.Clone;
  ifModifiedSinceElement := TFhirBundleEntryRequest(oSource).ifModifiedSinceElement.Clone;
  ifMatchElement := TFhirBundleEntryRequest(oSource).ifMatchElement.Clone;
  ifNoneExistElement := TFhirBundleEntryRequest(oSource).ifNoneExistElement.Clone;
end;

procedure TFhirBundleEntryRequest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'ifNoneMatch') Then
     list.add(self.link, 'ifNoneMatch', FIfNoneMatch.Link);
  if (child_name = 'ifModifiedSince') Then
     list.add(self.link, 'ifModifiedSince', FIfModifiedSince.Link);
  if (child_name = 'ifMatch') Then
     list.add(self.link, 'ifMatch', FIfMatch.Link);
  if (child_name = 'ifNoneExist') Then
     list.add(self.link, 'ifNoneExist', FIfNoneExist.Link);
end;

procedure TFhirBundleEntryRequest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'method', 'code', false, TFhirEnum, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'ifNoneMatch', 'string', false, TFhirString, FIfNoneMatch.Link));
  oList.add(TFHIRProperty.create(self, 'ifModifiedSince', 'instant', false, TFhirInstant, FIfModifiedSince.Link));
  oList.add(TFHIRProperty.create(self, 'ifMatch', 'string', false, TFhirString, FIfMatch.Link));
  oList.add(TFHIRProperty.create(self, 'ifNoneExist', 'string', false, TFhirString, FIfNoneExist.Link));
end;

function TFhirBundleEntryRequest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'method') then
  begin
    MethodElement := asEnum(SYSTEMS_TFhirHTTPVerbEnum, CODES_TFhirHTTPVerbEnum, propValue);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'ifNoneMatch') then
  begin
    IfNoneMatchElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'ifModifiedSince') then
  begin
    IfModifiedSinceElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'ifMatch') then
  begin
    IfMatchElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'ifNoneExist') then
  begin
    IfNoneExistElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryRequest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryRequest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'method') then result := TFhirEnum.create(SYSTEMS_TFhirHTTPVerbEnum[HTTPVerbNull], CODES_TFhirHTTPVerbEnum[HTTPVerbNull]) 
  else if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'ifNoneMatch') then result := TFhirString.create()
  else if (propName = 'ifModifiedSince') then result := TFhirInstant.create()
  else if (propName = 'ifMatch') then result := TFhirString.create()
  else if (propName = 'ifNoneExist') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryRequest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'method') then result := 'code'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'ifNoneMatch') then result := 'string'
  else if (propName = 'ifModifiedSince') then result := 'instant'
  else if (propName = 'ifMatch') then result := 'string'
  else if (propName = 'ifNoneExist') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryRequest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := nil
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := nil
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := nil
  else if (propName = 'ifMatch') then IfMatchElement := nil
  else if (propName = 'ifNoneExist') then IfNoneExistElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryRequest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'method') then MethodElement := asEnum(SYSTEMS_TFhirHTTPVerbEnum, CODES_TFhirHTTPVerbEnum, new)
  else if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'ifNoneMatch') then IfNoneMatchElement := asString(new)
  else if (propName = 'ifModifiedSince') then IfModifiedSinceElement := asInstant(new)
  else if (propName = 'ifMatch') then IfMatchElement := asString(new)
  else if (propName = 'ifNoneExist') then IfNoneExistElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryRequest.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryRequest.fhirType : string;
begin
  result := 'Bundle.entry.request';
end;

function TFhirBundleEntryRequest.Link : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Link);
end;

function TFhirBundleEntryRequest.Clone : TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(inherited Clone);
end;

function TFhirBundleEntryRequest.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntryRequest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryRequest)) then
    result := false
  else
  begin
    o := TFhirBundleEntryRequest(other);
    result := compareDeep(methodElement, o.methodElement, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(ifNoneMatchElement, o.ifNoneMatchElement, true) and compareDeep(ifModifiedSinceElement, o.ifModifiedSinceElement, true) and 
      compareDeep(ifMatchElement, o.ifMatchElement, true) and compareDeep(ifNoneExistElement, o.ifNoneExistElement, true);
  end;
end;

function TFhirBundleEntryRequest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMethod) and isEmptyProp(FUrl) and isEmptyProp(FIfNoneMatch) and isEmptyProp(FIfModifiedSince) and isEmptyProp(FIfMatch) and isEmptyProp(FIfNoneExist);
end;

procedure TFhirBundleEntryRequest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('method');
  fields.add('url');
  fields.add('ifNoneMatch');
  fields.add('ifModifiedSince');
  fields.add('ifMatch');
  fields.add('ifNoneExist');
end;

function TFhirBundleEntryRequest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBundleEntryRequest.SetMethod(value : TFhirEnum);
begin
  FMethod.free;
  FMethod := value;
end;

function TFhirBundleEntryRequest.GetMethodST : TFhirHTTPVerbEnum;
begin
  if FMethod = nil then
    result := TFhirHTTPVerbEnum(0)
  else
    result := TFhirHTTPVerbEnum(StringArrayIndexOfSensitive(CODES_TFhirHTTPVerbEnum, FMethod.value));
end;

procedure TFhirBundleEntryRequest.SetMethodST(value : TFhirHTTPVerbEnum);
begin
  if ord(value) = 0 then
    MethodElement := nil
  else
    MethodElement := TFhirEnum.create(SYSTEMS_TFhirHTTPVerbEnum[value], CODES_TFhirHTTPVerbEnum[value]);
end;

procedure TFhirBundleEntryRequest.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirBundleEntryRequest.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirBundleEntryRequest.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirBundleEntryRequest.SetIfNoneMatch(value : TFhirString);
begin
  FIfNoneMatch.free;
  FIfNoneMatch := value;
end;

function TFhirBundleEntryRequest.GetIfNoneMatchST : String;
begin
  if FIfNoneMatch = nil then
    result := ''
  else
    result := FIfNoneMatch.value;
end;

procedure TFhirBundleEntryRequest.SetIfNoneMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneMatch = nil then
      FIfNoneMatch := TFhirString.create;
    FIfNoneMatch.value := value
  end
  else if FIfNoneMatch <> nil then
    FIfNoneMatch.value := '';
end;

procedure TFhirBundleEntryRequest.SetIfModifiedSince(value : TFhirInstant);
begin
  FIfModifiedSince.free;
  FIfModifiedSince := value;
end;

function TFhirBundleEntryRequest.GetIfModifiedSinceST : TFslDateTime;
begin
  if FIfModifiedSince = nil then
    result := TFslDateTime.makeNull
  else
    result := FIfModifiedSince.value;
end;

procedure TFhirBundleEntryRequest.SetIfModifiedSinceST(value : TFslDateTime);
begin
  if FIfModifiedSince = nil then
    FIfModifiedSince := TFhirInstant.create;
  FIfModifiedSince.value := value
end;

procedure TFhirBundleEntryRequest.SetIfMatch(value : TFhirString);
begin
  FIfMatch.free;
  FIfMatch := value;
end;

function TFhirBundleEntryRequest.GetIfMatchST : String;
begin
  if FIfMatch = nil then
    result := ''
  else
    result := FIfMatch.value;
end;

procedure TFhirBundleEntryRequest.SetIfMatchST(value : String);
begin
  if value <> '' then
  begin
    if FIfMatch = nil then
      FIfMatch := TFhirString.create;
    FIfMatch.value := value
  end
  else if FIfMatch <> nil then
    FIfMatch.value := '';
end;

procedure TFhirBundleEntryRequest.SetIfNoneExist(value : TFhirString);
begin
  FIfNoneExist.free;
  FIfNoneExist := value;
end;

function TFhirBundleEntryRequest.GetIfNoneExistST : String;
begin
  if FIfNoneExist = nil then
    result := ''
  else
    result := FIfNoneExist.value;
end;

procedure TFhirBundleEntryRequest.SetIfNoneExistST(value : String);
begin
  if value <> '' then
  begin
    if FIfNoneExist = nil then
      FIfNoneExist := TFhirString.create;
    FIfNoneExist.value := value
  end
  else if FIfNoneExist <> nil then
    FIfNoneExist.value := '';
end;

{ TFhirBundleEntryRequestListEnumerator }

constructor TFhirBundleEntryRequestListEnumerator.Create(list : TFhirBundleEntryRequestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryRequestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryRequestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryRequestListEnumerator.GetCurrent : TFhirBundleEntryRequest;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryRequestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleEntryRequestList }

function TFhirBundleEntryRequestList.AddItem(value: TFhirBundleEntryRequest): TFhirBundleEntryRequest;
begin
  assert(value.ClassName = 'TFhirBundleEntryRequest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryRequest');
  add(value);
  result := value;
end;

function TFhirBundleEntryRequestList.Append: TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryRequestList.GetEnumerator : TFhirBundleEntryRequestListEnumerator;
begin
  result := TFhirBundleEntryRequestListEnumerator.Create(self.link);
end;

function TFhirBundleEntryRequestList.Clone: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Clone);
end;

function TFhirBundleEntryRequestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryRequestList.GetItemN(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryRequest;
end;
function TFhirBundleEntryRequestList.IndexOf(value: TFhirBundleEntryRequest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryRequestList.Insert(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryRequestList.InsertItem(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryRequestList.Item(index: Integer): TFhirBundleEntryRequest;
begin
  result := TFhirBundleEntryRequest(ObjectByIndex[index]);
end;

function TFhirBundleEntryRequestList.Link: TFhirBundleEntryRequestList;
begin
  result := TFhirBundleEntryRequestList(inherited Link);
end;

procedure TFhirBundleEntryRequestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryRequestList.SetItemByIndex(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  FhirBundleEntryRequests[index] := value;
end;

procedure TFhirBundleEntryRequestList.SetItemN(index: Integer; value: TFhirBundleEntryRequest);
begin
  assert(value is TFhirBundleEntryRequest);
  ObjectByIndex[index] := value;
end;

{ TFhirBundleEntryResponse }

constructor TFhirBundleEntryResponse.Create;
begin
  inherited;
end;

destructor TFhirBundleEntryResponse.Destroy;
begin
  FStatus.free;
  FLocation.free;
  FEtag.free;
  FLastModified.free;
  FOutcome.free;
  inherited;
end;

procedure TFhirBundleEntryResponse.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirBundleEntryResponse(oSource).statusElement.Clone;
  locationElement := TFhirBundleEntryResponse(oSource).locationElement.Clone;
  etagElement := TFhirBundleEntryResponse(oSource).etagElement.Clone;
  lastModifiedElement := TFhirBundleEntryResponse(oSource).lastModifiedElement.Clone;
  outcome := TFhirBundleEntryResponse(oSource).outcome.Clone;
end;

procedure TFhirBundleEntryResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'etag') Then
     list.add(self.link, 'etag', FEtag.Link);
  if (child_name = 'lastModified') Then
     list.add(self.link, 'lastModified', FLastModified.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
end;

procedure TFhirBundleEntryResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'string', false, TFhirString, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'uri', false, TFhirUri, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'etag', 'string', false, TFhirString, FEtag.Link));
  oList.add(TFHIRProperty.create(self, 'lastModified', 'instant', false, TFhirInstant, FLastModified.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'Resource', false, TFhirResource, FOutcome.Link));
end;

function TFhirBundleEntryResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'etag') then
  begin
    EtagElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'lastModified') then
  begin
    LastModifiedElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirResource;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundleEntryResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirBundleEntryResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirString.create()
  else if (propName = 'location') then result := TFhirUri.create()
  else if (propName = 'etag') then result := TFhirString.create()
  else if (propName = 'lastModified') then result := TFhirInstant.create()
  else if (propName = 'outcome') then raise EFHIRException.create('Cannot make property Outcome')
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundleEntryResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'string'
  else if (propName = 'location') then result := 'uri'
  else if (propName = 'etag') then result := 'string'
  else if (propName = 'lastModified') then result := 'instant'
  else if (propName = 'outcome') then result := 'Resource'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundleEntryResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'etag') then EtagElement := nil
  else if (propName = 'lastModified') then LastModifiedElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundleEntryResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asString(new)
  else if (propName = 'location') then LocationElement := asUri(new)
  else if (propName = 'etag') then EtagElement := asString(new)
  else if (propName = 'lastModified') then LastModifiedElement := asInstant(new)
  else if (propName = 'outcome') then OutcomeElement := new as TFhirResource
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundleEntryResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirBundleEntryResponse.fhirType : string;
begin
  result := 'Bundle.entry.response';
end;

function TFhirBundleEntryResponse.Link : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Link);
end;

function TFhirBundleEntryResponse.Clone : TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(inherited Clone);
end;

function TFhirBundleEntryResponse.equals(other : TObject) : boolean; 
var
  o : TFhirBundleEntryResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundleEntryResponse)) then
    result := false
  else
  begin
    o := TFhirBundleEntryResponse(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(locationElement, o.locationElement, true) and 
      compareDeep(etagElement, o.etagElement, true) and compareDeep(lastModifiedElement, o.lastModifiedElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true);
  end;
end;

function TFhirBundleEntryResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FLocation) and isEmptyProp(FEtag) and isEmptyProp(FLastModified) and isEmptyProp(FOutcome);
end;

procedure TFhirBundleEntryResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('location');
  fields.add('etag');
  fields.add('lastModified');
  fields.add('outcome');
end;

function TFhirBundleEntryResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirBundleEntryResponse.SetStatus(value : TFhirString);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirBundleEntryResponse.GetStatusST : String;
begin
  if FStatus = nil then
    result := ''
  else
    result := FStatus.value;
end;

procedure TFhirBundleEntryResponse.SetStatusST(value : String);
begin
  if value <> '' then
  begin
    if FStatus = nil then
      FStatus := TFhirString.create;
    FStatus.value := value
  end
  else if FStatus <> nil then
    FStatus.value := '';
end;

procedure TFhirBundleEntryResponse.SetLocation(value : TFhirUri);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirBundleEntryResponse.GetLocationST : String;
begin
  if FLocation = nil then
    result := ''
  else
    result := FLocation.value;
end;

procedure TFhirBundleEntryResponse.SetLocationST(value : String);
begin
  if value <> '' then
  begin
    if FLocation = nil then
      FLocation := TFhirUri.create;
    FLocation.value := value
  end
  else if FLocation <> nil then
    FLocation.value := '';
end;

procedure TFhirBundleEntryResponse.SetEtag(value : TFhirString);
begin
  FEtag.free;
  FEtag := value;
end;

function TFhirBundleEntryResponse.GetEtagST : String;
begin
  if FEtag = nil then
    result := ''
  else
    result := FEtag.value;
end;

procedure TFhirBundleEntryResponse.SetEtagST(value : String);
begin
  if value <> '' then
  begin
    if FEtag = nil then
      FEtag := TFhirString.create;
    FEtag.value := value
  end
  else if FEtag <> nil then
    FEtag.value := '';
end;

procedure TFhirBundleEntryResponse.SetLastModified(value : TFhirInstant);
begin
  FLastModified.free;
  FLastModified := value;
end;

function TFhirBundleEntryResponse.GetLastModifiedST : TFslDateTime;
begin
  if FLastModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastModified.value;
end;

procedure TFhirBundleEntryResponse.SetLastModifiedST(value : TFslDateTime);
begin
  if FLastModified = nil then
    FLastModified := TFhirInstant.create;
  FLastModified.value := value
end;

procedure TFhirBundleEntryResponse.SetOutcome(value : TFhirResource);
begin
  FOutcome.free;
  FOutcome := value;
end;

{ TFhirBundleEntryResponseListEnumerator }

constructor TFhirBundleEntryResponseListEnumerator.Create(list : TFhirBundleEntryResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleEntryResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleEntryResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleEntryResponseListEnumerator.GetCurrent : TFhirBundleEntryResponse;
begin
  Result := FList[FIndex];
end;

function TFhirBundleEntryResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleEntryResponseList }

function TFhirBundleEntryResponseList.AddItem(value: TFhirBundleEntryResponse): TFhirBundleEntryResponse;
begin
  assert(value.ClassName = 'TFhirBundleEntryResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundleEntryResponse');
  add(value);
  result := value;
end;

function TFhirBundleEntryResponseList.Append: TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.ClearItems;
begin
  Clear;
end;

function TFhirBundleEntryResponseList.GetEnumerator : TFhirBundleEntryResponseListEnumerator;
begin
  result := TFhirBundleEntryResponseListEnumerator.Create(self.link);
end;

function TFhirBundleEntryResponseList.Clone: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Clone);
end;

function TFhirBundleEntryResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleEntryResponseList.GetItemN(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundleEntryResponse;
end;
function TFhirBundleEntryResponseList.IndexOf(value: TFhirBundleEntryResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleEntryResponseList.Insert(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleEntryResponseList.InsertItem(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  Inherited Insert(index, value);
end;

function TFhirBundleEntryResponseList.Item(index: Integer): TFhirBundleEntryResponse;
begin
  result := TFhirBundleEntryResponse(ObjectByIndex[index]);
end;

function TFhirBundleEntryResponseList.Link: TFhirBundleEntryResponseList;
begin
  result := TFhirBundleEntryResponseList(inherited Link);
end;

procedure TFhirBundleEntryResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleEntryResponseList.SetItemByIndex(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  FhirBundleEntryResponses[index] := value;
end;

procedure TFhirBundleEntryResponseList.SetItemN(index: Integer; value: TFhirBundleEntryResponse);
begin
  assert(value is TFhirBundleEntryResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirBundle }

constructor TFhirBundle.Create;
begin
  inherited;
end;

destructor TFhirBundle.Destroy;
begin
  FIdentifier.free;
  FType_.free;
  FTimestamp.free;
  FTotal.free;
  FLink_List.Free;
  FEntryList.Free;
  FSignature.free;
  inherited;
end;

procedure TFhirBundle.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirBundle(oSource).identifier.Clone;
  type_Element := TFhirBundle(oSource).type_Element.Clone;
  timestampElement := TFhirBundle(oSource).timestampElement.Clone;
  totalElement := TFhirBundle(oSource).totalElement.Clone;
  if (TFhirBundle(oSource).FLink_List = nil) then
  begin
    FLink_List.free;
    FLink_List := nil;
  end
  else
  begin
    if FLink_List = nil then
      FLink_List := TFhirBundleLinkList.Create;
    FLink_List.Assign(TFhirBundle(oSource).FLink_List);
  end;
  if (TFhirBundle(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirBundleEntryList.Create;
    FEntryList.Assign(TFhirBundle(oSource).FEntryList);
  end;
  signature := TFhirBundle(oSource).signature.Clone;
end;

function TFhirBundle.GetResourceType : TFhirResourceType;
begin
  result := frtBundle;
end;

procedure TFhirBundle.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'total') Then
     list.add(self.link, 'total', FTotal.Link);
  if (child_name = 'link') Then
    list.addAll(self, 'link', FLink_List);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'signature') Then
     list.add(self.link, 'signature', FSignature.Link);
end;

procedure TFhirBundle.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', false, TFhirInstant, FTimestamp.Link));
  oList.add(TFHIRProperty.create(self, 'total', 'unsignedInt', false, TFhirUnsignedInt, FTotal.Link));
  oList.add(TFHIRProperty.create(self, 'link', 'BackboneElement', true, TFhirBundleLink, FLink_List.Link));
  oList.add(TFHIRProperty.create(self, 'entry', 'BackboneElement', true, TFhirBundleEntry, FEntryList.Link));
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', false, TFhirSignature, FSignature.Link));
end;

function TFhirBundle.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'timestamp') then
  begin
    TimestampElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'total') then
  begin
    TotalElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'link') then
  begin
    Link_List.add(propValue as TFhirBundleLink);
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirBundleEntry);
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    Signature := propValue as TFhirSignature;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirBundle.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'link') then Link_List.insertItem(index, propValue as TFhirBundleLink)
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirBundleEntry)
  else inherited;
end;

function TFhirBundle.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirBundleTypeEnum[BundleTypeNull], CODES_TFhirBundleTypeEnum[BundleTypeNull]) 
  else if (propName = 'timestamp') then result := TFhirInstant.create()
  else if (propName = 'total') then result := TFhirUnsignedInt.create()
  else if (propName = 'link') then result := Link_List.new()
  else if (propName = 'entry') then result := EntryList.new()
  else if (propName = 'signature') then result := TFhirSignature.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirBundle.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'timestamp') then result := 'instant'
  else if (propName = 'total') then result := 'unsignedInt'
  else if (propName = 'link') then result := 'BackboneElement'
  else if (propName = 'entry') then result := 'BackboneElement'
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirBundle.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'total') then TotalElement := nil
  else if (propName = 'link') then deletePropertyValue('link', Link_List, value)
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value)
  else if (propName = 'signature') then SignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirBundle.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirBundleTypeEnum, CODES_TFhirBundleTypeEnum, new)
  else if (propName = 'timestamp') then TimestampElement := asInstant(new)
  else if (propName = 'total') then TotalElement := asUnsignedInt(new)
  else if (propName = 'link') then replacePropertyValue('link', Link_List, existing, new)
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new)
  else if (propName = 'signature') then SignatureElement := new as TFhirSignature
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirBundle.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'link') then Link_List.move(source, destination)
  else if (propName = 'entry') then EntryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirBundle.fhirType : string;
begin
  result := 'Bundle';
end;

function TFhirBundle.Link : TFhirBundle;
begin
  result := TFhirBundle(inherited Link);
end;

function TFhirBundle.Clone : TFhirBundle;
begin
  result := TFhirBundle(inherited Clone);
end;

function TFhirBundle.equals(other : TObject) : boolean; 
var
  o : TFhirBundle;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirBundle)) then
    result := false
  else
  begin
    o := TFhirBundle(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(timestampElement, o.timestampElement, true) and compareDeep(totalElement, o.totalElement, true) and 
      compareDeep(link_List, o.link_List, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(signatureElement, o.signatureElement, true);
  end;
end;

function TFhirBundle.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FType_) and isEmptyProp(FTimestamp) and isEmptyProp(FTotal) and isEmptyProp(Flink_List) and isEmptyProp(FentryList) and isEmptyProp(FSignature);
end;

procedure TFhirBundle.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('type');
  fields.add('timestamp');
  fields.add('total');
  fields.add('link');
  fields.add('entry');
  fields.add('signature');
end;

function TFhirBundle.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLink_List.sizeInBytes(magic));
  inc(result, FEntryList.sizeInBytes(magic));
end;

procedure TFhirBundle.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirBundle.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirBundle.GetType_ST : TFhirBundleTypeEnum;
begin
  if FType_ = nil then
    result := TFhirBundleTypeEnum(0)
  else
    result := TFhirBundleTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirBundleTypeEnum, FType_.value));
end;

procedure TFhirBundle.SetType_ST(value : TFhirBundleTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirBundleTypeEnum[value], CODES_TFhirBundleTypeEnum[value]);
end;

procedure TFhirBundle.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

function TFhirBundle.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

procedure TFhirBundle.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirInstant.create;
  FTimestamp.value := value
end;

procedure TFhirBundle.SetTotal(value : TFhirUnsignedInt);
begin
  FTotal.free;
  FTotal := value;
end;

function TFhirBundle.GetTotalST : String;
begin
  if FTotal = nil then
    result := ''
  else
    result := FTotal.value;
end;

procedure TFhirBundle.SetTotalST(value : String);
begin
  if value <> '' then
  begin
    if FTotal = nil then
      FTotal := TFhirUnsignedInt.create;
    FTotal.value := value
  end
  else if FTotal <> nil then
    FTotal.value := '';
end;

function TFhirBundle.GetLink_List : TFhirBundleLinkList;
begin
  if FLink_List = nil then
    FLink_List := TFhirBundleLinkList.Create;
  result := FLink_List;
end;

function TFhirBundle.GetHasLink_List : boolean;
begin
  result := (FLink_List <> nil) and (FLink_List.count > 0);
end;

function TFhirBundle.GetEntryList : TFhirBundleEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirBundleEntryList.Create;
  result := FEntryList;
end;

function TFhirBundle.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

procedure TFhirBundle.SetSignature(value : TFhirSignature);
begin
  FSignature.free;
  FSignature := value;
end;

{ TFhirBundleListEnumerator }

constructor TFhirBundleListEnumerator.Create(list : TFhirBundleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirBundleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirBundleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirBundleListEnumerator.GetCurrent : TFhirBundle;
begin
  Result := FList[FIndex];
end;

function TFhirBundleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirBundleList }

function TFhirBundleList.AddItem(value: TFhirBundle): TFhirBundle;
begin
  assert(value.ClassName = 'TFhirBundle', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirBundle');
  add(value);
  result := value;
end;

function TFhirBundleList.Append: TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.ClearItems;
begin
  Clear;
end;

function TFhirBundleList.GetEnumerator : TFhirBundleListEnumerator;
begin
  result := TFhirBundleListEnumerator.Create(self.link);
end;

function TFhirBundleList.Clone: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Clone);
end;

function TFhirBundleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirBundleList.GetItemN(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.ItemClass: TFslObjectClass;
begin
  result := TFhirBundle;
end;
function TFhirBundleList.IndexOf(value: TFhirBundle): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirBundleList.Insert(index: Integer): TFhirBundle;
begin
  result := TFhirBundle.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirBundleList.InsertItem(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  Inherited Insert(index, value);
end;

function TFhirBundleList.Item(index: Integer): TFhirBundle;
begin
  result := TFhirBundle(ObjectByIndex[index]);
end;

function TFhirBundleList.Link: TFhirBundleList;
begin
  result := TFhirBundleList(inherited Link);
end;

procedure TFhirBundleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirBundleList.SetItemByIndex(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  FhirBundles[index] := value;
end;

procedure TFhirBundleList.SetItemN(index: Integer; value: TFhirBundle);
begin
  assert(value is TFhirBundle);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_BUNDLE}
{$IFDEF FHIR_CONSENT}
{ TFhirConsentPolicy }

constructor TFhirConsentPolicy.Create;
begin
  inherited;
end;

destructor TFhirConsentPolicy.Destroy;
begin
  FAuthority.free;
  FUri.free;
  inherited;
end;

procedure TFhirConsentPolicy.Assign(oSource : TFslObject);
begin
  inherited;
  authorityElement := TFhirConsentPolicy(oSource).authorityElement.Clone;
  uriElement := TFhirConsentPolicy(oSource).uriElement.Clone;
end;

procedure TFhirConsentPolicy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'authority') Then
     list.add(self.link, 'authority', FAuthority.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
end;

procedure TFhirConsentPolicy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'authority', 'uri', false, TFhirUri, FAuthority.Link));
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));
end;

function TFhirConsentPolicy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'authority') then
  begin
    AuthorityElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentPolicy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentPolicy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'authority') then result := TFhirUri.create()
  else if (propName = 'uri') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentPolicy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'authority') then result := 'uri'
  else if (propName = 'uri') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentPolicy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := nil
  else if (propName = 'uri') then UriElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentPolicy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'authority') then AuthorityElement := asUri(new)
  else if (propName = 'uri') then UriElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentPolicy.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentPolicy.fhirType : string;
begin
  result := 'Consent.policy';
end;

function TFhirConsentPolicy.Link : TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(inherited Link);
end;

function TFhirConsentPolicy.Clone : TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(inherited Clone);
end;

function TFhirConsentPolicy.equals(other : TObject) : boolean; 
var
  o : TFhirConsentPolicy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentPolicy)) then
    result := false
  else
  begin
    o := TFhirConsentPolicy(other);
    result := compareDeep(authorityElement, o.authorityElement, true) and compareDeep(uriElement, o.uriElement, true);
  end;
end;

function TFhirConsentPolicy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FAuthority) and isEmptyProp(FUri);
end;

procedure TFhirConsentPolicy.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('authority');
  fields.add('uri');
end;

function TFhirConsentPolicy.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirConsentPolicy.SetAuthority(value : TFhirUri);
begin
  FAuthority.free;
  FAuthority := value;
end;

function TFhirConsentPolicy.GetAuthorityST : String;
begin
  if FAuthority = nil then
    result := ''
  else
    result := FAuthority.value;
end;

procedure TFhirConsentPolicy.SetAuthorityST(value : String);
begin
  if value <> '' then
  begin
    if FAuthority = nil then
      FAuthority := TFhirUri.create;
    FAuthority.value := value
  end
  else if FAuthority <> nil then
    FAuthority.value := '';
end;

procedure TFhirConsentPolicy.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

function TFhirConsentPolicy.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

procedure TFhirConsentPolicy.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

{ TFhirConsentPolicyListEnumerator }

constructor TFhirConsentPolicyListEnumerator.Create(list : TFhirConsentPolicyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentPolicyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentPolicyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentPolicyListEnumerator.GetCurrent : TFhirConsentPolicy;
begin
  Result := FList[FIndex];
end;

function TFhirConsentPolicyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentPolicyList }

function TFhirConsentPolicyList.AddItem(value: TFhirConsentPolicy): TFhirConsentPolicy;
begin
  assert(value.ClassName = 'TFhirConsentPolicy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentPolicy');
  add(value);
  result := value;
end;

function TFhirConsentPolicyList.Append: TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentPolicyList.ClearItems;
begin
  Clear;
end;

function TFhirConsentPolicyList.GetEnumerator : TFhirConsentPolicyListEnumerator;
begin
  result := TFhirConsentPolicyListEnumerator.Create(self.link);
end;

function TFhirConsentPolicyList.Clone: TFhirConsentPolicyList;
begin
  result := TFhirConsentPolicyList(inherited Clone);
end;

function TFhirConsentPolicyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentPolicyList.GetItemN(index: Integer): TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(ObjectByIndex[index]);
end;

function TFhirConsentPolicyList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentPolicy;
end;
function TFhirConsentPolicyList.IndexOf(value: TFhirConsentPolicy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentPolicyList.Insert(index: Integer): TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentPolicyList.InsertItem(index: Integer; value: TFhirConsentPolicy);
begin
  assert(value is TFhirConsentPolicy);
  Inherited Insert(index, value);
end;

function TFhirConsentPolicyList.Item(index: Integer): TFhirConsentPolicy;
begin
  result := TFhirConsentPolicy(ObjectByIndex[index]);
end;

function TFhirConsentPolicyList.Link: TFhirConsentPolicyList;
begin
  result := TFhirConsentPolicyList(inherited Link);
end;

procedure TFhirConsentPolicyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentPolicyList.SetItemByIndex(index: Integer; value: TFhirConsentPolicy);
begin
  assert(value is TFhirConsentPolicy);
  FhirConsentPolicies[index] := value;
end;

procedure TFhirConsentPolicyList.SetItemN(index: Integer; value: TFhirConsentPolicy);
begin
  assert(value is TFhirConsentPolicy);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentVerification }

constructor TFhirConsentVerification.Create;
begin
  inherited;
end;

destructor TFhirConsentVerification.Destroy;
begin
  FVerified.free;
  FVerifiedWith.free;
  FVerificationDate.free;
  inherited;
end;

procedure TFhirConsentVerification.Assign(oSource : TFslObject);
begin
  inherited;
  verifiedElement := TFhirConsentVerification(oSource).verifiedElement.Clone;
  verifiedWith := TFhirConsentVerification(oSource).verifiedWith.Clone;
  verificationDateElement := TFhirConsentVerification(oSource).verificationDateElement.Clone;
end;

procedure TFhirConsentVerification.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'verified') Then
     list.add(self.link, 'verified', FVerified.Link);
  if (child_name = 'verifiedWith') Then
     list.add(self.link, 'verifiedWith', FVerifiedWith.Link);
  if (child_name = 'verificationDate') Then
     list.add(self.link, 'verificationDate', FVerificationDate.Link);
end;

procedure TFhirConsentVerification.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'verified', 'boolean', false, TFhirBoolean, FVerified.Link));
  oList.add(TFHIRProperty.create(self, 'verifiedWith', 'Reference', false, TFhirReference, FVerifiedWith.Link));
  oList.add(TFHIRProperty.create(self, 'verificationDate', 'dateTime', false, TFhirDateTime, FVerificationDate.Link));
end;

function TFhirConsentVerification.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'verified') then
  begin
    VerifiedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'verifiedWith') then
  begin
    VerifiedWith := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'verificationDate') then
  begin
    VerificationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentVerification.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentVerification.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'verified') then result := TFhirBoolean.create()
  else if (propName = 'verifiedWith') then result := TFhirReference.create()
  else if (propName = 'verificationDate') then result := TFhirDateTime.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentVerification.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'verified') then result := 'boolean'
  else if (propName = 'verifiedWith') then result := 'Reference'
  else if (propName = 'verificationDate') then result := 'dateTime'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentVerification.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'verified') then VerifiedElement := nil
  else if (propName = 'verifiedWith') then VerifiedWithElement := nil
  else if (propName = 'verificationDate') then VerificationDateElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentVerification.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'verified') then VerifiedElement := asBoolean(new)
  else if (propName = 'verifiedWith') then VerifiedWithElement := new as TFhirReference
  else if (propName = 'verificationDate') then VerificationDateElement := asDateTime(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentVerification.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentVerification.fhirType : string;
begin
  result := 'Consent.verification';
end;

function TFhirConsentVerification.Link : TFhirConsentVerification;
begin
  result := TFhirConsentVerification(inherited Link);
end;

function TFhirConsentVerification.Clone : TFhirConsentVerification;
begin
  result := TFhirConsentVerification(inherited Clone);
end;

function TFhirConsentVerification.equals(other : TObject) : boolean; 
var
  o : TFhirConsentVerification;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentVerification)) then
    result := false
  else
  begin
    o := TFhirConsentVerification(other);
    result := compareDeep(verifiedElement, o.verifiedElement, true) and compareDeep(verifiedWithElement, o.verifiedWithElement, true) and 
      compareDeep(verificationDateElement, o.verificationDateElement, true);
  end;
end;

function TFhirConsentVerification.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FVerified) and isEmptyProp(FVerifiedWith) and isEmptyProp(FVerificationDate);
end;

procedure TFhirConsentVerification.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('verified');
  fields.add('verifiedWith');
  fields.add('verificationDate');
end;

function TFhirConsentVerification.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirConsentVerification.SetVerified(value : TFhirBoolean);
begin
  FVerified.free;
  FVerified := value;
end;

function TFhirConsentVerification.GetVerifiedST : Boolean;
begin
  if FVerified = nil then
    result := false
  else
    result := FVerified.value;
end;

procedure TFhirConsentVerification.SetVerifiedST(value : Boolean);
begin
  if FVerified = nil then
    FVerified := TFhirBoolean.create;
  FVerified.value := value
end;

procedure TFhirConsentVerification.SetVerifiedWith(value : TFhirReference);
begin
  FVerifiedWith.free;
  FVerifiedWith := value;
end;

procedure TFhirConsentVerification.SetVerificationDate(value : TFhirDateTime);
begin
  FVerificationDate.free;
  FVerificationDate := value;
end;

function TFhirConsentVerification.GetVerificationDateST : TFslDateTime;
begin
  if FVerificationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FVerificationDate.value;
end;

procedure TFhirConsentVerification.SetVerificationDateST(value : TFslDateTime);
begin
  if FVerificationDate = nil then
    FVerificationDate := TFhirDateTime.create;
  FVerificationDate.value := value
end;

{ TFhirConsentVerificationListEnumerator }

constructor TFhirConsentVerificationListEnumerator.Create(list : TFhirConsentVerificationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentVerificationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentVerificationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentVerificationListEnumerator.GetCurrent : TFhirConsentVerification;
begin
  Result := FList[FIndex];
end;

function TFhirConsentVerificationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentVerificationList }

function TFhirConsentVerificationList.AddItem(value: TFhirConsentVerification): TFhirConsentVerification;
begin
  assert(value.ClassName = 'TFhirConsentVerification', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentVerification');
  add(value);
  result := value;
end;

function TFhirConsentVerificationList.Append: TFhirConsentVerification;
begin
  result := TFhirConsentVerification.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentVerificationList.ClearItems;
begin
  Clear;
end;

function TFhirConsentVerificationList.GetEnumerator : TFhirConsentVerificationListEnumerator;
begin
  result := TFhirConsentVerificationListEnumerator.Create(self.link);
end;

function TFhirConsentVerificationList.Clone: TFhirConsentVerificationList;
begin
  result := TFhirConsentVerificationList(inherited Clone);
end;

function TFhirConsentVerificationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentVerificationList.GetItemN(index: Integer): TFhirConsentVerification;
begin
  result := TFhirConsentVerification(ObjectByIndex[index]);
end;

function TFhirConsentVerificationList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentVerification;
end;
function TFhirConsentVerificationList.IndexOf(value: TFhirConsentVerification): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentVerificationList.Insert(index: Integer): TFhirConsentVerification;
begin
  result := TFhirConsentVerification.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentVerificationList.InsertItem(index: Integer; value: TFhirConsentVerification);
begin
  assert(value is TFhirConsentVerification);
  Inherited Insert(index, value);
end;

function TFhirConsentVerificationList.Item(index: Integer): TFhirConsentVerification;
begin
  result := TFhirConsentVerification(ObjectByIndex[index]);
end;

function TFhirConsentVerificationList.Link: TFhirConsentVerificationList;
begin
  result := TFhirConsentVerificationList(inherited Link);
end;

procedure TFhirConsentVerificationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentVerificationList.SetItemByIndex(index: Integer; value: TFhirConsentVerification);
begin
  assert(value is TFhirConsentVerification);
  FhirConsentVerifications[index] := value;
end;

procedure TFhirConsentVerificationList.SetItemN(index: Integer; value: TFhirConsentVerification);
begin
  assert(value is TFhirConsentVerification);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentProvision }

constructor TFhirConsentProvision.Create;
begin
  inherited;
end;

destructor TFhirConsentProvision.Destroy;
begin
  FType_.free;
  FPeriod.free;
  FActorList.Free;
  FActionList.Free;
  FSecurityLabelList.Free;
  FPurposeList.Free;
  FClass_List.Free;
  FCodeList.Free;
  FDataPeriod.free;
  FDataList.Free;
  FProvisionList.Free;
  inherited;
end;

procedure TFhirConsentProvision.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirConsentProvision(oSource).type_Element.Clone;
  period := TFhirConsentProvision(oSource).period.Clone;
  if (TFhirConsentProvision(oSource).FActorList = nil) then
  begin
    FActorList.free;
    FActorList := nil;
  end
  else
  begin
    if FActorList = nil then
      FActorList := TFhirConsentProvisionActorList.Create;
    FActorList.Assign(TFhirConsentProvision(oSource).FActorList);
  end;
  if (TFhirConsentProvision(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirCodeableConceptList.Create;
    FActionList.Assign(TFhirConsentProvision(oSource).FActionList);
  end;
  if (TFhirConsentProvision(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirCodingList.Create;
    FSecurityLabelList.Assign(TFhirConsentProvision(oSource).FSecurityLabelList);
  end;
  if (TFhirConsentProvision(oSource).FPurposeList = nil) then
  begin
    FPurposeList.free;
    FPurposeList := nil;
  end
  else
  begin
    if FPurposeList = nil then
      FPurposeList := TFhirCodingList.Create;
    FPurposeList.Assign(TFhirConsentProvision(oSource).FPurposeList);
  end;
  if (TFhirConsentProvision(oSource).FClass_List = nil) then
  begin
    FClass_List.free;
    FClass_List := nil;
  end
  else
  begin
    if FClass_List = nil then
      FClass_List := TFhirCodingList.Create;
    FClass_List.Assign(TFhirConsentProvision(oSource).FClass_List);
  end;
  if (TFhirConsentProvision(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirConsentProvision(oSource).FCodeList);
  end;
  dataPeriod := TFhirConsentProvision(oSource).dataPeriod.Clone;
  if (TFhirConsentProvision(oSource).FDataList = nil) then
  begin
    FDataList.free;
    FDataList := nil;
  end
  else
  begin
    if FDataList = nil then
      FDataList := TFhirConsentProvisionDataList.Create;
    FDataList.Assign(TFhirConsentProvision(oSource).FDataList);
  end;
  if (TFhirConsentProvision(oSource).FProvisionList = nil) then
  begin
    FProvisionList.free;
    FProvisionList := nil;
  end
  else
  begin
    if FProvisionList = nil then
      FProvisionList := TFhirConsentProvisionList.Create;
    FProvisionList.Assign(TFhirConsentProvision(oSource).FProvisionList);
  end;
end;

procedure TFhirConsentProvision.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'actor') Then
    list.addAll(self, 'actor', FActorList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'purpose') Then
    list.addAll(self, 'purpose', FPurposeList);
  if (child_name = 'class') Then
    list.addAll(self, 'class', FClass_List);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'dataPeriod') Then
     list.add(self.link, 'dataPeriod', FDataPeriod.Link);
  if (child_name = 'data') Then
    list.addAll(self, 'data', FDataList);
  if (child_name = 'provision') Then
    list.addAll(self, 'provision', FProvisionList);
end;

procedure TFhirConsentProvision.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'actor', 'BackboneElement', true, TFhirConsentProvisionActor, FActorList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'CodeableConcept', true, TFhirCodeableConcept, FActionList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'Coding', true, TFhirCoding, FSecurityLabelList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'Coding', true, TFhirCoding, FPurposeList.Link));
  oList.add(TFHIRProperty.create(self, 'class', 'Coding', true, TFhirCoding, FClass_List.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'dataPeriod', 'Period', false, TFhirPeriod, FDataPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'data', 'BackboneElement', true, TFhirConsentProvisionData, FDataList.Link));
  oList.add(TFHIRProperty.create(self, 'provision', '', true, TFhirConsentProvision, FProvisionList.Link));
end;

function TFhirConsentProvision.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirConsentProvisionTypeEnum, CODES_TFhirConsentProvisionTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'actor') then
  begin
    ActorList.add(propValue as TFhirConsentProvisionActor);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'class') then
  begin
    Class_List.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'dataPeriod') then
  begin
    DataPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'data') then
  begin
    DataList.add(propValue as TFhirConsentProvisionData);
    result := propValue;
  end
  else if (propName = 'provision') then
  begin
    ProvisionList.add(propValue as TFhirConsentProvision);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentProvision.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'actor') then ActorList.insertItem(index, propValue as TFhirConsentProvisionActor)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'purpose') then PurposeList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'class') then Class_List.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'data') then DataList.insertItem(index, propValue as TFhirConsentProvisionData)
  else if (propName = 'provision') then ProvisionList.insertItem(index, propValue as TFhirConsentProvision)
  else inherited;
end;

function TFhirConsentProvision.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirConsentProvisionTypeEnum[ConsentProvisionTypeNull], CODES_TFhirConsentProvisionTypeEnum[ConsentProvisionTypeNull]) 
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'actor') then result := ActorList.new()
  else if (propName = 'action') then result := ActionList.new()
  else if (propName = 'securityLabel') then result := SecurityLabelList.new()
  else if (propName = 'purpose') then result := PurposeList.new()
  else if (propName = 'class') then result := Class_List.new()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'dataPeriod') then result := TFhirPeriod.create()
  else if (propName = 'data') then result := DataList.new()
  else if (propName = 'provision') then result := ProvisionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentProvision.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'actor') then result := 'BackboneElement'
  else if (propName = 'action') then result := 'CodeableConcept'
  else if (propName = 'securityLabel') then result := 'Coding'
  else if (propName = 'purpose') then result := 'Coding'
  else if (propName = 'class') then result := 'Coding'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'dataPeriod') then result := 'Period'
  else if (propName = 'data') then result := 'BackboneElement'
  else if (propName = 'provision') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentProvision.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'actor') then deletePropertyValue('actor', ActorList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value)
  else if (propName = 'purpose') then deletePropertyValue('purpose', PurposeList, value)
  else if (propName = 'class') then deletePropertyValue('class', Class_List, value)
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'dataPeriod') then DataPeriodElement := nil
  else if (propName = 'data') then deletePropertyValue('data', DataList, value)
  else if (propName = 'provision') then deletePropertyValue('provision', ProvisionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentProvision.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirConsentProvisionTypeEnum, CODES_TFhirConsentProvisionTypeEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'actor') then replacePropertyValue('actor', ActorList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new)
  else if (propName = 'purpose') then replacePropertyValue('purpose', PurposeList, existing, new)
  else if (propName = 'class') then replacePropertyValue('class', Class_List, existing, new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'dataPeriod') then DataPeriodElement := new as TFhirPeriod
  else if (propName = 'data') then replacePropertyValue('data', DataList, existing, new)
  else if (propName = 'provision') then replacePropertyValue('provision', ProvisionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentProvision.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'actor') then ActorList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else if (propName = 'securityLabel') then SecurityLabelList.move(source, destination)
  else if (propName = 'purpose') then PurposeList.move(source, destination)
  else if (propName = 'class') then Class_List.move(source, destination)
  else if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'data') then DataList.move(source, destination)
  else if (propName = 'provision') then ProvisionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentProvision.fhirType : string;
begin
  result := 'Consent.provision';
end;

function TFhirConsentProvision.Link : TFhirConsentProvision;
begin
  result := TFhirConsentProvision(inherited Link);
end;

function TFhirConsentProvision.Clone : TFhirConsentProvision;
begin
  result := TFhirConsentProvision(inherited Clone);
end;

function TFhirConsentProvision.equals(other : TObject) : boolean; 
var
  o : TFhirConsentProvision;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentProvision)) then
    result := false
  else
  begin
    o := TFhirConsentProvision(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(actorList, o.actorList, true) and compareDeep(actionList, o.actionList, true) and 
      compareDeep(securityLabelList, o.securityLabelList, true) and compareDeep(purposeList, o.purposeList, true) and 
      compareDeep(class_List, o.class_List, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(dataPeriodElement, o.dataPeriodElement, true) and compareDeep(dataList, o.dataList, true) and 
      compareDeep(provisionList, o.provisionList, true);
  end;
end;

function TFhirConsentProvision.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FPeriod) and isEmptyProp(FactorList) and isEmptyProp(FactionList) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FpurposeList) and isEmptyProp(Fclass_List) and isEmptyProp(FcodeList) and isEmptyProp(FDataPeriod) and isEmptyProp(FdataList) and isEmptyProp(FprovisionList);
end;

procedure TFhirConsentProvision.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('period');
  fields.add('actor');
  fields.add('action');
  fields.add('securityLabel');
  fields.add('purpose');
  fields.add('class');
  fields.add('code');
  fields.add('dataPeriod');
  fields.add('data');
  fields.add('provision');
end;

function TFhirConsentProvision.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActorList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
  inc(result, FSecurityLabelList.sizeInBytes(magic));
  inc(result, FPurposeList.sizeInBytes(magic));
  inc(result, FClass_List.sizeInBytes(magic));
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FDataList.sizeInBytes(magic));
  inc(result, FProvisionList.sizeInBytes(magic));
end;

procedure TFhirConsentProvision.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirConsentProvision.GetType_ST : TFhirConsentProvisionTypeEnum;
begin
  if FType_ = nil then
    result := TFhirConsentProvisionTypeEnum(0)
  else
    result := TFhirConsentProvisionTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentProvisionTypeEnum, FType_.value));
end;

procedure TFhirConsentProvision.SetType_ST(value : TFhirConsentProvisionTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirConsentProvisionTypeEnum[value], CODES_TFhirConsentProvisionTypeEnum[value]);
end;

procedure TFhirConsentProvision.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirConsentProvision.GetActorList : TFhirConsentProvisionActorList;
begin
  if FActorList = nil then
    FActorList := TFhirConsentProvisionActorList.Create;
  result := FActorList;
end;

function TFhirConsentProvision.GetHasActorList : boolean;
begin
  result := (FActorList <> nil) and (FActorList.count > 0);
end;

function TFhirConsentProvision.GetActionList : TFhirCodeableConceptList;
begin
  if FActionList = nil then
    FActionList := TFhirCodeableConceptList.Create;
  result := FActionList;
end;

function TFhirConsentProvision.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirConsentProvision.GetSecurityLabelList : TFhirCodingList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirCodingList.Create;
  result := FSecurityLabelList;
end;

function TFhirConsentProvision.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

function TFhirConsentProvision.GetPurposeList : TFhirCodingList;
begin
  if FPurposeList = nil then
    FPurposeList := TFhirCodingList.Create;
  result := FPurposeList;
end;

function TFhirConsentProvision.GetHasPurposeList : boolean;
begin
  result := (FPurposeList <> nil) and (FPurposeList.count > 0);
end;

function TFhirConsentProvision.GetClass_List : TFhirCodingList;
begin
  if FClass_List = nil then
    FClass_List := TFhirCodingList.Create;
  result := FClass_List;
end;

function TFhirConsentProvision.GetHasClass_List : boolean;
begin
  result := (FClass_List <> nil) and (FClass_List.count > 0);
end;

function TFhirConsentProvision.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirConsentProvision.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

procedure TFhirConsentProvision.SetDataPeriod(value : TFhirPeriod);
begin
  FDataPeriod.free;
  FDataPeriod := value;
end;

function TFhirConsentProvision.GetDataList : TFhirConsentProvisionDataList;
begin
  if FDataList = nil then
    FDataList := TFhirConsentProvisionDataList.Create;
  result := FDataList;
end;

function TFhirConsentProvision.GetHasDataList : boolean;
begin
  result := (FDataList <> nil) and (FDataList.count > 0);
end;

function TFhirConsentProvision.GetProvisionList : TFhirConsentProvisionList;
begin
  if FProvisionList = nil then
    FProvisionList := TFhirConsentProvisionList.Create;
  result := FProvisionList;
end;

function TFhirConsentProvision.GetHasProvisionList : boolean;
begin
  result := (FProvisionList <> nil) and (FProvisionList.count > 0);
end;

{ TFhirConsentProvisionListEnumerator }

constructor TFhirConsentProvisionListEnumerator.Create(list : TFhirConsentProvisionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentProvisionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentProvisionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentProvisionListEnumerator.GetCurrent : TFhirConsentProvision;
begin
  Result := FList[FIndex];
end;

function TFhirConsentProvisionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentProvisionList }

function TFhirConsentProvisionList.AddItem(value: TFhirConsentProvision): TFhirConsentProvision;
begin
  assert(value.ClassName = 'TFhirConsentProvision', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentProvision');
  add(value);
  result := value;
end;

function TFhirConsentProvisionList.Append: TFhirConsentProvision;
begin
  result := TFhirConsentProvision.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionList.ClearItems;
begin
  Clear;
end;

function TFhirConsentProvisionList.GetEnumerator : TFhirConsentProvisionListEnumerator;
begin
  result := TFhirConsentProvisionListEnumerator.Create(self.link);
end;

function TFhirConsentProvisionList.Clone: TFhirConsentProvisionList;
begin
  result := TFhirConsentProvisionList(inherited Clone);
end;

function TFhirConsentProvisionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentProvisionList.GetItemN(index: Integer): TFhirConsentProvision;
begin
  result := TFhirConsentProvision(ObjectByIndex[index]);
end;

function TFhirConsentProvisionList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentProvision;
end;
function TFhirConsentProvisionList.IndexOf(value: TFhirConsentProvision): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentProvisionList.Insert(index: Integer): TFhirConsentProvision;
begin
  result := TFhirConsentProvision.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionList.InsertItem(index: Integer; value: TFhirConsentProvision);
begin
  assert(value is TFhirConsentProvision);
  Inherited Insert(index, value);
end;

function TFhirConsentProvisionList.Item(index: Integer): TFhirConsentProvision;
begin
  result := TFhirConsentProvision(ObjectByIndex[index]);
end;

function TFhirConsentProvisionList.Link: TFhirConsentProvisionList;
begin
  result := TFhirConsentProvisionList(inherited Link);
end;

procedure TFhirConsentProvisionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentProvisionList.SetItemByIndex(index: Integer; value: TFhirConsentProvision);
begin
  assert(value is TFhirConsentProvision);
  FhirConsentProvisions[index] := value;
end;

procedure TFhirConsentProvisionList.SetItemN(index: Integer; value: TFhirConsentProvision);
begin
  assert(value is TFhirConsentProvision);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentProvisionActor }

constructor TFhirConsentProvisionActor.Create;
begin
  inherited;
end;

destructor TFhirConsentProvisionActor.Destroy;
begin
  FRole.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentProvisionActor.Assign(oSource : TFslObject);
begin
  inherited;
  role := TFhirConsentProvisionActor(oSource).role.Clone;
  reference := TFhirConsentProvisionActor(oSource).reference.Clone;
end;

procedure TFhirConsentProvisionActor.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentProvisionActor.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
end;

function TFhirConsentProvisionActor.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentProvisionActor.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentProvisionActor.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirCodeableConcept.create()
  else if (propName = 'reference') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentProvisionActor.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentProvisionActor.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentProvisionActor.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentProvisionActor.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentProvisionActor.fhirType : string;
begin
  result := 'Consent.provision.actor';
end;

function TFhirConsentProvisionActor.Link : TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(inherited Link);
end;

function TFhirConsentProvisionActor.Clone : TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(inherited Clone);
end;

function TFhirConsentProvisionActor.equals(other : TObject) : boolean; 
var
  o : TFhirConsentProvisionActor;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentProvisionActor)) then
    result := false
  else
  begin
    o := TFhirConsentProvisionActor(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentProvisionActor.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FReference);
end;

procedure TFhirConsentProvisionActor.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('reference');
end;

function TFhirConsentProvisionActor.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirConsentProvisionActor.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

procedure TFhirConsentProvisionActor.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

{ TFhirConsentProvisionActorListEnumerator }

constructor TFhirConsentProvisionActorListEnumerator.Create(list : TFhirConsentProvisionActorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentProvisionActorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentProvisionActorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentProvisionActorListEnumerator.GetCurrent : TFhirConsentProvisionActor;
begin
  Result := FList[FIndex];
end;

function TFhirConsentProvisionActorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentProvisionActorList }

function TFhirConsentProvisionActorList.AddItem(value: TFhirConsentProvisionActor): TFhirConsentProvisionActor;
begin
  assert(value.ClassName = 'TFhirConsentProvisionActor', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentProvisionActor');
  add(value);
  result := value;
end;

function TFhirConsentProvisionActorList.Append: TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionActorList.ClearItems;
begin
  Clear;
end;

function TFhirConsentProvisionActorList.GetEnumerator : TFhirConsentProvisionActorListEnumerator;
begin
  result := TFhirConsentProvisionActorListEnumerator.Create(self.link);
end;

function TFhirConsentProvisionActorList.Clone: TFhirConsentProvisionActorList;
begin
  result := TFhirConsentProvisionActorList(inherited Clone);
end;

function TFhirConsentProvisionActorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentProvisionActorList.GetItemN(index: Integer): TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(ObjectByIndex[index]);
end;

function TFhirConsentProvisionActorList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentProvisionActor;
end;
function TFhirConsentProvisionActorList.IndexOf(value: TFhirConsentProvisionActor): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentProvisionActorList.Insert(index: Integer): TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionActorList.InsertItem(index: Integer; value: TFhirConsentProvisionActor);
begin
  assert(value is TFhirConsentProvisionActor);
  Inherited Insert(index, value);
end;

function TFhirConsentProvisionActorList.Item(index: Integer): TFhirConsentProvisionActor;
begin
  result := TFhirConsentProvisionActor(ObjectByIndex[index]);
end;

function TFhirConsentProvisionActorList.Link: TFhirConsentProvisionActorList;
begin
  result := TFhirConsentProvisionActorList(inherited Link);
end;

procedure TFhirConsentProvisionActorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentProvisionActorList.SetItemByIndex(index: Integer; value: TFhirConsentProvisionActor);
begin
  assert(value is TFhirConsentProvisionActor);
  FhirConsentProvisionActors[index] := value;
end;

procedure TFhirConsentProvisionActorList.SetItemN(index: Integer; value: TFhirConsentProvisionActor);
begin
  assert(value is TFhirConsentProvisionActor);
  ObjectByIndex[index] := value;
end;

{ TFhirConsentProvisionData }

constructor TFhirConsentProvisionData.Create;
begin
  inherited;
end;

destructor TFhirConsentProvisionData.Destroy;
begin
  FMeaning.free;
  FReference.free;
  inherited;
end;

procedure TFhirConsentProvisionData.Assign(oSource : TFslObject);
begin
  inherited;
  meaningElement := TFhirConsentProvisionData(oSource).meaningElement.Clone;
  reference := TFhirConsentProvisionData(oSource).reference.Clone;
end;

procedure TFhirConsentProvisionData.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'meaning') Then
     list.add(self.link, 'meaning', FMeaning.Link);
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
end;

procedure TFhirConsentProvisionData.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'meaning', 'code', false, TFhirEnum, FMeaning.Link));
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
end;

function TFhirConsentProvisionData.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'meaning') then
  begin
    MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, propValue);
    result := propValue;
  end
  else if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsentProvisionData.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirConsentProvisionData.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'meaning') then result := TFhirEnum.create(SYSTEMS_TFhirConsentDataMeaningEnum[ConsentDataMeaningNull], CODES_TFhirConsentDataMeaningEnum[ConsentDataMeaningNull]) 
  else if (propName = 'reference') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsentProvisionData.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'meaning') then result := 'code'
  else if (propName = 'reference') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsentProvisionData.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := nil
  else if (propName = 'reference') then ReferenceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsentProvisionData.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'meaning') then MeaningElement := asEnum(SYSTEMS_TFhirConsentDataMeaningEnum, CODES_TFhirConsentDataMeaningEnum, new)
  else if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsentProvisionData.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirConsentProvisionData.fhirType : string;
begin
  result := 'Consent.provision.data';
end;

function TFhirConsentProvisionData.Link : TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(inherited Link);
end;

function TFhirConsentProvisionData.Clone : TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(inherited Clone);
end;

function TFhirConsentProvisionData.equals(other : TObject) : boolean; 
var
  o : TFhirConsentProvisionData;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsentProvisionData)) then
    result := false
  else
  begin
    o := TFhirConsentProvisionData(other);
    result := compareDeep(meaningElement, o.meaningElement, true) and compareDeep(referenceElement, o.referenceElement, true);
  end;
end;

function TFhirConsentProvisionData.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeaning) and isEmptyProp(FReference);
end;

procedure TFhirConsentProvisionData.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('meaning');
  fields.add('reference');
end;

function TFhirConsentProvisionData.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirConsentProvisionData.SetMeaning(value : TFhirEnum);
begin
  FMeaning.free;
  FMeaning := value;
end;

function TFhirConsentProvisionData.GetMeaningST : TFhirConsentDataMeaningEnum;
begin
  if FMeaning = nil then
    result := TFhirConsentDataMeaningEnum(0)
  else
    result := TFhirConsentDataMeaningEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentDataMeaningEnum, FMeaning.value));
end;

procedure TFhirConsentProvisionData.SetMeaningST(value : TFhirConsentDataMeaningEnum);
begin
  if ord(value) = 0 then
    MeaningElement := nil
  else
    MeaningElement := TFhirEnum.create(SYSTEMS_TFhirConsentDataMeaningEnum[value], CODES_TFhirConsentDataMeaningEnum[value]);
end;

procedure TFhirConsentProvisionData.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

{ TFhirConsentProvisionDataListEnumerator }

constructor TFhirConsentProvisionDataListEnumerator.Create(list : TFhirConsentProvisionDataList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentProvisionDataListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentProvisionDataListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentProvisionDataListEnumerator.GetCurrent : TFhirConsentProvisionData;
begin
  Result := FList[FIndex];
end;

function TFhirConsentProvisionDataListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentProvisionDataList }

function TFhirConsentProvisionDataList.AddItem(value: TFhirConsentProvisionData): TFhirConsentProvisionData;
begin
  assert(value.ClassName = 'TFhirConsentProvisionData', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsentProvisionData');
  add(value);
  result := value;
end;

function TFhirConsentProvisionDataList.Append: TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionDataList.ClearItems;
begin
  Clear;
end;

function TFhirConsentProvisionDataList.GetEnumerator : TFhirConsentProvisionDataListEnumerator;
begin
  result := TFhirConsentProvisionDataListEnumerator.Create(self.link);
end;

function TFhirConsentProvisionDataList.Clone: TFhirConsentProvisionDataList;
begin
  result := TFhirConsentProvisionDataList(inherited Clone);
end;

function TFhirConsentProvisionDataList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentProvisionDataList.GetItemN(index: Integer): TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(ObjectByIndex[index]);
end;

function TFhirConsentProvisionDataList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsentProvisionData;
end;
function TFhirConsentProvisionDataList.IndexOf(value: TFhirConsentProvisionData): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentProvisionDataList.Insert(index: Integer): TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentProvisionDataList.InsertItem(index: Integer; value: TFhirConsentProvisionData);
begin
  assert(value is TFhirConsentProvisionData);
  Inherited Insert(index, value);
end;

function TFhirConsentProvisionDataList.Item(index: Integer): TFhirConsentProvisionData;
begin
  result := TFhirConsentProvisionData(ObjectByIndex[index]);
end;

function TFhirConsentProvisionDataList.Link: TFhirConsentProvisionDataList;
begin
  result := TFhirConsentProvisionDataList(inherited Link);
end;

procedure TFhirConsentProvisionDataList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentProvisionDataList.SetItemByIndex(index: Integer; value: TFhirConsentProvisionData);
begin
  assert(value is TFhirConsentProvisionData);
  FhirConsentProvisionData[index] := value;
end;

procedure TFhirConsentProvisionDataList.SetItemN(index: Integer; value: TFhirConsentProvisionData);
begin
  assert(value is TFhirConsentProvisionData);
  ObjectByIndex[index] := value;
end;

{ TFhirConsent }

constructor TFhirConsent.Create;
begin
  inherited;
end;

destructor TFhirConsent.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FScope.free;
  FCategoryList.Free;
  FPatient.free;
  FDateTime.free;
  FPerformerList.Free;
  FOrganizationList.Free;
  FSource.free;
  FPolicyList.Free;
  FPolicyRule.free;
  FVerificationList.Free;
  FProvision.free;
  inherited;
end;

procedure TFhirConsent.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirConsent(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirConsent(oSource).FIdentifierList);
  end;
  statusElement := TFhirConsent(oSource).statusElement.Clone;
  scope := TFhirConsent(oSource).scope.Clone;
  if (TFhirConsent(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirConsent(oSource).FCategoryList);
  end;
  patient := TFhirConsent(oSource).patient.Clone;
  dateTimeElement := TFhirConsent(oSource).dateTimeElement.Clone;
  if (TFhirConsent(oSource).FPerformerList = nil) then
  begin
    FPerformerList.free;
    FPerformerList := nil;
  end
  else
  begin
    if FPerformerList = nil then
      FPerformerList := TFhirReferenceList.Create;
    FPerformerList.Assign(TFhirConsent(oSource).FPerformerList);
  end;
  if (TFhirConsent(oSource).FOrganizationList = nil) then
  begin
    FOrganizationList.free;
    FOrganizationList := nil;
  end
  else
  begin
    if FOrganizationList = nil then
      FOrganizationList := TFhirReferenceList.Create;
    FOrganizationList.Assign(TFhirConsent(oSource).FOrganizationList);
  end;
  source := TFhirConsent(oSource).source.Clone;
  if (TFhirConsent(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirConsentPolicyList.Create;
    FPolicyList.Assign(TFhirConsent(oSource).FPolicyList);
  end;
  policyRule := TFhirConsent(oSource).policyRule.Clone;
  if (TFhirConsent(oSource).FVerificationList = nil) then
  begin
    FVerificationList.free;
    FVerificationList := nil;
  end
  else
  begin
    if FVerificationList = nil then
      FVerificationList := TFhirConsentVerificationList.Create;
    FVerificationList.Assign(TFhirConsent(oSource).FVerificationList);
  end;
  provision := TFhirConsent(oSource).provision.Clone;
end;

function TFhirConsent.GetResourceType : TFhirResourceType;
begin
  result := frtConsent;
end;

procedure TFhirConsent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'patient') Then
     list.add(self.link, 'patient', FPatient.Link);
  if (child_name = 'dateTime') Then
     list.add(self.link, 'dateTime', FDateTime.Link);
  if (child_name = 'performer') Then
    list.addAll(self, 'performer', FPerformerList);
  if (child_name = 'organization') Then
    list.addAll(self, 'organization', FOrganizationList);
  if (child_name = 'source[x]') or (child_name = 'source') Then
     list.add(self.link, 'source[x]', FSource.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'policyRule') Then
     list.add(self.link, 'policyRule', FPolicyRule.Link);
  if (child_name = 'verification') Then
    list.addAll(self, 'verification', FVerificationList);
  if (child_name = 'provision') Then
     list.add(self.link, 'provision', FProvision.Link);
end;

procedure TFhirConsent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'scope', 'CodeableConcept', false, TFhirCodeableConcept, FScope.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'patient', 'Reference', false, TFhirReference, FPatient.Link));
  oList.add(TFHIRProperty.create(self, 'dateTime', 'dateTime', false, TFhirDateTime, FDateTime.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', true, TFhirReference, FPerformerList.Link));
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', true, TFhirReference, FOrganizationList.Link));
  oList.add(TFHIRProperty.create(self, 'source[x]', 'Attachment|Reference', false, TFhirDataType, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'policy', 'BackboneElement', true, TFhirConsentPolicy, FPolicyList.Link));
  oList.add(TFHIRProperty.create(self, 'policyRule', 'CodeableConcept', false, TFhirCodeableConcept, FPolicyRule.Link));
  oList.add(TFHIRProperty.create(self, 'verification', 'BackboneElement', true, TFhirConsentVerification, FVerificationList.Link));
  oList.add(TFHIRProperty.create(self, 'provision', 'BackboneElement', false, TFhirConsentProvision, FProvision.Link));
end;

function TFhirConsent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirConsentStateEnum, CODES_TFhirConsentStateEnum, propValue);
    result := propValue;
  end
  else if (propName = 'scope') then
  begin
    Scope := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'patient') then
  begin
    Patient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'dateTime') then
  begin
    DateTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    PerformerList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'organization') then
  begin
    OrganizationList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (isMatchingName(propName, 'source', ['Attachment', 'Reference'])) then
  begin
    Source := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(propValue as TFhirConsentPolicy);
    result := propValue;
  end
  else if (propName = 'policyRule') then
  begin
    PolicyRule := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'verification') then
  begin
    VerificationList.add(propValue as TFhirConsentVerification);
    result := propValue;
  end
  else if (propName = 'provision') then
  begin
    Provision := propValue as TFhirConsentProvision;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirConsent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'performer') then PerformerList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'organization') then OrganizationList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'policy') then PolicyList.insertItem(index, propValue as TFhirConsentPolicy)
  else if (propName = 'verification') then VerificationList.insertItem(index, propValue as TFhirConsentVerification)
  else inherited;
end;

function TFhirConsent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirConsentStateEnum[ConsentStateNull], CODES_TFhirConsentStateEnum[ConsentStateNull]) 
  else if (propName = 'scope') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'patient') then result := TFhirReference.create()
  else if (propName = 'dateTime') then result := TFhirDateTime.create()
  else if (propName = 'performer') then result := PerformerList.new()
  else if (propName = 'organization') then result := OrganizationList.new()
  else if (isMatchingName(propName, 'source', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Source')
  else if (propName = 'policy') then result := PolicyList.new()
  else if (propName = 'policyRule') then result := TFhirCodeableConcept.create()
  else if (propName = 'verification') then result := VerificationList.new()
  else if (propName = 'provision') then result := TFhirConsentProvision.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirConsent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'scope') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'patient') then result := 'Reference'
  else if (propName = 'dateTime') then result := 'dateTime'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'organization') then result := 'Reference'
  else if (propName = 'source[x]') then result := 'Attachment|Reference'
  else if (propName = 'policy') then result := 'BackboneElement'
  else if (propName = 'policyRule') then result := 'CodeableConcept'
  else if (propName = 'verification') then result := 'BackboneElement'
  else if (propName = 'provision') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirConsent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'scope') then ScopeElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'patient') then PatientElement := nil
  else if (propName = 'dateTime') then DateTimeElement := nil
  else if (propName = 'performer') then deletePropertyValue('performer', PerformerList, value)
  else if (propName = 'organization') then deletePropertyValue('organization', OrganizationList, value)
  else if (isMatchingName(propName, 'source', ['Attachment', 'Reference'])) then SourceElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value)
  else if (propName = 'policyRule') then PolicyRuleElement := nil
  else if (propName = 'verification') then deletePropertyValue('verification', VerificationList, value)
  else if (propName = 'provision') then ProvisionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirConsent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirConsentStateEnum, CODES_TFhirConsentStateEnum, new)
  else if (propName = 'scope') then ScopeElement := new as TFhirCodeableConcept
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'patient') then PatientElement := new as TFhirReference
  else if (propName = 'dateTime') then DateTimeElement := asDateTime(new)
  else if (propName = 'performer') then replacePropertyValue('performer', PerformerList, existing, new)
  else if (propName = 'organization') then replacePropertyValue('organization', OrganizationList, existing, new)
  else if (isMatchingName(propName, 'source', ['Attachment', 'Reference'])) then SourceElement := new as TFhirDataType
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new)
  else if (propName = 'policyRule') then PolicyRuleElement := new as TFhirCodeableConcept
  else if (propName = 'verification') then replacePropertyValue('verification', VerificationList, existing, new)
  else if (propName = 'provision') then ProvisionElement := new as TFhirConsentProvision
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirConsent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'performer') then PerformerList.move(source, destination)
  else if (propName = 'organization') then OrganizationList.move(source, destination)
  else if (propName = 'policy') then PolicyList.move(source, destination)
  else if (propName = 'verification') then VerificationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirConsent.fhirType : string;
begin
  result := 'Consent';
end;

function TFhirConsent.Link : TFhirConsent;
begin
  result := TFhirConsent(inherited Link);
end;

function TFhirConsent.Clone : TFhirConsent;
begin
  result := TFhirConsent(inherited Clone);
end;

function TFhirConsent.equals(other : TObject) : boolean; 
var
  o : TFhirConsent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirConsent)) then
    result := false
  else
  begin
    o := TFhirConsent(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(scopeElement, o.scopeElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(patientElement, o.patientElement, true) and compareDeep(dateTimeElement, o.dateTimeElement, true) and 
      compareDeep(performerList, o.performerList, true) and compareDeep(organizationList, o.organizationList, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(policyList, o.policyList, true) and 
      compareDeep(policyRuleElement, o.policyRuleElement, true) and compareDeep(verificationList, o.verificationList, true) and 
      compareDeep(provisionElement, o.provisionElement, true);
  end;
end;

function TFhirConsent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FScope) and isEmptyProp(FcategoryList) and isEmptyProp(FPatient) and isEmptyProp(FDateTime) and isEmptyProp(FperformerList) and isEmptyProp(ForganizationList) and isEmptyProp(FSource) and isEmptyProp(FpolicyList) and isEmptyProp(FPolicyRule) and isEmptyProp(FverificationList) and isEmptyProp(FProvision);
end;

procedure TFhirConsent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('scope');
  fields.add('category');
  fields.add('patient');
  fields.add('dateTime');
  fields.add('performer');
  fields.add('organization');
  fields.add('source[x]');
  fields.add('policy');
  fields.add('policyRule');
  fields.add('verification');
  fields.add('provision');
end;

function TFhirConsent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FPerformerList.sizeInBytes(magic));
  inc(result, FOrganizationList.sizeInBytes(magic));
  inc(result, FPolicyList.sizeInBytes(magic));
  inc(result, FVerificationList.sizeInBytes(magic));
end;

function TFhirConsent.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirConsent.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirConsent.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirConsent.GetStatusST : TFhirConsentStateEnum;
begin
  if FStatus = nil then
    result := TFhirConsentStateEnum(0)
  else
    result := TFhirConsentStateEnum(StringArrayIndexOfSensitive(CODES_TFhirConsentStateEnum, FStatus.value));
end;

procedure TFhirConsent.SetStatusST(value : TFhirConsentStateEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirConsentStateEnum[value], CODES_TFhirConsentStateEnum[value]);
end;

procedure TFhirConsent.SetScope(value : TFhirCodeableConcept);
begin
  FScope.free;
  FScope := value;
end;

function TFhirConsent.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirConsent.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

procedure TFhirConsent.SetPatient(value : TFhirReference);
begin
  FPatient.free;
  FPatient := value;
end;

procedure TFhirConsent.SetDateTime(value : TFhirDateTime);
begin
  FDateTime.free;
  FDateTime := value;
end;

function TFhirConsent.GetDateTimeST : TFslDateTime;
begin
  if FDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FDateTime.value;
end;

procedure TFhirConsent.SetDateTimeST(value : TFslDateTime);
begin
  if FDateTime = nil then
    FDateTime := TFhirDateTime.create;
  FDateTime.value := value
end;

function TFhirConsent.GetPerformerList : TFhirReferenceList;
begin
  if FPerformerList = nil then
    FPerformerList := TFhirReferenceList.Create;
  result := FPerformerList;
end;

function TFhirConsent.GetHasPerformerList : boolean;
begin
  result := (FPerformerList <> nil) and (FPerformerList.count > 0);
end;

function TFhirConsent.GetOrganizationList : TFhirReferenceList;
begin
  if FOrganizationList = nil then
    FOrganizationList := TFhirReferenceList.Create;
  result := FOrganizationList;
end;

function TFhirConsent.GetHasOrganizationList : boolean;
begin
  result := (FOrganizationList <> nil) and (FOrganizationList.count > 0);
end;

procedure TFhirConsent.SetSource(value : TFhirDataType);
begin
  FSource.free;
  FSource := value;
end;

function TFhirConsent.GetPolicyList : TFhirConsentPolicyList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirConsentPolicyList.Create;
  result := FPolicyList;
end;

function TFhirConsent.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

procedure TFhirConsent.SetPolicyRule(value : TFhirCodeableConcept);
begin
  FPolicyRule.free;
  FPolicyRule := value;
end;

function TFhirConsent.GetVerificationList : TFhirConsentVerificationList;
begin
  if FVerificationList = nil then
    FVerificationList := TFhirConsentVerificationList.Create;
  result := FVerificationList;
end;

function TFhirConsent.GetHasVerificationList : boolean;
begin
  result := (FVerificationList <> nil) and (FVerificationList.count > 0);
end;

procedure TFhirConsent.SetProvision(value : TFhirConsentProvision);
begin
  FProvision.free;
  FProvision := value;
end;

{ TFhirConsentListEnumerator }

constructor TFhirConsentListEnumerator.Create(list : TFhirConsentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirConsentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirConsentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirConsentListEnumerator.GetCurrent : TFhirConsent;
begin
  Result := FList[FIndex];
end;

function TFhirConsentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirConsentList }

function TFhirConsentList.AddItem(value: TFhirConsent): TFhirConsent;
begin
  assert(value.ClassName = 'TFhirConsent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirConsent');
  add(value);
  result := value;
end;

function TFhirConsentList.Append: TFhirConsent;
begin
  result := TFhirConsent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentList.ClearItems;
begin
  Clear;
end;

function TFhirConsentList.GetEnumerator : TFhirConsentListEnumerator;
begin
  result := TFhirConsentListEnumerator.Create(self.link);
end;

function TFhirConsentList.Clone: TFhirConsentList;
begin
  result := TFhirConsentList(inherited Clone);
end;

function TFhirConsentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirConsentList.GetItemN(index: Integer): TFhirConsent;
begin
  result := TFhirConsent(ObjectByIndex[index]);
end;

function TFhirConsentList.ItemClass: TFslObjectClass;
begin
  result := TFhirConsent;
end;
function TFhirConsentList.IndexOf(value: TFhirConsent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirConsentList.Insert(index: Integer): TFhirConsent;
begin
  result := TFhirConsent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirConsentList.InsertItem(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  Inherited Insert(index, value);
end;

function TFhirConsentList.Item(index: Integer): TFhirConsent;
begin
  result := TFhirConsent(ObjectByIndex[index]);
end;

function TFhirConsentList.Link: TFhirConsentList;
begin
  result := TFhirConsentList(inherited Link);
end;

procedure TFhirConsentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirConsentList.SetItemByIndex(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  FhirConsents[index] := value;
end;

procedure TFhirConsentList.SetItemN(index: Integer; value: TFhirConsent);
begin
  assert(value is TFhirConsent);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONSENT}
{$IFDEF FHIR_CONTRACT}
{ TFhirContractContentDefinition }

constructor TFhirContractContentDefinition.Create;
begin
  inherited;
end;

destructor TFhirContractContentDefinition.Destroy;
begin
  FType_.free;
  FSubType.free;
  FPublisher.free;
  FPublicationDate.free;
  FPublicationStatus.free;
  FCopyright.free;
  inherited;
end;

procedure TFhirContractContentDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirContractContentDefinition(oSource).type_.Clone;
  subType := TFhirContractContentDefinition(oSource).subType.Clone;
  publisher := TFhirContractContentDefinition(oSource).publisher.Clone;
  publicationDateElement := TFhirContractContentDefinition(oSource).publicationDateElement.Clone;
  publicationStatusElement := TFhirContractContentDefinition(oSource).publicationStatusElement.Clone;
  copyrightElement := TFhirContractContentDefinition(oSource).copyrightElement.Clone;
end;

procedure TFhirContractContentDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'publicationDate') Then
     list.add(self.link, 'publicationDate', FPublicationDate.Link);
  if (child_name = 'publicationStatus') Then
     list.add(self.link, 'publicationStatus', FPublicationStatus.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
end;

procedure TFhirContractContentDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'Reference', false, TFhirReference, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'publicationDate', 'dateTime', false, TFhirDateTime, FPublicationDate.Link));
  oList.add(TFHIRProperty.create(self, 'publicationStatus', 'code', false, TFhirEnum, FPublicationStatus.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
end;

function TFhirContractContentDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    Publisher := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'publicationDate') then
  begin
    PublicationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publicationStatus') then
  begin
    PublicationStatusElement := asEnum(SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum, CODES_TFhirContractResourcePublicationStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractContentDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractContentDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subType') then result := TFhirCodeableConcept.create()
  else if (propName = 'publisher') then result := TFhirReference.create()
  else if (propName = 'publicationDate') then result := TFhirDateTime.create()
  else if (propName = 'publicationStatus') then result := TFhirEnum.create(SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum[ContractResourcePublicationStatusCodesNull], CODES_TFhirContractResourcePublicationStatusCodesEnum[ContractResourcePublicationStatusCodesNull]) 
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractContentDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'publisher') then result := 'Reference'
  else if (propName = 'publicationDate') then result := 'dateTime'
  else if (propName = 'publicationStatus') then result := 'code'
  else if (propName = 'copyright') then result := 'markdown'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractContentDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'publicationDate') then PublicationDateElement := nil
  else if (propName = 'publicationStatus') then PublicationStatusElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractContentDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept
  else if (propName = 'publisher') then PublisherElement := new as TFhirReference
  else if (propName = 'publicationDate') then PublicationDateElement := asDateTime(new)
  else if (propName = 'publicationStatus') then PublicationStatusElement := asEnum(SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum, CODES_TFhirContractResourcePublicationStatusCodesEnum, new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractContentDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractContentDefinition.fhirType : string;
begin
  result := 'Contract.contentDefinition';
end;

function TFhirContractContentDefinition.Link : TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(inherited Link);
end;

function TFhirContractContentDefinition.Clone : TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(inherited Clone);
end;

function TFhirContractContentDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirContractContentDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractContentDefinition)) then
    result := false
  else
  begin
    o := TFhirContractContentDefinition(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(publicationDateElement, o.publicationDateElement, true) and 
      compareDeep(publicationStatusElement, o.publicationStatusElement, true) and compareDeep(copyrightElement, o.copyrightElement, true);
  end;
end;

function TFhirContractContentDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FPublisher) and isEmptyProp(FPublicationDate) and isEmptyProp(FPublicationStatus) and isEmptyProp(FCopyright);
end;

procedure TFhirContractContentDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('subType');
  fields.add('publisher');
  fields.add('publicationDate');
  fields.add('publicationStatus');
  fields.add('copyright');
end;

function TFhirContractContentDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractContentDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirContractContentDefinition.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

procedure TFhirContractContentDefinition.SetPublisher(value : TFhirReference);
begin
  FPublisher.free;
  FPublisher := value;
end;

procedure TFhirContractContentDefinition.SetPublicationDate(value : TFhirDateTime);
begin
  FPublicationDate.free;
  FPublicationDate := value;
end;

function TFhirContractContentDefinition.GetPublicationDateST : TFslDateTime;
begin
  if FPublicationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPublicationDate.value;
end;

procedure TFhirContractContentDefinition.SetPublicationDateST(value : TFslDateTime);
begin
  if FPublicationDate = nil then
    FPublicationDate := TFhirDateTime.create;
  FPublicationDate.value := value
end;

procedure TFhirContractContentDefinition.SetPublicationStatus(value : TFhirEnum);
begin
  FPublicationStatus.free;
  FPublicationStatus := value;
end;

function TFhirContractContentDefinition.GetPublicationStatusST : TFhirContractResourcePublicationStatusCodesEnum;
begin
  if FPublicationStatus = nil then
    result := TFhirContractResourcePublicationStatusCodesEnum(0)
  else
    result := TFhirContractResourcePublicationStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirContractResourcePublicationStatusCodesEnum, FPublicationStatus.value));
end;

procedure TFhirContractContentDefinition.SetPublicationStatusST(value : TFhirContractResourcePublicationStatusCodesEnum);
begin
  if ord(value) = 0 then
    PublicationStatusElement := nil
  else
    PublicationStatusElement := TFhirEnum.create(SYSTEMS_TFhirContractResourcePublicationStatusCodesEnum[value], CODES_TFhirContractResourcePublicationStatusCodesEnum[value]);
end;

procedure TFhirContractContentDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirContractContentDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirContractContentDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

{ TFhirContractContentDefinitionListEnumerator }

constructor TFhirContractContentDefinitionListEnumerator.Create(list : TFhirContractContentDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractContentDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractContentDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractContentDefinitionListEnumerator.GetCurrent : TFhirContractContentDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirContractContentDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractContentDefinitionList }

function TFhirContractContentDefinitionList.AddItem(value: TFhirContractContentDefinition): TFhirContractContentDefinition;
begin
  assert(value.ClassName = 'TFhirContractContentDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractContentDefinition');
  add(value);
  result := value;
end;

function TFhirContractContentDefinitionList.Append: TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractContentDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirContractContentDefinitionList.GetEnumerator : TFhirContractContentDefinitionListEnumerator;
begin
  result := TFhirContractContentDefinitionListEnumerator.Create(self.link);
end;

function TFhirContractContentDefinitionList.Clone: TFhirContractContentDefinitionList;
begin
  result := TFhirContractContentDefinitionList(inherited Clone);
end;

function TFhirContractContentDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractContentDefinitionList.GetItemN(index: Integer): TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(ObjectByIndex[index]);
end;

function TFhirContractContentDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractContentDefinition;
end;
function TFhirContractContentDefinitionList.IndexOf(value: TFhirContractContentDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractContentDefinitionList.Insert(index: Integer): TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractContentDefinitionList.InsertItem(index: Integer; value: TFhirContractContentDefinition);
begin
  assert(value is TFhirContractContentDefinition);
  Inherited Insert(index, value);
end;

function TFhirContractContentDefinitionList.Item(index: Integer): TFhirContractContentDefinition;
begin
  result := TFhirContractContentDefinition(ObjectByIndex[index]);
end;

function TFhirContractContentDefinitionList.Link: TFhirContractContentDefinitionList;
begin
  result := TFhirContractContentDefinitionList(inherited Link);
end;

procedure TFhirContractContentDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractContentDefinitionList.SetItemByIndex(index: Integer; value: TFhirContractContentDefinition);
begin
  assert(value is TFhirContractContentDefinition);
  FhirContractContentDefinitions[index] := value;
end;

procedure TFhirContractContentDefinitionList.SetItemN(index: Integer; value: TFhirContractContentDefinition);
begin
  assert(value is TFhirContractContentDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTerm }

constructor TFhirContractTerm.Create;
begin
  inherited;
end;

destructor TFhirContractTerm.Destroy;
begin
  FIdentifier.free;
  FIssued.free;
  FApplies.free;
  FTopic.free;
  FType_.free;
  FSubType.free;
  FText.free;
  FSecurityLabelList.Free;
  FOffer.free;
  FAssetList.Free;
  FActionList.Free;
  FGroupList.Free;
  inherited;
end;

procedure TFhirContractTerm.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirContractTerm(oSource).identifier.Clone;
  issuedElement := TFhirContractTerm(oSource).issuedElement.Clone;
  applies := TFhirContractTerm(oSource).applies.Clone;
  topic := TFhirContractTerm(oSource).topic.Clone;
  type_ := TFhirContractTerm(oSource).type_.Clone;
  subType := TFhirContractTerm(oSource).subType.Clone;
  textElement := TFhirContractTerm(oSource).textElement.Clone;
  if (TFhirContractTerm(oSource).FSecurityLabelList = nil) then
  begin
    FSecurityLabelList.free;
    FSecurityLabelList := nil;
  end
  else
  begin
    if FSecurityLabelList = nil then
      FSecurityLabelList := TFhirContractTermSecurityLabelList.Create;
    FSecurityLabelList.Assign(TFhirContractTerm(oSource).FSecurityLabelList);
  end;
  offer := TFhirContractTerm(oSource).offer.Clone;
  if (TFhirContractTerm(oSource).FAssetList = nil) then
  begin
    FAssetList.free;
    FAssetList := nil;
  end
  else
  begin
    if FAssetList = nil then
      FAssetList := TFhirContractTermAssetList.Create;
    FAssetList.Assign(TFhirContractTerm(oSource).FAssetList);
  end;
  if (TFhirContractTerm(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirContractTermActionList.Create;
    FActionList.Assign(TFhirContractTerm(oSource).FActionList);
  end;
  if (TFhirContractTerm(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirContractTermList.Create;
    FGroupList.Assign(TFhirContractTerm(oSource).FGroupList);
  end;
end;

procedure TFhirContractTerm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'topic[x]') or (child_name = 'topic') Then
     list.add(self.link, 'topic[x]', FTopic.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
     list.add(self.link, 'subType', FSubType.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'securityLabel') Then
    list.addAll(self, 'securityLabel', FSecurityLabelList);
  if (child_name = 'offer') Then
     list.add(self.link, 'offer', FOffer.Link);
  if (child_name = 'asset') Then
    list.addAll(self, 'asset', FAssetList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
end;

procedure TFhirContractTerm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));
  oList.add(TFHIRProperty.create(self, 'topic[x]', 'CodeableConcept|Reference', false, TFhirDataType, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', false, TFhirCodeableConcept, FSubType.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabel', 'BackboneElement', true, TFhirContractTermSecurityLabel, FSecurityLabelList.Link));
  oList.add(TFHIRProperty.create(self, 'offer', 'BackboneElement', false, TFhirContractTermOffer, FOffer.Link));
  oList.add(TFHIRProperty.create(self, 'asset', 'BackboneElement', true, TFhirContractTermAsset, FAssetList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirContractTermAction, FActionList.Link));
  oList.add(TFHIRProperty.create(self, 'group', '', true, TFhirContractTerm, FGroupList.Link));
end;

function TFhirContractTerm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then
  begin
    Topic := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'securityLabel') then
  begin
    SecurityLabelList.add(propValue as TFhirContractTermSecurityLabel);
    result := propValue;
  end
  else if (propName = 'offer') then
  begin
    Offer := propValue as TFhirContractTermOffer;
    result := propValue;
  end
  else if (propName = 'asset') then
  begin
    AssetList.add(propValue as TFhirContractTermAsset);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirContractTermAction);
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirContractTerm);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTerm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.insertItem(index, propValue as TFhirContractTermSecurityLabel)
  else if (propName = 'asset') then AssetList.insertItem(index, propValue as TFhirContractTermAsset)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirContractTermAction)
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirContractTerm)
  else inherited;
end;

function TFhirContractTerm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'issued') then result := TFhirDateTime.create()
  else if (propName = 'applies') then result := TFhirPeriod.create()
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Topic')
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subType') then result := TFhirCodeableConcept.create()
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'securityLabel') then result := SecurityLabelList.new()
  else if (propName = 'offer') then result := TFhirContractTermOffer.create()
  else if (propName = 'asset') then result := AssetList.new()
  else if (propName = 'action') then result := ActionList.new()
  else if (propName = 'group') then result := GroupList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTerm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'topic[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'securityLabel') then result := 'BackboneElement'
  else if (propName = 'offer') then result := 'BackboneElement'
  else if (propName = 'asset') then result := 'BackboneElement'
  else if (propName = 'action') then result := 'BackboneElement'
  else if (propName = 'group') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTerm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then SubTypeElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'securityLabel') then deletePropertyValue('securityLabel', SecurityLabelList, value)
  else if (propName = 'offer') then OfferElement := nil
  else if (propName = 'asset') then deletePropertyValue('asset', AssetList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTerm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'issued') then IssuedElement := asDateTime(new)
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := new as TFhirDataType
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subType') then SubTypeElement := new as TFhirCodeableConcept
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'securityLabel') then replacePropertyValue('securityLabel', SecurityLabelList, existing, new)
  else if (propName = 'offer') then OfferElement := new as TFhirContractTermOffer
  else if (propName = 'asset') then replacePropertyValue('asset', AssetList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTerm.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'securityLabel') then SecurityLabelList.move(source, destination)
  else if (propName = 'asset') then AssetList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else if (propName = 'group') then GroupList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTerm.fhirType : string;
begin
  result := 'Contract.term';
end;

function TFhirContractTerm.Link : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Link);
end;

function TFhirContractTerm.Clone : TFhirContractTerm;
begin
  result := TFhirContractTerm(inherited Clone);
end;

function TFhirContractTerm.equals(other : TObject) : boolean; 
var
  o : TFhirContractTerm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTerm)) then
    result := false
  else
  begin
    o := TFhirContractTerm(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(issuedElement, o.issuedElement, true) and 
      compareDeep(appliesElement, o.appliesElement, true) and compareDeep(topicElement, o.topicElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeElement, o.subTypeElement, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(securityLabelList, o.securityLabelList, true) and 
      compareDeep(offerElement, o.offerElement, true) and compareDeep(assetList, o.assetList, true) and 
      compareDeep(actionList, o.actionList, true) and compareDeep(groupList, o.groupList, true);
  end;
end;

function TFhirContractTerm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FTopic) and isEmptyProp(FType_) and isEmptyProp(FSubType) and isEmptyProp(FText) and isEmptyProp(FsecurityLabelList) and isEmptyProp(FOffer) and isEmptyProp(FassetList) and isEmptyProp(FactionList) and isEmptyProp(FgroupList);
end;

procedure TFhirContractTerm.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('issued');
  fields.add('applies');
  fields.add('topic[x]');
  fields.add('type');
  fields.add('subType');
  fields.add('text');
  fields.add('securityLabel');
  fields.add('offer');
  fields.add('asset');
  fields.add('action');
  fields.add('group');
end;

function TFhirContractTerm.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSecurityLabelList.sizeInBytes(magic));
  inc(result, FAssetList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
  inc(result, FGroupList.sizeInBytes(magic));
end;

procedure TFhirContractTerm.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirContractTerm.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

function TFhirContractTerm.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirContractTerm.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

procedure TFhirContractTerm.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

procedure TFhirContractTerm.SetTopic(value : TFhirDataType);
begin
  FTopic.free;
  FTopic := value;
end;

procedure TFhirContractTerm.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirContractTerm.SetSubType(value : TFhirCodeableConcept);
begin
  FSubType.free;
  FSubType := value;
end;

procedure TFhirContractTerm.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirContractTerm.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirContractTerm.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirContractTerm.GetSecurityLabelList : TFhirContractTermSecurityLabelList;
begin
  if FSecurityLabelList = nil then
    FSecurityLabelList := TFhirContractTermSecurityLabelList.Create;
  result := FSecurityLabelList;
end;

function TFhirContractTerm.GetHasSecurityLabelList : boolean;
begin
  result := (FSecurityLabelList <> nil) and (FSecurityLabelList.count > 0);
end;

procedure TFhirContractTerm.SetOffer(value : TFhirContractTermOffer);
begin
  FOffer.free;
  FOffer := value;
end;

function TFhirContractTerm.GetAssetList : TFhirContractTermAssetList;
begin
  if FAssetList = nil then
    FAssetList := TFhirContractTermAssetList.Create;
  result := FAssetList;
end;

function TFhirContractTerm.GetHasAssetList : boolean;
begin
  result := (FAssetList <> nil) and (FAssetList.count > 0);
end;

function TFhirContractTerm.GetActionList : TFhirContractTermActionList;
begin
  if FActionList = nil then
    FActionList := TFhirContractTermActionList.Create;
  result := FActionList;
end;

function TFhirContractTerm.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

function TFhirContractTerm.GetGroupList : TFhirContractTermList;
begin
  if FGroupList = nil then
    FGroupList := TFhirContractTermList.Create;
  result := FGroupList;
end;

function TFhirContractTerm.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

{ TFhirContractTermListEnumerator }

constructor TFhirContractTermListEnumerator.Create(list : TFhirContractTermList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermListEnumerator.GetCurrent : TFhirContractTerm;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermList }

function TFhirContractTermList.AddItem(value: TFhirContractTerm): TFhirContractTerm;
begin
  assert(value.ClassName = 'TFhirContractTerm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTerm');
  add(value);
  result := value;
end;

function TFhirContractTermList.Append: TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermList.GetEnumerator : TFhirContractTermListEnumerator;
begin
  result := TFhirContractTermListEnumerator.Create(self.link);
end;

function TFhirContractTermList.Clone: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Clone);
end;

function TFhirContractTermList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermList.GetItemN(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTerm;
end;
function TFhirContractTermList.IndexOf(value: TFhirContractTerm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermList.Insert(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermList.InsertItem(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  Inherited Insert(index, value);
end;

function TFhirContractTermList.Item(index: Integer): TFhirContractTerm;
begin
  result := TFhirContractTerm(ObjectByIndex[index]);
end;

function TFhirContractTermList.Link: TFhirContractTermList;
begin
  result := TFhirContractTermList(inherited Link);
end;

procedure TFhirContractTermList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermList.SetItemByIndex(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  FhirContractTerms[index] := value;
end;

procedure TFhirContractTermList.SetItemN(index: Integer; value: TFhirContractTerm);
begin
  assert(value is TFhirContractTerm);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermSecurityLabel }

constructor TFhirContractTermSecurityLabel.Create;
begin
  inherited;
end;

destructor TFhirContractTermSecurityLabel.Destroy;
begin
  FNumberList.Free;
  FClassification.free;
  FCategoryList.Free;
  FControlList.Free;
  inherited;
end;

procedure TFhirContractTermSecurityLabel.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermSecurityLabel(oSource).FNumberList = nil) then
  begin
    FNumberList.free;
    FNumberList := nil;
  end
  else
  begin
    if FNumberList = nil then
      FNumberList := TFhirUnsignedIntList.Create;
    FNumberList.Assign(TFhirContractTermSecurityLabel(oSource).FNumberList);
  end;
  classification := TFhirContractTermSecurityLabel(oSource).classification.Clone;
  if (TFhirContractTermSecurityLabel(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodingList.Create;
    FCategoryList.Assign(TFhirContractTermSecurityLabel(oSource).FCategoryList);
  end;
  if (TFhirContractTermSecurityLabel(oSource).FControlList = nil) then
  begin
    FControlList.free;
    FControlList := nil;
  end
  else
  begin
    if FControlList = nil then
      FControlList := TFhirCodingList.Create;
    FControlList.Assign(TFhirContractTermSecurityLabel(oSource).FControlList);
  end;
end;

procedure TFhirContractTermSecurityLabel.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'number') Then
    list.addAll(self, 'number', FNumberList);
  if (child_name = 'classification') Then
     list.add(self.link, 'classification', FClassification.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'control') Then
    list.addAll(self, 'control', FControlList);
end;

procedure TFhirContractTermSecurityLabel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'number', 'unsignedInt', true, TFhirUnsignedInt, FNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'classification', 'Coding', false, TFhirCoding, FClassification.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'Coding', true, TFhirCoding, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'control', 'Coding', true, TFhirCoding, FControlList.Link));
end;

function TFhirContractTermSecurityLabel.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'number') then
  begin
    NumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'classification') then
  begin
    Classification := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else if (propName = 'control') then
  begin
    ControlList.add(propValue as TFhirCoding);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermSecurityLabel.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'number') then NumberList.insertItem(index, asUnsignedInt(propValue))
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCoding)
  else if (propName = 'control') then ControlList.insertItem(index, propValue as TFhirCoding)
  else inherited;
end;

function TFhirContractTermSecurityLabel.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'number') then result := NumberList.new()
  else if (propName = 'classification') then result := TFhirCoding.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'control') then result := ControlList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermSecurityLabel.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'number') then result := 'unsignedInt'
  else if (propName = 'classification') then result := 'Coding'
  else if (propName = 'category') then result := 'Coding'
  else if (propName = 'control') then result := 'Coding'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermSecurityLabel.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'number') then deletePropertyValue('number', NumberList, value)
  else if (propName = 'classification') then ClassificationElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'control') then deletePropertyValue('control', ControlList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermSecurityLabel.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'number') then replacePropertyValue('number', NumberList, existing, new)
  else if (propName = 'classification') then ClassificationElement := new as TFhirCoding
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'control') then replacePropertyValue('control', ControlList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermSecurityLabel.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'number') then NumberList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'control') then ControlList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermSecurityLabel.fhirType : string;
begin
  result := 'Contract.term.securityLabel';
end;

function TFhirContractTermSecurityLabel.Link : TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(inherited Link);
end;

function TFhirContractTermSecurityLabel.Clone : TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(inherited Clone);
end;

function TFhirContractTermSecurityLabel.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermSecurityLabel;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermSecurityLabel)) then
    result := false
  else
  begin
    o := TFhirContractTermSecurityLabel(other);
    result := compareDeep(numberList, o.numberList, true) and compareDeep(classificationElement, o.classificationElement, true) and 
      compareDeep(categoryList, o.categoryList, true) and compareDeep(controlList, o.controlList, true);
  end;
end;

function TFhirContractTermSecurityLabel.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FnumberList) and isEmptyProp(FClassification) and isEmptyProp(FcategoryList) and isEmptyProp(FcontrolList);
end;

procedure TFhirContractTermSecurityLabel.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('number');
  fields.add('classification');
  fields.add('category');
  fields.add('control');
end;

function TFhirContractTermSecurityLabel.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNumberList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FControlList.sizeInBytes(magic));
end;

function TFhirContractTermSecurityLabel.GetNumberList : TFhirUnsignedIntList;
begin
  if FNumberList = nil then
    FNumberList := TFhirUnsignedIntList.Create;
  result := FNumberList;
end;

function TFhirContractTermSecurityLabel.GetHasNumberList : boolean;
begin
  result := (FNumberList <> nil) and (FNumberList.count > 0);
end;

procedure TFhirContractTermSecurityLabel.SetClassification(value : TFhirCoding);
begin
  FClassification.free;
  FClassification := value;
end;

function TFhirContractTermSecurityLabel.GetCategoryList : TFhirCodingList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodingList.Create;
  result := FCategoryList;
end;

function TFhirContractTermSecurityLabel.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

function TFhirContractTermSecurityLabel.GetControlList : TFhirCodingList;
begin
  if FControlList = nil then
    FControlList := TFhirCodingList.Create;
  result := FControlList;
end;

function TFhirContractTermSecurityLabel.GetHasControlList : boolean;
begin
  result := (FControlList <> nil) and (FControlList.count > 0);
end;

{ TFhirContractTermSecurityLabelListEnumerator }

constructor TFhirContractTermSecurityLabelListEnumerator.Create(list : TFhirContractTermSecurityLabelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermSecurityLabelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermSecurityLabelListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermSecurityLabelListEnumerator.GetCurrent : TFhirContractTermSecurityLabel;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermSecurityLabelListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermSecurityLabelList }

function TFhirContractTermSecurityLabelList.AddItem(value: TFhirContractTermSecurityLabel): TFhirContractTermSecurityLabel;
begin
  assert(value.ClassName = 'TFhirContractTermSecurityLabel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermSecurityLabel');
  add(value);
  result := value;
end;

function TFhirContractTermSecurityLabelList.Append: TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermSecurityLabelList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermSecurityLabelList.GetEnumerator : TFhirContractTermSecurityLabelListEnumerator;
begin
  result := TFhirContractTermSecurityLabelListEnumerator.Create(self.link);
end;

function TFhirContractTermSecurityLabelList.Clone: TFhirContractTermSecurityLabelList;
begin
  result := TFhirContractTermSecurityLabelList(inherited Clone);
end;

function TFhirContractTermSecurityLabelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermSecurityLabelList.GetItemN(index: Integer): TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(ObjectByIndex[index]);
end;

function TFhirContractTermSecurityLabelList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermSecurityLabel;
end;
function TFhirContractTermSecurityLabelList.IndexOf(value: TFhirContractTermSecurityLabel): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermSecurityLabelList.Insert(index: Integer): TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermSecurityLabelList.InsertItem(index: Integer; value: TFhirContractTermSecurityLabel);
begin
  assert(value is TFhirContractTermSecurityLabel);
  Inherited Insert(index, value);
end;

function TFhirContractTermSecurityLabelList.Item(index: Integer): TFhirContractTermSecurityLabel;
begin
  result := TFhirContractTermSecurityLabel(ObjectByIndex[index]);
end;

function TFhirContractTermSecurityLabelList.Link: TFhirContractTermSecurityLabelList;
begin
  result := TFhirContractTermSecurityLabelList(inherited Link);
end;

procedure TFhirContractTermSecurityLabelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermSecurityLabelList.SetItemByIndex(index: Integer; value: TFhirContractTermSecurityLabel);
begin
  assert(value is TFhirContractTermSecurityLabel);
  FhirContractTermSecurityLabels[index] := value;
end;

procedure TFhirContractTermSecurityLabelList.SetItemN(index: Integer; value: TFhirContractTermSecurityLabel);
begin
  assert(value is TFhirContractTermSecurityLabel);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermOffer }

constructor TFhirContractTermOffer.Create;
begin
  inherited;
end;

destructor TFhirContractTermOffer.Destroy;
begin
  FIdentifierList.Free;
  FPartyList.Free;
  FTopic.free;
  FType_.free;
  FDecision.free;
  FDecisionModeList.Free;
  FAnswerList.Free;
  FText.free;
  FLinkIdList.Free;
  FSecurityLabelNumberList.Free;
  inherited;
end;

procedure TFhirContractTermOffer.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermOffer(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirContractTermOffer(oSource).FIdentifierList);
  end;
  if (TFhirContractTermOffer(oSource).FPartyList = nil) then
  begin
    FPartyList.free;
    FPartyList := nil;
  end
  else
  begin
    if FPartyList = nil then
      FPartyList := TFhirContractTermOfferPartyList.Create;
    FPartyList.Assign(TFhirContractTermOffer(oSource).FPartyList);
  end;
  topic := TFhirContractTermOffer(oSource).topic.Clone;
  type_ := TFhirContractTermOffer(oSource).type_.Clone;
  decision := TFhirContractTermOffer(oSource).decision.Clone;
  if (TFhirContractTermOffer(oSource).FDecisionModeList = nil) then
  begin
    FDecisionModeList.free;
    FDecisionModeList := nil;
  end
  else
  begin
    if FDecisionModeList = nil then
      FDecisionModeList := TFhirCodeableConceptList.Create;
    FDecisionModeList.Assign(TFhirContractTermOffer(oSource).FDecisionModeList);
  end;
  if (TFhirContractTermOffer(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirContractTermOfferAnswerList.Create;
    FAnswerList.Assign(TFhirContractTermOffer(oSource).FAnswerList);
  end;
  textElement := TFhirContractTermOffer(oSource).textElement.Clone;
  if (TFhirContractTermOffer(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermOffer(oSource).FLinkIdList);
  end;
  if (TFhirContractTermOffer(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermOffer(oSource).FSecurityLabelNumberList);
  end;
end;

procedure TFhirContractTermOffer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'party') Then
    list.addAll(self, 'party', FPartyList);
  if (child_name = 'topic') Then
     list.add(self.link, 'topic', FTopic.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'decision') Then
     list.add(self.link, 'decision', FDecision.Link);
  if (child_name = 'decisionMode') Then
    list.addAll(self, 'decisionMode', FDecisionModeList);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
end;

procedure TFhirContractTermOffer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'party', 'BackboneElement', true, TFhirContractTermOfferParty, FPartyList.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'Reference', false, TFhirReference, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'decision', 'CodeableConcept', false, TFhirCodeableConcept, FDecision.Link));
  oList.add(TFHIRProperty.create(self, 'decisionMode', 'CodeableConcept', true, TFhirCodeableConcept, FDecisionModeList.Link));
  oList.add(TFHIRProperty.create(self, 'answer', 'BackboneElement', true, TFhirContractTermOfferAnswer, FAnswerList.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link));
end;

function TFhirContractTermOffer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    PartyList.add(propValue as TFhirContractTermOfferParty);
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    Topic := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'decision') then
  begin
    Decision := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'decisionMode') then
  begin
    DecisionModeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirContractTermOfferAnswer);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermOffer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'party') then PartyList.insertItem(index, propValue as TFhirContractTermOfferParty)
  else if (propName = 'decisionMode') then DecisionModeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirContractTermOfferAnswer)
  else if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue))
  else inherited;
end;

function TFhirContractTermOffer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'party') then result := PartyList.new()
  else if (propName = 'topic') then result := TFhirReference.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'decision') then result := TFhirCodeableConcept.create()
  else if (propName = 'decisionMode') then result := DecisionModeList.new()
  else if (propName = 'answer') then result := AnswerList.new()
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'linkId') then result := LinkIdList.new()
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermOffer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'party') then result := 'BackboneElement'
  else if (propName = 'topic') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'decision') then result := 'CodeableConcept'
  else if (propName = 'decisionMode') then result := 'CodeableConcept'
  else if (propName = 'answer') then result := 'BackboneElement'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermOffer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'party') then deletePropertyValue('party', PartyList, value)
  else if (propName = 'topic') then TopicElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'decision') then DecisionElement := nil
  else if (propName = 'decisionMode') then deletePropertyValue('decisionMode', DecisionModeList, value)
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value)
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value)
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermOffer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'party') then replacePropertyValue('party', PartyList, existing, new)
  else if (propName = 'topic') then TopicElement := new as TFhirReference
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'decision') then DecisionElement := new as TFhirCodeableConcept
  else if (propName = 'decisionMode') then replacePropertyValue('decisionMode', DecisionModeList, existing, new)
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new)
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new)
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermOffer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'party') then PartyList.move(source, destination)
  else if (propName = 'decisionMode') then DecisionModeList.move(source, destination)
  else if (propName = 'answer') then AnswerList.move(source, destination)
  else if (propName = 'linkId') then LinkIdList.move(source, destination)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermOffer.fhirType : string;
begin
  result := 'Contract.term.offer';
end;

function TFhirContractTermOffer.Link : TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(inherited Link);
end;

function TFhirContractTermOffer.Clone : TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(inherited Clone);
end;

function TFhirContractTermOffer.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermOffer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermOffer)) then
    result := false
  else
  begin
    o := TFhirContractTermOffer(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(partyList, o.partyList, true) and 
      compareDeep(topicElement, o.topicElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(decisionElement, o.decisionElement, true) and compareDeep(decisionModeList, o.decisionModeList, true) and 
      compareDeep(answerList, o.answerList, true) and compareDeep(textElement, o.textElement, true) and 
      compareDeep(linkIdList, o.linkIdList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true);
  end;
end;

function TFhirContractTermOffer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FpartyList) and isEmptyProp(FTopic) and isEmptyProp(FType_) and isEmptyProp(FDecision) and isEmptyProp(FdecisionModeList) and isEmptyProp(FanswerList) and isEmptyProp(FText) and isEmptyProp(FlinkIdList) and isEmptyProp(FsecurityLabelNumberList);
end;

procedure TFhirContractTermOffer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('party');
  fields.add('topic');
  fields.add('type');
  fields.add('decision');
  fields.add('decisionMode');
  fields.add('answer');
  fields.add('text');
  fields.add('linkId');
  fields.add('securityLabelNumber');
end;

function TFhirContractTermOffer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FPartyList.sizeInBytes(magic));
  inc(result, FDecisionModeList.sizeInBytes(magic));
  inc(result, FAnswerList.sizeInBytes(magic));
  inc(result, FLinkIdList.sizeInBytes(magic));
  inc(result, FSecurityLabelNumberList.sizeInBytes(magic));
end;

function TFhirContractTermOffer.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirContractTermOffer.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirContractTermOffer.GetPartyList : TFhirContractTermOfferPartyList;
begin
  if FPartyList = nil then
    FPartyList := TFhirContractTermOfferPartyList.Create;
  result := FPartyList;
end;

function TFhirContractTermOffer.GetHasPartyList : boolean;
begin
  result := (FPartyList <> nil) and (FPartyList.count > 0);
end;

procedure TFhirContractTermOffer.SetTopic(value : TFhirReference);
begin
  FTopic.free;
  FTopic := value;
end;

procedure TFhirContractTermOffer.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirContractTermOffer.SetDecision(value : TFhirCodeableConcept);
begin
  FDecision.free;
  FDecision := value;
end;

function TFhirContractTermOffer.GetDecisionModeList : TFhirCodeableConceptList;
begin
  if FDecisionModeList = nil then
    FDecisionModeList := TFhirCodeableConceptList.Create;
  result := FDecisionModeList;
end;

function TFhirContractTermOffer.GetHasDecisionModeList : boolean;
begin
  result := (FDecisionModeList <> nil) and (FDecisionModeList.count > 0);
end;

function TFhirContractTermOffer.GetAnswerList : TFhirContractTermOfferAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirContractTermOfferAnswerList.Create;
  result := FAnswerList;
end;

function TFhirContractTermOffer.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

procedure TFhirContractTermOffer.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirContractTermOffer.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirContractTermOffer.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirContractTermOffer.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

function TFhirContractTermOffer.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

function TFhirContractTermOffer.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

function TFhirContractTermOffer.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

{ TFhirContractTermOfferListEnumerator }

constructor TFhirContractTermOfferListEnumerator.Create(list : TFhirContractTermOfferList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermOfferListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermOfferListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermOfferListEnumerator.GetCurrent : TFhirContractTermOffer;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermOfferListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermOfferList }

function TFhirContractTermOfferList.AddItem(value: TFhirContractTermOffer): TFhirContractTermOffer;
begin
  assert(value.ClassName = 'TFhirContractTermOffer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermOffer');
  add(value);
  result := value;
end;

function TFhirContractTermOfferList.Append: TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermOfferList.GetEnumerator : TFhirContractTermOfferListEnumerator;
begin
  result := TFhirContractTermOfferListEnumerator.Create(self.link);
end;

function TFhirContractTermOfferList.Clone: TFhirContractTermOfferList;
begin
  result := TFhirContractTermOfferList(inherited Clone);
end;

function TFhirContractTermOfferList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermOfferList.GetItemN(index: Integer): TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermOffer;
end;
function TFhirContractTermOfferList.IndexOf(value: TFhirContractTermOffer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermOfferList.Insert(index: Integer): TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferList.InsertItem(index: Integer; value: TFhirContractTermOffer);
begin
  assert(value is TFhirContractTermOffer);
  Inherited Insert(index, value);
end;

function TFhirContractTermOfferList.Item(index: Integer): TFhirContractTermOffer;
begin
  result := TFhirContractTermOffer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferList.Link: TFhirContractTermOfferList;
begin
  result := TFhirContractTermOfferList(inherited Link);
end;

procedure TFhirContractTermOfferList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermOfferList.SetItemByIndex(index: Integer; value: TFhirContractTermOffer);
begin
  assert(value is TFhirContractTermOffer);
  FhirContractTermOffers[index] := value;
end;

procedure TFhirContractTermOfferList.SetItemN(index: Integer; value: TFhirContractTermOffer);
begin
  assert(value is TFhirContractTermOffer);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermOfferParty }

constructor TFhirContractTermOfferParty.Create;
begin
  inherited;
end;

destructor TFhirContractTermOfferParty.Destroy;
begin
  FReferenceList.Free;
  FRole.free;
  inherited;
end;

procedure TFhirContractTermOfferParty.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermOfferParty(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList.Create;
    FReferenceList.Assign(TFhirContractTermOfferParty(oSource).FReferenceList);
  end;
  role := TFhirContractTermOfferParty(oSource).role.Clone;
end;

procedure TFhirContractTermOfferParty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirContractTermOfferParty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', true, TFhirReference, FReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
end;

function TFhirContractTermOfferParty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermOfferParty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirContractTermOfferParty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := ReferenceList.new()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermOfferParty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermOfferParty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value)
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermOfferParty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermOfferParty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermOfferParty.fhirType : string;
begin
  result := 'Contract.term.offer.party';
end;

function TFhirContractTermOfferParty.Link : TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(inherited Link);
end;

function TFhirContractTermOfferParty.Clone : TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(inherited Clone);
end;

function TFhirContractTermOfferParty.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermOfferParty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermOfferParty)) then
    result := false
  else
  begin
    o := TFhirContractTermOfferParty(other);
    result := compareDeep(referenceList, o.referenceList, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirContractTermOfferParty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FreferenceList) and isEmptyProp(FRole);
end;

procedure TFhirContractTermOfferParty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('role');
end;

function TFhirContractTermOfferParty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FReferenceList.sizeInBytes(magic));
end;

function TFhirContractTermOfferParty.GetReferenceList : TFhirReferenceList;
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList.Create;
  result := FReferenceList;
end;

function TFhirContractTermOfferParty.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

procedure TFhirContractTermOfferParty.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

{ TFhirContractTermOfferPartyListEnumerator }

constructor TFhirContractTermOfferPartyListEnumerator.Create(list : TFhirContractTermOfferPartyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermOfferPartyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermOfferPartyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermOfferPartyListEnumerator.GetCurrent : TFhirContractTermOfferParty;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermOfferPartyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermOfferPartyList }

function TFhirContractTermOfferPartyList.AddItem(value: TFhirContractTermOfferParty): TFhirContractTermOfferParty;
begin
  assert(value.ClassName = 'TFhirContractTermOfferParty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermOfferParty');
  add(value);
  result := value;
end;

function TFhirContractTermOfferPartyList.Append: TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferPartyList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermOfferPartyList.GetEnumerator : TFhirContractTermOfferPartyListEnumerator;
begin
  result := TFhirContractTermOfferPartyListEnumerator.Create(self.link);
end;

function TFhirContractTermOfferPartyList.Clone: TFhirContractTermOfferPartyList;
begin
  result := TFhirContractTermOfferPartyList(inherited Clone);
end;

function TFhirContractTermOfferPartyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermOfferPartyList.GetItemN(index: Integer): TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(ObjectByIndex[index]);
end;

function TFhirContractTermOfferPartyList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermOfferParty;
end;
function TFhirContractTermOfferPartyList.IndexOf(value: TFhirContractTermOfferParty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermOfferPartyList.Insert(index: Integer): TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferPartyList.InsertItem(index: Integer; value: TFhirContractTermOfferParty);
begin
  assert(value is TFhirContractTermOfferParty);
  Inherited Insert(index, value);
end;

function TFhirContractTermOfferPartyList.Item(index: Integer): TFhirContractTermOfferParty;
begin
  result := TFhirContractTermOfferParty(ObjectByIndex[index]);
end;

function TFhirContractTermOfferPartyList.Link: TFhirContractTermOfferPartyList;
begin
  result := TFhirContractTermOfferPartyList(inherited Link);
end;

procedure TFhirContractTermOfferPartyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermOfferPartyList.SetItemByIndex(index: Integer; value: TFhirContractTermOfferParty);
begin
  assert(value is TFhirContractTermOfferParty);
  FhirContractTermOfferParties[index] := value;
end;

procedure TFhirContractTermOfferPartyList.SetItemN(index: Integer; value: TFhirContractTermOfferParty);
begin
  assert(value is TFhirContractTermOfferParty);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermOfferAnswer }

constructor TFhirContractTermOfferAnswer.Create;
begin
  inherited;
end;

destructor TFhirContractTermOfferAnswer.Destroy;
begin
  FValue.free;
  inherited;
end;

procedure TFhirContractTermOfferAnswer.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirContractTermOfferAnswer(oSource).value.Clone;
end;

procedure TFhirContractTermOfferAnswer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirContractTermOfferAnswer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference', false, TFhirDataType, FValue.Link));
end;

function TFhirContractTermOfferAnswer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermOfferAnswer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractTermOfferAnswer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermOfferAnswer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermOfferAnswer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermOfferAnswer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermOfferAnswer.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermOfferAnswer.fhirType : string;
begin
  result := 'Contract.term.offer.answer';
end;

function TFhirContractTermOfferAnswer.Link : TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(inherited Link);
end;

function TFhirContractTermOfferAnswer.Clone : TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(inherited Clone);
end;

function TFhirContractTermOfferAnswer.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermOfferAnswer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermOfferAnswer)) then
    result := false
  else
  begin
    o := TFhirContractTermOfferAnswer(other);
    result := compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirContractTermOfferAnswer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue);
end;

procedure TFhirContractTermOfferAnswer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('value[x]');
end;

function TFhirContractTermOfferAnswer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractTermOfferAnswer.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirContractTermOfferAnswerListEnumerator }

constructor TFhirContractTermOfferAnswerListEnumerator.Create(list : TFhirContractTermOfferAnswerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermOfferAnswerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermOfferAnswerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermOfferAnswerListEnumerator.GetCurrent : TFhirContractTermOfferAnswer;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermOfferAnswerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermOfferAnswerList }

function TFhirContractTermOfferAnswerList.AddItem(value: TFhirContractTermOfferAnswer): TFhirContractTermOfferAnswer;
begin
  assert(value.ClassName = 'TFhirContractTermOfferAnswer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermOfferAnswer');
  add(value);
  result := value;
end;

function TFhirContractTermOfferAnswerList.Append: TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferAnswerList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermOfferAnswerList.GetEnumerator : TFhirContractTermOfferAnswerListEnumerator;
begin
  result := TFhirContractTermOfferAnswerListEnumerator.Create(self.link);
end;

function TFhirContractTermOfferAnswerList.Clone: TFhirContractTermOfferAnswerList;
begin
  result := TFhirContractTermOfferAnswerList(inherited Clone);
end;

function TFhirContractTermOfferAnswerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermOfferAnswerList.GetItemN(index: Integer): TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferAnswerList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermOfferAnswer;
end;
function TFhirContractTermOfferAnswerList.IndexOf(value: TFhirContractTermOfferAnswer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermOfferAnswerList.Insert(index: Integer): TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermOfferAnswerList.InsertItem(index: Integer; value: TFhirContractTermOfferAnswer);
begin
  assert(value is TFhirContractTermOfferAnswer);
  Inherited Insert(index, value);
end;

function TFhirContractTermOfferAnswerList.Item(index: Integer): TFhirContractTermOfferAnswer;
begin
  result := TFhirContractTermOfferAnswer(ObjectByIndex[index]);
end;

function TFhirContractTermOfferAnswerList.Link: TFhirContractTermOfferAnswerList;
begin
  result := TFhirContractTermOfferAnswerList(inherited Link);
end;

procedure TFhirContractTermOfferAnswerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermOfferAnswerList.SetItemByIndex(index: Integer; value: TFhirContractTermOfferAnswer);
begin
  assert(value is TFhirContractTermOfferAnswer);
  FhirContractTermOfferAnswers[index] := value;
end;

procedure TFhirContractTermOfferAnswerList.SetItemN(index: Integer; value: TFhirContractTermOfferAnswer);
begin
  assert(value is TFhirContractTermOfferAnswer);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAsset }

constructor TFhirContractTermAsset.Create;
begin
  inherited;
end;

destructor TFhirContractTermAsset.Destroy;
begin
  FScope.free;
  FType_List.Free;
  FTypeReferenceList.Free;
  FSubtypeList.Free;
  FRelationship.free;
  FContextList.Free;
  FCondition.free;
  FPeriodTypeList.Free;
  FPeriodList.Free;
  FUsePeriodList.Free;
  FText.free;
  FLinkIdList.Free;
  FAnswerList.Free;
  FSecurityLabelNumberList.Free;
  FValuedItemList.Free;
  inherited;
end;

procedure TFhirContractTermAsset.Assign(oSource : TFslObject);
begin
  inherited;
  scope := TFhirContractTermAsset(oSource).scope.Clone;
  if (TFhirContractTermAsset(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirContractTermAsset(oSource).FType_List);
  end;
  if (TFhirContractTermAsset(oSource).FTypeReferenceList = nil) then
  begin
    FTypeReferenceList.free;
    FTypeReferenceList := nil;
  end
  else
  begin
    if FTypeReferenceList = nil then
      FTypeReferenceList := TFhirReferenceList.Create;
    FTypeReferenceList.Assign(TFhirContractTermAsset(oSource).FTypeReferenceList);
  end;
  if (TFhirContractTermAsset(oSource).FSubtypeList = nil) then
  begin
    FSubtypeList.free;
    FSubtypeList := nil;
  end
  else
  begin
    if FSubtypeList = nil then
      FSubtypeList := TFhirCodeableConceptList.Create;
    FSubtypeList.Assign(TFhirContractTermAsset(oSource).FSubtypeList);
  end;
  relationship := TFhirContractTermAsset(oSource).relationship.Clone;
  if (TFhirContractTermAsset(oSource).FContextList = nil) then
  begin
    FContextList.free;
    FContextList := nil;
  end
  else
  begin
    if FContextList = nil then
      FContextList := TFhirContractTermAssetContextList.Create;
    FContextList.Assign(TFhirContractTermAsset(oSource).FContextList);
  end;
  conditionElement := TFhirContractTermAsset(oSource).conditionElement.Clone;
  if (TFhirContractTermAsset(oSource).FPeriodTypeList = nil) then
  begin
    FPeriodTypeList.free;
    FPeriodTypeList := nil;
  end
  else
  begin
    if FPeriodTypeList = nil then
      FPeriodTypeList := TFhirCodeableConceptList.Create;
    FPeriodTypeList.Assign(TFhirContractTermAsset(oSource).FPeriodTypeList);
  end;
  if (TFhirContractTermAsset(oSource).FPeriodList = nil) then
  begin
    FPeriodList.free;
    FPeriodList := nil;
  end
  else
  begin
    if FPeriodList = nil then
      FPeriodList := TFhirPeriodList.Create;
    FPeriodList.Assign(TFhirContractTermAsset(oSource).FPeriodList);
  end;
  if (TFhirContractTermAsset(oSource).FUsePeriodList = nil) then
  begin
    FUsePeriodList.free;
    FUsePeriodList := nil;
  end
  else
  begin
    if FUsePeriodList = nil then
      FUsePeriodList := TFhirPeriodList.Create;
    FUsePeriodList.Assign(TFhirContractTermAsset(oSource).FUsePeriodList);
  end;
  textElement := TFhirContractTermAsset(oSource).textElement.Clone;
  if (TFhirContractTermAsset(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermAsset(oSource).FLinkIdList);
  end;
  if (TFhirContractTermAsset(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirContractTermOfferAnswerList.Create;
    FAnswerList.Assign(TFhirContractTermAsset(oSource).FAnswerList);
  end;
  if (TFhirContractTermAsset(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermAsset(oSource).FSecurityLabelNumberList);
  end;
  if (TFhirContractTermAsset(oSource).FValuedItemList = nil) then
  begin
    FValuedItemList.free;
    FValuedItemList := nil;
  end
  else
  begin
    if FValuedItemList = nil then
      FValuedItemList := TFhirContractTermAssetValuedItemList.Create;
    FValuedItemList.Assign(TFhirContractTermAsset(oSource).FValuedItemList);
  end;
end;

procedure TFhirContractTermAsset.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'typeReference') Then
    list.addAll(self, 'typeReference', FTypeReferenceList);
  if (child_name = 'subtype') Then
    list.addAll(self, 'subtype', FSubtypeList);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'context') Then
    list.addAll(self, 'context', FContextList);
  if (child_name = 'condition') Then
     list.add(self.link, 'condition', FCondition.Link);
  if (child_name = 'periodType') Then
    list.addAll(self, 'periodType', FPeriodTypeList);
  if (child_name = 'period') Then
    list.addAll(self, 'period', FPeriodList);
  if (child_name = 'usePeriod') Then
    list.addAll(self, 'usePeriod', FUsePeriodList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
  if (child_name = 'valuedItem') Then
    list.addAll(self, 'valuedItem', FValuedItemList);
end;

procedure TFhirContractTermAsset.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'scope', 'CodeableConcept', false, TFhirCodeableConcept, FScope.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'typeReference', 'Reference', true, TFhirReference, FTypeReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'subtype', 'CodeableConcept', true, TFhirCodeableConcept, FSubtypeList.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'Coding', false, TFhirCoding, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'BackboneElement', true, TFhirContractTermAssetContext, FContextList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'string', false, TFhirString, FCondition.Link));
  oList.add(TFHIRProperty.create(self, 'periodType', 'CodeableConcept', true, TFhirCodeableConcept, FPeriodTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', true, TFhirPeriod, FPeriodList.Link));
  oList.add(TFHIRProperty.create(self, 'usePeriod', 'Period', true, TFhirPeriod, FUsePeriodList.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'answer', '', true, TFhirContractTermOfferAnswer, FAnswerList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link));
  oList.add(TFHIRProperty.create(self, 'valuedItem', 'BackboneElement', true, TFhirContractTermAssetValuedItem, FValuedItemList.Link));
end;

function TFhirContractTermAsset.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'scope') then
  begin
    Scope := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'typeReference') then
  begin
    TypeReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'subtype') then
  begin
    SubtypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    Relationship := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    ContextList.add(propValue as TFhirContractTermAssetContext);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'periodType') then
  begin
    PeriodTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    PeriodList.add(propValue as TFhirPeriod);
    result := propValue;
  end
  else if (propName = 'usePeriod') then
  begin
    UsePeriodList.add(propValue as TFhirPeriod);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirContractTermOfferAnswer);
    result := propValue;
  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else if (propName = 'valuedItem') then
  begin
    ValuedItemList.add(propValue as TFhirContractTermAssetValuedItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAsset.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'typeReference') then TypeReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'subtype') then SubtypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'context') then ContextList.insertItem(index, propValue as TFhirContractTermAssetContext)
  else if (propName = 'periodType') then PeriodTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'period') then PeriodList.insertItem(index, propValue as TFhirPeriod)
  else if (propName = 'usePeriod') then UsePeriodList.insertItem(index, propValue as TFhirPeriod)
  else if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirContractTermOfferAnswer)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue))
  else if (propName = 'valuedItem') then ValuedItemList.insertItem(index, propValue as TFhirContractTermAssetValuedItem)
  else inherited;
end;

function TFhirContractTermAsset.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'scope') then result := TFhirCodeableConcept.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'typeReference') then result := TypeReferenceList.new()
  else if (propName = 'subtype') then result := SubtypeList.new()
  else if (propName = 'relationship') then result := TFhirCoding.create()
  else if (propName = 'context') then result := ContextList.new()
  else if (propName = 'condition') then result := TFhirString.create()
  else if (propName = 'periodType') then result := PeriodTypeList.new()
  else if (propName = 'period') then result := PeriodList.new()
  else if (propName = 'usePeriod') then result := UsePeriodList.new()
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'linkId') then result := LinkIdList.new()
  else if (propName = 'answer') then result := AnswerList.new()
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new()
  else if (propName = 'valuedItem') then result := ValuedItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAsset.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'scope') then result := 'CodeableConcept'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'typeReference') then result := 'Reference'
  else if (propName = 'subtype') then result := 'CodeableConcept'
  else if (propName = 'relationship') then result := 'Coding'
  else if (propName = 'context') then result := 'BackboneElement'
  else if (propName = 'condition') then result := 'string'
  else if (propName = 'periodType') then result := 'CodeableConcept'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'usePeriod') then result := 'Period'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'answer') then result := ''
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else if (propName = 'valuedItem') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAsset.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'scope') then ScopeElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'typeReference') then deletePropertyValue('typeReference', TypeReferenceList, value)
  else if (propName = 'subtype') then deletePropertyValue('subtype', SubtypeList, value)
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (propName = 'context') then deletePropertyValue('context', ContextList, value)
  else if (propName = 'condition') then ConditionElement := nil
  else if (propName = 'periodType') then deletePropertyValue('periodType', PeriodTypeList, value)
  else if (propName = 'period') then deletePropertyValue('period', PeriodList, value)
  else if (propName = 'usePeriod') then deletePropertyValue('usePeriod', UsePeriodList, value)
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value)
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value)
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value)
  else if (propName = 'valuedItem') then deletePropertyValue('valuedItem', ValuedItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAsset.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'scope') then ScopeElement := new as TFhirCodeableConcept
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'typeReference') then replacePropertyValue('typeReference', TypeReferenceList, existing, new)
  else if (propName = 'subtype') then replacePropertyValue('subtype', SubtypeList, existing, new)
  else if (propName = 'relationship') then RelationshipElement := new as TFhirCoding
  else if (propName = 'context') then replacePropertyValue('context', ContextList, existing, new)
  else if (propName = 'condition') then ConditionElement := asString(new)
  else if (propName = 'periodType') then replacePropertyValue('periodType', PeriodTypeList, existing, new)
  else if (propName = 'period') then replacePropertyValue('period', PeriodList, existing, new)
  else if (propName = 'usePeriod') then replacePropertyValue('usePeriod', UsePeriodList, existing, new)
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new)
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new)
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new)
  else if (propName = 'valuedItem') then replacePropertyValue('valuedItem', ValuedItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAsset.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'typeReference') then TypeReferenceList.move(source, destination)
  else if (propName = 'subtype') then SubtypeList.move(source, destination)
  else if (propName = 'context') then ContextList.move(source, destination)
  else if (propName = 'periodType') then PeriodTypeList.move(source, destination)
  else if (propName = 'period') then PeriodList.move(source, destination)
  else if (propName = 'usePeriod') then UsePeriodList.move(source, destination)
  else if (propName = 'linkId') then LinkIdList.move(source, destination)
  else if (propName = 'answer') then AnswerList.move(source, destination)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination)
  else if (propName = 'valuedItem') then ValuedItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAsset.fhirType : string;
begin
  result := 'Contract.term.asset';
end;

function TFhirContractTermAsset.Link : TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(inherited Link);
end;

function TFhirContractTermAsset.Clone : TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(inherited Clone);
end;

function TFhirContractTermAsset.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAsset;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAsset)) then
    result := false
  else
  begin
    o := TFhirContractTermAsset(other);
    result := compareDeep(scopeElement, o.scopeElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(typeReferenceList, o.typeReferenceList, true) and compareDeep(subtypeList, o.subtypeList, true) and 
      compareDeep(relationshipElement, o.relationshipElement, true) and compareDeep(contextList, o.contextList, true) and 
      compareDeep(conditionElement, o.conditionElement, true) and compareDeep(periodTypeList, o.periodTypeList, true) and 
      compareDeep(periodList, o.periodList, true) and compareDeep(usePeriodList, o.usePeriodList, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(linkIdList, o.linkIdList, true) and 
      compareDeep(answerList, o.answerList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true) and 
      compareDeep(valuedItemList, o.valuedItemList, true);
  end;
end;

function TFhirContractTermAsset.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FScope) and isEmptyProp(Ftype_List) and isEmptyProp(FtypeReferenceList) and isEmptyProp(FsubtypeList) and isEmptyProp(FRelationship) and isEmptyProp(FcontextList) and isEmptyProp(FCondition) and isEmptyProp(FperiodTypeList) and isEmptyProp(FperiodList) and isEmptyProp(FusePeriodList) and isEmptyProp(FText) and isEmptyProp(FlinkIdList) and isEmptyProp(FanswerList) and isEmptyProp(FsecurityLabelNumberList) and isEmptyProp(FvaluedItemList);
end;

procedure TFhirContractTermAsset.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('scope');
  fields.add('type');
  fields.add('typeReference');
  fields.add('subtype');
  fields.add('relationship');
  fields.add('context');
  fields.add('condition');
  fields.add('periodType');
  fields.add('period');
  fields.add('usePeriod');
  fields.add('text');
  fields.add('linkId');
  fields.add('answer');
  fields.add('securityLabelNumber');
  fields.add('valuedItem');
end;

function TFhirContractTermAsset.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FTypeReferenceList.sizeInBytes(magic));
  inc(result, FSubtypeList.sizeInBytes(magic));
  inc(result, FContextList.sizeInBytes(magic));
  inc(result, FPeriodTypeList.sizeInBytes(magic));
  inc(result, FPeriodList.sizeInBytes(magic));
  inc(result, FUsePeriodList.sizeInBytes(magic));
  inc(result, FLinkIdList.sizeInBytes(magic));
  inc(result, FAnswerList.sizeInBytes(magic));
  inc(result, FSecurityLabelNumberList.sizeInBytes(magic));
  inc(result, FValuedItemList.sizeInBytes(magic));
end;

procedure TFhirContractTermAsset.SetScope(value : TFhirCodeableConcept);
begin
  FScope.free;
  FScope := value;
end;

function TFhirContractTermAsset.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirContractTermAsset.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirContractTermAsset.GetTypeReferenceList : TFhirReferenceList;
begin
  if FTypeReferenceList = nil then
    FTypeReferenceList := TFhirReferenceList.Create;
  result := FTypeReferenceList;
end;

function TFhirContractTermAsset.GetHasTypeReferenceList : boolean;
begin
  result := (FTypeReferenceList <> nil) and (FTypeReferenceList.count > 0);
end;

function TFhirContractTermAsset.GetSubtypeList : TFhirCodeableConceptList;
begin
  if FSubtypeList = nil then
    FSubtypeList := TFhirCodeableConceptList.Create;
  result := FSubtypeList;
end;

function TFhirContractTermAsset.GetHasSubtypeList : boolean;
begin
  result := (FSubtypeList <> nil) and (FSubtypeList.count > 0);
end;

procedure TFhirContractTermAsset.SetRelationship(value : TFhirCoding);
begin
  FRelationship.free;
  FRelationship := value;
end;

function TFhirContractTermAsset.GetContextList : TFhirContractTermAssetContextList;
begin
  if FContextList = nil then
    FContextList := TFhirContractTermAssetContextList.Create;
  result := FContextList;
end;

function TFhirContractTermAsset.GetHasContextList : boolean;
begin
  result := (FContextList <> nil) and (FContextList.count > 0);
end;

procedure TFhirContractTermAsset.SetCondition(value : TFhirString);
begin
  FCondition.free;
  FCondition := value;
end;

function TFhirContractTermAsset.GetConditionST : String;
begin
  if FCondition = nil then
    result := ''
  else
    result := FCondition.value;
end;

procedure TFhirContractTermAsset.SetConditionST(value : String);
begin
  if value <> '' then
  begin
    if FCondition = nil then
      FCondition := TFhirString.create;
    FCondition.value := value
  end
  else if FCondition <> nil then
    FCondition.value := '';
end;

function TFhirContractTermAsset.GetPeriodTypeList : TFhirCodeableConceptList;
begin
  if FPeriodTypeList = nil then
    FPeriodTypeList := TFhirCodeableConceptList.Create;
  result := FPeriodTypeList;
end;

function TFhirContractTermAsset.GetHasPeriodTypeList : boolean;
begin
  result := (FPeriodTypeList <> nil) and (FPeriodTypeList.count > 0);
end;

function TFhirContractTermAsset.GetPeriodList : TFhirPeriodList;
begin
  if FPeriodList = nil then
    FPeriodList := TFhirPeriodList.Create;
  result := FPeriodList;
end;

function TFhirContractTermAsset.GetHasPeriodList : boolean;
begin
  result := (FPeriodList <> nil) and (FPeriodList.count > 0);
end;

function TFhirContractTermAsset.GetUsePeriodList : TFhirPeriodList;
begin
  if FUsePeriodList = nil then
    FUsePeriodList := TFhirPeriodList.Create;
  result := FUsePeriodList;
end;

function TFhirContractTermAsset.GetHasUsePeriodList : boolean;
begin
  result := (FUsePeriodList <> nil) and (FUsePeriodList.count > 0);
end;

procedure TFhirContractTermAsset.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirContractTermAsset.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirContractTermAsset.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirContractTermAsset.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

function TFhirContractTermAsset.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

function TFhirContractTermAsset.GetAnswerList : TFhirContractTermOfferAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirContractTermOfferAnswerList.Create;
  result := FAnswerList;
end;

function TFhirContractTermAsset.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

function TFhirContractTermAsset.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

function TFhirContractTermAsset.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

function TFhirContractTermAsset.GetValuedItemList : TFhirContractTermAssetValuedItemList;
begin
  if FValuedItemList = nil then
    FValuedItemList := TFhirContractTermAssetValuedItemList.Create;
  result := FValuedItemList;
end;

function TFhirContractTermAsset.GetHasValuedItemList : boolean;
begin
  result := (FValuedItemList <> nil) and (FValuedItemList.count > 0);
end;

{ TFhirContractTermAssetListEnumerator }

constructor TFhirContractTermAssetListEnumerator.Create(list : TFhirContractTermAssetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAssetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAssetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAssetListEnumerator.GetCurrent : TFhirContractTermAsset;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAssetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermAssetList }

function TFhirContractTermAssetList.AddItem(value: TFhirContractTermAsset): TFhirContractTermAsset;
begin
  assert(value.ClassName = 'TFhirContractTermAsset', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAsset');
  add(value);
  result := value;
end;

function TFhirContractTermAssetList.Append: TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAssetList.GetEnumerator : TFhirContractTermAssetListEnumerator;
begin
  result := TFhirContractTermAssetListEnumerator.Create(self.link);
end;

function TFhirContractTermAssetList.Clone: TFhirContractTermAssetList;
begin
  result := TFhirContractTermAssetList(inherited Clone);
end;

function TFhirContractTermAssetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAssetList.GetItemN(index: Integer): TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(ObjectByIndex[index]);
end;

function TFhirContractTermAssetList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAsset;
end;
function TFhirContractTermAssetList.IndexOf(value: TFhirContractTermAsset): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAssetList.Insert(index: Integer): TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetList.InsertItem(index: Integer; value: TFhirContractTermAsset);
begin
  assert(value is TFhirContractTermAsset);
  Inherited Insert(index, value);
end;

function TFhirContractTermAssetList.Item(index: Integer): TFhirContractTermAsset;
begin
  result := TFhirContractTermAsset(ObjectByIndex[index]);
end;

function TFhirContractTermAssetList.Link: TFhirContractTermAssetList;
begin
  result := TFhirContractTermAssetList(inherited Link);
end;

procedure TFhirContractTermAssetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAssetList.SetItemByIndex(index: Integer; value: TFhirContractTermAsset);
begin
  assert(value is TFhirContractTermAsset);
  FhirContractTermAssets[index] := value;
end;

procedure TFhirContractTermAssetList.SetItemN(index: Integer; value: TFhirContractTermAsset);
begin
  assert(value is TFhirContractTermAsset);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAssetContext }

constructor TFhirContractTermAssetContext.Create;
begin
  inherited;
end;

destructor TFhirContractTermAssetContext.Destroy;
begin
  FReference.free;
  FCodeList.Free;
  FText.free;
  inherited;
end;

procedure TFhirContractTermAssetContext.Assign(oSource : TFslObject);
begin
  inherited;
  reference := TFhirContractTermAssetContext(oSource).reference.Clone;
  if (TFhirContractTermAssetContext(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirContractTermAssetContext(oSource).FCodeList);
  end;
  textElement := TFhirContractTermAssetContext(oSource).textElement.Clone;
end;

procedure TFhirContractTermAssetContext.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
     list.add(self.link, 'reference', FReference.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
end;

procedure TFhirContractTermAssetContext.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', false, TFhirReference, FReference.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
end;

function TFhirContractTermAssetContext.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    Reference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAssetContext.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirContractTermAssetContext.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := TFhirReference.create()
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'text') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAssetContext.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'text') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAssetContext.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'text') then TextElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAssetContext.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then ReferenceElement := new as TFhirReference
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'text') then TextElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAssetContext.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAssetContext.fhirType : string;
begin
  result := 'Contract.term.asset.context';
end;

function TFhirContractTermAssetContext.Link : TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(inherited Link);
end;

function TFhirContractTermAssetContext.Clone : TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(inherited Clone);
end;

function TFhirContractTermAssetContext.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAssetContext;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAssetContext)) then
    result := false
  else
  begin
    o := TFhirContractTermAssetContext(other);
    result := compareDeep(referenceElement, o.referenceElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(textElement, o.textElement, true);
  end;
end;

function TFhirContractTermAssetContext.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FReference) and isEmptyProp(FcodeList) and isEmptyProp(FText);
end;

procedure TFhirContractTermAssetContext.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('code');
  fields.add('text');
end;

function TFhirContractTermAssetContext.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
end;

procedure TFhirContractTermAssetContext.SetReference(value : TFhirReference);
begin
  FReference.free;
  FReference := value;
end;

function TFhirContractTermAssetContext.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirContractTermAssetContext.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

procedure TFhirContractTermAssetContext.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirContractTermAssetContext.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirContractTermAssetContext.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

{ TFhirContractTermAssetContextListEnumerator }

constructor TFhirContractTermAssetContextListEnumerator.Create(list : TFhirContractTermAssetContextList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAssetContextListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAssetContextListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAssetContextListEnumerator.GetCurrent : TFhirContractTermAssetContext;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAssetContextListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermAssetContextList }

function TFhirContractTermAssetContextList.AddItem(value: TFhirContractTermAssetContext): TFhirContractTermAssetContext;
begin
  assert(value.ClassName = 'TFhirContractTermAssetContext', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAssetContext');
  add(value);
  result := value;
end;

function TFhirContractTermAssetContextList.Append: TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetContextList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAssetContextList.GetEnumerator : TFhirContractTermAssetContextListEnumerator;
begin
  result := TFhirContractTermAssetContextListEnumerator.Create(self.link);
end;

function TFhirContractTermAssetContextList.Clone: TFhirContractTermAssetContextList;
begin
  result := TFhirContractTermAssetContextList(inherited Clone);
end;

function TFhirContractTermAssetContextList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAssetContextList.GetItemN(index: Integer): TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(ObjectByIndex[index]);
end;

function TFhirContractTermAssetContextList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAssetContext;
end;
function TFhirContractTermAssetContextList.IndexOf(value: TFhirContractTermAssetContext): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAssetContextList.Insert(index: Integer): TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetContextList.InsertItem(index: Integer; value: TFhirContractTermAssetContext);
begin
  assert(value is TFhirContractTermAssetContext);
  Inherited Insert(index, value);
end;

function TFhirContractTermAssetContextList.Item(index: Integer): TFhirContractTermAssetContext;
begin
  result := TFhirContractTermAssetContext(ObjectByIndex[index]);
end;

function TFhirContractTermAssetContextList.Link: TFhirContractTermAssetContextList;
begin
  result := TFhirContractTermAssetContextList(inherited Link);
end;

procedure TFhirContractTermAssetContextList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAssetContextList.SetItemByIndex(index: Integer; value: TFhirContractTermAssetContext);
begin
  assert(value is TFhirContractTermAssetContext);
  FhirContractTermAssetContexts[index] := value;
end;

procedure TFhirContractTermAssetContextList.SetItemN(index: Integer; value: TFhirContractTermAssetContext);
begin
  assert(value is TFhirContractTermAssetContext);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAssetValuedItem }

constructor TFhirContractTermAssetValuedItem.Create;
begin
  inherited;
end;

destructor TFhirContractTermAssetValuedItem.Destroy;
begin
  FEntity.free;
  FIdentifier.free;
  FEffectiveTime.free;
  FQuantity.free;
  FUnitPrice.free;
  FFactor.free;
  FPoints.free;
  FNet.free;
  FPayment.free;
  FPaymentDate.free;
  FResponsible.free;
  FRecipient.free;
  FLinkIdList.Free;
  FSecurityLabelNumberList.Free;
  inherited;
end;

procedure TFhirContractTermAssetValuedItem.Assign(oSource : TFslObject);
begin
  inherited;
  entity := TFhirContractTermAssetValuedItem(oSource).entity.Clone;
  identifier := TFhirContractTermAssetValuedItem(oSource).identifier.Clone;
  effectiveTimeElement := TFhirContractTermAssetValuedItem(oSource).effectiveTimeElement.Clone;
  quantity := TFhirContractTermAssetValuedItem(oSource).quantity.Clone;
  unitPrice := TFhirContractTermAssetValuedItem(oSource).unitPrice.Clone;
  factorElement := TFhirContractTermAssetValuedItem(oSource).factorElement.Clone;
  pointsElement := TFhirContractTermAssetValuedItem(oSource).pointsElement.Clone;
  net := TFhirContractTermAssetValuedItem(oSource).net.Clone;
  paymentElement := TFhirContractTermAssetValuedItem(oSource).paymentElement.Clone;
  paymentDateElement := TFhirContractTermAssetValuedItem(oSource).paymentDateElement.Clone;
  responsible := TFhirContractTermAssetValuedItem(oSource).responsible.Clone;
  recipient := TFhirContractTermAssetValuedItem(oSource).recipient.Clone;
  if (TFhirContractTermAssetValuedItem(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermAssetValuedItem(oSource).FLinkIdList);
  end;
  if (TFhirContractTermAssetValuedItem(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermAssetValuedItem(oSource).FSecurityLabelNumberList);
  end;
end;

procedure TFhirContractTermAssetValuedItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'entity[x]') or (child_name = 'entity') Then
     list.add(self.link, 'entity[x]', FEntity.Link);
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'effectiveTime') Then
     list.add(self.link, 'effectiveTime', FEffectiveTime.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'unitPrice') Then
     list.add(self.link, 'unitPrice', FUnitPrice.Link);
  if (child_name = 'factor') Then
     list.add(self.link, 'factor', FFactor.Link);
  if (child_name = 'points') Then
     list.add(self.link, 'points', FPoints.Link);
  if (child_name = 'net') Then
     list.add(self.link, 'net', FNet.Link);
  if (child_name = 'payment') Then
     list.add(self.link, 'payment', FPayment.Link);
  if (child_name = 'paymentDate') Then
     list.add(self.link, 'paymentDate', FPaymentDate.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'recipient') Then
     list.add(self.link, 'recipient', FRecipient.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
end;

procedure TFhirContractTermAssetValuedItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'entity[x]', 'CodeableConcept|Reference', false, TFhirDataType, FEntity.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'effectiveTime', 'dateTime', false, TFhirDateTime, FEffectiveTime.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'unitPrice', 'Money', false, TFhirMoney, FUnitPrice.Link));
  oList.add(TFHIRProperty.create(self, 'factor', 'decimal', false, TFhirDecimal, FFactor.Link));
  oList.add(TFHIRProperty.create(self, 'points', 'decimal', false, TFhirDecimal, FPoints.Link));
  oList.add(TFHIRProperty.create(self, 'net', 'Money', false, TFhirMoney, FNet.Link));
  oList.add(TFHIRProperty.create(self, 'payment', 'string', false, TFhirString, FPayment.Link));
  oList.add(TFHIRProperty.create(self, 'paymentDate', 'dateTime', false, TFhirDateTime, FPaymentDate.Link));
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference', false, TFhirReference, FResponsible.Link));
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', false, TFhirReference, FRecipient.Link));
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link));
end;

function TFhirContractTermAssetValuedItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then
  begin
    Entity := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'effectiveTime') then
  begin
    EffectiveTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'unitPrice') then
  begin
    UnitPrice := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'factor') then
  begin
    FactorElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'points') then
  begin
    PointsElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'net') then
  begin
    Net := propValue as TFhirMoney;
    result := propValue;
  end
  else if (propName = 'payment') then
  begin
    PaymentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'paymentDate') then
  begin
    PaymentDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    Recipient := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAssetValuedItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue))
  else inherited;
end;

function TFhirContractTermAssetValuedItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Entity')
  else if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'effectiveTime') then result := TFhirDateTime.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'unitPrice') then result := TFhirMoney.create()
  else if (propName = 'factor') then result := TFhirDecimal.create()
  else if (propName = 'points') then result := TFhirDecimal.create()
  else if (propName = 'net') then result := TFhirMoney.create()
  else if (propName = 'payment') then result := TFhirString.create()
  else if (propName = 'paymentDate') then result := TFhirDateTime.create()
  else if (propName = 'responsible') then result := TFhirReference.create()
  else if (propName = 'recipient') then result := TFhirReference.create()
  else if (propName = 'linkId') then result := LinkIdList.new()
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAssetValuedItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'entity[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'effectiveTime') then result := 'dateTime'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'unitPrice') then result := 'Money'
  else if (propName = 'factor') then result := 'decimal'
  else if (propName = 'points') then result := 'decimal'
  else if (propName = 'net') then result := 'Money'
  else if (propName = 'payment') then result := 'string'
  else if (propName = 'paymentDate') then result := 'dateTime'
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'recipient') then result := 'Reference'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAssetValuedItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := nil
  else if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'effectiveTime') then EffectiveTimeElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'unitPrice') then UnitPriceElement := nil
  else if (propName = 'factor') then FactorElement := nil
  else if (propName = 'points') then PointsElement := nil
  else if (propName = 'net') then NetElement := nil
  else if (propName = 'payment') then PaymentElement := nil
  else if (propName = 'paymentDate') then PaymentDateElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'recipient') then RecipientElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value)
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAssetValuedItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'entity', ['CodeableConcept', 'Reference'])) then EntityElement := new as TFhirDataType
  else if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'effectiveTime') then EffectiveTimeElement := asDateTime(new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'unitPrice') then UnitPriceElement := new as TFhirMoney
  else if (propName = 'factor') then FactorElement := asDecimal(new)
  else if (propName = 'points') then PointsElement := asDecimal(new)
  else if (propName = 'net') then NetElement := new as TFhirMoney
  else if (propName = 'payment') then PaymentElement := asString(new)
  else if (propName = 'paymentDate') then PaymentDateElement := asDateTime(new)
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference
  else if (propName = 'recipient') then RecipientElement := new as TFhirReference
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new)
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAssetValuedItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'linkId') then LinkIdList.move(source, destination)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAssetValuedItem.fhirType : string;
begin
  result := 'Contract.term.asset.valuedItem';
end;

function TFhirContractTermAssetValuedItem.Link : TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(inherited Link);
end;

function TFhirContractTermAssetValuedItem.Clone : TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(inherited Clone);
end;

function TFhirContractTermAssetValuedItem.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAssetValuedItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAssetValuedItem)) then
    result := false
  else
  begin
    o := TFhirContractTermAssetValuedItem(other);
    result := compareDeep(entityElement, o.entityElement, true) and compareDeep(identifierElement, o.identifierElement, true) and 
      compareDeep(effectiveTimeElement, o.effectiveTimeElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(unitPriceElement, o.unitPriceElement, true) and compareDeep(factorElement, o.factorElement, true) and 
      compareDeep(pointsElement, o.pointsElement, true) and compareDeep(netElement, o.netElement, true) and 
      compareDeep(paymentElement, o.paymentElement, true) and compareDeep(paymentDateElement, o.paymentDateElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(recipientElement, o.recipientElement, true) and 
      compareDeep(linkIdList, o.linkIdList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true);
  end;
end;

function TFhirContractTermAssetValuedItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEntity) and isEmptyProp(FIdentifier) and isEmptyProp(FEffectiveTime) and isEmptyProp(FQuantity) and isEmptyProp(FUnitPrice) and isEmptyProp(FFactor) and isEmptyProp(FPoints) and isEmptyProp(FNet) and isEmptyProp(FPayment) and isEmptyProp(FPaymentDate) and isEmptyProp(FResponsible) and isEmptyProp(FRecipient) and isEmptyProp(FlinkIdList) and isEmptyProp(FsecurityLabelNumberList);
end;

procedure TFhirContractTermAssetValuedItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('entity[x]');
  fields.add('identifier');
  fields.add('effectiveTime');
  fields.add('quantity');
  fields.add('unitPrice');
  fields.add('factor');
  fields.add('points');
  fields.add('net');
  fields.add('payment');
  fields.add('paymentDate');
  fields.add('responsible');
  fields.add('recipient');
  fields.add('linkId');
  fields.add('securityLabelNumber');
end;

function TFhirContractTermAssetValuedItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLinkIdList.sizeInBytes(magic));
  inc(result, FSecurityLabelNumberList.sizeInBytes(magic));
end;

procedure TFhirContractTermAssetValuedItem.SetEntity(value : TFhirDataType);
begin
  FEntity.free;
  FEntity := value;
end;

procedure TFhirContractTermAssetValuedItem.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirContractTermAssetValuedItem.SetEffectiveTime(value : TFhirDateTime);
begin
  FEffectiveTime.free;
  FEffectiveTime := value;
end;

function TFhirContractTermAssetValuedItem.GetEffectiveTimeST : TFslDateTime;
begin
  if FEffectiveTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FEffectiveTime.value;
end;

procedure TFhirContractTermAssetValuedItem.SetEffectiveTimeST(value : TFslDateTime);
begin
  if FEffectiveTime = nil then
    FEffectiveTime := TFhirDateTime.create;
  FEffectiveTime.value := value
end;

procedure TFhirContractTermAssetValuedItem.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirContractTermAssetValuedItem.SetUnitPrice(value : TFhirMoney);
begin
  FUnitPrice.free;
  FUnitPrice := value;
end;

procedure TFhirContractTermAssetValuedItem.SetFactor(value : TFhirDecimal);
begin
  FFactor.free;
  FFactor := value;
end;

function TFhirContractTermAssetValuedItem.GetFactorST : String;
begin
  if FFactor = nil then
    result := ''
  else
    result := FFactor.value;
end;

procedure TFhirContractTermAssetValuedItem.SetFactorST(value : String);
begin
  if value <> '' then
  begin
    if FFactor = nil then
      FFactor := TFhirDecimal.create;
    FFactor.value := value
  end
  else if FFactor <> nil then
    FFactor.value := '';
end;

procedure TFhirContractTermAssetValuedItem.SetPoints(value : TFhirDecimal);
begin
  FPoints.free;
  FPoints := value;
end;

function TFhirContractTermAssetValuedItem.GetPointsST : String;
begin
  if FPoints = nil then
    result := ''
  else
    result := FPoints.value;
end;

procedure TFhirContractTermAssetValuedItem.SetPointsST(value : String);
begin
  if value <> '' then
  begin
    if FPoints = nil then
      FPoints := TFhirDecimal.create;
    FPoints.value := value
  end
  else if FPoints <> nil then
    FPoints.value := '';
end;

procedure TFhirContractTermAssetValuedItem.SetNet(value : TFhirMoney);
begin
  FNet.free;
  FNet := value;
end;

procedure TFhirContractTermAssetValuedItem.SetPayment(value : TFhirString);
begin
  FPayment.free;
  FPayment := value;
end;

function TFhirContractTermAssetValuedItem.GetPaymentST : String;
begin
  if FPayment = nil then
    result := ''
  else
    result := FPayment.value;
end;

procedure TFhirContractTermAssetValuedItem.SetPaymentST(value : String);
begin
  if value <> '' then
  begin
    if FPayment = nil then
      FPayment := TFhirString.create;
    FPayment.value := value
  end
  else if FPayment <> nil then
    FPayment.value := '';
end;

procedure TFhirContractTermAssetValuedItem.SetPaymentDate(value : TFhirDateTime);
begin
  FPaymentDate.free;
  FPaymentDate := value;
end;

function TFhirContractTermAssetValuedItem.GetPaymentDateST : TFslDateTime;
begin
  if FPaymentDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FPaymentDate.value;
end;

procedure TFhirContractTermAssetValuedItem.SetPaymentDateST(value : TFslDateTime);
begin
  if FPaymentDate = nil then
    FPaymentDate := TFhirDateTime.create;
  FPaymentDate.value := value
end;

procedure TFhirContractTermAssetValuedItem.SetResponsible(value : TFhirReference);
begin
  FResponsible.free;
  FResponsible := value;
end;

procedure TFhirContractTermAssetValuedItem.SetRecipient(value : TFhirReference);
begin
  FRecipient.free;
  FRecipient := value;
end;

function TFhirContractTermAssetValuedItem.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

function TFhirContractTermAssetValuedItem.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

function TFhirContractTermAssetValuedItem.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

function TFhirContractTermAssetValuedItem.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

{ TFhirContractTermAssetValuedItemListEnumerator }

constructor TFhirContractTermAssetValuedItemListEnumerator.Create(list : TFhirContractTermAssetValuedItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermAssetValuedItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermAssetValuedItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermAssetValuedItemListEnumerator.GetCurrent : TFhirContractTermAssetValuedItem;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermAssetValuedItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermAssetValuedItemList }

function TFhirContractTermAssetValuedItemList.AddItem(value: TFhirContractTermAssetValuedItem): TFhirContractTermAssetValuedItem;
begin
  assert(value.ClassName = 'TFhirContractTermAssetValuedItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAssetValuedItem');
  add(value);
  result := value;
end;

function TFhirContractTermAssetValuedItemList.Append: TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetValuedItemList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermAssetValuedItemList.GetEnumerator : TFhirContractTermAssetValuedItemListEnumerator;
begin
  result := TFhirContractTermAssetValuedItemListEnumerator.Create(self.link);
end;

function TFhirContractTermAssetValuedItemList.Clone: TFhirContractTermAssetValuedItemList;
begin
  result := TFhirContractTermAssetValuedItemList(inherited Clone);
end;

function TFhirContractTermAssetValuedItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermAssetValuedItemList.GetItemN(index: Integer): TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermAssetValuedItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAssetValuedItem;
end;
function TFhirContractTermAssetValuedItemList.IndexOf(value: TFhirContractTermAssetValuedItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermAssetValuedItemList.Insert(index: Integer): TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermAssetValuedItemList.InsertItem(index: Integer; value: TFhirContractTermAssetValuedItem);
begin
  assert(value is TFhirContractTermAssetValuedItem);
  Inherited Insert(index, value);
end;

function TFhirContractTermAssetValuedItemList.Item(index: Integer): TFhirContractTermAssetValuedItem;
begin
  result := TFhirContractTermAssetValuedItem(ObjectByIndex[index]);
end;

function TFhirContractTermAssetValuedItemList.Link: TFhirContractTermAssetValuedItemList;
begin
  result := TFhirContractTermAssetValuedItemList(inherited Link);
end;

procedure TFhirContractTermAssetValuedItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermAssetValuedItemList.SetItemByIndex(index: Integer; value: TFhirContractTermAssetValuedItem);
begin
  assert(value is TFhirContractTermAssetValuedItem);
  FhirContractTermAssetValuedItems[index] := value;
end;

procedure TFhirContractTermAssetValuedItemList.SetItemN(index: Integer; value: TFhirContractTermAssetValuedItem);
begin
  assert(value is TFhirContractTermAssetValuedItem);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermAction }

constructor TFhirContractTermAction.Create;
begin
  inherited;
end;

destructor TFhirContractTermAction.Destroy;
begin
  FDoNotPerform.free;
  FType_.free;
  FSubjectList.Free;
  FIntent.free;
  FLinkIdList.Free;
  FStatus.free;
  FContext.free;
  FContextLinkIdList.Free;
  FOccurrence.free;
  FRequesterList.Free;
  FRequesterLinkIdList.Free;
  FPerformerTypeList.Free;
  FPerformerRole.free;
  FPerformer.free;
  FPerformerLinkIdList.Free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FReasonList.Free;
  FReasonLinkIdList.Free;
  FNoteList.Free;
  FSecurityLabelNumberList.Free;
  inherited;
end;

procedure TFhirContractTermAction.Assign(oSource : TFslObject);
begin
  inherited;
  doNotPerformElement := TFhirContractTermAction(oSource).doNotPerformElement.Clone;
  type_ := TFhirContractTermAction(oSource).type_.Clone;
  if (TFhirContractTermAction(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirContractTermActionSubjectList.Create;
    FSubjectList.Assign(TFhirContractTermAction(oSource).FSubjectList);
  end;
  intent := TFhirContractTermAction(oSource).intent.Clone;
  if (TFhirContractTermAction(oSource).FLinkIdList = nil) then
  begin
    FLinkIdList.free;
    FLinkIdList := nil;
  end
  else
  begin
    if FLinkIdList = nil then
      FLinkIdList := TFhirStringList.Create;
    FLinkIdList.Assign(TFhirContractTermAction(oSource).FLinkIdList);
  end;
  status := TFhirContractTermAction(oSource).status.Clone;
  context := TFhirContractTermAction(oSource).context.Clone;
  if (TFhirContractTermAction(oSource).FContextLinkIdList = nil) then
  begin
    FContextLinkIdList.free;
    FContextLinkIdList := nil;
  end
  else
  begin
    if FContextLinkIdList = nil then
      FContextLinkIdList := TFhirStringList.Create;
    FContextLinkIdList.Assign(TFhirContractTermAction(oSource).FContextLinkIdList);
  end;
  occurrence := TFhirContractTermAction(oSource).occurrence.Clone;
  if (TFhirContractTermAction(oSource).FRequesterList = nil) then
  begin
    FRequesterList.free;
    FRequesterList := nil;
  end
  else
  begin
    if FRequesterList = nil then
      FRequesterList := TFhirReferenceList.Create;
    FRequesterList.Assign(TFhirContractTermAction(oSource).FRequesterList);
  end;
  if (TFhirContractTermAction(oSource).FRequesterLinkIdList = nil) then
  begin
    FRequesterLinkIdList.free;
    FRequesterLinkIdList := nil;
  end
  else
  begin
    if FRequesterLinkIdList = nil then
      FRequesterLinkIdList := TFhirStringList.Create;
    FRequesterLinkIdList.Assign(TFhirContractTermAction(oSource).FRequesterLinkIdList);
  end;
  if (TFhirContractTermAction(oSource).FPerformerTypeList = nil) then
  begin
    FPerformerTypeList.free;
    FPerformerTypeList := nil;
  end
  else
  begin
    if FPerformerTypeList = nil then
      FPerformerTypeList := TFhirCodeableConceptList.Create;
    FPerformerTypeList.Assign(TFhirContractTermAction(oSource).FPerformerTypeList);
  end;
  performerRole := TFhirContractTermAction(oSource).performerRole.Clone;
  performer := TFhirContractTermAction(oSource).performer.Clone;
  if (TFhirContractTermAction(oSource).FPerformerLinkIdList = nil) then
  begin
    FPerformerLinkIdList.free;
    FPerformerLinkIdList := nil;
  end
  else
  begin
    if FPerformerLinkIdList = nil then
      FPerformerLinkIdList := TFhirStringList.Create;
    FPerformerLinkIdList.Assign(TFhirContractTermAction(oSource).FPerformerLinkIdList);
  end;
  if (TFhirContractTermAction(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirContractTermAction(oSource).FReasonCodeList);
  end;
  if (TFhirContractTermAction(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirContractTermAction(oSource).FReasonReferenceList);
  end;
  if (TFhirContractTermAction(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirStringList.Create;
    FReasonList.Assign(TFhirContractTermAction(oSource).FReasonList);
  end;
  if (TFhirContractTermAction(oSource).FReasonLinkIdList = nil) then
  begin
    FReasonLinkIdList.free;
    FReasonLinkIdList := nil;
  end
  else
  begin
    if FReasonLinkIdList = nil then
      FReasonLinkIdList := TFhirStringList.Create;
    FReasonLinkIdList.Assign(TFhirContractTermAction(oSource).FReasonLinkIdList);
  end;
  if (TFhirContractTermAction(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirContractTermAction(oSource).FNoteList);
  end;
  if (TFhirContractTermAction(oSource).FSecurityLabelNumberList = nil) then
  begin
    FSecurityLabelNumberList.free;
    FSecurityLabelNumberList := nil;
  end
  else
  begin
    if FSecurityLabelNumberList = nil then
      FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
    FSecurityLabelNumberList.Assign(TFhirContractTermAction(oSource).FSecurityLabelNumberList);
  end;
end;

procedure TFhirContractTermAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'doNotPerform') Then
     list.add(self.link, 'doNotPerform', FDoNotPerform.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'linkId') Then
    list.addAll(self, 'linkId', FLinkIdList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'context') Then
     list.add(self.link, 'context', FContext.Link);
  if (child_name = 'contextLinkId') Then
    list.addAll(self, 'contextLinkId', FContextLinkIdList);
  if (child_name = 'occurrence[x]') or (child_name = 'occurrence') Then
     list.add(self.link, 'occurrence[x]', FOccurrence.Link);
  if (child_name = 'requester') Then
    list.addAll(self, 'requester', FRequesterList);
  if (child_name = 'requesterLinkId') Then
    list.addAll(self, 'requesterLinkId', FRequesterLinkIdList);
  if (child_name = 'performerType') Then
    list.addAll(self, 'performerType', FPerformerTypeList);
  if (child_name = 'performerRole') Then
     list.add(self.link, 'performerRole', FPerformerRole.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'performerLinkId') Then
    list.addAll(self, 'performerLinkId', FPerformerLinkIdList);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'reasonLinkId') Then
    list.addAll(self, 'reasonLinkId', FReasonLinkIdList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'securityLabelNumber') Then
    list.addAll(self, 'securityLabelNumber', FSecurityLabelNumberList);
end;

procedure TFhirContractTermAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'doNotPerform', 'boolean', false, TFhirBoolean, FDoNotPerform.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'BackboneElement', true, TFhirContractTermActionSubject, FSubjectList.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'CodeableConcept', false, TFhirCodeableConcept, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', true, TFhirString, FLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'CodeableConcept', false, TFhirCodeableConcept, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'context', 'Reference', false, TFhirReference, FContext.Link));
  oList.add(TFHIRProperty.create(self, 'contextLinkId', 'string', true, TFhirString, FContextLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'occurrence[x]', 'dateTime|Period|Timing', false, TFhirDataType, FOccurrence.Link));
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', true, TFhirReference, FRequesterList.Link));
  oList.add(TFHIRProperty.create(self, 'requesterLinkId', 'string', true, TFhirString, FRequesterLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', true, TFhirCodeableConcept, FPerformerTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'performerRole', 'CodeableConcept', false, TFhirCodeableConcept, FPerformerRole.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link));
  oList.add(TFHIRProperty.create(self, 'performerLinkId', 'string', true, TFhirString, FPerformerLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'string', true, TFhirString, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonLinkId', 'string', true, TFhirString, FReasonLinkIdList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'securityLabelNumber', 'unsignedInt', true, TFhirUnsignedInt, FSecurityLabelNumberList.Link));
end;

function TFhirContractTermAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'doNotPerform') then
  begin
    DoNotPerformElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirContractTermActionSubject);
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    Intent := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'linkId') then
  begin
    LinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    Status := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'context') then
  begin
    Context := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'contextLinkId') then
  begin
    ContextLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then
  begin
    Occurrence := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    RequesterList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'requesterLinkId') then
  begin
    RequesterLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'performerType') then
  begin
    PerformerTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'performerRole') then
  begin
    PerformerRole := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performerLinkId') then
  begin
    PerformerLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'reasonLinkId') then
  begin
    ReasonLinkIdList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'securityLabelNumber') then
  begin
    SecurityLabelNumberList.add(asUnsignedInt(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirContractTermActionSubject)
  else if (propName = 'linkId') then LinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'contextLinkId') then ContextLinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'requester') then RequesterList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'requesterLinkId') then RequesterLinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'performerType') then PerformerTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'performerLinkId') then PerformerLinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reason') then ReasonList.insertItem(index, asString(propValue))
  else if (propName = 'reasonLinkId') then ReasonLinkIdList.insertItem(index, asString(propValue))
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.insertItem(index, asUnsignedInt(propValue))
  else inherited;
end;

function TFhirContractTermAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'doNotPerform') then result := TFhirBoolean.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := SubjectList.new()
  else if (propName = 'intent') then result := TFhirCodeableConcept.create()
  else if (propName = 'linkId') then result := LinkIdList.new()
  else if (propName = 'status') then result := TFhirCodeableConcept.create()
  else if (propName = 'context') then result := TFhirReference.create()
  else if (propName = 'contextLinkId') then result := ContextLinkIdList.new()
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then raise EFHIRException.create('Cannot make property Occurrence')
  else if (propName = 'requester') then result := RequesterList.new()
  else if (propName = 'requesterLinkId') then result := RequesterLinkIdList.new()
  else if (propName = 'performerType') then result := PerformerTypeList.new()
  else if (propName = 'performerRole') then result := TFhirCodeableConcept.create()
  else if (propName = 'performer') then result := TFhirReference.create()
  else if (propName = 'performerLinkId') then result := PerformerLinkIdList.new()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'reasonLinkId') then result := ReasonLinkIdList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'securityLabelNumber') then result := SecurityLabelNumberList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'doNotPerform') then result := 'boolean'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'BackboneElement'
  else if (propName = 'intent') then result := 'CodeableConcept'
  else if (propName = 'linkId') then result := 'string'
  else if (propName = 'status') then result := 'CodeableConcept'
  else if (propName = 'context') then result := 'Reference'
  else if (propName = 'contextLinkId') then result := 'string'
  else if (propName = 'occurrence[x]') then result := 'dateTime|Period|Timing'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'requesterLinkId') then result := 'string'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'performerRole') then result := 'CodeableConcept'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'performerLinkId') then result := 'string'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'reason') then result := 'string'
  else if (propName = 'reasonLinkId') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'securityLabelNumber') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'doNotPerform') then DoNotPerformElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value)
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'linkId') then deletePropertyValue('linkId', LinkIdList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'context') then ContextElement := nil
  else if (propName = 'contextLinkId') then deletePropertyValue('contextLinkId', ContextLinkIdList, value)
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := nil
  else if (propName = 'requester') then deletePropertyValue('requester', RequesterList, value)
  else if (propName = 'requesterLinkId') then deletePropertyValue('requesterLinkId', RequesterLinkIdList, value)
  else if (propName = 'performerType') then deletePropertyValue('performerType', PerformerTypeList, value)
  else if (propName = 'performerRole') then PerformerRoleElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'performerLinkId') then deletePropertyValue('performerLinkId', PerformerLinkIdList, value)
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'reasonLinkId') then deletePropertyValue('reasonLinkId', ReasonLinkIdList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'securityLabelNumber') then deletePropertyValue('securityLabelNumber', SecurityLabelNumberList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'doNotPerform') then DoNotPerformElement := asBoolean(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new)
  else if (propName = 'intent') then IntentElement := new as TFhirCodeableConcept
  else if (propName = 'linkId') then replacePropertyValue('linkId', LinkIdList, existing, new)
  else if (propName = 'status') then StatusElement := new as TFhirCodeableConcept
  else if (propName = 'context') then ContextElement := new as TFhirReference
  else if (propName = 'contextLinkId') then replacePropertyValue('contextLinkId', ContextLinkIdList, existing, new)
  else if (isMatchingName(propName, 'occurrence', ['DateTime', 'Period', 'Timing'])) then OccurrenceElement := new as TFhirDataType
  else if (propName = 'requester') then replacePropertyValue('requester', RequesterList, existing, new)
  else if (propName = 'requesterLinkId') then replacePropertyValue('requesterLinkId', RequesterLinkIdList, existing, new)
  else if (propName = 'performerType') then replacePropertyValue('performerType', PerformerTypeList, existing, new)
  else if (propName = 'performerRole') then PerformerRoleElement := new as TFhirCodeableConcept
  else if (propName = 'performer') then PerformerElement := new as TFhirReference
  else if (propName = 'performerLinkId') then replacePropertyValue('performerLinkId', PerformerLinkIdList, existing, new)
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'reasonLinkId') then replacePropertyValue('reasonLinkId', ReasonLinkIdList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'securityLabelNumber') then replacePropertyValue('securityLabelNumber', SecurityLabelNumberList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'subject') then SubjectList.move(source, destination)
  else if (propName = 'linkId') then LinkIdList.move(source, destination)
  else if (propName = 'contextLinkId') then ContextLinkIdList.move(source, destination)
  else if (propName = 'requester') then RequesterList.move(source, destination)
  else if (propName = 'requesterLinkId') then RequesterLinkIdList.move(source, destination)
  else if (propName = 'performerType') then PerformerTypeList.move(source, destination)
  else if (propName = 'performerLinkId') then PerformerLinkIdList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'reasonLinkId') then ReasonLinkIdList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'securityLabelNumber') then SecurityLabelNumberList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermAction.fhirType : string;
begin
  result := 'Contract.term.action';
end;

function TFhirContractTermAction.Link : TFhirContractTermAction;
begin
  result := TFhirContractTermAction(inherited Link);
end;

function TFhirContractTermAction.Clone : TFhirContractTermAction;
begin
  result := TFhirContractTermAction(inherited Clone);
end;

function TFhirContractTermAction.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermAction)) then
    result := false
  else
  begin
    o := TFhirContractTermAction(other);
    result := compareDeep(doNotPerformElement, o.doNotPerformElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(intentElement, o.intentElement, true) and compareDeep(linkIdList, o.linkIdList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(contextElement, o.contextElement, true) and 
      compareDeep(contextLinkIdList, o.contextLinkIdList, true) and compareDeep(occurrenceElement, o.occurrenceElement, true) and 
      compareDeep(requesterList, o.requesterList, true) and compareDeep(requesterLinkIdList, o.requesterLinkIdList, true) and 
      compareDeep(performerTypeList, o.performerTypeList, true) and compareDeep(performerRoleElement, o.performerRoleElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(performerLinkIdList, o.performerLinkIdList, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(reasonLinkIdList, o.reasonLinkIdList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(securityLabelNumberList, o.securityLabelNumberList, true);
  end;
end;

function TFhirContractTermAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDoNotPerform) and isEmptyProp(FType_) and isEmptyProp(FsubjectList) and isEmptyProp(FIntent) and isEmptyProp(FlinkIdList) and isEmptyProp(FStatus) and isEmptyProp(FContext) and isEmptyProp(FcontextLinkIdList) and isEmptyProp(FOccurrence) and isEmptyProp(FrequesterList) and isEmptyProp(FrequesterLinkIdList) and isEmptyProp(FperformerTypeList) and isEmptyProp(FPerformerRole) and isEmptyProp(FPerformer) and isEmptyProp(FperformerLinkIdList) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FreasonList) and isEmptyProp(FreasonLinkIdList) and isEmptyProp(FnoteList) and isEmptyProp(FsecurityLabelNumberList);
end;

procedure TFhirContractTermAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('doNotPerform');
  fields.add('type');
  fields.add('subject');
  fields.add('intent');
  fields.add('linkId');
  fields.add('status');
  fields.add('context');
  fields.add('contextLinkId');
  fields.add('occurrence[x]');
  fields.add('requester');
  fields.add('requesterLinkId');
  fields.add('performerType');
  fields.add('performerRole');
  fields.add('performer');
  fields.add('performerLinkId');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('reason');
  fields.add('reasonLinkId');
  fields.add('note');
  fields.add('securityLabelNumber');
end;

function TFhirContractTermAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSubjectList.sizeInBytes(magic));
  inc(result, FLinkIdList.sizeInBytes(magic));
  inc(result, FContextLinkIdList.sizeInBytes(magic));
  inc(result, FRequesterList.sizeInBytes(magic));
  inc(result, FRequesterLinkIdList.sizeInBytes(magic));
  inc(result, FPerformerTypeList.sizeInBytes(magic));
  inc(result, FPerformerLinkIdList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FReasonLinkIdList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSecurityLabelNumberList.sizeInBytes(magic));
end;

procedure TFhirContractTermAction.SetDoNotPerform(value : TFhirBoolean);
begin
  FDoNotPerform.free;
  FDoNotPerform := value;
end;

function TFhirContractTermAction.GetDoNotPerformST : Boolean;
begin
  if FDoNotPerform = nil then
    result := false
  else
    result := FDoNotPerform.value;
end;

procedure TFhirContractTermAction.SetDoNotPerformST(value : Boolean);
begin
  if FDoNotPerform = nil then
    FDoNotPerform := TFhirBoolean.create;
  FDoNotPerform.value := value
end;

procedure TFhirContractTermAction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirContractTermAction.GetSubjectList : TFhirContractTermActionSubjectList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirContractTermActionSubjectList.Create;
  result := FSubjectList;
end;

function TFhirContractTermAction.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

procedure TFhirContractTermAction.SetIntent(value : TFhirCodeableConcept);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirContractTermAction.GetLinkIdList : TFhirStringList;
begin
  if FLinkIdList = nil then
    FLinkIdList := TFhirStringList.Create;
  result := FLinkIdList;
end;

function TFhirContractTermAction.GetHasLinkIdList : boolean;
begin
  result := (FLinkIdList <> nil) and (FLinkIdList.count > 0);
end;

procedure TFhirContractTermAction.SetStatus(value : TFhirCodeableConcept);
begin
  FStatus.free;
  FStatus := value;
end;

procedure TFhirContractTermAction.SetContext(value : TFhirReference);
begin
  FContext.free;
  FContext := value;
end;

function TFhirContractTermAction.GetContextLinkIdList : TFhirStringList;
begin
  if FContextLinkIdList = nil then
    FContextLinkIdList := TFhirStringList.Create;
  result := FContextLinkIdList;
end;

function TFhirContractTermAction.GetHasContextLinkIdList : boolean;
begin
  result := (FContextLinkIdList <> nil) and (FContextLinkIdList.count > 0);
end;

procedure TFhirContractTermAction.SetOccurrence(value : TFhirDataType);
begin
  FOccurrence.free;
  FOccurrence := value;
end;

function TFhirContractTermAction.GetRequesterList : TFhirReferenceList;
begin
  if FRequesterList = nil then
    FRequesterList := TFhirReferenceList.Create;
  result := FRequesterList;
end;

function TFhirContractTermAction.GetHasRequesterList : boolean;
begin
  result := (FRequesterList <> nil) and (FRequesterList.count > 0);
end;

function TFhirContractTermAction.GetRequesterLinkIdList : TFhirStringList;
begin
  if FRequesterLinkIdList = nil then
    FRequesterLinkIdList := TFhirStringList.Create;
  result := FRequesterLinkIdList;
end;

function TFhirContractTermAction.GetHasRequesterLinkIdList : boolean;
begin
  result := (FRequesterLinkIdList <> nil) and (FRequesterLinkIdList.count > 0);
end;

function TFhirContractTermAction.GetPerformerTypeList : TFhirCodeableConceptList;
begin
  if FPerformerTypeList = nil then
    FPerformerTypeList := TFhirCodeableConceptList.Create;
  result := FPerformerTypeList;
end;

function TFhirContractTermAction.GetHasPerformerTypeList : boolean;
begin
  result := (FPerformerTypeList <> nil) and (FPerformerTypeList.count > 0);
end;

procedure TFhirContractTermAction.SetPerformerRole(value : TFhirCodeableConcept);
begin
  FPerformerRole.free;
  FPerformerRole := value;
end;

procedure TFhirContractTermAction.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value;
end;

function TFhirContractTermAction.GetPerformerLinkIdList : TFhirStringList;
begin
  if FPerformerLinkIdList = nil then
    FPerformerLinkIdList := TFhirStringList.Create;
  result := FPerformerLinkIdList;
end;

function TFhirContractTermAction.GetHasPerformerLinkIdList : boolean;
begin
  result := (FPerformerLinkIdList <> nil) and (FPerformerLinkIdList.count > 0);
end;

function TFhirContractTermAction.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirContractTermAction.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirContractTermAction.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirContractTermAction.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirContractTermAction.GetReasonList : TFhirStringList;
begin
  if FReasonList = nil then
    FReasonList := TFhirStringList.Create;
  result := FReasonList;
end;

function TFhirContractTermAction.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirContractTermAction.GetReasonLinkIdList : TFhirStringList;
begin
  if FReasonLinkIdList = nil then
    FReasonLinkIdList := TFhirStringList.Create;
  result := FReasonLinkIdList;
end;

function TFhirContractTermAction.GetHasReasonLinkIdList : boolean;
begin
  result := (FReasonLinkIdList <> nil) and (FReasonLinkIdList.count > 0);
end;

function TFhirContractTermAction.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirContractTermAction.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirContractTermAction.GetSecurityLabelNumberList : TFhirUnsignedIntList;
begin
  if FSecurityLabelNumberList = nil then
    FSecurityLabelNumberList := TFhirUnsignedIntList.Create;
  result := FSecurityLabelNumberList;
end;

function TFhirContractTermAction.GetHasSecurityLabelNumberList : boolean;
begin
  result := (FSecurityLabelNumberList <> nil) and (FSecurityLabelNumberList.count > 0);
end;

{ TFhirContractTermActionListEnumerator }

constructor TFhirContractTermActionListEnumerator.Create(list : TFhirContractTermActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermActionListEnumerator.GetCurrent : TFhirContractTermAction;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermActionList }

function TFhirContractTermActionList.AddItem(value: TFhirContractTermAction): TFhirContractTermAction;
begin
  assert(value.ClassName = 'TFhirContractTermAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermAction');
  add(value);
  result := value;
end;

function TFhirContractTermActionList.Append: TFhirContractTermAction;
begin
  result := TFhirContractTermAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermActionList.GetEnumerator : TFhirContractTermActionListEnumerator;
begin
  result := TFhirContractTermActionListEnumerator.Create(self.link);
end;

function TFhirContractTermActionList.Clone: TFhirContractTermActionList;
begin
  result := TFhirContractTermActionList(inherited Clone);
end;

function TFhirContractTermActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermActionList.GetItemN(index: Integer): TFhirContractTermAction;
begin
  result := TFhirContractTermAction(ObjectByIndex[index]);
end;

function TFhirContractTermActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermAction;
end;
function TFhirContractTermActionList.IndexOf(value: TFhirContractTermAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermActionList.Insert(index: Integer): TFhirContractTermAction;
begin
  result := TFhirContractTermAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionList.InsertItem(index: Integer; value: TFhirContractTermAction);
begin
  assert(value is TFhirContractTermAction);
  Inherited Insert(index, value);
end;

function TFhirContractTermActionList.Item(index: Integer): TFhirContractTermAction;
begin
  result := TFhirContractTermAction(ObjectByIndex[index]);
end;

function TFhirContractTermActionList.Link: TFhirContractTermActionList;
begin
  result := TFhirContractTermActionList(inherited Link);
end;

procedure TFhirContractTermActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermActionList.SetItemByIndex(index: Integer; value: TFhirContractTermAction);
begin
  assert(value is TFhirContractTermAction);
  FhirContractTermActions[index] := value;
end;

procedure TFhirContractTermActionList.SetItemN(index: Integer; value: TFhirContractTermAction);
begin
  assert(value is TFhirContractTermAction);
  ObjectByIndex[index] := value;
end;

{ TFhirContractTermActionSubject }

constructor TFhirContractTermActionSubject.Create;
begin
  inherited;
end;

destructor TFhirContractTermActionSubject.Destroy;
begin
  FReferenceList.Free;
  FRole.free;
  inherited;
end;

procedure TFhirContractTermActionSubject.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContractTermActionSubject(oSource).FReferenceList = nil) then
  begin
    FReferenceList.free;
    FReferenceList := nil;
  end
  else
  begin
    if FReferenceList = nil then
      FReferenceList := TFhirReferenceList.Create;
    FReferenceList.Assign(TFhirContractTermActionSubject(oSource).FReferenceList);
  end;
  role := TFhirContractTermActionSubject(oSource).role.Clone;
end;

procedure TFhirContractTermActionSubject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'reference') Then
    list.addAll(self, 'reference', FReferenceList);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirContractTermActionSubject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'reference', 'Reference', true, TFhirReference, FReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
end;

function TFhirContractTermActionSubject.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'reference') then
  begin
    ReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractTermActionSubject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'reference') then ReferenceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirContractTermActionSubject.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'reference') then result := ReferenceList.new()
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractTermActionSubject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'reference') then result := 'Reference'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractTermActionSubject.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'reference') then deletePropertyValue('reference', ReferenceList, value)
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractTermActionSubject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'reference') then replacePropertyValue('reference', ReferenceList, existing, new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractTermActionSubject.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'reference') then ReferenceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractTermActionSubject.fhirType : string;
begin
  result := 'Contract.term.action.subject';
end;

function TFhirContractTermActionSubject.Link : TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(inherited Link);
end;

function TFhirContractTermActionSubject.Clone : TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(inherited Clone);
end;

function TFhirContractTermActionSubject.equals(other : TObject) : boolean; 
var
  o : TFhirContractTermActionSubject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractTermActionSubject)) then
    result := false
  else
  begin
    o := TFhirContractTermActionSubject(other);
    result := compareDeep(referenceList, o.referenceList, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirContractTermActionSubject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FreferenceList) and isEmptyProp(FRole);
end;

procedure TFhirContractTermActionSubject.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('reference');
  fields.add('role');
end;

function TFhirContractTermActionSubject.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FReferenceList.sizeInBytes(magic));
end;

function TFhirContractTermActionSubject.GetReferenceList : TFhirReferenceList;
begin
  if FReferenceList = nil then
    FReferenceList := TFhirReferenceList.Create;
  result := FReferenceList;
end;

function TFhirContractTermActionSubject.GetHasReferenceList : boolean;
begin
  result := (FReferenceList <> nil) and (FReferenceList.count > 0);
end;

procedure TFhirContractTermActionSubject.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

{ TFhirContractTermActionSubjectListEnumerator }

constructor TFhirContractTermActionSubjectListEnumerator.Create(list : TFhirContractTermActionSubjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractTermActionSubjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractTermActionSubjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractTermActionSubjectListEnumerator.GetCurrent : TFhirContractTermActionSubject;
begin
  Result := FList[FIndex];
end;

function TFhirContractTermActionSubjectListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractTermActionSubjectList }

function TFhirContractTermActionSubjectList.AddItem(value: TFhirContractTermActionSubject): TFhirContractTermActionSubject;
begin
  assert(value.ClassName = 'TFhirContractTermActionSubject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractTermActionSubject');
  add(value);
  result := value;
end;

function TFhirContractTermActionSubjectList.Append: TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionSubjectList.ClearItems;
begin
  Clear;
end;

function TFhirContractTermActionSubjectList.GetEnumerator : TFhirContractTermActionSubjectListEnumerator;
begin
  result := TFhirContractTermActionSubjectListEnumerator.Create(self.link);
end;

function TFhirContractTermActionSubjectList.Clone: TFhirContractTermActionSubjectList;
begin
  result := TFhirContractTermActionSubjectList(inherited Clone);
end;

function TFhirContractTermActionSubjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractTermActionSubjectList.GetItemN(index: Integer): TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(ObjectByIndex[index]);
end;

function TFhirContractTermActionSubjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractTermActionSubject;
end;
function TFhirContractTermActionSubjectList.IndexOf(value: TFhirContractTermActionSubject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractTermActionSubjectList.Insert(index: Integer): TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractTermActionSubjectList.InsertItem(index: Integer; value: TFhirContractTermActionSubject);
begin
  assert(value is TFhirContractTermActionSubject);
  Inherited Insert(index, value);
end;

function TFhirContractTermActionSubjectList.Item(index: Integer): TFhirContractTermActionSubject;
begin
  result := TFhirContractTermActionSubject(ObjectByIndex[index]);
end;

function TFhirContractTermActionSubjectList.Link: TFhirContractTermActionSubjectList;
begin
  result := TFhirContractTermActionSubjectList(inherited Link);
end;

procedure TFhirContractTermActionSubjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractTermActionSubjectList.SetItemByIndex(index: Integer; value: TFhirContractTermActionSubject);
begin
  assert(value is TFhirContractTermActionSubject);
  FhirContractTermActionSubjects[index] := value;
end;

procedure TFhirContractTermActionSubjectList.SetItemN(index: Integer; value: TFhirContractTermActionSubject);
begin
  assert(value is TFhirContractTermActionSubject);
  ObjectByIndex[index] := value;
end;

{ TFhirContractSigner }

constructor TFhirContractSigner.Create;
begin
  inherited;
end;

destructor TFhirContractSigner.Destroy;
begin
  FType_.free;
  FParty.free;
  FSignatureList.Free;
  inherited;
end;

procedure TFhirContractSigner.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirContractSigner(oSource).type_.Clone;
  party := TFhirContractSigner(oSource).party.Clone;
  if (TFhirContractSigner(oSource).FSignatureList = nil) then
  begin
    FSignatureList.free;
    FSignatureList := nil;
  end
  else
  begin
    if FSignatureList = nil then
      FSignatureList := TFhirSignatureList.Create;
    FSignatureList.Assign(TFhirContractSigner(oSource).FSignatureList);
  end;
end;

procedure TFhirContractSigner.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'party') Then
     list.add(self.link, 'party', FParty.Link);
  if (child_name = 'signature') Then
    list.addAll(self, 'signature', FSignatureList);
end;

procedure TFhirContractSigner.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'Coding', false, TFhirCoding, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'party', 'Reference', false, TFhirReference, FParty.Link));
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', true, TFhirSignature, FSignatureList.Link));
end;

function TFhirContractSigner.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCoding;
    result := propValue;
  end
  else if (propName = 'party') then
  begin
    Party := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureList.add(propValue as TFhirSignature);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractSigner.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'signature') then SignatureList.insertItem(index, propValue as TFhirSignature)
  else inherited;
end;

function TFhirContractSigner.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCoding.create()
  else if (propName = 'party') then result := TFhirReference.create()
  else if (propName = 'signature') then result := SignatureList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractSigner.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'Coding'
  else if (propName = 'party') then result := 'Reference'
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractSigner.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'party') then PartyElement := nil
  else if (propName = 'signature') then deletePropertyValue('signature', SignatureList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractSigner.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCoding
  else if (propName = 'party') then PartyElement := new as TFhirReference
  else if (propName = 'signature') then replacePropertyValue('signature', SignatureList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractSigner.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'signature') then SignatureList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContractSigner.fhirType : string;
begin
  result := 'Contract.signer';
end;

function TFhirContractSigner.Link : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Link);
end;

function TFhirContractSigner.Clone : TFhirContractSigner;
begin
  result := TFhirContractSigner(inherited Clone);
end;

function TFhirContractSigner.equals(other : TObject) : boolean; 
var
  o : TFhirContractSigner;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractSigner)) then
    result := false
  else
  begin
    o := TFhirContractSigner(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(partyElement, o.partyElement, true) and 
      compareDeep(signatureList, o.signatureList, true);
  end;
end;

function TFhirContractSigner.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FParty) and isEmptyProp(FsignatureList);
end;

procedure TFhirContractSigner.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('party');
  fields.add('signature');
end;

function TFhirContractSigner.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSignatureList.sizeInBytes(magic));
end;

procedure TFhirContractSigner.SetType_(value : TFhirCoding);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirContractSigner.SetParty(value : TFhirReference);
begin
  FParty.free;
  FParty := value;
end;

function TFhirContractSigner.GetSignatureList : TFhirSignatureList;
begin
  if FSignatureList = nil then
    FSignatureList := TFhirSignatureList.Create;
  result := FSignatureList;
end;

function TFhirContractSigner.GetHasSignatureList : boolean;
begin
  result := (FSignatureList <> nil) and (FSignatureList.count > 0);
end;

{ TFhirContractSignerListEnumerator }

constructor TFhirContractSignerListEnumerator.Create(list : TFhirContractSignerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractSignerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractSignerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractSignerListEnumerator.GetCurrent : TFhirContractSigner;
begin
  Result := FList[FIndex];
end;

function TFhirContractSignerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractSignerList }

function TFhirContractSignerList.AddItem(value: TFhirContractSigner): TFhirContractSigner;
begin
  assert(value.ClassName = 'TFhirContractSigner', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractSigner');
  add(value);
  result := value;
end;

function TFhirContractSignerList.Append: TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.ClearItems;
begin
  Clear;
end;

function TFhirContractSignerList.GetEnumerator : TFhirContractSignerListEnumerator;
begin
  result := TFhirContractSignerListEnumerator.Create(self.link);
end;

function TFhirContractSignerList.Clone: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Clone);
end;

function TFhirContractSignerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractSignerList.GetItemN(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractSigner;
end;
function TFhirContractSignerList.IndexOf(value: TFhirContractSigner): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractSignerList.Insert(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractSignerList.InsertItem(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  Inherited Insert(index, value);
end;

function TFhirContractSignerList.Item(index: Integer): TFhirContractSigner;
begin
  result := TFhirContractSigner(ObjectByIndex[index]);
end;

function TFhirContractSignerList.Link: TFhirContractSignerList;
begin
  result := TFhirContractSignerList(inherited Link);
end;

procedure TFhirContractSignerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractSignerList.SetItemByIndex(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  FhirContractSigners[index] := value;
end;

procedure TFhirContractSignerList.SetItemN(index: Integer; value: TFhirContractSigner);
begin
  assert(value is TFhirContractSigner);
  ObjectByIndex[index] := value;
end;

{ TFhirContractFriendly }

constructor TFhirContractFriendly.Create;
begin
  inherited;
end;

destructor TFhirContractFriendly.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractFriendly.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractFriendly(oSource).content.Clone;
end;

procedure TFhirContractFriendly.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractFriendly.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference', false, TFhirDataType, FContent.Link));
end;

function TFhirContractFriendly.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractFriendly.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractFriendly.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractFriendly.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractFriendly.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractFriendly.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractFriendly.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractFriendly.fhirType : string;
begin
  result := 'Contract.friendly';
end;

function TFhirContractFriendly.Link : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Link);
end;

function TFhirContractFriendly.Clone : TFhirContractFriendly;
begin
  result := TFhirContractFriendly(inherited Clone);
end;

function TFhirContractFriendly.equals(other : TObject) : boolean; 
var
  o : TFhirContractFriendly;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractFriendly)) then
    result := false
  else
  begin
    o := TFhirContractFriendly(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractFriendly.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractFriendly.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirContractFriendly.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractFriendly.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value;
end;

{ TFhirContractFriendlyListEnumerator }

constructor TFhirContractFriendlyListEnumerator.Create(list : TFhirContractFriendlyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractFriendlyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractFriendlyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractFriendlyListEnumerator.GetCurrent : TFhirContractFriendly;
begin
  Result := FList[FIndex];
end;

function TFhirContractFriendlyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractFriendlyList }

function TFhirContractFriendlyList.AddItem(value: TFhirContractFriendly): TFhirContractFriendly;
begin
  assert(value.ClassName = 'TFhirContractFriendly', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractFriendly');
  add(value);
  result := value;
end;

function TFhirContractFriendlyList.Append: TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.ClearItems;
begin
  Clear;
end;

function TFhirContractFriendlyList.GetEnumerator : TFhirContractFriendlyListEnumerator;
begin
  result := TFhirContractFriendlyListEnumerator.Create(self.link);
end;

function TFhirContractFriendlyList.Clone: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Clone);
end;

function TFhirContractFriendlyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractFriendlyList.GetItemN(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractFriendly;
end;
function TFhirContractFriendlyList.IndexOf(value: TFhirContractFriendly): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractFriendlyList.Insert(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractFriendlyList.InsertItem(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  Inherited Insert(index, value);
end;

function TFhirContractFriendlyList.Item(index: Integer): TFhirContractFriendly;
begin
  result := TFhirContractFriendly(ObjectByIndex[index]);
end;

function TFhirContractFriendlyList.Link: TFhirContractFriendlyList;
begin
  result := TFhirContractFriendlyList(inherited Link);
end;

procedure TFhirContractFriendlyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractFriendlyList.SetItemByIndex(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  FhirContractFriendlies[index] := value;
end;

procedure TFhirContractFriendlyList.SetItemN(index: Integer; value: TFhirContractFriendly);
begin
  assert(value is TFhirContractFriendly);
  ObjectByIndex[index] := value;
end;

{ TFhirContractLegal }

constructor TFhirContractLegal.Create;
begin
  inherited;
end;

destructor TFhirContractLegal.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractLegal.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractLegal(oSource).content.Clone;
end;

procedure TFhirContractLegal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractLegal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference', false, TFhirDataType, FContent.Link));
end;

function TFhirContractLegal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractLegal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractLegal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractLegal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractLegal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractLegal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractLegal.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractLegal.fhirType : string;
begin
  result := 'Contract.legal';
end;

function TFhirContractLegal.Link : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Link);
end;

function TFhirContractLegal.Clone : TFhirContractLegal;
begin
  result := TFhirContractLegal(inherited Clone);
end;

function TFhirContractLegal.equals(other : TObject) : boolean; 
var
  o : TFhirContractLegal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractLegal)) then
    result := false
  else
  begin
    o := TFhirContractLegal(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractLegal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractLegal.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirContractLegal.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractLegal.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value;
end;

{ TFhirContractLegalListEnumerator }

constructor TFhirContractLegalListEnumerator.Create(list : TFhirContractLegalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractLegalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractLegalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractLegalListEnumerator.GetCurrent : TFhirContractLegal;
begin
  Result := FList[FIndex];
end;

function TFhirContractLegalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractLegalList }

function TFhirContractLegalList.AddItem(value: TFhirContractLegal): TFhirContractLegal;
begin
  assert(value.ClassName = 'TFhirContractLegal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractLegal');
  add(value);
  result := value;
end;

function TFhirContractLegalList.Append: TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.ClearItems;
begin
  Clear;
end;

function TFhirContractLegalList.GetEnumerator : TFhirContractLegalListEnumerator;
begin
  result := TFhirContractLegalListEnumerator.Create(self.link);
end;

function TFhirContractLegalList.Clone: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Clone);
end;

function TFhirContractLegalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractLegalList.GetItemN(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractLegal;
end;
function TFhirContractLegalList.IndexOf(value: TFhirContractLegal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractLegalList.Insert(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractLegalList.InsertItem(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  Inherited Insert(index, value);
end;

function TFhirContractLegalList.Item(index: Integer): TFhirContractLegal;
begin
  result := TFhirContractLegal(ObjectByIndex[index]);
end;

function TFhirContractLegalList.Link: TFhirContractLegalList;
begin
  result := TFhirContractLegalList(inherited Link);
end;

procedure TFhirContractLegalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractLegalList.SetItemByIndex(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  FhirContractLegals[index] := value;
end;

procedure TFhirContractLegalList.SetItemN(index: Integer; value: TFhirContractLegal);
begin
  assert(value is TFhirContractLegal);
  ObjectByIndex[index] := value;
end;

{ TFhirContractRule }

constructor TFhirContractRule.Create;
begin
  inherited;
end;

destructor TFhirContractRule.Destroy;
begin
  FContent.free;
  inherited;
end;

procedure TFhirContractRule.Assign(oSource : TFslObject);
begin
  inherited;
  content := TFhirContractRule(oSource).content.Clone;
end;

procedure TFhirContractRule.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'content[x]') or (child_name = 'content') Then
     list.add(self.link, 'content[x]', FContent.Link);
end;

procedure TFhirContractRule.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'content[x]', 'Attachment|Reference', false, TFhirDataType, FContent.Link));
end;

function TFhirContractRule.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then
  begin
    Content := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContractRule.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirContractRule.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property Content')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContractRule.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'content[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContractRule.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContractRule.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'content', ['Attachment', 'Reference'])) then ContentElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContractRule.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirContractRule.fhirType : string;
begin
  result := 'Contract.rule';
end;

function TFhirContractRule.Link : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Link);
end;

function TFhirContractRule.Clone : TFhirContractRule;
begin
  result := TFhirContractRule(inherited Clone);
end;

function TFhirContractRule.equals(other : TObject) : boolean; 
var
  o : TFhirContractRule;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContractRule)) then
    result := false
  else
  begin
    o := TFhirContractRule(other);
    result := compareDeep(contentElement, o.contentElement, true);
  end;
end;

function TFhirContractRule.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FContent);
end;

procedure TFhirContractRule.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('content[x]');
end;

function TFhirContractRule.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirContractRule.SetContent(value : TFhirDataType);
begin
  FContent.free;
  FContent := value;
end;

{ TFhirContractRuleListEnumerator }

constructor TFhirContractRuleListEnumerator.Create(list : TFhirContractRuleList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractRuleListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractRuleListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractRuleListEnumerator.GetCurrent : TFhirContractRule;
begin
  Result := FList[FIndex];
end;

function TFhirContractRuleListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractRuleList }

function TFhirContractRuleList.AddItem(value: TFhirContractRule): TFhirContractRule;
begin
  assert(value.ClassName = 'TFhirContractRule', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContractRule');
  add(value);
  result := value;
end;

function TFhirContractRuleList.Append: TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.ClearItems;
begin
  Clear;
end;

function TFhirContractRuleList.GetEnumerator : TFhirContractRuleListEnumerator;
begin
  result := TFhirContractRuleListEnumerator.Create(self.link);
end;

function TFhirContractRuleList.Clone: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Clone);
end;

function TFhirContractRuleList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractRuleList.GetItemN(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.ItemClass: TFslObjectClass;
begin
  result := TFhirContractRule;
end;
function TFhirContractRuleList.IndexOf(value: TFhirContractRule): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractRuleList.Insert(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractRuleList.InsertItem(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  Inherited Insert(index, value);
end;

function TFhirContractRuleList.Item(index: Integer): TFhirContractRule;
begin
  result := TFhirContractRule(ObjectByIndex[index]);
end;

function TFhirContractRuleList.Link: TFhirContractRuleList;
begin
  result := TFhirContractRuleList(inherited Link);
end;

procedure TFhirContractRuleList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractRuleList.SetItemByIndex(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  FhirContractRules[index] := value;
end;

procedure TFhirContractRuleList.SetItemN(index: Integer; value: TFhirContractRule);
begin
  assert(value is TFhirContractRule);
  ObjectByIndex[index] := value;
end;

{ TFhirContract }

constructor TFhirContract.Create;
begin
  inherited;
end;

destructor TFhirContract.Destroy;
begin
  FIdentifierList.Free;
  FUrl.free;
  FVersion.free;
  FStatus.free;
  FLegalState.free;
  FInstantiatesCanonical.free;
  FInstantiatesUri.free;
  FContentDerivative.free;
  FIssued.free;
  FApplies.free;
  FExpirationType.free;
  FSubjectList.Free;
  FAuthorityList.Free;
  FDomainList.Free;
  FSiteList.Free;
  FName.free;
  FTitle.free;
  FSubtitle.free;
  FAliasList.Free;
  FAuthor.free;
  FScope.free;
  FTopic.free;
  FType_.free;
  FSubTypeList.Free;
  FContentDefinition.free;
  FTermList.Free;
  FSupportingInfoList.Free;
  FRelevantHistoryList.Free;
  FSignerList.Free;
  FFriendlyList.Free;
  FLegalList.Free;
  FRuleList.Free;
  FLegallyBinding.free;
  inherited;
end;

procedure TFhirContract.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirContract(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirContract(oSource).FIdentifierList);
  end;
  urlElement := TFhirContract(oSource).urlElement.Clone;
  versionElement := TFhirContract(oSource).versionElement.Clone;
  statusElement := TFhirContract(oSource).statusElement.Clone;
  legalState := TFhirContract(oSource).legalState.Clone;
  instantiatesCanonical := TFhirContract(oSource).instantiatesCanonical.Clone;
  instantiatesUriElement := TFhirContract(oSource).instantiatesUriElement.Clone;
  contentDerivative := TFhirContract(oSource).contentDerivative.Clone;
  issuedElement := TFhirContract(oSource).issuedElement.Clone;
  applies := TFhirContract(oSource).applies.Clone;
  expirationType := TFhirContract(oSource).expirationType.Clone;
  if (TFhirContract(oSource).FSubjectList = nil) then
  begin
    FSubjectList.free;
    FSubjectList := nil;
  end
  else
  begin
    if FSubjectList = nil then
      FSubjectList := TFhirReferenceList.Create;
    FSubjectList.Assign(TFhirContract(oSource).FSubjectList);
  end;
  if (TFhirContract(oSource).FAuthorityList = nil) then
  begin
    FAuthorityList.free;
    FAuthorityList := nil;
  end
  else
  begin
    if FAuthorityList = nil then
      FAuthorityList := TFhirReferenceList.Create;
    FAuthorityList.Assign(TFhirContract(oSource).FAuthorityList);
  end;
  if (TFhirContract(oSource).FDomainList = nil) then
  begin
    FDomainList.free;
    FDomainList := nil;
  end
  else
  begin
    if FDomainList = nil then
      FDomainList := TFhirReferenceList.Create;
    FDomainList.Assign(TFhirContract(oSource).FDomainList);
  end;
  if (TFhirContract(oSource).FSiteList = nil) then
  begin
    FSiteList.free;
    FSiteList := nil;
  end
  else
  begin
    if FSiteList = nil then
      FSiteList := TFhirReferenceList.Create;
    FSiteList.Assign(TFhirContract(oSource).FSiteList);
  end;
  nameElement := TFhirContract(oSource).nameElement.Clone;
  titleElement := TFhirContract(oSource).titleElement.Clone;
  subtitleElement := TFhirContract(oSource).subtitleElement.Clone;
  if (TFhirContract(oSource).FAliasList = nil) then
  begin
    FAliasList.free;
    FAliasList := nil;
  end
  else
  begin
    if FAliasList = nil then
      FAliasList := TFhirStringList.Create;
    FAliasList.Assign(TFhirContract(oSource).FAliasList);
  end;
  author := TFhirContract(oSource).author.Clone;
  scope := TFhirContract(oSource).scope.Clone;
  topic := TFhirContract(oSource).topic.Clone;
  type_ := TFhirContract(oSource).type_.Clone;
  if (TFhirContract(oSource).FSubTypeList = nil) then
  begin
    FSubTypeList.free;
    FSubTypeList := nil;
  end
  else
  begin
    if FSubTypeList = nil then
      FSubTypeList := TFhirCodeableConceptList.Create;
    FSubTypeList.Assign(TFhirContract(oSource).FSubTypeList);
  end;
  contentDefinition := TFhirContract(oSource).contentDefinition.Clone;
  if (TFhirContract(oSource).FTermList = nil) then
  begin
    FTermList.free;
    FTermList := nil;
  end
  else
  begin
    if FTermList = nil then
      FTermList := TFhirContractTermList.Create;
    FTermList.Assign(TFhirContract(oSource).FTermList);
  end;
  if (TFhirContract(oSource).FSupportingInfoList = nil) then
  begin
    FSupportingInfoList.free;
    FSupportingInfoList := nil;
  end
  else
  begin
    if FSupportingInfoList = nil then
      FSupportingInfoList := TFhirReferenceList.Create;
    FSupportingInfoList.Assign(TFhirContract(oSource).FSupportingInfoList);
  end;
  if (TFhirContract(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList.Create;
    FRelevantHistoryList.Assign(TFhirContract(oSource).FRelevantHistoryList);
  end;
  if (TFhirContract(oSource).FSignerList = nil) then
  begin
    FSignerList.free;
    FSignerList := nil;
  end
  else
  begin
    if FSignerList = nil then
      FSignerList := TFhirContractSignerList.Create;
    FSignerList.Assign(TFhirContract(oSource).FSignerList);
  end;
  if (TFhirContract(oSource).FFriendlyList = nil) then
  begin
    FFriendlyList.free;
    FFriendlyList := nil;
  end
  else
  begin
    if FFriendlyList = nil then
      FFriendlyList := TFhirContractFriendlyList.Create;
    FFriendlyList.Assign(TFhirContract(oSource).FFriendlyList);
  end;
  if (TFhirContract(oSource).FLegalList = nil) then
  begin
    FLegalList.free;
    FLegalList := nil;
  end
  else
  begin
    if FLegalList = nil then
      FLegalList := TFhirContractLegalList.Create;
    FLegalList.Assign(TFhirContract(oSource).FLegalList);
  end;
  if (TFhirContract(oSource).FRuleList = nil) then
  begin
    FRuleList.free;
    FRuleList := nil;
  end
  else
  begin
    if FRuleList = nil then
      FRuleList := TFhirContractRuleList.Create;
    FRuleList.Assign(TFhirContract(oSource).FRuleList);
  end;
  legallyBinding := TFhirContract(oSource).legallyBinding.Clone;
end;

function TFhirContract.GetResourceType : TFhirResourceType;
begin
  result := frtContract;
end;

procedure TFhirContract.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'legalState') Then
     list.add(self.link, 'legalState', FLegalState.Link);
  if (child_name = 'instantiatesCanonical') Then
     list.add(self.link, 'instantiatesCanonical', FInstantiatesCanonical.Link);
  if (child_name = 'instantiatesUri') Then
     list.add(self.link, 'instantiatesUri', FInstantiatesUri.Link);
  if (child_name = 'contentDerivative') Then
     list.add(self.link, 'contentDerivative', FContentDerivative.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'applies') Then
     list.add(self.link, 'applies', FApplies.Link);
  if (child_name = 'expirationType') Then
     list.add(self.link, 'expirationType', FExpirationType.Link);
  if (child_name = 'subject') Then
    list.addAll(self, 'subject', FSubjectList);
  if (child_name = 'authority') Then
    list.addAll(self, 'authority', FAuthorityList);
  if (child_name = 'domain') Then
    list.addAll(self, 'domain', FDomainList);
  if (child_name = 'site') Then
    list.addAll(self, 'site', FSiteList);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'alias') Then
    list.addAll(self, 'alias', FAliasList);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'scope') Then
     list.add(self.link, 'scope', FScope.Link);
  if (child_name = 'topic[x]') or (child_name = 'topic') Then
     list.add(self.link, 'topic[x]', FTopic.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'subType') Then
    list.addAll(self, 'subType', FSubTypeList);
  if (child_name = 'contentDefinition') Then
     list.add(self.link, 'contentDefinition', FContentDefinition.Link);
  if (child_name = 'term') Then
    list.addAll(self, 'term', FTermList);
  if (child_name = 'supportingInfo') Then
    list.addAll(self, 'supportingInfo', FSupportingInfoList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
  if (child_name = 'signer') Then
    list.addAll(self, 'signer', FSignerList);
  if (child_name = 'friendly') Then
    list.addAll(self, 'friendly', FFriendlyList);
  if (child_name = 'legal') Then
    list.addAll(self, 'legal', FLegalList);
  if (child_name = 'rule') Then
    list.addAll(self, 'rule', FRuleList);
  if (child_name = 'legallyBinding[x]') or (child_name = 'legallyBinding') Then
     list.add(self.link, 'legallyBinding[x]', FLegallyBinding.Link);
end;

procedure TFhirContract.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'legalState', 'CodeableConcept', false, TFhirCodeableConcept, FLegalState.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'Reference', false, TFhirReference, FInstantiatesCanonical.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', false, TFhirUri, FInstantiatesUri.Link));
  oList.add(TFHIRProperty.create(self, 'contentDerivative', 'CodeableConcept', false, TFhirCodeableConcept, FContentDerivative.Link));
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));
  oList.add(TFHIRProperty.create(self, 'applies', 'Period', false, TFhirPeriod, FApplies.Link));
  oList.add(TFHIRProperty.create(self, 'expirationType', 'CodeableConcept', false, TFhirCodeableConcept, FExpirationType.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', true, TFhirReference, FSubjectList.Link));
  oList.add(TFHIRProperty.create(self, 'authority', 'Reference', true, TFhirReference, FAuthorityList.Link));
  oList.add(TFHIRProperty.create(self, 'domain', 'Reference', true, TFhirReference, FDomainList.Link));
  oList.add(TFHIRProperty.create(self, 'site', 'Reference', true, TFhirReference, FSiteList.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'alias', 'string', true, TFhirString, FAliasList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'scope', 'CodeableConcept', false, TFhirCodeableConcept, FScope.Link));
  oList.add(TFHIRProperty.create(self, 'topic[x]', 'CodeableConcept|Reference', false, TFhirDataType, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'subType', 'CodeableConcept', true, TFhirCodeableConcept, FSubTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'contentDefinition', 'BackboneElement', false, TFhirContractContentDefinition, FContentDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'term', 'BackboneElement', true, TFhirContractTerm, FTermList.Link));
  oList.add(TFHIRProperty.create(self, 'supportingInfo', 'Reference', true, TFhirReference, FSupportingInfoList.Link));
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference', true, TFhirReference, FRelevantHistoryList.Link));
  oList.add(TFHIRProperty.create(self, 'signer', 'BackboneElement', true, TFhirContractSigner, FSignerList.Link));
  oList.add(TFHIRProperty.create(self, 'friendly', 'BackboneElement', true, TFhirContractFriendly, FFriendlyList.Link));
  oList.add(TFHIRProperty.create(self, 'legal', 'BackboneElement', true, TFhirContractLegal, FLegalList.Link));
  oList.add(TFHIRProperty.create(self, 'rule', 'BackboneElement', true, TFhirContractRule, FRuleList.Link));
  oList.add(TFHIRProperty.create(self, 'legallyBinding[x]', 'Attachment|Reference', false, TFhirDataType, FLegallyBinding.Link));
end;

function TFhirContract.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirContractResourceStatusCodesEnum, CODES_TFhirContractResourceStatusCodesEnum, propValue);
    result := propValue;
  end
  else if (propName = 'legalState') then
  begin
    LegalState := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonical := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'contentDerivative') then
  begin
    ContentDerivative := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'applies') then
  begin
    Applies := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'expirationType') then
  begin
    ExpirationType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    SubjectList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'authority') then
  begin
    AuthorityList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'domain') then
  begin
    DomainList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    SiteList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'alias') then
  begin
    AliasList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'scope') then
  begin
    Scope := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then
  begin
    Topic := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subType') then
  begin
    SubTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'contentDefinition') then
  begin
    ContentDefinition := propValue as TFhirContractContentDefinition;
    result := propValue;
  end
  else if (propName = 'term') then
  begin
    TermList.add(propValue as TFhirContractTerm);
    result := propValue;
  end
  else if (propName = 'supportingInfo') then
  begin
    SupportingInfoList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'signer') then
  begin
    SignerList.add(propValue as TFhirContractSigner);
    result := propValue;
  end
  else if (propName = 'friendly') then
  begin
    FriendlyList.add(propValue as TFhirContractFriendly);
    result := propValue;
  end
  else if (propName = 'legal') then
  begin
    LegalList.add(propValue as TFhirContractLegal);
    result := propValue;
  end
  else if (propName = 'rule') then
  begin
    RuleList.add(propValue as TFhirContractRule);
    result := propValue;
  end
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then
  begin
    LegallyBinding := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirContract.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'subject') then SubjectList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'authority') then AuthorityList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'domain') then DomainList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'site') then SiteList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'alias') then AliasList.insertItem(index, asString(propValue))
  else if (propName = 'subType') then SubTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'term') then TermList.insertItem(index, propValue as TFhirContractTerm)
  else if (propName = 'supportingInfo') then SupportingInfoList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'signer') then SignerList.insertItem(index, propValue as TFhirContractSigner)
  else if (propName = 'friendly') then FriendlyList.insertItem(index, propValue as TFhirContractFriendly)
  else if (propName = 'legal') then LegalList.insertItem(index, propValue as TFhirContractLegal)
  else if (propName = 'rule') then RuleList.insertItem(index, propValue as TFhirContractRule)
  else inherited;
end;

function TFhirContract.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirContractResourceStatusCodesEnum[ContractResourceStatusCodesNull], CODES_TFhirContractResourceStatusCodesEnum[ContractResourceStatusCodesNull]) 
  else if (propName = 'legalState') then result := TFhirCodeableConcept.create()
  else if (propName = 'instantiatesCanonical') then result := TFhirReference.create()
  else if (propName = 'instantiatesUri') then result := TFhirUri.create()
  else if (propName = 'contentDerivative') then result := TFhirCodeableConcept.create()
  else if (propName = 'issued') then result := TFhirDateTime.create()
  else if (propName = 'applies') then result := TFhirPeriod.create()
  else if (propName = 'expirationType') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := SubjectList.new()
  else if (propName = 'authority') then result := AuthorityList.new()
  else if (propName = 'domain') then result := DomainList.new()
  else if (propName = 'site') then result := SiteList.new()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'alias') then result := AliasList.new()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'scope') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Topic')
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'subType') then result := SubTypeList.new()
  else if (propName = 'contentDefinition') then result := TFhirContractContentDefinition.create()
  else if (propName = 'term') then result := TermList.new()
  else if (propName = 'supportingInfo') then result := SupportingInfoList.new()
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new()
  else if (propName = 'signer') then result := SignerList.new()
  else if (propName = 'friendly') then result := FriendlyList.new()
  else if (propName = 'legal') then result := LegalList.new()
  else if (propName = 'rule') then result := RuleList.new()
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then raise EFHIRException.create('Cannot make property LegallyBinding')
  else result := inherited createPropertyValue(propName);
end;

function TFhirContract.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'url') then result := 'uri'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'legalState') then result := 'CodeableConcept'
  else if (propName = 'instantiatesCanonical') then result := 'Reference'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'contentDerivative') then result := 'CodeableConcept'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'applies') then result := 'Period'
  else if (propName = 'expirationType') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'authority') then result := 'Reference'
  else if (propName = 'domain') then result := 'Reference'
  else if (propName = 'site') then result := 'Reference'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'alias') then result := 'string'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'scope') then result := 'CodeableConcept'
  else if (propName = 'topic[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'subType') then result := 'CodeableConcept'
  else if (propName = 'contentDefinition') then result := 'BackboneElement'
  else if (propName = 'term') then result := 'BackboneElement'
  else if (propName = 'supportingInfo') then result := 'Reference'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else if (propName = 'signer') then result := 'BackboneElement'
  else if (propName = 'friendly') then result := 'BackboneElement'
  else if (propName = 'legal') then result := 'BackboneElement'
  else if (propName = 'rule') then result := 'BackboneElement'
  else if (propName = 'legallyBinding[x]') then result := 'Attachment|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirContract.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'url') then UrlElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'legalState') then LegalStateElement := nil
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := nil
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := nil
  else if (propName = 'contentDerivative') then ContentDerivativeElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'applies') then AppliesElement := nil
  else if (propName = 'expirationType') then ExpirationTypeElement := nil
  else if (propName = 'subject') then deletePropertyValue('subject', SubjectList, value)
  else if (propName = 'authority') then deletePropertyValue('authority', AuthorityList, value)
  else if (propName = 'domain') then deletePropertyValue('domain', DomainList, value)
  else if (propName = 'site') then deletePropertyValue('site', SiteList, value)
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'alias') then deletePropertyValue('alias', AliasList, value)
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'scope') then ScopeElement := nil
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'subType') then deletePropertyValue('subType', SubTypeList, value)
  else if (propName = 'contentDefinition') then ContentDefinitionElement := nil
  else if (propName = 'term') then deletePropertyValue('term', TermList, value)
  else if (propName = 'supportingInfo') then deletePropertyValue('supportingInfo', SupportingInfoList, value)
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value)
  else if (propName = 'signer') then deletePropertyValue('signer', SignerList, value)
  else if (propName = 'friendly') then deletePropertyValue('friendly', FriendlyList, value)
  else if (propName = 'legal') then deletePropertyValue('legal', LegalList, value)
  else if (propName = 'rule') then deletePropertyValue('rule', RuleList, value)
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then LegallyBindingElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirContract.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirContractResourceStatusCodesEnum, CODES_TFhirContractResourceStatusCodesEnum, new)
  else if (propName = 'legalState') then LegalStateElement := new as TFhirCodeableConcept
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := new as TFhirReference
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := asUri(new)
  else if (propName = 'contentDerivative') then ContentDerivativeElement := new as TFhirCodeableConcept
  else if (propName = 'issued') then IssuedElement := asDateTime(new)
  else if (propName = 'applies') then AppliesElement := new as TFhirPeriod
  else if (propName = 'expirationType') then ExpirationTypeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then replacePropertyValue('subject', SubjectList, existing, new)
  else if (propName = 'authority') then replacePropertyValue('authority', AuthorityList, existing, new)
  else if (propName = 'domain') then replacePropertyValue('domain', DomainList, existing, new)
  else if (propName = 'site') then replacePropertyValue('site', SiteList, existing, new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'alias') then replacePropertyValue('alias', AliasList, existing, new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'scope') then ScopeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'topic', ['CodeableConcept', 'Reference'])) then TopicElement := new as TFhirDataType
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'subType') then replacePropertyValue('subType', SubTypeList, existing, new)
  else if (propName = 'contentDefinition') then ContentDefinitionElement := new as TFhirContractContentDefinition
  else if (propName = 'term') then replacePropertyValue('term', TermList, existing, new)
  else if (propName = 'supportingInfo') then replacePropertyValue('supportingInfo', SupportingInfoList, existing, new)
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new)
  else if (propName = 'signer') then replacePropertyValue('signer', SignerList, existing, new)
  else if (propName = 'friendly') then replacePropertyValue('friendly', FriendlyList, existing, new)
  else if (propName = 'legal') then replacePropertyValue('legal', LegalList, existing, new)
  else if (propName = 'rule') then replacePropertyValue('rule', RuleList, existing, new)
  else if (isMatchingName(propName, 'legallyBinding', ['Attachment', 'Reference'])) then LegallyBindingElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirContract.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'subject') then SubjectList.move(source, destination)
  else if (propName = 'authority') then AuthorityList.move(source, destination)
  else if (propName = 'domain') then DomainList.move(source, destination)
  else if (propName = 'site') then SiteList.move(source, destination)
  else if (propName = 'alias') then AliasList.move(source, destination)
  else if (propName = 'subType') then SubTypeList.move(source, destination)
  else if (propName = 'term') then TermList.move(source, destination)
  else if (propName = 'supportingInfo') then SupportingInfoList.move(source, destination)
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination)
  else if (propName = 'signer') then SignerList.move(source, destination)
  else if (propName = 'friendly') then FriendlyList.move(source, destination)
  else if (propName = 'legal') then LegalList.move(source, destination)
  else if (propName = 'rule') then RuleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirContract.fhirType : string;
begin
  result := 'Contract';
end;

function TFhirContract.Link : TFhirContract;
begin
  result := TFhirContract(inherited Link);
end;

function TFhirContract.Clone : TFhirContract;
begin
  result := TFhirContract(inherited Clone);
end;

function TFhirContract.equals(other : TObject) : boolean; 
var
  o : TFhirContract;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirContract)) then
    result := false
  else
  begin
    o := TFhirContract(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(urlElement, o.urlElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(legalStateElement, o.legalStateElement, true) and compareDeep(instantiatesCanonicalElement, o.instantiatesCanonicalElement, true) and 
      compareDeep(instantiatesUriElement, o.instantiatesUriElement, true) and compareDeep(contentDerivativeElement, o.contentDerivativeElement, true) and 
      compareDeep(issuedElement, o.issuedElement, true) and compareDeep(appliesElement, o.appliesElement, true) and 
      compareDeep(expirationTypeElement, o.expirationTypeElement, true) and compareDeep(subjectList, o.subjectList, true) and 
      compareDeep(authorityList, o.authorityList, true) and compareDeep(domainList, o.domainList, true) and 
      compareDeep(siteList, o.siteList, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(subtitleElement, o.subtitleElement, true) and 
      compareDeep(aliasList, o.aliasList, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(scopeElement, o.scopeElement, true) and compareDeep(topicElement, o.topicElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(subTypeList, o.subTypeList, true) and 
      compareDeep(contentDefinitionElement, o.contentDefinitionElement, true) and compareDeep(termList, o.termList, true) and 
      compareDeep(supportingInfoList, o.supportingInfoList, true) and compareDeep(relevantHistoryList, o.relevantHistoryList, true) and 
      compareDeep(signerList, o.signerList, true) and compareDeep(friendlyList, o.friendlyList, true) and 
      compareDeep(legalList, o.legalList, true) and compareDeep(ruleList, o.ruleList, true) and 
      compareDeep(legallyBindingElement, o.legallyBindingElement, true);
  end;
end;

function TFhirContract.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FUrl) and isEmptyProp(FVersion) and isEmptyProp(FStatus) and isEmptyProp(FLegalState) and isEmptyProp(FInstantiatesCanonical) and isEmptyProp(FInstantiatesUri) and isEmptyProp(FContentDerivative) and isEmptyProp(FIssued) and isEmptyProp(FApplies) and isEmptyProp(FExpirationType) and isEmptyProp(FsubjectList) and isEmptyProp(FauthorityList) and isEmptyProp(FdomainList) and isEmptyProp(FsiteList) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FaliasList) and isEmptyProp(FAuthor) and isEmptyProp(FScope) and isEmptyProp(FTopic) and isEmptyProp(FType_) and isEmptyProp(FsubTypeList) and isEmptyProp(FContentDefinition) and isEmptyProp(FtermList) and isEmptyProp(FsupportingInfoList) and isEmptyProp(FrelevantHistoryList) and isEmptyProp(FsignerList) and isEmptyProp(FfriendlyList) and isEmptyProp(FlegalList) and isEmptyProp(FruleList) and isEmptyProp(FLegallyBinding);
end;

procedure TFhirContract.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('url');
  fields.add('version');
  fields.add('status');
  fields.add('legalState');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('contentDerivative');
  fields.add('issued');
  fields.add('applies');
  fields.add('expirationType');
  fields.add('subject');
  fields.add('authority');
  fields.add('domain');
  fields.add('site');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('alias');
  fields.add('author');
  fields.add('scope');
  fields.add('topic[x]');
  fields.add('type');
  fields.add('subType');
  fields.add('contentDefinition');
  fields.add('term');
  fields.add('supportingInfo');
  fields.add('relevantHistory');
  fields.add('signer');
  fields.add('friendly');
  fields.add('legal');
  fields.add('rule');
  fields.add('legallyBinding[x]');
end;

function TFhirContract.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FSubjectList.sizeInBytes(magic));
  inc(result, FAuthorityList.sizeInBytes(magic));
  inc(result, FDomainList.sizeInBytes(magic));
  inc(result, FSiteList.sizeInBytes(magic));
  inc(result, FAliasList.sizeInBytes(magic));
  inc(result, FSubTypeList.sizeInBytes(magic));
  inc(result, FTermList.sizeInBytes(magic));
  inc(result, FSupportingInfoList.sizeInBytes(magic));
  inc(result, FRelevantHistoryList.sizeInBytes(magic));
  inc(result, FSignerList.sizeInBytes(magic));
  inc(result, FFriendlyList.sizeInBytes(magic));
  inc(result, FLegalList.sizeInBytes(magic));
  inc(result, FRuleList.sizeInBytes(magic));
end;

function TFhirContract.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirContract.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirContract.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirContract.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirContract.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirContract.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirContract.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirContract.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirContract.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirContract.GetStatusST : TFhirContractResourceStatusCodesEnum;
begin
  if FStatus = nil then
    result := TFhirContractResourceStatusCodesEnum(0)
  else
    result := TFhirContractResourceStatusCodesEnum(StringArrayIndexOfSensitive(CODES_TFhirContractResourceStatusCodesEnum, FStatus.value));
end;

procedure TFhirContract.SetStatusST(value : TFhirContractResourceStatusCodesEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirContractResourceStatusCodesEnum[value], CODES_TFhirContractResourceStatusCodesEnum[value]);
end;

procedure TFhirContract.SetLegalState(value : TFhirCodeableConcept);
begin
  FLegalState.free;
  FLegalState := value;
end;

procedure TFhirContract.SetInstantiatesCanonical(value : TFhirReference);
begin
  FInstantiatesCanonical.free;
  FInstantiatesCanonical := value;
end;

procedure TFhirContract.SetInstantiatesUri(value : TFhirUri);
begin
  FInstantiatesUri.free;
  FInstantiatesUri := value;
end;

function TFhirContract.GetInstantiatesUriST : String;
begin
  if FInstantiatesUri = nil then
    result := ''
  else
    result := FInstantiatesUri.value;
end;

procedure TFhirContract.SetInstantiatesUriST(value : String);
begin
  if value <> '' then
  begin
    if FInstantiatesUri = nil then
      FInstantiatesUri := TFhirUri.create;
    FInstantiatesUri.value := value
  end
  else if FInstantiatesUri <> nil then
    FInstantiatesUri.value := '';
end;

procedure TFhirContract.SetContentDerivative(value : TFhirCodeableConcept);
begin
  FContentDerivative.free;
  FContentDerivative := value;
end;

procedure TFhirContract.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

function TFhirContract.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirContract.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

procedure TFhirContract.SetApplies(value : TFhirPeriod);
begin
  FApplies.free;
  FApplies := value;
end;

procedure TFhirContract.SetExpirationType(value : TFhirCodeableConcept);
begin
  FExpirationType.free;
  FExpirationType := value;
end;

function TFhirContract.GetSubjectList : TFhirReferenceList;
begin
  if FSubjectList = nil then
    FSubjectList := TFhirReferenceList.Create;
  result := FSubjectList;
end;

function TFhirContract.GetHasSubjectList : boolean;
begin
  result := (FSubjectList <> nil) and (FSubjectList.count > 0);
end;

function TFhirContract.GetAuthorityList : TFhirReferenceList;
begin
  if FAuthorityList = nil then
    FAuthorityList := TFhirReferenceList.Create;
  result := FAuthorityList;
end;

function TFhirContract.GetHasAuthorityList : boolean;
begin
  result := (FAuthorityList <> nil) and (FAuthorityList.count > 0);
end;

function TFhirContract.GetDomainList : TFhirReferenceList;
begin
  if FDomainList = nil then
    FDomainList := TFhirReferenceList.Create;
  result := FDomainList;
end;

function TFhirContract.GetHasDomainList : boolean;
begin
  result := (FDomainList <> nil) and (FDomainList.count > 0);
end;

function TFhirContract.GetSiteList : TFhirReferenceList;
begin
  if FSiteList = nil then
    FSiteList := TFhirReferenceList.Create;
  result := FSiteList;
end;

function TFhirContract.GetHasSiteList : boolean;
begin
  result := (FSiteList <> nil) and (FSiteList.count > 0);
end;

procedure TFhirContract.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirContract.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirContract.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirContract.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirContract.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirContract.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirContract.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirContract.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirContract.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

function TFhirContract.GetAliasList : TFhirStringList;
begin
  if FAliasList = nil then
    FAliasList := TFhirStringList.Create;
  result := FAliasList;
end;

function TFhirContract.GetHasAliasList : boolean;
begin
  result := (FAliasList <> nil) and (FAliasList.count > 0);
end;

procedure TFhirContract.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

procedure TFhirContract.SetScope(value : TFhirCodeableConcept);
begin
  FScope.free;
  FScope := value;
end;

procedure TFhirContract.SetTopic(value : TFhirDataType);
begin
  FTopic.free;
  FTopic := value;
end;

procedure TFhirContract.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirContract.GetSubTypeList : TFhirCodeableConceptList;
begin
  if FSubTypeList = nil then
    FSubTypeList := TFhirCodeableConceptList.Create;
  result := FSubTypeList;
end;

function TFhirContract.GetHasSubTypeList : boolean;
begin
  result := (FSubTypeList <> nil) and (FSubTypeList.count > 0);
end;

procedure TFhirContract.SetContentDefinition(value : TFhirContractContentDefinition);
begin
  FContentDefinition.free;
  FContentDefinition := value;
end;

function TFhirContract.GetTermList : TFhirContractTermList;
begin
  if FTermList = nil then
    FTermList := TFhirContractTermList.Create;
  result := FTermList;
end;

function TFhirContract.GetHasTermList : boolean;
begin
  result := (FTermList <> nil) and (FTermList.count > 0);
end;

function TFhirContract.GetSupportingInfoList : TFhirReferenceList;
begin
  if FSupportingInfoList = nil then
    FSupportingInfoList := TFhirReferenceList.Create;
  result := FSupportingInfoList;
end;

function TFhirContract.GetHasSupportingInfoList : boolean;
begin
  result := (FSupportingInfoList <> nil) and (FSupportingInfoList.count > 0);
end;

function TFhirContract.GetRelevantHistoryList : TFhirReferenceList;
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList.Create;
  result := FRelevantHistoryList;
end;

function TFhirContract.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

function TFhirContract.GetSignerList : TFhirContractSignerList;
begin
  if FSignerList = nil then
    FSignerList := TFhirContractSignerList.Create;
  result := FSignerList;
end;

function TFhirContract.GetHasSignerList : boolean;
begin
  result := (FSignerList <> nil) and (FSignerList.count > 0);
end;

function TFhirContract.GetFriendlyList : TFhirContractFriendlyList;
begin
  if FFriendlyList = nil then
    FFriendlyList := TFhirContractFriendlyList.Create;
  result := FFriendlyList;
end;

function TFhirContract.GetHasFriendlyList : boolean;
begin
  result := (FFriendlyList <> nil) and (FFriendlyList.count > 0);
end;

function TFhirContract.GetLegalList : TFhirContractLegalList;
begin
  if FLegalList = nil then
    FLegalList := TFhirContractLegalList.Create;
  result := FLegalList;
end;

function TFhirContract.GetHasLegalList : boolean;
begin
  result := (FLegalList <> nil) and (FLegalList.count > 0);
end;

function TFhirContract.GetRuleList : TFhirContractRuleList;
begin
  if FRuleList = nil then
    FRuleList := TFhirContractRuleList.Create;
  result := FRuleList;
end;

function TFhirContract.GetHasRuleList : boolean;
begin
  result := (FRuleList <> nil) and (FRuleList.count > 0);
end;

procedure TFhirContract.SetLegallyBinding(value : TFhirDataType);
begin
  FLegallyBinding.free;
  FLegallyBinding := value;
end;

{ TFhirContractListEnumerator }

constructor TFhirContractListEnumerator.Create(list : TFhirContractList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirContractListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirContractListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirContractListEnumerator.GetCurrent : TFhirContract;
begin
  Result := FList[FIndex];
end;

function TFhirContractListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirContractList }

function TFhirContractList.AddItem(value: TFhirContract): TFhirContract;
begin
  assert(value.ClassName = 'TFhirContract', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirContract');
  add(value);
  result := value;
end;

function TFhirContractList.Append: TFhirContract;
begin
  result := TFhirContract.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.ClearItems;
begin
  Clear;
end;

function TFhirContractList.GetEnumerator : TFhirContractListEnumerator;
begin
  result := TFhirContractListEnumerator.Create(self.link);
end;

function TFhirContractList.Clone: TFhirContractList;
begin
  result := TFhirContractList(inherited Clone);
end;

function TFhirContractList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirContractList.GetItemN(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.ItemClass: TFslObjectClass;
begin
  result := TFhirContract;
end;
function TFhirContractList.IndexOf(value: TFhirContract): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirContractList.Insert(index: Integer): TFhirContract;
begin
  result := TFhirContract.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirContractList.InsertItem(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  Inherited Insert(index, value);
end;

function TFhirContractList.Item(index: Integer): TFhirContract;
begin
  result := TFhirContract(ObjectByIndex[index]);
end;

function TFhirContractList.Link: TFhirContractList;
begin
  result := TFhirContractList(inherited Link);
end;

procedure TFhirContractList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirContractList.SetItemByIndex(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  FhirContracts[index] := value;
end;

procedure TFhirContractList.SetItemN(index: Integer; value: TFhirContract);
begin
  assert(value is TFhirContract);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_CONTRACT}
{$IFDEF FHIR_EVIDENCE}
{ TFhirEvidenceVariableDefinition }

constructor TFhirEvidenceVariableDefinition.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableDefinition.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FVariableRole.free;
  FObserved.free;
  FIntended.free;
  FDirectnessMatch.free;
  inherited;
end;

procedure TFhirEvidenceVariableDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceVariableDefinition(oSource).descriptionElement.Clone;
  if (TFhirEvidenceVariableDefinition(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceVariableDefinition(oSource).FNoteList);
  end;
  variableRole := TFhirEvidenceVariableDefinition(oSource).variableRole.Clone;
  observed := TFhirEvidenceVariableDefinition(oSource).observed.Clone;
  intended := TFhirEvidenceVariableDefinition(oSource).intended.Clone;
  directnessMatch := TFhirEvidenceVariableDefinition(oSource).directnessMatch.Clone;
end;

procedure TFhirEvidenceVariableDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'variableRole') Then
     list.add(self.link, 'variableRole', FVariableRole.Link);
  if (child_name = 'observed') Then
     list.add(self.link, 'observed', FObserved.Link);
  if (child_name = 'intended') Then
     list.add(self.link, 'intended', FIntended.Link);
  if (child_name = 'directnessMatch') Then
     list.add(self.link, 'directnessMatch', FDirectnessMatch.Link);
end;

procedure TFhirEvidenceVariableDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'variableRole', 'CodeableConcept', false, TFhirCodeableConcept, FVariableRole.Link));
  oList.add(TFHIRProperty.create(self, 'observed', 'Reference', false, TFhirReference, FObserved.Link));
  oList.add(TFHIRProperty.create(self, 'intended', 'Reference', false, TFhirReference, FIntended.Link));
  oList.add(TFHIRProperty.create(self, 'directnessMatch', 'CodeableConcept', false, TFhirCodeableConcept, FDirectnessMatch.Link));
end;

function TFhirEvidenceVariableDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'variableRole') then
  begin
    VariableRole := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'observed') then
  begin
    Observed := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'intended') then
  begin
    Intended := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'directnessMatch') then
  begin
    DirectnessMatch := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirEvidenceVariableDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'variableRole') then result := TFhirCodeableConcept.create()
  else if (propName = 'observed') then result := TFhirReference.create()
  else if (propName = 'intended') then result := TFhirReference.create()
  else if (propName = 'directnessMatch') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'variableRole') then result := 'CodeableConcept'
  else if (propName = 'observed') then result := 'Reference'
  else if (propName = 'intended') then result := 'Reference'
  else if (propName = 'directnessMatch') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'variableRole') then VariableRoleElement := nil
  else if (propName = 'observed') then ObservedElement := nil
  else if (propName = 'intended') then IntendedElement := nil
  else if (propName = 'directnessMatch') then DirectnessMatchElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'variableRole') then VariableRoleElement := new as TFhirCodeableConcept
  else if (propName = 'observed') then ObservedElement := new as TFhirReference
  else if (propName = 'intended') then IntendedElement := new as TFhirReference
  else if (propName = 'directnessMatch') then DirectnessMatchElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableDefinition.fhirType : string;
begin
  result := 'Evidence.variableDefinition';
end;

function TFhirEvidenceVariableDefinition.Link : TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition(inherited Link);
end;

function TFhirEvidenceVariableDefinition.Clone : TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition(inherited Clone);
end;

function TFhirEvidenceVariableDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableDefinition)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableDefinition(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(variableRoleElement, o.variableRoleElement, true) and compareDeep(observedElement, o.observedElement, true) and 
      compareDeep(intendedElement, o.intendedElement, true) and compareDeep(directnessMatchElement, o.directnessMatchElement, true);
  end;
end;

function TFhirEvidenceVariableDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FVariableRole) and isEmptyProp(FObserved) and isEmptyProp(FIntended) and isEmptyProp(FDirectnessMatch);
end;

procedure TFhirEvidenceVariableDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('variableRole');
  fields.add('observed');
  fields.add('intended');
  fields.add('directnessMatch');
end;

function TFhirEvidenceVariableDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirEvidenceVariableDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceVariableDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceVariableDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceVariableDefinition.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceVariableDefinition.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceVariableDefinition.SetVariableRole(value : TFhirCodeableConcept);
begin
  FVariableRole.free;
  FVariableRole := value;
end;

procedure TFhirEvidenceVariableDefinition.SetObserved(value : TFhirReference);
begin
  FObserved.free;
  FObserved := value;
end;

procedure TFhirEvidenceVariableDefinition.SetIntended(value : TFhirReference);
begin
  FIntended.free;
  FIntended := value;
end;

procedure TFhirEvidenceVariableDefinition.SetDirectnessMatch(value : TFhirCodeableConcept);
begin
  FDirectnessMatch.free;
  FDirectnessMatch := value;
end;

{ TFhirEvidenceVariableDefinitionListEnumerator }

constructor TFhirEvidenceVariableDefinitionListEnumerator.Create(list : TFhirEvidenceVariableDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableDefinitionListEnumerator.GetCurrent : TFhirEvidenceVariableDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableDefinitionList }

function TFhirEvidenceVariableDefinitionList.AddItem(value: TFhirEvidenceVariableDefinition): TFhirEvidenceVariableDefinition;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableDefinition');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableDefinitionList.Append: TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableDefinitionList.GetEnumerator : TFhirEvidenceVariableDefinitionListEnumerator;
begin
  result := TFhirEvidenceVariableDefinitionListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableDefinitionList.Clone: TFhirEvidenceVariableDefinitionList;
begin
  result := TFhirEvidenceVariableDefinitionList(inherited Clone);
end;

function TFhirEvidenceVariableDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableDefinitionList.GetItemN(index: Integer): TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableDefinition;
end;
function TFhirEvidenceVariableDefinitionList.IndexOf(value: TFhirEvidenceVariableDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableDefinitionList.Insert(index: Integer): TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableDefinitionList.InsertItem(index: Integer; value: TFhirEvidenceVariableDefinition);
begin
  assert(value is TFhirEvidenceVariableDefinition);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableDefinitionList.Item(index: Integer): TFhirEvidenceVariableDefinition;
begin
  result := TFhirEvidenceVariableDefinition(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableDefinitionList.Link: TFhirEvidenceVariableDefinitionList;
begin
  result := TFhirEvidenceVariableDefinitionList(inherited Link);
end;

procedure TFhirEvidenceVariableDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableDefinitionList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableDefinition);
begin
  assert(value is TFhirEvidenceVariableDefinition);
  FhirEvidenceVariableDefinitions[index] := value;
end;

procedure TFhirEvidenceVariableDefinitionList.SetItemN(index: Integer; value: TFhirEvidenceVariableDefinition);
begin
  assert(value is TFhirEvidenceVariableDefinition);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatistic }

constructor TFhirEvidenceStatistic.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatistic.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FStatisticType.free;
  FCategory.free;
  FQuantity.free;
  FNumberOfEvents.free;
  FNumberAffected.free;
  FSampleSize.free;
  FAttributeEstimateList.Free;
  FModelCharacteristicList.Free;
  inherited;
end;

procedure TFhirEvidenceStatistic.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceStatistic(oSource).descriptionElement.Clone;
  if (TFhirEvidenceStatistic(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceStatistic(oSource).FNoteList);
  end;
  statisticType := TFhirEvidenceStatistic(oSource).statisticType.Clone;
  category := TFhirEvidenceStatistic(oSource).category.Clone;
  quantity := TFhirEvidenceStatistic(oSource).quantity.Clone;
  numberOfEventsElement := TFhirEvidenceStatistic(oSource).numberOfEventsElement.Clone;
  numberAffectedElement := TFhirEvidenceStatistic(oSource).numberAffectedElement.Clone;
  sampleSize := TFhirEvidenceStatistic(oSource).sampleSize.Clone;
  if (TFhirEvidenceStatistic(oSource).FAttributeEstimateList = nil) then
  begin
    FAttributeEstimateList.free;
    FAttributeEstimateList := nil;
  end
  else
  begin
    if FAttributeEstimateList = nil then
      FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
    FAttributeEstimateList.Assign(TFhirEvidenceStatistic(oSource).FAttributeEstimateList);
  end;
  if (TFhirEvidenceStatistic(oSource).FModelCharacteristicList = nil) then
  begin
    FModelCharacteristicList.free;
    FModelCharacteristicList := nil;
  end
  else
  begin
    if FModelCharacteristicList = nil then
      FModelCharacteristicList := TFhirEvidenceStatisticModelCharacteristicList.Create;
    FModelCharacteristicList.Assign(TFhirEvidenceStatistic(oSource).FModelCharacteristicList);
  end;
end;

procedure TFhirEvidenceStatistic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'statisticType') Then
     list.add(self.link, 'statisticType', FStatisticType.Link);
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'numberOfEvents') Then
     list.add(self.link, 'numberOfEvents', FNumberOfEvents.Link);
  if (child_name = 'numberAffected') Then
     list.add(self.link, 'numberAffected', FNumberAffected.Link);
  if (child_name = 'sampleSize') Then
     list.add(self.link, 'sampleSize', FSampleSize.Link);
  if (child_name = 'attributeEstimate') Then
    list.addAll(self, 'attributeEstimate', FAttributeEstimateList);
  if (child_name = 'modelCharacteristic') Then
    list.addAll(self, 'modelCharacteristic', FModelCharacteristicList);
end;

procedure TFhirEvidenceStatistic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'statisticType', 'CodeableConcept', false, TFhirCodeableConcept, FStatisticType.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfEvents', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfEvents.Link));
  oList.add(TFHIRProperty.create(self, 'numberAffected', 'unsignedInt', false, TFhirUnsignedInt, FNumberAffected.Link));
  oList.add(TFHIRProperty.create(self, 'sampleSize', 'BackboneElement', false, TFhirEvidenceStatisticSampleSize, FSampleSize.Link));
  oList.add(TFHIRProperty.create(self, 'attributeEstimate', 'BackboneElement', true, TFhirEvidenceStatisticAttributeEstimate, FAttributeEstimateList.Link));
  oList.add(TFHIRProperty.create(self, 'modelCharacteristic', 'BackboneElement', true, TFhirEvidenceStatisticModelCharacteristic, FModelCharacteristicList.Link));
end;

function TFhirEvidenceStatistic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'statisticType') then
  begin
    StatisticType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'numberOfEvents') then
  begin
    NumberOfEventsElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'numberAffected') then
  begin
    NumberAffectedElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'sampleSize') then
  begin
    SampleSize := propValue as TFhirEvidenceStatisticSampleSize;
    result := propValue;
  end
  else if (propName = 'attributeEstimate') then
  begin
    AttributeEstimateList.add(propValue as TFhirEvidenceStatisticAttributeEstimate);
    result := propValue;
  end
  else if (propName = 'modelCharacteristic') then
  begin
    ModelCharacteristicList.add(propValue as TFhirEvidenceStatisticModelCharacteristic);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatistic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.insertItem(index, propValue as TFhirEvidenceStatisticAttributeEstimate)
  else if (propName = 'modelCharacteristic') then ModelCharacteristicList.insertItem(index, propValue as TFhirEvidenceStatisticModelCharacteristic)
  else inherited;
end;

function TFhirEvidenceStatistic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'statisticType') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'numberOfEvents') then result := TFhirUnsignedInt.create()
  else if (propName = 'numberAffected') then result := TFhirUnsignedInt.create()
  else if (propName = 'sampleSize') then result := TFhirEvidenceStatisticSampleSize.create()
  else if (propName = 'attributeEstimate') then result := AttributeEstimateList.new()
  else if (propName = 'modelCharacteristic') then result := ModelCharacteristicList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatistic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'statisticType') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'numberOfEvents') then result := 'unsignedInt'
  else if (propName = 'numberAffected') then result := 'unsignedInt'
  else if (propName = 'sampleSize') then result := 'BackboneElement'
  else if (propName = 'attributeEstimate') then result := 'BackboneElement'
  else if (propName = 'modelCharacteristic') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatistic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'statisticType') then StatisticTypeElement := nil
  else if (propName = 'category') then CategoryElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'numberOfEvents') then NumberOfEventsElement := nil
  else if (propName = 'numberAffected') then NumberAffectedElement := nil
  else if (propName = 'sampleSize') then SampleSizeElement := nil
  else if (propName = 'attributeEstimate') then deletePropertyValue('attributeEstimate', AttributeEstimateList, value)
  else if (propName = 'modelCharacteristic') then deletePropertyValue('modelCharacteristic', ModelCharacteristicList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatistic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'statisticType') then StatisticTypeElement := new as TFhirCodeableConcept
  else if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'numberOfEvents') then NumberOfEventsElement := asUnsignedInt(new)
  else if (propName = 'numberAffected') then NumberAffectedElement := asUnsignedInt(new)
  else if (propName = 'sampleSize') then SampleSizeElement := new as TFhirEvidenceStatisticSampleSize
  else if (propName = 'attributeEstimate') then replacePropertyValue('attributeEstimate', AttributeEstimateList, existing, new)
  else if (propName = 'modelCharacteristic') then replacePropertyValue('modelCharacteristic', ModelCharacteristicList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatistic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.move(source, destination)
  else if (propName = 'modelCharacteristic') then ModelCharacteristicList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatistic.fhirType : string;
begin
  result := 'Evidence.statistic';
end;

function TFhirEvidenceStatistic.Link : TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic(inherited Link);
end;

function TFhirEvidenceStatistic.Clone : TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic(inherited Clone);
end;

function TFhirEvidenceStatistic.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatistic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatistic)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatistic(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(statisticTypeElement, o.statisticTypeElement, true) and compareDeep(categoryElement, o.categoryElement, true) and 
      compareDeep(quantityElement, o.quantityElement, true) and compareDeep(numberOfEventsElement, o.numberOfEventsElement, true) and 
      compareDeep(numberAffectedElement, o.numberAffectedElement, true) and compareDeep(sampleSizeElement, o.sampleSizeElement, true) and 
      compareDeep(attributeEstimateList, o.attributeEstimateList, true) and compareDeep(modelCharacteristicList, o.modelCharacteristicList, true);
  end;
end;

function TFhirEvidenceStatistic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FStatisticType) and isEmptyProp(FCategory) and isEmptyProp(FQuantity) and isEmptyProp(FNumberOfEvents) and isEmptyProp(FNumberAffected) and isEmptyProp(FSampleSize) and isEmptyProp(FattributeEstimateList) and isEmptyProp(FmodelCharacteristicList);
end;

procedure TFhirEvidenceStatistic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('statisticType');
  fields.add('category');
  fields.add('quantity');
  fields.add('numberOfEvents');
  fields.add('numberAffected');
  fields.add('sampleSize');
  fields.add('attributeEstimate');
  fields.add('modelCharacteristic');
end;

function TFhirEvidenceStatistic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FAttributeEstimateList.sizeInBytes(magic));
  inc(result, FModelCharacteristicList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatistic.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceStatistic.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceStatistic.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceStatistic.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceStatistic.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceStatistic.SetStatisticType(value : TFhirCodeableConcept);
begin
  FStatisticType.free;
  FStatisticType := value;
end;

procedure TFhirEvidenceStatistic.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirEvidenceStatistic.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirEvidenceStatistic.SetNumberOfEvents(value : TFhirUnsignedInt);
begin
  FNumberOfEvents.free;
  FNumberOfEvents := value;
end;

function TFhirEvidenceStatistic.GetNumberOfEventsST : String;
begin
  if FNumberOfEvents = nil then
    result := ''
  else
    result := FNumberOfEvents.value;
end;

procedure TFhirEvidenceStatistic.SetNumberOfEventsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfEvents = nil then
      FNumberOfEvents := TFhirUnsignedInt.create;
    FNumberOfEvents.value := value
  end
  else if FNumberOfEvents <> nil then
    FNumberOfEvents.value := '';
end;

procedure TFhirEvidenceStatistic.SetNumberAffected(value : TFhirUnsignedInt);
begin
  FNumberAffected.free;
  FNumberAffected := value;
end;

function TFhirEvidenceStatistic.GetNumberAffectedST : String;
begin
  if FNumberAffected = nil then
    result := ''
  else
    result := FNumberAffected.value;
end;

procedure TFhirEvidenceStatistic.SetNumberAffectedST(value : String);
begin
  if value <> '' then
  begin
    if FNumberAffected = nil then
      FNumberAffected := TFhirUnsignedInt.create;
    FNumberAffected.value := value
  end
  else if FNumberAffected <> nil then
    FNumberAffected.value := '';
end;

procedure TFhirEvidenceStatistic.SetSampleSize(value : TFhirEvidenceStatisticSampleSize);
begin
  FSampleSize.free;
  FSampleSize := value;
end;

function TFhirEvidenceStatistic.GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
begin
  if FAttributeEstimateList = nil then
    FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
  result := FAttributeEstimateList;
end;

function TFhirEvidenceStatistic.GetHasAttributeEstimateList : boolean;
begin
  result := (FAttributeEstimateList <> nil) and (FAttributeEstimateList.count > 0);
end;

function TFhirEvidenceStatistic.GetModelCharacteristicList : TFhirEvidenceStatisticModelCharacteristicList;
begin
  if FModelCharacteristicList = nil then
    FModelCharacteristicList := TFhirEvidenceStatisticModelCharacteristicList.Create;
  result := FModelCharacteristicList;
end;

function TFhirEvidenceStatistic.GetHasModelCharacteristicList : boolean;
begin
  result := (FModelCharacteristicList <> nil) and (FModelCharacteristicList.count > 0);
end;

{ TFhirEvidenceStatisticListEnumerator }

constructor TFhirEvidenceStatisticListEnumerator.Create(list : TFhirEvidenceStatisticList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticListEnumerator.GetCurrent : TFhirEvidenceStatistic;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticList }

function TFhirEvidenceStatisticList.AddItem(value: TFhirEvidenceStatistic): TFhirEvidenceStatistic;
begin
  assert(value.ClassName = 'TFhirEvidenceStatistic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatistic');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticList.Append: TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticList.GetEnumerator : TFhirEvidenceStatisticListEnumerator;
begin
  result := TFhirEvidenceStatisticListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticList.Clone: TFhirEvidenceStatisticList;
begin
  result := TFhirEvidenceStatisticList(inherited Clone);
end;

function TFhirEvidenceStatisticList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticList.GetItemN(index: Integer): TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatistic;
end;
function TFhirEvidenceStatisticList.IndexOf(value: TFhirEvidenceStatistic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticList.Insert(index: Integer): TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticList.InsertItem(index: Integer; value: TFhirEvidenceStatistic);
begin
  assert(value is TFhirEvidenceStatistic);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticList.Item(index: Integer): TFhirEvidenceStatistic;
begin
  result := TFhirEvidenceStatistic(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticList.Link: TFhirEvidenceStatisticList;
begin
  result := TFhirEvidenceStatisticList(inherited Link);
end;

procedure TFhirEvidenceStatisticList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatistic);
begin
  assert(value is TFhirEvidenceStatistic);
  FhirEvidenceStatistics[index] := value;
end;

procedure TFhirEvidenceStatisticList.SetItemN(index: Integer; value: TFhirEvidenceStatistic);
begin
  assert(value is TFhirEvidenceStatistic);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatisticSampleSize }

constructor TFhirEvidenceStatisticSampleSize.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatisticSampleSize.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FNumberOfStudies.free;
  FNumberOfParticipants.free;
  FKnownDataCount.free;
  inherited;
end;

procedure TFhirEvidenceStatisticSampleSize.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceStatisticSampleSize(oSource).descriptionElement.Clone;
  if (TFhirEvidenceStatisticSampleSize(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceStatisticSampleSize(oSource).FNoteList);
  end;
  numberOfStudiesElement := TFhirEvidenceStatisticSampleSize(oSource).numberOfStudiesElement.Clone;
  numberOfParticipantsElement := TFhirEvidenceStatisticSampleSize(oSource).numberOfParticipantsElement.Clone;
  knownDataCountElement := TFhirEvidenceStatisticSampleSize(oSource).knownDataCountElement.Clone;
end;

procedure TFhirEvidenceStatisticSampleSize.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'numberOfStudies') Then
     list.add(self.link, 'numberOfStudies', FNumberOfStudies.Link);
  if (child_name = 'numberOfParticipants') Then
     list.add(self.link, 'numberOfParticipants', FNumberOfParticipants.Link);
  if (child_name = 'knownDataCount') Then
     list.add(self.link, 'knownDataCount', FKnownDataCount.Link);
end;

procedure TFhirEvidenceStatisticSampleSize.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfStudies', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfStudies.Link));
  oList.add(TFHIRProperty.create(self, 'numberOfParticipants', 'unsignedInt', false, TFhirUnsignedInt, FNumberOfParticipants.Link));
  oList.add(TFHIRProperty.create(self, 'knownDataCount', 'unsignedInt', false, TFhirUnsignedInt, FKnownDataCount.Link));
end;

function TFhirEvidenceStatisticSampleSize.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'numberOfStudies') then
  begin
    NumberOfStudiesElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'numberOfParticipants') then
  begin
    NumberOfParticipantsElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else if (propName = 'knownDataCount') then
  begin
    KnownDataCountElement := asUnsignedInt(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatisticSampleSize.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirEvidenceStatisticSampleSize.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'numberOfStudies') then result := TFhirUnsignedInt.create()
  else if (propName = 'numberOfParticipants') then result := TFhirUnsignedInt.create()
  else if (propName = 'knownDataCount') then result := TFhirUnsignedInt.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatisticSampleSize.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'numberOfStudies') then result := 'unsignedInt'
  else if (propName = 'numberOfParticipants') then result := 'unsignedInt'
  else if (propName = 'knownDataCount') then result := 'unsignedInt'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatisticSampleSize.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'numberOfStudies') then NumberOfStudiesElement := nil
  else if (propName = 'numberOfParticipants') then NumberOfParticipantsElement := nil
  else if (propName = 'knownDataCount') then KnownDataCountElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatisticSampleSize.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'numberOfStudies') then NumberOfStudiesElement := asUnsignedInt(new)
  else if (propName = 'numberOfParticipants') then NumberOfParticipantsElement := asUnsignedInt(new)
  else if (propName = 'knownDataCount') then KnownDataCountElement := asUnsignedInt(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatisticSampleSize.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatisticSampleSize.fhirType : string;
begin
  result := 'Evidence.statistic.sampleSize';
end;

function TFhirEvidenceStatisticSampleSize.Link : TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize(inherited Link);
end;

function TFhirEvidenceStatisticSampleSize.Clone : TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize(inherited Clone);
end;

function TFhirEvidenceStatisticSampleSize.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatisticSampleSize;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatisticSampleSize)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatisticSampleSize(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(numberOfStudiesElement, o.numberOfStudiesElement, true) and compareDeep(numberOfParticipantsElement, o.numberOfParticipantsElement, true) and 
      compareDeep(knownDataCountElement, o.knownDataCountElement, true);
  end;
end;

function TFhirEvidenceStatisticSampleSize.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FNumberOfStudies) and isEmptyProp(FNumberOfParticipants) and isEmptyProp(FKnownDataCount);
end;

procedure TFhirEvidenceStatisticSampleSize.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('numberOfStudies');
  fields.add('numberOfParticipants');
  fields.add('knownDataCount');
end;

function TFhirEvidenceStatisticSampleSize.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatisticSampleSize.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceStatisticSampleSize.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceStatisticSampleSize.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceStatisticSampleSize.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceStatisticSampleSize.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceStatisticSampleSize.SetNumberOfStudies(value : TFhirUnsignedInt);
begin
  FNumberOfStudies.free;
  FNumberOfStudies := value;
end;

function TFhirEvidenceStatisticSampleSize.GetNumberOfStudiesST : String;
begin
  if FNumberOfStudies = nil then
    result := ''
  else
    result := FNumberOfStudies.value;
end;

procedure TFhirEvidenceStatisticSampleSize.SetNumberOfStudiesST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfStudies = nil then
      FNumberOfStudies := TFhirUnsignedInt.create;
    FNumberOfStudies.value := value
  end
  else if FNumberOfStudies <> nil then
    FNumberOfStudies.value := '';
end;

procedure TFhirEvidenceStatisticSampleSize.SetNumberOfParticipants(value : TFhirUnsignedInt);
begin
  FNumberOfParticipants.free;
  FNumberOfParticipants := value;
end;

function TFhirEvidenceStatisticSampleSize.GetNumberOfParticipantsST : String;
begin
  if FNumberOfParticipants = nil then
    result := ''
  else
    result := FNumberOfParticipants.value;
end;

procedure TFhirEvidenceStatisticSampleSize.SetNumberOfParticipantsST(value : String);
begin
  if value <> '' then
  begin
    if FNumberOfParticipants = nil then
      FNumberOfParticipants := TFhirUnsignedInt.create;
    FNumberOfParticipants.value := value
  end
  else if FNumberOfParticipants <> nil then
    FNumberOfParticipants.value := '';
end;

procedure TFhirEvidenceStatisticSampleSize.SetKnownDataCount(value : TFhirUnsignedInt);
begin
  FKnownDataCount.free;
  FKnownDataCount := value;
end;

function TFhirEvidenceStatisticSampleSize.GetKnownDataCountST : String;
begin
  if FKnownDataCount = nil then
    result := ''
  else
    result := FKnownDataCount.value;
end;

procedure TFhirEvidenceStatisticSampleSize.SetKnownDataCountST(value : String);
begin
  if value <> '' then
  begin
    if FKnownDataCount = nil then
      FKnownDataCount := TFhirUnsignedInt.create;
    FKnownDataCount.value := value
  end
  else if FKnownDataCount <> nil then
    FKnownDataCount.value := '';
end;

{ TFhirEvidenceStatisticSampleSizeListEnumerator }

constructor TFhirEvidenceStatisticSampleSizeListEnumerator.Create(list : TFhirEvidenceStatisticSampleSizeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticSampleSizeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticSampleSizeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticSampleSizeListEnumerator.GetCurrent : TFhirEvidenceStatisticSampleSize;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticSampleSizeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticSampleSizeList }

function TFhirEvidenceStatisticSampleSizeList.AddItem(value: TFhirEvidenceStatisticSampleSize): TFhirEvidenceStatisticSampleSize;
begin
  assert(value.ClassName = 'TFhirEvidenceStatisticSampleSize', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatisticSampleSize');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticSampleSizeList.Append: TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticSampleSizeList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticSampleSizeList.GetEnumerator : TFhirEvidenceStatisticSampleSizeListEnumerator;
begin
  result := TFhirEvidenceStatisticSampleSizeListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticSampleSizeList.Clone: TFhirEvidenceStatisticSampleSizeList;
begin
  result := TFhirEvidenceStatisticSampleSizeList(inherited Clone);
end;

function TFhirEvidenceStatisticSampleSizeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticSampleSizeList.GetItemN(index: Integer): TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticSampleSizeList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatisticSampleSize;
end;
function TFhirEvidenceStatisticSampleSizeList.IndexOf(value: TFhirEvidenceStatisticSampleSize): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticSampleSizeList.Insert(index: Integer): TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticSampleSizeList.InsertItem(index: Integer; value: TFhirEvidenceStatisticSampleSize);
begin
  assert(value is TFhirEvidenceStatisticSampleSize);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticSampleSizeList.Item(index: Integer): TFhirEvidenceStatisticSampleSize;
begin
  result := TFhirEvidenceStatisticSampleSize(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticSampleSizeList.Link: TFhirEvidenceStatisticSampleSizeList;
begin
  result := TFhirEvidenceStatisticSampleSizeList(inherited Link);
end;

procedure TFhirEvidenceStatisticSampleSizeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticSampleSizeList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatisticSampleSize);
begin
  assert(value is TFhirEvidenceStatisticSampleSize);
  FhirEvidenceStatisticSampleSizes[index] := value;
end;

procedure TFhirEvidenceStatisticSampleSizeList.SetItemN(index: Integer; value: TFhirEvidenceStatisticSampleSize);
begin
  assert(value is TFhirEvidenceStatisticSampleSize);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatisticAttributeEstimate }

constructor TFhirEvidenceStatisticAttributeEstimate.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatisticAttributeEstimate.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FType_.free;
  FQuantity.free;
  FLevel.free;
  FRange.free;
  FAttributeEstimateList.Free;
  inherited;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceStatisticAttributeEstimate(oSource).descriptionElement.Clone;
  if (TFhirEvidenceStatisticAttributeEstimate(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceStatisticAttributeEstimate(oSource).FNoteList);
  end;
  type_ := TFhirEvidenceStatisticAttributeEstimate(oSource).type_.Clone;
  quantity := TFhirEvidenceStatisticAttributeEstimate(oSource).quantity.Clone;
  levelElement := TFhirEvidenceStatisticAttributeEstimate(oSource).levelElement.Clone;
  range := TFhirEvidenceStatisticAttributeEstimate(oSource).range.Clone;
  if (TFhirEvidenceStatisticAttributeEstimate(oSource).FAttributeEstimateList = nil) then
  begin
    FAttributeEstimateList.free;
    FAttributeEstimateList := nil;
  end
  else
  begin
    if FAttributeEstimateList = nil then
      FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
    FAttributeEstimateList.Assign(TFhirEvidenceStatisticAttributeEstimate(oSource).FAttributeEstimateList);
  end;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'level') Then
     list.add(self.link, 'level', FLevel.Link);
  if (child_name = 'range') Then
     list.add(self.link, 'range', FRange.Link);
  if (child_name = 'attributeEstimate') Then
    list.addAll(self, 'attributeEstimate', FAttributeEstimateList);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'level', 'decimal', false, TFhirDecimal, FLevel.Link));
  oList.add(TFHIRProperty.create(self, 'range', 'Range', false, TFhirRange, FRange.Link));
  oList.add(TFHIRProperty.create(self, 'attributeEstimate', '', true, TFhirEvidenceStatisticAttributeEstimate, FAttributeEstimateList.Link));
end;

function TFhirEvidenceStatisticAttributeEstimate.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'level') then
  begin
    LevelElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'range') then
  begin
    Range := propValue as TFhirRange;
    result := propValue;
  end
  else if (propName = 'attributeEstimate') then
  begin
    AttributeEstimateList.add(propValue as TFhirEvidenceStatisticAttributeEstimate);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.insertItem(index, propValue as TFhirEvidenceStatisticAttributeEstimate)
  else inherited;
end;

function TFhirEvidenceStatisticAttributeEstimate.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'level') then result := TFhirDecimal.create()
  else if (propName = 'range') then result := TFhirRange.create()
  else if (propName = 'attributeEstimate') then result := AttributeEstimateList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatisticAttributeEstimate.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'level') then result := 'decimal'
  else if (propName = 'range') then result := 'Range'
  else if (propName = 'attributeEstimate') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'level') then LevelElement := nil
  else if (propName = 'range') then RangeElement := nil
  else if (propName = 'attributeEstimate') then deletePropertyValue('attributeEstimate', AttributeEstimateList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'level') then LevelElement := asDecimal(new)
  else if (propName = 'range') then RangeElement := new as TFhirRange
  else if (propName = 'attributeEstimate') then replacePropertyValue('attributeEstimate', AttributeEstimateList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatisticAttributeEstimate.fhirType : string;
begin
  result := 'Evidence.statistic.attributeEstimate';
end;

function TFhirEvidenceStatisticAttributeEstimate.Link : TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate(inherited Link);
end;

function TFhirEvidenceStatisticAttributeEstimate.Clone : TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate(inherited Clone);
end;

function TFhirEvidenceStatisticAttributeEstimate.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatisticAttributeEstimate;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatisticAttributeEstimate)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatisticAttributeEstimate(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(levelElement, o.levelElement, true) and compareDeep(rangeElement, o.rangeElement, true) and 
      compareDeep(attributeEstimateList, o.attributeEstimateList, true);
  end;
end;

function TFhirEvidenceStatisticAttributeEstimate.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FType_) and isEmptyProp(FQuantity) and isEmptyProp(FLevel) and isEmptyProp(FRange) and isEmptyProp(FattributeEstimateList);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('type');
  fields.add('quantity');
  fields.add('level');
  fields.add('range');
  fields.add('attributeEstimate');
end;

function TFhirEvidenceStatisticAttributeEstimate.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FAttributeEstimateList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceStatisticAttributeEstimate.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetLevel(value : TFhirDecimal);
begin
  FLevel.free;
  FLevel := value;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetLevelST : String;
begin
  if FLevel = nil then
    result := ''
  else
    result := FLevel.value;
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetLevelST(value : String);
begin
  if value <> '' then
  begin
    if FLevel = nil then
      FLevel := TFhirDecimal.create;
    FLevel.value := value
  end
  else if FLevel <> nil then
    FLevel.value := '';
end;

procedure TFhirEvidenceStatisticAttributeEstimate.SetRange(value : TFhirRange);
begin
  FRange.free;
  FRange := value;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
begin
  if FAttributeEstimateList = nil then
    FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
  result := FAttributeEstimateList;
end;

function TFhirEvidenceStatisticAttributeEstimate.GetHasAttributeEstimateList : boolean;
begin
  result := (FAttributeEstimateList <> nil) and (FAttributeEstimateList.count > 0);
end;

{ TFhirEvidenceStatisticAttributeEstimateListEnumerator }

constructor TFhirEvidenceStatisticAttributeEstimateListEnumerator.Create(list : TFhirEvidenceStatisticAttributeEstimateList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticAttributeEstimateListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticAttributeEstimateListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticAttributeEstimateListEnumerator.GetCurrent : TFhirEvidenceStatisticAttributeEstimate;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticAttributeEstimateListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticAttributeEstimateList }

function TFhirEvidenceStatisticAttributeEstimateList.AddItem(value: TFhirEvidenceStatisticAttributeEstimate): TFhirEvidenceStatisticAttributeEstimate;
begin
  assert(value.ClassName = 'TFhirEvidenceStatisticAttributeEstimate', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatisticAttributeEstimate');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticAttributeEstimateList.Append: TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticAttributeEstimateList.GetEnumerator : TFhirEvidenceStatisticAttributeEstimateListEnumerator;
begin
  result := TFhirEvidenceStatisticAttributeEstimateListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Clone: TFhirEvidenceStatisticAttributeEstimateList;
begin
  result := TFhirEvidenceStatisticAttributeEstimateList(inherited Clone);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticAttributeEstimateList.GetItemN(index: Integer): TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticAttributeEstimateList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatisticAttributeEstimate;
end;
function TFhirEvidenceStatisticAttributeEstimateList.IndexOf(value: TFhirEvidenceStatisticAttributeEstimate): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Insert(index: Integer): TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.InsertItem(index: Integer; value: TFhirEvidenceStatisticAttributeEstimate);
begin
  assert(value is TFhirEvidenceStatisticAttributeEstimate);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Item(index: Integer): TFhirEvidenceStatisticAttributeEstimate;
begin
  result := TFhirEvidenceStatisticAttributeEstimate(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticAttributeEstimateList.Link: TFhirEvidenceStatisticAttributeEstimateList;
begin
  result := TFhirEvidenceStatisticAttributeEstimateList(inherited Link);
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatisticAttributeEstimate);
begin
  assert(value is TFhirEvidenceStatisticAttributeEstimate);
  FhirEvidenceStatisticAttributeEstimates[index] := value;
end;

procedure TFhirEvidenceStatisticAttributeEstimateList.SetItemN(index: Integer; value: TFhirEvidenceStatisticAttributeEstimate);
begin
  assert(value is TFhirEvidenceStatisticAttributeEstimate);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatisticModelCharacteristic }

constructor TFhirEvidenceStatisticModelCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatisticModelCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FVariableList.Free;
  FAttributeEstimateList.Free;
  inherited;
end;

procedure TFhirEvidenceStatisticModelCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirEvidenceStatisticModelCharacteristic(oSource).code.Clone;
  value := TFhirEvidenceStatisticModelCharacteristic(oSource).value.Clone;
  if (TFhirEvidenceStatisticModelCharacteristic(oSource).FVariableList = nil) then
  begin
    FVariableList.free;
    FVariableList := nil;
  end
  else
  begin
    if FVariableList = nil then
      FVariableList := TFhirEvidenceStatisticModelCharacteristicVariableList.Create;
    FVariableList.Assign(TFhirEvidenceStatisticModelCharacteristic(oSource).FVariableList);
  end;
  if (TFhirEvidenceStatisticModelCharacteristic(oSource).FAttributeEstimateList = nil) then
  begin
    FAttributeEstimateList.free;
    FAttributeEstimateList := nil;
  end
  else
  begin
    if FAttributeEstimateList = nil then
      FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
    FAttributeEstimateList.Assign(TFhirEvidenceStatisticModelCharacteristic(oSource).FAttributeEstimateList);
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'variable') Then
    list.addAll(self, 'variable', FVariableList);
  if (child_name = 'attributeEstimate') Then
    list.addAll(self, 'attributeEstimate', FAttributeEstimateList);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'Quantity', false, TFhirQuantity, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'variable', 'BackboneElement', true, TFhirEvidenceStatisticModelCharacteristicVariable, FVariableList.Link));
  oList.add(TFHIRProperty.create(self, 'attributeEstimate', '', true, TFhirEvidenceStatisticAttributeEstimate, FAttributeEstimateList.Link));
end;

function TFhirEvidenceStatisticModelCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'variable') then
  begin
    VariableList.add(propValue as TFhirEvidenceStatisticModelCharacteristicVariable);
    result := propValue;
  end
  else if (propName = 'attributeEstimate') then
  begin
    AttributeEstimateList.add(propValue as TFhirEvidenceStatisticAttributeEstimate);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'variable') then VariableList.insertItem(index, propValue as TFhirEvidenceStatisticModelCharacteristicVariable)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.insertItem(index, propValue as TFhirEvidenceStatisticAttributeEstimate)
  else inherited;
end;

function TFhirEvidenceStatisticModelCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirQuantity.create()
  else if (propName = 'variable') then result := VariableList.new()
  else if (propName = 'attributeEstimate') then result := AttributeEstimateList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatisticModelCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'Quantity'
  else if (propName = 'variable') then result := 'BackboneElement'
  else if (propName = 'attributeEstimate') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'value') then ValueElement := nil
  else if (propName = 'variable') then deletePropertyValue('variable', VariableList, value)
  else if (propName = 'attributeEstimate') then deletePropertyValue('attributeEstimate', AttributeEstimateList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := new as TFhirQuantity
  else if (propName = 'variable') then replacePropertyValue('variable', VariableList, existing, new)
  else if (propName = 'attributeEstimate') then replacePropertyValue('attributeEstimate', AttributeEstimateList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'variable') then VariableList.move(source, destination)
  else if (propName = 'attributeEstimate') then AttributeEstimateList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatisticModelCharacteristic.fhirType : string;
begin
  result := 'Evidence.statistic.modelCharacteristic';
end;

function TFhirEvidenceStatisticModelCharacteristic.Link : TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic(inherited Link);
end;

function TFhirEvidenceStatisticModelCharacteristic.Clone : TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic(inherited Clone);
end;

function TFhirEvidenceStatisticModelCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatisticModelCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatisticModelCharacteristic)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatisticModelCharacteristic(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(variableList, o.variableList, true) and compareDeep(attributeEstimateList, o.attributeEstimateList, true);
  end;
end;

function TFhirEvidenceStatisticModelCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FvariableList) and isEmptyProp(FattributeEstimateList);
end;

procedure TFhirEvidenceStatisticModelCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value');
  fields.add('variable');
  fields.add('attributeEstimate');
end;

function TFhirEvidenceStatisticModelCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FVariableList.sizeInBytes(magic));
  inc(result, FAttributeEstimateList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatisticModelCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirEvidenceStatisticModelCharacteristic.SetValue(value : TFhirQuantity);
begin
  FValue.free;
  FValue := value;
end;

function TFhirEvidenceStatisticModelCharacteristic.GetVariableList : TFhirEvidenceStatisticModelCharacteristicVariableList;
begin
  if FVariableList = nil then
    FVariableList := TFhirEvidenceStatisticModelCharacteristicVariableList.Create;
  result := FVariableList;
end;

function TFhirEvidenceStatisticModelCharacteristic.GetHasVariableList : boolean;
begin
  result := (FVariableList <> nil) and (FVariableList.count > 0);
end;

function TFhirEvidenceStatisticModelCharacteristic.GetAttributeEstimateList : TFhirEvidenceStatisticAttributeEstimateList;
begin
  if FAttributeEstimateList = nil then
    FAttributeEstimateList := TFhirEvidenceStatisticAttributeEstimateList.Create;
  result := FAttributeEstimateList;
end;

function TFhirEvidenceStatisticModelCharacteristic.GetHasAttributeEstimateList : boolean;
begin
  result := (FAttributeEstimateList <> nil) and (FAttributeEstimateList.count > 0);
end;

{ TFhirEvidenceStatisticModelCharacteristicListEnumerator }

constructor TFhirEvidenceStatisticModelCharacteristicListEnumerator.Create(list : TFhirEvidenceStatisticModelCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticModelCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticModelCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticModelCharacteristicListEnumerator.GetCurrent : TFhirEvidenceStatisticModelCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticModelCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticModelCharacteristicList }

function TFhirEvidenceStatisticModelCharacteristicList.AddItem(value: TFhirEvidenceStatisticModelCharacteristic): TFhirEvidenceStatisticModelCharacteristic;
begin
  assert(value.ClassName = 'TFhirEvidenceStatisticModelCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatisticModelCharacteristic');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticModelCharacteristicList.Append: TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticModelCharacteristicList.GetEnumerator : TFhirEvidenceStatisticModelCharacteristicListEnumerator;
begin
  result := TFhirEvidenceStatisticModelCharacteristicListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Clone: TFhirEvidenceStatisticModelCharacteristicList;
begin
  result := TFhirEvidenceStatisticModelCharacteristicList(inherited Clone);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticModelCharacteristicList.GetItemN(index: Integer): TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticModelCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatisticModelCharacteristic;
end;
function TFhirEvidenceStatisticModelCharacteristicList.IndexOf(value: TFhirEvidenceStatisticModelCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Insert(index: Integer): TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.InsertItem(index: Integer; value: TFhirEvidenceStatisticModelCharacteristic);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Item(index: Integer): TFhirEvidenceStatisticModelCharacteristic;
begin
  result := TFhirEvidenceStatisticModelCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticModelCharacteristicList.Link: TFhirEvidenceStatisticModelCharacteristicList;
begin
  result := TFhirEvidenceStatisticModelCharacteristicList(inherited Link);
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatisticModelCharacteristic);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristic);
  FhirEvidenceStatisticModelCharacteristics[index] := value;
end;

procedure TFhirEvidenceStatisticModelCharacteristicList.SetItemN(index: Integer; value: TFhirEvidenceStatisticModelCharacteristic);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceStatisticModelCharacteristicVariable }

constructor TFhirEvidenceStatisticModelCharacteristicVariable.Create;
begin
  inherited;
end;

destructor TFhirEvidenceStatisticModelCharacteristicVariable.Destroy;
begin
  FVariableDefinition.free;
  FHandling.free;
  FValueCategoryList.Free;
  FValueQuantityList.Free;
  FValueRangeList.Free;
  inherited;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.Assign(oSource : TFslObject);
begin
  inherited;
  variableDefinition := TFhirEvidenceStatisticModelCharacteristicVariable(oSource).variableDefinition.Clone;
  handlingElement := TFhirEvidenceStatisticModelCharacteristicVariable(oSource).handlingElement.Clone;
  if (TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueCategoryList = nil) then
  begin
    FValueCategoryList.free;
    FValueCategoryList := nil;
  end
  else
  begin
    if FValueCategoryList = nil then
      FValueCategoryList := TFhirCodeableConceptList.Create;
    FValueCategoryList.Assign(TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueCategoryList);
  end;
  if (TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueQuantityList = nil) then
  begin
    FValueQuantityList.free;
    FValueQuantityList := nil;
  end
  else
  begin
    if FValueQuantityList = nil then
      FValueQuantityList := TFhirQuantityList.Create;
    FValueQuantityList.Assign(TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueQuantityList);
  end;
  if (TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueRangeList = nil) then
  begin
    FValueRangeList.free;
    FValueRangeList := nil;
  end
  else
  begin
    if FValueRangeList = nil then
      FValueRangeList := TFhirRangeList.Create;
    FValueRangeList.Assign(TFhirEvidenceStatisticModelCharacteristicVariable(oSource).FValueRangeList);
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'variableDefinition') Then
     list.add(self.link, 'variableDefinition', FVariableDefinition.Link);
  if (child_name = 'handling') Then
     list.add(self.link, 'handling', FHandling.Link);
  if (child_name = 'valueCategory') Then
    list.addAll(self, 'valueCategory', FValueCategoryList);
  if (child_name = 'valueQuantity') Then
    list.addAll(self, 'valueQuantity', FValueQuantityList);
  if (child_name = 'valueRange') Then
    list.addAll(self, 'valueRange', FValueRangeList);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'variableDefinition', 'Reference', false, TFhirReference, FVariableDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'handling', 'code', false, TFhirEnum, FHandling.Link));
  oList.add(TFHIRProperty.create(self, 'valueCategory', 'CodeableConcept', true, TFhirCodeableConcept, FValueCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'valueQuantity', 'Quantity', true, TFhirQuantity, FValueQuantityList.Link));
  oList.add(TFHIRProperty.create(self, 'valueRange', 'Range', true, TFhirRange, FValueRangeList.Link));
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'variableDefinition') then
  begin
    VariableDefinition := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'handling') then
  begin
    HandlingElement := asEnum(SYSTEMS_TFhirEvidenceVariableHandlingEnum, CODES_TFhirEvidenceVariableHandlingEnum, propValue);
    result := propValue;
  end
  else if (propName = 'valueCategory') then
  begin
    ValueCategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'valueQuantity') then
  begin
    ValueQuantityList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'valueRange') then
  begin
    ValueRangeList.add(propValue as TFhirRange);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'valueCategory') then ValueCategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'valueQuantity') then ValueQuantityList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'valueRange') then ValueRangeList.insertItem(index, propValue as TFhirRange)
  else inherited;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'variableDefinition') then result := TFhirReference.create()
  else if (propName = 'handling') then result := TFhirEnum.create(SYSTEMS_TFhirEvidenceVariableHandlingEnum[EvidenceVariableHandlingNull], CODES_TFhirEvidenceVariableHandlingEnum[EvidenceVariableHandlingNull]) 
  else if (propName = 'valueCategory') then result := ValueCategoryList.new()
  else if (propName = 'valueQuantity') then result := ValueQuantityList.new()
  else if (propName = 'valueRange') then result := ValueRangeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'variableDefinition') then result := 'Reference'
  else if (propName = 'handling') then result := 'code'
  else if (propName = 'valueCategory') then result := 'CodeableConcept'
  else if (propName = 'valueQuantity') then result := 'Quantity'
  else if (propName = 'valueRange') then result := 'Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'variableDefinition') then VariableDefinitionElement := nil
  else if (propName = 'handling') then HandlingElement := nil
  else if (propName = 'valueCategory') then deletePropertyValue('valueCategory', ValueCategoryList, value)
  else if (propName = 'valueQuantity') then deletePropertyValue('valueQuantity', ValueQuantityList, value)
  else if (propName = 'valueRange') then deletePropertyValue('valueRange', ValueRangeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'variableDefinition') then VariableDefinitionElement := new as TFhirReference
  else if (propName = 'handling') then HandlingElement := asEnum(SYSTEMS_TFhirEvidenceVariableHandlingEnum, CODES_TFhirEvidenceVariableHandlingEnum, new)
  else if (propName = 'valueCategory') then replacePropertyValue('valueCategory', ValueCategoryList, existing, new)
  else if (propName = 'valueQuantity') then replacePropertyValue('valueQuantity', ValueQuantityList, existing, new)
  else if (propName = 'valueRange') then replacePropertyValue('valueRange', ValueRangeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'valueCategory') then ValueCategoryList.move(source, destination)
  else if (propName = 'valueQuantity') then ValueQuantityList.move(source, destination)
  else if (propName = 'valueRange') then ValueRangeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.fhirType : string;
begin
  result := 'Evidence.statistic.modelCharacteristic.variable';
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.Link : TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable(inherited Link);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.Clone : TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable(inherited Clone);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceStatisticModelCharacteristicVariable)) then
    result := false
  else
  begin
    o := TFhirEvidenceStatisticModelCharacteristicVariable(other);
    result := compareDeep(variableDefinitionElement, o.variableDefinitionElement, true) and 
      compareDeep(handlingElement, o.handlingElement, true) and compareDeep(valueCategoryList, o.valueCategoryList, true) and 
      compareDeep(valueQuantityList, o.valueQuantityList, true) and compareDeep(valueRangeList, o.valueRangeList, true);
  end;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FVariableDefinition) and isEmptyProp(FHandling) and isEmptyProp(FvalueCategoryList) and isEmptyProp(FvalueQuantityList) and isEmptyProp(FvalueRangeList);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('variableDefinition');
  fields.add('handling');
  fields.add('valueCategory');
  fields.add('valueQuantity');
  fields.add('valueRange');
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FValueCategoryList.sizeInBytes(magic));
  inc(result, FValueQuantityList.sizeInBytes(magic));
  inc(result, FValueRangeList.sizeInBytes(magic));
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.SetVariableDefinition(value : TFhirReference);
begin
  FVariableDefinition.free;
  FVariableDefinition := value;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.SetHandling(value : TFhirEnum);
begin
  FHandling.free;
  FHandling := value;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetHandlingST : TFhirEvidenceVariableHandlingEnum;
begin
  if FHandling = nil then
    result := TFhirEvidenceVariableHandlingEnum(0)
  else
    result := TFhirEvidenceVariableHandlingEnum(StringArrayIndexOfSensitive(CODES_TFhirEvidenceVariableHandlingEnum, FHandling.value));
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariable.SetHandlingST(value : TFhirEvidenceVariableHandlingEnum);
begin
  if ord(value) = 0 then
    HandlingElement := nil
  else
    HandlingElement := TFhirEnum.create(SYSTEMS_TFhirEvidenceVariableHandlingEnum[value], CODES_TFhirEvidenceVariableHandlingEnum[value]);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetValueCategoryList : TFhirCodeableConceptList;
begin
  if FValueCategoryList = nil then
    FValueCategoryList := TFhirCodeableConceptList.Create;
  result := FValueCategoryList;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetHasValueCategoryList : boolean;
begin
  result := (FValueCategoryList <> nil) and (FValueCategoryList.count > 0);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetValueQuantityList : TFhirQuantityList;
begin
  if FValueQuantityList = nil then
    FValueQuantityList := TFhirQuantityList.Create;
  result := FValueQuantityList;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetHasValueQuantityList : boolean;
begin
  result := (FValueQuantityList <> nil) and (FValueQuantityList.count > 0);
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetValueRangeList : TFhirRangeList;
begin
  if FValueRangeList = nil then
    FValueRangeList := TFhirRangeList.Create;
  result := FValueRangeList;
end;

function TFhirEvidenceStatisticModelCharacteristicVariable.GetHasValueRangeList : boolean;
begin
  result := (FValueRangeList <> nil) and (FValueRangeList.count > 0);
end;

{ TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator }

constructor TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.Create(list : TFhirEvidenceStatisticModelCharacteristicVariableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.GetCurrent : TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceStatisticModelCharacteristicVariableList }

function TFhirEvidenceStatisticModelCharacteristicVariableList.AddItem(value: TFhirEvidenceStatisticModelCharacteristicVariable): TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  assert(value.ClassName = 'TFhirEvidenceStatisticModelCharacteristicVariable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceStatisticModelCharacteristicVariable');
  add(value);
  result := value;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Append: TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.GetEnumerator : TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariableListEnumerator.Create(self.link);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Clone: TFhirEvidenceStatisticModelCharacteristicVariableList;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariableList(inherited Clone);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.GetItemN(index: Integer): TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable;
end;
function TFhirEvidenceStatisticModelCharacteristicVariableList.IndexOf(value: TFhirEvidenceStatisticModelCharacteristicVariable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Insert(index: Integer): TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.InsertItem(index: Integer; value: TFhirEvidenceStatisticModelCharacteristicVariable);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristicVariable);
  Inherited Insert(index, value);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Item(index: Integer): TFhirEvidenceStatisticModelCharacteristicVariable;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceStatisticModelCharacteristicVariableList.Link: TFhirEvidenceStatisticModelCharacteristicVariableList;
begin
  result := TFhirEvidenceStatisticModelCharacteristicVariableList(inherited Link);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.SetItemByIndex(index: Integer; value: TFhirEvidenceStatisticModelCharacteristicVariable);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristicVariable);
  FhirEvidenceStatisticModelCharacteristicVariables[index] := value;
end;

procedure TFhirEvidenceStatisticModelCharacteristicVariableList.SetItemN(index: Integer; value: TFhirEvidenceStatisticModelCharacteristicVariable);
begin
  assert(value is TFhirEvidenceStatisticModelCharacteristicVariable);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceCertainty }

constructor TFhirEvidenceCertainty.Create;
begin
  inherited;
end;

destructor TFhirEvidenceCertainty.Destroy;
begin
  FDescription.free;
  FNoteList.Free;
  FType_.free;
  FRating.free;
  FRater.free;
  FSubcomponentList.Free;
  inherited;
end;

procedure TFhirEvidenceCertainty.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceCertainty(oSource).descriptionElement.Clone;
  if (TFhirEvidenceCertainty(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceCertainty(oSource).FNoteList);
  end;
  type_ := TFhirEvidenceCertainty(oSource).type_.Clone;
  rating := TFhirEvidenceCertainty(oSource).rating.Clone;
  raterElement := TFhirEvidenceCertainty(oSource).raterElement.Clone;
  if (TFhirEvidenceCertainty(oSource).FSubcomponentList = nil) then
  begin
    FSubcomponentList.free;
    FSubcomponentList := nil;
  end
  else
  begin
    if FSubcomponentList = nil then
      FSubcomponentList := TFhirEvidenceCertaintyList.Create;
    FSubcomponentList.Assign(TFhirEvidenceCertainty(oSource).FSubcomponentList);
  end;
end;

procedure TFhirEvidenceCertainty.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'rating') Then
     list.add(self.link, 'rating', FRating.Link);
  if (child_name = 'rater') Then
     list.add(self.link, 'rater', FRater.Link);
  if (child_name = 'subcomponent') Then
    list.addAll(self, 'subcomponent', FSubcomponentList);
end;

procedure TFhirEvidenceCertainty.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'rating', 'CodeableConcept', false, TFhirCodeableConcept, FRating.Link));
  oList.add(TFHIRProperty.create(self, 'rater', 'string', false, TFhirString, FRater.Link));
  oList.add(TFHIRProperty.create(self, 'subcomponent', '', true, TFhirEvidenceCertainty, FSubcomponentList.Link));
end;

function TFhirEvidenceCertainty.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'rating') then
  begin
    Rating := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'rater') then
  begin
    RaterElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subcomponent') then
  begin
    SubcomponentList.add(propValue as TFhirEvidenceCertainty);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceCertainty.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'subcomponent') then SubcomponentList.insertItem(index, propValue as TFhirEvidenceCertainty)
  else inherited;
end;

function TFhirEvidenceCertainty.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'rating') then result := TFhirCodeableConcept.create()
  else if (propName = 'rater') then result := TFhirString.create()
  else if (propName = 'subcomponent') then result := SubcomponentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceCertainty.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'rating') then result := 'CodeableConcept'
  else if (propName = 'rater') then result := 'string'
  else if (propName = 'subcomponent') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceCertainty.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'rating') then RatingElement := nil
  else if (propName = 'rater') then RaterElement := nil
  else if (propName = 'subcomponent') then deletePropertyValue('subcomponent', SubcomponentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceCertainty.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'rating') then RatingElement := new as TFhirCodeableConcept
  else if (propName = 'rater') then RaterElement := asString(new)
  else if (propName = 'subcomponent') then replacePropertyValue('subcomponent', SubcomponentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceCertainty.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'subcomponent') then SubcomponentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceCertainty.fhirType : string;
begin
  result := 'Evidence.certainty';
end;

function TFhirEvidenceCertainty.Link : TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty(inherited Link);
end;

function TFhirEvidenceCertainty.Clone : TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty(inherited Clone);
end;

function TFhirEvidenceCertainty.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceCertainty;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceCertainty)) then
    result := false
  else
  begin
    o := TFhirEvidenceCertainty(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(ratingElement, o.ratingElement, true) and 
      compareDeep(raterElement, o.raterElement, true) and compareDeep(subcomponentList, o.subcomponentList, true);
  end;
end;

function TFhirEvidenceCertainty.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FType_) and isEmptyProp(FRating) and isEmptyProp(FRater) and isEmptyProp(FsubcomponentList);
end;

procedure TFhirEvidenceCertainty.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('note');
  fields.add('type');
  fields.add('rating');
  fields.add('rater');
  fields.add('subcomponent');
end;

function TFhirEvidenceCertainty.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FSubcomponentList.sizeInBytes(magic));
end;

procedure TFhirEvidenceCertainty.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceCertainty.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceCertainty.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceCertainty.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceCertainty.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

procedure TFhirEvidenceCertainty.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirEvidenceCertainty.SetRating(value : TFhirCodeableConcept);
begin
  FRating.free;
  FRating := value;
end;

procedure TFhirEvidenceCertainty.SetRater(value : TFhirString);
begin
  FRater.free;
  FRater := value;
end;

function TFhirEvidenceCertainty.GetRaterST : String;
begin
  if FRater = nil then
    result := ''
  else
    result := FRater.value;
end;

procedure TFhirEvidenceCertainty.SetRaterST(value : String);
begin
  if value <> '' then
  begin
    if FRater = nil then
      FRater := TFhirString.create;
    FRater.value := value
  end
  else if FRater <> nil then
    FRater.value := '';
end;

function TFhirEvidenceCertainty.GetSubcomponentList : TFhirEvidenceCertaintyList;
begin
  if FSubcomponentList = nil then
    FSubcomponentList := TFhirEvidenceCertaintyList.Create;
  result := FSubcomponentList;
end;

function TFhirEvidenceCertainty.GetHasSubcomponentList : boolean;
begin
  result := (FSubcomponentList <> nil) and (FSubcomponentList.count > 0);
end;

{ TFhirEvidenceCertaintyListEnumerator }

constructor TFhirEvidenceCertaintyListEnumerator.Create(list : TFhirEvidenceCertaintyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceCertaintyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceCertaintyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceCertaintyListEnumerator.GetCurrent : TFhirEvidenceCertainty;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceCertaintyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceCertaintyList }

function TFhirEvidenceCertaintyList.AddItem(value: TFhirEvidenceCertainty): TFhirEvidenceCertainty;
begin
  assert(value.ClassName = 'TFhirEvidenceCertainty', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceCertainty');
  add(value);
  result := value;
end;

function TFhirEvidenceCertaintyList.Append: TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceCertaintyList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceCertaintyList.GetEnumerator : TFhirEvidenceCertaintyListEnumerator;
begin
  result := TFhirEvidenceCertaintyListEnumerator.Create(self.link);
end;

function TFhirEvidenceCertaintyList.Clone: TFhirEvidenceCertaintyList;
begin
  result := TFhirEvidenceCertaintyList(inherited Clone);
end;

function TFhirEvidenceCertaintyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceCertaintyList.GetItemN(index: Integer): TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty(ObjectByIndex[index]);
end;

function TFhirEvidenceCertaintyList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceCertainty;
end;
function TFhirEvidenceCertaintyList.IndexOf(value: TFhirEvidenceCertainty): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceCertaintyList.Insert(index: Integer): TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceCertaintyList.InsertItem(index: Integer; value: TFhirEvidenceCertainty);
begin
  assert(value is TFhirEvidenceCertainty);
  Inherited Insert(index, value);
end;

function TFhirEvidenceCertaintyList.Item(index: Integer): TFhirEvidenceCertainty;
begin
  result := TFhirEvidenceCertainty(ObjectByIndex[index]);
end;

function TFhirEvidenceCertaintyList.Link: TFhirEvidenceCertaintyList;
begin
  result := TFhirEvidenceCertaintyList(inherited Link);
end;

procedure TFhirEvidenceCertaintyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceCertaintyList.SetItemByIndex(index: Integer; value: TFhirEvidenceCertainty);
begin
  assert(value is TFhirEvidenceCertainty);
  FhirEvidenceCertainties[index] := value;
end;

procedure TFhirEvidenceCertaintyList.SetItemN(index: Integer; value: TFhirEvidenceCertainty);
begin
  assert(value is TFhirEvidenceCertainty);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidence }

constructor TFhirEvidence.Create;
begin
  inherited;
end;

destructor TFhirEvidence.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FTitle.free;
  FCiteAs.free;
  FStatus.free;
  FDate.free;
  FUseContextList.Free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FPublisher.free;
  FContactList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FDescription.free;
  FAssertion.free;
  FNoteList.Free;
  FVariableDefinitionList.Free;
  FSynthesisType.free;
  FStudyType.free;
  FStatisticList.Free;
  FCertaintyList.Free;
  inherited;
end;

procedure TFhirEvidence.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirEvidence(oSource).urlElement.Clone;
  if (TFhirEvidence(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEvidence(oSource).FIdentifierList);
  end;
  versionElement := TFhirEvidence(oSource).versionElement.Clone;
  titleElement := TFhirEvidence(oSource).titleElement.Clone;
  citeAs := TFhirEvidence(oSource).citeAs.Clone;
  statusElement := TFhirEvidence(oSource).statusElement.Clone;
  dateElement := TFhirEvidence(oSource).dateElement.Clone;
  if (TFhirEvidence(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirEvidence(oSource).FUseContextList);
  end;
  approvalDateElement := TFhirEvidence(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirEvidence(oSource).lastReviewDateElement.Clone;
  publisherElement := TFhirEvidence(oSource).publisherElement.Clone;
  if (TFhirEvidence(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirEvidence(oSource).FContactList);
  end;
  if (TFhirEvidence(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirEvidence(oSource).FAuthorList);
  end;
  if (TFhirEvidence(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirEvidence(oSource).FEditorList);
  end;
  if (TFhirEvidence(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirEvidence(oSource).FReviewerList);
  end;
  if (TFhirEvidence(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirEvidence(oSource).FEndorserList);
  end;
  if (TFhirEvidence(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirEvidence(oSource).FRelatedArtifactList);
  end;
  descriptionElement := TFhirEvidence(oSource).descriptionElement.Clone;
  assertionElement := TFhirEvidence(oSource).assertionElement.Clone;
  if (TFhirEvidence(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidence(oSource).FNoteList);
  end;
  if (TFhirEvidence(oSource).FVariableDefinitionList = nil) then
  begin
    FVariableDefinitionList.free;
    FVariableDefinitionList := nil;
  end
  else
  begin
    if FVariableDefinitionList = nil then
      FVariableDefinitionList := TFhirEvidenceVariableDefinitionList.Create;
    FVariableDefinitionList.Assign(TFhirEvidence(oSource).FVariableDefinitionList);
  end;
  synthesisType := TFhirEvidence(oSource).synthesisType.Clone;
  studyType := TFhirEvidence(oSource).studyType.Clone;
  if (TFhirEvidence(oSource).FStatisticList = nil) then
  begin
    FStatisticList.free;
    FStatisticList := nil;
  end
  else
  begin
    if FStatisticList = nil then
      FStatisticList := TFhirEvidenceStatisticList.Create;
    FStatisticList.Assign(TFhirEvidence(oSource).FStatisticList);
  end;
  if (TFhirEvidence(oSource).FCertaintyList = nil) then
  begin
    FCertaintyList.free;
    FCertaintyList := nil;
  end
  else
  begin
    if FCertaintyList = nil then
      FCertaintyList := TFhirEvidenceCertaintyList.Create;
    FCertaintyList.Assign(TFhirEvidence(oSource).FCertaintyList);
  end;
end;

function TFhirEvidence.GetResourceType : TFhirResourceType;
begin
  result := frtEvidence;
end;

procedure TFhirEvidence.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'citeAs[x]') or (child_name = 'citeAs') Then
     list.add(self.link, 'citeAs[x]', FCiteAs.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'assertion') Then
     list.add(self.link, 'assertion', FAssertion.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'variableDefinition') Then
    list.addAll(self, 'variableDefinition', FVariableDefinitionList);
  if (child_name = 'synthesisType') Then
     list.add(self.link, 'synthesisType', FSynthesisType.Link);
  if (child_name = 'studyType') Then
     list.add(self.link, 'studyType', FStudyType.Link);
  if (child_name = 'statistic') Then
    list.addAll(self, 'statistic', FStatisticList);
  if (child_name = 'certainty') Then
    list.addAll(self, 'certainty', FCertaintyList);
end;

procedure TFhirEvidence.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'citeAs[x]', 'Reference|markdown', false, TFhirDataType, FCiteAs.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'assertion', 'markdown', false, TFhirMarkdown, FAssertion.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'variableDefinition', 'BackboneElement', true, TFhirEvidenceVariableDefinition, FVariableDefinitionList.Link));
  oList.add(TFHIRProperty.create(self, 'synthesisType', 'CodeableConcept', false, TFhirCodeableConcept, FSynthesisType.Link));
  oList.add(TFHIRProperty.create(self, 'studyType', 'CodeableConcept', false, TFhirCodeableConcept, FStudyType.Link));
  oList.add(TFHIRProperty.create(self, 'statistic', 'BackboneElement', true, TFhirEvidenceStatistic, FStatisticList.Link));
  oList.add(TFHIRProperty.create(self, 'certainty', 'BackboneElement', true, TFhirEvidenceCertainty, FCertaintyList.Link));
end;

function TFhirEvidence.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then
  begin
    CiteAs := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'assertion') then
  begin
    AssertionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'variableDefinition') then
  begin
    VariableDefinitionList.add(propValue as TFhirEvidenceVariableDefinition);
    result := propValue;
  end
  else if (propName = 'synthesisType') then
  begin
    SynthesisType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'studyType') then
  begin
    StudyType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'statistic') then
  begin
    StatisticList.add(propValue as TFhirEvidenceStatistic);
    result := propValue;
  end
  else if (propName = 'certainty') then
  begin
    CertaintyList.add(propValue as TFhirEvidenceCertainty);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidence.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'variableDefinition') then VariableDefinitionList.insertItem(index, propValue as TFhirEvidenceVariableDefinition)
  else if (propName = 'statistic') then StatisticList.insertItem(index, propValue as TFhirEvidenceStatistic)
  else if (propName = 'certainty') then CertaintyList.insertItem(index, propValue as TFhirEvidenceCertainty)
  else inherited;
end;

function TFhirEvidence.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then raise EFHIRException.create('Cannot make property CiteAs')
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'assertion') then result := TFhirMarkdown.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'variableDefinition') then result := VariableDefinitionList.new()
  else if (propName = 'synthesisType') then result := TFhirCodeableConcept.create()
  else if (propName = 'studyType') then result := TFhirCodeableConcept.create()
  else if (propName = 'statistic') then result := StatisticList.new()
  else if (propName = 'certainty') then result := CertaintyList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidence.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'citeAs[x]') then result := 'Reference|markdown'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'assertion') then result := 'markdown'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'variableDefinition') then result := 'BackboneElement'
  else if (propName = 'synthesisType') then result := 'CodeableConcept'
  else if (propName = 'studyType') then result := 'CodeableConcept'
  else if (propName = 'statistic') then result := 'BackboneElement'
  else if (propName = 'certainty') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidence.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'assertion') then AssertionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'variableDefinition') then deletePropertyValue('variableDefinition', VariableDefinitionList, value)
  else if (propName = 'synthesisType') then SynthesisTypeElement := nil
  else if (propName = 'studyType') then StudyTypeElement := nil
  else if (propName = 'statistic') then deletePropertyValue('statistic', StatisticList, value)
  else if (propName = 'certainty') then deletePropertyValue('certainty', CertaintyList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidence.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := new as TFhirDataType
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'assertion') then AssertionElement := asMarkdown(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'variableDefinition') then replacePropertyValue('variableDefinition', VariableDefinitionList, existing, new)
  else if (propName = 'synthesisType') then SynthesisTypeElement := new as TFhirCodeableConcept
  else if (propName = 'studyType') then StudyTypeElement := new as TFhirCodeableConcept
  else if (propName = 'statistic') then replacePropertyValue('statistic', StatisticList, existing, new)
  else if (propName = 'certainty') then replacePropertyValue('certainty', CertaintyList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidence.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'variableDefinition') then VariableDefinitionList.move(source, destination)
  else if (propName = 'statistic') then StatisticList.move(source, destination)
  else if (propName = 'certainty') then CertaintyList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidence.fhirType : string;
begin
  result := 'Evidence';
end;

function TFhirEvidence.Link : TFhirEvidence;
begin
  result := TFhirEvidence(inherited Link);
end;

function TFhirEvidence.Clone : TFhirEvidence;
begin
  result := TFhirEvidence(inherited Clone);
end;

function TFhirEvidence.equals(other : TObject) : boolean; 
var
  o : TFhirEvidence;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidence)) then
    result := false
  else
  begin
    o := TFhirEvidence(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(citeAsElement, o.citeAsElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(assertionElement, o.assertionElement, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(variableDefinitionList, o.variableDefinitionList, true) and compareDeep(synthesisTypeElement, o.synthesisTypeElement, true) and 
      compareDeep(studyTypeElement, o.studyTypeElement, true) and compareDeep(statisticList, o.statisticList, true) and 
      compareDeep(certaintyList, o.certaintyList, true);
  end;
end;

function TFhirEvidence.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FTitle) and isEmptyProp(FCiteAs) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FuseContextList) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FDescription) and isEmptyProp(FAssertion) and isEmptyProp(FnoteList) and isEmptyProp(FvariableDefinitionList) and isEmptyProp(FSynthesisType) and isEmptyProp(FStudyType) and isEmptyProp(FstatisticList) and isEmptyProp(FcertaintyList);
end;

procedure TFhirEvidence.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('title');
  fields.add('citeAs[x]');
  fields.add('status');
  fields.add('date');
  fields.add('useContext');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('publisher');
  fields.add('contact');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('description');
  fields.add('assertion');
  fields.add('note');
  fields.add('variableDefinition');
  fields.add('synthesisType');
  fields.add('studyType');
  fields.add('statistic');
  fields.add('certainty');
end;

function TFhirEvidence.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FVariableDefinitionList.sizeInBytes(magic));
  inc(result, FStatisticList.sizeInBytes(magic));
  inc(result, FCertaintyList.sizeInBytes(magic));
end;

procedure TFhirEvidence.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirEvidence.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirEvidence.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirEvidence.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEvidence.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEvidence.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirEvidence.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirEvidence.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirEvidence.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirEvidence.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirEvidence.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirEvidence.SetCiteAs(value : TFhirDataType);
begin
  FCiteAs.free;
  FCiteAs := value;
end;

procedure TFhirEvidence.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEvidence.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirEvidence.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirEvidence.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirEvidence.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirEvidence.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

function TFhirEvidence.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirEvidence.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

procedure TFhirEvidence.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirEvidence.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirEvidence.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirEvidence.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirEvidence.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirEvidence.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirEvidence.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirEvidence.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirEvidence.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirEvidence.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirEvidence.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirEvidence.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirEvidence.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirEvidence.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirEvidence.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirEvidence.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirEvidence.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirEvidence.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirEvidence.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirEvidence.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirEvidence.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

procedure TFhirEvidence.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidence.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidence.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirEvidence.SetAssertion(value : TFhirMarkdown);
begin
  FAssertion.free;
  FAssertion := value;
end;

function TFhirEvidence.GetAssertionST : String;
begin
  if FAssertion = nil then
    result := ''
  else
    result := FAssertion.value;
end;

procedure TFhirEvidence.SetAssertionST(value : String);
begin
  if value <> '' then
  begin
    if FAssertion = nil then
      FAssertion := TFhirMarkdown.create;
    FAssertion.value := value
  end
  else if FAssertion <> nil then
    FAssertion.value := '';
end;

function TFhirEvidence.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidence.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirEvidence.GetVariableDefinitionList : TFhirEvidenceVariableDefinitionList;
begin
  if FVariableDefinitionList = nil then
    FVariableDefinitionList := TFhirEvidenceVariableDefinitionList.Create;
  result := FVariableDefinitionList;
end;

function TFhirEvidence.GetHasVariableDefinitionList : boolean;
begin
  result := (FVariableDefinitionList <> nil) and (FVariableDefinitionList.count > 0);
end;

procedure TFhirEvidence.SetSynthesisType(value : TFhirCodeableConcept);
begin
  FSynthesisType.free;
  FSynthesisType := value;
end;

procedure TFhirEvidence.SetStudyType(value : TFhirCodeableConcept);
begin
  FStudyType.free;
  FStudyType := value;
end;

function TFhirEvidence.GetStatisticList : TFhirEvidenceStatisticList;
begin
  if FStatisticList = nil then
    FStatisticList := TFhirEvidenceStatisticList.Create;
  result := FStatisticList;
end;

function TFhirEvidence.GetHasStatisticList : boolean;
begin
  result := (FStatisticList <> nil) and (FStatisticList.count > 0);
end;

function TFhirEvidence.GetCertaintyList : TFhirEvidenceCertaintyList;
begin
  if FCertaintyList = nil then
    FCertaintyList := TFhirEvidenceCertaintyList.Create;
  result := FCertaintyList;
end;

function TFhirEvidence.GetHasCertaintyList : boolean;
begin
  result := (FCertaintyList <> nil) and (FCertaintyList.count > 0);
end;

{ TFhirEvidenceListEnumerator }

constructor TFhirEvidenceListEnumerator.Create(list : TFhirEvidenceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceListEnumerator.GetCurrent : TFhirEvidence;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceList }

function TFhirEvidenceList.AddItem(value: TFhirEvidence): TFhirEvidence;
begin
  assert(value.ClassName = 'TFhirEvidence', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidence');
  add(value);
  result := value;
end;

function TFhirEvidenceList.Append: TFhirEvidence;
begin
  result := TFhirEvidence.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceList.GetEnumerator : TFhirEvidenceListEnumerator;
begin
  result := TFhirEvidenceListEnumerator.Create(self.link);
end;

function TFhirEvidenceList.Clone: TFhirEvidenceList;
begin
  result := TFhirEvidenceList(inherited Clone);
end;

function TFhirEvidenceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceList.GetItemN(index: Integer): TFhirEvidence;
begin
  result := TFhirEvidence(ObjectByIndex[index]);
end;

function TFhirEvidenceList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidence;
end;
function TFhirEvidenceList.IndexOf(value: TFhirEvidence): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceList.Insert(index: Integer): TFhirEvidence;
begin
  result := TFhirEvidence.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceList.InsertItem(index: Integer; value: TFhirEvidence);
begin
  assert(value is TFhirEvidence);
  Inherited Insert(index, value);
end;

function TFhirEvidenceList.Item(index: Integer): TFhirEvidence;
begin
  result := TFhirEvidence(ObjectByIndex[index]);
end;

function TFhirEvidenceList.Link: TFhirEvidenceList;
begin
  result := TFhirEvidenceList(inherited Link);
end;

procedure TFhirEvidenceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceList.SetItemByIndex(index: Integer; value: TFhirEvidence);
begin
  assert(value is TFhirEvidence);
  FhirEvidences[index] := value;
end;

procedure TFhirEvidenceList.SetItemN(index: Integer; value: TFhirEvidence);
begin
  assert(value is TFhirEvidence);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EVIDENCE}
{$IFDEF FHIR_EVIDENCEREPORT}
{ TFhirEvidenceReportSubject }

constructor TFhirEvidenceReportSubject.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReportSubject.Destroy;
begin
  FCharacteristicList.Free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirEvidenceReportSubject.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirEvidenceReportSubject(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirEvidenceReportSubjectCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirEvidenceReportSubject(oSource).FCharacteristicList);
  end;
  if (TFhirEvidenceReportSubject(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceReportSubject(oSource).FNoteList);
  end;
end;

procedure TFhirEvidenceReportSubject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirEvidenceReportSubject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirEvidenceReportSubjectCharacteristic, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirEvidenceReportSubject.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirEvidenceReportSubjectCharacteristic);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReportSubject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirEvidenceReportSubjectCharacteristic)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirEvidenceReportSubject.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReportSubject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'characteristic') then result := 'BackboneElement'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReportSubject.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReportSubject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReportSubject.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReportSubject.fhirType : string;
begin
  result := 'EvidenceReport.subject';
end;

function TFhirEvidenceReportSubject.Link : TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject(inherited Link);
end;

function TFhirEvidenceReportSubject.Clone : TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject(inherited Clone);
end;

function TFhirEvidenceReportSubject.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReportSubject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReportSubject)) then
    result := false
  else
  begin
    o := TFhirEvidenceReportSubject(other);
    result := compareDeep(characteristicList, o.characteristicList, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirEvidenceReportSubject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcharacteristicList) and isEmptyProp(FnoteList);
end;

procedure TFhirEvidenceReportSubject.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('characteristic');
  fields.add('note');
end;

function TFhirEvidenceReportSubject.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
end;

function TFhirEvidenceReportSubject.GetCharacteristicList : TFhirEvidenceReportSubjectCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirEvidenceReportSubjectCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirEvidenceReportSubject.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

function TFhirEvidenceReportSubject.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceReportSubject.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirEvidenceReportSubjectListEnumerator }

constructor TFhirEvidenceReportSubjectListEnumerator.Create(list : TFhirEvidenceReportSubjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportSubjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportSubjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportSubjectListEnumerator.GetCurrent : TFhirEvidenceReportSubject;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportSubjectListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportSubjectList }

function TFhirEvidenceReportSubjectList.AddItem(value: TFhirEvidenceReportSubject): TFhirEvidenceReportSubject;
begin
  assert(value.ClassName = 'TFhirEvidenceReportSubject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReportSubject');
  add(value);
  result := value;
end;

function TFhirEvidenceReportSubjectList.Append: TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSubjectList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportSubjectList.GetEnumerator : TFhirEvidenceReportSubjectListEnumerator;
begin
  result := TFhirEvidenceReportSubjectListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportSubjectList.Clone: TFhirEvidenceReportSubjectList;
begin
  result := TFhirEvidenceReportSubjectList(inherited Clone);
end;

function TFhirEvidenceReportSubjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportSubjectList.GetItemN(index: Integer): TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSubjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReportSubject;
end;
function TFhirEvidenceReportSubjectList.IndexOf(value: TFhirEvidenceReportSubject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportSubjectList.Insert(index: Integer): TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSubjectList.InsertItem(index: Integer; value: TFhirEvidenceReportSubject);
begin
  assert(value is TFhirEvidenceReportSubject);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportSubjectList.Item(index: Integer): TFhirEvidenceReportSubject;
begin
  result := TFhirEvidenceReportSubject(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSubjectList.Link: TFhirEvidenceReportSubjectList;
begin
  result := TFhirEvidenceReportSubjectList(inherited Link);
end;

procedure TFhirEvidenceReportSubjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportSubjectList.SetItemByIndex(index: Integer; value: TFhirEvidenceReportSubject);
begin
  assert(value is TFhirEvidenceReportSubject);
  FhirEvidenceReportSubjects[index] := value;
end;

procedure TFhirEvidenceReportSubjectList.SetItemN(index: Integer; value: TFhirEvidenceReportSubject);
begin
  assert(value is TFhirEvidenceReportSubject);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceReportSubjectCharacteristic }

constructor TFhirEvidenceReportSubjectCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReportSubjectCharacteristic.Destroy;
begin
  FCode.free;
  FValue.free;
  FExclude.free;
  FPeriod.free;
  inherited;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirEvidenceReportSubjectCharacteristic(oSource).code.Clone;
  value := TFhirEvidenceReportSubjectCharacteristic(oSource).value.Clone;
  excludeElement := TFhirEvidenceReportSubjectCharacteristic(oSource).excludeElement.Clone;
  period := TFhirEvidenceReportSubjectCharacteristic(oSource).period.Clone;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'Reference|CodeableConcept|boolean|Quantity|Range', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
end;

function TFhirEvidenceReportSubjectCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept', 'Boolean', 'Quantity', 'Range'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEvidenceReportSubjectCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept', 'Boolean', 'Quantity', 'Range'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'exclude') then result := TFhirBoolean.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReportSubjectCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'Reference|CodeableConcept|boolean|Quantity|Range'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'period') then result := 'Period'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept', 'Boolean', 'Quantity', 'Range'])) then ValueElement := nil
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Reference', 'CodeableConcept', 'Boolean', 'Quantity', 'Range'])) then ValueElement := new as TFhirDataType
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReportSubjectCharacteristic.fhirType : string;
begin
  result := 'EvidenceReport.subject.characteristic';
end;

function TFhirEvidenceReportSubjectCharacteristic.Link : TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic(inherited Link);
end;

function TFhirEvidenceReportSubjectCharacteristic.Clone : TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic(inherited Clone);
end;

function TFhirEvidenceReportSubjectCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReportSubjectCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReportSubjectCharacteristic)) then
    result := false
  else
  begin
    o := TFhirEvidenceReportSubjectCharacteristic(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(excludeElement, o.excludeElement, true) and compareDeep(periodElement, o.periodElement, true);
  end;
end;

function TFhirEvidenceReportSubjectCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue) and isEmptyProp(FExclude) and isEmptyProp(FPeriod);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value[x]');
  fields.add('exclude');
  fields.add('period');
end;

function TFhirEvidenceReportSubjectCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

function TFhirEvidenceReportSubjectCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;

procedure TFhirEvidenceReportSubjectCharacteristic.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

{ TFhirEvidenceReportSubjectCharacteristicListEnumerator }

constructor TFhirEvidenceReportSubjectCharacteristicListEnumerator.Create(list : TFhirEvidenceReportSubjectCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportSubjectCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportSubjectCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportSubjectCharacteristicListEnumerator.GetCurrent : TFhirEvidenceReportSubjectCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportSubjectCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportSubjectCharacteristicList }

function TFhirEvidenceReportSubjectCharacteristicList.AddItem(value: TFhirEvidenceReportSubjectCharacteristic): TFhirEvidenceReportSubjectCharacteristic;
begin
  assert(value.ClassName = 'TFhirEvidenceReportSubjectCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReportSubjectCharacteristic');
  add(value);
  result := value;
end;

function TFhirEvidenceReportSubjectCharacteristicList.Append: TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportSubjectCharacteristicList.GetEnumerator : TFhirEvidenceReportSubjectCharacteristicListEnumerator;
begin
  result := TFhirEvidenceReportSubjectCharacteristicListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Clone: TFhirEvidenceReportSubjectCharacteristicList;
begin
  result := TFhirEvidenceReportSubjectCharacteristicList(inherited Clone);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportSubjectCharacteristicList.GetItemN(index: Integer): TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSubjectCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReportSubjectCharacteristic;
end;
function TFhirEvidenceReportSubjectCharacteristicList.IndexOf(value: TFhirEvidenceReportSubjectCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Insert(index: Integer): TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.InsertItem(index: Integer; value: TFhirEvidenceReportSubjectCharacteristic);
begin
  assert(value is TFhirEvidenceReportSubjectCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Item(index: Integer): TFhirEvidenceReportSubjectCharacteristic;
begin
  result := TFhirEvidenceReportSubjectCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSubjectCharacteristicList.Link: TFhirEvidenceReportSubjectCharacteristicList;
begin
  result := TFhirEvidenceReportSubjectCharacteristicList(inherited Link);
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.SetItemByIndex(index: Integer; value: TFhirEvidenceReportSubjectCharacteristic);
begin
  assert(value is TFhirEvidenceReportSubjectCharacteristic);
  FhirEvidenceReportSubjectCharacteristics[index] := value;
end;

procedure TFhirEvidenceReportSubjectCharacteristicList.SetItemN(index: Integer; value: TFhirEvidenceReportSubjectCharacteristic);
begin
  assert(value is TFhirEvidenceReportSubjectCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceReportRelatesTo }

constructor TFhirEvidenceReportRelatesTo.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReportRelatesTo.Destroy;
begin
  FCode.free;
  FTarget.free;
  inherited;
end;

procedure TFhirEvidenceReportRelatesTo.Assign(oSource : TFslObject);
begin
  inherited;
  codeElement := TFhirEvidenceReportRelatesTo(oSource).codeElement.Clone;
  target := TFhirEvidenceReportRelatesTo(oSource).target.Clone;
end;

procedure TFhirEvidenceReportRelatesTo.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'target[x]') or (child_name = 'target') Then
     list.add(self.link, 'target[x]', FTarget.Link);
end;

procedure TFhirEvidenceReportRelatesTo.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'target[x]', 'Identifier|Reference', false, TFhirDataType, FTarget.Link));
end;

function TFhirEvidenceReportRelatesTo.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirReportRelationshipTypeEnum, CODES_TFhirReportRelationshipTypeEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then
  begin
    Target := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReportRelatesTo.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEvidenceReportRelatesTo.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirReportRelationshipTypeEnum[ReportRelationshipTypeNull], CODES_TFhirReportRelationshipTypeEnum[ReportRelationshipTypeNull]) 
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then raise EFHIRException.create('Cannot make property Target')
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReportRelatesTo.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'code'
  else if (propName = 'target[x]') then result := 'Identifier|Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReportRelatesTo.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then TargetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReportRelatesTo.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirReportRelationshipTypeEnum, CODES_TFhirReportRelationshipTypeEnum, new)
  else if (isMatchingName(propName, 'target', ['Identifier', 'Reference'])) then TargetElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReportRelatesTo.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReportRelatesTo.fhirType : string;
begin
  result := 'EvidenceReport.relatesTo';
end;

function TFhirEvidenceReportRelatesTo.Link : TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo(inherited Link);
end;

function TFhirEvidenceReportRelatesTo.Clone : TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo(inherited Clone);
end;

function TFhirEvidenceReportRelatesTo.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReportRelatesTo;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReportRelatesTo)) then
    result := false
  else
  begin
    o := TFhirEvidenceReportRelatesTo(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(targetElement, o.targetElement, true);
  end;
end;

function TFhirEvidenceReportRelatesTo.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FTarget);
end;

procedure TFhirEvidenceReportRelatesTo.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('target[x]');
end;

function TFhirEvidenceReportRelatesTo.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEvidenceReportRelatesTo.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirEvidenceReportRelatesTo.GetCodeST : TFhirReportRelationshipTypeEnum;
begin
  if FCode = nil then
    result := TFhirReportRelationshipTypeEnum(0)
  else
    result := TFhirReportRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirReportRelationshipTypeEnum, FCode.value));
end;

procedure TFhirEvidenceReportRelatesTo.SetCodeST(value : TFhirReportRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirReportRelationshipTypeEnum[value], CODES_TFhirReportRelationshipTypeEnum[value]);
end;

procedure TFhirEvidenceReportRelatesTo.SetTarget(value : TFhirDataType);
begin
  FTarget.free;
  FTarget := value;
end;

{ TFhirEvidenceReportRelatesToListEnumerator }

constructor TFhirEvidenceReportRelatesToListEnumerator.Create(list : TFhirEvidenceReportRelatesToList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportRelatesToListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportRelatesToListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportRelatesToListEnumerator.GetCurrent : TFhirEvidenceReportRelatesTo;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportRelatesToListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportRelatesToList }

function TFhirEvidenceReportRelatesToList.AddItem(value: TFhirEvidenceReportRelatesTo): TFhirEvidenceReportRelatesTo;
begin
  assert(value.ClassName = 'TFhirEvidenceReportRelatesTo', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReportRelatesTo');
  add(value);
  result := value;
end;

function TFhirEvidenceReportRelatesToList.Append: TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportRelatesToList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportRelatesToList.GetEnumerator : TFhirEvidenceReportRelatesToListEnumerator;
begin
  result := TFhirEvidenceReportRelatesToListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportRelatesToList.Clone: TFhirEvidenceReportRelatesToList;
begin
  result := TFhirEvidenceReportRelatesToList(inherited Clone);
end;

function TFhirEvidenceReportRelatesToList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportRelatesToList.GetItemN(index: Integer): TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo(ObjectByIndex[index]);
end;

function TFhirEvidenceReportRelatesToList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReportRelatesTo;
end;
function TFhirEvidenceReportRelatesToList.IndexOf(value: TFhirEvidenceReportRelatesTo): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportRelatesToList.Insert(index: Integer): TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportRelatesToList.InsertItem(index: Integer; value: TFhirEvidenceReportRelatesTo);
begin
  assert(value is TFhirEvidenceReportRelatesTo);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportRelatesToList.Item(index: Integer): TFhirEvidenceReportRelatesTo;
begin
  result := TFhirEvidenceReportRelatesTo(ObjectByIndex[index]);
end;

function TFhirEvidenceReportRelatesToList.Link: TFhirEvidenceReportRelatesToList;
begin
  result := TFhirEvidenceReportRelatesToList(inherited Link);
end;

procedure TFhirEvidenceReportRelatesToList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportRelatesToList.SetItemByIndex(index: Integer; value: TFhirEvidenceReportRelatesTo);
begin
  assert(value is TFhirEvidenceReportRelatesTo);
  FhirEvidenceReportRelatesTos[index] := value;
end;

procedure TFhirEvidenceReportRelatesToList.SetItemN(index: Integer; value: TFhirEvidenceReportRelatesTo);
begin
  assert(value is TFhirEvidenceReportRelatesTo);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceReportSection }

constructor TFhirEvidenceReportSection.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReportSection.Destroy;
begin
  FTitle.free;
  FFocus.free;
  FFocusReference.free;
  FAuthorList.Free;
  FText.free;
  FMode.free;
  FOrderedBy.free;
  FEntryClassifierList.Free;
  FEntryReferenceList.Free;
  FEntryQuantityList.Free;
  FEmptyReason.free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirEvidenceReportSection.Assign(oSource : TFslObject);
begin
  inherited;
  titleElement := TFhirEvidenceReportSection(oSource).titleElement.Clone;
  focus := TFhirEvidenceReportSection(oSource).focus.Clone;
  focusReference := TFhirEvidenceReportSection(oSource).focusReference.Clone;
  if (TFhirEvidenceReportSection(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirReferenceList.Create;
    FAuthorList.Assign(TFhirEvidenceReportSection(oSource).FAuthorList);
  end;
  text := TFhirEvidenceReportSection(oSource).text.Clone;
  modeElement := TFhirEvidenceReportSection(oSource).modeElement.Clone;
  orderedBy := TFhirEvidenceReportSection(oSource).orderedBy.Clone;
  if (TFhirEvidenceReportSection(oSource).FEntryClassifierList = nil) then
  begin
    FEntryClassifierList.free;
    FEntryClassifierList := nil;
  end
  else
  begin
    if FEntryClassifierList = nil then
      FEntryClassifierList := TFhirCodeableConceptList.Create;
    FEntryClassifierList.Assign(TFhirEvidenceReportSection(oSource).FEntryClassifierList);
  end;
  if (TFhirEvidenceReportSection(oSource).FEntryReferenceList = nil) then
  begin
    FEntryReferenceList.free;
    FEntryReferenceList := nil;
  end
  else
  begin
    if FEntryReferenceList = nil then
      FEntryReferenceList := TFhirReferenceList.Create;
    FEntryReferenceList.Assign(TFhirEvidenceReportSection(oSource).FEntryReferenceList);
  end;
  if (TFhirEvidenceReportSection(oSource).FEntryQuantityList = nil) then
  begin
    FEntryQuantityList.free;
    FEntryQuantityList := nil;
  end
  else
  begin
    if FEntryQuantityList = nil then
      FEntryQuantityList := TFhirQuantityList.Create;
    FEntryQuantityList.Assign(TFhirEvidenceReportSection(oSource).FEntryQuantityList);
  end;
  emptyReason := TFhirEvidenceReportSection(oSource).emptyReason.Clone;
  if (TFhirEvidenceReportSection(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirEvidenceReportSectionList.Create;
    FSectionList.Assign(TFhirEvidenceReportSection(oSource).FSectionList);
  end;
end;

procedure TFhirEvidenceReportSection.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'focusReference') Then
     list.add(self.link, 'focusReference', FFocusReference.Link);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'entryClassifier') Then
    list.addAll(self, 'entryClassifier', FEntryClassifierList);
  if (child_name = 'entryReference') Then
    list.addAll(self, 'entryReference', FEntryReferenceList);
  if (child_name = 'entryQuantity') Then
    list.addAll(self, 'entryQuantity', FEntryQuantityList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirEvidenceReportSection.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'CodeableConcept', false, TFhirCodeableConcept, FFocus.Link));
  oList.add(TFHIRProperty.create(self, 'focusReference', 'Reference', false, TFhirReference, FFocusReference.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', true, TFhirReference, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'Narrative', false, TFhirNarrative, FText.Link));
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));
  oList.add(TFHIRProperty.create(self, 'entryClassifier', 'CodeableConcept', true, TFhirCodeableConcept, FEntryClassifierList.Link));
  oList.add(TFHIRProperty.create(self, 'entryReference', 'Reference', true, TFhirReference, FEntryReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'entryQuantity', 'Quantity', true, TFhirQuantity, FEntryQuantityList.Link));
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));
  oList.add(TFHIRProperty.create(self, 'section', '', true, TFhirEvidenceReportSection, FSectionList.Link));
end;

function TFhirEvidenceReportSection.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'focusReference') then
  begin
    FocusReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    Text := propValue as TFhirNarrative;
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'entryClassifier') then
  begin
    EntryClassifierList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'entryReference') then
  begin
    EntryReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'entryQuantity') then
  begin
    EntryQuantityList.add(propValue as TFhirQuantity);
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirEvidenceReportSection);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReportSection.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'entryClassifier') then EntryClassifierList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'entryReference') then EntryReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'entryQuantity') then EntryQuantityList.insertItem(index, propValue as TFhirQuantity)
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirEvidenceReportSection)
  else inherited;
end;

function TFhirEvidenceReportSection.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'focus') then result := TFhirCodeableConcept.create()
  else if (propName = 'focusReference') then result := TFhirReference.create()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'text') then result := TFhirNarrative.create()
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[ListModeNull], CODES_TFhirListModeEnum[ListModeNull]) 
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create()
  else if (propName = 'entryClassifier') then result := EntryClassifierList.new()
  else if (propName = 'entryReference') then result := EntryReferenceList.new()
  else if (propName = 'entryQuantity') then result := EntryQuantityList.new()
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'section') then result := SectionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReportSection.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'title') then result := 'string'
  else if (propName = 'focus') then result := 'CodeableConcept'
  else if (propName = 'focusReference') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'text') then result := 'Narrative'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'entryClassifier') then result := 'CodeableConcept'
  else if (propName = 'entryReference') then result := 'Reference'
  else if (propName = 'entryQuantity') then result := 'Quantity'
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else if (propName = 'section') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReportSection.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'focusReference') then FocusReferenceElement := nil
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'entryClassifier') then deletePropertyValue('entryClassifier', EntryClassifierList, value)
  else if (propName = 'entryReference') then deletePropertyValue('entryReference', EntryReferenceList, value)
  else if (propName = 'entryQuantity') then deletePropertyValue('entryQuantity', EntryQuantityList, value)
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReportSection.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'focus') then FocusElement := new as TFhirCodeableConcept
  else if (propName = 'focusReference') then FocusReferenceElement := new as TFhirReference
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'text') then TextElement := new as TFhirNarrative
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new)
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept
  else if (propName = 'entryClassifier') then replacePropertyValue('entryClassifier', EntryClassifierList, existing, new)
  else if (propName = 'entryReference') then replacePropertyValue('entryReference', EntryReferenceList, existing, new)
  else if (propName = 'entryQuantity') then replacePropertyValue('entryQuantity', EntryQuantityList, existing, new)
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReportSection.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'entryClassifier') then EntryClassifierList.move(source, destination)
  else if (propName = 'entryReference') then EntryReferenceList.move(source, destination)
  else if (propName = 'entryQuantity') then EntryQuantityList.move(source, destination)
  else if (propName = 'section') then SectionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReportSection.fhirType : string;
begin
  result := 'EvidenceReport.section';
end;

function TFhirEvidenceReportSection.Link : TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection(inherited Link);
end;

function TFhirEvidenceReportSection.Clone : TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection(inherited Clone);
end;

function TFhirEvidenceReportSection.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReportSection;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReportSection)) then
    result := false
  else
  begin
    o := TFhirEvidenceReportSection(other);
    result := compareDeep(titleElement, o.titleElement, true) and compareDeep(focusElement, o.focusElement, true) and 
      compareDeep(focusReferenceElement, o.focusReferenceElement, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(modeElement, o.modeElement, true) and 
      compareDeep(orderedByElement, o.orderedByElement, true) and compareDeep(entryClassifierList, o.entryClassifierList, true) and 
      compareDeep(entryReferenceList, o.entryReferenceList, true) and compareDeep(entryQuantityList, o.entryQuantityList, true) and 
      compareDeep(emptyReasonElement, o.emptyReasonElement, true) and compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirEvidenceReportSection.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FTitle) and isEmptyProp(FFocus) and isEmptyProp(FFocusReference) and isEmptyProp(FauthorList) and isEmptyProp(FText) and isEmptyProp(FMode) and isEmptyProp(FOrderedBy) and isEmptyProp(FentryClassifierList) and isEmptyProp(FentryReferenceList) and isEmptyProp(FentryQuantityList) and isEmptyProp(FEmptyReason) and isEmptyProp(FsectionList);
end;

procedure TFhirEvidenceReportSection.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('title');
  fields.add('focus');
  fields.add('focusReference');
  fields.add('author');
  fields.add('text');
  fields.add('mode');
  fields.add('orderedBy');
  fields.add('entryClassifier');
  fields.add('entryReference');
  fields.add('entryQuantity');
  fields.add('emptyReason');
  fields.add('section');
end;

function TFhirEvidenceReportSection.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEntryClassifierList.sizeInBytes(magic));
  inc(result, FEntryReferenceList.sizeInBytes(magic));
  inc(result, FEntryQuantityList.sizeInBytes(magic));
  inc(result, FSectionList.sizeInBytes(magic));
end;

procedure TFhirEvidenceReportSection.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirEvidenceReportSection.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirEvidenceReportSection.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirEvidenceReportSection.SetFocus(value : TFhirCodeableConcept);
begin
  FFocus.free;
  FFocus := value;
end;

procedure TFhirEvidenceReportSection.SetFocusReference(value : TFhirReference);
begin
  FFocusReference.free;
  FFocusReference := value;
end;

function TFhirEvidenceReportSection.GetAuthorList : TFhirReferenceList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirReferenceList.Create;
  result := FAuthorList;
end;

function TFhirEvidenceReportSection.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

procedure TFhirEvidenceReportSection.SetText(value : TFhirNarrative);
begin
  FText.free;
  FText := value;
end;

procedure TFhirEvidenceReportSection.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirEvidenceReportSection.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

procedure TFhirEvidenceReportSection.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

procedure TFhirEvidenceReportSection.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

function TFhirEvidenceReportSection.GetEntryClassifierList : TFhirCodeableConceptList;
begin
  if FEntryClassifierList = nil then
    FEntryClassifierList := TFhirCodeableConceptList.Create;
  result := FEntryClassifierList;
end;

function TFhirEvidenceReportSection.GetHasEntryClassifierList : boolean;
begin
  result := (FEntryClassifierList <> nil) and (FEntryClassifierList.count > 0);
end;

function TFhirEvidenceReportSection.GetEntryReferenceList : TFhirReferenceList;
begin
  if FEntryReferenceList = nil then
    FEntryReferenceList := TFhirReferenceList.Create;
  result := FEntryReferenceList;
end;

function TFhirEvidenceReportSection.GetHasEntryReferenceList : boolean;
begin
  result := (FEntryReferenceList <> nil) and (FEntryReferenceList.count > 0);
end;

function TFhirEvidenceReportSection.GetEntryQuantityList : TFhirQuantityList;
begin
  if FEntryQuantityList = nil then
    FEntryQuantityList := TFhirQuantityList.Create;
  result := FEntryQuantityList;
end;

function TFhirEvidenceReportSection.GetHasEntryQuantityList : boolean;
begin
  result := (FEntryQuantityList <> nil) and (FEntryQuantityList.count > 0);
end;

procedure TFhirEvidenceReportSection.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

function TFhirEvidenceReportSection.GetSectionList : TFhirEvidenceReportSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirEvidenceReportSectionList.Create;
  result := FSectionList;
end;

function TFhirEvidenceReportSection.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

{ TFhirEvidenceReportSectionListEnumerator }

constructor TFhirEvidenceReportSectionListEnumerator.Create(list : TFhirEvidenceReportSectionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportSectionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportSectionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportSectionListEnumerator.GetCurrent : TFhirEvidenceReportSection;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportSectionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportSectionList }

function TFhirEvidenceReportSectionList.AddItem(value: TFhirEvidenceReportSection): TFhirEvidenceReportSection;
begin
  assert(value.ClassName = 'TFhirEvidenceReportSection', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReportSection');
  add(value);
  result := value;
end;

function TFhirEvidenceReportSectionList.Append: TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSectionList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportSectionList.GetEnumerator : TFhirEvidenceReportSectionListEnumerator;
begin
  result := TFhirEvidenceReportSectionListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportSectionList.Clone: TFhirEvidenceReportSectionList;
begin
  result := TFhirEvidenceReportSectionList(inherited Clone);
end;

function TFhirEvidenceReportSectionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportSectionList.GetItemN(index: Integer): TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSectionList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReportSection;
end;
function TFhirEvidenceReportSectionList.IndexOf(value: TFhirEvidenceReportSection): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportSectionList.Insert(index: Integer): TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportSectionList.InsertItem(index: Integer; value: TFhirEvidenceReportSection);
begin
  assert(value is TFhirEvidenceReportSection);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportSectionList.Item(index: Integer): TFhirEvidenceReportSection;
begin
  result := TFhirEvidenceReportSection(ObjectByIndex[index]);
end;

function TFhirEvidenceReportSectionList.Link: TFhirEvidenceReportSectionList;
begin
  result := TFhirEvidenceReportSectionList(inherited Link);
end;

procedure TFhirEvidenceReportSectionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportSectionList.SetItemByIndex(index: Integer; value: TFhirEvidenceReportSection);
begin
  assert(value is TFhirEvidenceReportSection);
  FhirEvidenceReportSections[index] := value;
end;

procedure TFhirEvidenceReportSectionList.SetItemN(index: Integer; value: TFhirEvidenceReportSection);
begin
  assert(value is TFhirEvidenceReportSection);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceReport }

constructor TFhirEvidenceReport.Create;
begin
  inherited;
end;

destructor TFhirEvidenceReport.Destroy;
begin
  FUrl.free;
  FStatus.free;
  FUseContextList.Free;
  FIdentifierList.Free;
  FRelatedIdentifierList.Free;
  FCiteAs.free;
  FType_.free;
  FNoteList.Free;
  FRelatedArtifactList.Free;
  FSubject.free;
  FPublisher.free;
  FContactList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatesToList.Free;
  FSectionList.Free;
  inherited;
end;

procedure TFhirEvidenceReport.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirEvidenceReport(oSource).urlElement.Clone;
  statusElement := TFhirEvidenceReport(oSource).statusElement.Clone;
  if (TFhirEvidenceReport(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirEvidenceReport(oSource).FUseContextList);
  end;
  if (TFhirEvidenceReport(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEvidenceReport(oSource).FIdentifierList);
  end;
  if (TFhirEvidenceReport(oSource).FRelatedIdentifierList = nil) then
  begin
    FRelatedIdentifierList.free;
    FRelatedIdentifierList := nil;
  end
  else
  begin
    if FRelatedIdentifierList = nil then
      FRelatedIdentifierList := TFhirIdentifierList.Create;
    FRelatedIdentifierList.Assign(TFhirEvidenceReport(oSource).FRelatedIdentifierList);
  end;
  citeAs := TFhirEvidenceReport(oSource).citeAs.Clone;
  type_ := TFhirEvidenceReport(oSource).type_.Clone;
  if (TFhirEvidenceReport(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceReport(oSource).FNoteList);
  end;
  if (TFhirEvidenceReport(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirEvidenceReport(oSource).FRelatedArtifactList);
  end;
  subject := TFhirEvidenceReport(oSource).subject.Clone;
  publisherElement := TFhirEvidenceReport(oSource).publisherElement.Clone;
  if (TFhirEvidenceReport(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirEvidenceReport(oSource).FContactList);
  end;
  if (TFhirEvidenceReport(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirEvidenceReport(oSource).FAuthorList);
  end;
  if (TFhirEvidenceReport(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirEvidenceReport(oSource).FEditorList);
  end;
  if (TFhirEvidenceReport(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirEvidenceReport(oSource).FReviewerList);
  end;
  if (TFhirEvidenceReport(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirEvidenceReport(oSource).FEndorserList);
  end;
  if (TFhirEvidenceReport(oSource).FRelatesToList = nil) then
  begin
    FRelatesToList.free;
    FRelatesToList := nil;
  end
  else
  begin
    if FRelatesToList = nil then
      FRelatesToList := TFhirEvidenceReportRelatesToList.Create;
    FRelatesToList.Assign(TFhirEvidenceReport(oSource).FRelatesToList);
  end;
  if (TFhirEvidenceReport(oSource).FSectionList = nil) then
  begin
    FSectionList.free;
    FSectionList := nil;
  end
  else
  begin
    if FSectionList = nil then
      FSectionList := TFhirEvidenceReportSectionList.Create;
    FSectionList.Assign(TFhirEvidenceReport(oSource).FSectionList);
  end;
end;

function TFhirEvidenceReport.GetResourceType : TFhirResourceType;
begin
  result := frtEvidenceReport;
end;

procedure TFhirEvidenceReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'relatedIdentifier') Then
    list.addAll(self, 'relatedIdentifier', FRelatedIdentifierList);
  if (child_name = 'citeAs[x]') or (child_name = 'citeAs') Then
     list.add(self.link, 'citeAs[x]', FCiteAs.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatesTo') Then
    list.addAll(self, 'relatesTo', FRelatesToList);
  if (child_name = 'section') Then
    list.addAll(self, 'section', FSectionList);
end;

procedure TFhirEvidenceReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedIdentifier', 'Identifier', true, TFhirIdentifier, FRelatedIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'citeAs[x]', 'Reference|markdown', false, TFhirDataType, FCiteAs.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'BackboneElement', false, TFhirEvidenceReportSubject, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatesTo', 'BackboneElement', true, TFhirEvidenceReportRelatesTo, FRelatesToList.Link));
  oList.add(TFHIRProperty.create(self, 'section', 'BackboneElement', true, TFhirEvidenceReportSection, FSectionList.Link));
end;

function TFhirEvidenceReport.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'relatedIdentifier') then
  begin
    RelatedIdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then
  begin
    CiteAs := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirEvidenceReportSubject;
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatesTo') then
  begin
    RelatesToList.add(propValue as TFhirEvidenceReportRelatesTo);
    result := propValue;
  end
  else if (propName = 'section') then
  begin
    SectionList.add(propValue as TFhirEvidenceReportSection);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'relatedIdentifier') then RelatedIdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatesTo') then RelatesToList.insertItem(index, propValue as TFhirEvidenceReportRelatesTo)
  else if (propName = 'section') then SectionList.insertItem(index, propValue as TFhirEvidenceReportSection)
  else inherited;
end;

function TFhirEvidenceReport.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'relatedIdentifier') then result := RelatedIdentifierList.new()
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then raise EFHIRException.create('Cannot make property CiteAs')
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'subject') then result := TFhirEvidenceReportSubject.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatesTo') then result := RelatesToList.new()
  else if (propName = 'section') then result := SectionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'relatedIdentifier') then result := 'Identifier'
  else if (propName = 'citeAs[x]') then result := 'Reference|markdown'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'subject') then result := 'BackboneElement'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatesTo') then result := 'BackboneElement'
  else if (propName = 'section') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceReport.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'relatedIdentifier') then deletePropertyValue('relatedIdentifier', RelatedIdentifierList, value)
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatesTo') then deletePropertyValue('relatesTo', RelatesToList, value)
  else if (propName = 'section') then deletePropertyValue('section', SectionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'relatedIdentifier') then replacePropertyValue('relatedIdentifier', RelatedIdentifierList, existing, new)
  else if (isMatchingName(propName, 'citeAs', ['Reference', 'Markdown'])) then CiteAsElement := new as TFhirDataType
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirEvidenceReportSubject
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatesTo') then replacePropertyValue('relatesTo', RelatesToList, existing, new)
  else if (propName = 'section') then replacePropertyValue('section', SectionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'relatedIdentifier') then RelatedIdentifierList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatesTo') then RelatesToList.move(source, destination)
  else if (propName = 'section') then SectionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceReport.fhirType : string;
begin
  result := 'EvidenceReport';
end;

function TFhirEvidenceReport.Link : TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport(inherited Link);
end;

function TFhirEvidenceReport.Clone : TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport(inherited Clone);
end;

function TFhirEvidenceReport.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceReport)) then
    result := false
  else
  begin
    o := TFhirEvidenceReport(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(relatedIdentifierList, o.relatedIdentifierList, true) and compareDeep(citeAsElement, o.citeAsElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatesToList, o.relatesToList, true) and compareDeep(sectionList, o.sectionList, true);
  end;
end;

function TFhirEvidenceReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FStatus) and isEmptyProp(FuseContextList) and isEmptyProp(FidentifierList) and isEmptyProp(FrelatedIdentifierList) and isEmptyProp(FCiteAs) and isEmptyProp(FType_) and isEmptyProp(FnoteList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FSubject) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatesToList) and isEmptyProp(FsectionList);
end;

procedure TFhirEvidenceReport.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('status');
  fields.add('useContext');
  fields.add('identifier');
  fields.add('relatedIdentifier');
  fields.add('citeAs[x]');
  fields.add('type');
  fields.add('note');
  fields.add('relatedArtifact');
  fields.add('subject');
  fields.add('publisher');
  fields.add('contact');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatesTo');
  fields.add('section');
end;

function TFhirEvidenceReport.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FRelatedIdentifierList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatesToList.sizeInBytes(magic));
  inc(result, FSectionList.sizeInBytes(magic));
end;

procedure TFhirEvidenceReport.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirEvidenceReport.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirEvidenceReport.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

procedure TFhirEvidenceReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEvidenceReport.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirEvidenceReport.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

function TFhirEvidenceReport.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirEvidenceReport.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirEvidenceReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEvidenceReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirEvidenceReport.GetRelatedIdentifierList : TFhirIdentifierList;
begin
  if FRelatedIdentifierList = nil then
    FRelatedIdentifierList := TFhirIdentifierList.Create;
  result := FRelatedIdentifierList;
end;

function TFhirEvidenceReport.GetHasRelatedIdentifierList : boolean;
begin
  result := (FRelatedIdentifierList <> nil) and (FRelatedIdentifierList.count > 0);
end;

procedure TFhirEvidenceReport.SetCiteAs(value : TFhirDataType);
begin
  FCiteAs.free;
  FCiteAs := value;
end;

procedure TFhirEvidenceReport.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirEvidenceReport.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceReport.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirEvidenceReport.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirEvidenceReport.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

procedure TFhirEvidenceReport.SetSubject(value : TFhirEvidenceReportSubject);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirEvidenceReport.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirEvidenceReport.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirEvidenceReport.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirEvidenceReport.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirEvidenceReport.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirEvidenceReport.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirEvidenceReport.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirEvidenceReport.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirEvidenceReport.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirEvidenceReport.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirEvidenceReport.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirEvidenceReport.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirEvidenceReport.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirEvidenceReport.GetRelatesToList : TFhirEvidenceReportRelatesToList;
begin
  if FRelatesToList = nil then
    FRelatesToList := TFhirEvidenceReportRelatesToList.Create;
  result := FRelatesToList;
end;

function TFhirEvidenceReport.GetHasRelatesToList : boolean;
begin
  result := (FRelatesToList <> nil) and (FRelatesToList.count > 0);
end;

function TFhirEvidenceReport.GetSectionList : TFhirEvidenceReportSectionList;
begin
  if FSectionList = nil then
    FSectionList := TFhirEvidenceReportSectionList.Create;
  result := FSectionList;
end;

function TFhirEvidenceReport.GetHasSectionList : boolean;
begin
  result := (FSectionList <> nil) and (FSectionList.count > 0);
end;

{ TFhirEvidenceReportListEnumerator }

constructor TFhirEvidenceReportListEnumerator.Create(list : TFhirEvidenceReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceReportListEnumerator.GetCurrent : TFhirEvidenceReport;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceReportListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceReportList }

function TFhirEvidenceReportList.AddItem(value: TFhirEvidenceReport): TFhirEvidenceReport;
begin
  assert(value.ClassName = 'TFhirEvidenceReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceReport');
  add(value);
  result := value;
end;

function TFhirEvidenceReportList.Append: TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceReportList.GetEnumerator : TFhirEvidenceReportListEnumerator;
begin
  result := TFhirEvidenceReportListEnumerator.Create(self.link);
end;

function TFhirEvidenceReportList.Clone: TFhirEvidenceReportList;
begin
  result := TFhirEvidenceReportList(inherited Clone);
end;

function TFhirEvidenceReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceReportList.GetItemN(index: Integer): TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport(ObjectByIndex[index]);
end;

function TFhirEvidenceReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceReport;
end;
function TFhirEvidenceReportList.IndexOf(value: TFhirEvidenceReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceReportList.Insert(index: Integer): TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceReportList.InsertItem(index: Integer; value: TFhirEvidenceReport);
begin
  assert(value is TFhirEvidenceReport);
  Inherited Insert(index, value);
end;

function TFhirEvidenceReportList.Item(index: Integer): TFhirEvidenceReport;
begin
  result := TFhirEvidenceReport(ObjectByIndex[index]);
end;

function TFhirEvidenceReportList.Link: TFhirEvidenceReportList;
begin
  result := TFhirEvidenceReportList(inherited Link);
end;

procedure TFhirEvidenceReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceReportList.SetItemByIndex(index: Integer; value: TFhirEvidenceReport);
begin
  assert(value is TFhirEvidenceReport);
  FhirEvidenceReports[index] := value;
end;

procedure TFhirEvidenceReportList.SetItemN(index: Integer; value: TFhirEvidenceReport);
begin
  assert(value is TFhirEvidenceReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EVIDENCEREPORT}
{$IFDEF FHIR_EVIDENCEVARIABLE}
{ TFhirEvidenceVariableCharacteristic }

constructor TFhirEvidenceVariableCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableCharacteristic.Destroy;
begin
  FDescription.free;
  FDefinition.free;
  FMethod.free;
  FDevice.free;
  FExclude.free;
  FTimeFromStart.free;
  FGroupMeasure.free;
  inherited;
end;

procedure TFhirEvidenceVariableCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceVariableCharacteristic(oSource).descriptionElement.Clone;
  definition := TFhirEvidenceVariableCharacteristic(oSource).definition.Clone;
  method := TFhirEvidenceVariableCharacteristic(oSource).method.Clone;
  device := TFhirEvidenceVariableCharacteristic(oSource).device.Clone;
  excludeElement := TFhirEvidenceVariableCharacteristic(oSource).excludeElement.Clone;
  timeFromStart := TFhirEvidenceVariableCharacteristic(oSource).timeFromStart.Clone;
  groupMeasureElement := TFhirEvidenceVariableCharacteristic(oSource).groupMeasureElement.Clone;
end;

procedure TFhirEvidenceVariableCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'definition[x]') or (child_name = 'definition') Then
     list.add(self.link, 'definition[x]', FDefinition.Link);
  if (child_name = 'method') Then
     list.add(self.link, 'method', FMethod.Link);
  if (child_name = 'device') Then
     list.add(self.link, 'device', FDevice.Link);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'timeFromStart') Then
     list.add(self.link, 'timeFromStart', FTimeFromStart.Link);
  if (child_name = 'groupMeasure') Then
     list.add(self.link, 'groupMeasure', FGroupMeasure.Link);
end;

procedure TFhirEvidenceVariableCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'definition[x]', 'Reference|canonical|CodeableConcept|Expression', false, TFhirDataType, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'method', 'CodeableConcept', false, TFhirCodeableConcept, FMethod.Link));
  oList.add(TFHIRProperty.create(self, 'device', 'Reference', false, TFhirReference, FDevice.Link));
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));
  oList.add(TFHIRProperty.create(self, 'timeFromStart', 'BackboneElement', false, TFhirEvidenceVariableCharacteristicTimeFromStart, FTimeFromStart.Link));
  oList.add(TFHIRProperty.create(self, 'groupMeasure', 'code', false, TFhirEnum, FGroupMeasure.Link));
end;

function TFhirEvidenceVariableCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'definition', ['Reference', 'Canonical', 'CodeableConcept', 'Expression'])) then
  begin
    Definition := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'method') then
  begin
    Method := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'device') then
  begin
    Device := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'timeFromStart') then
  begin
    TimeFromStart := propValue as TFhirEvidenceVariableCharacteristicTimeFromStart;
    result := propValue;
  end
  else if (propName = 'groupMeasure') then
  begin
    GroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEvidenceVariableCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (isMatchingName(propName, 'definition', ['Reference', 'Canonical', 'CodeableConcept', 'Expression'])) then raise EFHIRException.create('Cannot make property Definition')
  else if (propName = 'method') then result := TFhirCodeableConcept.create()
  else if (propName = 'device') then result := TFhirReference.create()
  else if (propName = 'exclude') then result := TFhirBoolean.create()
  else if (propName = 'timeFromStart') then result := TFhirEvidenceVariableCharacteristicTimeFromStart.create()
  else if (propName = 'groupMeasure') then result := TFhirEnum.create(SYSTEMS_TFhirGroupMeasureEnum[GroupMeasureNull], CODES_TFhirGroupMeasureEnum[GroupMeasureNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'definition[x]') then result := 'Reference|canonical|CodeableConcept|Expression'
  else if (propName = 'method') then result := 'CodeableConcept'
  else if (propName = 'device') then result := 'Reference'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'timeFromStart') then result := 'BackboneElement'
  else if (propName = 'groupMeasure') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (isMatchingName(propName, 'definition', ['Reference', 'Canonical', 'CodeableConcept', 'Expression'])) then DefinitionElement := nil
  else if (propName = 'method') then MethodElement := nil
  else if (propName = 'device') then DeviceElement := nil
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'timeFromStart') then TimeFromStartElement := nil
  else if (propName = 'groupMeasure') then GroupMeasureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (isMatchingName(propName, 'definition', ['Reference', 'Canonical', 'CodeableConcept', 'Expression'])) then DefinitionElement := new as TFhirDataType
  else if (propName = 'method') then MethodElement := new as TFhirCodeableConcept
  else if (propName = 'device') then DeviceElement := new as TFhirReference
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new)
  else if (propName = 'timeFromStart') then TimeFromStartElement := new as TFhirEvidenceVariableCharacteristicTimeFromStart
  else if (propName = 'groupMeasure') then GroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableCharacteristic.fhirType : string;
begin
  result := 'EvidenceVariable.characteristic';
end;

function TFhirEvidenceVariableCharacteristic.Link : TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(inherited Link);
end;

function TFhirEvidenceVariableCharacteristic.Clone : TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableCharacteristic)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableCharacteristic(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(methodElement, o.methodElement, true) and compareDeep(deviceElement, o.deviceElement, true) and 
      compareDeep(excludeElement, o.excludeElement, true) and compareDeep(timeFromStartElement, o.timeFromStartElement, true) and 
      compareDeep(groupMeasureElement, o.groupMeasureElement, true);
  end;
end;

function TFhirEvidenceVariableCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FDefinition) and isEmptyProp(FMethod) and isEmptyProp(FDevice) and isEmptyProp(FExclude) and isEmptyProp(FTimeFromStart) and isEmptyProp(FGroupMeasure);
end;

procedure TFhirEvidenceVariableCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('definition[x]');
  fields.add('method');
  fields.add('device');
  fields.add('exclude');
  fields.add('timeFromStart');
  fields.add('groupMeasure');
end;

function TFhirEvidenceVariableCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEvidenceVariableCharacteristic.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceVariableCharacteristic.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirEvidenceVariableCharacteristic.SetDefinition(value : TFhirDataType);
begin
  FDefinition.free;
  FDefinition := value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetMethod(value : TFhirCodeableConcept);
begin
  FMethod.free;
  FMethod := value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetDevice(value : TFhirReference);
begin
  FDevice.free;
  FDevice := value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

function TFhirEvidenceVariableCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;

procedure TFhirEvidenceVariableCharacteristic.SetTimeFromStart(value : TFhirEvidenceVariableCharacteristicTimeFromStart);
begin
  FTimeFromStart.free;
  FTimeFromStart := value;
end;

procedure TFhirEvidenceVariableCharacteristic.SetGroupMeasure(value : TFhirEnum);
begin
  FGroupMeasure.free;
  FGroupMeasure := value;
end;

function TFhirEvidenceVariableCharacteristic.GetGroupMeasureST : TFhirGroupMeasureEnum;
begin
  if FGroupMeasure = nil then
    result := TFhirGroupMeasureEnum(0)
  else
    result := TFhirGroupMeasureEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupMeasureEnum, FGroupMeasure.value));
end;

procedure TFhirEvidenceVariableCharacteristic.SetGroupMeasureST(value : TFhirGroupMeasureEnum);
begin
  if ord(value) = 0 then
    GroupMeasureElement := nil
  else
    GroupMeasureElement := TFhirEnum.create(SYSTEMS_TFhirGroupMeasureEnum[value], CODES_TFhirGroupMeasureEnum[value]);
end;

{ TFhirEvidenceVariableCharacteristicListEnumerator }

constructor TFhirEvidenceVariableCharacteristicListEnumerator.Create(list : TFhirEvidenceVariableCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableCharacteristicListEnumerator.GetCurrent : TFhirEvidenceVariableCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableCharacteristicList }

function TFhirEvidenceVariableCharacteristicList.AddItem(value: TFhirEvidenceVariableCharacteristic): TFhirEvidenceVariableCharacteristic;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableCharacteristic');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableCharacteristicList.Append: TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableCharacteristicList.GetEnumerator : TFhirEvidenceVariableCharacteristicListEnumerator;
begin
  result := TFhirEvidenceVariableCharacteristicListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableCharacteristicList.Clone: TFhirEvidenceVariableCharacteristicList;
begin
  result := TFhirEvidenceVariableCharacteristicList(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableCharacteristicList.GetItemN(index: Integer): TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableCharacteristic;
end;
function TFhirEvidenceVariableCharacteristicList.IndexOf(value: TFhirEvidenceVariableCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableCharacteristicList.Insert(index: Integer): TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicList.InsertItem(index: Integer; value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value is TFhirEvidenceVariableCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableCharacteristicList.Item(index: Integer): TFhirEvidenceVariableCharacteristic;
begin
  result := TFhirEvidenceVariableCharacteristic(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicList.Link: TFhirEvidenceVariableCharacteristicList;
begin
  result := TFhirEvidenceVariableCharacteristicList(inherited Link);
end;

procedure TFhirEvidenceVariableCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableCharacteristicList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value is TFhirEvidenceVariableCharacteristic);
  FhirEvidenceVariableCharacteristics[index] := value;
end;

procedure TFhirEvidenceVariableCharacteristicList.SetItemN(index: Integer; value: TFhirEvidenceVariableCharacteristic);
begin
  assert(value is TFhirEvidenceVariableCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceVariableCharacteristicTimeFromStart }

constructor TFhirEvidenceVariableCharacteristicTimeFromStart.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableCharacteristicTimeFromStart.Destroy;
begin
  FDescription.free;
  FQuantity.free;
  FRange.free;
  FNoteList.Free;
  inherited;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirEvidenceVariableCharacteristicTimeFromStart(oSource).descriptionElement.Clone;
  quantity := TFhirEvidenceVariableCharacteristicTimeFromStart(oSource).quantity.Clone;
  range := TFhirEvidenceVariableCharacteristicTimeFromStart(oSource).range.Clone;
  if (TFhirEvidenceVariableCharacteristicTimeFromStart(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceVariableCharacteristicTimeFromStart(oSource).FNoteList);
  end;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'quantity') Then
     list.add(self.link, 'quantity', FQuantity.Link);
  if (child_name = 'range') Then
     list.add(self.link, 'range', FRange.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'quantity', 'Quantity', false, TFhirQuantity, FQuantity.Link));
  oList.add(TFHIRProperty.create(self, 'range', 'Range', false, TFhirRange, FRange.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'quantity') then
  begin
    Quantity := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'range') then
  begin
    Range := propValue as TFhirRange;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else inherited;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'quantity') then result := TFhirQuantity.create()
  else if (propName = 'range') then result := TFhirRange.create()
  else if (propName = 'note') then result := NoteList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'string'
  else if (propName = 'quantity') then result := 'Quantity'
  else if (propName = 'range') then result := 'Range'
  else if (propName = 'note') then result := 'Annotation'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'quantity') then QuantityElement := nil
  else if (propName = 'range') then RangeElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'quantity') then QuantityElement := new as TFhirQuantity
  else if (propName = 'range') then RangeElement := new as TFhirRange
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'note') then NoteList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.fhirType : string;
begin
  result := 'EvidenceVariable.characteristic.timeFromStart';
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.Link : TFhirEvidenceVariableCharacteristicTimeFromStart;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStart(inherited Link);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.Clone : TFhirEvidenceVariableCharacteristicTimeFromStart;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStart(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableCharacteristicTimeFromStart;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableCharacteristicTimeFromStart)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableCharacteristicTimeFromStart(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(quantityElement, o.quantityElement, true) and 
      compareDeep(rangeElement, o.rangeElement, true) and compareDeep(noteList, o.noteList, true);
  end;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FQuantity) and isEmptyProp(FRange) and isEmptyProp(FnoteList);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('quantity');
  fields.add('range');
  fields.add('note');
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNoteList.sizeInBytes(magic));
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.SetQuantity(value : TFhirQuantity);
begin
  FQuantity.free;
  FQuantity := value;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStart.SetRange(value : TFhirRange);
begin
  FRange.free;
  FRange := value;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStart.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

{ TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator }

constructor TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator.Create(list : TFhirEvidenceVariableCharacteristicTimeFromStartList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator.GetCurrent : TFhirEvidenceVariableCharacteristicTimeFromStart;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableCharacteristicTimeFromStartList }

function TFhirEvidenceVariableCharacteristicTimeFromStartList.AddItem(value: TFhirEvidenceVariableCharacteristicTimeFromStart): TFhirEvidenceVariableCharacteristicTimeFromStart;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableCharacteristicTimeFromStart', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableCharacteristicTimeFromStart');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartList.Append: TFhirEvidenceVariableCharacteristicTimeFromStart;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStart.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStartList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartList.GetEnumerator : TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStartListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartList.Clone: TFhirEvidenceVariableCharacteristicTimeFromStartList;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStartList(inherited Clone);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartList.GetItemN(index: Integer): TFhirEvidenceVariableCharacteristicTimeFromStart;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStart(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStart;
end;
function TFhirEvidenceVariableCharacteristicTimeFromStartList.IndexOf(value: TFhirEvidenceVariableCharacteristicTimeFromStart): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartList.Insert(index: Integer): TFhirEvidenceVariableCharacteristicTimeFromStart;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStart.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStartList.InsertItem(index: Integer; value: TFhirEvidenceVariableCharacteristicTimeFromStart);
begin
  assert(value is TFhirEvidenceVariableCharacteristicTimeFromStart);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartList.Item(index: Integer): TFhirEvidenceVariableCharacteristicTimeFromStart;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStart(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCharacteristicTimeFromStartList.Link: TFhirEvidenceVariableCharacteristicTimeFromStartList;
begin
  result := TFhirEvidenceVariableCharacteristicTimeFromStartList(inherited Link);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStartList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStartList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableCharacteristicTimeFromStart);
begin
  assert(value is TFhirEvidenceVariableCharacteristicTimeFromStart);
  FhirEvidenceVariableCharacteristicTimeFromStarts[index] := value;
end;

procedure TFhirEvidenceVariableCharacteristicTimeFromStartList.SetItemN(index: Integer; value: TFhirEvidenceVariableCharacteristicTimeFromStart);
begin
  assert(value is TFhirEvidenceVariableCharacteristicTimeFromStart);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceVariableCategory }

constructor TFhirEvidenceVariableCategory.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariableCategory.Destroy;
begin
  FName.free;
  FValue.free;
  inherited;
end;

procedure TFhirEvidenceVariableCategory.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirEvidenceVariableCategory(oSource).nameElement.Clone;
  value := TFhirEvidenceVariableCategory(oSource).value.Clone;
end;

procedure TFhirEvidenceVariableCategory.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirEvidenceVariableCategory.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'CodeableConcept|Quantity|Range', false, TFhirDataType, FValue.Link));
end;

function TFhirEvidenceVariableCategory.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariableCategory.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirEvidenceVariableCategory.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariableCategory.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := 'CodeableConcept|Quantity|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariableCategory.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariableCategory.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (isMatchingName(propName, 'value', ['CodeableConcept', 'Quantity', 'Range'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariableCategory.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariableCategory.fhirType : string;
begin
  result := 'EvidenceVariable.category';
end;

function TFhirEvidenceVariableCategory.Link : TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory(inherited Link);
end;

function TFhirEvidenceVariableCategory.Clone : TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory(inherited Clone);
end;

function TFhirEvidenceVariableCategory.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariableCategory;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariableCategory)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariableCategory(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirEvidenceVariableCategory.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue);
end;

procedure TFhirEvidenceVariableCategory.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
end;

function TFhirEvidenceVariableCategory.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirEvidenceVariableCategory.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirEvidenceVariableCategory.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirEvidenceVariableCategory.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirEvidenceVariableCategory.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirEvidenceVariableCategoryListEnumerator }

constructor TFhirEvidenceVariableCategoryListEnumerator.Create(list : TFhirEvidenceVariableCategoryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableCategoryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableCategoryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableCategoryListEnumerator.GetCurrent : TFhirEvidenceVariableCategory;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableCategoryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableCategoryList }

function TFhirEvidenceVariableCategoryList.AddItem(value: TFhirEvidenceVariableCategory): TFhirEvidenceVariableCategory;
begin
  assert(value.ClassName = 'TFhirEvidenceVariableCategory', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariableCategory');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableCategoryList.Append: TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCategoryList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableCategoryList.GetEnumerator : TFhirEvidenceVariableCategoryListEnumerator;
begin
  result := TFhirEvidenceVariableCategoryListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableCategoryList.Clone: TFhirEvidenceVariableCategoryList;
begin
  result := TFhirEvidenceVariableCategoryList(inherited Clone);
end;

function TFhirEvidenceVariableCategoryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableCategoryList.GetItemN(index: Integer): TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCategoryList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariableCategory;
end;
function TFhirEvidenceVariableCategoryList.IndexOf(value: TFhirEvidenceVariableCategory): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableCategoryList.Insert(index: Integer): TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableCategoryList.InsertItem(index: Integer; value: TFhirEvidenceVariableCategory);
begin
  assert(value is TFhirEvidenceVariableCategory);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableCategoryList.Item(index: Integer): TFhirEvidenceVariableCategory;
begin
  result := TFhirEvidenceVariableCategory(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableCategoryList.Link: TFhirEvidenceVariableCategoryList;
begin
  result := TFhirEvidenceVariableCategoryList(inherited Link);
end;

procedure TFhirEvidenceVariableCategoryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableCategoryList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariableCategory);
begin
  assert(value is TFhirEvidenceVariableCategory);
  FhirEvidenceVariableCategories[index] := value;
end;

procedure TFhirEvidenceVariableCategoryList.SetItemN(index: Integer; value: TFhirEvidenceVariableCategory);
begin
  assert(value is TFhirEvidenceVariableCategory);
  ObjectByIndex[index] := value;
end;

{ TFhirEvidenceVariable }

constructor TFhirEvidenceVariable.Create;
begin
  inherited;
end;

destructor TFhirEvidenceVariable.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FShortTitle.free;
  FSubtitle.free;
  FStatus.free;
  FDate.free;
  FDescription.free;
  FNoteList.Free;
  FUseContextList.Free;
  FPublisher.free;
  FContactList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FActual.free;
  FCharacteristicCombination.free;
  FCharacteristicList.Free;
  FHandling.free;
  FCategoryList.Free;
  inherited;
end;

procedure TFhirEvidenceVariable.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirEvidenceVariable(oSource).urlElement.Clone;
  if (TFhirEvidenceVariable(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirEvidenceVariable(oSource).FIdentifierList);
  end;
  versionElement := TFhirEvidenceVariable(oSource).versionElement.Clone;
  nameElement := TFhirEvidenceVariable(oSource).nameElement.Clone;
  titleElement := TFhirEvidenceVariable(oSource).titleElement.Clone;
  shortTitleElement := TFhirEvidenceVariable(oSource).shortTitleElement.Clone;
  subtitleElement := TFhirEvidenceVariable(oSource).subtitleElement.Clone;
  statusElement := TFhirEvidenceVariable(oSource).statusElement.Clone;
  dateElement := TFhirEvidenceVariable(oSource).dateElement.Clone;
  descriptionElement := TFhirEvidenceVariable(oSource).descriptionElement.Clone;
  if (TFhirEvidenceVariable(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirEvidenceVariable(oSource).FNoteList);
  end;
  if (TFhirEvidenceVariable(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirEvidenceVariable(oSource).FUseContextList);
  end;
  publisherElement := TFhirEvidenceVariable(oSource).publisherElement.Clone;
  if (TFhirEvidenceVariable(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirEvidenceVariable(oSource).FContactList);
  end;
  if (TFhirEvidenceVariable(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirEvidenceVariable(oSource).FAuthorList);
  end;
  if (TFhirEvidenceVariable(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirEvidenceVariable(oSource).FEditorList);
  end;
  if (TFhirEvidenceVariable(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirEvidenceVariable(oSource).FReviewerList);
  end;
  if (TFhirEvidenceVariable(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirEvidenceVariable(oSource).FEndorserList);
  end;
  if (TFhirEvidenceVariable(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirEvidenceVariable(oSource).FRelatedArtifactList);
  end;
  actualElement := TFhirEvidenceVariable(oSource).actualElement.Clone;
  characteristicCombinationElement := TFhirEvidenceVariable(oSource).characteristicCombinationElement.Clone;
  if (TFhirEvidenceVariable(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirEvidenceVariableCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirEvidenceVariable(oSource).FCharacteristicList);
  end;
  handlingElement := TFhirEvidenceVariable(oSource).handlingElement.Clone;
  if (TFhirEvidenceVariable(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirEvidenceVariableCategoryList.Create;
    FCategoryList.Assign(TFhirEvidenceVariable(oSource).FCategoryList);
  end;
end;

function TFhirEvidenceVariable.GetResourceType : TFhirResourceType;
begin
  result := frtEvidenceVariable;
end;

procedure TFhirEvidenceVariable.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'shortTitle') Then
     list.add(self.link, 'shortTitle', FShortTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'actual') Then
     list.add(self.link, 'actual', FActual.Link);
  if (child_name = 'characteristicCombination') Then
     list.add(self.link, 'characteristicCombination', FCharacteristicCombination.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
  if (child_name = 'handling') Then
     list.add(self.link, 'handling', FHandling.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
end;

procedure TFhirEvidenceVariable.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'shortTitle', 'string', false, TFhirString, FShortTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'actual', 'boolean', false, TFhirBoolean, FActual.Link));
  oList.add(TFHIRProperty.create(self, 'characteristicCombination', 'code', false, TFhirEnum, FCharacteristicCombination.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirEvidenceVariableCharacteristic, FCharacteristicList.Link));
  oList.add(TFHIRProperty.create(self, 'handling', 'code', false, TFhirEnum, FHandling.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'BackboneElement', true, TFhirEvidenceVariableCategory, FCategoryList.Link));
end;

function TFhirEvidenceVariable.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'shortTitle') then
  begin
    ShortTitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'actual') then
  begin
    ActualElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'characteristicCombination') then
  begin
    CharacteristicCombinationElement := asEnum(SYSTEMS_TFhirCharacteristicCombinationEnum, CODES_TFhirCharacteristicCombinationEnum, propValue);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirEvidenceVariableCharacteristic);
    result := propValue;
  end
  else if (propName = 'handling') then
  begin
    HandlingElement := asEnum(SYSTEMS_TFhirEvidenceVariableHandlingEnum, CODES_TFhirEvidenceVariableHandlingEnum, propValue);
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirEvidenceVariableCategory);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirEvidenceVariable.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirEvidenceVariableCharacteristic)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirEvidenceVariableCategory)
  else inherited;
end;

function TFhirEvidenceVariable.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'shortTitle') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'actual') then result := TFhirBoolean.create()
  else if (propName = 'characteristicCombination') then result := TFhirEnum.create(SYSTEMS_TFhirCharacteristicCombinationEnum[CharacteristicCombinationNull], CODES_TFhirCharacteristicCombinationEnum[CharacteristicCombinationNull]) 
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else if (propName = 'handling') then result := TFhirEnum.create(SYSTEMS_TFhirEvidenceVariableHandlingEnum[EvidenceVariableHandlingNull], CODES_TFhirEvidenceVariableHandlingEnum[EvidenceVariableHandlingNull]) 
  else if (propName = 'category') then result := CategoryList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirEvidenceVariable.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'shortTitle') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'actual') then result := 'boolean'
  else if (propName = 'characteristicCombination') then result := 'code'
  else if (propName = 'characteristic') then result := 'BackboneElement'
  else if (propName = 'handling') then result := 'code'
  else if (propName = 'category') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirEvidenceVariable.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'shortTitle') then ShortTitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'actual') then ActualElement := nil
  else if (propName = 'characteristicCombination') then CharacteristicCombinationElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else if (propName = 'handling') then HandlingElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirEvidenceVariable.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'shortTitle') then ShortTitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'actual') then ActualElement := asBoolean(new)
  else if (propName = 'characteristicCombination') then CharacteristicCombinationElement := asEnum(SYSTEMS_TFhirCharacteristicCombinationEnum, CODES_TFhirCharacteristicCombinationEnum, new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else if (propName = 'handling') then HandlingElement := asEnum(SYSTEMS_TFhirEvidenceVariableHandlingEnum, CODES_TFhirEvidenceVariableHandlingEnum, new)
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirEvidenceVariable.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirEvidenceVariable.fhirType : string;
begin
  result := 'EvidenceVariable';
end;

function TFhirEvidenceVariable.Link : TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(inherited Link);
end;

function TFhirEvidenceVariable.Clone : TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(inherited Clone);
end;

function TFhirEvidenceVariable.equals(other : TObject) : boolean; 
var
  o : TFhirEvidenceVariable;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirEvidenceVariable)) then
    result := false
  else
  begin
    o := TFhirEvidenceVariable(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(shortTitleElement, o.shortTitleElement, true) and 
      compareDeep(subtitleElement, o.subtitleElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(actualElement, o.actualElement, true) and 
      compareDeep(characteristicCombinationElement, o.characteristicCombinationElement, true) and 
      compareDeep(characteristicList, o.characteristicList, true) and compareDeep(handlingElement, o.handlingElement, true) and 
      compareDeep(categoryList, o.categoryList, true);
  end;
end;

function TFhirEvidenceVariable.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FShortTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FStatus) and isEmptyProp(FDate) and isEmptyProp(FDescription) and isEmptyProp(FnoteList) and isEmptyProp(FuseContextList) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FActual) and isEmptyProp(FCharacteristicCombination) and isEmptyProp(FcharacteristicList) and isEmptyProp(FHandling) and isEmptyProp(FcategoryList);
end;

procedure TFhirEvidenceVariable.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('shortTitle');
  fields.add('subtitle');
  fields.add('status');
  fields.add('date');
  fields.add('description');
  fields.add('note');
  fields.add('useContext');
  fields.add('publisher');
  fields.add('contact');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('actual');
  fields.add('characteristicCombination');
  fields.add('characteristic');
  fields.add('handling');
  fields.add('category');
end;

function TFhirEvidenceVariable.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
end;

procedure TFhirEvidenceVariable.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirEvidenceVariable.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirEvidenceVariable.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirEvidenceVariable.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirEvidenceVariable.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirEvidenceVariable.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirEvidenceVariable.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirEvidenceVariable.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirEvidenceVariable.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirEvidenceVariable.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirEvidenceVariable.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirEvidenceVariable.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirEvidenceVariable.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirEvidenceVariable.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirEvidenceVariable.SetShortTitle(value : TFhirString);
begin
  FShortTitle.free;
  FShortTitle := value;
end;

function TFhirEvidenceVariable.GetShortTitleST : String;
begin
  if FShortTitle = nil then
    result := ''
  else
    result := FShortTitle.value;
end;

procedure TFhirEvidenceVariable.SetShortTitleST(value : String);
begin
  if value <> '' then
  begin
    if FShortTitle = nil then
      FShortTitle := TFhirString.create;
    FShortTitle.value := value
  end
  else if FShortTitle <> nil then
    FShortTitle.value := '';
end;

procedure TFhirEvidenceVariable.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirEvidenceVariable.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirEvidenceVariable.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirEvidenceVariable.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirEvidenceVariable.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirEvidenceVariable.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirEvidenceVariable.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirEvidenceVariable.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirEvidenceVariable.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirEvidenceVariable.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirEvidenceVariable.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirEvidenceVariable.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirEvidenceVariable.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirEvidenceVariable.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirEvidenceVariable.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirEvidenceVariable.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

procedure TFhirEvidenceVariable.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirEvidenceVariable.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirEvidenceVariable.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirEvidenceVariable.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirEvidenceVariable.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirEvidenceVariable.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirEvidenceVariable.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirEvidenceVariable.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirEvidenceVariable.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirEvidenceVariable.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirEvidenceVariable.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirEvidenceVariable.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirEvidenceVariable.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirEvidenceVariable.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirEvidenceVariable.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

procedure TFhirEvidenceVariable.SetActual(value : TFhirBoolean);
begin
  FActual.free;
  FActual := value;
end;

function TFhirEvidenceVariable.GetActualST : Boolean;
begin
  if FActual = nil then
    result := false
  else
    result := FActual.value;
end;

procedure TFhirEvidenceVariable.SetActualST(value : Boolean);
begin
  if FActual = nil then
    FActual := TFhirBoolean.create;
  FActual.value := value
end;

procedure TFhirEvidenceVariable.SetCharacteristicCombination(value : TFhirEnum);
begin
  FCharacteristicCombination.free;
  FCharacteristicCombination := value;
end;

function TFhirEvidenceVariable.GetCharacteristicCombinationST : TFhirCharacteristicCombinationEnum;
begin
  if FCharacteristicCombination = nil then
    result := TFhirCharacteristicCombinationEnum(0)
  else
    result := TFhirCharacteristicCombinationEnum(StringArrayIndexOfSensitive(CODES_TFhirCharacteristicCombinationEnum, FCharacteristicCombination.value));
end;

procedure TFhirEvidenceVariable.SetCharacteristicCombinationST(value : TFhirCharacteristicCombinationEnum);
begin
  if ord(value) = 0 then
    CharacteristicCombinationElement := nil
  else
    CharacteristicCombinationElement := TFhirEnum.create(SYSTEMS_TFhirCharacteristicCombinationEnum[value], CODES_TFhirCharacteristicCombinationEnum[value]);
end;

function TFhirEvidenceVariable.GetCharacteristicList : TFhirEvidenceVariableCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirEvidenceVariableCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirEvidenceVariable.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

procedure TFhirEvidenceVariable.SetHandling(value : TFhirEnum);
begin
  FHandling.free;
  FHandling := value;
end;

function TFhirEvidenceVariable.GetHandlingST : TFhirEvidenceVariableHandlingEnum;
begin
  if FHandling = nil then
    result := TFhirEvidenceVariableHandlingEnum(0)
  else
    result := TFhirEvidenceVariableHandlingEnum(StringArrayIndexOfSensitive(CODES_TFhirEvidenceVariableHandlingEnum, FHandling.value));
end;

procedure TFhirEvidenceVariable.SetHandlingST(value : TFhirEvidenceVariableHandlingEnum);
begin
  if ord(value) = 0 then
    HandlingElement := nil
  else
    HandlingElement := TFhirEnum.create(SYSTEMS_TFhirEvidenceVariableHandlingEnum[value], CODES_TFhirEvidenceVariableHandlingEnum[value]);
end;

function TFhirEvidenceVariable.GetCategoryList : TFhirEvidenceVariableCategoryList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirEvidenceVariableCategoryList.Create;
  result := FCategoryList;
end;

function TFhirEvidenceVariable.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

{ TFhirEvidenceVariableListEnumerator }

constructor TFhirEvidenceVariableListEnumerator.Create(list : TFhirEvidenceVariableList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirEvidenceVariableListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirEvidenceVariableListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirEvidenceVariableListEnumerator.GetCurrent : TFhirEvidenceVariable;
begin
  Result := FList[FIndex];
end;

function TFhirEvidenceVariableListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirEvidenceVariableList }

function TFhirEvidenceVariableList.AddItem(value: TFhirEvidenceVariable): TFhirEvidenceVariable;
begin
  assert(value.ClassName = 'TFhirEvidenceVariable', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirEvidenceVariable');
  add(value);
  result := value;
end;

function TFhirEvidenceVariableList.Append: TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableList.ClearItems;
begin
  Clear;
end;

function TFhirEvidenceVariableList.GetEnumerator : TFhirEvidenceVariableListEnumerator;
begin
  result := TFhirEvidenceVariableListEnumerator.Create(self.link);
end;

function TFhirEvidenceVariableList.Clone: TFhirEvidenceVariableList;
begin
  result := TFhirEvidenceVariableList(inherited Clone);
end;

function TFhirEvidenceVariableList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirEvidenceVariableList.GetItemN(index: Integer): TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableList.ItemClass: TFslObjectClass;
begin
  result := TFhirEvidenceVariable;
end;
function TFhirEvidenceVariableList.IndexOf(value: TFhirEvidenceVariable): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirEvidenceVariableList.Insert(index: Integer): TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirEvidenceVariableList.InsertItem(index: Integer; value: TFhirEvidenceVariable);
begin
  assert(value is TFhirEvidenceVariable);
  Inherited Insert(index, value);
end;

function TFhirEvidenceVariableList.Item(index: Integer): TFhirEvidenceVariable;
begin
  result := TFhirEvidenceVariable(ObjectByIndex[index]);
end;

function TFhirEvidenceVariableList.Link: TFhirEvidenceVariableList;
begin
  result := TFhirEvidenceVariableList(inherited Link);
end;

procedure TFhirEvidenceVariableList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirEvidenceVariableList.SetItemByIndex(index: Integer; value: TFhirEvidenceVariable);
begin
  assert(value is TFhirEvidenceVariable);
  FhirEvidenceVariables[index] := value;
end;

procedure TFhirEvidenceVariableList.SetItemN(index: Integer; value: TFhirEvidenceVariable);
begin
  assert(value is TFhirEvidenceVariable);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_EVIDENCEVARIABLE}
{$IFDEF FHIR_GUIDANCERESPONSE}
{ TFhirGuidanceResponse }

constructor TFhirGuidanceResponse.Create;
begin
  inherited;
end;

destructor TFhirGuidanceResponse.Destroy;
begin
  FRequestIdentifier.free;
  FIdentifierList.Free;
  FModule.free;
  FStatus.free;
  FSubject.free;
  FEncounter.free;
  FOccurrenceDateTime.free;
  FPerformer.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FEvaluationMessageList.Free;
  FOutputParameters.free;
  FResult.free;
  FDataRequirementList.Free;
  inherited;
end;

procedure TFhirGuidanceResponse.Assign(oSource : TFslObject);
begin
  inherited;
  requestIdentifier := TFhirGuidanceResponse(oSource).requestIdentifier.Clone;
  if (TFhirGuidanceResponse(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirGuidanceResponse(oSource).FIdentifierList);
  end;
  module := TFhirGuidanceResponse(oSource).module.Clone;
  statusElement := TFhirGuidanceResponse(oSource).statusElement.Clone;
  subject := TFhirGuidanceResponse(oSource).subject.Clone;
  encounter := TFhirGuidanceResponse(oSource).encounter.Clone;
  occurrenceDateTimeElement := TFhirGuidanceResponse(oSource).occurrenceDateTimeElement.Clone;
  performer := TFhirGuidanceResponse(oSource).performer.Clone;
  if (TFhirGuidanceResponse(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirGuidanceResponse(oSource).FReasonCodeList);
  end;
  if (TFhirGuidanceResponse(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirGuidanceResponse(oSource).FReasonReferenceList);
  end;
  if (TFhirGuidanceResponse(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirGuidanceResponse(oSource).FNoteList);
  end;
  if (TFhirGuidanceResponse(oSource).FEvaluationMessageList = nil) then
  begin
    FEvaluationMessageList.free;
    FEvaluationMessageList := nil;
  end
  else
  begin
    if FEvaluationMessageList = nil then
      FEvaluationMessageList := TFhirReferenceList.Create;
    FEvaluationMessageList.Assign(TFhirGuidanceResponse(oSource).FEvaluationMessageList);
  end;
  outputParameters := TFhirGuidanceResponse(oSource).outputParameters.Clone;
  result := TFhirGuidanceResponse(oSource).result.Clone;
  if (TFhirGuidanceResponse(oSource).FDataRequirementList = nil) then
  begin
    FDataRequirementList.free;
    FDataRequirementList := nil;
  end
  else
  begin
    if FDataRequirementList = nil then
      FDataRequirementList := TFhirDataRequirementList.Create;
    FDataRequirementList.Assign(TFhirGuidanceResponse(oSource).FDataRequirementList);
  end;
end;

function TFhirGuidanceResponse.GetResourceType : TFhirResourceType;
begin
  result := frtGuidanceResponse;
end;

procedure TFhirGuidanceResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'requestIdentifier') Then
     list.add(self.link, 'requestIdentifier', FRequestIdentifier.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'module[x]') or (child_name = 'module') Then
     list.add(self.link, 'module[x]', FModule.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'occurrenceDateTime') Then
     list.add(self.link, 'occurrenceDateTime', FOccurrenceDateTime.Link);
  if (child_name = 'performer') Then
     list.add(self.link, 'performer', FPerformer.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'evaluationMessage') Then
    list.addAll(self, 'evaluationMessage', FEvaluationMessageList);
  if (child_name = 'outputParameters') Then
     list.add(self.link, 'outputParameters', FOutputParameters.Link);
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'dataRequirement') Then
    list.addAll(self, 'dataRequirement', FDataRequirementList);
end;

procedure TFhirGuidanceResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'requestIdentifier', 'Identifier', false, TFhirIdentifier, FRequestIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'module[x]', 'uri|canonical|CodeableConcept', false, TFhirDataType, FModule.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'occurrenceDateTime', 'dateTime', false, TFhirDateTime, FOccurrenceDateTime.Link));
  oList.add(TFHIRProperty.create(self, 'performer', 'Reference', false, TFhirReference, FPerformer.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'evaluationMessage', 'Reference', true, TFhirReference, FEvaluationMessageList.Link));
  oList.add(TFHIRProperty.create(self, 'outputParameters', 'Reference', false, TFhirReference, FOutputParameters.Link));
  oList.add(TFHIRProperty.create(self, 'result', 'Reference', false, TFhirReference, FResult.Link));
  oList.add(TFHIRProperty.create(self, 'dataRequirement', 'DataRequirement', true, TFhirDataRequirement, FDataRequirementList.Link));
end;

function TFhirGuidanceResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'requestIdentifier') then
  begin
    RequestIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then
  begin
    Module := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirGuidanceResponseStatusEnum, CODES_TFhirGuidanceResponseStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'occurrenceDateTime') then
  begin
    OccurrenceDateTimeElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'performer') then
  begin
    Performer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'evaluationMessage') then
  begin
    EvaluationMessageList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'outputParameters') then
  begin
    OutputParameters := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    Result := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'dataRequirement') then
  begin
    DataRequirementList.add(propValue as TFhirDataRequirement);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirGuidanceResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'evaluationMessage') then EvaluationMessageList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'dataRequirement') then DataRequirementList.insertItem(index, propValue as TFhirDataRequirement)
  else inherited;
end;

function TFhirGuidanceResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'requestIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Module')
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirGuidanceResponseStatusEnum[GuidanceResponseStatusNull], CODES_TFhirGuidanceResponseStatusEnum[GuidanceResponseStatusNull]) 
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'occurrenceDateTime') then result := TFhirDateTime.create()
  else if (propName = 'performer') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'evaluationMessage') then result := EvaluationMessageList.new()
  else if (propName = 'outputParameters') then result := TFhirReference.create()
  else if (propName = 'result') then result := TFhirReference.create()
  else if (propName = 'dataRequirement') then result := DataRequirementList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirGuidanceResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'requestIdentifier') then result := 'Identifier'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'module[x]') then result := 'uri|canonical|CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'occurrenceDateTime') then result := 'dateTime'
  else if (propName = 'performer') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'evaluationMessage') then result := 'Reference'
  else if (propName = 'outputParameters') then result := 'Reference'
  else if (propName = 'result') then result := 'Reference'
  else if (propName = 'dataRequirement') then result := 'DataRequirement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirGuidanceResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'requestIdentifier') then RequestIdentifierElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then ModuleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'occurrenceDateTime') then OccurrenceDateTimeElement := nil
  else if (propName = 'performer') then PerformerElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'evaluationMessage') then deletePropertyValue('evaluationMessage', EvaluationMessageList, value)
  else if (propName = 'outputParameters') then OutputParametersElement := nil
  else if (propName = 'result') then ResultElement := nil
  else if (propName = 'dataRequirement') then deletePropertyValue('dataRequirement', DataRequirementList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirGuidanceResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'requestIdentifier') then RequestIdentifierElement := new as TFhirIdentifier
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (isMatchingName(propName, 'module', ['Uri', 'Canonical', 'CodeableConcept'])) then ModuleElement := new as TFhirDataType
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirGuidanceResponseStatusEnum, CODES_TFhirGuidanceResponseStatusEnum, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'occurrenceDateTime') then OccurrenceDateTimeElement := asDateTime(new)
  else if (propName = 'performer') then PerformerElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'evaluationMessage') then replacePropertyValue('evaluationMessage', EvaluationMessageList, existing, new)
  else if (propName = 'outputParameters') then OutputParametersElement := new as TFhirReference
  else if (propName = 'result') then ResultElement := new as TFhirReference
  else if (propName = 'dataRequirement') then replacePropertyValue('dataRequirement', DataRequirementList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirGuidanceResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'evaluationMessage') then EvaluationMessageList.move(source, destination)
  else if (propName = 'dataRequirement') then DataRequirementList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirGuidanceResponse.fhirType : string;
begin
  result := 'GuidanceResponse';
end;

function TFhirGuidanceResponse.Link : TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(inherited Link);
end;

function TFhirGuidanceResponse.Clone : TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(inherited Clone);
end;

function TFhirGuidanceResponse.equals(other : TObject) : boolean; 
var
  o : TFhirGuidanceResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirGuidanceResponse)) then
    result := false
  else
  begin
    o := TFhirGuidanceResponse(other);
    result := compareDeep(requestIdentifierElement, o.requestIdentifierElement, true) and 
      compareDeep(identifierList, o.identifierList, true) and compareDeep(moduleElement, o.moduleElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(occurrenceDateTimeElement, o.occurrenceDateTimeElement, true) and 
      compareDeep(performerElement, o.performerElement, true) and compareDeep(reasonCodeList, o.reasonCodeList, true) and 
      compareDeep(reasonReferenceList, o.reasonReferenceList, true) and compareDeep(noteList, o.noteList, true) and 
      compareDeep(evaluationMessageList, o.evaluationMessageList, true) and compareDeep(outputParametersElement, o.outputParametersElement, true) and 
      compareDeep(resultElement, o.resultElement, true) and compareDeep(dataRequirementList, o.dataRequirementList, true);
  end;
end;

function TFhirGuidanceResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRequestIdentifier) and isEmptyProp(FidentifierList) and isEmptyProp(FModule) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FOccurrenceDateTime) and isEmptyProp(FPerformer) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FevaluationMessageList) and isEmptyProp(FOutputParameters) and isEmptyProp(FResult) and isEmptyProp(FdataRequirementList);
end;

procedure TFhirGuidanceResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('requestIdentifier');
  fields.add('identifier');
  fields.add('module[x]');
  fields.add('status');
  fields.add('subject');
  fields.add('encounter');
  fields.add('occurrenceDateTime');
  fields.add('performer');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('evaluationMessage');
  fields.add('outputParameters');
  fields.add('result');
  fields.add('dataRequirement');
end;

function TFhirGuidanceResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FEvaluationMessageList.sizeInBytes(magic));
  inc(result, FDataRequirementList.sizeInBytes(magic));
end;

procedure TFhirGuidanceResponse.SetRequestIdentifier(value : TFhirIdentifier);
begin
  FRequestIdentifier.free;
  FRequestIdentifier := value;
end;

function TFhirGuidanceResponse.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirGuidanceResponse.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirGuidanceResponse.SetModule(value : TFhirDataType);
begin
  FModule.free;
  FModule := value;
end;

procedure TFhirGuidanceResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirGuidanceResponse.GetStatusST : TFhirGuidanceResponseStatusEnum;
begin
  if FStatus = nil then
    result := TFhirGuidanceResponseStatusEnum(0)
  else
    result := TFhirGuidanceResponseStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirGuidanceResponseStatusEnum, FStatus.value));
end;

procedure TFhirGuidanceResponse.SetStatusST(value : TFhirGuidanceResponseStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirGuidanceResponseStatusEnum[value], CODES_TFhirGuidanceResponseStatusEnum[value]);
end;

procedure TFhirGuidanceResponse.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirGuidanceResponse.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirGuidanceResponse.SetOccurrenceDateTime(value : TFhirDateTime);
begin
  FOccurrenceDateTime.free;
  FOccurrenceDateTime := value;
end;

function TFhirGuidanceResponse.GetOccurrenceDateTimeST : TFslDateTime;
begin
  if FOccurrenceDateTime = nil then
    result := TFslDateTime.makeNull
  else
    result := FOccurrenceDateTime.value;
end;

procedure TFhirGuidanceResponse.SetOccurrenceDateTimeST(value : TFslDateTime);
begin
  if FOccurrenceDateTime = nil then
    FOccurrenceDateTime := TFhirDateTime.create;
  FOccurrenceDateTime.value := value
end;

procedure TFhirGuidanceResponse.SetPerformer(value : TFhirReference);
begin
  FPerformer.free;
  FPerformer := value;
end;

function TFhirGuidanceResponse.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirGuidanceResponse.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirGuidanceResponse.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirGuidanceResponse.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirGuidanceResponse.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirGuidanceResponse.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirGuidanceResponse.GetEvaluationMessageList : TFhirReferenceList;
begin
  if FEvaluationMessageList = nil then
    FEvaluationMessageList := TFhirReferenceList.Create;
  result := FEvaluationMessageList;
end;

function TFhirGuidanceResponse.GetHasEvaluationMessageList : boolean;
begin
  result := (FEvaluationMessageList <> nil) and (FEvaluationMessageList.count > 0);
end;

procedure TFhirGuidanceResponse.SetOutputParameters(value : TFhirReference);
begin
  FOutputParameters.free;
  FOutputParameters := value;
end;

procedure TFhirGuidanceResponse.SetResult(value : TFhirReference);
begin
  FResult.free;
  FResult := value;
end;

function TFhirGuidanceResponse.GetDataRequirementList : TFhirDataRequirementList;
begin
  if FDataRequirementList = nil then
    FDataRequirementList := TFhirDataRequirementList.Create;
  result := FDataRequirementList;
end;

function TFhirGuidanceResponse.GetHasDataRequirementList : boolean;
begin
  result := (FDataRequirementList <> nil) and (FDataRequirementList.count > 0);
end;

{ TFhirGuidanceResponseListEnumerator }

constructor TFhirGuidanceResponseListEnumerator.Create(list : TFhirGuidanceResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirGuidanceResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirGuidanceResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirGuidanceResponseListEnumerator.GetCurrent : TFhirGuidanceResponse;
begin
  Result := FList[FIndex];
end;

function TFhirGuidanceResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirGuidanceResponseList }

function TFhirGuidanceResponseList.AddItem(value: TFhirGuidanceResponse): TFhirGuidanceResponse;
begin
  assert(value.ClassName = 'TFhirGuidanceResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirGuidanceResponse');
  add(value);
  result := value;
end;

function TFhirGuidanceResponseList.Append: TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGuidanceResponseList.ClearItems;
begin
  Clear;
end;

function TFhirGuidanceResponseList.GetEnumerator : TFhirGuidanceResponseListEnumerator;
begin
  result := TFhirGuidanceResponseListEnumerator.Create(self.link);
end;

function TFhirGuidanceResponseList.Clone: TFhirGuidanceResponseList;
begin
  result := TFhirGuidanceResponseList(inherited Clone);
end;

function TFhirGuidanceResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirGuidanceResponseList.GetItemN(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(ObjectByIndex[index]);
end;

function TFhirGuidanceResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirGuidanceResponse;
end;
function TFhirGuidanceResponseList.IndexOf(value: TFhirGuidanceResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirGuidanceResponseList.Insert(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirGuidanceResponseList.InsertItem(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  Inherited Insert(index, value);
end;

function TFhirGuidanceResponseList.Item(index: Integer): TFhirGuidanceResponse;
begin
  result := TFhirGuidanceResponse(ObjectByIndex[index]);
end;

function TFhirGuidanceResponseList.Link: TFhirGuidanceResponseList;
begin
  result := TFhirGuidanceResponseList(inherited Link);
end;

procedure TFhirGuidanceResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirGuidanceResponseList.SetItemByIndex(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  FhirGuidanceResponses[index] := value;
end;

procedure TFhirGuidanceResponseList.SetItemN(index: Integer; value: TFhirGuidanceResponse);
begin
  assert(value is TFhirGuidanceResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_GUIDANCERESPONSE}
{$IFDEF FHIR_LINKAGE}
{ TFhirLinkageItem }

constructor TFhirLinkageItem.Create;
begin
  inherited;
end;

destructor TFhirLinkageItem.Destroy;
begin
  FType_.free;
  FResource.free;
  inherited;
end;

procedure TFhirLinkageItem.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirLinkageItem(oSource).type_Element.Clone;
  resource := TFhirLinkageItem(oSource).resource.Clone;
end;

procedure TFhirLinkageItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirLinkageItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference', false, TFhirReference, FResource.Link));
end;

function TFhirLinkageItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirLinkageTypeEnum, CODES_TFhirLinkageTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLinkageItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirLinkageItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirLinkageTypeEnum[LinkageTypeNull], CODES_TFhirLinkageTypeEnum[LinkageTypeNull]) 
  else if (propName = 'resource') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLinkageItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'resource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLinkageItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLinkageItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirLinkageTypeEnum, CODES_TFhirLinkageTypeEnum, new)
  else if (propName = 'resource') then ResourceElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLinkageItem.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirLinkageItem.fhirType : string;
begin
  result := 'Linkage.item';
end;

function TFhirLinkageItem.Link : TFhirLinkageItem;
begin
  result := TFhirLinkageItem(inherited Link);
end;

function TFhirLinkageItem.Clone : TFhirLinkageItem;
begin
  result := TFhirLinkageItem(inherited Clone);
end;

function TFhirLinkageItem.equals(other : TObject) : boolean; 
var
  o : TFhirLinkageItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLinkageItem)) then
    result := false
  else
  begin
    o := TFhirLinkageItem(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirLinkageItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FResource);
end;

procedure TFhirLinkageItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('resource');
end;

function TFhirLinkageItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirLinkageItem.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirLinkageItem.GetType_ST : TFhirLinkageTypeEnum;
begin
  if FType_ = nil then
    result := TFhirLinkageTypeEnum(0)
  else
    result := TFhirLinkageTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirLinkageTypeEnum, FType_.value));
end;

procedure TFhirLinkageItem.SetType_ST(value : TFhirLinkageTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirLinkageTypeEnum[value], CODES_TFhirLinkageTypeEnum[value]);
end;

procedure TFhirLinkageItem.SetResource(value : TFhirReference);
begin
  FResource.free;
  FResource := value;
end;

{ TFhirLinkageItemListEnumerator }

constructor TFhirLinkageItemListEnumerator.Create(list : TFhirLinkageItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLinkageItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLinkageItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLinkageItemListEnumerator.GetCurrent : TFhirLinkageItem;
begin
  Result := FList[FIndex];
end;

function TFhirLinkageItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLinkageItemList }

function TFhirLinkageItemList.AddItem(value: TFhirLinkageItem): TFhirLinkageItem;
begin
  assert(value.ClassName = 'TFhirLinkageItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLinkageItem');
  add(value);
  result := value;
end;

function TFhirLinkageItemList.Append: TFhirLinkageItem;
begin
  result := TFhirLinkageItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageItemList.ClearItems;
begin
  Clear;
end;

function TFhirLinkageItemList.GetEnumerator : TFhirLinkageItemListEnumerator;
begin
  result := TFhirLinkageItemListEnumerator.Create(self.link);
end;

function TFhirLinkageItemList.Clone: TFhirLinkageItemList;
begin
  result := TFhirLinkageItemList(inherited Clone);
end;

function TFhirLinkageItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLinkageItemList.GetItemN(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem(ObjectByIndex[index]);
end;

function TFhirLinkageItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirLinkageItem;
end;
function TFhirLinkageItemList.IndexOf(value: TFhirLinkageItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLinkageItemList.Insert(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageItemList.InsertItem(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  Inherited Insert(index, value);
end;

function TFhirLinkageItemList.Item(index: Integer): TFhirLinkageItem;
begin
  result := TFhirLinkageItem(ObjectByIndex[index]);
end;

function TFhirLinkageItemList.Link: TFhirLinkageItemList;
begin
  result := TFhirLinkageItemList(inherited Link);
end;

procedure TFhirLinkageItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLinkageItemList.SetItemByIndex(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  FhirLinkageItems[index] := value;
end;

procedure TFhirLinkageItemList.SetItemN(index: Integer; value: TFhirLinkageItem);
begin
  assert(value is TFhirLinkageItem);
  ObjectByIndex[index] := value;
end;

{ TFhirLinkage }

constructor TFhirLinkage.Create;
begin
  inherited;
end;

destructor TFhirLinkage.Destroy;
begin
  FActive.free;
  FAuthor.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirLinkage.Assign(oSource : TFslObject);
begin
  inherited;
  activeElement := TFhirLinkage(oSource).activeElement.Clone;
  author := TFhirLinkage(oSource).author.Clone;
  if (TFhirLinkage(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirLinkageItemList.Create;
    FItemList.Assign(TFhirLinkage(oSource).FItemList);
  end;
end;

function TFhirLinkage.GetResourceType : TFhirResourceType;
begin
  result := frtLinkage;
end;

procedure TFhirLinkage.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'active') Then
     list.add(self.link, 'active', FActive.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirLinkage.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'active', 'boolean', false, TFhirBoolean, FActive.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirLinkageItem, FItemList.Link));
end;

function TFhirLinkage.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'active') then
  begin
    ActiveElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirLinkageItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirLinkage.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirLinkageItem)
  else inherited;
end;

function TFhirLinkage.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'active') then result := TFhirBoolean.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirLinkage.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'active') then result := 'boolean'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'item') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirLinkage.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'active') then ActiveElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirLinkage.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'active') then ActiveElement := asBoolean(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirLinkage.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirLinkage.fhirType : string;
begin
  result := 'Linkage';
end;

function TFhirLinkage.Link : TFhirLinkage;
begin
  result := TFhirLinkage(inherited Link);
end;

function TFhirLinkage.Clone : TFhirLinkage;
begin
  result := TFhirLinkage(inherited Clone);
end;

function TFhirLinkage.equals(other : TObject) : boolean; 
var
  o : TFhirLinkage;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirLinkage)) then
    result := false
  else
  begin
    o := TFhirLinkage(other);
    result := compareDeep(activeElement, o.activeElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirLinkage.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActive) and isEmptyProp(FAuthor) and isEmptyProp(FitemList);
end;

procedure TFhirLinkage.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('active');
  fields.add('author');
  fields.add('item');
end;

function TFhirLinkage.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirLinkage.SetActive(value : TFhirBoolean);
begin
  FActive.free;
  FActive := value;
end;

function TFhirLinkage.GetActiveST : Boolean;
begin
  if FActive = nil then
    result := false
  else
    result := FActive.value;
end;

procedure TFhirLinkage.SetActiveST(value : Boolean);
begin
  if FActive = nil then
    FActive := TFhirBoolean.create;
  FActive.value := value
end;

procedure TFhirLinkage.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirLinkage.GetItemList : TFhirLinkageItemList;
begin
  if FItemList = nil then
    FItemList := TFhirLinkageItemList.Create;
  result := FItemList;
end;

function TFhirLinkage.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirLinkageListEnumerator }

constructor TFhirLinkageListEnumerator.Create(list : TFhirLinkageList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirLinkageListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirLinkageListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirLinkageListEnumerator.GetCurrent : TFhirLinkage;
begin
  Result := FList[FIndex];
end;

function TFhirLinkageListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirLinkageList }

function TFhirLinkageList.AddItem(value: TFhirLinkage): TFhirLinkage;
begin
  assert(value.ClassName = 'TFhirLinkage', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirLinkage');
  add(value);
  result := value;
end;

function TFhirLinkageList.Append: TFhirLinkage;
begin
  result := TFhirLinkage.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageList.ClearItems;
begin
  Clear;
end;

function TFhirLinkageList.GetEnumerator : TFhirLinkageListEnumerator;
begin
  result := TFhirLinkageListEnumerator.Create(self.link);
end;

function TFhirLinkageList.Clone: TFhirLinkageList;
begin
  result := TFhirLinkageList(inherited Clone);
end;

function TFhirLinkageList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirLinkageList.GetItemN(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage(ObjectByIndex[index]);
end;

function TFhirLinkageList.ItemClass: TFslObjectClass;
begin
  result := TFhirLinkage;
end;
function TFhirLinkageList.IndexOf(value: TFhirLinkage): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirLinkageList.Insert(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirLinkageList.InsertItem(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  Inherited Insert(index, value);
end;

function TFhirLinkageList.Item(index: Integer): TFhirLinkage;
begin
  result := TFhirLinkage(ObjectByIndex[index]);
end;

function TFhirLinkageList.Link: TFhirLinkageList;
begin
  result := TFhirLinkageList(inherited Link);
end;

procedure TFhirLinkageList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirLinkageList.SetItemByIndex(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  FhirLinkages[index] := value;
end;

procedure TFhirLinkageList.SetItemN(index: Integer; value: TFhirLinkage);
begin
  assert(value is TFhirLinkage);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LINKAGE}
{$IFDEF FHIR_LIST}
{ TFhirListEntry }

constructor TFhirListEntry.Create;
begin
  inherited;
end;

destructor TFhirListEntry.Destroy;
begin
  FFlag.free;
  FDeleted.free;
  FDate.free;
  FItem.free;
  inherited;
end;

procedure TFhirListEntry.Assign(oSource : TFslObject);
begin
  inherited;
  flag := TFhirListEntry(oSource).flag.Clone;
  deletedElement := TFhirListEntry(oSource).deletedElement.Clone;
  dateElement := TFhirListEntry(oSource).dateElement.Clone;
  item := TFhirListEntry(oSource).item.Clone;
end;

procedure TFhirListEntry.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'flag') Then
     list.add(self.link, 'flag', FFlag.Link);
  if (child_name = 'deleted') Then
     list.add(self.link, 'deleted', FDeleted.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'item') Then
     list.add(self.link, 'item', FItem.Link);
end;

procedure TFhirListEntry.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'flag', 'CodeableConcept', false, TFhirCodeableConcept, FFlag.Link));
  oList.add(TFHIRProperty.create(self, 'deleted', 'boolean', false, TFhirBoolean, FDeleted.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'Reference', false, TFhirReference, FItem.Link));
end;

function TFhirListEntry.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'flag') then
  begin
    Flag := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'deleted') then
  begin
    DeletedElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    Item := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirListEntry.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirListEntry.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'flag') then result := TFhirCodeableConcept.create()
  else if (propName = 'deleted') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'item') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirListEntry.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'flag') then result := 'CodeableConcept'
  else if (propName = 'deleted') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'item') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirListEntry.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := nil
  else if (propName = 'deleted') then DeletedElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'item') then ItemElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirListEntry.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'flag') then FlagElement := new as TFhirCodeableConcept
  else if (propName = 'deleted') then DeletedElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'item') then ItemElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirListEntry.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirListEntry.fhirType : string;
begin
  result := 'List.entry';
end;

function TFhirListEntry.Link : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Link);
end;

function TFhirListEntry.Clone : TFhirListEntry;
begin
  result := TFhirListEntry(inherited Clone);
end;

function TFhirListEntry.equals(other : TObject) : boolean; 
var
  o : TFhirListEntry;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirListEntry)) then
    result := false
  else
  begin
    o := TFhirListEntry(other);
    result := compareDeep(flagElement, o.flagElement, true) and compareDeep(deletedElement, o.deletedElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(itemElement, o.itemElement, true);
  end;
end;

function TFhirListEntry.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FFlag) and isEmptyProp(FDeleted) and isEmptyProp(FDate) and isEmptyProp(FItem);
end;

procedure TFhirListEntry.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('flag');
  fields.add('deleted');
  fields.add('date');
  fields.add('item');
end;

function TFhirListEntry.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirListEntry.SetFlag(value : TFhirCodeableConcept);
begin
  FFlag.free;
  FFlag := value;
end;

procedure TFhirListEntry.SetDeleted(value : TFhirBoolean);
begin
  FDeleted.free;
  FDeleted := value;
end;

function TFhirListEntry.GetDeletedST : Boolean;
begin
  if FDeleted = nil then
    result := false
  else
    result := FDeleted.value;
end;

procedure TFhirListEntry.SetDeletedST(value : Boolean);
begin
  if FDeleted = nil then
    FDeleted := TFhirBoolean.create;
  FDeleted.value := value
end;

procedure TFhirListEntry.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirListEntry.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirListEntry.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirListEntry.SetItem(value : TFhirReference);
begin
  FItem.free;
  FItem := value;
end;

{ TFhirListEntryListEnumerator }

constructor TFhirListEntryListEnumerator.Create(list : TFhirListEntryList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListEntryListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListEntryListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListEntryListEnumerator.GetCurrent : TFhirListEntry;
begin
  Result := FList[FIndex];
end;

function TFhirListEntryListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirListEntryList }

function TFhirListEntryList.AddItem(value: TFhirListEntry): TFhirListEntry;
begin
  assert(value.ClassName = 'TFhirListEntry', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirListEntry');
  add(value);
  result := value;
end;

function TFhirListEntryList.Append: TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.ClearItems;
begin
  Clear;
end;

function TFhirListEntryList.GetEnumerator : TFhirListEntryListEnumerator;
begin
  result := TFhirListEntryListEnumerator.Create(self.link);
end;

function TFhirListEntryList.Clone: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Clone);
end;

function TFhirListEntryList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListEntryList.GetItemN(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.ItemClass: TFslObjectClass;
begin
  result := TFhirListEntry;
end;
function TFhirListEntryList.IndexOf(value: TFhirListEntry): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListEntryList.Insert(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListEntryList.InsertItem(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  Inherited Insert(index, value);
end;

function TFhirListEntryList.Item(index: Integer): TFhirListEntry;
begin
  result := TFhirListEntry(ObjectByIndex[index]);
end;

function TFhirListEntryList.Link: TFhirListEntryList;
begin
  result := TFhirListEntryList(inherited Link);
end;

procedure TFhirListEntryList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListEntryList.SetItemByIndex(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  FhirListEntries[index] := value;
end;

procedure TFhirListEntryList.SetItemN(index: Integer; value: TFhirListEntry);
begin
  assert(value is TFhirListEntry);
  ObjectByIndex[index] := value;
end;

{ TFhirList }

constructor TFhirList.Create;
begin
  inherited;
end;

destructor TFhirList.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FMode.free;
  FTitle.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FDate.free;
  FSource.free;
  FOrderedBy.free;
  FNoteList.Free;
  FEntryList.Free;
  FEmptyReason.free;
  inherited;
end;

procedure TFhirList.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirList(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirList(oSource).FIdentifierList);
  end;
  statusElement := TFhirList(oSource).statusElement.Clone;
  modeElement := TFhirList(oSource).modeElement.Clone;
  titleElement := TFhirList(oSource).titleElement.Clone;
  code := TFhirList(oSource).code.Clone;
  subject := TFhirList(oSource).subject.Clone;
  encounter := TFhirList(oSource).encounter.Clone;
  dateElement := TFhirList(oSource).dateElement.Clone;
  source := TFhirList(oSource).source.Clone;
  orderedBy := TFhirList(oSource).orderedBy.Clone;
  if (TFhirList(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirList(oSource).FNoteList);
  end;
  if (TFhirList(oSource).FEntryList = nil) then
  begin
    FEntryList.free;
    FEntryList := nil;
  end
  else
  begin
    if FEntryList = nil then
      FEntryList := TFhirListEntryList.Create;
    FEntryList.Assign(TFhirList(oSource).FEntryList);
  end;
  emptyReason := TFhirList(oSource).emptyReason.Clone;
end;

function TFhirList.GetResourceType : TFhirResourceType;
begin
  result := frtList;
end;

procedure TFhirList.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'mode') Then
     list.add(self.link, 'mode', FMode.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'orderedBy') Then
     list.add(self.link, 'orderedBy', FOrderedBy.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'entry') Then
    list.addAll(self, 'entry', FEntryList);
  if (child_name = 'emptyReason') Then
     list.add(self.link, 'emptyReason', FEmptyReason.Link);
end;

procedure TFhirList.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'mode', 'code', false, TFhirEnum, FMode.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'orderedBy', 'CodeableConcept', false, TFhirCodeableConcept, FOrderedBy.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'entry', 'BackboneElement', true, TFhirListEntry, FEntryList.Link));
  oList.add(TFHIRProperty.create(self, 'emptyReason', 'CodeableConcept', false, TFhirCodeableConcept, FEmptyReason.Link));
end;

function TFhirList.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'mode') then
  begin
    ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'orderedBy') then
  begin
    OrderedBy := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'entry') then
  begin
    EntryList.add(propValue as TFhirListEntry);
    result := propValue;
  end
  else if (propName = 'emptyReason') then
  begin
    EmptyReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirList.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'entry') then EntryList.insertItem(index, propValue as TFhirListEntry)
  else inherited;
end;

function TFhirList.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirListStatusEnum[ListStatusNull], CODES_TFhirListStatusEnum[ListStatusNull]) 
  else if (propName = 'mode') then result := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[ListModeNull], CODES_TFhirListModeEnum[ListModeNull]) 
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'source') then result := TFhirReference.create()
  else if (propName = 'orderedBy') then result := TFhirCodeableConcept.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'entry') then result := EntryList.new()
  else if (propName = 'emptyReason') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirList.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'mode') then result := 'code'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'orderedBy') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'entry') then result := 'BackboneElement'
  else if (propName = 'emptyReason') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirList.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'mode') then ModeElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'orderedBy') then OrderedByElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'entry') then deletePropertyValue('entry', EntryList, value)
  else if (propName = 'emptyReason') then EmptyReasonElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirList.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirListStatusEnum, CODES_TFhirListStatusEnum, new)
  else if (propName = 'mode') then ModeElement := asEnum(SYSTEMS_TFhirListModeEnum, CODES_TFhirListModeEnum, new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else if (propName = 'orderedBy') then OrderedByElement := new as TFhirCodeableConcept
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'entry') then replacePropertyValue('entry', EntryList, existing, new)
  else if (propName = 'emptyReason') then EmptyReasonElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirList.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'entry') then EntryList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirList.fhirType : string;
begin
  result := 'List';
end;

function TFhirList.Link : TFhirList;
begin
  result := TFhirList(inherited Link);
end;

function TFhirList.Clone : TFhirList;
begin
  result := TFhirList(inherited Clone);
end;

function TFhirList.equals(other : TObject) : boolean; 
var
  o : TFhirList;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirList)) then
    result := false
  else
  begin
    o := TFhirList(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(modeElement, o.modeElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(codeElement, o.codeElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(sourceElement, o.sourceElement, true) and compareDeep(orderedByElement, o.orderedByElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(entryList, o.entryList, true) and 
      compareDeep(emptyReasonElement, o.emptyReasonElement, true);
  end;
end;

function TFhirList.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FMode) and isEmptyProp(FTitle) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FDate) and isEmptyProp(FSource) and isEmptyProp(FOrderedBy) and isEmptyProp(FnoteList) and isEmptyProp(FentryList) and isEmptyProp(FEmptyReason);
end;

procedure TFhirList.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('mode');
  fields.add('title');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('date');
  fields.add('source');
  fields.add('orderedBy');
  fields.add('note');
  fields.add('entry');
  fields.add('emptyReason');
end;

function TFhirList.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FEntryList.sizeInBytes(magic));
end;

function TFhirList.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirList.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirList.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirList.GetStatusST : TFhirListStatusEnum;
begin
  if FStatus = nil then
    result := TFhirListStatusEnum(0)
  else
    result := TFhirListStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirListStatusEnum, FStatus.value));
end;

procedure TFhirList.SetStatusST(value : TFhirListStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirListStatusEnum[value], CODES_TFhirListStatusEnum[value]);
end;

procedure TFhirList.SetMode(value : TFhirEnum);
begin
  FMode.free;
  FMode := value;
end;

function TFhirList.GetModeST : TFhirListModeEnum;
begin
  if FMode = nil then
    result := TFhirListModeEnum(0)
  else
    result := TFhirListModeEnum(StringArrayIndexOfSensitive(CODES_TFhirListModeEnum, FMode.value));
end;

procedure TFhirList.SetModeST(value : TFhirListModeEnum);
begin
  if ord(value) = 0 then
    ModeElement := nil
  else
    ModeElement := TFhirEnum.create(SYSTEMS_TFhirListModeEnum[value], CODES_TFhirListModeEnum[value]);
end;

procedure TFhirList.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirList.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirList.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirList.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirList.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirList.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirList.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirList.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirList.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirList.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirList.SetOrderedBy(value : TFhirCodeableConcept);
begin
  FOrderedBy.free;
  FOrderedBy := value;
end;

function TFhirList.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirList.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirList.GetEntryList : TFhirListEntryList;
begin
  if FEntryList = nil then
    FEntryList := TFhirListEntryList.Create;
  result := FEntryList;
end;

function TFhirList.GetHasEntryList : boolean;
begin
  result := (FEntryList <> nil) and (FEntryList.count > 0);
end;

procedure TFhirList.SetEmptyReason(value : TFhirCodeableConcept);
begin
  FEmptyReason.free;
  FEmptyReason := value;
end;

{ TFhirListListEnumerator }

constructor TFhirListListEnumerator.Create(list : TFhirListList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirListListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirListListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirListListEnumerator.GetCurrent : TFhirList;
begin
  Result := FList[FIndex];
end;

function TFhirListListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirListList }

function TFhirListList.AddItem(value: TFhirList): TFhirList;
begin
  assert(value.ClassName = 'TFhirList', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirList');
  add(value);
  result := value;
end;

function TFhirListList.Append: TFhirList;
begin
  result := TFhirList.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.ClearItems;
begin
  Clear;
end;

function TFhirListList.GetEnumerator : TFhirListListEnumerator;
begin
  result := TFhirListListEnumerator.Create(self.link);
end;

function TFhirListList.Clone: TFhirListList;
begin
  result := TFhirListList(inherited Clone);
end;

function TFhirListList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirListList.GetItemN(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.ItemClass: TFslObjectClass;
begin
  result := TFhirList;
end;
function TFhirListList.IndexOf(value: TFhirList): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirListList.Insert(index: Integer): TFhirList;
begin
  result := TFhirList.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirListList.InsertItem(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  Inherited Insert(index, value);
end;

function TFhirListList.Item(index: Integer): TFhirList;
begin
  result := TFhirList(ObjectByIndex[index]);
end;

function TFhirListList.Link: TFhirListList;
begin
  result := TFhirListList(inherited Link);
end;

procedure TFhirListList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirListList.SetItemByIndex(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  FhirLists[index] := value;
end;

procedure TFhirListList.SetItemN(index: Integer; value: TFhirList);
begin
  assert(value is TFhirList);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_LIST}
{$IFDEF FHIR_MEASUREREPORT}
{ TFhirMeasureReportGroup }

constructor TFhirMeasureReportGroup.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroup.Destroy;
begin
  FCode.free;
  FPopulationList.Free;
  FMeasureScore.free;
  FStratifierList.Free;
  inherited;
end;

procedure TFhirMeasureReportGroup.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroup(oSource).code.Clone;
  if (TFhirMeasureReportGroup(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureReportGroupPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureReportGroup(oSource).FPopulationList);
  end;
  measureScore := TFhirMeasureReportGroup(oSource).measureScore.Clone;
  if (TFhirMeasureReportGroup(oSource).FStratifierList = nil) then
  begin
    FStratifierList.free;
    FStratifierList := nil;
  end
  else
  begin
    if FStratifierList = nil then
      FStratifierList := TFhirMeasureReportGroupStratifierList.Create;
    FStratifierList.Assign(TFhirMeasureReportGroup(oSource).FStratifierList);
  end;
end;

procedure TFhirMeasureReportGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'measureScore') Then
     list.add(self.link, 'measureScore', FMeasureScore.Link);
  if (child_name = 'stratifier') Then
    list.addAll(self, 'stratifier', FStratifierList);
end;

procedure TFhirMeasureReportGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'population', 'BackboneElement', true, TFhirMeasureReportGroupPopulation, FPopulationList.Link));
  oList.add(TFHIRProperty.create(self, 'measureScore', 'Quantity', false, TFhirQuantity, FMeasureScore.Link));
  oList.add(TFHIRProperty.create(self, 'stratifier', 'BackboneElement', true, TFhirMeasureReportGroupStratifier, FStratifierList.Link));
end;

function TFhirMeasureReportGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureReportGroupPopulation);
    result := propValue;
  end
  else if (propName = 'measureScore') then
  begin
    MeasureScore := propValue as TFhirQuantity;
    result := propValue;
  end
  else if (propName = 'stratifier') then
  begin
    StratifierList.add(propValue as TFhirMeasureReportGroupStratifier);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureReportGroupPopulation)
  else if (propName = 'stratifier') then StratifierList.insertItem(index, propValue as TFhirMeasureReportGroupStratifier)
  else inherited;
end;

function TFhirMeasureReportGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'population') then result := PopulationList.new()
  else if (propName = 'measureScore') then result := TFhirQuantity.create()
  else if (propName = 'stratifier') then result := StratifierList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'population') then result := 'BackboneElement'
  else if (propName = 'measureScore') then result := 'Quantity'
  else if (propName = 'stratifier') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value)
  else if (propName = 'measureScore') then MeasureScoreElement := nil
  else if (propName = 'stratifier') then deletePropertyValue('stratifier', StratifierList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new)
  else if (propName = 'measureScore') then MeasureScoreElement := new as TFhirQuantity
  else if (propName = 'stratifier') then replacePropertyValue('stratifier', StratifierList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'population') then PopulationList.move(source, destination)
  else if (propName = 'stratifier') then StratifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroup.fhirType : string;
begin
  result := 'MeasureReport.group';
end;

function TFhirMeasureReportGroup.Link : TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(inherited Link);
end;

function TFhirMeasureReportGroup.Clone : TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(inherited Clone);
end;

function TFhirMeasureReportGroup.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroup)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroup(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(populationList, o.populationList, true) and 
      compareDeep(measureScoreElement, o.measureScoreElement, true) and compareDeep(stratifierList, o.stratifierList, true);
  end;
end;

function TFhirMeasureReportGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FpopulationList) and isEmptyProp(FMeasureScore) and isEmptyProp(FstratifierList);
end;

procedure TFhirMeasureReportGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('population');
  fields.add('measureScore');
  fields.add('stratifier');
end;

function TFhirMeasureReportGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPopulationList.sizeInBytes(magic));
  inc(result, FStratifierList.sizeInBytes(magic));
end;

procedure TFhirMeasureReportGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

function TFhirMeasureReportGroup.GetPopulationList : TFhirMeasureReportGroupPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureReportGroupPopulationList.Create;
  result := FPopulationList;
end;

function TFhirMeasureReportGroup.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

procedure TFhirMeasureReportGroup.SetMeasureScore(value : TFhirQuantity);
begin
  FMeasureScore.free;
  FMeasureScore := value;
end;

function TFhirMeasureReportGroup.GetStratifierList : TFhirMeasureReportGroupStratifierList;
begin
  if FStratifierList = nil then
    FStratifierList := TFhirMeasureReportGroupStratifierList.Create;
  result := FStratifierList;
end;

function TFhirMeasureReportGroup.GetHasStratifierList : boolean;
begin
  result := (FStratifierList <> nil) and (FStratifierList.count > 0);
end;

{ TFhirMeasureReportGroupListEnumerator }

constructor TFhirMeasureReportGroupListEnumerator.Create(list : TFhirMeasureReportGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupListEnumerator.GetCurrent : TFhirMeasureReportGroup;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupList }

function TFhirMeasureReportGroupList.AddItem(value: TFhirMeasureReportGroup): TFhirMeasureReportGroup;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroup');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupList.Append: TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupList.GetEnumerator : TFhirMeasureReportGroupListEnumerator;
begin
  result := TFhirMeasureReportGroupListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupList.Clone: TFhirMeasureReportGroupList;
begin
  result := TFhirMeasureReportGroupList(inherited Clone);
end;

function TFhirMeasureReportGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupList.GetItemN(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroup;
end;
function TFhirMeasureReportGroupList.IndexOf(value: TFhirMeasureReportGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupList.Insert(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupList.InsertItem(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupList.Item(index: Integer): TFhirMeasureReportGroup;
begin
  result := TFhirMeasureReportGroup(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupList.Link: TFhirMeasureReportGroupList;
begin
  result := TFhirMeasureReportGroupList(inherited Link);
end;

procedure TFhirMeasureReportGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  FhirMeasureReportGroups[index] := value;
end;

procedure TFhirMeasureReportGroupList.SetItemN(index: Integer; value: TFhirMeasureReportGroup);
begin
  assert(value is TFhirMeasureReportGroup);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupPopulation }

constructor TFhirMeasureReportGroupPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupPopulation.Destroy;
begin
  FCode.free;
  FCount.free;
  FSubjectResults.free;
  inherited;
end;

procedure TFhirMeasureReportGroupPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupPopulation(oSource).code.Clone;
  countElement := TFhirMeasureReportGroupPopulation(oSource).countElement.Clone;
  subjectResults := TFhirMeasureReportGroupPopulation(oSource).subjectResults.Clone;
end;

procedure TFhirMeasureReportGroupPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'subjectResults') Then
     list.add(self.link, 'subjectResults', FSubjectResults.Link);
end;

procedure TFhirMeasureReportGroupPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));
  oList.add(TFHIRProperty.create(self, 'subjectResults', 'Reference', false, TFhirReference, FSubjectResults.Link));
end;

function TFhirMeasureReportGroupPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'subjectResults') then
  begin
    SubjectResults := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'count') then result := TFhirInteger.create()
  else if (propName = 'subjectResults') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'count') then result := 'integer'
  else if (propName = 'subjectResults') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'subjectResults') then SubjectResultsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'count') then CountElement := asInteger(new)
  else if (propName = 'subjectResults') then SubjectResultsElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupPopulation.fhirType : string;
begin
  result := 'MeasureReport.group.population';
end;

function TFhirMeasureReportGroupPopulation.Link : TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(inherited Link);
end;

function TFhirMeasureReportGroupPopulation.Clone : TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(inherited Clone);
end;

function TFhirMeasureReportGroupPopulation.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupPopulation(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(countElement, o.countElement, true) and 
      compareDeep(subjectResultsElement, o.subjectResultsElement, true);
  end;
end;

function TFhirMeasureReportGroupPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCount) and isEmptyProp(FSubjectResults);
end;

procedure TFhirMeasureReportGroupPopulation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('count');
  fields.add('subjectResults');
end;

function TFhirMeasureReportGroupPopulation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMeasureReportGroupPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureReportGroupPopulation.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

function TFhirMeasureReportGroupPopulation.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

procedure TFhirMeasureReportGroupPopulation.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

procedure TFhirMeasureReportGroupPopulation.SetSubjectResults(value : TFhirReference);
begin
  FSubjectResults.free;
  FSubjectResults := value;
end;

{ TFhirMeasureReportGroupPopulationListEnumerator }

constructor TFhirMeasureReportGroupPopulationListEnumerator.Create(list : TFhirMeasureReportGroupPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupPopulationListEnumerator.GetCurrent : TFhirMeasureReportGroupPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupPopulationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupPopulationList }

function TFhirMeasureReportGroupPopulationList.AddItem(value: TFhirMeasureReportGroupPopulation): TFhirMeasureReportGroupPopulation;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupPopulation');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupPopulationList.Append: TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupPopulationList.GetEnumerator : TFhirMeasureReportGroupPopulationListEnumerator;
begin
  result := TFhirMeasureReportGroupPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupPopulationList.Clone: TFhirMeasureReportGroupPopulationList;
begin
  result := TFhirMeasureReportGroupPopulationList(inherited Clone);
end;

function TFhirMeasureReportGroupPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupPopulationList.GetItemN(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupPopulation;
end;
function TFhirMeasureReportGroupPopulationList.IndexOf(value: TFhirMeasureReportGroupPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupPopulationList.Insert(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupPopulationList.InsertItem(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupPopulationList.Item(index: Integer): TFhirMeasureReportGroupPopulation;
begin
  result := TFhirMeasureReportGroupPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupPopulationList.Link: TFhirMeasureReportGroupPopulationList;
begin
  result := TFhirMeasureReportGroupPopulationList(inherited Link);
end;

procedure TFhirMeasureReportGroupPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  FhirMeasureReportGroupPopulations[index] := value;
end;

procedure TFhirMeasureReportGroupPopulationList.SetItemN(index: Integer; value: TFhirMeasureReportGroupPopulation);
begin
  assert(value is TFhirMeasureReportGroupPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifier }

constructor TFhirMeasureReportGroupStratifier.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifier.Destroy;
begin
  FCodeList.Free;
  FStratumList.Free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifier.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMeasureReportGroupStratifier(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirMeasureReportGroupStratifier(oSource).FCodeList);
  end;
  if (TFhirMeasureReportGroupStratifier(oSource).FStratumList = nil) then
  begin
    FStratumList.free;
    FStratumList := nil;
  end
  else
  begin
    if FStratumList = nil then
      FStratumList := TFhirMeasureReportGroupStratifierStratumList.Create;
    FStratumList.Assign(TFhirMeasureReportGroupStratifier(oSource).FStratumList);
  end;
end;

procedure TFhirMeasureReportGroupStratifier.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'stratum') Then
    list.addAll(self, 'stratum', FStratumList);
end;

procedure TFhirMeasureReportGroupStratifier.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'stratum', 'BackboneElement', true, TFhirMeasureReportGroupStratifierStratum, FStratumList.Link));
end;

function TFhirMeasureReportGroupStratifier.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'stratum') then
  begin
    StratumList.add(propValue as TFhirMeasureReportGroupStratifierStratum);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifier.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'stratum') then StratumList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratum)
  else inherited;
end;

function TFhirMeasureReportGroupStratifier.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := CodeList.new()
  else if (propName = 'stratum') then result := StratumList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifier.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'stratum') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifier.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'stratum') then deletePropertyValue('stratum', StratumList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifier.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'stratum') then replacePropertyValue('stratum', StratumList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifier.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'stratum') then StratumList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifier.fhirType : string;
begin
  result := 'MeasureReport.group.stratifier';
end;

function TFhirMeasureReportGroupStratifier.Link : TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(inherited Link);
end;

function TFhirMeasureReportGroupStratifier.Clone : TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(inherited Clone);
end;

function TFhirMeasureReportGroupStratifier.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifier;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifier)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifier(other);
    result := compareDeep(codeList, o.codeList, true) and compareDeep(stratumList, o.stratumList, true);
  end;
end;

function TFhirMeasureReportGroupStratifier.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FcodeList) and isEmptyProp(FstratumList);
end;

procedure TFhirMeasureReportGroupStratifier.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('stratum');
end;

function TFhirMeasureReportGroupStratifier.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FStratumList.sizeInBytes(magic));
end;

function TFhirMeasureReportGroupStratifier.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirMeasureReportGroupStratifier.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirMeasureReportGroupStratifier.GetStratumList : TFhirMeasureReportGroupStratifierStratumList;
begin
  if FStratumList = nil then
    FStratumList := TFhirMeasureReportGroupStratifierStratumList.Create;
  result := FStratumList;
end;

function TFhirMeasureReportGroupStratifier.GetHasStratumList : boolean;
begin
  result := (FStratumList <> nil) and (FStratumList.count > 0);
end;

{ TFhirMeasureReportGroupStratifierListEnumerator }

constructor TFhirMeasureReportGroupStratifierListEnumerator.Create(list : TFhirMeasureReportGroupStratifierList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifier;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupStratifierList }

function TFhirMeasureReportGroupStratifierList.AddItem(value: TFhirMeasureReportGroupStratifier): TFhirMeasureReportGroupStratifier;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifier', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifier');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupStratifierList.Append: TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierList.GetEnumerator : TFhirMeasureReportGroupStratifierListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierList.Clone: TFhirMeasureReportGroupStratifierList;
begin
  result := TFhirMeasureReportGroupStratifierList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifier;
end;
function TFhirMeasureReportGroupStratifierList.IndexOf(value: TFhirMeasureReportGroupStratifier): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierList.Insert(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierList.Item(index: Integer): TFhirMeasureReportGroupStratifier;
begin
  result := TFhirMeasureReportGroupStratifier(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierList.Link: TFhirMeasureReportGroupStratifierList;
begin
  result := TFhirMeasureReportGroupStratifierList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  FhirMeasureReportGroupStratifiers[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifier);
begin
  assert(value is TFhirMeasureReportGroupStratifier);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratum }

constructor TFhirMeasureReportGroupStratifierStratum.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratum.Destroy;
begin
  FValue.free;
  FComponentList.Free;
  FPopulationList.Free;
  FMeasureScore.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratum.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirMeasureReportGroupStratifierStratum(oSource).value.Clone;
  if (TFhirMeasureReportGroupStratifierStratum(oSource).FComponentList = nil) then
  begin
    FComponentList.free;
    FComponentList := nil;
  end
  else
  begin
    if FComponentList = nil then
      FComponentList := TFhirMeasureReportGroupStratifierStratumComponentList.Create;
    FComponentList.Assign(TFhirMeasureReportGroupStratifierStratum(oSource).FComponentList);
  end;
  if (TFhirMeasureReportGroupStratifierStratum(oSource).FPopulationList = nil) then
  begin
    FPopulationList.free;
    FPopulationList := nil;
  end
  else
  begin
    if FPopulationList = nil then
      FPopulationList := TFhirMeasureReportGroupStratifierStratumPopulationList.Create;
    FPopulationList.Assign(TFhirMeasureReportGroupStratifierStratum(oSource).FPopulationList);
  end;
  measureScore := TFhirMeasureReportGroupStratifierStratum(oSource).measureScore.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratum.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
  if (child_name = 'component') Then
    list.addAll(self, 'component', FComponentList);
  if (child_name = 'population') Then
    list.addAll(self, 'population', FPopulationList);
  if (child_name = 'measureScore') Then
     list.add(self.link, 'measureScore', FMeasureScore.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratum.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value', 'CodeableConcept', false, TFhirCodeableConcept, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'component', 'BackboneElement', true, TFhirMeasureReportGroupStratifierStratumComponent, FComponentList.Link));
  oList.add(TFHIRProperty.create(self, 'population', 'BackboneElement', true, TFhirMeasureReportGroupStratifierStratumPopulation, FPopulationList.Link));
  oList.add(TFHIRProperty.create(self, 'measureScore', 'Quantity', false, TFhirQuantity, FMeasureScore.Link));
end;

function TFhirMeasureReportGroupStratifierStratum.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'value') then
  begin
    Value := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'component') then
  begin
    ComponentList.add(propValue as TFhirMeasureReportGroupStratifierStratumComponent);
    result := propValue;
  end
  else if (propName = 'population') then
  begin
    PopulationList.add(propValue as TFhirMeasureReportGroupStratifierStratumPopulation);
    result := propValue;
  end
  else if (propName = 'measureScore') then
  begin
    MeasureScore := propValue as TFhirQuantity;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratum.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'component') then ComponentList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratumComponent)
  else if (propName = 'population') then PopulationList.insertItem(index, propValue as TFhirMeasureReportGroupStratifierStratumPopulation)
  else inherited;
end;

function TFhirMeasureReportGroupStratifierStratum.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'value') then result := TFhirCodeableConcept.create()
  else if (propName = 'component') then result := ComponentList.new()
  else if (propName = 'population') then result := PopulationList.new()
  else if (propName = 'measureScore') then result := TFhirQuantity.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratum.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value') then result := 'CodeableConcept'
  else if (propName = 'component') then result := 'BackboneElement'
  else if (propName = 'population') then result := 'BackboneElement'
  else if (propName = 'measureScore') then result := 'Quantity'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratum.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := nil
  else if (propName = 'component') then deletePropertyValue('component', ComponentList, value)
  else if (propName = 'population') then deletePropertyValue('population', PopulationList, value)
  else if (propName = 'measureScore') then MeasureScoreElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratum.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'value') then ValueElement := new as TFhirCodeableConcept
  else if (propName = 'component') then replacePropertyValue('component', ComponentList, existing, new)
  else if (propName = 'population') then replacePropertyValue('population', PopulationList, existing, new)
  else if (propName = 'measureScore') then MeasureScoreElement := new as TFhirQuantity
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratum.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'component') then ComponentList.move(source, destination)
  else if (propName = 'population') then PopulationList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratum.fhirType : string;
begin
  result := 'MeasureReport.group.stratifier.stratum';
end;

function TFhirMeasureReportGroupStratifierStratum.Link : TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratum.Clone : TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratum.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifierStratum;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratum)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratum(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(componentList, o.componentList, true) and 
      compareDeep(populationList, o.populationList, true) and compareDeep(measureScoreElement, o.measureScoreElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratum.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FcomponentList) and isEmptyProp(FpopulationList) and isEmptyProp(FMeasureScore);
end;

procedure TFhirMeasureReportGroupStratifierStratum.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('value');
  fields.add('component');
  fields.add('population');
  fields.add('measureScore');
end;

function TFhirMeasureReportGroupStratifierStratum.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FComponentList.sizeInBytes(magic));
  inc(result, FPopulationList.sizeInBytes(magic));
end;

procedure TFhirMeasureReportGroupStratifierStratum.SetValue(value : TFhirCodeableConcept);
begin
  FValue.free;
  FValue := value;
end;

function TFhirMeasureReportGroupStratifierStratum.GetComponentList : TFhirMeasureReportGroupStratifierStratumComponentList;
begin
  if FComponentList = nil then
    FComponentList := TFhirMeasureReportGroupStratifierStratumComponentList.Create;
  result := FComponentList;
end;

function TFhirMeasureReportGroupStratifierStratum.GetHasComponentList : boolean;
begin
  result := (FComponentList <> nil) and (FComponentList.count > 0);
end;

function TFhirMeasureReportGroupStratifierStratum.GetPopulationList : TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  if FPopulationList = nil then
    FPopulationList := TFhirMeasureReportGroupStratifierStratumPopulationList.Create;
  result := FPopulationList;
end;

function TFhirMeasureReportGroupStratifierStratum.GetHasPopulationList : boolean;
begin
  result := (FPopulationList <> nil) and (FPopulationList.count > 0);
end;

procedure TFhirMeasureReportGroupStratifierStratum.SetMeasureScore(value : TFhirQuantity);
begin
  FMeasureScore.free;
  FMeasureScore := value;
end;

{ TFhirMeasureReportGroupStratifierStratumListEnumerator }

constructor TFhirMeasureReportGroupStratifierStratumListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratum;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupStratifierStratumList }

function TFhirMeasureReportGroupStratifierStratumList.AddItem(value: TFhirMeasureReportGroupStratifierStratum): TFhirMeasureReportGroupStratifierStratum;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratum', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratum');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupStratifierStratumList.Append: TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumList.Clone: TFhirMeasureReportGroupStratifierStratumList;
begin
  result := TFhirMeasureReportGroupStratifierStratumList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratum;
end;
function TFhirMeasureReportGroupStratifierStratumList.IndexOf(value: TFhirMeasureReportGroupStratifierStratum): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratum;
begin
  result := TFhirMeasureReportGroupStratifierStratum(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumList.Link: TFhirMeasureReportGroupStratifierStratumList;
begin
  result := TFhirMeasureReportGroupStratifierStratumList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  FhirMeasureReportGroupStratifierStrata[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratum);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratum);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratumComponent }

constructor TFhirMeasureReportGroupStratifierStratumComponent.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratumComponent.Destroy;
begin
  FCode.free;
  FValue.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupStratifierStratumComponent(oSource).code.Clone;
  value := TFhirMeasureReportGroupStratifierStratumComponent(oSource).value.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'value') Then
     list.add(self.link, 'value', FValue.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'value', 'CodeableConcept', false, TFhirCodeableConcept, FValue.Link));
end;

function TFhirMeasureReportGroupStratifierStratumComponent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'value') then
  begin
    Value := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumComponent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'value') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'value') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'value') then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'value') then ValueElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.fhirType : string;
begin
  result := 'MeasureReport.group.stratifier.stratum.component';
end;

function TFhirMeasureReportGroupStratifierStratumComponent.Link : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.Clone : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumComponent.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratumComponent)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratumComponent(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratumComponent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('value');
end;

function TFhirMeasureReportGroupStratifierStratumComponent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponent.SetValue(value : TFhirCodeableConcept);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirMeasureReportGroupStratifierStratumComponentListEnumerator }

constructor TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumComponentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratumComponent;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupStratifierStratumComponentList }

function TFhirMeasureReportGroupStratifierStratumComponentList.AddItem(value: TFhirMeasureReportGroupStratifierStratumComponent): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratumComponent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratumComponent');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Append: TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumComponentListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponentListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Clone: TFhirMeasureReportGroupStratifierStratumComponentList;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponentList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent;
end;
function TFhirMeasureReportGroupStratifierStratumComponentList.IndexOf(value: TFhirMeasureReportGroupStratifierStratumComponent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumComponent);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratumComponent;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponent(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumComponentList.Link: TFhirMeasureReportGroupStratifierStratumComponentList;
begin
  result := TFhirMeasureReportGroupStratifierStratumComponentList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumComponent);
  FhirMeasureReportGroupStratifierStratumComponents[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumComponentList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratumComponent);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumComponent);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReportGroupStratifierStratumPopulation }

constructor TFhirMeasureReportGroupStratifierStratumPopulation.Create;
begin
  inherited;
end;

destructor TFhirMeasureReportGroupStratifierStratumPopulation.Destroy;
begin
  FCode.free;
  FCount.free;
  FSubjectResults.free;
  inherited;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.Assign(oSource : TFslObject);
begin
  inherited;
  code := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).code.Clone;
  countElement := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).countElement.Clone;
  subjectResults := TFhirMeasureReportGroupStratifierStratumPopulation(oSource).subjectResults.Clone;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'count') Then
     list.add(self.link, 'count', FCount.Link);
  if (child_name = 'subjectResults') Then
     list.add(self.link, 'subjectResults', FSubjectResults.Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'count', 'integer', false, TFhirInteger, FCount.Link));
  oList.add(TFHIRProperty.create(self, 'subjectResults', 'Reference', false, TFhirReference, FSubjectResults.Link));
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'count') then
  begin
    CountElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'subjectResults') then
  begin
    SubjectResults := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'count') then result := TFhirInteger.create()
  else if (propName = 'subjectResults') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'count') then result := 'integer'
  else if (propName = 'subjectResults') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := nil
  else if (propName = 'count') then CountElement := nil
  else if (propName = 'subjectResults') then SubjectResultsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'count') then CountElement := asInteger(new)
  else if (propName = 'subjectResults') then SubjectResultsElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.fhirType : string;
begin
  result := 'MeasureReport.group.stratifier.stratum.population';
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.Link : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(inherited Link);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.Clone : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReportGroupStratifierStratumPopulation)) then
    result := false
  else
  begin
    o := TFhirMeasureReportGroupStratifierStratumPopulation(other);
    result := compareDeep(codeElement, o.codeElement, true) and compareDeep(countElement, o.countElement, true) and 
      compareDeep(subjectResultsElement, o.subjectResultsElement, true);
  end;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCode) and isEmptyProp(FCount) and isEmptyProp(FSubjectResults);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('code');
  fields.add('count');
  fields.add('subjectResults');
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCount(value : TFhirInteger);
begin
  FCount.free;
  FCount := value;
end;

function TFhirMeasureReportGroupStratifierStratumPopulation.GetCountST : String;
begin
  if FCount = nil then
    result := ''
  else
    result := FCount.value;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetCountST(value : String);
begin
  if value <> '' then
  begin
    if FCount = nil then
      FCount := TFhirInteger.create;
    FCount.value := value
  end
  else if FCount <> nil then
    FCount.value := '';
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulation.SetSubjectResults(value : TFhirReference);
begin
  FSubjectResults.free;
  FSubjectResults := value;
end;

{ TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator }

constructor TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Create(list : TFhirMeasureReportGroupStratifierStratumPopulationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.GetCurrent : TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportGroupStratifierStratumPopulationList }

function TFhirMeasureReportGroupStratifierStratumPopulationList.AddItem(value: TFhirMeasureReportGroupStratifierStratumPopulation): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  assert(value.ClassName = 'TFhirMeasureReportGroupStratifierStratumPopulation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReportGroupStratifierStratumPopulation');
  add(value);
  result := value;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Append: TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.GetEnumerator : TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationListEnumerator.Create(self.link);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Clone: TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationList(inherited Clone);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.GetItemN(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation;
end;
function TFhirMeasureReportGroupStratifierStratumPopulationList.IndexOf(value: TFhirMeasureReportGroupStratifierStratumPopulation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Insert(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.InsertItem(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Item(index: Integer): TFhirMeasureReportGroupStratifierStratumPopulation;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulation(ObjectByIndex[index]);
end;

function TFhirMeasureReportGroupStratifierStratumPopulationList.Link: TFhirMeasureReportGroupStratifierStratumPopulationList;
begin
  result := TFhirMeasureReportGroupStratifierStratumPopulationList(inherited Link);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.SetItemByIndex(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  FhirMeasureReportGroupStratifierStratumPopulations[index] := value;
end;

procedure TFhirMeasureReportGroupStratifierStratumPopulationList.SetItemN(index: Integer; value: TFhirMeasureReportGroupStratifierStratumPopulation);
begin
  assert(value is TFhirMeasureReportGroupStratifierStratumPopulation);
  ObjectByIndex[index] := value;
end;

{ TFhirMeasureReport }

constructor TFhirMeasureReport.Create;
begin
  inherited;
end;

destructor TFhirMeasureReport.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FType_.free;
  FMeasure.free;
  FSubject.free;
  FDate.free;
  FReporter.free;
  FPeriod.free;
  FImprovementNotation.free;
  FGroupList.Free;
  FEvaluatedResourceList.Free;
  inherited;
end;

procedure TFhirMeasureReport.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirMeasureReport(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirMeasureReport(oSource).FIdentifierList);
  end;
  statusElement := TFhirMeasureReport(oSource).statusElement.Clone;
  type_Element := TFhirMeasureReport(oSource).type_Element.Clone;
  measureElement := TFhirMeasureReport(oSource).measureElement.Clone;
  subject := TFhirMeasureReport(oSource).subject.Clone;
  dateElement := TFhirMeasureReport(oSource).dateElement.Clone;
  reporter := TFhirMeasureReport(oSource).reporter.Clone;
  period := TFhirMeasureReport(oSource).period.Clone;
  improvementNotation := TFhirMeasureReport(oSource).improvementNotation.Clone;
  if (TFhirMeasureReport(oSource).FGroupList = nil) then
  begin
    FGroupList.free;
    FGroupList := nil;
  end
  else
  begin
    if FGroupList = nil then
      FGroupList := TFhirMeasureReportGroupList.Create;
    FGroupList.Assign(TFhirMeasureReport(oSource).FGroupList);
  end;
  if (TFhirMeasureReport(oSource).FEvaluatedResourceList = nil) then
  begin
    FEvaluatedResourceList.free;
    FEvaluatedResourceList := nil;
  end
  else
  begin
    if FEvaluatedResourceList = nil then
      FEvaluatedResourceList := TFhirReferenceList.Create;
    FEvaluatedResourceList.Assign(TFhirMeasureReport(oSource).FEvaluatedResourceList);
  end;
end;

function TFhirMeasureReport.GetResourceType : TFhirResourceType;
begin
  result := frtMeasureReport;
end;

procedure TFhirMeasureReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'reporter') Then
     list.add(self.link, 'reporter', FReporter.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'improvementNotation') Then
     list.add(self.link, 'improvementNotation', FImprovementNotation.Link);
  if (child_name = 'group') Then
    list.addAll(self, 'group', FGroupList);
  if (child_name = 'evaluatedResource') Then
    list.addAll(self, 'evaluatedResource', FEvaluatedResourceList);
end;

procedure TFhirMeasureReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'measure', 'canonical', false, TFhirCanonical, FMeasure.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'reporter', 'Reference', false, TFhirReference, FReporter.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'improvementNotation', 'CodeableConcept', false, TFhirCodeableConcept, FImprovementNotation.Link));
  oList.add(TFHIRProperty.create(self, 'group', 'BackboneElement', true, TFhirMeasureReportGroup, FGroupList.Link));
  oList.add(TFHIRProperty.create(self, 'evaluatedResource', 'Reference', true, TFhirReference, FEvaluatedResourceList.Link));
end;

function TFhirMeasureReport.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirMeasureReportStatusEnum, CODES_TFhirMeasureReportStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirMeasureReportTypeEnum, CODES_TFhirMeasureReportTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'measure') then
  begin
    MeasureElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'reporter') then
  begin
    Reporter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'improvementNotation') then
  begin
    ImprovementNotation := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'group') then
  begin
    GroupList.add(propValue as TFhirMeasureReportGroup);
    result := propValue;
  end
  else if (propName = 'evaluatedResource') then
  begin
    EvaluatedResourceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMeasureReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'group') then GroupList.insertItem(index, propValue as TFhirMeasureReportGroup)
  else if (propName = 'evaluatedResource') then EvaluatedResourceList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMeasureReport.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirMeasureReportStatusEnum[MeasureReportStatusNull], CODES_TFhirMeasureReportStatusEnum[MeasureReportStatusNull]) 
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirMeasureReportTypeEnum[MeasureReportTypeNull], CODES_TFhirMeasureReportTypeEnum[MeasureReportTypeNull]) 
  else if (propName = 'measure') then result := TFhirCanonical.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'reporter') then result := TFhirReference.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'improvementNotation') then result := TFhirCodeableConcept.create()
  else if (propName = 'group') then result := GroupList.new()
  else if (propName = 'evaluatedResource') then result := EvaluatedResourceList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMeasureReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'measure') then result := 'canonical'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'reporter') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'improvementNotation') then result := 'CodeableConcept'
  else if (propName = 'group') then result := 'BackboneElement'
  else if (propName = 'evaluatedResource') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMeasureReport.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'measure') then MeasureElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'reporter') then ReporterElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'improvementNotation') then ImprovementNotationElement := nil
  else if (propName = 'group') then deletePropertyValue('group', GroupList, value)
  else if (propName = 'evaluatedResource') then deletePropertyValue('evaluatedResource', EvaluatedResourceList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMeasureReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirMeasureReportStatusEnum, CODES_TFhirMeasureReportStatusEnum, new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirMeasureReportTypeEnum, CODES_TFhirMeasureReportTypeEnum, new)
  else if (propName = 'measure') then MeasureElement := asCanonical(new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'reporter') then ReporterElement := new as TFhirReference
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'improvementNotation') then ImprovementNotationElement := new as TFhirCodeableConcept
  else if (propName = 'group') then replacePropertyValue('group', GroupList, existing, new)
  else if (propName = 'evaluatedResource') then replacePropertyValue('evaluatedResource', EvaluatedResourceList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMeasureReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'group') then GroupList.move(source, destination)
  else if (propName = 'evaluatedResource') then EvaluatedResourceList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMeasureReport.fhirType : string;
begin
  result := 'MeasureReport';
end;

function TFhirMeasureReport.Link : TFhirMeasureReport;
begin
  result := TFhirMeasureReport(inherited Link);
end;

function TFhirMeasureReport.Clone : TFhirMeasureReport;
begin
  result := TFhirMeasureReport(inherited Clone);
end;

function TFhirMeasureReport.equals(other : TObject) : boolean; 
var
  o : TFhirMeasureReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMeasureReport)) then
    result := false
  else
  begin
    o := TFhirMeasureReport(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(measureElement, o.measureElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(reporterElement, o.reporterElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(improvementNotationElement, o.improvementNotationElement, true) and 
      compareDeep(groupList, o.groupList, true) and compareDeep(evaluatedResourceList, o.evaluatedResourceList, true);
  end;
end;

function TFhirMeasureReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FMeasure) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FReporter) and isEmptyProp(FPeriod) and isEmptyProp(FImprovementNotation) and isEmptyProp(FgroupList) and isEmptyProp(FevaluatedResourceList);
end;

procedure TFhirMeasureReport.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('type');
  fields.add('measure');
  fields.add('subject');
  fields.add('date');
  fields.add('reporter');
  fields.add('period');
  fields.add('improvementNotation');
  fields.add('group');
  fields.add('evaluatedResource');
end;

function TFhirMeasureReport.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FGroupList.sizeInBytes(magic));
  inc(result, FEvaluatedResourceList.sizeInBytes(magic));
end;

function TFhirMeasureReport.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirMeasureReport.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirMeasureReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirMeasureReport.GetStatusST : TFhirMeasureReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirMeasureReportStatusEnum(0)
  else
    result := TFhirMeasureReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirMeasureReportStatusEnum, FStatus.value));
end;

procedure TFhirMeasureReport.SetStatusST(value : TFhirMeasureReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirMeasureReportStatusEnum[value], CODES_TFhirMeasureReportStatusEnum[value]);
end;

procedure TFhirMeasureReport.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirMeasureReport.GetType_ST : TFhirMeasureReportTypeEnum;
begin
  if FType_ = nil then
    result := TFhirMeasureReportTypeEnum(0)
  else
    result := TFhirMeasureReportTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirMeasureReportTypeEnum, FType_.value));
end;

procedure TFhirMeasureReport.SetType_ST(value : TFhirMeasureReportTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirMeasureReportTypeEnum[value], CODES_TFhirMeasureReportTypeEnum[value]);
end;

procedure TFhirMeasureReport.SetMeasure(value : TFhirCanonical);
begin
  FMeasure.free;
  FMeasure := value;
end;

function TFhirMeasureReport.GetMeasureST : String;
begin
  if FMeasure = nil then
    result := ''
  else
    result := FMeasure.value;
end;

procedure TFhirMeasureReport.SetMeasureST(value : String);
begin
  if value <> '' then
  begin
    if FMeasure = nil then
      FMeasure := TFhirCanonical.create;
    FMeasure.value := value
  end
  else if FMeasure <> nil then
    FMeasure.value := '';
end;

procedure TFhirMeasureReport.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirMeasureReport.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirMeasureReport.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirMeasureReport.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirMeasureReport.SetReporter(value : TFhirReference);
begin
  FReporter.free;
  FReporter := value;
end;

procedure TFhirMeasureReport.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirMeasureReport.SetImprovementNotation(value : TFhirCodeableConcept);
begin
  FImprovementNotation.free;
  FImprovementNotation := value;
end;

function TFhirMeasureReport.GetGroupList : TFhirMeasureReportGroupList;
begin
  if FGroupList = nil then
    FGroupList := TFhirMeasureReportGroupList.Create;
  result := FGroupList;
end;

function TFhirMeasureReport.GetHasGroupList : boolean;
begin
  result := (FGroupList <> nil) and (FGroupList.count > 0);
end;

function TFhirMeasureReport.GetEvaluatedResourceList : TFhirReferenceList;
begin
  if FEvaluatedResourceList = nil then
    FEvaluatedResourceList := TFhirReferenceList.Create;
  result := FEvaluatedResourceList;
end;

function TFhirMeasureReport.GetHasEvaluatedResourceList : boolean;
begin
  result := (FEvaluatedResourceList <> nil) and (FEvaluatedResourceList.count > 0);
end;

{ TFhirMeasureReportListEnumerator }

constructor TFhirMeasureReportListEnumerator.Create(list : TFhirMeasureReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMeasureReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMeasureReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMeasureReportListEnumerator.GetCurrent : TFhirMeasureReport;
begin
  Result := FList[FIndex];
end;

function TFhirMeasureReportListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMeasureReportList }

function TFhirMeasureReportList.AddItem(value: TFhirMeasureReport): TFhirMeasureReport;
begin
  assert(value.ClassName = 'TFhirMeasureReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMeasureReport');
  add(value);
  result := value;
end;

function TFhirMeasureReportList.Append: TFhirMeasureReport;
begin
  result := TFhirMeasureReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportList.ClearItems;
begin
  Clear;
end;

function TFhirMeasureReportList.GetEnumerator : TFhirMeasureReportListEnumerator;
begin
  result := TFhirMeasureReportListEnumerator.Create(self.link);
end;

function TFhirMeasureReportList.Clone: TFhirMeasureReportList;
begin
  result := TFhirMeasureReportList(inherited Clone);
end;

function TFhirMeasureReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMeasureReportList.GetItemN(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport(ObjectByIndex[index]);
end;

function TFhirMeasureReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirMeasureReport;
end;
function TFhirMeasureReportList.IndexOf(value: TFhirMeasureReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMeasureReportList.Insert(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMeasureReportList.InsertItem(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  Inherited Insert(index, value);
end;

function TFhirMeasureReportList.Item(index: Integer): TFhirMeasureReport;
begin
  result := TFhirMeasureReport(ObjectByIndex[index]);
end;

function TFhirMeasureReportList.Link: TFhirMeasureReportList;
begin
  result := TFhirMeasureReportList(inherited Link);
end;

procedure TFhirMeasureReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMeasureReportList.SetItemByIndex(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  FhirMeasureReports[index] := value;
end;

procedure TFhirMeasureReportList.SetItemN(index: Integer; value: TFhirMeasureReport);
begin
  assert(value is TFhirMeasureReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MEASUREREPORT}
{$IFDEF FHIR_MESSAGEHEADER}
{ TFhirMessageHeaderDestination }

constructor TFhirMessageHeaderDestination.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderDestination.Destroy;
begin
  FName.free;
  FTarget.free;
  FEndpoint.free;
  FReceiver.free;
  inherited;
end;

procedure TFhirMessageHeaderDestination.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderDestination(oSource).nameElement.Clone;
  target := TFhirMessageHeaderDestination(oSource).target.Clone;
  endpointElement := TFhirMessageHeaderDestination(oSource).endpointElement.Clone;
  receiver := TFhirMessageHeaderDestination(oSource).receiver.Clone;
end;

procedure TFhirMessageHeaderDestination.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'target') Then
     list.add(self.link, 'target', FTarget.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
  if (child_name = 'receiver') Then
     list.add(self.link, 'receiver', FReceiver.Link);
end;

procedure TFhirMessageHeaderDestination.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', false, TFhirReference, FTarget.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'url', false, TFhirUrl, FEndpoint.Link));
  oList.add(TFHIRProperty.create(self, 'receiver', 'Reference', false, TFhirReference, FReceiver.Link));
end;

function TFhirMessageHeaderDestination.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    Target := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUrl(propValue);
    result := propValue;
  end
  else if (propName = 'receiver') then
  begin
    Receiver := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderDestination.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderDestination.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'target') then result := TFhirReference.create()
  else if (propName = 'endpoint') then result := TFhirUrl.create()
  else if (propName = 'receiver') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderDestination.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'target') then result := 'Reference'
  else if (propName = 'endpoint') then result := 'url'
  else if (propName = 'receiver') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderDestination.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'target') then TargetElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else if (propName = 'receiver') then ReceiverElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderDestination.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'target') then TargetElement := new as TFhirReference
  else if (propName = 'endpoint') then EndpointElement := asUrl(new)
  else if (propName = 'receiver') then ReceiverElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderDestination.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderDestination.fhirType : string;
begin
  result := 'MessageHeader.destination';
end;

function TFhirMessageHeaderDestination.Link : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Link);
end;

function TFhirMessageHeaderDestination.Clone : TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(inherited Clone);
end;

function TFhirMessageHeaderDestination.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeaderDestination;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderDestination)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderDestination(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(targetElement, o.targetElement, true) and 
      compareDeep(endpointElement, o.endpointElement, true) and compareDeep(receiverElement, o.receiverElement, true);
  end;
end;

function TFhirMessageHeaderDestination.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FTarget) and isEmptyProp(FEndpoint) and isEmptyProp(FReceiver);
end;

procedure TFhirMessageHeaderDestination.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('target');
  fields.add('endpoint');
  fields.add('receiver');
end;

function TFhirMessageHeaderDestination.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMessageHeaderDestination.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirMessageHeaderDestination.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMessageHeaderDestination.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirMessageHeaderDestination.SetTarget(value : TFhirReference);
begin
  FTarget.free;
  FTarget := value;
end;

procedure TFhirMessageHeaderDestination.SetEndpoint(value : TFhirUrl);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

function TFhirMessageHeaderDestination.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

procedure TFhirMessageHeaderDestination.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUrl.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

procedure TFhirMessageHeaderDestination.SetReceiver(value : TFhirReference);
begin
  FReceiver.free;
  FReceiver := value;
end;

{ TFhirMessageHeaderDestinationListEnumerator }

constructor TFhirMessageHeaderDestinationListEnumerator.Create(list : TFhirMessageHeaderDestinationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderDestinationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderDestinationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderDestinationListEnumerator.GetCurrent : TFhirMessageHeaderDestination;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderDestinationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageHeaderDestinationList }

function TFhirMessageHeaderDestinationList.AddItem(value: TFhirMessageHeaderDestination): TFhirMessageHeaderDestination;
begin
  assert(value.ClassName = 'TFhirMessageHeaderDestination', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderDestination');
  add(value);
  result := value;
end;

function TFhirMessageHeaderDestinationList.Append: TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderDestinationList.GetEnumerator : TFhirMessageHeaderDestinationListEnumerator;
begin
  result := TFhirMessageHeaderDestinationListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderDestinationList.Clone: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Clone);
end;

function TFhirMessageHeaderDestinationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderDestinationList.GetItemN(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderDestination;
end;
function TFhirMessageHeaderDestinationList.IndexOf(value: TFhirMessageHeaderDestination): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderDestinationList.Insert(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderDestinationList.InsertItem(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderDestinationList.Item(index: Integer): TFhirMessageHeaderDestination;
begin
  result := TFhirMessageHeaderDestination(ObjectByIndex[index]);
end;

function TFhirMessageHeaderDestinationList.Link: TFhirMessageHeaderDestinationList;
begin
  result := TFhirMessageHeaderDestinationList(inherited Link);
end;

procedure TFhirMessageHeaderDestinationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderDestinationList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  FhirMessageHeaderDestinations[index] := value;
end;

procedure TFhirMessageHeaderDestinationList.SetItemN(index: Integer; value: TFhirMessageHeaderDestination);
begin
  assert(value is TFhirMessageHeaderDestination);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderSource }

constructor TFhirMessageHeaderSource.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderSource.Destroy;
begin
  FName.free;
  FSoftware.free;
  FVersion.free;
  FContact.free;
  FEndpoint.free;
  inherited;
end;

procedure TFhirMessageHeaderSource.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirMessageHeaderSource(oSource).nameElement.Clone;
  softwareElement := TFhirMessageHeaderSource(oSource).softwareElement.Clone;
  versionElement := TFhirMessageHeaderSource(oSource).versionElement.Clone;
  contact := TFhirMessageHeaderSource(oSource).contact.Clone;
  endpointElement := TFhirMessageHeaderSource(oSource).endpointElement.Clone;
end;

procedure TFhirMessageHeaderSource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'software') Then
     list.add(self.link, 'software', FSoftware.Link);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'contact') Then
     list.add(self.link, 'contact', FContact.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
end;

procedure TFhirMessageHeaderSource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'software', 'string', false, TFhirString, FSoftware.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', false, TFhirContactPoint, FContact.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'url', false, TFhirUrl, FEndpoint.Link));
end;

function TFhirMessageHeaderSource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'software') then
  begin
    SoftwareElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    Contact := propValue as TFhirContactPoint;
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUrl(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderSource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderSource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'software') then result := TFhirString.create()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'contact') then result := TFhirContactPoint.create()
  else if (propName = 'endpoint') then result := TFhirUrl.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderSource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'software') then result := 'string'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'endpoint') then result := 'url'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderSource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'software') then SoftwareElement := nil
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'contact') then ContactElement := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderSource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'software') then SoftwareElement := asString(new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'contact') then ContactElement := new as TFhirContactPoint
  else if (propName = 'endpoint') then EndpointElement := asUrl(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderSource.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderSource.fhirType : string;
begin
  result := 'MessageHeader.source';
end;

function TFhirMessageHeaderSource.Link : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Link);
end;

function TFhirMessageHeaderSource.Clone : TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(inherited Clone);
end;

function TFhirMessageHeaderSource.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeaderSource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderSource)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderSource(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(softwareElement, o.softwareElement, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(contactElement, o.contactElement, true) and 
      compareDeep(endpointElement, o.endpointElement, true);
  end;
end;

function TFhirMessageHeaderSource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FSoftware) and isEmptyProp(FVersion) and isEmptyProp(FContact) and isEmptyProp(FEndpoint);
end;

procedure TFhirMessageHeaderSource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('software');
  fields.add('version');
  fields.add('contact');
  fields.add('endpoint');
end;

function TFhirMessageHeaderSource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMessageHeaderSource.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirMessageHeaderSource.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirMessageHeaderSource.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirMessageHeaderSource.SetSoftware(value : TFhirString);
begin
  FSoftware.free;
  FSoftware := value;
end;

function TFhirMessageHeaderSource.GetSoftwareST : String;
begin
  if FSoftware = nil then
    result := ''
  else
    result := FSoftware.value;
end;

procedure TFhirMessageHeaderSource.SetSoftwareST(value : String);
begin
  if value <> '' then
  begin
    if FSoftware = nil then
      FSoftware := TFhirString.create;
    FSoftware.value := value
  end
  else if FSoftware <> nil then
    FSoftware.value := '';
end;

procedure TFhirMessageHeaderSource.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirMessageHeaderSource.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirMessageHeaderSource.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirMessageHeaderSource.SetContact(value : TFhirContactPoint);
begin
  FContact.free;
  FContact := value;
end;

procedure TFhirMessageHeaderSource.SetEndpoint(value : TFhirUrl);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

function TFhirMessageHeaderSource.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

procedure TFhirMessageHeaderSource.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUrl.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

{ TFhirMessageHeaderSourceListEnumerator }

constructor TFhirMessageHeaderSourceListEnumerator.Create(list : TFhirMessageHeaderSourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderSourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderSourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderSourceListEnumerator.GetCurrent : TFhirMessageHeaderSource;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderSourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageHeaderSourceList }

function TFhirMessageHeaderSourceList.AddItem(value: TFhirMessageHeaderSource): TFhirMessageHeaderSource;
begin
  assert(value.ClassName = 'TFhirMessageHeaderSource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderSource');
  add(value);
  result := value;
end;

function TFhirMessageHeaderSourceList.Append: TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderSourceList.GetEnumerator : TFhirMessageHeaderSourceListEnumerator;
begin
  result := TFhirMessageHeaderSourceListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderSourceList.Clone: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Clone);
end;

function TFhirMessageHeaderSourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderSourceList.GetItemN(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderSource;
end;
function TFhirMessageHeaderSourceList.IndexOf(value: TFhirMessageHeaderSource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderSourceList.Insert(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderSourceList.InsertItem(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderSourceList.Item(index: Integer): TFhirMessageHeaderSource;
begin
  result := TFhirMessageHeaderSource(ObjectByIndex[index]);
end;

function TFhirMessageHeaderSourceList.Link: TFhirMessageHeaderSourceList;
begin
  result := TFhirMessageHeaderSourceList(inherited Link);
end;

procedure TFhirMessageHeaderSourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderSourceList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  FhirMessageHeaderSources[index] := value;
end;

procedure TFhirMessageHeaderSourceList.SetItemN(index: Integer; value: TFhirMessageHeaderSource);
begin
  assert(value is TFhirMessageHeaderSource);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeaderResponse }

constructor TFhirMessageHeaderResponse.Create;
begin
  inherited;
end;

destructor TFhirMessageHeaderResponse.Destroy;
begin
  FIdentifier.free;
  FCode.free;
  FDetails.free;
  inherited;
end;

procedure TFhirMessageHeaderResponse.Assign(oSource : TFslObject);
begin
  inherited;
  identifierElement := TFhirMessageHeaderResponse(oSource).identifierElement.Clone;
  codeElement := TFhirMessageHeaderResponse(oSource).codeElement.Clone;
  details := TFhirMessageHeaderResponse(oSource).details.Clone;
end;

procedure TFhirMessageHeaderResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
end;

procedure TFhirMessageHeaderResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'id', false, TFhirId, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'details', 'Reference', false, TFhirReference, FDetails.Link));
end;

function TFhirMessageHeaderResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirResponseTypeEnum, CODES_TFhirResponseTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeaderResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirMessageHeaderResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirId.create()
  else if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirResponseTypeEnum[ResponseTypeNull], CODES_TFhirResponseTypeEnum[ResponseTypeNull]) 
  else if (propName = 'details') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeaderResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'id'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeaderResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeaderResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := asId(new)
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirResponseTypeEnum, CODES_TFhirResponseTypeEnum, new)
  else if (propName = 'details') then DetailsElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeaderResponse.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeaderResponse.fhirType : string;
begin
  result := 'MessageHeader.response';
end;

function TFhirMessageHeaderResponse.Link : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Link);
end;

function TFhirMessageHeaderResponse.Clone : TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(inherited Clone);
end;

function TFhirMessageHeaderResponse.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeaderResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeaderResponse)) then
    result := false
  else
  begin
    o := TFhirMessageHeaderResponse(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(detailsElement, o.detailsElement, true);
  end;
end;

function TFhirMessageHeaderResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FCode) and isEmptyProp(FDetails);
end;

procedure TFhirMessageHeaderResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('code');
  fields.add('details');
end;

function TFhirMessageHeaderResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirMessageHeaderResponse.SetIdentifier(value : TFhirId);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

function TFhirMessageHeaderResponse.GetIdentifierST : String;
begin
  if FIdentifier = nil then
    result := ''
  else
    result := FIdentifier.value;
end;

procedure TFhirMessageHeaderResponse.SetIdentifierST(value : String);
begin
  if value <> '' then
  begin
    if FIdentifier = nil then
      FIdentifier := TFhirId.create;
    FIdentifier.value := value
  end
  else if FIdentifier <> nil then
    FIdentifier.value := '';
end;

procedure TFhirMessageHeaderResponse.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirMessageHeaderResponse.GetCodeST : TFhirResponseTypeEnum;
begin
  if FCode = nil then
    result := TFhirResponseTypeEnum(0)
  else
    result := TFhirResponseTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirResponseTypeEnum, FCode.value));
end;

procedure TFhirMessageHeaderResponse.SetCodeST(value : TFhirResponseTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirResponseTypeEnum[value], CODES_TFhirResponseTypeEnum[value]);
end;

procedure TFhirMessageHeaderResponse.SetDetails(value : TFhirReference);
begin
  FDetails.free;
  FDetails := value;
end;

{ TFhirMessageHeaderResponseListEnumerator }

constructor TFhirMessageHeaderResponseListEnumerator.Create(list : TFhirMessageHeaderResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderResponseListEnumerator.GetCurrent : TFhirMessageHeaderResponse;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageHeaderResponseList }

function TFhirMessageHeaderResponseList.AddItem(value: TFhirMessageHeaderResponse): TFhirMessageHeaderResponse;
begin
  assert(value.ClassName = 'TFhirMessageHeaderResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeaderResponse');
  add(value);
  result := value;
end;

function TFhirMessageHeaderResponseList.Append: TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderResponseList.GetEnumerator : TFhirMessageHeaderResponseListEnumerator;
begin
  result := TFhirMessageHeaderResponseListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderResponseList.Clone: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Clone);
end;

function TFhirMessageHeaderResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderResponseList.GetItemN(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeaderResponse;
end;
function TFhirMessageHeaderResponseList.IndexOf(value: TFhirMessageHeaderResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderResponseList.Insert(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderResponseList.InsertItem(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderResponseList.Item(index: Integer): TFhirMessageHeaderResponse;
begin
  result := TFhirMessageHeaderResponse(ObjectByIndex[index]);
end;

function TFhirMessageHeaderResponseList.Link: TFhirMessageHeaderResponseList;
begin
  result := TFhirMessageHeaderResponseList(inherited Link);
end;

procedure TFhirMessageHeaderResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderResponseList.SetItemByIndex(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  FhirMessageHeaderResponses[index] := value;
end;

procedure TFhirMessageHeaderResponseList.SetItemN(index: Integer; value: TFhirMessageHeaderResponse);
begin
  assert(value is TFhirMessageHeaderResponse);
  ObjectByIndex[index] := value;
end;

{ TFhirMessageHeader }

constructor TFhirMessageHeader.Create;
begin
  inherited;
end;

destructor TFhirMessageHeader.Destroy;
begin
  FEvent.free;
  FDestinationList.Free;
  FSender.free;
  FEnterer.free;
  FAuthor.free;
  FSource.free;
  FResponsible.free;
  FReason.free;
  FResponse.free;
  FFocusList.Free;
  FDefinition.free;
  inherited;
end;

procedure TFhirMessageHeader.Assign(oSource : TFslObject);
begin
  inherited;
  event := TFhirMessageHeader(oSource).event.Clone;
  if (TFhirMessageHeader(oSource).FDestinationList = nil) then
  begin
    FDestinationList.free;
    FDestinationList := nil;
  end
  else
  begin
    if FDestinationList = nil then
      FDestinationList := TFhirMessageHeaderDestinationList.Create;
    FDestinationList.Assign(TFhirMessageHeader(oSource).FDestinationList);
  end;
  sender := TFhirMessageHeader(oSource).sender.Clone;
  enterer := TFhirMessageHeader(oSource).enterer.Clone;
  author := TFhirMessageHeader(oSource).author.Clone;
  source := TFhirMessageHeader(oSource).source.Clone;
  responsible := TFhirMessageHeader(oSource).responsible.Clone;
  reason := TFhirMessageHeader(oSource).reason.Clone;
  response := TFhirMessageHeader(oSource).response.Clone;
  if (TFhirMessageHeader(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirReferenceList.Create;
    FFocusList.Assign(TFhirMessageHeader(oSource).FFocusList);
  end;
  definitionElement := TFhirMessageHeader(oSource).definitionElement.Clone;
end;

function TFhirMessageHeader.GetResourceType : TFhirResourceType;
begin
  result := frtMessageHeader;
end;

procedure TFhirMessageHeader.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'event[x]') or (child_name = 'event') Then
     list.add(self.link, 'event[x]', FEvent.Link);
  if (child_name = 'destination') Then
    list.addAll(self, 'destination', FDestinationList);
  if (child_name = 'sender') Then
     list.add(self.link, 'sender', FSender.Link);
  if (child_name = 'enterer') Then
     list.add(self.link, 'enterer', FEnterer.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'responsible') Then
     list.add(self.link, 'responsible', FResponsible.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'response') Then
     list.add(self.link, 'response', FResponse.Link);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
end;

procedure TFhirMessageHeader.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'event[x]', 'Coding|uri', false, TFhirDataType, FEvent.Link));
  oList.add(TFHIRProperty.create(self, 'destination', 'BackboneElement', true, TFhirMessageHeaderDestination, FDestinationList.Link));
  oList.add(TFHIRProperty.create(self, 'sender', 'Reference', false, TFhirReference, FSender.Link));
  oList.add(TFHIRProperty.create(self, 'enterer', 'Reference', false, TFhirReference, FEnterer.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'BackboneElement', false, TFhirMessageHeaderSource, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'responsible', 'Reference', false, TFhirReference, FResponsible.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', false, TFhirCodeableConcept, FReason.Link));
  oList.add(TFHIRProperty.create(self, 'response', 'BackboneElement', false, TFhirMessageHeaderResponse, FResponse.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', true, TFhirReference, FFocusList.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'canonical', false, TFhirCanonical, FDefinition.Link));
end;

function TFhirMessageHeader.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then
  begin
    Event := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'destination') then
  begin
    DestinationList.add(propValue as TFhirMessageHeaderDestination);
    result := propValue;
  end
  else if (propName = 'sender') then
  begin
    Sender := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'enterer') then
  begin
    Enterer := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirMessageHeaderSource;
    result := propValue;
  end
  else if (propName = 'responsible') then
  begin
    Responsible := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    Reason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'response') then
  begin
    Response := propValue as TFhirMessageHeaderResponse;
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asCanonical(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirMessageHeader.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'destination') then DestinationList.insertItem(index, propValue as TFhirMessageHeaderDestination)
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirMessageHeader.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then raise EFHIRException.create('Cannot make property Event')
  else if (propName = 'destination') then result := DestinationList.new()
  else if (propName = 'sender') then result := TFhirReference.create()
  else if (propName = 'enterer') then result := TFhirReference.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'source') then result := TFhirMessageHeaderSource.create()
  else if (propName = 'responsible') then result := TFhirReference.create()
  else if (propName = 'reason') then result := TFhirCodeableConcept.create()
  else if (propName = 'response') then result := TFhirMessageHeaderResponse.create()
  else if (propName = 'focus') then result := FocusList.new()
  else if (propName = 'definition') then result := TFhirCanonical.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirMessageHeader.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'event[x]') then result := 'Coding|uri'
  else if (propName = 'destination') then result := 'BackboneElement'
  else if (propName = 'sender') then result := 'Reference'
  else if (propName = 'enterer') then result := 'Reference'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'source') then result := 'BackboneElement'
  else if (propName = 'responsible') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'response') then result := 'BackboneElement'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'definition') then result := 'canonical'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirMessageHeader.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then EventElement := nil
  else if (propName = 'destination') then deletePropertyValue('destination', DestinationList, value)
  else if (propName = 'sender') then SenderElement := nil
  else if (propName = 'enterer') then EntererElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'responsible') then ResponsibleElement := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'response') then ResponseElement := nil
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value)
  else if (propName = 'definition') then DefinitionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirMessageHeader.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'event', ['Coding', 'Uri'])) then EventElement := new as TFhirDataType
  else if (propName = 'destination') then replacePropertyValue('destination', DestinationList, existing, new)
  else if (propName = 'sender') then SenderElement := new as TFhirReference
  else if (propName = 'enterer') then EntererElement := new as TFhirReference
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'source') then SourceElement := new as TFhirMessageHeaderSource
  else if (propName = 'responsible') then ResponsibleElement := new as TFhirReference
  else if (propName = 'reason') then ReasonElement := new as TFhirCodeableConcept
  else if (propName = 'response') then ResponseElement := new as TFhirMessageHeaderResponse
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new)
  else if (propName = 'definition') then DefinitionElement := asCanonical(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirMessageHeader.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'destination') then DestinationList.move(source, destination)
  else if (propName = 'focus') then FocusList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirMessageHeader.fhirType : string;
begin
  result := 'MessageHeader';
end;

function TFhirMessageHeader.Link : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Link);
end;

function TFhirMessageHeader.Clone : TFhirMessageHeader;
begin
  result := TFhirMessageHeader(inherited Clone);
end;

function TFhirMessageHeader.equals(other : TObject) : boolean; 
var
  o : TFhirMessageHeader;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirMessageHeader)) then
    result := false
  else
  begin
    o := TFhirMessageHeader(other);
    result := compareDeep(eventElement, o.eventElement, true) and compareDeep(destinationList, o.destinationList, true) and 
      compareDeep(senderElement, o.senderElement, true) and compareDeep(entererElement, o.entererElement, true) and 
      compareDeep(authorElement, o.authorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(responsibleElement, o.responsibleElement, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(responseElement, o.responseElement, true) and compareDeep(focusList, o.focusList, true) and 
      compareDeep(definitionElement, o.definitionElement, true);
  end;
end;

function TFhirMessageHeader.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEvent) and isEmptyProp(FdestinationList) and isEmptyProp(FSender) and isEmptyProp(FEnterer) and isEmptyProp(FAuthor) and isEmptyProp(FSource) and isEmptyProp(FResponsible) and isEmptyProp(FReason) and isEmptyProp(FResponse) and isEmptyProp(FfocusList) and isEmptyProp(FDefinition);
end;

procedure TFhirMessageHeader.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('event[x]');
  fields.add('destination');
  fields.add('sender');
  fields.add('enterer');
  fields.add('author');
  fields.add('source');
  fields.add('responsible');
  fields.add('reason');
  fields.add('response');
  fields.add('focus');
  fields.add('definition');
end;

function TFhirMessageHeader.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FDestinationList.sizeInBytes(magic));
  inc(result, FFocusList.sizeInBytes(magic));
end;

procedure TFhirMessageHeader.SetEvent(value : TFhirDataType);
begin
  FEvent.free;
  FEvent := value;
end;

function TFhirMessageHeader.GetDestinationList : TFhirMessageHeaderDestinationList;
begin
  if FDestinationList = nil then
    FDestinationList := TFhirMessageHeaderDestinationList.Create;
  result := FDestinationList;
end;

function TFhirMessageHeader.GetHasDestinationList : boolean;
begin
  result := (FDestinationList <> nil) and (FDestinationList.count > 0);
end;

procedure TFhirMessageHeader.SetSender(value : TFhirReference);
begin
  FSender.free;
  FSender := value;
end;

procedure TFhirMessageHeader.SetEnterer(value : TFhirReference);
begin
  FEnterer.free;
  FEnterer := value;
end;

procedure TFhirMessageHeader.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

procedure TFhirMessageHeader.SetSource(value : TFhirMessageHeaderSource);
begin
  FSource.free;
  FSource := value;
end;

procedure TFhirMessageHeader.SetResponsible(value : TFhirReference);
begin
  FResponsible.free;
  FResponsible := value;
end;

procedure TFhirMessageHeader.SetReason(value : TFhirCodeableConcept);
begin
  FReason.free;
  FReason := value;
end;

procedure TFhirMessageHeader.SetResponse(value : TFhirMessageHeaderResponse);
begin
  FResponse.free;
  FResponse := value;
end;

function TFhirMessageHeader.GetFocusList : TFhirReferenceList;
begin
  if FFocusList = nil then
    FFocusList := TFhirReferenceList.Create;
  result := FFocusList;
end;

function TFhirMessageHeader.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

procedure TFhirMessageHeader.SetDefinition(value : TFhirCanonical);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirMessageHeader.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirMessageHeader.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirCanonical.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

{ TFhirMessageHeaderListEnumerator }

constructor TFhirMessageHeaderListEnumerator.Create(list : TFhirMessageHeaderList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirMessageHeaderListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirMessageHeaderListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirMessageHeaderListEnumerator.GetCurrent : TFhirMessageHeader;
begin
  Result := FList[FIndex];
end;

function TFhirMessageHeaderListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirMessageHeaderList }

function TFhirMessageHeaderList.AddItem(value: TFhirMessageHeader): TFhirMessageHeader;
begin
  assert(value.ClassName = 'TFhirMessageHeader', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirMessageHeader');
  add(value);
  result := value;
end;

function TFhirMessageHeaderList.Append: TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.ClearItems;
begin
  Clear;
end;

function TFhirMessageHeaderList.GetEnumerator : TFhirMessageHeaderListEnumerator;
begin
  result := TFhirMessageHeaderListEnumerator.Create(self.link);
end;

function TFhirMessageHeaderList.Clone: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Clone);
end;

function TFhirMessageHeaderList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirMessageHeaderList.GetItemN(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.ItemClass: TFslObjectClass;
begin
  result := TFhirMessageHeader;
end;
function TFhirMessageHeaderList.IndexOf(value: TFhirMessageHeader): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirMessageHeaderList.Insert(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirMessageHeaderList.InsertItem(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  Inherited Insert(index, value);
end;

function TFhirMessageHeaderList.Item(index: Integer): TFhirMessageHeader;
begin
  result := TFhirMessageHeader(ObjectByIndex[index]);
end;

function TFhirMessageHeaderList.Link: TFhirMessageHeaderList;
begin
  result := TFhirMessageHeaderList(inherited Link);
end;

procedure TFhirMessageHeaderList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirMessageHeaderList.SetItemByIndex(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  FhirMessageHeaders[index] := value;
end;

procedure TFhirMessageHeaderList.SetItemN(index: Integer; value: TFhirMessageHeader);
begin
  assert(value is TFhirMessageHeader);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_MESSAGEHEADER}
{$IFDEF FHIR_OPERATIONOUTCOME}
{ TFhirOperationOutcomeIssue }

constructor TFhirOperationOutcomeIssue.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcomeIssue.Destroy;
begin
  FSeverity.free;
  FCode.free;
  FDetails.free;
  FDiagnostics.free;
  FLocationList.Free;
  FExpressionList.Free;
  inherited;
end;

procedure TFhirOperationOutcomeIssue.Assign(oSource : TFslObject);
begin
  inherited;
  severityElement := TFhirOperationOutcomeIssue(oSource).severityElement.Clone;
  codeElement := TFhirOperationOutcomeIssue(oSource).codeElement.Clone;
  details := TFhirOperationOutcomeIssue(oSource).details.Clone;
  diagnosticsElement := TFhirOperationOutcomeIssue(oSource).diagnosticsElement.Clone;
  if (TFhirOperationOutcomeIssue(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirStringList.Create;
    FLocationList.Assign(TFhirOperationOutcomeIssue(oSource).FLocationList);
  end;
  if (TFhirOperationOutcomeIssue(oSource).FExpressionList = nil) then
  begin
    FExpressionList.free;
    FExpressionList := nil;
  end
  else
  begin
    if FExpressionList = nil then
      FExpressionList := TFhirStringList.Create;
    FExpressionList.Assign(TFhirOperationOutcomeIssue(oSource).FExpressionList);
  end;
end;

procedure TFhirOperationOutcomeIssue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'severity') Then
     list.add(self.link, 'severity', FSeverity.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'details') Then
     list.add(self.link, 'details', FDetails.Link);
  if (child_name = 'diagnostics') Then
     list.add(self.link, 'diagnostics', FDiagnostics.Link);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'expression') Then
    list.addAll(self, 'expression', FExpressionList);
end;

procedure TFhirOperationOutcomeIssue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'severity', 'code', false, TFhirEnum, FSeverity.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'code', false, TFhirEnum, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'details', 'CodeableConcept', false, TFhirCodeableConcept, FDetails.Link));
  oList.add(TFHIRProperty.create(self, 'diagnostics', 'string', false, TFhirString, FDiagnostics.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'string', true, TFhirString, FLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'string', true, TFhirString, FExpressionList.Link));
end;

function TFhirOperationOutcomeIssue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'severity') then
  begin
    SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'details') then
  begin
    Details := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'diagnostics') then
  begin
    DiagnosticsElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'expression') then
  begin
    ExpressionList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationOutcomeIssue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'location') then LocationList.insertItem(index, asString(propValue))
  else if (propName = 'expression') then ExpressionList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirOperationOutcomeIssue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'severity') then result := TFhirEnum.create(SYSTEMS_TFhirIssueSeverityEnum[IssueSeverityNull], CODES_TFhirIssueSeverityEnum[IssueSeverityNull]) 
  else if (propName = 'code') then result := TFhirEnum.create(SYSTEMS_TFhirIssueTypeEnum[IssueTypeNull], CODES_TFhirIssueTypeEnum[IssueTypeNull]) 
  else if (propName = 'details') then result := TFhirCodeableConcept.create()
  else if (propName = 'diagnostics') then result := TFhirString.create()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'expression') then result := ExpressionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcomeIssue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'severity') then result := 'code'
  else if (propName = 'code') then result := 'code'
  else if (propName = 'details') then result := 'CodeableConcept'
  else if (propName = 'diagnostics') then result := 'string'
  else if (propName = 'location') then result := 'string'
  else if (propName = 'expression') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcomeIssue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'details') then DetailsElement := nil
  else if (propName = 'diagnostics') then DiagnosticsElement := nil
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'expression') then deletePropertyValue('expression', ExpressionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcomeIssue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'severity') then SeverityElement := asEnum(SYSTEMS_TFhirIssueSeverityEnum, CODES_TFhirIssueSeverityEnum, new)
  else if (propName = 'code') then CodeElement := asEnum(SYSTEMS_TFhirIssueTypeEnum, CODES_TFhirIssueTypeEnum, new)
  else if (propName = 'details') then DetailsElement := new as TFhirCodeableConcept
  else if (propName = 'diagnostics') then DiagnosticsElement := asString(new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'expression') then replacePropertyValue('expression', ExpressionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcomeIssue.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'expression') then ExpressionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcomeIssue.fhirType : string;
begin
  result := 'OperationOutcome.issue';
end;

function TFhirOperationOutcomeIssue.Link : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Link);
end;

function TFhirOperationOutcomeIssue.Clone : TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(inherited Clone);
end;

function TFhirOperationOutcomeIssue.equals(other : TObject) : boolean; 
var
  o : TFhirOperationOutcomeIssue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcomeIssue)) then
    result := false
  else
  begin
    o := TFhirOperationOutcomeIssue(other);
    result := compareDeep(severityElement, o.severityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(detailsElement, o.detailsElement, true) and compareDeep(diagnosticsElement, o.diagnosticsElement, true) and 
      compareDeep(locationList, o.locationList, true) and compareDeep(expressionList, o.expressionList, true);
  end;
end;

function TFhirOperationOutcomeIssue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FSeverity) and isEmptyProp(FCode) and isEmptyProp(FDetails) and isEmptyProp(FDiagnostics) and isEmptyProp(FlocationList) and isEmptyProp(FexpressionList);
end;

procedure TFhirOperationOutcomeIssue.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('severity');
  fields.add('code');
  fields.add('details');
  fields.add('diagnostics');
  fields.add('location');
  fields.add('expression');
end;

function TFhirOperationOutcomeIssue.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FExpressionList.sizeInBytes(magic));
end;

procedure TFhirOperationOutcomeIssue.SetSeverity(value : TFhirEnum);
begin
  FSeverity.free;
  FSeverity := value;
end;

function TFhirOperationOutcomeIssue.GetSeverityST : TFhirIssueSeverityEnum;
begin
  if FSeverity = nil then
    result := TFhirIssueSeverityEnum(0)
  else
    result := TFhirIssueSeverityEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueSeverityEnum, FSeverity.value));
end;

procedure TFhirOperationOutcomeIssue.SetSeverityST(value : TFhirIssueSeverityEnum);
begin
  if ord(value) = 0 then
    SeverityElement := nil
  else
    SeverityElement := TFhirEnum.create(SYSTEMS_TFhirIssueSeverityEnum[value], CODES_TFhirIssueSeverityEnum[value]);
end;

procedure TFhirOperationOutcomeIssue.SetCode(value : TFhirEnum);
begin
  FCode.free;
  FCode := value;
end;

function TFhirOperationOutcomeIssue.GetCodeST : TFhirIssueTypeEnum;
begin
  if FCode = nil then
    result := TFhirIssueTypeEnum(0)
  else
    result := TFhirIssueTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirIssueTypeEnum, FCode.value));
end;

procedure TFhirOperationOutcomeIssue.SetCodeST(value : TFhirIssueTypeEnum);
begin
  if ord(value) = 0 then
    CodeElement := nil
  else
    CodeElement := TFhirEnum.create(SYSTEMS_TFhirIssueTypeEnum[value], CODES_TFhirIssueTypeEnum[value]);
end;

procedure TFhirOperationOutcomeIssue.SetDetails(value : TFhirCodeableConcept);
begin
  FDetails.free;
  FDetails := value;
end;

procedure TFhirOperationOutcomeIssue.SetDiagnostics(value : TFhirString);
begin
  FDiagnostics.free;
  FDiagnostics := value;
end;

function TFhirOperationOutcomeIssue.GetDiagnosticsST : String;
begin
  if FDiagnostics = nil then
    result := ''
  else
    result := FDiagnostics.value;
end;

procedure TFhirOperationOutcomeIssue.SetDiagnosticsST(value : String);
begin
  if value <> '' then
  begin
    if FDiagnostics = nil then
      FDiagnostics := TFhirString.create;
    FDiagnostics.value := value
  end
  else if FDiagnostics <> nil then
    FDiagnostics.value := '';
end;

function TFhirOperationOutcomeIssue.GetLocationList : TFhirStringList;
begin
  if FLocationList = nil then
    FLocationList := TFhirStringList.Create;
  result := FLocationList;
end;

function TFhirOperationOutcomeIssue.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

function TFhirOperationOutcomeIssue.GetExpressionList : TFhirStringList;
begin
  if FExpressionList = nil then
    FExpressionList := TFhirStringList.Create;
  result := FExpressionList;
end;

function TFhirOperationOutcomeIssue.GetHasExpressionList : boolean;
begin
  result := (FExpressionList <> nil) and (FExpressionList.count > 0);
end;

{ TFhirOperationOutcomeIssueListEnumerator }

constructor TFhirOperationOutcomeIssueListEnumerator.Create(list : TFhirOperationOutcomeIssueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeIssueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeIssueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeIssueListEnumerator.GetCurrent : TFhirOperationOutcomeIssue;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeIssueListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOperationOutcomeIssueList }

function TFhirOperationOutcomeIssueList.AddItem(value: TFhirOperationOutcomeIssue): TFhirOperationOutcomeIssue;
begin
  assert(value.ClassName = 'TFhirOperationOutcomeIssue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcomeIssue');
  add(value);
  result := value;
end;

function TFhirOperationOutcomeIssueList.Append: TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeIssueList.GetEnumerator : TFhirOperationOutcomeIssueListEnumerator;
begin
  result := TFhirOperationOutcomeIssueListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeIssueList.Clone: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Clone);
end;

function TFhirOperationOutcomeIssueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeIssueList.GetItemN(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcomeIssue;
end;
function TFhirOperationOutcomeIssueList.IndexOf(value: TFhirOperationOutcomeIssue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeIssueList.Insert(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeIssueList.InsertItem(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeIssueList.Item(index: Integer): TFhirOperationOutcomeIssue;
begin
  result := TFhirOperationOutcomeIssue(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeIssueList.Link: TFhirOperationOutcomeIssueList;
begin
  result := TFhirOperationOutcomeIssueList(inherited Link);
end;

procedure TFhirOperationOutcomeIssueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeIssueList.SetItemByIndex(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  FhirOperationOutcomeIssues[index] := value;
end;

procedure TFhirOperationOutcomeIssueList.SetItemN(index: Integer; value: TFhirOperationOutcomeIssue);
begin
  assert(value is TFhirOperationOutcomeIssue);
  ObjectByIndex[index] := value;
end;

{ TFhirOperationOutcome }

constructor TFhirOperationOutcome.Create;
begin
  inherited;
end;

destructor TFhirOperationOutcome.Destroy;
begin
  FIssueList.Free;
  inherited;
end;

procedure TFhirOperationOutcome.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirOperationOutcome(oSource).FIssueList = nil) then
  begin
    FIssueList.free;
    FIssueList := nil;
  end
  else
  begin
    if FIssueList = nil then
      FIssueList := TFhirOperationOutcomeIssueList.Create;
    FIssueList.Assign(TFhirOperationOutcome(oSource).FIssueList);
  end;
end;

function TFhirOperationOutcome.GetResourceType : TFhirResourceType;
begin
  result := frtOperationOutcome;
end;

procedure TFhirOperationOutcome.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'issue') Then
    list.addAll(self, 'issue', FIssueList);
end;

procedure TFhirOperationOutcome.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'issue', 'BackboneElement', true, TFhirOperationOutcomeIssue, FIssueList.Link));
end;

function TFhirOperationOutcome.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'issue') then
  begin
    IssueList.add(propValue as TFhirOperationOutcomeIssue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirOperationOutcome.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'issue') then IssueList.insertItem(index, propValue as TFhirOperationOutcomeIssue)
  else inherited;
end;

function TFhirOperationOutcome.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'issue') then result := IssueList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirOperationOutcome.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'issue') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirOperationOutcome.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'issue') then deletePropertyValue('issue', IssueList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirOperationOutcome.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'issue') then replacePropertyValue('issue', IssueList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirOperationOutcome.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'issue') then IssueList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirOperationOutcome.fhirType : string;
begin
  result := 'OperationOutcome';
end;

function TFhirOperationOutcome.Link : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Link);
end;

function TFhirOperationOutcome.Clone : TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(inherited Clone);
end;

function TFhirOperationOutcome.equals(other : TObject) : boolean; 
var
  o : TFhirOperationOutcome;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirOperationOutcome)) then
    result := false
  else
  begin
    o := TFhirOperationOutcome(other);
    result := compareDeep(issueList, o.issueList, true);
  end;
end;

function TFhirOperationOutcome.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FissueList);
end;

procedure TFhirOperationOutcome.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('issue');
end;

function TFhirOperationOutcome.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIssueList.sizeInBytes(magic));
end;

function TFhirOperationOutcome.GetIssueList : TFhirOperationOutcomeIssueList;
begin
  if FIssueList = nil then
    FIssueList := TFhirOperationOutcomeIssueList.Create;
  result := FIssueList;
end;

function TFhirOperationOutcome.GetHasIssueList : boolean;
begin
  result := (FIssueList <> nil) and (FIssueList.count > 0);
end;

{ TFhirOperationOutcomeListEnumerator }

constructor TFhirOperationOutcomeListEnumerator.Create(list : TFhirOperationOutcomeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirOperationOutcomeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirOperationOutcomeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirOperationOutcomeListEnumerator.GetCurrent : TFhirOperationOutcome;
begin
  Result := FList[FIndex];
end;

function TFhirOperationOutcomeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirOperationOutcomeList }

function TFhirOperationOutcomeList.AddItem(value: TFhirOperationOutcome): TFhirOperationOutcome;
begin
  assert(value.ClassName = 'TFhirOperationOutcome', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirOperationOutcome');
  add(value);
  result := value;
end;

function TFhirOperationOutcomeList.Append: TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.ClearItems;
begin
  Clear;
end;

function TFhirOperationOutcomeList.GetEnumerator : TFhirOperationOutcomeListEnumerator;
begin
  result := TFhirOperationOutcomeListEnumerator.Create(self.link);
end;

function TFhirOperationOutcomeList.Clone: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Clone);
end;

function TFhirOperationOutcomeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirOperationOutcomeList.GetItemN(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.ItemClass: TFslObjectClass;
begin
  result := TFhirOperationOutcome;
end;
function TFhirOperationOutcomeList.IndexOf(value: TFhirOperationOutcome): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirOperationOutcomeList.Insert(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirOperationOutcomeList.InsertItem(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  Inherited Insert(index, value);
end;

function TFhirOperationOutcomeList.Item(index: Integer): TFhirOperationOutcome;
begin
  result := TFhirOperationOutcome(ObjectByIndex[index]);
end;

function TFhirOperationOutcomeList.Link: TFhirOperationOutcomeList;
begin
  result := TFhirOperationOutcomeList(inherited Link);
end;

procedure TFhirOperationOutcomeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirOperationOutcomeList.SetItemByIndex(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  FhirOperationOutcomes[index] := value;
end;

procedure TFhirOperationOutcomeList.SetItemN(index: Integer; value: TFhirOperationOutcome);
begin
  assert(value is TFhirOperationOutcome);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_OPERATIONOUTCOME}
{$IFDEF FHIR_PARAMETERS}
{ TFhirParametersParameter }

constructor TFhirParametersParameter.Create;
begin
  inherited;
end;

destructor TFhirParametersParameter.Destroy;
begin
  FName.free;
  FValue.free;
  FResource.free;
  FPartList.Free;
  inherited;
end;

procedure TFhirParametersParameter.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirParametersParameter(oSource).nameElement.Clone;
  value := TFhirParametersParameter(oSource).value.Clone;
  resource := TFhirParametersParameter(oSource).resource.Clone;
  if (TFhirParametersParameter(oSource).FPartList = nil) then
  begin
    FPartList.free;
    FPartList := nil;
  end
  else
  begin
    if FPartList = nil then
      FPartList := TFhirParametersParameterList.Create;
    FPartList.Assign(TFhirParametersParameter(oSource).FPartList);
  end;
end;

procedure TFhirParametersParameter.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'part') Then
    list.addAll(self, 'part', FPartList);
end;

procedure TFhirParametersParameter.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage|Meta', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Resource', false, TFhirResource, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'part', '', true, TFhirParametersParameter, FPartList.Link));
end;

function TFhirParametersParameter.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirResource;
    result := propValue;
  end
  else if (propName = 'part') then
  begin
    PartList.add(propValue as TFhirParametersParameter);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirParametersParameter.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'part') then PartList.insertItem(index, propValue as TFhirParametersParameter)
  else inherited;
end;

function TFhirParametersParameter.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'resource') then raise EFHIRException.create('Cannot make property Resource')
  else if (propName = 'part') then result := PartList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirParametersParameter.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage|Meta'
  else if (propName = 'resource') then result := 'Resource'
  else if (propName = 'part') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParametersParameter.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then ValueElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'part') then deletePropertyValue('part', PartList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParametersParameter.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then ValueElement := new as TFhirDataType
  else if (propName = 'resource') then ResourceElement := new as TFhirResource
  else if (propName = 'part') then replacePropertyValue('part', PartList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParametersParameter.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'part') then PartList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParametersParameter.fhirType : string;
begin
  result := 'Parameters.parameter';
end;

function TFhirParametersParameter.Link : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Link);
end;

function TFhirParametersParameter.Clone : TFhirParametersParameter;
begin
  result := TFhirParametersParameter(inherited Clone);
end;

function TFhirParametersParameter.equals(other : TObject) : boolean; 
var
  o : TFhirParametersParameter;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParametersParameter)) then
    result := false
  else
  begin
    o := TFhirParametersParameter(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(valueElement, o.valueElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(partList, o.partList, true);
  end;
end;

function TFhirParametersParameter.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FValue) and isEmptyProp(FResource) and isEmptyProp(FpartList);
end;

procedure TFhirParametersParameter.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('value[x]');
  fields.add('resource');
  fields.add('part');
end;

function TFhirParametersParameter.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FPartList.sizeInBytes(magic));
end;

procedure TFhirParametersParameter.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirParametersParameter.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirParametersParameter.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirParametersParameter.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

procedure TFhirParametersParameter.SetResource(value : TFhirResource);
begin
  FResource.free;
  FResource := value;
end;

function TFhirParametersParameter.GetPartList : TFhirParametersParameterList;
begin
  if FPartList = nil then
    FPartList := TFhirParametersParameterList.Create;
  result := FPartList;
end;

function TFhirParametersParameter.GetHasPartList : boolean;
begin
  result := (FPartList <> nil) and (FPartList.count > 0);
end;

{ TFhirParametersParameterListEnumerator }

constructor TFhirParametersParameterListEnumerator.Create(list : TFhirParametersParameterList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersParameterListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersParameterListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersParameterListEnumerator.GetCurrent : TFhirParametersParameter;
begin
  Result := FList[FIndex];
end;

function TFhirParametersParameterListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirParametersParameterList }

function TFhirParametersParameterList.AddItem(value: TFhirParametersParameter): TFhirParametersParameter;
begin
  assert(value.ClassName = 'TFhirParametersParameter', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParametersParameter');
  add(value);
  result := value;
end;

function TFhirParametersParameterList.Append: TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.ClearItems;
begin
  Clear;
end;

function TFhirParametersParameterList.GetEnumerator : TFhirParametersParameterListEnumerator;
begin
  result := TFhirParametersParameterListEnumerator.Create(self.link);
end;

function TFhirParametersParameterList.Clone: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Clone);
end;

function TFhirParametersParameterList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersParameterList.GetItemN(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.ItemClass: TFslObjectClass;
begin
  result := TFhirParametersParameter;
end;
function TFhirParametersParameterList.IndexOf(value: TFhirParametersParameter): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersParameterList.Insert(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersParameterList.InsertItem(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  Inherited Insert(index, value);
end;

function TFhirParametersParameterList.Item(index: Integer): TFhirParametersParameter;
begin
  result := TFhirParametersParameter(ObjectByIndex[index]);
end;

function TFhirParametersParameterList.Link: TFhirParametersParameterList;
begin
  result := TFhirParametersParameterList(inherited Link);
end;

procedure TFhirParametersParameterList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersParameterList.SetItemByIndex(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  FhirParametersParameters[index] := value;
end;

procedure TFhirParametersParameterList.SetItemN(index: Integer; value: TFhirParametersParameter);
begin
  assert(value is TFhirParametersParameter);
  ObjectByIndex[index] := value;
end;

{ TFhirParameters }

constructor TFhirParameters.Create;
begin
  inherited;
end;

destructor TFhirParameters.Destroy;
begin
  FParameterList.Free;
  inherited;
end;

procedure TFhirParameters.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirParameters(oSource).FParameterList = nil) then
  begin
    FParameterList.free;
    FParameterList := nil;
  end
  else
  begin
    if FParameterList = nil then
      FParameterList := TFhirParametersParameterList.Create;
    FParameterList.Assign(TFhirParameters(oSource).FParameterList);
  end;
end;

function TFhirParameters.GetResourceType : TFhirResourceType;
begin
  result := frtParameters;
end;

procedure TFhirParameters.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'parameter') Then
    list.addAll(self, 'parameter', FParameterList);
end;

procedure TFhirParameters.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'parameter', 'BackboneElement', true, TFhirParametersParameter, FParameterList.Link));
end;

function TFhirParameters.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'parameter') then
  begin
    ParameterList.add(propValue as TFhirParametersParameter);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirParameters.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'parameter') then ParameterList.insertItem(index, propValue as TFhirParametersParameter)
  else inherited;
end;

function TFhirParameters.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'parameter') then result := ParameterList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirParameters.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'parameter') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirParameters.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'parameter') then deletePropertyValue('parameter', ParameterList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirParameters.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'parameter') then replacePropertyValue('parameter', ParameterList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirParameters.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'parameter') then ParameterList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirParameters.fhirType : string;
begin
  result := 'Parameters';
end;

function TFhirParameters.Link : TFhirParameters;
begin
  result := TFhirParameters(inherited Link);
end;

function TFhirParameters.Clone : TFhirParameters;
begin
  result := TFhirParameters(inherited Clone);
end;

function TFhirParameters.equals(other : TObject) : boolean; 
var
  o : TFhirParameters;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirParameters)) then
    result := false
  else
  begin
    o := TFhirParameters(other);
    result := compareDeep(parameterList, o.parameterList, true);
  end;
end;

function TFhirParameters.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FparameterList);
end;

procedure TFhirParameters.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('parameter');
end;

function TFhirParameters.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FParameterList.sizeInBytes(magic));
end;

function TFhirParameters.GetParameterList : TFhirParametersParameterList;
begin
  if FParameterList = nil then
    FParameterList := TFhirParametersParameterList.Create;
  result := FParameterList;
end;

function TFhirParameters.GetHasParameterList : boolean;
begin
  result := (FParameterList <> nil) and (FParameterList.count > 0);
end;

{ TFhirParametersListEnumerator }

constructor TFhirParametersListEnumerator.Create(list : TFhirParametersList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirParametersListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirParametersListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirParametersListEnumerator.GetCurrent : TFhirParameters;
begin
  Result := FList[FIndex];
end;

function TFhirParametersListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirParametersList }

function TFhirParametersList.AddItem(value: TFhirParameters): TFhirParameters;
begin
  assert(value.ClassName = 'TFhirParameters', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirParameters');
  add(value);
  result := value;
end;

function TFhirParametersList.Append: TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.ClearItems;
begin
  Clear;
end;

function TFhirParametersList.GetEnumerator : TFhirParametersListEnumerator;
begin
  result := TFhirParametersListEnumerator.Create(self.link);
end;

function TFhirParametersList.Clone: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Clone);
end;

function TFhirParametersList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirParametersList.GetItemN(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.ItemClass: TFslObjectClass;
begin
  result := TFhirParameters;
end;
function TFhirParametersList.IndexOf(value: TFhirParameters): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirParametersList.Insert(index: Integer): TFhirParameters;
begin
  result := TFhirParameters.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirParametersList.InsertItem(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  Inherited Insert(index, value);
end;

function TFhirParametersList.Item(index: Integer): TFhirParameters;
begin
  result := TFhirParameters(ObjectByIndex[index]);
end;

function TFhirParametersList.Link: TFhirParametersList;
begin
  result := TFhirParametersList(inherited Link);
end;

procedure TFhirParametersList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirParametersList.SetItemByIndex(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  FhirParameters[index] := value;
end;

procedure TFhirParametersList.SetItemN(index: Integer; value: TFhirParameters);
begin
  assert(value is TFhirParameters);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PARAMETERS}
{$IFDEF FHIR_PLANDEFINITION}
{ TFhirPlanDefinitionGoal }

constructor TFhirPlanDefinitionGoal.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionGoal.Destroy;
begin
  FCategory.free;
  FDescription.free;
  FPriority.free;
  FStart.free;
  FAddressesList.Free;
  FDocumentationList.Free;
  FTargetList.Free;
  inherited;
end;

procedure TFhirPlanDefinitionGoal.Assign(oSource : TFslObject);
begin
  inherited;
  category := TFhirPlanDefinitionGoal(oSource).category.Clone;
  description := TFhirPlanDefinitionGoal(oSource).description.Clone;
  priority := TFhirPlanDefinitionGoal(oSource).priority.Clone;
  start := TFhirPlanDefinitionGoal(oSource).start.Clone;
  if (TFhirPlanDefinitionGoal(oSource).FAddressesList = nil) then
  begin
    FAddressesList.free;
    FAddressesList := nil;
  end
  else
  begin
    if FAddressesList = nil then
      FAddressesList := TFhirCodeableConceptList.Create;
    FAddressesList.Assign(TFhirPlanDefinitionGoal(oSource).FAddressesList);
  end;
  if (TFhirPlanDefinitionGoal(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirPlanDefinitionGoal(oSource).FDocumentationList);
  end;
  if (TFhirPlanDefinitionGoal(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirPlanDefinitionGoalTargetList.Create;
    FTargetList.Assign(TFhirPlanDefinitionGoal(oSource).FTargetList);
  end;
end;

procedure TFhirPlanDefinitionGoal.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'category') Then
     list.add(self.link, 'category', FCategory.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'start') Then
     list.add(self.link, 'start', FStart.Link);
  if (child_name = 'addresses') Then
    list.addAll(self, 'addresses', FAddressesList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
end;

procedure TFhirPlanDefinitionGoal.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', false, TFhirCodeableConcept, FCategory.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'CodeableConcept', false, TFhirCodeableConcept, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'CodeableConcept', false, TFhirCodeableConcept, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'start', 'CodeableConcept', false, TFhirCodeableConcept, FStart.Link));
  oList.add(TFHIRProperty.create(self, 'addresses', 'CodeableConcept', true, TFhirCodeableConcept, FAddressesList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link));
  oList.add(TFHIRProperty.create(self, 'target', 'BackboneElement', true, TFhirPlanDefinitionGoalTarget, FTargetList.Link));
end;

function TFhirPlanDefinitionGoal.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'category') then
  begin
    Category := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    Description := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    Priority := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'start') then
  begin
    Start := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'addresses') then
  begin
    AddressesList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirPlanDefinitionGoalTarget);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionGoal.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'addresses') then AddressesList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirPlanDefinitionGoalTarget)
  else inherited;
end;

function TFhirPlanDefinitionGoal.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'category') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirCodeableConcept.create()
  else if (propName = 'priority') then result := TFhirCodeableConcept.create()
  else if (propName = 'start') then result := TFhirCodeableConcept.create()
  else if (propName = 'addresses') then result := AddressesList.new()
  else if (propName = 'documentation') then result := DocumentationList.new()
  else if (propName = 'target') then result := TargetList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionGoal.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'CodeableConcept'
  else if (propName = 'priority') then result := 'CodeableConcept'
  else if (propName = 'start') then result := 'CodeableConcept'
  else if (propName = 'addresses') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'target') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionGoal.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'start') then StartElement := nil
  else if (propName = 'addresses') then deletePropertyValue('addresses', AddressesList, value)
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value)
  else if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionGoal.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'category') then CategoryElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := new as TFhirCodeableConcept
  else if (propName = 'priority') then PriorityElement := new as TFhirCodeableConcept
  else if (propName = 'start') then StartElement := new as TFhirCodeableConcept
  else if (propName = 'addresses') then replacePropertyValue('addresses', AddressesList, existing, new)
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new)
  else if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionGoal.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'addresses') then AddressesList.move(source, destination)
  else if (propName = 'documentation') then DocumentationList.move(source, destination)
  else if (propName = 'target') then TargetList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionGoal.fhirType : string;
begin
  result := 'PlanDefinition.goal';
end;

function TFhirPlanDefinitionGoal.Link : TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(inherited Link);
end;

function TFhirPlanDefinitionGoal.Clone : TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(inherited Clone);
end;

function TFhirPlanDefinitionGoal.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionGoal;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionGoal)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionGoal(other);
    result := compareDeep(categoryElement, o.categoryElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(startElement, o.startElement, true) and 
      compareDeep(addressesList, o.addressesList, true) and compareDeep(documentationList, o.documentationList, true) and 
      compareDeep(targetList, o.targetList, true);
  end;
end;

function TFhirPlanDefinitionGoal.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FCategory) and isEmptyProp(FDescription) and isEmptyProp(FPriority) and isEmptyProp(FStart) and isEmptyProp(FaddressesList) and isEmptyProp(FdocumentationList) and isEmptyProp(FtargetList);
end;

procedure TFhirPlanDefinitionGoal.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('category');
  fields.add('description');
  fields.add('priority');
  fields.add('start');
  fields.add('addresses');
  fields.add('documentation');
  fields.add('target');
end;

function TFhirPlanDefinitionGoal.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAddressesList.sizeInBytes(magic));
  inc(result, FDocumentationList.sizeInBytes(magic));
  inc(result, FTargetList.sizeInBytes(magic));
end;

procedure TFhirPlanDefinitionGoal.SetCategory(value : TFhirCodeableConcept);
begin
  FCategory.free;
  FCategory := value;
end;

procedure TFhirPlanDefinitionGoal.SetDescription(value : TFhirCodeableConcept);
begin
  FDescription.free;
  FDescription := value;
end;

procedure TFhirPlanDefinitionGoal.SetPriority(value : TFhirCodeableConcept);
begin
  FPriority.free;
  FPriority := value;
end;

procedure TFhirPlanDefinitionGoal.SetStart(value : TFhirCodeableConcept);
begin
  FStart.free;
  FStart := value;
end;

function TFhirPlanDefinitionGoal.GetAddressesList : TFhirCodeableConceptList;
begin
  if FAddressesList = nil then
    FAddressesList := TFhirCodeableConceptList.Create;
  result := FAddressesList;
end;

function TFhirPlanDefinitionGoal.GetHasAddressesList : boolean;
begin
  result := (FAddressesList <> nil) and (FAddressesList.count > 0);
end;

function TFhirPlanDefinitionGoal.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

function TFhirPlanDefinitionGoal.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

function TFhirPlanDefinitionGoal.GetTargetList : TFhirPlanDefinitionGoalTargetList;
begin
  if FTargetList = nil then
    FTargetList := TFhirPlanDefinitionGoalTargetList.Create;
  result := FTargetList;
end;

function TFhirPlanDefinitionGoal.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

{ TFhirPlanDefinitionGoalListEnumerator }

constructor TFhirPlanDefinitionGoalListEnumerator.Create(list : TFhirPlanDefinitionGoalList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionGoalListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionGoalListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionGoalListEnumerator.GetCurrent : TFhirPlanDefinitionGoal;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionGoalListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionGoalList }

function TFhirPlanDefinitionGoalList.AddItem(value: TFhirPlanDefinitionGoal): TFhirPlanDefinitionGoal;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionGoal', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionGoal');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionGoalList.Append: TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionGoalList.GetEnumerator : TFhirPlanDefinitionGoalListEnumerator;
begin
  result := TFhirPlanDefinitionGoalListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionGoalList.Clone: TFhirPlanDefinitionGoalList;
begin
  result := TFhirPlanDefinitionGoalList(inherited Clone);
end;

function TFhirPlanDefinitionGoalList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionGoalList.GetItemN(index: Integer): TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionGoal;
end;
function TFhirPlanDefinitionGoalList.IndexOf(value: TFhirPlanDefinitionGoal): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionGoalList.Insert(index: Integer): TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalList.InsertItem(index: Integer; value: TFhirPlanDefinitionGoal);
begin
  assert(value is TFhirPlanDefinitionGoal);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionGoalList.Item(index: Integer): TFhirPlanDefinitionGoal;
begin
  result := TFhirPlanDefinitionGoal(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalList.Link: TFhirPlanDefinitionGoalList;
begin
  result := TFhirPlanDefinitionGoalList(inherited Link);
end;

procedure TFhirPlanDefinitionGoalList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionGoalList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionGoal);
begin
  assert(value is TFhirPlanDefinitionGoal);
  FhirPlanDefinitionGoals[index] := value;
end;

procedure TFhirPlanDefinitionGoalList.SetItemN(index: Integer; value: TFhirPlanDefinitionGoal);
begin
  assert(value is TFhirPlanDefinitionGoal);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionGoalTarget }

constructor TFhirPlanDefinitionGoalTarget.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionGoalTarget.Destroy;
begin
  FMeasure.free;
  FDetail.free;
  FDue.free;
  inherited;
end;

procedure TFhirPlanDefinitionGoalTarget.Assign(oSource : TFslObject);
begin
  inherited;
  measure := TFhirPlanDefinitionGoalTarget(oSource).measure.Clone;
  detail := TFhirPlanDefinitionGoalTarget(oSource).detail.Clone;
  due := TFhirPlanDefinitionGoalTarget(oSource).due.Clone;
end;

procedure TFhirPlanDefinitionGoalTarget.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'measure') Then
     list.add(self.link, 'measure', FMeasure.Link);
  if (child_name = 'detail[x]') or (child_name = 'detail') Then
     list.add(self.link, 'detail[x]', FDetail.Link);
  if (child_name = 'due') Then
     list.add(self.link, 'due', FDue.Link);
end;

procedure TFhirPlanDefinitionGoalTarget.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'measure', 'CodeableConcept', false, TFhirCodeableConcept, FMeasure.Link));
  oList.add(TFHIRProperty.create(self, 'detail[x]', 'Quantity|Range|CodeableConcept', false, TFhirDataType, FDetail.Link));
  oList.add(TFHIRProperty.create(self, 'due', 'Duration', false, TFhirDuration, FDue.Link));
end;

function TFhirPlanDefinitionGoalTarget.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'measure') then
  begin
    Measure := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then
  begin
    Detail := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'due') then
  begin
    Due := propValue as TFhirDuration;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionGoalTarget.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionGoalTarget.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'measure') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then raise EFHIRException.create('Cannot make property Detail')
  else if (propName = 'due') then result := TFhirDuration.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionGoalTarget.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'measure') then result := 'CodeableConcept'
  else if (propName = 'detail[x]') then result := 'Quantity|Range|CodeableConcept'
  else if (propName = 'due') then result := 'Duration'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionGoalTarget.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := nil
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then DetailElement := nil
  else if (propName = 'due') then DueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionGoalTarget.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'measure') then MeasureElement := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'detail', ['Quantity', 'Range', 'CodeableConcept'])) then DetailElement := new as TFhirDataType
  else if (propName = 'due') then DueElement := new as TFhirDuration
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionGoalTarget.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionGoalTarget.fhirType : string;
begin
  result := 'PlanDefinition.goal.target';
end;

function TFhirPlanDefinitionGoalTarget.Link : TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(inherited Link);
end;

function TFhirPlanDefinitionGoalTarget.Clone : TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(inherited Clone);
end;

function TFhirPlanDefinitionGoalTarget.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionGoalTarget;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionGoalTarget)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionGoalTarget(other);
    result := compareDeep(measureElement, o.measureElement, true) and compareDeep(detailElement, o.detailElement, true) and 
      compareDeep(dueElement, o.dueElement, true);
  end;
end;

function TFhirPlanDefinitionGoalTarget.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FMeasure) and isEmptyProp(FDetail) and isEmptyProp(FDue);
end;

procedure TFhirPlanDefinitionGoalTarget.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('measure');
  fields.add('detail[x]');
  fields.add('due');
end;

function TFhirPlanDefinitionGoalTarget.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionGoalTarget.SetMeasure(value : TFhirCodeableConcept);
begin
  FMeasure.free;
  FMeasure := value;
end;

procedure TFhirPlanDefinitionGoalTarget.SetDetail(value : TFhirDataType);
begin
  FDetail.free;
  FDetail := value;
end;

procedure TFhirPlanDefinitionGoalTarget.SetDue(value : TFhirDuration);
begin
  FDue.free;
  FDue := value;
end;

{ TFhirPlanDefinitionGoalTargetListEnumerator }

constructor TFhirPlanDefinitionGoalTargetListEnumerator.Create(list : TFhirPlanDefinitionGoalTargetList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionGoalTargetListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionGoalTargetListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionGoalTargetListEnumerator.GetCurrent : TFhirPlanDefinitionGoalTarget;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionGoalTargetListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionGoalTargetList }

function TFhirPlanDefinitionGoalTargetList.AddItem(value: TFhirPlanDefinitionGoalTarget): TFhirPlanDefinitionGoalTarget;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionGoalTarget', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionGoalTarget');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionGoalTargetList.Append: TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalTargetList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionGoalTargetList.GetEnumerator : TFhirPlanDefinitionGoalTargetListEnumerator;
begin
  result := TFhirPlanDefinitionGoalTargetListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionGoalTargetList.Clone: TFhirPlanDefinitionGoalTargetList;
begin
  result := TFhirPlanDefinitionGoalTargetList(inherited Clone);
end;

function TFhirPlanDefinitionGoalTargetList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionGoalTargetList.GetItemN(index: Integer): TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalTargetList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionGoalTarget;
end;
function TFhirPlanDefinitionGoalTargetList.IndexOf(value: TFhirPlanDefinitionGoalTarget): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionGoalTargetList.Insert(index: Integer): TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionGoalTargetList.InsertItem(index: Integer; value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value is TFhirPlanDefinitionGoalTarget);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionGoalTargetList.Item(index: Integer): TFhirPlanDefinitionGoalTarget;
begin
  result := TFhirPlanDefinitionGoalTarget(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionGoalTargetList.Link: TFhirPlanDefinitionGoalTargetList;
begin
  result := TFhirPlanDefinitionGoalTargetList(inherited Link);
end;

procedure TFhirPlanDefinitionGoalTargetList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionGoalTargetList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value is TFhirPlanDefinitionGoalTarget);
  FhirPlanDefinitionGoalTargets[index] := value;
end;

procedure TFhirPlanDefinitionGoalTargetList.SetItemN(index: Integer; value: TFhirPlanDefinitionGoalTarget);
begin
  assert(value is TFhirPlanDefinitionGoalTarget);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionAction }

constructor TFhirPlanDefinitionAction.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionAction.Destroy;
begin
  FPrefix.free;
  FTitle.free;
  FDescription.free;
  FTextEquivalent.free;
  FPriority.free;
  FCodeList.Free;
  FReasonList.Free;
  FDocumentationList.Free;
  FGoalIdList.Free;
  FSubject.free;
  FTriggerList.Free;
  FConditionList.Free;
  FInputList.Free;
  FOutputList.Free;
  FRelatedActionList.Free;
  FTiming.free;
  FParticipantList.Free;
  FType_.free;
  FGroupingBehavior.free;
  FSelectionBehavior.free;
  FRequiredBehavior.free;
  FPrecheckBehavior.free;
  FCardinalityBehavior.free;
  FDefinition.free;
  FTransform.free;
  FDynamicValueList.Free;
  FActionList.Free;
  inherited;
end;

procedure TFhirPlanDefinitionAction.Assign(oSource : TFslObject);
begin
  inherited;
  prefixElement := TFhirPlanDefinitionAction(oSource).prefixElement.Clone;
  titleElement := TFhirPlanDefinitionAction(oSource).titleElement.Clone;
  descriptionElement := TFhirPlanDefinitionAction(oSource).descriptionElement.Clone;
  textEquivalentElement := TFhirPlanDefinitionAction(oSource).textEquivalentElement.Clone;
  priorityElement := TFhirPlanDefinitionAction(oSource).priorityElement.Clone;
  if (TFhirPlanDefinitionAction(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirPlanDefinitionAction(oSource).FCodeList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirPlanDefinitionAction(oSource).FReasonList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirPlanDefinitionAction(oSource).FDocumentationList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FGoalIdList = nil) then
  begin
    FGoalIdList.free;
    FGoalIdList := nil;
  end
  else
  begin
    if FGoalIdList = nil then
      FGoalIdList := TFhirIdList.Create;
    FGoalIdList.Assign(TFhirPlanDefinitionAction(oSource).FGoalIdList);
  end;
  subject := TFhirPlanDefinitionAction(oSource).subject.Clone;
  if (TFhirPlanDefinitionAction(oSource).FTriggerList = nil) then
  begin
    FTriggerList.free;
    FTriggerList := nil;
  end
  else
  begin
    if FTriggerList = nil then
      FTriggerList := TFhirTriggerDefinitionList.Create;
    FTriggerList.Assign(TFhirPlanDefinitionAction(oSource).FTriggerList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirPlanDefinitionActionConditionList.Create;
    FConditionList.Assign(TFhirPlanDefinitionAction(oSource).FConditionList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirDataRequirementList.Create;
    FInputList.Assign(TFhirPlanDefinitionAction(oSource).FInputList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FOutputList = nil) then
  begin
    FOutputList.free;
    FOutputList := nil;
  end
  else
  begin
    if FOutputList = nil then
      FOutputList := TFhirDataRequirementList.Create;
    FOutputList.Assign(TFhirPlanDefinitionAction(oSource).FOutputList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FRelatedActionList = nil) then
  begin
    FRelatedActionList.free;
    FRelatedActionList := nil;
  end
  else
  begin
    if FRelatedActionList = nil then
      FRelatedActionList := TFhirPlanDefinitionActionRelatedActionList.Create;
    FRelatedActionList.Assign(TFhirPlanDefinitionAction(oSource).FRelatedActionList);
  end;
  timing := TFhirPlanDefinitionAction(oSource).timing.Clone;
  if (TFhirPlanDefinitionAction(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirPlanDefinitionActionParticipantList.Create;
    FParticipantList.Assign(TFhirPlanDefinitionAction(oSource).FParticipantList);
  end;
  type_ := TFhirPlanDefinitionAction(oSource).type_.Clone;
  groupingBehaviorElement := TFhirPlanDefinitionAction(oSource).groupingBehaviorElement.Clone;
  selectionBehaviorElement := TFhirPlanDefinitionAction(oSource).selectionBehaviorElement.Clone;
  requiredBehaviorElement := TFhirPlanDefinitionAction(oSource).requiredBehaviorElement.Clone;
  precheckBehaviorElement := TFhirPlanDefinitionAction(oSource).precheckBehaviorElement.Clone;
  cardinalityBehaviorElement := TFhirPlanDefinitionAction(oSource).cardinalityBehaviorElement.Clone;
  definition := TFhirPlanDefinitionAction(oSource).definition.Clone;
  transformElement := TFhirPlanDefinitionAction(oSource).transformElement.Clone;
  if (TFhirPlanDefinitionAction(oSource).FDynamicValueList = nil) then
  begin
    FDynamicValueList.free;
    FDynamicValueList := nil;
  end
  else
  begin
    if FDynamicValueList = nil then
      FDynamicValueList := TFhirPlanDefinitionActionDynamicValueList.Create;
    FDynamicValueList.Assign(TFhirPlanDefinitionAction(oSource).FDynamicValueList);
  end;
  if (TFhirPlanDefinitionAction(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirPlanDefinitionActionList.Create;
    FActionList.Assign(TFhirPlanDefinitionAction(oSource).FActionList);
  end;
end;

procedure TFhirPlanDefinitionAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'prefix') Then
     list.add(self.link, 'prefix', FPrefix.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'textEquivalent') Then
     list.add(self.link, 'textEquivalent', FTextEquivalent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'goalId') Then
    list.addAll(self, 'goalId', FGoalIdList);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'trigger') Then
    list.addAll(self, 'trigger', FTriggerList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'output') Then
    list.addAll(self, 'output', FOutputList);
  if (child_name = 'relatedAction') Then
    list.addAll(self, 'relatedAction', FRelatedActionList);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupingBehavior') Then
     list.add(self.link, 'groupingBehavior', FGroupingBehavior.Link);
  if (child_name = 'selectionBehavior') Then
     list.add(self.link, 'selectionBehavior', FSelectionBehavior.Link);
  if (child_name = 'requiredBehavior') Then
     list.add(self.link, 'requiredBehavior', FRequiredBehavior.Link);
  if (child_name = 'precheckBehavior') Then
     list.add(self.link, 'precheckBehavior', FPrecheckBehavior.Link);
  if (child_name = 'cardinalityBehavior') Then
     list.add(self.link, 'cardinalityBehavior', FCardinalityBehavior.Link);
  if (child_name = 'definition[x]') or (child_name = 'definition') Then
     list.add(self.link, 'definition[x]', FDefinition.Link);
  if (child_name = 'transform') Then
     list.add(self.link, 'transform', FTransform.Link);
  if (child_name = 'dynamicValue') Then
    list.addAll(self, 'dynamicValue', FDynamicValueList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirPlanDefinitionAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'prefix', 'string', false, TFhirString, FPrefix.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'textEquivalent', 'string', false, TFhirString, FTextEquivalent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link));
  oList.add(TFHIRProperty.create(self, 'goalId', 'id', true, TFhirId, FGoalIdList.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference|canonical', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'trigger', 'TriggerDefinition', true, TFhirTriggerDefinition, FTriggerList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'BackboneElement', true, TFhirPlanDefinitionActionCondition, FConditionList.Link));
  oList.add(TFHIRProperty.create(self, 'input', 'DataRequirement', true, TFhirDataRequirement, FInputList.Link));
  oList.add(TFHIRProperty.create(self, 'output', 'DataRequirement', true, TFhirDataRequirement, FOutputList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedAction', 'BackboneElement', true, TFhirPlanDefinitionActionRelatedAction, FRelatedActionList.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Age|Period|Duration|Range|Timing', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirPlanDefinitionActionParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'groupingBehavior', 'code', false, TFhirEnum, FGroupingBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'selectionBehavior', 'code', false, TFhirEnum, FSelectionBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'requiredBehavior', 'code', false, TFhirEnum, FRequiredBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'precheckBehavior', 'code', false, TFhirEnum, FPrecheckBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'cardinalityBehavior', 'code', false, TFhirEnum, FCardinalityBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'definition[x]', 'canonical|uri', false, TFhirDataType, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'transform', 'canonical', false, TFhirCanonical, FTransform.Link));
  oList.add(TFHIRProperty.create(self, 'dynamicValue', 'BackboneElement', true, TFhirPlanDefinitionActionDynamicValue, FDynamicValueList.Link));
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirPlanDefinitionAction, FActionList.Link));
end;

function TFhirPlanDefinitionAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'prefix') then
  begin
    PrefixElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'textEquivalent') then
  begin
    TextEquivalentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'goalId') then
  begin
    GoalIdList.add(asId(propValue)){2};     result := propValue;

  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'trigger') then
  begin
    TriggerList.add(propValue as TFhirTriggerDefinition);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirPlanDefinitionActionCondition);
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirDataRequirement);
    result := propValue;
  end
  else if (propName = 'output') then
  begin
    OutputList.add(propValue as TFhirDataRequirement);
    result := propValue;
  end
  else if (propName = 'relatedAction') then
  begin
    RelatedActionList.add(propValue as TFhirPlanDefinitionActionRelatedAction);
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirPlanDefinitionActionParticipant);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'groupingBehavior') then
  begin
    GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'selectionBehavior') then
  begin
    SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'requiredBehavior') then
  begin
    RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'precheckBehavior') then
  begin
    PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'cardinalityBehavior') then
  begin
    CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then
  begin
    Definition := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'transform') then
  begin
    TransformElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'dynamicValue') then
  begin
    DynamicValueList.add(propValue as TFhirPlanDefinitionActionDynamicValue);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirPlanDefinitionAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'goalId') then GoalIdList.insertItem(index, asId(propValue))
  else if (propName = 'trigger') then TriggerList.insertItem(index, propValue as TFhirTriggerDefinition)
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirPlanDefinitionActionCondition)
  else if (propName = 'input') then InputList.insertItem(index, propValue as TFhirDataRequirement)
  else if (propName = 'output') then OutputList.insertItem(index, propValue as TFhirDataRequirement)
  else if (propName = 'relatedAction') then RelatedActionList.insertItem(index, propValue as TFhirPlanDefinitionActionRelatedAction)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirPlanDefinitionActionParticipant)
  else if (propName = 'dynamicValue') then DynamicValueList.insertItem(index, propValue as TFhirPlanDefinitionActionDynamicValue)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirPlanDefinitionAction)
  else inherited;
end;

function TFhirPlanDefinitionAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'prefix') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'textEquivalent') then result := TFhirString.create()
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'documentation') then result := DocumentationList.new()
  else if (propName = 'goalId') then result := GoalIdList.new()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'trigger') then result := TriggerList.new()
  else if (propName = 'condition') then result := ConditionList.new()
  else if (propName = 'input') then result := InputList.new()
  else if (propName = 'output') then result := OutputList.new()
  else if (propName = 'relatedAction') then result := RelatedActionList.new()
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'groupingBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[ActionGroupingBehaviorNull], CODES_TFhirActionGroupingBehaviorEnum[ActionGroupingBehaviorNull]) 
  else if (propName = 'selectionBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[ActionSelectionBehaviorNull], CODES_TFhirActionSelectionBehaviorEnum[ActionSelectionBehaviorNull]) 
  else if (propName = 'requiredBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[ActionRequiredBehaviorNull], CODES_TFhirActionRequiredBehaviorEnum[ActionRequiredBehaviorNull]) 
  else if (propName = 'precheckBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[ActionPrecheckBehaviorNull], CODES_TFhirActionPrecheckBehaviorEnum[ActionPrecheckBehaviorNull]) 
  else if (propName = 'cardinalityBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[ActionCardinalityBehaviorNull], CODES_TFhirActionCardinalityBehaviorEnum[ActionCardinalityBehaviorNull]) 
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then raise EFHIRException.create('Cannot make property Definition')
  else if (propName = 'transform') then result := TFhirCanonical.create()
  else if (propName = 'dynamicValue') then result := DynamicValueList.new()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'prefix') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'textEquivalent') then result := 'string'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'goalId') then result := 'id'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference|canonical'
  else if (propName = 'trigger') then result := 'TriggerDefinition'
  else if (propName = 'condition') then result := 'BackboneElement'
  else if (propName = 'input') then result := 'DataRequirement'
  else if (propName = 'output') then result := 'DataRequirement'
  else if (propName = 'relatedAction') then result := 'BackboneElement'
  else if (propName = 'timing[x]') then result := 'dateTime|Age|Period|Duration|Range|Timing'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'groupingBehavior') then result := 'code'
  else if (propName = 'selectionBehavior') then result := 'code'
  else if (propName = 'requiredBehavior') then result := 'code'
  else if (propName = 'precheckBehavior') then result := 'code'
  else if (propName = 'cardinalityBehavior') then result := 'code'
  else if (propName = 'definition[x]') then result := 'canonical|uri'
  else if (propName = 'transform') then result := 'canonical'
  else if (propName = 'dynamicValue') then result := 'BackboneElement'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'prefix') then PrefixElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'textEquivalent') then TextEquivalentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value)
  else if (propName = 'goalId') then deletePropertyValue('goalId', GoalIdList, value)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := nil
  else if (propName = 'trigger') then deletePropertyValue('trigger', TriggerList, value)
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value)
  else if (propName = 'input') then deletePropertyValue('input', InputList, value)
  else if (propName = 'output') then deletePropertyValue('output', OutputList, value)
  else if (propName = 'relatedAction') then deletePropertyValue('relatedAction', RelatedActionList, value)
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := nil
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := nil
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := nil
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := nil
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := nil
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then DefinitionElement := nil
  else if (propName = 'transform') then TransformElement := nil
  else if (propName = 'dynamicValue') then deletePropertyValue('dynamicValue', DynamicValueList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'prefix') then PrefixElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'textEquivalent') then TextEquivalentElement := asString(new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new)
  else if (propName = 'goalId') then replacePropertyValue('goalId', GoalIdList, existing, new)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'trigger') then replacePropertyValue('trigger', TriggerList, existing, new)
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new)
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new)
  else if (propName = 'output') then replacePropertyValue('output', OutputList, existing, new)
  else if (propName = 'relatedAction') then replacePropertyValue('relatedAction', RelatedActionList, existing, new)
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := new as TFhirDataType
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, new)
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, new)
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, new)
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, new)
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, new)
  else if (isMatchingName(propName, 'definition', ['Canonical', 'Uri'])) then DefinitionElement := new as TFhirDataType
  else if (propName = 'transform') then TransformElement := asCanonical(new)
  else if (propName = 'dynamicValue') then replacePropertyValue('dynamicValue', DynamicValueList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'documentation') then DocumentationList.move(source, destination)
  else if (propName = 'goalId') then GoalIdList.move(source, destination)
  else if (propName = 'trigger') then TriggerList.move(source, destination)
  else if (propName = 'condition') then ConditionList.move(source, destination)
  else if (propName = 'input') then InputList.move(source, destination)
  else if (propName = 'output') then OutputList.move(source, destination)
  else if (propName = 'relatedAction') then RelatedActionList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'dynamicValue') then DynamicValueList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionAction.fhirType : string;
begin
  result := 'PlanDefinition.action';
end;

function TFhirPlanDefinitionAction.Link : TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(inherited Link);
end;

function TFhirPlanDefinitionAction.Clone : TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(inherited Clone);
end;

function TFhirPlanDefinitionAction.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionAction)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionAction(other);
    result := compareDeep(prefixElement, o.prefixElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(textEquivalentElement, o.textEquivalentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(reasonList, o.reasonList, true) and compareDeep(documentationList, o.documentationList, true) and 
      compareDeep(goalIdList, o.goalIdList, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(triggerList, o.triggerList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(inputList, o.inputList, true) and compareDeep(outputList, o.outputList, true) and 
      compareDeep(relatedActionList, o.relatedActionList, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(groupingBehaviorElement, o.groupingBehaviorElement, true) and compareDeep(selectionBehaviorElement, o.selectionBehaviorElement, true) and 
      compareDeep(requiredBehaviorElement, o.requiredBehaviorElement, true) and compareDeep(precheckBehaviorElement, o.precheckBehaviorElement, true) and 
      compareDeep(cardinalityBehaviorElement, o.cardinalityBehaviorElement, true) and 
      compareDeep(definitionElement, o.definitionElement, true) and compareDeep(transformElement, o.transformElement, true) and 
      compareDeep(dynamicValueList, o.dynamicValueList, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirPlanDefinitionAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPrefix) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FTextEquivalent) and isEmptyProp(FPriority) and isEmptyProp(FcodeList) and isEmptyProp(FreasonList) and isEmptyProp(FdocumentationList) and isEmptyProp(FgoalIdList) and isEmptyProp(FSubject) and isEmptyProp(FtriggerList) and isEmptyProp(FconditionList) and isEmptyProp(FinputList) and isEmptyProp(FoutputList) and isEmptyProp(FrelatedActionList) and isEmptyProp(FTiming) and isEmptyProp(FparticipantList) and isEmptyProp(FType_) and isEmptyProp(FGroupingBehavior) and isEmptyProp(FSelectionBehavior) and isEmptyProp(FRequiredBehavior) and isEmptyProp(FPrecheckBehavior) and isEmptyProp(FCardinalityBehavior) and isEmptyProp(FDefinition) and isEmptyProp(FTransform) and isEmptyProp(FdynamicValueList) and isEmptyProp(FactionList);
end;

procedure TFhirPlanDefinitionAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('prefix');
  fields.add('title');
  fields.add('description');
  fields.add('textEquivalent');
  fields.add('priority');
  fields.add('code');
  fields.add('reason');
  fields.add('documentation');
  fields.add('goalId');
  fields.add('subject[x]');
  fields.add('trigger');
  fields.add('condition');
  fields.add('input');
  fields.add('output');
  fields.add('relatedAction');
  fields.add('timing[x]');
  fields.add('participant');
  fields.add('type');
  fields.add('groupingBehavior');
  fields.add('selectionBehavior');
  fields.add('requiredBehavior');
  fields.add('precheckBehavior');
  fields.add('cardinalityBehavior');
  fields.add('definition[x]');
  fields.add('transform');
  fields.add('dynamicValue');
  fields.add('action');
end;

function TFhirPlanDefinitionAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FDocumentationList.sizeInBytes(magic));
  inc(result, FGoalIdList.sizeInBytes(magic));
  inc(result, FTriggerList.sizeInBytes(magic));
  inc(result, FConditionList.sizeInBytes(magic));
  inc(result, FInputList.sizeInBytes(magic));
  inc(result, FOutputList.sizeInBytes(magic));
  inc(result, FRelatedActionList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FDynamicValueList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirPlanDefinitionAction.SetPrefix(value : TFhirString);
begin
  FPrefix.free;
  FPrefix := value;
end;

function TFhirPlanDefinitionAction.GetPrefixST : String;
begin
  if FPrefix = nil then
    result := ''
  else
    result := FPrefix.value;
end;

procedure TFhirPlanDefinitionAction.SetPrefixST(value : String);
begin
  if value <> '' then
  begin
    if FPrefix = nil then
      FPrefix := TFhirString.create;
    FPrefix.value := value
  end
  else if FPrefix <> nil then
    FPrefix.value := '';
end;

procedure TFhirPlanDefinitionAction.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirPlanDefinitionAction.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirPlanDefinitionAction.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirPlanDefinitionAction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirPlanDefinitionAction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPlanDefinitionAction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirPlanDefinitionAction.SetTextEquivalent(value : TFhirString);
begin
  FTextEquivalent.free;
  FTextEquivalent := value;
end;

function TFhirPlanDefinitionAction.GetTextEquivalentST : String;
begin
  if FTextEquivalent = nil then
    result := ''
  else
    result := FTextEquivalent.value;
end;

procedure TFhirPlanDefinitionAction.SetTextEquivalentST(value : String);
begin
  if value <> '' then
  begin
    if FTextEquivalent = nil then
      FTextEquivalent := TFhirString.create;
    FTextEquivalent.value := value
  end
  else if FTextEquivalent <> nil then
    FTextEquivalent.value := '';
end;

procedure TFhirPlanDefinitionAction.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirPlanDefinitionAction.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirPlanDefinitionAction.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

function TFhirPlanDefinitionAction.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirPlanDefinitionAction.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirPlanDefinitionAction.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

function TFhirPlanDefinitionAction.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

function TFhirPlanDefinitionAction.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

function TFhirPlanDefinitionAction.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

function TFhirPlanDefinitionAction.GetGoalIdList : TFhirIdList;
begin
  if FGoalIdList = nil then
    FGoalIdList := TFhirIdList.Create;
  result := FGoalIdList;
end;

function TFhirPlanDefinitionAction.GetHasGoalIdList : boolean;
begin
  result := (FGoalIdList <> nil) and (FGoalIdList.count > 0);
end;

procedure TFhirPlanDefinitionAction.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

function TFhirPlanDefinitionAction.GetTriggerList : TFhirTriggerDefinitionList;
begin
  if FTriggerList = nil then
    FTriggerList := TFhirTriggerDefinitionList.Create;
  result := FTriggerList;
end;

function TFhirPlanDefinitionAction.GetHasTriggerList : boolean;
begin
  result := (FTriggerList <> nil) and (FTriggerList.count > 0);
end;

function TFhirPlanDefinitionAction.GetConditionList : TFhirPlanDefinitionActionConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirPlanDefinitionActionConditionList.Create;
  result := FConditionList;
end;

function TFhirPlanDefinitionAction.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirPlanDefinitionAction.GetInputList : TFhirDataRequirementList;
begin
  if FInputList = nil then
    FInputList := TFhirDataRequirementList.Create;
  result := FInputList;
end;

function TFhirPlanDefinitionAction.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

function TFhirPlanDefinitionAction.GetOutputList : TFhirDataRequirementList;
begin
  if FOutputList = nil then
    FOutputList := TFhirDataRequirementList.Create;
  result := FOutputList;
end;

function TFhirPlanDefinitionAction.GetHasOutputList : boolean;
begin
  result := (FOutputList <> nil) and (FOutputList.count > 0);
end;

function TFhirPlanDefinitionAction.GetRelatedActionList : TFhirPlanDefinitionActionRelatedActionList;
begin
  if FRelatedActionList = nil then
    FRelatedActionList := TFhirPlanDefinitionActionRelatedActionList.Create;
  result := FRelatedActionList;
end;

function TFhirPlanDefinitionAction.GetHasRelatedActionList : boolean;
begin
  result := (FRelatedActionList <> nil) and (FRelatedActionList.count > 0);
end;

procedure TFhirPlanDefinitionAction.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

function TFhirPlanDefinitionAction.GetParticipantList : TFhirPlanDefinitionActionParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirPlanDefinitionActionParticipantList.Create;
  result := FParticipantList;
end;

function TFhirPlanDefinitionAction.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirPlanDefinitionAction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirPlanDefinitionAction.SetGroupingBehavior(value : TFhirEnum);
begin
  FGroupingBehavior.free;
  FGroupingBehavior := value;
end;

function TFhirPlanDefinitionAction.GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
begin
  if FGroupingBehavior = nil then
    result := TFhirActionGroupingBehaviorEnum(0)
  else
    result := TFhirActionGroupingBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionGroupingBehaviorEnum, FGroupingBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
begin
  if ord(value) = 0 then
    GroupingBehaviorElement := nil
  else
    GroupingBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[value], CODES_TFhirActionGroupingBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetSelectionBehavior(value : TFhirEnum);
begin
  FSelectionBehavior.free;
  FSelectionBehavior := value;
end;

function TFhirPlanDefinitionAction.GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
begin
  if FSelectionBehavior = nil then
    result := TFhirActionSelectionBehaviorEnum(0)
  else
    result := TFhirActionSelectionBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionSelectionBehaviorEnum, FSelectionBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
begin
  if ord(value) = 0 then
    SelectionBehaviorElement := nil
  else
    SelectionBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[value], CODES_TFhirActionSelectionBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetRequiredBehavior(value : TFhirEnum);
begin
  FRequiredBehavior.free;
  FRequiredBehavior := value;
end;

function TFhirPlanDefinitionAction.GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
begin
  if FRequiredBehavior = nil then
    result := TFhirActionRequiredBehaviorEnum(0)
  else
    result := TFhirActionRequiredBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRequiredBehaviorEnum, FRequiredBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
begin
  if ord(value) = 0 then
    RequiredBehaviorElement := nil
  else
    RequiredBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[value], CODES_TFhirActionRequiredBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetPrecheckBehavior(value : TFhirEnum);
begin
  FPrecheckBehavior.free;
  FPrecheckBehavior := value;
end;

function TFhirPlanDefinitionAction.GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
begin
  if FPrecheckBehavior = nil then
    result := TFhirActionPrecheckBehaviorEnum(0)
  else
    result := TFhirActionPrecheckBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionPrecheckBehaviorEnum, FPrecheckBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
begin
  if ord(value) = 0 then
    PrecheckBehaviorElement := nil
  else
    PrecheckBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[value], CODES_TFhirActionPrecheckBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetCardinalityBehavior(value : TFhirEnum);
begin
  FCardinalityBehavior.free;
  FCardinalityBehavior := value;
end;

function TFhirPlanDefinitionAction.GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
begin
  if FCardinalityBehavior = nil then
    result := TFhirActionCardinalityBehaviorEnum(0)
  else
    result := TFhirActionCardinalityBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionCardinalityBehaviorEnum, FCardinalityBehavior.value));
end;

procedure TFhirPlanDefinitionAction.SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
begin
  if ord(value) = 0 then
    CardinalityBehaviorElement := nil
  else
    CardinalityBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[value], CODES_TFhirActionCardinalityBehaviorEnum[value]);
end;

procedure TFhirPlanDefinitionAction.SetDefinition(value : TFhirDataType);
begin
  FDefinition.free;
  FDefinition := value;
end;

procedure TFhirPlanDefinitionAction.SetTransform(value : TFhirCanonical);
begin
  FTransform.free;
  FTransform := value;
end;

function TFhirPlanDefinitionAction.GetTransformST : String;
begin
  if FTransform = nil then
    result := ''
  else
    result := FTransform.value;
end;

procedure TFhirPlanDefinitionAction.SetTransformST(value : String);
begin
  if value <> '' then
  begin
    if FTransform = nil then
      FTransform := TFhirCanonical.create;
    FTransform.value := value
  end
  else if FTransform <> nil then
    FTransform.value := '';
end;

function TFhirPlanDefinitionAction.GetDynamicValueList : TFhirPlanDefinitionActionDynamicValueList;
begin
  if FDynamicValueList = nil then
    FDynamicValueList := TFhirPlanDefinitionActionDynamicValueList.Create;
  result := FDynamicValueList;
end;

function TFhirPlanDefinitionAction.GetHasDynamicValueList : boolean;
begin
  result := (FDynamicValueList <> nil) and (FDynamicValueList.count > 0);
end;

function TFhirPlanDefinitionAction.GetActionList : TFhirPlanDefinitionActionList;
begin
  if FActionList = nil then
    FActionList := TFhirPlanDefinitionActionList.Create;
  result := FActionList;
end;

function TFhirPlanDefinitionAction.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirPlanDefinitionActionListEnumerator }

constructor TFhirPlanDefinitionActionListEnumerator.Create(list : TFhirPlanDefinitionActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionListEnumerator.GetCurrent : TFhirPlanDefinitionAction;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionList }

function TFhirPlanDefinitionActionList.AddItem(value: TFhirPlanDefinitionAction): TFhirPlanDefinitionAction;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionAction');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionList.Append: TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionList.GetEnumerator : TFhirPlanDefinitionActionListEnumerator;
begin
  result := TFhirPlanDefinitionActionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionList.Clone: TFhirPlanDefinitionActionList;
begin
  result := TFhirPlanDefinitionActionList(inherited Clone);
end;

function TFhirPlanDefinitionActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionList.GetItemN(index: Integer): TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionAction;
end;
function TFhirPlanDefinitionActionList.IndexOf(value: TFhirPlanDefinitionAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionList.Insert(index: Integer): TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionList.InsertItem(index: Integer; value: TFhirPlanDefinitionAction);
begin
  assert(value is TFhirPlanDefinitionAction);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionList.Item(index: Integer): TFhirPlanDefinitionAction;
begin
  result := TFhirPlanDefinitionAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionList.Link: TFhirPlanDefinitionActionList;
begin
  result := TFhirPlanDefinitionActionList(inherited Link);
end;

procedure TFhirPlanDefinitionActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionAction);
begin
  assert(value is TFhirPlanDefinitionAction);
  FhirPlanDefinitionActions[index] := value;
end;

procedure TFhirPlanDefinitionActionList.SetItemN(index: Integer; value: TFhirPlanDefinitionAction);
begin
  assert(value is TFhirPlanDefinitionAction);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionCondition }

constructor TFhirPlanDefinitionActionCondition.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionCondition.Destroy;
begin
  FKind.free;
  FExpression.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionCondition.Assign(oSource : TFslObject);
begin
  inherited;
  kindElement := TFhirPlanDefinitionActionCondition(oSource).kindElement.Clone;
  expression := TFhirPlanDefinitionActionCondition(oSource).expression.Clone;
end;

procedure TFhirPlanDefinitionActionCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirPlanDefinitionActionCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirPlanDefinitionActionCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[ActionConditionKindNull], CODES_TFhirActionConditionKindEnum[ActionConditionKindNull]) 
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionCondition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionCondition.fhirType : string;
begin
  result := 'PlanDefinition.action.condition';
end;

function TFhirPlanDefinitionActionCondition.Link : TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(inherited Link);
end;

function TFhirPlanDefinitionActionCondition.Clone : TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(inherited Clone);
end;

function TFhirPlanDefinitionActionCondition.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionCondition)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionCondition(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirPlanDefinitionActionCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FExpression);
end;

procedure TFhirPlanDefinitionActionCondition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('kind');
  fields.add('expression');
end;

function TFhirPlanDefinitionActionCondition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionCondition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirPlanDefinitionActionCondition.GetKindST : TFhirActionConditionKindEnum;
begin
  if FKind = nil then
    result := TFhirActionConditionKindEnum(0)
  else
    result := TFhirActionConditionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirActionConditionKindEnum, FKind.value));
end;

procedure TFhirPlanDefinitionActionCondition.SetKindST(value : TFhirActionConditionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[value], CODES_TFhirActionConditionKindEnum[value]);
end;

procedure TFhirPlanDefinitionActionCondition.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirPlanDefinitionActionConditionListEnumerator }

constructor TFhirPlanDefinitionActionConditionListEnumerator.Create(list : TFhirPlanDefinitionActionConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionConditionListEnumerator.GetCurrent : TFhirPlanDefinitionActionCondition;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionConditionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionConditionList }

function TFhirPlanDefinitionActionConditionList.AddItem(value: TFhirPlanDefinitionActionCondition): TFhirPlanDefinitionActionCondition;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionCondition');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionConditionList.Append: TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionConditionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionConditionList.GetEnumerator : TFhirPlanDefinitionActionConditionListEnumerator;
begin
  result := TFhirPlanDefinitionActionConditionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionConditionList.Clone: TFhirPlanDefinitionActionConditionList;
begin
  result := TFhirPlanDefinitionActionConditionList(inherited Clone);
end;

function TFhirPlanDefinitionActionConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionConditionList.GetItemN(index: Integer): TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionCondition;
end;
function TFhirPlanDefinitionActionConditionList.IndexOf(value: TFhirPlanDefinitionActionCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionConditionList.Insert(index: Integer): TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionConditionList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionCondition);
begin
  assert(value is TFhirPlanDefinitionActionCondition);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionConditionList.Item(index: Integer): TFhirPlanDefinitionActionCondition;
begin
  result := TFhirPlanDefinitionActionCondition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionConditionList.Link: TFhirPlanDefinitionActionConditionList;
begin
  result := TFhirPlanDefinitionActionConditionList(inherited Link);
end;

procedure TFhirPlanDefinitionActionConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionConditionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionCondition);
begin
  assert(value is TFhirPlanDefinitionActionCondition);
  FhirPlanDefinitionActionConditions[index] := value;
end;

procedure TFhirPlanDefinitionActionConditionList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionCondition);
begin
  assert(value is TFhirPlanDefinitionActionCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionRelatedAction }

constructor TFhirPlanDefinitionActionRelatedAction.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionRelatedAction.Destroy;
begin
  FActionId.free;
  FRelationship.free;
  FOffset.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionRelatedAction.Assign(oSource : TFslObject);
begin
  inherited;
  actionIdElement := TFhirPlanDefinitionActionRelatedAction(oSource).actionIdElement.Clone;
  relationshipElement := TFhirPlanDefinitionActionRelatedAction(oSource).relationshipElement.Clone;
  offset := TFhirPlanDefinitionActionRelatedAction(oSource).offset.Clone;
end;

procedure TFhirPlanDefinitionActionRelatedAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actionId') Then
     list.add(self.link, 'actionId', FActionId.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'offset[x]') or (child_name = 'offset') Then
     list.add(self.link, 'offset[x]', FOffset.Link);
end;

procedure TFhirPlanDefinitionActionRelatedAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actionId', 'id', false, TFhirId, FActionId.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', false, TFhirEnum, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'offset[x]', 'Duration|Range', false, TFhirDataType, FOffset.Link));
end;

function TFhirPlanDefinitionActionRelatedAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actionId') then
  begin
    ActionIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then
  begin
    Offset := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionRelatedAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionRelatedAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actionId') then result := TFhirId.create()
  else if (propName = 'relationship') then result := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[ActionRelationshipTypeNull], CODES_TFhirActionRelationshipTypeEnum[ActionRelationshipTypeNull]) 
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then raise EFHIRException.create('Cannot make property Offset')
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionRelatedAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actionId') then result := 'id'
  else if (propName = 'relationship') then result := 'code'
  else if (propName = 'offset[x]') then result := 'Duration|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionRelatedAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionRelatedAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := asId(new)
  else if (propName = 'relationship') then RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, new)
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionRelatedAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionRelatedAction.fhirType : string;
begin
  result := 'PlanDefinition.action.relatedAction';
end;

function TFhirPlanDefinitionActionRelatedAction.Link : TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(inherited Link);
end;

function TFhirPlanDefinitionActionRelatedAction.Clone : TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(inherited Clone);
end;

function TFhirPlanDefinitionActionRelatedAction.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionRelatedAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionRelatedAction)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionRelatedAction(other);
    result := compareDeep(actionIdElement, o.actionIdElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirPlanDefinitionActionRelatedAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActionId) and isEmptyProp(FRelationship) and isEmptyProp(FOffset);
end;

procedure TFhirPlanDefinitionActionRelatedAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('actionId');
  fields.add('relationship');
  fields.add('offset[x]');
end;

function TFhirPlanDefinitionActionRelatedAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetActionId(value : TFhirId);
begin
  FActionId.free;
  FActionId := value;
end;

function TFhirPlanDefinitionActionRelatedAction.GetActionIdST : String;
begin
  if FActionId = nil then
    result := ''
  else
    result := FActionId.value;
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetActionIdST(value : String);
begin
  if value <> '' then
  begin
    if FActionId = nil then
      FActionId := TFhirId.create;
    FActionId.value := value
  end
  else if FActionId <> nil then
    FActionId.value := '';
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

function TFhirPlanDefinitionActionRelatedAction.GetRelationshipST : TFhirActionRelationshipTypeEnum;
begin
  if FRelationship = nil then
    result := TFhirActionRelationshipTypeEnum(0)
  else
    result := TFhirActionRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRelationshipTypeEnum, FRelationship.value));
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    RelationshipElement := nil
  else
    RelationshipElement := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[value], CODES_TFhirActionRelationshipTypeEnum[value]);
end;

procedure TFhirPlanDefinitionActionRelatedAction.SetOffset(value : TFhirDataType);
begin
  FOffset.free;
  FOffset := value;
end;

{ TFhirPlanDefinitionActionRelatedActionListEnumerator }

constructor TFhirPlanDefinitionActionRelatedActionListEnumerator.Create(list : TFhirPlanDefinitionActionRelatedActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionRelatedActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionRelatedActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionRelatedActionListEnumerator.GetCurrent : TFhirPlanDefinitionActionRelatedAction;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionRelatedActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionRelatedActionList }

function TFhirPlanDefinitionActionRelatedActionList.AddItem(value: TFhirPlanDefinitionActionRelatedAction): TFhirPlanDefinitionActionRelatedAction;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionRelatedAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionRelatedAction');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionRelatedActionList.Append: TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionRelatedActionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionRelatedActionList.GetEnumerator : TFhirPlanDefinitionActionRelatedActionListEnumerator;
begin
  result := TFhirPlanDefinitionActionRelatedActionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionRelatedActionList.Clone: TFhirPlanDefinitionActionRelatedActionList;
begin
  result := TFhirPlanDefinitionActionRelatedActionList(inherited Clone);
end;

function TFhirPlanDefinitionActionRelatedActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionRelatedActionList.GetItemN(index: Integer): TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionRelatedActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionRelatedAction;
end;
function TFhirPlanDefinitionActionRelatedActionList.IndexOf(value: TFhirPlanDefinitionActionRelatedAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionRelatedActionList.Insert(index: Integer): TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionRelatedActionList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value is TFhirPlanDefinitionActionRelatedAction);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionRelatedActionList.Item(index: Integer): TFhirPlanDefinitionActionRelatedAction;
begin
  result := TFhirPlanDefinitionActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionRelatedActionList.Link: TFhirPlanDefinitionActionRelatedActionList;
begin
  result := TFhirPlanDefinitionActionRelatedActionList(inherited Link);
end;

procedure TFhirPlanDefinitionActionRelatedActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionRelatedActionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value is TFhirPlanDefinitionActionRelatedAction);
  FhirPlanDefinitionActionRelatedActions[index] := value;
end;

procedure TFhirPlanDefinitionActionRelatedActionList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionRelatedAction);
begin
  assert(value is TFhirPlanDefinitionActionRelatedAction);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionParticipant }

constructor TFhirPlanDefinitionActionParticipant.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionParticipant.Destroy;
begin
  FType_.free;
  FRole.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirPlanDefinitionActionParticipant(oSource).type_Element.Clone;
  role := TFhirPlanDefinitionActionParticipant(oSource).role.Clone;
end;

procedure TFhirPlanDefinitionActionParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
end;

procedure TFhirPlanDefinitionActionParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', false, TFhirCodeableConcept, FRole.Link));
end;

function TFhirPlanDefinitionActionParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    Role := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull], CODES_TFhirActionParticipantTypeEnum[ActionParticipantTypeNull]) 
  else if (propName = 'role') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'role') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then RoleElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirActionParticipantTypeEnum, CODES_TFhirActionParticipantTypeEnum, new)
  else if (propName = 'role') then RoleElement := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionParticipant.fhirType : string;
begin
  result := 'PlanDefinition.action.participant';
end;

function TFhirPlanDefinitionActionParticipant.Link : TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(inherited Link);
end;

function TFhirPlanDefinitionActionParticipant.Clone : TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(inherited Clone);
end;

function TFhirPlanDefinitionActionParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionParticipant)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleElement, o.roleElement, true);
  end;
end;

function TFhirPlanDefinitionActionParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FRole);
end;

procedure TFhirPlanDefinitionActionParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
end;

function TFhirPlanDefinitionActionParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirPlanDefinitionActionParticipant.GetType_ST : TFhirActionParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirActionParticipantTypeEnum(0)
  else
    result := TFhirActionParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionParticipantTypeEnum, FType_.value));
end;

procedure TFhirPlanDefinitionActionParticipant.SetType_ST(value : TFhirActionParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirActionParticipantTypeEnum[value], CODES_TFhirActionParticipantTypeEnum[value]);
end;

procedure TFhirPlanDefinitionActionParticipant.SetRole(value : TFhirCodeableConcept);
begin
  FRole.free;
  FRole := value;
end;

{ TFhirPlanDefinitionActionParticipantListEnumerator }

constructor TFhirPlanDefinitionActionParticipantListEnumerator.Create(list : TFhirPlanDefinitionActionParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionParticipantListEnumerator.GetCurrent : TFhirPlanDefinitionActionParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionParticipantList }

function TFhirPlanDefinitionActionParticipantList.AddItem(value: TFhirPlanDefinitionActionParticipant): TFhirPlanDefinitionActionParticipant;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionParticipant');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionParticipantList.Append: TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionParticipantList.GetEnumerator : TFhirPlanDefinitionActionParticipantListEnumerator;
begin
  result := TFhirPlanDefinitionActionParticipantListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionParticipantList.Clone: TFhirPlanDefinitionActionParticipantList;
begin
  result := TFhirPlanDefinitionActionParticipantList(inherited Clone);
end;

function TFhirPlanDefinitionActionParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionParticipantList.GetItemN(index: Integer): TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionParticipant;
end;
function TFhirPlanDefinitionActionParticipantList.IndexOf(value: TFhirPlanDefinitionActionParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionParticipantList.Insert(index: Integer): TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionParticipantList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value is TFhirPlanDefinitionActionParticipant);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionParticipantList.Item(index: Integer): TFhirPlanDefinitionActionParticipant;
begin
  result := TFhirPlanDefinitionActionParticipant(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionParticipantList.Link: TFhirPlanDefinitionActionParticipantList;
begin
  result := TFhirPlanDefinitionActionParticipantList(inherited Link);
end;

procedure TFhirPlanDefinitionActionParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionParticipantList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value is TFhirPlanDefinitionActionParticipant);
  FhirPlanDefinitionActionParticipants[index] := value;
end;

procedure TFhirPlanDefinitionActionParticipantList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionParticipant);
begin
  assert(value is TFhirPlanDefinitionActionParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinitionActionDynamicValue }

constructor TFhirPlanDefinitionActionDynamicValue.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinitionActionDynamicValue.Destroy;
begin
  FPath.free;
  FExpression.free;
  inherited;
end;

procedure TFhirPlanDefinitionActionDynamicValue.Assign(oSource : TFslObject);
begin
  inherited;
  pathElement := TFhirPlanDefinitionActionDynamicValue(oSource).pathElement.Clone;
  expression := TFhirPlanDefinitionActionDynamicValue(oSource).expression.Clone;
end;

procedure TFhirPlanDefinitionActionDynamicValue.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'path') Then
     list.add(self.link, 'path', FPath.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirPlanDefinitionActionDynamicValue.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'path', 'string', false, TFhirString, FPath.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirPlanDefinitionActionDynamicValue.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'path') then
  begin
    PathElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinitionActionDynamicValue.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirPlanDefinitionActionDynamicValue.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'path') then result := TFhirString.create()
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinitionActionDynamicValue.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'path') then result := 'string'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinitionActionDynamicValue.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'path') then PathElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinitionActionDynamicValue.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'path') then PathElement := asString(new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinitionActionDynamicValue.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinitionActionDynamicValue.fhirType : string;
begin
  result := 'PlanDefinition.action.dynamicValue';
end;

function TFhirPlanDefinitionActionDynamicValue.Link : TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(inherited Link);
end;

function TFhirPlanDefinitionActionDynamicValue.Clone : TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(inherited Clone);
end;

function TFhirPlanDefinitionActionDynamicValue.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinitionActionDynamicValue;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinitionActionDynamicValue)) then
    result := false
  else
  begin
    o := TFhirPlanDefinitionActionDynamicValue(other);
    result := compareDeep(pathElement, o.pathElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirPlanDefinitionActionDynamicValue.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPath) and isEmptyProp(FExpression);
end;

procedure TFhirPlanDefinitionActionDynamicValue.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('path');
  fields.add('expression');
end;

function TFhirPlanDefinitionActionDynamicValue.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirPlanDefinitionActionDynamicValue.SetPath(value : TFhirString);
begin
  FPath.free;
  FPath := value;
end;

function TFhirPlanDefinitionActionDynamicValue.GetPathST : String;
begin
  if FPath = nil then
    result := ''
  else
    result := FPath.value;
end;

procedure TFhirPlanDefinitionActionDynamicValue.SetPathST(value : String);
begin
  if value <> '' then
  begin
    if FPath = nil then
      FPath := TFhirString.create;
    FPath.value := value
  end
  else if FPath <> nil then
    FPath.value := '';
end;

procedure TFhirPlanDefinitionActionDynamicValue.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirPlanDefinitionActionDynamicValueListEnumerator }

constructor TFhirPlanDefinitionActionDynamicValueListEnumerator.Create(list : TFhirPlanDefinitionActionDynamicValueList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionActionDynamicValueListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionActionDynamicValueListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionActionDynamicValueListEnumerator.GetCurrent : TFhirPlanDefinitionActionDynamicValue;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionActionDynamicValueListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionActionDynamicValueList }

function TFhirPlanDefinitionActionDynamicValueList.AddItem(value: TFhirPlanDefinitionActionDynamicValue): TFhirPlanDefinitionActionDynamicValue;
begin
  assert(value.ClassName = 'TFhirPlanDefinitionActionDynamicValue', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinitionActionDynamicValue');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionActionDynamicValueList.Append: TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionDynamicValueList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionActionDynamicValueList.GetEnumerator : TFhirPlanDefinitionActionDynamicValueListEnumerator;
begin
  result := TFhirPlanDefinitionActionDynamicValueListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionActionDynamicValueList.Clone: TFhirPlanDefinitionActionDynamicValueList;
begin
  result := TFhirPlanDefinitionActionDynamicValueList(inherited Clone);
end;

function TFhirPlanDefinitionActionDynamicValueList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionActionDynamicValueList.GetItemN(index: Integer): TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionDynamicValueList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinitionActionDynamicValue;
end;
function TFhirPlanDefinitionActionDynamicValueList.IndexOf(value: TFhirPlanDefinitionActionDynamicValue): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionActionDynamicValueList.Insert(index: Integer): TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionActionDynamicValueList.InsertItem(index: Integer; value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value is TFhirPlanDefinitionActionDynamicValue);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionActionDynamicValueList.Item(index: Integer): TFhirPlanDefinitionActionDynamicValue;
begin
  result := TFhirPlanDefinitionActionDynamicValue(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionActionDynamicValueList.Link: TFhirPlanDefinitionActionDynamicValueList;
begin
  result := TFhirPlanDefinitionActionDynamicValueList(inherited Link);
end;

procedure TFhirPlanDefinitionActionDynamicValueList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionActionDynamicValueList.SetItemByIndex(index: Integer; value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value is TFhirPlanDefinitionActionDynamicValue);
  FhirPlanDefinitionActionDynamicValues[index] := value;
end;

procedure TFhirPlanDefinitionActionDynamicValueList.SetItemN(index: Integer; value: TFhirPlanDefinitionActionDynamicValue);
begin
  assert(value is TFhirPlanDefinitionActionDynamicValue);
  ObjectByIndex[index] := value;
end;

{ TFhirPlanDefinition }

constructor TFhirPlanDefinition.Create;
begin
  inherited;
end;

destructor TFhirPlanDefinition.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FSubtitle.free;
  FType_.free;
  FStatus.free;
  FExperimental.free;
  FSubject.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FUsage.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FGoalList.Free;
  FActionList.Free;
  inherited;
end;

procedure TFhirPlanDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirPlanDefinition(oSource).urlElement.Clone;
  if (TFhirPlanDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirPlanDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirPlanDefinition(oSource).versionElement.Clone;
  nameElement := TFhirPlanDefinition(oSource).nameElement.Clone;
  titleElement := TFhirPlanDefinition(oSource).titleElement.Clone;
  subtitleElement := TFhirPlanDefinition(oSource).subtitleElement.Clone;
  type_ := TFhirPlanDefinition(oSource).type_.Clone;
  statusElement := TFhirPlanDefinition(oSource).statusElement.Clone;
  experimentalElement := TFhirPlanDefinition(oSource).experimentalElement.Clone;
  subject := TFhirPlanDefinition(oSource).subject.Clone;
  dateElement := TFhirPlanDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirPlanDefinition(oSource).publisherElement.Clone;
  if (TFhirPlanDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirPlanDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirPlanDefinition(oSource).descriptionElement.Clone;
  if (TFhirPlanDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirPlanDefinition(oSource).FUseContextList);
  end;
  if (TFhirPlanDefinition(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirPlanDefinition(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirPlanDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirPlanDefinition(oSource).usageElement.Clone;
  copyrightElement := TFhirPlanDefinition(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirPlanDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirPlanDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirPlanDefinition(oSource).effectivePeriod.Clone;
  if (TFhirPlanDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirPlanDefinition(oSource).FTopicList);
  end;
  if (TFhirPlanDefinition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirPlanDefinition(oSource).FAuthorList);
  end;
  if (TFhirPlanDefinition(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirPlanDefinition(oSource).FEditorList);
  end;
  if (TFhirPlanDefinition(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirPlanDefinition(oSource).FReviewerList);
  end;
  if (TFhirPlanDefinition(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirPlanDefinition(oSource).FEndorserList);
  end;
  if (TFhirPlanDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirPlanDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirPlanDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirCanonicalList.Create;
    FLibrary_List.Assign(TFhirPlanDefinition(oSource).FLibrary_List);
  end;
  if (TFhirPlanDefinition(oSource).FGoalList = nil) then
  begin
    FGoalList.free;
    FGoalList := nil;
  end
  else
  begin
    if FGoalList = nil then
      FGoalList := TFhirPlanDefinitionGoalList.Create;
    FGoalList.Assign(TFhirPlanDefinition(oSource).FGoalList);
  end;
  if (TFhirPlanDefinition(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirPlanDefinitionActionList.Create;
    FActionList.Assign(TFhirPlanDefinition(oSource).FActionList);
  end;
end;

function TFhirPlanDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtPlanDefinition;
end;

procedure TFhirPlanDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'goal') Then
    list.addAll(self, 'goal', FGoalList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirPlanDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference|canonical', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'library', 'canonical', true, TFhirCanonical, FLibrary_List.Link));
  oList.add(TFHIRProperty.create(self, 'goal', 'BackboneElement', true, TFhirPlanDefinitionGoal, FGoalList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirPlanDefinitionAction, FActionList.Link));
end;

function TFhirPlanDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'goal') then
  begin
    GoalList.add(propValue as TFhirPlanDefinitionGoal);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirPlanDefinitionAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirPlanDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'library') then Library_List.insertItem(index, asCanonical(propValue))
  else if (propName = 'goal') then GoalList.insertItem(index, propValue as TFhirPlanDefinitionGoal)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirPlanDefinitionAction)
  else inherited;
end;

function TFhirPlanDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'topic') then result := TopicList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'library') then result := Library_List.new()
  else if (propName = 'goal') then result := GoalList.new()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirPlanDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference|canonical'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'canonical'
  else if (propName = 'goal') then result := 'BackboneElement'
  else if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirPlanDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value)
  else if (propName = 'goal') then deletePropertyValue('goal', GoalList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirPlanDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference', 'Canonical'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new)
  else if (propName = 'goal') then replacePropertyValue('goal', GoalList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirPlanDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'topic') then TopicList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'library') then Library_List.move(source, destination)
  else if (propName = 'goal') then GoalList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirPlanDefinition.fhirType : string;
begin
  result := 'PlanDefinition';
end;

function TFhirPlanDefinition.Link : TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(inherited Link);
end;

function TFhirPlanDefinition.Clone : TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(inherited Clone);
end;

function TFhirPlanDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirPlanDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirPlanDefinition)) then
    result := false
  else
  begin
    o := TFhirPlanDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(subtitleElement, o.subtitleElement, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(useContextList, o.useContextList, true) and compareDeep(jurisdictionList, o.jurisdictionList, true) and 
      compareDeep(purposeElement, o.purposeElement, true) and compareDeep(usageElement, o.usageElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and 
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(topicList, o.topicList, true) and compareDeep(authorList, o.authorList, true) and 
      compareDeep(editorList, o.editorList, true) and compareDeep(reviewerList, o.reviewerList, true) and 
      compareDeep(endorserList, o.endorserList, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and 
      compareDeep(library_List, o.library_List, true) and compareDeep(goalList, o.goalList, true) and 
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirPlanDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FType_) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FgoalList) and isEmptyProp(FactionList);
end;

procedure TFhirPlanDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('subtitle');
  fields.add('type');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('goal');
  fields.add('action');
end;

function TFhirPlanDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FTopicList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FLibrary_List.sizeInBytes(magic));
  inc(result, FGoalList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirPlanDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirPlanDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirPlanDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirPlanDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirPlanDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirPlanDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirPlanDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirPlanDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirPlanDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirPlanDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirPlanDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirPlanDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirPlanDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirPlanDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirPlanDefinition.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirPlanDefinition.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirPlanDefinition.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirPlanDefinition.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirPlanDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirPlanDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirPlanDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirPlanDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirPlanDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirPlanDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirPlanDefinition.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirPlanDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirPlanDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirPlanDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirPlanDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirPlanDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirPlanDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirPlanDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirPlanDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirPlanDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirPlanDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirPlanDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirPlanDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirPlanDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirPlanDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirPlanDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirPlanDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirPlanDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirPlanDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirPlanDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirPlanDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirPlanDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

procedure TFhirPlanDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirPlanDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirPlanDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirPlanDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirPlanDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirPlanDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirPlanDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirPlanDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirPlanDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirPlanDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirPlanDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

function TFhirPlanDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

function TFhirPlanDefinition.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirPlanDefinition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirPlanDefinition.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirPlanDefinition.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirPlanDefinition.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirPlanDefinition.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirPlanDefinition.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirPlanDefinition.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirPlanDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirPlanDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirPlanDefinition.GetLibrary_List : TFhirCanonicalList;
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirCanonicalList.Create;
  result := FLibrary_List;
end;

function TFhirPlanDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

function TFhirPlanDefinition.GetGoalList : TFhirPlanDefinitionGoalList;
begin
  if FGoalList = nil then
    FGoalList := TFhirPlanDefinitionGoalList.Create;
  result := FGoalList;
end;

function TFhirPlanDefinition.GetHasGoalList : boolean;
begin
  result := (FGoalList <> nil) and (FGoalList.count > 0);
end;

function TFhirPlanDefinition.GetActionList : TFhirPlanDefinitionActionList;
begin
  if FActionList = nil then
    FActionList := TFhirPlanDefinitionActionList.Create;
  result := FActionList;
end;

function TFhirPlanDefinition.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirPlanDefinitionListEnumerator }

constructor TFhirPlanDefinitionListEnumerator.Create(list : TFhirPlanDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirPlanDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirPlanDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirPlanDefinitionListEnumerator.GetCurrent : TFhirPlanDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirPlanDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirPlanDefinitionList }

function TFhirPlanDefinitionList.AddItem(value: TFhirPlanDefinition): TFhirPlanDefinition;
begin
  assert(value.ClassName = 'TFhirPlanDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirPlanDefinition');
  add(value);
  result := value;
end;

function TFhirPlanDefinitionList.Append: TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirPlanDefinitionList.GetEnumerator : TFhirPlanDefinitionListEnumerator;
begin
  result := TFhirPlanDefinitionListEnumerator.Create(self.link);
end;

function TFhirPlanDefinitionList.Clone: TFhirPlanDefinitionList;
begin
  result := TFhirPlanDefinitionList(inherited Clone);
end;

function TFhirPlanDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirPlanDefinitionList.GetItemN(index: Integer): TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirPlanDefinition;
end;
function TFhirPlanDefinitionList.IndexOf(value: TFhirPlanDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirPlanDefinitionList.Insert(index: Integer): TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirPlanDefinitionList.InsertItem(index: Integer; value: TFhirPlanDefinition);
begin
  assert(value is TFhirPlanDefinition);
  Inherited Insert(index, value);
end;

function TFhirPlanDefinitionList.Item(index: Integer): TFhirPlanDefinition;
begin
  result := TFhirPlanDefinition(ObjectByIndex[index]);
end;

function TFhirPlanDefinitionList.Link: TFhirPlanDefinitionList;
begin
  result := TFhirPlanDefinitionList(inherited Link);
end;

procedure TFhirPlanDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirPlanDefinitionList.SetItemByIndex(index: Integer; value: TFhirPlanDefinition);
begin
  assert(value is TFhirPlanDefinition);
  FhirPlanDefinitions[index] := value;
end;

procedure TFhirPlanDefinitionList.SetItemN(index: Integer; value: TFhirPlanDefinition);
begin
  assert(value is TFhirPlanDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PLANDEFINITION}
{$IFDEF FHIR_PROVENANCE}
{ TFhirProvenanceAgent }

constructor TFhirProvenanceAgent.Create;
begin
  inherited;
end;

destructor TFhirProvenanceAgent.Destroy;
begin
  FType_.free;
  FRoleList.Free;
  FWho.free;
  FOnBehalfOf.free;
  inherited;
end;

procedure TFhirProvenanceAgent.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirProvenanceAgent(oSource).type_.Clone;
  if (TFhirProvenanceAgent(oSource).FRoleList = nil) then
  begin
    FRoleList.free;
    FRoleList := nil;
  end
  else
  begin
    if FRoleList = nil then
      FRoleList := TFhirCodeableConceptList.Create;
    FRoleList.Assign(TFhirProvenanceAgent(oSource).FRoleList);
  end;
  who := TFhirProvenanceAgent(oSource).who.Clone;
  onBehalfOf := TFhirProvenanceAgent(oSource).onBehalfOf.Clone;
end;

procedure TFhirProvenanceAgent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'role') Then
    list.addAll(self, 'role', FRoleList);
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
end;

procedure TFhirProvenanceAgent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'role', 'CodeableConcept', true, TFhirCodeableConcept, FRoleList.Link));
  oList.add(TFHIRProperty.create(self, 'who', 'Reference', false, TFhirReference, FWho.Link));
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference', false, TFhirReference, FOnBehalfOf.Link));
end;

function TFhirProvenanceAgent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'role') then
  begin
    RoleList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'who') then
  begin
    Who := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceAgent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'role') then RoleList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirProvenanceAgent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'role') then result := RoleList.new()
  else if (propName = 'who') then result := TFhirReference.create()
  else if (propName = 'onBehalfOf') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceAgent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'role') then result := 'CodeableConcept'
  else if (propName = 'who') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceAgent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'role') then deletePropertyValue('role', RoleList, value)
  else if (propName = 'who') then WhoElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceAgent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'role') then replacePropertyValue('role', RoleList, existing, new)
  else if (propName = 'who') then WhoElement := new as TFhirReference
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceAgent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'role') then RoleList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceAgent.fhirType : string;
begin
  result := 'Provenance.agent';
end;

function TFhirProvenanceAgent.Link : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Link);
end;

function TFhirProvenanceAgent.Clone : TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(inherited Clone);
end;

function TFhirProvenanceAgent.equals(other : TObject) : boolean; 
var
  o : TFhirProvenanceAgent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceAgent)) then
    result := false
  else
  begin
    o := TFhirProvenanceAgent(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(roleList, o.roleList, true) and 
      compareDeep(whoElement, o.whoElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true);
  end;
end;

function TFhirProvenanceAgent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FroleList) and isEmptyProp(FWho) and isEmptyProp(FOnBehalfOf);
end;

procedure TFhirProvenanceAgent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('role');
  fields.add('who');
  fields.add('onBehalfOf');
end;

function TFhirProvenanceAgent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRoleList.sizeInBytes(magic));
end;

procedure TFhirProvenanceAgent.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirProvenanceAgent.GetRoleList : TFhirCodeableConceptList;
begin
  if FRoleList = nil then
    FRoleList := TFhirCodeableConceptList.Create;
  result := FRoleList;
end;

function TFhirProvenanceAgent.GetHasRoleList : boolean;
begin
  result := (FRoleList <> nil) and (FRoleList.count > 0);
end;

procedure TFhirProvenanceAgent.SetWho(value : TFhirReference);
begin
  FWho.free;
  FWho := value;
end;

procedure TFhirProvenanceAgent.SetOnBehalfOf(value : TFhirReference);
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

{ TFhirProvenanceAgentListEnumerator }

constructor TFhirProvenanceAgentListEnumerator.Create(list : TFhirProvenanceAgentList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceAgentListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceAgentListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceAgentListEnumerator.GetCurrent : TFhirProvenanceAgent;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceAgentListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirProvenanceAgentList }

function TFhirProvenanceAgentList.AddItem(value: TFhirProvenanceAgent): TFhirProvenanceAgent;
begin
  assert(value.ClassName = 'TFhirProvenanceAgent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceAgent');
  add(value);
  result := value;
end;

function TFhirProvenanceAgentList.Append: TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceAgentList.GetEnumerator : TFhirProvenanceAgentListEnumerator;
begin
  result := TFhirProvenanceAgentListEnumerator.Create(self.link);
end;

function TFhirProvenanceAgentList.Clone: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Clone);
end;

function TFhirProvenanceAgentList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceAgentList.GetItemN(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceAgent;
end;
function TFhirProvenanceAgentList.IndexOf(value: TFhirProvenanceAgent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceAgentList.Insert(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceAgentList.InsertItem(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  Inherited Insert(index, value);
end;

function TFhirProvenanceAgentList.Item(index: Integer): TFhirProvenanceAgent;
begin
  result := TFhirProvenanceAgent(ObjectByIndex[index]);
end;

function TFhirProvenanceAgentList.Link: TFhirProvenanceAgentList;
begin
  result := TFhirProvenanceAgentList(inherited Link);
end;

procedure TFhirProvenanceAgentList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceAgentList.SetItemByIndex(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  FhirProvenanceAgents[index] := value;
end;

procedure TFhirProvenanceAgentList.SetItemN(index: Integer; value: TFhirProvenanceAgent);
begin
  assert(value is TFhirProvenanceAgent);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenanceEntity }

constructor TFhirProvenanceEntity.Create;
begin
  inherited;
end;

destructor TFhirProvenanceEntity.Destroy;
begin
  FRole.free;
  FWhat.free;
  FAgentList.Free;
  inherited;
end;

procedure TFhirProvenanceEntity.Assign(oSource : TFslObject);
begin
  inherited;
  roleElement := TFhirProvenanceEntity(oSource).roleElement.Clone;
  what := TFhirProvenanceEntity(oSource).what.Clone;
  if (TFhirProvenanceEntity(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirProvenanceAgentList.Create;
    FAgentList.Assign(TFhirProvenanceEntity(oSource).FAgentList);
  end;
end;

procedure TFhirProvenanceEntity.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'role') Then
     list.add(self.link, 'role', FRole.Link);
  if (child_name = 'what') Then
     list.add(self.link, 'what', FWhat.Link);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
end;

procedure TFhirProvenanceEntity.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'role', 'code', false, TFhirEnum, FRole.Link));
  oList.add(TFHIRProperty.create(self, 'what', 'Reference', false, TFhirReference, FWhat.Link));
  oList.add(TFHIRProperty.create(self, 'agent', '', true, TFhirProvenanceAgent, FAgentList.Link));
end;

function TFhirProvenanceEntity.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'role') then
  begin
    RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, propValue);
    result := propValue;
  end
  else if (propName = 'what') then
  begin
    What := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirProvenanceAgent);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenanceEntity.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirProvenanceAgent)
  else inherited;
end;

function TFhirProvenanceEntity.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'role') then result := TFhirEnum.create(SYSTEMS_TFhirProvenanceEntityRoleEnum[ProvenanceEntityRoleNull], CODES_TFhirProvenanceEntityRoleEnum[ProvenanceEntityRoleNull]) 
  else if (propName = 'what') then result := TFhirReference.create()
  else if (propName = 'agent') then result := AgentList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenanceEntity.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'role') then result := 'code'
  else if (propName = 'what') then result := 'Reference'
  else if (propName = 'agent') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenanceEntity.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := nil
  else if (propName = 'what') then WhatElement := nil
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenanceEntity.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'role') then RoleElement := asEnum(SYSTEMS_TFhirProvenanceEntityRoleEnum, CODES_TFhirProvenanceEntityRoleEnum, new)
  else if (propName = 'what') then WhatElement := new as TFhirReference
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenanceEntity.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'agent') then AgentList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenanceEntity.fhirType : string;
begin
  result := 'Provenance.entity';
end;

function TFhirProvenanceEntity.Link : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Link);
end;

function TFhirProvenanceEntity.Clone : TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(inherited Clone);
end;

function TFhirProvenanceEntity.equals(other : TObject) : boolean; 
var
  o : TFhirProvenanceEntity;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenanceEntity)) then
    result := false
  else
  begin
    o := TFhirProvenanceEntity(other);
    result := compareDeep(roleElement, o.roleElement, true) and compareDeep(whatElement, o.whatElement, true) and 
      compareDeep(agentList, o.agentList, true);
  end;
end;

function TFhirProvenanceEntity.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRole) and isEmptyProp(FWhat) and isEmptyProp(FagentList);
end;

procedure TFhirProvenanceEntity.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('role');
  fields.add('what');
  fields.add('agent');
end;

function TFhirProvenanceEntity.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAgentList.sizeInBytes(magic));
end;

procedure TFhirProvenanceEntity.SetRole(value : TFhirEnum);
begin
  FRole.free;
  FRole := value;
end;

function TFhirProvenanceEntity.GetRoleST : TFhirProvenanceEntityRoleEnum;
begin
  if FRole = nil then
    result := TFhirProvenanceEntityRoleEnum(0)
  else
    result := TFhirProvenanceEntityRoleEnum(StringArrayIndexOfSensitive(CODES_TFhirProvenanceEntityRoleEnum, FRole.value));
end;

procedure TFhirProvenanceEntity.SetRoleST(value : TFhirProvenanceEntityRoleEnum);
begin
  if ord(value) = 0 then
    RoleElement := nil
  else
    RoleElement := TFhirEnum.create(SYSTEMS_TFhirProvenanceEntityRoleEnum[value], CODES_TFhirProvenanceEntityRoleEnum[value]);
end;

procedure TFhirProvenanceEntity.SetWhat(value : TFhirReference);
begin
  FWhat.free;
  FWhat := value;
end;

function TFhirProvenanceEntity.GetAgentList : TFhirProvenanceAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirProvenanceAgentList.Create;
  result := FAgentList;
end;

function TFhirProvenanceEntity.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

{ TFhirProvenanceEntityListEnumerator }

constructor TFhirProvenanceEntityListEnumerator.Create(list : TFhirProvenanceEntityList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceEntityListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceEntityListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceEntityListEnumerator.GetCurrent : TFhirProvenanceEntity;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceEntityListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirProvenanceEntityList }

function TFhirProvenanceEntityList.AddItem(value: TFhirProvenanceEntity): TFhirProvenanceEntity;
begin
  assert(value.ClassName = 'TFhirProvenanceEntity', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenanceEntity');
  add(value);
  result := value;
end;

function TFhirProvenanceEntityList.Append: TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceEntityList.GetEnumerator : TFhirProvenanceEntityListEnumerator;
begin
  result := TFhirProvenanceEntityListEnumerator.Create(self.link);
end;

function TFhirProvenanceEntityList.Clone: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Clone);
end;

function TFhirProvenanceEntityList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceEntityList.GetItemN(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenanceEntity;
end;
function TFhirProvenanceEntityList.IndexOf(value: TFhirProvenanceEntity): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceEntityList.Insert(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceEntityList.InsertItem(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  Inherited Insert(index, value);
end;

function TFhirProvenanceEntityList.Item(index: Integer): TFhirProvenanceEntity;
begin
  result := TFhirProvenanceEntity(ObjectByIndex[index]);
end;

function TFhirProvenanceEntityList.Link: TFhirProvenanceEntityList;
begin
  result := TFhirProvenanceEntityList(inherited Link);
end;

procedure TFhirProvenanceEntityList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceEntityList.SetItemByIndex(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  FhirProvenanceEntities[index] := value;
end;

procedure TFhirProvenanceEntityList.SetItemN(index: Integer; value: TFhirProvenanceEntity);
begin
  assert(value is TFhirProvenanceEntity);
  ObjectByIndex[index] := value;
end;

{ TFhirProvenance }

constructor TFhirProvenance.Create;
begin
  inherited;
end;

destructor TFhirProvenance.Destroy;
begin
  FTargetList.Free;
  FOccurred.free;
  FRecorded.free;
  FPolicyList.Free;
  FLocation.free;
  FReasonList.Free;
  FActivity.free;
  FAgentList.Free;
  FEntityList.Free;
  FSignatureList.Free;
  inherited;
end;

procedure TFhirProvenance.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirProvenance(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirReferenceList.Create;
    FTargetList.Assign(TFhirProvenance(oSource).FTargetList);
  end;
  occurred := TFhirProvenance(oSource).occurred.Clone;
  recordedElement := TFhirProvenance(oSource).recordedElement.Clone;
  if (TFhirProvenance(oSource).FPolicyList = nil) then
  begin
    FPolicyList.free;
    FPolicyList := nil;
  end
  else
  begin
    if FPolicyList = nil then
      FPolicyList := TFhirUriList.Create;
    FPolicyList.Assign(TFhirProvenance(oSource).FPolicyList);
  end;
  location := TFhirProvenance(oSource).location.Clone;
  if (TFhirProvenance(oSource).FReasonList = nil) then
  begin
    FReasonList.free;
    FReasonList := nil;
  end
  else
  begin
    if FReasonList = nil then
      FReasonList := TFhirCodeableConceptList.Create;
    FReasonList.Assign(TFhirProvenance(oSource).FReasonList);
  end;
  activity := TFhirProvenance(oSource).activity.Clone;
  if (TFhirProvenance(oSource).FAgentList = nil) then
  begin
    FAgentList.free;
    FAgentList := nil;
  end
  else
  begin
    if FAgentList = nil then
      FAgentList := TFhirProvenanceAgentList.Create;
    FAgentList.Assign(TFhirProvenance(oSource).FAgentList);
  end;
  if (TFhirProvenance(oSource).FEntityList = nil) then
  begin
    FEntityList.free;
    FEntityList := nil;
  end
  else
  begin
    if FEntityList = nil then
      FEntityList := TFhirProvenanceEntityList.Create;
    FEntityList.Assign(TFhirProvenance(oSource).FEntityList);
  end;
  if (TFhirProvenance(oSource).FSignatureList = nil) then
  begin
    FSignatureList.free;
    FSignatureList := nil;
  end
  else
  begin
    if FSignatureList = nil then
      FSignatureList := TFhirSignatureList.Create;
    FSignatureList.Assign(TFhirProvenance(oSource).FSignatureList);
  end;
end;

function TFhirProvenance.GetResourceType : TFhirResourceType;
begin
  result := frtProvenance;
end;

procedure TFhirProvenance.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'occurred[x]') or (child_name = 'occurred') Then
     list.add(self.link, 'occurred[x]', FOccurred.Link);
  if (child_name = 'recorded') Then
     list.add(self.link, 'recorded', FRecorded.Link);
  if (child_name = 'policy') Then
    list.addAll(self, 'policy', FPolicyList);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reason') Then
    list.addAll(self, 'reason', FReasonList);
  if (child_name = 'activity') Then
     list.add(self.link, 'activity', FActivity.Link);
  if (child_name = 'agent') Then
    list.addAll(self, 'agent', FAgentList);
  if (child_name = 'entity') Then
    list.addAll(self, 'entity', FEntityList);
  if (child_name = 'signature') Then
    list.addAll(self, 'signature', FSignatureList);
end;

procedure TFhirProvenance.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', true, TFhirReference, FTargetList.Link));
  oList.add(TFHIRProperty.create(self, 'occurred[x]', 'Period|dateTime', false, TFhirDataType, FOccurred.Link));
  oList.add(TFHIRProperty.create(self, 'recorded', 'instant', false, TFhirInstant, FRecorded.Link));
  oList.add(TFHIRProperty.create(self, 'policy', 'uri', true, TFhirUri, FPolicyList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'CodeableConcept', true, TFhirCodeableConcept, FReasonList.Link));
  oList.add(TFHIRProperty.create(self, 'activity', 'CodeableConcept', false, TFhirCodeableConcept, FActivity.Link));
  oList.add(TFHIRProperty.create(self, 'agent', 'BackboneElement', true, TFhirProvenanceAgent, FAgentList.Link));
  oList.add(TFHIRProperty.create(self, 'entity', 'BackboneElement', true, TFhirProvenanceEntity, FEntityList.Link));
  oList.add(TFHIRProperty.create(self, 'signature', 'Signature', true, TFhirSignature, FSignatureList.Link));
end;

function TFhirProvenance.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then
  begin
    Occurred := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'recorded') then
  begin
    RecordedElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'policy') then
  begin
    PolicyList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'activity') then
  begin
    Activity := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'agent') then
  begin
    AgentList.add(propValue as TFhirProvenanceAgent);
    result := propValue;
  end
  else if (propName = 'entity') then
  begin
    EntityList.add(propValue as TFhirProvenanceEntity);
    result := propValue;
  end
  else if (propName = 'signature') then
  begin
    SignatureList.add(propValue as TFhirSignature);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirProvenance.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'policy') then PolicyList.insertItem(index, asUri(propValue))
  else if (propName = 'reason') then ReasonList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'agent') then AgentList.insertItem(index, propValue as TFhirProvenanceAgent)
  else if (propName = 'entity') then EntityList.insertItem(index, propValue as TFhirProvenanceEntity)
  else if (propName = 'signature') then SignatureList.insertItem(index, propValue as TFhirSignature)
  else inherited;
end;

function TFhirProvenance.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TargetList.new()
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then raise EFHIRException.create('Cannot make property Occurred')
  else if (propName = 'recorded') then result := TFhirInstant.create()
  else if (propName = 'policy') then result := PolicyList.new()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'reason') then result := ReasonList.new()
  else if (propName = 'activity') then result := TFhirCodeableConcept.create()
  else if (propName = 'agent') then result := AgentList.new()
  else if (propName = 'entity') then result := EntityList.new()
  else if (propName = 'signature') then result := SignatureList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirProvenance.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'occurred[x]') then result := 'Period|dateTime'
  else if (propName = 'recorded') then result := 'instant'
  else if (propName = 'policy') then result := 'uri'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reason') then result := 'CodeableConcept'
  else if (propName = 'activity') then result := 'CodeableConcept'
  else if (propName = 'agent') then result := 'BackboneElement'
  else if (propName = 'entity') then result := 'BackboneElement'
  else if (propName = 'signature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirProvenance.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then OccurredElement := nil
  else if (propName = 'recorded') then RecordedElement := nil
  else if (propName = 'policy') then deletePropertyValue('policy', PolicyList, value)
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reason') then deletePropertyValue('reason', ReasonList, value)
  else if (propName = 'activity') then ActivityElement := nil
  else if (propName = 'agent') then deletePropertyValue('agent', AgentList, value)
  else if (propName = 'entity') then deletePropertyValue('entity', EntityList, value)
  else if (propName = 'signature') then deletePropertyValue('signature', SignatureList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirProvenance.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else if (isMatchingName(propName, 'occurred', ['Period', 'DateTime'])) then OccurredElement := new as TFhirDataType
  else if (propName = 'recorded') then RecordedElement := asInstant(new)
  else if (propName = 'policy') then replacePropertyValue('policy', PolicyList, existing, new)
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'reason') then replacePropertyValue('reason', ReasonList, existing, new)
  else if (propName = 'activity') then ActivityElement := new as TFhirCodeableConcept
  else if (propName = 'agent') then replacePropertyValue('agent', AgentList, existing, new)
  else if (propName = 'entity') then replacePropertyValue('entity', EntityList, existing, new)
  else if (propName = 'signature') then replacePropertyValue('signature', SignatureList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirProvenance.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination)
  else if (propName = 'policy') then PolicyList.move(source, destination)
  else if (propName = 'reason') then ReasonList.move(source, destination)
  else if (propName = 'agent') then AgentList.move(source, destination)
  else if (propName = 'entity') then EntityList.move(source, destination)
  else if (propName = 'signature') then SignatureList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirProvenance.fhirType : string;
begin
  result := 'Provenance';
end;

function TFhirProvenance.Link : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Link);
end;

function TFhirProvenance.Clone : TFhirProvenance;
begin
  result := TFhirProvenance(inherited Clone);
end;

function TFhirProvenance.equals(other : TObject) : boolean; 
var
  o : TFhirProvenance;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirProvenance)) then
    result := false
  else
  begin
    o := TFhirProvenance(other);
    result := compareDeep(targetList, o.targetList, true) and compareDeep(occurredElement, o.occurredElement, true) and 
      compareDeep(recordedElement, o.recordedElement, true) and compareDeep(policyList, o.policyList, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(reasonList, o.reasonList, true) and 
      compareDeep(activityElement, o.activityElement, true) and compareDeep(agentList, o.agentList, true) and 
      compareDeep(entityList, o.entityList, true) and compareDeep(signatureList, o.signatureList, true);
  end;
end;

function TFhirProvenance.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FtargetList) and isEmptyProp(FOccurred) and isEmptyProp(FRecorded) and isEmptyProp(FpolicyList) and isEmptyProp(FLocation) and isEmptyProp(FreasonList) and isEmptyProp(FActivity) and isEmptyProp(FagentList) and isEmptyProp(FentityList) and isEmptyProp(FsignatureList);
end;

procedure TFhirProvenance.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('target');
  fields.add('occurred[x]');
  fields.add('recorded');
  fields.add('policy');
  fields.add('location');
  fields.add('reason');
  fields.add('activity');
  fields.add('agent');
  fields.add('entity');
  fields.add('signature');
end;

function TFhirProvenance.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetList.sizeInBytes(magic));
  inc(result, FPolicyList.sizeInBytes(magic));
  inc(result, FReasonList.sizeInBytes(magic));
  inc(result, FAgentList.sizeInBytes(magic));
  inc(result, FEntityList.sizeInBytes(magic));
  inc(result, FSignatureList.sizeInBytes(magic));
end;

function TFhirProvenance.GetTargetList : TFhirReferenceList;
begin
  if FTargetList = nil then
    FTargetList := TFhirReferenceList.Create;
  result := FTargetList;
end;

function TFhirProvenance.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

procedure TFhirProvenance.SetOccurred(value : TFhirDataType);
begin
  FOccurred.free;
  FOccurred := value;
end;

procedure TFhirProvenance.SetRecorded(value : TFhirInstant);
begin
  FRecorded.free;
  FRecorded := value;
end;

function TFhirProvenance.GetRecordedST : TFslDateTime;
begin
  if FRecorded = nil then
    result := TFslDateTime.makeNull
  else
    result := FRecorded.value;
end;

procedure TFhirProvenance.SetRecordedST(value : TFslDateTime);
begin
  if FRecorded = nil then
    FRecorded := TFhirInstant.create;
  FRecorded.value := value
end;

function TFhirProvenance.GetPolicyList : TFhirUriList;
begin
  if FPolicyList = nil then
    FPolicyList := TFhirUriList.Create;
  result := FPolicyList;
end;

function TFhirProvenance.GetHasPolicyList : boolean;
begin
  result := (FPolicyList <> nil) and (FPolicyList.count > 0);
end;

procedure TFhirProvenance.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

function TFhirProvenance.GetReasonList : TFhirCodeableConceptList;
begin
  if FReasonList = nil then
    FReasonList := TFhirCodeableConceptList.Create;
  result := FReasonList;
end;

function TFhirProvenance.GetHasReasonList : boolean;
begin
  result := (FReasonList <> nil) and (FReasonList.count > 0);
end;

procedure TFhirProvenance.SetActivity(value : TFhirCodeableConcept);
begin
  FActivity.free;
  FActivity := value;
end;

function TFhirProvenance.GetAgentList : TFhirProvenanceAgentList;
begin
  if FAgentList = nil then
    FAgentList := TFhirProvenanceAgentList.Create;
  result := FAgentList;
end;

function TFhirProvenance.GetHasAgentList : boolean;
begin
  result := (FAgentList <> nil) and (FAgentList.count > 0);
end;

function TFhirProvenance.GetEntityList : TFhirProvenanceEntityList;
begin
  if FEntityList = nil then
    FEntityList := TFhirProvenanceEntityList.Create;
  result := FEntityList;
end;

function TFhirProvenance.GetHasEntityList : boolean;
begin
  result := (FEntityList <> nil) and (FEntityList.count > 0);
end;

function TFhirProvenance.GetSignatureList : TFhirSignatureList;
begin
  if FSignatureList = nil then
    FSignatureList := TFhirSignatureList.Create;
  result := FSignatureList;
end;

function TFhirProvenance.GetHasSignatureList : boolean;
begin
  result := (FSignatureList <> nil) and (FSignatureList.count > 0);
end;

{ TFhirProvenanceListEnumerator }

constructor TFhirProvenanceListEnumerator.Create(list : TFhirProvenanceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirProvenanceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirProvenanceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirProvenanceListEnumerator.GetCurrent : TFhirProvenance;
begin
  Result := FList[FIndex];
end;

function TFhirProvenanceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirProvenanceList }

function TFhirProvenanceList.AddItem(value: TFhirProvenance): TFhirProvenance;
begin
  assert(value.ClassName = 'TFhirProvenance', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirProvenance');
  add(value);
  result := value;
end;

function TFhirProvenanceList.Append: TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.ClearItems;
begin
  Clear;
end;

function TFhirProvenanceList.GetEnumerator : TFhirProvenanceListEnumerator;
begin
  result := TFhirProvenanceListEnumerator.Create(self.link);
end;

function TFhirProvenanceList.Clone: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Clone);
end;

function TFhirProvenanceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirProvenanceList.GetItemN(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.ItemClass: TFslObjectClass;
begin
  result := TFhirProvenance;
end;
function TFhirProvenanceList.IndexOf(value: TFhirProvenance): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirProvenanceList.Insert(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirProvenanceList.InsertItem(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  Inherited Insert(index, value);
end;

function TFhirProvenanceList.Item(index: Integer): TFhirProvenance;
begin
  result := TFhirProvenance(ObjectByIndex[index]);
end;

function TFhirProvenanceList.Link: TFhirProvenanceList;
begin
  result := TFhirProvenanceList(inherited Link);
end;

procedure TFhirProvenanceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirProvenanceList.SetItemByIndex(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  FhirProvenances[index] := value;
end;

procedure TFhirProvenanceList.SetItemN(index: Integer; value: TFhirProvenance);
begin
  assert(value is TFhirProvenance);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_PROVENANCE}
{$IFDEF FHIR_QUESTIONNAIRERESPONSE}
{ TFhirQuestionnaireResponseItem }

constructor TFhirQuestionnaireResponseItem.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponseItem.Destroy;
begin
  FLinkId.free;
  FDefinition.free;
  FText.free;
  FAnswerList.Free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponseItem.Assign(oSource : TFslObject);
begin
  inherited;
  linkIdElement := TFhirQuestionnaireResponseItem(oSource).linkIdElement.Clone;
  definitionElement := TFhirQuestionnaireResponseItem(oSource).definitionElement.Clone;
  textElement := TFhirQuestionnaireResponseItem(oSource).textElement.Clone;
  if (TFhirQuestionnaireResponseItem(oSource).FAnswerList = nil) then
  begin
    FAnswerList.free;
    FAnswerList := nil;
  end
  else
  begin
    if FAnswerList = nil then
      FAnswerList := TFhirQuestionnaireResponseItemAnswerList.Create;
    FAnswerList.Assign(TFhirQuestionnaireResponseItem(oSource).FAnswerList);
  end;
  if (TFhirQuestionnaireResponseItem(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireResponseItemList.Create;
    FItemList.Assign(TFhirQuestionnaireResponseItem(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaireResponseItem.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'linkId') Then
     list.add(self.link, 'linkId', FLinkId.Link);
  if (child_name = 'definition') Then
     list.add(self.link, 'definition', FDefinition.Link);
  if (child_name = 'text') Then
     list.add(self.link, 'text', FText.Link);
  if (child_name = 'answer') Then
    list.addAll(self, 'answer', FAnswerList);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireResponseItem.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'linkId', 'string', false, TFhirString, FLinkId.Link));
  oList.add(TFHIRProperty.create(self, 'definition', 'uri', false, TFhirUri, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'text', 'string', false, TFhirString, FText.Link));
  oList.add(TFHIRProperty.create(self, 'answer', 'BackboneElement', true, TFhirQuestionnaireResponseItemAnswer, FAnswerList.Link));
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirQuestionnaireResponseItem, FItemList.Link));
end;

function TFhirQuestionnaireResponseItem.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'linkId') then
  begin
    LinkIdElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'definition') then
  begin
    DefinitionElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'text') then
  begin
    TextElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'answer') then
  begin
    AnswerList.add(propValue as TFhirQuestionnaireResponseItemAnswer);
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireResponseItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponseItem.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'answer') then AnswerList.insertItem(index, propValue as TFhirQuestionnaireResponseItemAnswer)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireResponseItem)
  else inherited;
end;

function TFhirQuestionnaireResponseItem.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'linkId') then result := TFhirString.create()
  else if (propName = 'definition') then result := TFhirUri.create()
  else if (propName = 'text') then result := TFhirString.create()
  else if (propName = 'answer') then result := AnswerList.new()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponseItem.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'linkId') then result := 'string'
  else if (propName = 'definition') then result := 'uri'
  else if (propName = 'text') then result := 'string'
  else if (propName = 'answer') then result := 'BackboneElement'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponseItem.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := nil
  else if (propName = 'definition') then DefinitionElement := nil
  else if (propName = 'text') then TextElement := nil
  else if (propName = 'answer') then deletePropertyValue('answer', AnswerList, value)
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponseItem.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'linkId') then LinkIdElement := asString(new)
  else if (propName = 'definition') then DefinitionElement := asUri(new)
  else if (propName = 'text') then TextElement := asString(new)
  else if (propName = 'answer') then replacePropertyValue('answer', AnswerList, existing, new)
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponseItem.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'answer') then AnswerList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponseItem.fhirType : string;
begin
  result := 'QuestionnaireResponse.item';
end;

function TFhirQuestionnaireResponseItem.Link : TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(inherited Link);
end;

function TFhirQuestionnaireResponseItem.Clone : TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(inherited Clone);
end;

function TFhirQuestionnaireResponseItem.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireResponseItem;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponseItem)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponseItem(other);
    result := compareDeep(linkIdElement, o.linkIdElement, true) and compareDeep(definitionElement, o.definitionElement, true) and 
      compareDeep(textElement, o.textElement, true) and compareDeep(answerList, o.answerList, true) and 
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireResponseItem.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FLinkId) and isEmptyProp(FDefinition) and isEmptyProp(FText) and isEmptyProp(FanswerList) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireResponseItem.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('linkId');
  fields.add('definition');
  fields.add('text');
  fields.add('answer');
  fields.add('item');
end;

function TFhirQuestionnaireResponseItem.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAnswerList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirQuestionnaireResponseItem.SetLinkId(value : TFhirString);
begin
  FLinkId.free;
  FLinkId := value;
end;

function TFhirQuestionnaireResponseItem.GetLinkIdST : String;
begin
  if FLinkId = nil then
    result := ''
  else
    result := FLinkId.value;
end;

procedure TFhirQuestionnaireResponseItem.SetLinkIdST(value : String);
begin
  if value <> '' then
  begin
    if FLinkId = nil then
      FLinkId := TFhirString.create;
    FLinkId.value := value
  end
  else if FLinkId <> nil then
    FLinkId.value := '';
end;

procedure TFhirQuestionnaireResponseItem.SetDefinition(value : TFhirUri);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirQuestionnaireResponseItem.GetDefinitionST : String;
begin
  if FDefinition = nil then
    result := ''
  else
    result := FDefinition.value;
end;

procedure TFhirQuestionnaireResponseItem.SetDefinitionST(value : String);
begin
  if value <> '' then
  begin
    if FDefinition = nil then
      FDefinition := TFhirUri.create;
    FDefinition.value := value
  end
  else if FDefinition <> nil then
    FDefinition.value := '';
end;

procedure TFhirQuestionnaireResponseItem.SetText(value : TFhirString);
begin
  FText.free;
  FText := value;
end;

function TFhirQuestionnaireResponseItem.GetTextST : String;
begin
  if FText = nil then
    result := ''
  else
    result := FText.value;
end;

procedure TFhirQuestionnaireResponseItem.SetTextST(value : String);
begin
  if value <> '' then
  begin
    if FText = nil then
      FText := TFhirString.create;
    FText.value := value
  end
  else if FText <> nil then
    FText.value := '';
end;

function TFhirQuestionnaireResponseItem.GetAnswerList : TFhirQuestionnaireResponseItemAnswerList;
begin
  if FAnswerList = nil then
    FAnswerList := TFhirQuestionnaireResponseItemAnswerList.Create;
  result := FAnswerList;
end;

function TFhirQuestionnaireResponseItem.GetHasAnswerList : boolean;
begin
  result := (FAnswerList <> nil) and (FAnswerList.count > 0);
end;

function TFhirQuestionnaireResponseItem.GetItemList : TFhirQuestionnaireResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireResponseItemList.Create;
  result := FItemList;
end;

function TFhirQuestionnaireResponseItem.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirQuestionnaireResponseItemListEnumerator }

constructor TFhirQuestionnaireResponseItemListEnumerator.Create(list : TFhirQuestionnaireResponseItemList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseItemListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseItemListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseItemListEnumerator.GetCurrent : TFhirQuestionnaireResponseItem;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseItemListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireResponseItemList }

function TFhirQuestionnaireResponseItemList.AddItem(value: TFhirQuestionnaireResponseItem): TFhirQuestionnaireResponseItem;
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponseItem', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponseItem');
  add(value);
  result := value;
end;

function TFhirQuestionnaireResponseItemList.Append: TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseItemList.GetEnumerator : TFhirQuestionnaireResponseItemListEnumerator;
begin
  result := TFhirQuestionnaireResponseItemListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseItemList.Clone: TFhirQuestionnaireResponseItemList;
begin
  result := TFhirQuestionnaireResponseItemList(inherited Clone);
end;

function TFhirQuestionnaireResponseItemList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseItemList.GetItemN(index: Integer): TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponseItem;
end;
function TFhirQuestionnaireResponseItemList.IndexOf(value: TFhirQuestionnaireResponseItem): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseItemList.Insert(index: Integer): TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemList.InsertItem(index: Integer; value: TFhirQuestionnaireResponseItem);
begin
  assert(value is TFhirQuestionnaireResponseItem);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseItemList.Item(index: Integer): TFhirQuestionnaireResponseItem;
begin
  result := TFhirQuestionnaireResponseItem(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemList.Link: TFhirQuestionnaireResponseItemList;
begin
  result := TFhirQuestionnaireResponseItemList(inherited Link);
end;

procedure TFhirQuestionnaireResponseItemList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseItemList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponseItem);
begin
  assert(value is TFhirQuestionnaireResponseItem);
  FhirQuestionnaireResponseItems[index] := value;
end;

procedure TFhirQuestionnaireResponseItemList.SetItemN(index: Integer; value: TFhirQuestionnaireResponseItem);
begin
  assert(value is TFhirQuestionnaireResponseItem);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireResponseItemAnswer }

constructor TFhirQuestionnaireResponseItemAnswer.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponseItemAnswer.Destroy;
begin
  FValue.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponseItemAnswer.Assign(oSource : TFslObject);
begin
  inherited;
  value := TFhirQuestionnaireResponseItemAnswer(oSource).value.Clone;
  if (TFhirQuestionnaireResponseItemAnswer(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireResponseItemList.Create;
    FItemList.Assign(TFhirQuestionnaireResponseItemAnswer(oSource).FItemList);
  end;
end;

procedure TFhirQuestionnaireResponseItemAnswer.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireResponseItemAnswer.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'value[x]', 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference', false, TFhirDataType, FValue.Link));
  oList.add(TFHIRProperty.create(self, 'item', '', true, TFhirQuestionnaireResponseItem, FItemList.Link));
end;

function TFhirQuestionnaireResponseItemAnswer.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireResponseItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponseItemAnswer.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireResponseItem)
  else inherited;
end;

function TFhirQuestionnaireResponseItemAnswer.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then raise EFHIRException.create('Cannot make property Value')
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponseItemAnswer.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'value[x]') then result := 'boolean|decimal|integer|date|dateTime|time|string|uri|Attachment|Coding|Quantity|Reference'
  else if (propName = 'item') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponseItemAnswer.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponseItemAnswer.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'value', ['Boolean', 'Decimal', 'Integer', 'Date', 'DateTime', 'Time', 'String', 'Uri', 'Attachment', 'Coding', 'Quantity', 'Reference'])) then ValueElement := new as TFhirDataType
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponseItemAnswer.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponseItemAnswer.fhirType : string;
begin
  result := 'QuestionnaireResponse.item.answer';
end;

function TFhirQuestionnaireResponseItemAnswer.Link : TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(inherited Link);
end;

function TFhirQuestionnaireResponseItemAnswer.Clone : TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(inherited Clone);
end;

function TFhirQuestionnaireResponseItemAnswer.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireResponseItemAnswer;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponseItemAnswer)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponseItemAnswer(other);
    result := compareDeep(valueElement, o.valueElement, true) and compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireResponseItemAnswer.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FValue) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireResponseItemAnswer.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('value[x]');
  fields.add('item');
end;

function TFhirQuestionnaireResponseItemAnswer.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirQuestionnaireResponseItemAnswer.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

function TFhirQuestionnaireResponseItemAnswer.GetItemList : TFhirQuestionnaireResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireResponseItemList.Create;
  result := FItemList;
end;

function TFhirQuestionnaireResponseItemAnswer.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirQuestionnaireResponseItemAnswerListEnumerator }

constructor TFhirQuestionnaireResponseItemAnswerListEnumerator.Create(list : TFhirQuestionnaireResponseItemAnswerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseItemAnswerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseItemAnswerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseItemAnswerListEnumerator.GetCurrent : TFhirQuestionnaireResponseItemAnswer;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseItemAnswerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireResponseItemAnswerList }

function TFhirQuestionnaireResponseItemAnswerList.AddItem(value: TFhirQuestionnaireResponseItemAnswer): TFhirQuestionnaireResponseItemAnswer;
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponseItemAnswer', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponseItemAnswer');
  add(value);
  result := value;
end;

function TFhirQuestionnaireResponseItemAnswerList.Append: TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemAnswerList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseItemAnswerList.GetEnumerator : TFhirQuestionnaireResponseItemAnswerListEnumerator;
begin
  result := TFhirQuestionnaireResponseItemAnswerListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseItemAnswerList.Clone: TFhirQuestionnaireResponseItemAnswerList;
begin
  result := TFhirQuestionnaireResponseItemAnswerList(inherited Clone);
end;

function TFhirQuestionnaireResponseItemAnswerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseItemAnswerList.GetItemN(index: Integer): TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemAnswerList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponseItemAnswer;
end;
function TFhirQuestionnaireResponseItemAnswerList.IndexOf(value: TFhirQuestionnaireResponseItemAnswer): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseItemAnswerList.Insert(index: Integer): TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseItemAnswerList.InsertItem(index: Integer; value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value is TFhirQuestionnaireResponseItemAnswer);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseItemAnswerList.Item(index: Integer): TFhirQuestionnaireResponseItemAnswer;
begin
  result := TFhirQuestionnaireResponseItemAnswer(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseItemAnswerList.Link: TFhirQuestionnaireResponseItemAnswerList;
begin
  result := TFhirQuestionnaireResponseItemAnswerList(inherited Link);
end;

procedure TFhirQuestionnaireResponseItemAnswerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseItemAnswerList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value is TFhirQuestionnaireResponseItemAnswer);
  FhirQuestionnaireResponseItemAnswers[index] := value;
end;

procedure TFhirQuestionnaireResponseItemAnswerList.SetItemN(index: Integer; value: TFhirQuestionnaireResponseItemAnswer);
begin
  assert(value is TFhirQuestionnaireResponseItemAnswer);
  ObjectByIndex[index] := value;
end;

{ TFhirQuestionnaireResponse }

constructor TFhirQuestionnaireResponse.Create;
begin
  inherited;
end;

destructor TFhirQuestionnaireResponse.Destroy;
begin
  FIdentifier.free;
  FBasedOnList.Free;
  FPartOfList.Free;
  FQuestionnaire.free;
  FStatus.free;
  FSubject.free;
  FEncounter.free;
  FAuthored.free;
  FAuthor.free;
  FSource.free;
  FItemList.Free;
  inherited;
end;

procedure TFhirQuestionnaireResponse.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirQuestionnaireResponse(oSource).identifier.Clone;
  if (TFhirQuestionnaireResponse(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirQuestionnaireResponse(oSource).FBasedOnList);
  end;
  if (TFhirQuestionnaireResponse(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirQuestionnaireResponse(oSource).FPartOfList);
  end;
  questionnaireElement := TFhirQuestionnaireResponse(oSource).questionnaireElement.Clone;
  statusElement := TFhirQuestionnaireResponse(oSource).statusElement.Clone;
  subject := TFhirQuestionnaireResponse(oSource).subject.Clone;
  encounter := TFhirQuestionnaireResponse(oSource).encounter.Clone;
  authoredElement := TFhirQuestionnaireResponse(oSource).authoredElement.Clone;
  author := TFhirQuestionnaireResponse(oSource).author.Clone;
  source := TFhirQuestionnaireResponse(oSource).source.Clone;
  if (TFhirQuestionnaireResponse(oSource).FItemList = nil) then
  begin
    FItemList.free;
    FItemList := nil;
  end
  else
  begin
    if FItemList = nil then
      FItemList := TFhirQuestionnaireResponseItemList.Create;
    FItemList.Assign(TFhirQuestionnaireResponse(oSource).FItemList);
  end;
end;

function TFhirQuestionnaireResponse.GetResourceType : TFhirResourceType;
begin
  result := frtQuestionnaireResponse;
end;

procedure TFhirQuestionnaireResponse.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'questionnaire') Then
     list.add(self.link, 'questionnaire', FQuestionnaire.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'authored') Then
     list.add(self.link, 'authored', FAuthored.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'source') Then
     list.add(self.link, 'source', FSource.Link);
  if (child_name = 'item') Then
    list.addAll(self, 'item', FItemList);
end;

procedure TFhirQuestionnaireResponse.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'questionnaire', 'canonical', false, TFhirCanonical, FQuestionnaire.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'authored', 'dateTime', false, TFhirDateTime, FAuthored.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'source', 'Reference', false, TFhirReference, FSource.Link));
  oList.add(TFHIRProperty.create(self, 'item', 'BackboneElement', true, TFhirQuestionnaireResponseItem, FItemList.Link));
end;

function TFhirQuestionnaireResponse.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'questionnaire') then
  begin
    QuestionnaireElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireResponseStatusEnum, CODES_TFhirQuestionnaireResponseStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'authored') then
  begin
    AuthoredElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'source') then
  begin
    Source := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'item') then
  begin
    ItemList.add(propValue as TFhirQuestionnaireResponseItem);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirQuestionnaireResponse.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'item') then ItemList.insertItem(index, propValue as TFhirQuestionnaireResponseItem)
  else inherited;
end;

function TFhirQuestionnaireResponse.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'questionnaire') then result := TFhirCanonical.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireResponseStatusEnum[QuestionnaireResponseStatusNull], CODES_TFhirQuestionnaireResponseStatusEnum[QuestionnaireResponseStatusNull]) 
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'authored') then result := TFhirDateTime.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'source') then result := TFhirReference.create()
  else if (propName = 'item') then result := ItemList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirQuestionnaireResponse.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'questionnaire') then result := 'canonical'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'authored') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'source') then result := 'Reference'
  else if (propName = 'item') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirQuestionnaireResponse.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'questionnaire') then QuestionnaireElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'authored') then AuthoredElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'source') then SourceElement := nil
  else if (propName = 'item') then deletePropertyValue('item', ItemList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirQuestionnaireResponse.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'questionnaire') then QuestionnaireElement := asCanonical(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirQuestionnaireResponseStatusEnum, CODES_TFhirQuestionnaireResponseStatusEnum, new)
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'authored') then AuthoredElement := asDateTime(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'source') then SourceElement := new as TFhirReference
  else if (propName = 'item') then replacePropertyValue('item', ItemList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirQuestionnaireResponse.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'item') then ItemList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirQuestionnaireResponse.fhirType : string;
begin
  result := 'QuestionnaireResponse';
end;

function TFhirQuestionnaireResponse.Link : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(inherited Link);
end;

function TFhirQuestionnaireResponse.Clone : TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(inherited Clone);
end;

function TFhirQuestionnaireResponse.equals(other : TObject) : boolean; 
var
  o : TFhirQuestionnaireResponse;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirQuestionnaireResponse)) then
    result := false
  else
  begin
    o := TFhirQuestionnaireResponse(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(partOfList, o.partOfList, true) and compareDeep(questionnaireElement, o.questionnaireElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(encounterElement, o.encounterElement, true) and compareDeep(authoredElement, o.authoredElement, true) and 
      compareDeep(authorElement, o.authorElement, true) and compareDeep(sourceElement, o.sourceElement, true) and 
      compareDeep(itemList, o.itemList, true);
  end;
end;

function TFhirQuestionnaireResponse.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FbasedOnList) and isEmptyProp(FpartOfList) and isEmptyProp(FQuestionnaire) and isEmptyProp(FStatus) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FAuthored) and isEmptyProp(FAuthor) and isEmptyProp(FSource) and isEmptyProp(FitemList);
end;

procedure TFhirQuestionnaireResponse.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('basedOn');
  fields.add('partOf');
  fields.add('questionnaire');
  fields.add('status');
  fields.add('subject');
  fields.add('encounter');
  fields.add('authored');
  fields.add('author');
  fields.add('source');
  fields.add('item');
end;

function TFhirQuestionnaireResponse.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FItemList.sizeInBytes(magic));
end;

procedure TFhirQuestionnaireResponse.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

function TFhirQuestionnaireResponse.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirQuestionnaireResponse.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirQuestionnaireResponse.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirQuestionnaireResponse.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirQuestionnaireResponse.SetQuestionnaire(value : TFhirCanonical);
begin
  FQuestionnaire.free;
  FQuestionnaire := value;
end;

function TFhirQuestionnaireResponse.GetQuestionnaireST : String;
begin
  if FQuestionnaire = nil then
    result := ''
  else
    result := FQuestionnaire.value;
end;

procedure TFhirQuestionnaireResponse.SetQuestionnaireST(value : String);
begin
  if value <> '' then
  begin
    if FQuestionnaire = nil then
      FQuestionnaire := TFhirCanonical.create;
    FQuestionnaire.value := value
  end
  else if FQuestionnaire <> nil then
    FQuestionnaire.value := '';
end;

procedure TFhirQuestionnaireResponse.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirQuestionnaireResponse.GetStatusST : TFhirQuestionnaireResponseStatusEnum;
begin
  if FStatus = nil then
    result := TFhirQuestionnaireResponseStatusEnum(0)
  else
    result := TFhirQuestionnaireResponseStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirQuestionnaireResponseStatusEnum, FStatus.value));
end;

procedure TFhirQuestionnaireResponse.SetStatusST(value : TFhirQuestionnaireResponseStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirQuestionnaireResponseStatusEnum[value], CODES_TFhirQuestionnaireResponseStatusEnum[value]);
end;

procedure TFhirQuestionnaireResponse.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirQuestionnaireResponse.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirQuestionnaireResponse.SetAuthored(value : TFhirDateTime);
begin
  FAuthored.free;
  FAuthored := value;
end;

function TFhirQuestionnaireResponse.GetAuthoredST : TFslDateTime;
begin
  if FAuthored = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthored.value;
end;

procedure TFhirQuestionnaireResponse.SetAuthoredST(value : TFslDateTime);
begin
  if FAuthored = nil then
    FAuthored := TFhirDateTime.create;
  FAuthored.value := value
end;

procedure TFhirQuestionnaireResponse.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

procedure TFhirQuestionnaireResponse.SetSource(value : TFhirReference);
begin
  FSource.free;
  FSource := value;
end;

function TFhirQuestionnaireResponse.GetItemList : TFhirQuestionnaireResponseItemList;
begin
  if FItemList = nil then
    FItemList := TFhirQuestionnaireResponseItemList.Create;
  result := FItemList;
end;

function TFhirQuestionnaireResponse.GetHasItemList : boolean;
begin
  result := (FItemList <> nil) and (FItemList.count > 0);
end;

{ TFhirQuestionnaireResponseListEnumerator }

constructor TFhirQuestionnaireResponseListEnumerator.Create(list : TFhirQuestionnaireResponseList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirQuestionnaireResponseListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirQuestionnaireResponseListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirQuestionnaireResponseListEnumerator.GetCurrent : TFhirQuestionnaireResponse;
begin
  Result := FList[FIndex];
end;

function TFhirQuestionnaireResponseListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirQuestionnaireResponseList }

function TFhirQuestionnaireResponseList.AddItem(value: TFhirQuestionnaireResponse): TFhirQuestionnaireResponse;
begin
  assert(value.ClassName = 'TFhirQuestionnaireResponse', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirQuestionnaireResponse');
  add(value);
  result := value;
end;

function TFhirQuestionnaireResponseList.Append: TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseList.ClearItems;
begin
  Clear;
end;

function TFhirQuestionnaireResponseList.GetEnumerator : TFhirQuestionnaireResponseListEnumerator;
begin
  result := TFhirQuestionnaireResponseListEnumerator.Create(self.link);
end;

function TFhirQuestionnaireResponseList.Clone: TFhirQuestionnaireResponseList;
begin
  result := TFhirQuestionnaireResponseList(inherited Clone);
end;

function TFhirQuestionnaireResponseList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirQuestionnaireResponseList.GetItemN(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseList.ItemClass: TFslObjectClass;
begin
  result := TFhirQuestionnaireResponse;
end;
function TFhirQuestionnaireResponseList.IndexOf(value: TFhirQuestionnaireResponse): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirQuestionnaireResponseList.Insert(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirQuestionnaireResponseList.InsertItem(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  Inherited Insert(index, value);
end;

function TFhirQuestionnaireResponseList.Item(index: Integer): TFhirQuestionnaireResponse;
begin
  result := TFhirQuestionnaireResponse(ObjectByIndex[index]);
end;

function TFhirQuestionnaireResponseList.Link: TFhirQuestionnaireResponseList;
begin
  result := TFhirQuestionnaireResponseList(inherited Link);
end;

procedure TFhirQuestionnaireResponseList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirQuestionnaireResponseList.SetItemByIndex(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  FhirQuestionnaireResponses[index] := value;
end;

procedure TFhirQuestionnaireResponseList.SetItemN(index: Integer; value: TFhirQuestionnaireResponse);
begin
  assert(value is TFhirQuestionnaireResponse);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_QUESTIONNAIRERESPONSE}
{$IFDEF FHIR_REQUESTGROUP}
{ TFhirRequestGroupAction }

constructor TFhirRequestGroupAction.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupAction.Destroy;
begin
  FPrefix.free;
  FTitle.free;
  FDescription.free;
  FTextEquivalent.free;
  FPriority.free;
  FCodeList.Free;
  FDocumentationList.Free;
  FConditionList.Free;
  FRelatedActionList.Free;
  FTiming.free;
  FParticipantList.Free;
  FType_.free;
  FGroupingBehavior.free;
  FSelectionBehavior.free;
  FRequiredBehavior.free;
  FPrecheckBehavior.free;
  FCardinalityBehavior.free;
  FResource.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirRequestGroupAction.Assign(oSource : TFslObject);
begin
  inherited;
  prefixElement := TFhirRequestGroupAction(oSource).prefixElement.Clone;
  titleElement := TFhirRequestGroupAction(oSource).titleElement.Clone;
  descriptionElement := TFhirRequestGroupAction(oSource).descriptionElement.Clone;
  textEquivalentElement := TFhirRequestGroupAction(oSource).textEquivalentElement.Clone;
  priorityElement := TFhirRequestGroupAction(oSource).priorityElement.Clone;
  if (TFhirRequestGroupAction(oSource).FCodeList = nil) then
  begin
    FCodeList.free;
    FCodeList := nil;
  end
  else
  begin
    if FCodeList = nil then
      FCodeList := TFhirCodeableConceptList.Create;
    FCodeList.Assign(TFhirRequestGroupAction(oSource).FCodeList);
  end;
  if (TFhirRequestGroupAction(oSource).FDocumentationList = nil) then
  begin
    FDocumentationList.free;
    FDocumentationList := nil;
  end
  else
  begin
    if FDocumentationList = nil then
      FDocumentationList := TFhirRelatedArtifactList.Create;
    FDocumentationList.Assign(TFhirRequestGroupAction(oSource).FDocumentationList);
  end;
  if (TFhirRequestGroupAction(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirRequestGroupActionConditionList.Create;
    FConditionList.Assign(TFhirRequestGroupAction(oSource).FConditionList);
  end;
  if (TFhirRequestGroupAction(oSource).FRelatedActionList = nil) then
  begin
    FRelatedActionList.free;
    FRelatedActionList := nil;
  end
  else
  begin
    if FRelatedActionList = nil then
      FRelatedActionList := TFhirRequestGroupActionRelatedActionList.Create;
    FRelatedActionList.Assign(TFhirRequestGroupAction(oSource).FRelatedActionList);
  end;
  timing := TFhirRequestGroupAction(oSource).timing.Clone;
  if (TFhirRequestGroupAction(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirReferenceList.Create;
    FParticipantList.Assign(TFhirRequestGroupAction(oSource).FParticipantList);
  end;
  type_ := TFhirRequestGroupAction(oSource).type_.Clone;
  groupingBehaviorElement := TFhirRequestGroupAction(oSource).groupingBehaviorElement.Clone;
  selectionBehaviorElement := TFhirRequestGroupAction(oSource).selectionBehaviorElement.Clone;
  requiredBehaviorElement := TFhirRequestGroupAction(oSource).requiredBehaviorElement.Clone;
  precheckBehaviorElement := TFhirRequestGroupAction(oSource).precheckBehaviorElement.Clone;
  cardinalityBehaviorElement := TFhirRequestGroupAction(oSource).cardinalityBehaviorElement.Clone;
  resource := TFhirRequestGroupAction(oSource).resource.Clone;
  if (TFhirRequestGroupAction(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestGroupActionList.Create;
    FActionList.Assign(TFhirRequestGroupAction(oSource).FActionList);
  end;
end;

procedure TFhirRequestGroupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'prefix') Then
     list.add(self.link, 'prefix', FPrefix.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'textEquivalent') Then
     list.add(self.link, 'textEquivalent', FTextEquivalent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
    list.addAll(self, 'code', FCodeList);
  if (child_name = 'documentation') Then
    list.addAll(self, 'documentation', FDocumentationList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'relatedAction') Then
    list.addAll(self, 'relatedAction', FRelatedActionList);
  if (child_name = 'timing[x]') or (child_name = 'timing') Then
     list.add(self.link, 'timing[x]', FTiming.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'groupingBehavior') Then
     list.add(self.link, 'groupingBehavior', FGroupingBehavior.Link);
  if (child_name = 'selectionBehavior') Then
     list.add(self.link, 'selectionBehavior', FSelectionBehavior.Link);
  if (child_name = 'requiredBehavior') Then
     list.add(self.link, 'requiredBehavior', FRequiredBehavior.Link);
  if (child_name = 'precheckBehavior') Then
     list.add(self.link, 'precheckBehavior', FPrecheckBehavior.Link);
  if (child_name = 'cardinalityBehavior') Then
     list.add(self.link, 'cardinalityBehavior', FCardinalityBehavior.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestGroupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'prefix', 'string', false, TFhirString, FPrefix.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'textEquivalent', 'string', false, TFhirString, FTextEquivalent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', true, TFhirCodeableConcept, FCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'documentation', 'RelatedArtifact', true, TFhirRelatedArtifact, FDocumentationList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'BackboneElement', true, TFhirRequestGroupActionCondition, FConditionList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedAction', 'BackboneElement', true, TFhirRequestGroupActionRelatedAction, FRelatedActionList.Link));
  oList.add(TFHIRProperty.create(self, 'timing[x]', 'dateTime|Age|Period|Duration|Range|Timing', false, TFhirDataType, FTiming.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'Reference', true, TFhirReference, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'groupingBehavior', 'code', false, TFhirEnum, FGroupingBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'selectionBehavior', 'code', false, TFhirEnum, FSelectionBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'requiredBehavior', 'code', false, TFhirEnum, FRequiredBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'precheckBehavior', 'code', false, TFhirEnum, FPrecheckBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'cardinalityBehavior', 'code', false, TFhirEnum, FCardinalityBehavior.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'Reference', false, TFhirReference, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'action', '', true, TFhirRequestGroupAction, FActionList.Link));
end;

function TFhirRequestGroupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'prefix') then
  begin
    PrefixElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'textEquivalent') then
  begin
    TextEquivalentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    CodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'documentation') then
  begin
    DocumentationList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirRequestGroupActionCondition);
    result := propValue;
  end
  else if (propName = 'relatedAction') then
  begin
    RelatedActionList.add(propValue as TFhirRequestGroupActionRelatedAction);
    result := propValue;
  end
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then
  begin
    Timing := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'groupingBehavior') then
  begin
    GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'selectionBehavior') then
  begin
    SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'requiredBehavior') then
  begin
    RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'precheckBehavior') then
  begin
    PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'cardinalityBehavior') then
  begin
    CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    Resource := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestGroupAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'code') then CodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'documentation') then DocumentationList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirRequestGroupActionCondition)
  else if (propName = 'relatedAction') then RelatedActionList.insertItem(index, propValue as TFhirRequestGroupActionRelatedAction)
  else if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestGroupAction)
  else inherited;
end;

function TFhirRequestGroupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'prefix') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'textEquivalent') then result := TFhirString.create()
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'code') then result := CodeList.new()
  else if (propName = 'documentation') then result := DocumentationList.new()
  else if (propName = 'condition') then result := ConditionList.new()
  else if (propName = 'relatedAction') then result := RelatedActionList.new()
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then raise EFHIRException.create('Cannot make property Timing')
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'groupingBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[ActionGroupingBehaviorNull], CODES_TFhirActionGroupingBehaviorEnum[ActionGroupingBehaviorNull]) 
  else if (propName = 'selectionBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[ActionSelectionBehaviorNull], CODES_TFhirActionSelectionBehaviorEnum[ActionSelectionBehaviorNull]) 
  else if (propName = 'requiredBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[ActionRequiredBehaviorNull], CODES_TFhirActionRequiredBehaviorEnum[ActionRequiredBehaviorNull]) 
  else if (propName = 'precheckBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[ActionPrecheckBehaviorNull], CODES_TFhirActionPrecheckBehaviorEnum[ActionPrecheckBehaviorNull]) 
  else if (propName = 'cardinalityBehavior') then result := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[ActionCardinalityBehaviorNull], CODES_TFhirActionCardinalityBehaviorEnum[ActionCardinalityBehaviorNull]) 
  else if (propName = 'resource') then result := TFhirReference.create()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'prefix') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'textEquivalent') then result := 'string'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'documentation') then result := 'RelatedArtifact'
  else if (propName = 'condition') then result := 'BackboneElement'
  else if (propName = 'relatedAction') then result := 'BackboneElement'
  else if (propName = 'timing[x]') then result := 'dateTime|Age|Period|Duration|Range|Timing'
  else if (propName = 'participant') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'groupingBehavior') then result := 'code'
  else if (propName = 'selectionBehavior') then result := 'code'
  else if (propName = 'requiredBehavior') then result := 'code'
  else if (propName = 'precheckBehavior') then result := 'code'
  else if (propName = 'cardinalityBehavior') then result := 'code'
  else if (propName = 'resource') then result := 'Reference'
  else if (propName = 'action') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'prefix') then PrefixElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'textEquivalent') then TextEquivalentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then deletePropertyValue('code', CodeList, value)
  else if (propName = 'documentation') then deletePropertyValue('documentation', DocumentationList, value)
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value)
  else if (propName = 'relatedAction') then deletePropertyValue('relatedAction', RelatedActionList, value)
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := nil
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := nil
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := nil
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := nil
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'prefix') then PrefixElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'textEquivalent') then TextEquivalentElement := asString(new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'code') then replacePropertyValue('code', CodeList, existing, new)
  else if (propName = 'documentation') then replacePropertyValue('documentation', DocumentationList, existing, new)
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new)
  else if (propName = 'relatedAction') then replacePropertyValue('relatedAction', RelatedActionList, existing, new)
  else if (isMatchingName(propName, 'timing', ['DateTime', 'Age', 'Period', 'Duration', 'Range', 'Timing'])) then TimingElement := new as TFhirDataType
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'groupingBehavior') then GroupingBehaviorElement := asEnum(SYSTEMS_TFhirActionGroupingBehaviorEnum, CODES_TFhirActionGroupingBehaviorEnum, new)
  else if (propName = 'selectionBehavior') then SelectionBehaviorElement := asEnum(SYSTEMS_TFhirActionSelectionBehaviorEnum, CODES_TFhirActionSelectionBehaviorEnum, new)
  else if (propName = 'requiredBehavior') then RequiredBehaviorElement := asEnum(SYSTEMS_TFhirActionRequiredBehaviorEnum, CODES_TFhirActionRequiredBehaviorEnum, new)
  else if (propName = 'precheckBehavior') then PrecheckBehaviorElement := asEnum(SYSTEMS_TFhirActionPrecheckBehaviorEnum, CODES_TFhirActionPrecheckBehaviorEnum, new)
  else if (propName = 'cardinalityBehavior') then CardinalityBehaviorElement := asEnum(SYSTEMS_TFhirActionCardinalityBehaviorEnum, CODES_TFhirActionCardinalityBehaviorEnum, new)
  else if (propName = 'resource') then ResourceElement := new as TFhirReference
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupAction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'code') then CodeList.move(source, destination)
  else if (propName = 'documentation') then DocumentationList.move(source, destination)
  else if (propName = 'condition') then ConditionList.move(source, destination)
  else if (propName = 'relatedAction') then RelatedActionList.move(source, destination)
  else if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupAction.fhirType : string;
begin
  result := 'RequestGroup.action';
end;

function TFhirRequestGroupAction.Link : TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(inherited Link);
end;

function TFhirRequestGroupAction.Clone : TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(inherited Clone);
end;

function TFhirRequestGroupAction.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupAction)) then
    result := false
  else
  begin
    o := TFhirRequestGroupAction(other);
    result := compareDeep(prefixElement, o.prefixElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(textEquivalentElement, o.textEquivalentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeList, o.codeList, true) and 
      compareDeep(documentationList, o.documentationList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(relatedActionList, o.relatedActionList, true) and compareDeep(timingElement, o.timingElement, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(groupingBehaviorElement, o.groupingBehaviorElement, true) and compareDeep(selectionBehaviorElement, o.selectionBehaviorElement, true) and 
      compareDeep(requiredBehaviorElement, o.requiredBehaviorElement, true) and compareDeep(precheckBehaviorElement, o.precheckBehaviorElement, true) and 
      compareDeep(cardinalityBehaviorElement, o.cardinalityBehaviorElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestGroupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPrefix) and isEmptyProp(FTitle) and isEmptyProp(FDescription) and isEmptyProp(FTextEquivalent) and isEmptyProp(FPriority) and isEmptyProp(FcodeList) and isEmptyProp(FdocumentationList) and isEmptyProp(FconditionList) and isEmptyProp(FrelatedActionList) and isEmptyProp(FTiming) and isEmptyProp(FparticipantList) and isEmptyProp(FType_) and isEmptyProp(FGroupingBehavior) and isEmptyProp(FSelectionBehavior) and isEmptyProp(FRequiredBehavior) and isEmptyProp(FPrecheckBehavior) and isEmptyProp(FCardinalityBehavior) and isEmptyProp(FResource) and isEmptyProp(FactionList);
end;

procedure TFhirRequestGroupAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('prefix');
  fields.add('title');
  fields.add('description');
  fields.add('textEquivalent');
  fields.add('priority');
  fields.add('code');
  fields.add('documentation');
  fields.add('condition');
  fields.add('relatedAction');
  fields.add('timing[x]');
  fields.add('participant');
  fields.add('type');
  fields.add('groupingBehavior');
  fields.add('selectionBehavior');
  fields.add('requiredBehavior');
  fields.add('precheckBehavior');
  fields.add('cardinalityBehavior');
  fields.add('resource');
  fields.add('action');
end;

function TFhirRequestGroupAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FCodeList.sizeInBytes(magic));
  inc(result, FDocumentationList.sizeInBytes(magic));
  inc(result, FConditionList.sizeInBytes(magic));
  inc(result, FRelatedActionList.sizeInBytes(magic));
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirRequestGroupAction.SetPrefix(value : TFhirString);
begin
  FPrefix.free;
  FPrefix := value;
end;

function TFhirRequestGroupAction.GetPrefixST : String;
begin
  if FPrefix = nil then
    result := ''
  else
    result := FPrefix.value;
end;

procedure TFhirRequestGroupAction.SetPrefixST(value : String);
begin
  if value <> '' then
  begin
    if FPrefix = nil then
      FPrefix := TFhirString.create;
    FPrefix.value := value
  end
  else if FPrefix <> nil then
    FPrefix.value := '';
end;

procedure TFhirRequestGroupAction.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirRequestGroupAction.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirRequestGroupAction.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirRequestGroupAction.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirRequestGroupAction.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirRequestGroupAction.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirRequestGroupAction.SetTextEquivalent(value : TFhirString);
begin
  FTextEquivalent.free;
  FTextEquivalent := value;
end;

function TFhirRequestGroupAction.GetTextEquivalentST : String;
begin
  if FTextEquivalent = nil then
    result := ''
  else
    result := FTextEquivalent.value;
end;

procedure TFhirRequestGroupAction.SetTextEquivalentST(value : String);
begin
  if value <> '' then
  begin
    if FTextEquivalent = nil then
      FTextEquivalent := TFhirString.create;
    FTextEquivalent.value := value
  end
  else if FTextEquivalent <> nil then
    FTextEquivalent.value := '';
end;

procedure TFhirRequestGroupAction.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirRequestGroupAction.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirRequestGroupAction.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

function TFhirRequestGroupAction.GetCodeList : TFhirCodeableConceptList;
begin
  if FCodeList = nil then
    FCodeList := TFhirCodeableConceptList.Create;
  result := FCodeList;
end;

function TFhirRequestGroupAction.GetHasCodeList : boolean;
begin
  result := (FCodeList <> nil) and (FCodeList.count > 0);
end;

function TFhirRequestGroupAction.GetDocumentationList : TFhirRelatedArtifactList;
begin
  if FDocumentationList = nil then
    FDocumentationList := TFhirRelatedArtifactList.Create;
  result := FDocumentationList;
end;

function TFhirRequestGroupAction.GetHasDocumentationList : boolean;
begin
  result := (FDocumentationList <> nil) and (FDocumentationList.count > 0);
end;

function TFhirRequestGroupAction.GetConditionList : TFhirRequestGroupActionConditionList;
begin
  if FConditionList = nil then
    FConditionList := TFhirRequestGroupActionConditionList.Create;
  result := FConditionList;
end;

function TFhirRequestGroupAction.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirRequestGroupAction.GetRelatedActionList : TFhirRequestGroupActionRelatedActionList;
begin
  if FRelatedActionList = nil then
    FRelatedActionList := TFhirRequestGroupActionRelatedActionList.Create;
  result := FRelatedActionList;
end;

function TFhirRequestGroupAction.GetHasRelatedActionList : boolean;
begin
  result := (FRelatedActionList <> nil) and (FRelatedActionList.count > 0);
end;

procedure TFhirRequestGroupAction.SetTiming(value : TFhirDataType);
begin
  FTiming.free;
  FTiming := value;
end;

function TFhirRequestGroupAction.GetParticipantList : TFhirReferenceList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirReferenceList.Create;
  result := FParticipantList;
end;

function TFhirRequestGroupAction.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirRequestGroupAction.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirRequestGroupAction.SetGroupingBehavior(value : TFhirEnum);
begin
  FGroupingBehavior.free;
  FGroupingBehavior := value;
end;

function TFhirRequestGroupAction.GetGroupingBehaviorST : TFhirActionGroupingBehaviorEnum;
begin
  if FGroupingBehavior = nil then
    result := TFhirActionGroupingBehaviorEnum(0)
  else
    result := TFhirActionGroupingBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionGroupingBehaviorEnum, FGroupingBehavior.value));
end;

procedure TFhirRequestGroupAction.SetGroupingBehaviorST(value : TFhirActionGroupingBehaviorEnum);
begin
  if ord(value) = 0 then
    GroupingBehaviorElement := nil
  else
    GroupingBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionGroupingBehaviorEnum[value], CODES_TFhirActionGroupingBehaviorEnum[value]);
end;

procedure TFhirRequestGroupAction.SetSelectionBehavior(value : TFhirEnum);
begin
  FSelectionBehavior.free;
  FSelectionBehavior := value;
end;

function TFhirRequestGroupAction.GetSelectionBehaviorST : TFhirActionSelectionBehaviorEnum;
begin
  if FSelectionBehavior = nil then
    result := TFhirActionSelectionBehaviorEnum(0)
  else
    result := TFhirActionSelectionBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionSelectionBehaviorEnum, FSelectionBehavior.value));
end;

procedure TFhirRequestGroupAction.SetSelectionBehaviorST(value : TFhirActionSelectionBehaviorEnum);
begin
  if ord(value) = 0 then
    SelectionBehaviorElement := nil
  else
    SelectionBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionSelectionBehaviorEnum[value], CODES_TFhirActionSelectionBehaviorEnum[value]);
end;

procedure TFhirRequestGroupAction.SetRequiredBehavior(value : TFhirEnum);
begin
  FRequiredBehavior.free;
  FRequiredBehavior := value;
end;

function TFhirRequestGroupAction.GetRequiredBehaviorST : TFhirActionRequiredBehaviorEnum;
begin
  if FRequiredBehavior = nil then
    result := TFhirActionRequiredBehaviorEnum(0)
  else
    result := TFhirActionRequiredBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRequiredBehaviorEnum, FRequiredBehavior.value));
end;

procedure TFhirRequestGroupAction.SetRequiredBehaviorST(value : TFhirActionRequiredBehaviorEnum);
begin
  if ord(value) = 0 then
    RequiredBehaviorElement := nil
  else
    RequiredBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionRequiredBehaviorEnum[value], CODES_TFhirActionRequiredBehaviorEnum[value]);
end;

procedure TFhirRequestGroupAction.SetPrecheckBehavior(value : TFhirEnum);
begin
  FPrecheckBehavior.free;
  FPrecheckBehavior := value;
end;

function TFhirRequestGroupAction.GetPrecheckBehaviorST : TFhirActionPrecheckBehaviorEnum;
begin
  if FPrecheckBehavior = nil then
    result := TFhirActionPrecheckBehaviorEnum(0)
  else
    result := TFhirActionPrecheckBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionPrecheckBehaviorEnum, FPrecheckBehavior.value));
end;

procedure TFhirRequestGroupAction.SetPrecheckBehaviorST(value : TFhirActionPrecheckBehaviorEnum);
begin
  if ord(value) = 0 then
    PrecheckBehaviorElement := nil
  else
    PrecheckBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionPrecheckBehaviorEnum[value], CODES_TFhirActionPrecheckBehaviorEnum[value]);
end;

procedure TFhirRequestGroupAction.SetCardinalityBehavior(value : TFhirEnum);
begin
  FCardinalityBehavior.free;
  FCardinalityBehavior := value;
end;

function TFhirRequestGroupAction.GetCardinalityBehaviorST : TFhirActionCardinalityBehaviorEnum;
begin
  if FCardinalityBehavior = nil then
    result := TFhirActionCardinalityBehaviorEnum(0)
  else
    result := TFhirActionCardinalityBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirActionCardinalityBehaviorEnum, FCardinalityBehavior.value));
end;

procedure TFhirRequestGroupAction.SetCardinalityBehaviorST(value : TFhirActionCardinalityBehaviorEnum);
begin
  if ord(value) = 0 then
    CardinalityBehaviorElement := nil
  else
    CardinalityBehaviorElement := TFhirEnum.create(SYSTEMS_TFhirActionCardinalityBehaviorEnum[value], CODES_TFhirActionCardinalityBehaviorEnum[value]);
end;

procedure TFhirRequestGroupAction.SetResource(value : TFhirReference);
begin
  FResource.free;
  FResource := value;
end;

function TFhirRequestGroupAction.GetActionList : TFhirRequestGroupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestGroupActionList.Create;
  result := FActionList;
end;

function TFhirRequestGroupAction.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirRequestGroupActionListEnumerator }

constructor TFhirRequestGroupActionListEnumerator.Create(list : TFhirRequestGroupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionListEnumerator.GetCurrent : TFhirRequestGroupAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestGroupActionList }

function TFhirRequestGroupActionList.AddItem(value: TFhirRequestGroupAction): TFhirRequestGroupAction;
begin
  assert(value.ClassName = 'TFhirRequestGroupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupAction');
  add(value);
  result := value;
end;

function TFhirRequestGroupActionList.Append: TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionList.GetEnumerator : TFhirRequestGroupActionListEnumerator;
begin
  result := TFhirRequestGroupActionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionList.Clone: TFhirRequestGroupActionList;
begin
  result := TFhirRequestGroupActionList(inherited Clone);
end;

function TFhirRequestGroupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionList.GetItemN(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupAction;
end;
function TFhirRequestGroupActionList.IndexOf(value: TFhirRequestGroupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionList.Insert(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionList.InsertItem(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionList.Item(index: Integer): TFhirRequestGroupAction;
begin
  result := TFhirRequestGroupAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionList.Link: TFhirRequestGroupActionList;
begin
  result := TFhirRequestGroupActionList(inherited Link);
end;

procedure TFhirRequestGroupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  FhirRequestGroupActions[index] := value;
end;

procedure TFhirRequestGroupActionList.SetItemN(index: Integer; value: TFhirRequestGroupAction);
begin
  assert(value is TFhirRequestGroupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroupActionCondition }

constructor TFhirRequestGroupActionCondition.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupActionCondition.Destroy;
begin
  FKind.free;
  FExpression.free;
  inherited;
end;

procedure TFhirRequestGroupActionCondition.Assign(oSource : TFslObject);
begin
  inherited;
  kindElement := TFhirRequestGroupActionCondition(oSource).kindElement.Clone;
  expression := TFhirRequestGroupActionCondition(oSource).expression.Clone;
end;

procedure TFhirRequestGroupActionCondition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'kind') Then
     list.add(self.link, 'kind', FKind.Link);
  if (child_name = 'expression') Then
     list.add(self.link, 'expression', FExpression.Link);
end;

procedure TFhirRequestGroupActionCondition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'kind', 'code', false, TFhirEnum, FKind.Link));
  oList.add(TFHIRProperty.create(self, 'expression', 'Expression', false, TFhirExpression, FExpression.Link));
end;

function TFhirRequestGroupActionCondition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'kind') then
  begin
    KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, propValue);
    result := propValue;
  end
  else if (propName = 'expression') then
  begin
    Expression := propValue as TFhirExpression;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupActionCondition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestGroupActionCondition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'kind') then result := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[ActionConditionKindNull], CODES_TFhirActionConditionKindEnum[ActionConditionKindNull]) 
  else if (propName = 'expression') then result := TFhirExpression.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupActionCondition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'kind') then result := 'code'
  else if (propName = 'expression') then result := 'Expression'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupActionCondition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := nil
  else if (propName = 'expression') then ExpressionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupActionCondition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'kind') then KindElement := asEnum(SYSTEMS_TFhirActionConditionKindEnum, CODES_TFhirActionConditionKindEnum, new)
  else if (propName = 'expression') then ExpressionElement := new as TFhirExpression
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupActionCondition.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupActionCondition.fhirType : string;
begin
  result := 'RequestGroup.action.condition';
end;

function TFhirRequestGroupActionCondition.Link : TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(inherited Link);
end;

function TFhirRequestGroupActionCondition.Clone : TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(inherited Clone);
end;

function TFhirRequestGroupActionCondition.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupActionCondition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupActionCondition)) then
    result := false
  else
  begin
    o := TFhirRequestGroupActionCondition(other);
    result := compareDeep(kindElement, o.kindElement, true) and compareDeep(expressionElement, o.expressionElement, true);
  end;
end;

function TFhirRequestGroupActionCondition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FKind) and isEmptyProp(FExpression);
end;

procedure TFhirRequestGroupActionCondition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('kind');
  fields.add('expression');
end;

function TFhirRequestGroupActionCondition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestGroupActionCondition.SetKind(value : TFhirEnum);
begin
  FKind.free;
  FKind := value;
end;

function TFhirRequestGroupActionCondition.GetKindST : TFhirActionConditionKindEnum;
begin
  if FKind = nil then
    result := TFhirActionConditionKindEnum(0)
  else
    result := TFhirActionConditionKindEnum(StringArrayIndexOfSensitive(CODES_TFhirActionConditionKindEnum, FKind.value));
end;

procedure TFhirRequestGroupActionCondition.SetKindST(value : TFhirActionConditionKindEnum);
begin
  if ord(value) = 0 then
    KindElement := nil
  else
    KindElement := TFhirEnum.create(SYSTEMS_TFhirActionConditionKindEnum[value], CODES_TFhirActionConditionKindEnum[value]);
end;

procedure TFhirRequestGroupActionCondition.SetExpression(value : TFhirExpression);
begin
  FExpression.free;
  FExpression := value;
end;

{ TFhirRequestGroupActionConditionListEnumerator }

constructor TFhirRequestGroupActionConditionListEnumerator.Create(list : TFhirRequestGroupActionConditionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionConditionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionConditionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionConditionListEnumerator.GetCurrent : TFhirRequestGroupActionCondition;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionConditionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestGroupActionConditionList }

function TFhirRequestGroupActionConditionList.AddItem(value: TFhirRequestGroupActionCondition): TFhirRequestGroupActionCondition;
begin
  assert(value.ClassName = 'TFhirRequestGroupActionCondition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupActionCondition');
  add(value);
  result := value;
end;

function TFhirRequestGroupActionConditionList.Append: TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionConditionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionConditionList.GetEnumerator : TFhirRequestGroupActionConditionListEnumerator;
begin
  result := TFhirRequestGroupActionConditionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionConditionList.Clone: TFhirRequestGroupActionConditionList;
begin
  result := TFhirRequestGroupActionConditionList(inherited Clone);
end;

function TFhirRequestGroupActionConditionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionConditionList.GetItemN(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionConditionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupActionCondition;
end;
function TFhirRequestGroupActionConditionList.IndexOf(value: TFhirRequestGroupActionCondition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionConditionList.Insert(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionConditionList.InsertItem(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionConditionList.Item(index: Integer): TFhirRequestGroupActionCondition;
begin
  result := TFhirRequestGroupActionCondition(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionConditionList.Link: TFhirRequestGroupActionConditionList;
begin
  result := TFhirRequestGroupActionConditionList(inherited Link);
end;

procedure TFhirRequestGroupActionConditionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionConditionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  FhirRequestGroupActionConditions[index] := value;
end;

procedure TFhirRequestGroupActionConditionList.SetItemN(index: Integer; value: TFhirRequestGroupActionCondition);
begin
  assert(value is TFhirRequestGroupActionCondition);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroupActionRelatedAction }

constructor TFhirRequestGroupActionRelatedAction.Create;
begin
  inherited;
end;

destructor TFhirRequestGroupActionRelatedAction.Destroy;
begin
  FActionId.free;
  FRelationship.free;
  FOffset.free;
  inherited;
end;

procedure TFhirRequestGroupActionRelatedAction.Assign(oSource : TFslObject);
begin
  inherited;
  actionIdElement := TFhirRequestGroupActionRelatedAction(oSource).actionIdElement.Clone;
  relationshipElement := TFhirRequestGroupActionRelatedAction(oSource).relationshipElement.Clone;
  offset := TFhirRequestGroupActionRelatedAction(oSource).offset.Clone;
end;

procedure TFhirRequestGroupActionRelatedAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'actionId') Then
     list.add(self.link, 'actionId', FActionId.Link);
  if (child_name = 'relationship') Then
     list.add(self.link, 'relationship', FRelationship.Link);
  if (child_name = 'offset[x]') or (child_name = 'offset') Then
     list.add(self.link, 'offset[x]', FOffset.Link);
end;

procedure TFhirRequestGroupActionRelatedAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'actionId', 'id', false, TFhirId, FActionId.Link));
  oList.add(TFHIRProperty.create(self, 'relationship', 'code', false, TFhirEnum, FRelationship.Link));
  oList.add(TFHIRProperty.create(self, 'offset[x]', 'Duration|Range', false, TFhirDataType, FOffset.Link));
end;

function TFhirRequestGroupActionRelatedAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'actionId') then
  begin
    ActionIdElement := asId(propValue);
    result := propValue;
  end
  else if (propName = 'relationship') then
  begin
    RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then
  begin
    Offset := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroupActionRelatedAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirRequestGroupActionRelatedAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'actionId') then result := TFhirId.create()
  else if (propName = 'relationship') then result := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[ActionRelationshipTypeNull], CODES_TFhirActionRelationshipTypeEnum[ActionRelationshipTypeNull]) 
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then raise EFHIRException.create('Cannot make property Offset')
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroupActionRelatedAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'actionId') then result := 'id'
  else if (propName = 'relationship') then result := 'code'
  else if (propName = 'offset[x]') then result := 'Duration|Range'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroupActionRelatedAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := nil
  else if (propName = 'relationship') then RelationshipElement := nil
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroupActionRelatedAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'actionId') then ActionIdElement := asId(new)
  else if (propName = 'relationship') then RelationshipElement := asEnum(SYSTEMS_TFhirActionRelationshipTypeEnum, CODES_TFhirActionRelationshipTypeEnum, new)
  else if (isMatchingName(propName, 'offset', ['Duration', 'Range'])) then OffsetElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroupActionRelatedAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroupActionRelatedAction.fhirType : string;
begin
  result := 'RequestGroup.action.relatedAction';
end;

function TFhirRequestGroupActionRelatedAction.Link : TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(inherited Link);
end;

function TFhirRequestGroupActionRelatedAction.Clone : TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(inherited Clone);
end;

function TFhirRequestGroupActionRelatedAction.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroupActionRelatedAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroupActionRelatedAction)) then
    result := false
  else
  begin
    o := TFhirRequestGroupActionRelatedAction(other);
    result := compareDeep(actionIdElement, o.actionIdElement, true) and compareDeep(relationshipElement, o.relationshipElement, true) and 
      compareDeep(offsetElement, o.offsetElement, true);
  end;
end;

function TFhirRequestGroupActionRelatedAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FActionId) and isEmptyProp(FRelationship) and isEmptyProp(FOffset);
end;

procedure TFhirRequestGroupActionRelatedAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('actionId');
  fields.add('relationship');
  fields.add('offset[x]');
end;

function TFhirRequestGroupActionRelatedAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirRequestGroupActionRelatedAction.SetActionId(value : TFhirId);
begin
  FActionId.free;
  FActionId := value;
end;

function TFhirRequestGroupActionRelatedAction.GetActionIdST : String;
begin
  if FActionId = nil then
    result := ''
  else
    result := FActionId.value;
end;

procedure TFhirRequestGroupActionRelatedAction.SetActionIdST(value : String);
begin
  if value <> '' then
  begin
    if FActionId = nil then
      FActionId := TFhirId.create;
    FActionId.value := value
  end
  else if FActionId <> nil then
    FActionId.value := '';
end;

procedure TFhirRequestGroupActionRelatedAction.SetRelationship(value : TFhirEnum);
begin
  FRelationship.free;
  FRelationship := value;
end;

function TFhirRequestGroupActionRelatedAction.GetRelationshipST : TFhirActionRelationshipTypeEnum;
begin
  if FRelationship = nil then
    result := TFhirActionRelationshipTypeEnum(0)
  else
    result := TFhirActionRelationshipTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirActionRelationshipTypeEnum, FRelationship.value));
end;

procedure TFhirRequestGroupActionRelatedAction.SetRelationshipST(value : TFhirActionRelationshipTypeEnum);
begin
  if ord(value) = 0 then
    RelationshipElement := nil
  else
    RelationshipElement := TFhirEnum.create(SYSTEMS_TFhirActionRelationshipTypeEnum[value], CODES_TFhirActionRelationshipTypeEnum[value]);
end;

procedure TFhirRequestGroupActionRelatedAction.SetOffset(value : TFhirDataType);
begin
  FOffset.free;
  FOffset := value;
end;

{ TFhirRequestGroupActionRelatedActionListEnumerator }

constructor TFhirRequestGroupActionRelatedActionListEnumerator.Create(list : TFhirRequestGroupActionRelatedActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupActionRelatedActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.GetCurrent : TFhirRequestGroupActionRelatedAction;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupActionRelatedActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestGroupActionRelatedActionList }

function TFhirRequestGroupActionRelatedActionList.AddItem(value: TFhirRequestGroupActionRelatedAction): TFhirRequestGroupActionRelatedAction;
begin
  assert(value.ClassName = 'TFhirRequestGroupActionRelatedAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroupActionRelatedAction');
  add(value);
  result := value;
end;

function TFhirRequestGroupActionRelatedActionList.Append: TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionRelatedActionList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupActionRelatedActionList.GetEnumerator : TFhirRequestGroupActionRelatedActionListEnumerator;
begin
  result := TFhirRequestGroupActionRelatedActionListEnumerator.Create(self.link);
end;

function TFhirRequestGroupActionRelatedActionList.Clone: TFhirRequestGroupActionRelatedActionList;
begin
  result := TFhirRequestGroupActionRelatedActionList(inherited Clone);
end;

function TFhirRequestGroupActionRelatedActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupActionRelatedActionList.GetItemN(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionRelatedActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroupActionRelatedAction;
end;
function TFhirRequestGroupActionRelatedActionList.IndexOf(value: TFhirRequestGroupActionRelatedAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupActionRelatedActionList.Insert(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupActionRelatedActionList.InsertItem(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupActionRelatedActionList.Item(index: Integer): TFhirRequestGroupActionRelatedAction;
begin
  result := TFhirRequestGroupActionRelatedAction(ObjectByIndex[index]);
end;

function TFhirRequestGroupActionRelatedActionList.Link: TFhirRequestGroupActionRelatedActionList;
begin
  result := TFhirRequestGroupActionRelatedActionList(inherited Link);
end;

procedure TFhirRequestGroupActionRelatedActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupActionRelatedActionList.SetItemByIndex(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  FhirRequestGroupActionRelatedActions[index] := value;
end;

procedure TFhirRequestGroupActionRelatedActionList.SetItemN(index: Integer; value: TFhirRequestGroupActionRelatedAction);
begin
  assert(value is TFhirRequestGroupActionRelatedAction);
  ObjectByIndex[index] := value;
end;

{ TFhirRequestGroup }

constructor TFhirRequestGroup.Create;
begin
  inherited;
end;

destructor TFhirRequestGroup.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonicalList.Free;
  FInstantiatesUriList.Free;
  FBasedOnList.Free;
  FReplacesList.Free;
  FGroupIdentifier.free;
  FStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FSubject.free;
  FEncounter.free;
  FAuthoredOn.free;
  FAuthor.free;
  FReasonCodeList.Free;
  FReasonReferenceList.Free;
  FNoteList.Free;
  FActionList.Free;
  inherited;
end;

procedure TFhirRequestGroup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirRequestGroup(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirRequestGroup(oSource).FIdentifierList);
  end;
  if (TFhirRequestGroup(oSource).FInstantiatesCanonicalList = nil) then
  begin
    FInstantiatesCanonicalList.free;
    FInstantiatesCanonicalList := nil;
  end
  else
  begin
    if FInstantiatesCanonicalList = nil then
      FInstantiatesCanonicalList := TFhirCanonicalList.Create;
    FInstantiatesCanonicalList.Assign(TFhirRequestGroup(oSource).FInstantiatesCanonicalList);
  end;
  if (TFhirRequestGroup(oSource).FInstantiatesUriList = nil) then
  begin
    FInstantiatesUriList.free;
    FInstantiatesUriList := nil;
  end
  else
  begin
    if FInstantiatesUriList = nil then
      FInstantiatesUriList := TFhirUriList.Create;
    FInstantiatesUriList.Assign(TFhirRequestGroup(oSource).FInstantiatesUriList);
  end;
  if (TFhirRequestGroup(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirRequestGroup(oSource).FBasedOnList);
  end;
  if (TFhirRequestGroup(oSource).FReplacesList = nil) then
  begin
    FReplacesList.free;
    FReplacesList := nil;
  end
  else
  begin
    if FReplacesList = nil then
      FReplacesList := TFhirReferenceList.Create;
    FReplacesList.Assign(TFhirRequestGroup(oSource).FReplacesList);
  end;
  groupIdentifier := TFhirRequestGroup(oSource).groupIdentifier.Clone;
  statusElement := TFhirRequestGroup(oSource).statusElement.Clone;
  intentElement := TFhirRequestGroup(oSource).intentElement.Clone;
  priorityElement := TFhirRequestGroup(oSource).priorityElement.Clone;
  code := TFhirRequestGroup(oSource).code.Clone;
  subject := TFhirRequestGroup(oSource).subject.Clone;
  encounter := TFhirRequestGroup(oSource).encounter.Clone;
  authoredOnElement := TFhirRequestGroup(oSource).authoredOnElement.Clone;
  author := TFhirRequestGroup(oSource).author.Clone;
  if (TFhirRequestGroup(oSource).FReasonCodeList = nil) then
  begin
    FReasonCodeList.free;
    FReasonCodeList := nil;
  end
  else
  begin
    if FReasonCodeList = nil then
      FReasonCodeList := TFhirCodeableConceptList.Create;
    FReasonCodeList.Assign(TFhirRequestGroup(oSource).FReasonCodeList);
  end;
  if (TFhirRequestGroup(oSource).FReasonReferenceList = nil) then
  begin
    FReasonReferenceList.free;
    FReasonReferenceList := nil;
  end
  else
  begin
    if FReasonReferenceList = nil then
      FReasonReferenceList := TFhirReferenceList.Create;
    FReasonReferenceList.Assign(TFhirRequestGroup(oSource).FReasonReferenceList);
  end;
  if (TFhirRequestGroup(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirRequestGroup(oSource).FNoteList);
  end;
  if (TFhirRequestGroup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirRequestGroupActionList.Create;
    FActionList.Assign(TFhirRequestGroup(oSource).FActionList);
  end;
end;

function TFhirRequestGroup.GetResourceType : TFhirResourceType;
begin
  result := frtRequestGroup;
end;

procedure TFhirRequestGroup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
    list.addAll(self, 'instantiatesCanonical', FInstantiatesCanonicalList);
  if (child_name = 'instantiatesUri') Then
    list.addAll(self, 'instantiatesUri', FInstantiatesUriList);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'replaces') Then
    list.addAll(self, 'replaces', FReplacesList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'subject') Then
     list.add(self.link, 'subject', FSubject.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'author') Then
     list.add(self.link, 'author', FAuthor.Link);
  if (child_name = 'reasonCode') Then
    list.addAll(self, 'reasonCode', FReasonCodeList);
  if (child_name = 'reasonReference') Then
    list.addAll(self, 'reasonReference', FReasonReferenceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirRequestGroup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', true, TFhirCanonical, FInstantiatesCanonicalList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', true, TFhirUri, FInstantiatesUriList.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'replaces', 'Reference', true, TFhirReference, FReplacesList.Link));
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'subject', 'Reference', false, TFhirReference, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'Reference', false, TFhirReference, FAuthor.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', true, TFhirCodeableConcept, FReasonCodeList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', true, TFhirReference, FReasonReferenceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirRequestGroupAction, FActionList.Link));
end;

function TFhirRequestGroup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriList.add(asUri(propValue)){2};     result := propValue;

  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'replaces') then
  begin
    ReplacesList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'subject') then
  begin
    Subject := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    Author := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCodeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReferenceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirRequestGroupAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirRequestGroup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.insertItem(index, asCanonical(propValue))
  else if (propName = 'instantiatesUri') then InstantiatesUriList.insertItem(index, asUri(propValue))
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'replaces') then ReplacesList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'reasonCode') then ReasonCodeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'reasonReference') then ReasonReferenceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirRequestGroupAction)
  else inherited;
end;

function TFhirRequestGroup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := InstantiatesCanonicalList.new()
  else if (propName = 'instantiatesUri') then result := InstantiatesUriList.new()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'replaces') then result := ReplacesList.new()
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[RequestStatusNull], CODES_TFhirRequestStatusEnum[RequestStatusNull]) 
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[RequestIntentNull], CODES_TFhirRequestIntentEnum[RequestIntentNull]) 
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'subject') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'author') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := ReasonCodeList.new()
  else if (propName = 'reasonReference') then result := ReasonReferenceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirRequestGroup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'replaces') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'subject') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'author') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirRequestGroup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then deletePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, value)
  else if (propName = 'instantiatesUri') then deletePropertyValue('instantiatesUri', InstantiatesUriList, value)
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'replaces') then deletePropertyValue('replaces', ReplacesList, value)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'subject') then SubjectElement := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'author') then AuthorElement := nil
  else if (propName = 'reasonCode') then deletePropertyValue('reasonCode', ReasonCodeList, value)
  else if (propName = 'reasonReference') then deletePropertyValue('reasonReference', ReasonReferenceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirRequestGroup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then replacePropertyValue('instantiatesCanonical', InstantiatesCanonicalList, existing, new)
  else if (propName = 'instantiatesUri') then replacePropertyValue('instantiatesUri', InstantiatesUriList, existing, new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'replaces') then replacePropertyValue('replaces', ReplacesList, existing, new)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirRequestStatusEnum, CODES_TFhirRequestStatusEnum, new)
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirRequestIntentEnum, CODES_TFhirRequestIntentEnum, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'subject') then SubjectElement := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'author') then AuthorElement := new as TFhirReference
  else if (propName = 'reasonCode') then replacePropertyValue('reasonCode', ReasonCodeList, existing, new)
  else if (propName = 'reasonReference') then replacePropertyValue('reasonReference', ReasonReferenceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirRequestGroup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalList.move(source, destination)
  else if (propName = 'instantiatesUri') then InstantiatesUriList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'replaces') then ReplacesList.move(source, destination)
  else if (propName = 'reasonCode') then ReasonCodeList.move(source, destination)
  else if (propName = 'reasonReference') then ReasonReferenceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirRequestGroup.fhirType : string;
begin
  result := 'RequestGroup';
end;

function TFhirRequestGroup.Link : TFhirRequestGroup;
begin
  result := TFhirRequestGroup(inherited Link);
end;

function TFhirRequestGroup.Clone : TFhirRequestGroup;
begin
  result := TFhirRequestGroup(inherited Clone);
end;

function TFhirRequestGroup.equals(other : TObject) : boolean; 
var
  o : TFhirRequestGroup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirRequestGroup)) then
    result := false
  else
  begin
    o := TFhirRequestGroup(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalList, o.instantiatesCanonicalList, true) and 
      compareDeep(instantiatesUriList, o.instantiatesUriList, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(replacesList, o.replacesList, true) and compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(subjectElement, o.subjectElement, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(authoredOnElement, o.authoredOnElement, true) and compareDeep(authorElement, o.authorElement, true) and 
      compareDeep(reasonCodeList, o.reasonCodeList, true) and compareDeep(reasonReferenceList, o.reasonReferenceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirRequestGroup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FinstantiatesCanonicalList) and isEmptyProp(FinstantiatesUriList) and isEmptyProp(FbasedOnList) and isEmptyProp(FreplacesList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FSubject) and isEmptyProp(FEncounter) and isEmptyProp(FAuthoredOn) and isEmptyProp(FAuthor) and isEmptyProp(FreasonCodeList) and isEmptyProp(FreasonReferenceList) and isEmptyProp(FnoteList) and isEmptyProp(FactionList);
end;

procedure TFhirRequestGroup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('replaces');
  fields.add('groupIdentifier');
  fields.add('status');
  fields.add('intent');
  fields.add('priority');
  fields.add('code');
  fields.add('subject');
  fields.add('encounter');
  fields.add('authoredOn');
  fields.add('author');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('note');
  fields.add('action');
end;

function TFhirRequestGroup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FInstantiatesCanonicalList.sizeInBytes(magic));
  inc(result, FInstantiatesUriList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FReplacesList.sizeInBytes(magic));
  inc(result, FReasonCodeList.sizeInBytes(magic));
  inc(result, FReasonReferenceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FActionList.sizeInBytes(magic));
end;

function TFhirRequestGroup.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirRequestGroup.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

function TFhirRequestGroup.GetInstantiatesCanonicalList : TFhirCanonicalList;
begin
  if FInstantiatesCanonicalList = nil then
    FInstantiatesCanonicalList := TFhirCanonicalList.Create;
  result := FInstantiatesCanonicalList;
end;

function TFhirRequestGroup.GetHasInstantiatesCanonicalList : boolean;
begin
  result := (FInstantiatesCanonicalList <> nil) and (FInstantiatesCanonicalList.count > 0);
end;

function TFhirRequestGroup.GetInstantiatesUriList : TFhirUriList;
begin
  if FInstantiatesUriList = nil then
    FInstantiatesUriList := TFhirUriList.Create;
  result := FInstantiatesUriList;
end;

function TFhirRequestGroup.GetHasInstantiatesUriList : boolean;
begin
  result := (FInstantiatesUriList <> nil) and (FInstantiatesUriList.count > 0);
end;

function TFhirRequestGroup.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirRequestGroup.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

function TFhirRequestGroup.GetReplacesList : TFhirReferenceList;
begin
  if FReplacesList = nil then
    FReplacesList := TFhirReferenceList.Create;
  result := FReplacesList;
end;

function TFhirRequestGroup.GetHasReplacesList : boolean;
begin
  result := (FReplacesList <> nil) and (FReplacesList.count > 0);
end;

procedure TFhirRequestGroup.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

procedure TFhirRequestGroup.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirRequestGroup.GetStatusST : TFhirRequestStatusEnum;
begin
  if FStatus = nil then
    result := TFhirRequestStatusEnum(0)
  else
    result := TFhirRequestStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestStatusEnum, FStatus.value));
end;

procedure TFhirRequestGroup.SetStatusST(value : TFhirRequestStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirRequestStatusEnum[value], CODES_TFhirRequestStatusEnum[value]);
end;

procedure TFhirRequestGroup.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirRequestGroup.GetIntentST : TFhirRequestIntentEnum;
begin
  if FIntent = nil then
    result := TFhirRequestIntentEnum(0)
  else
    result := TFhirRequestIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestIntentEnum, FIntent.value));
end;

procedure TFhirRequestGroup.SetIntentST(value : TFhirRequestIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirRequestIntentEnum[value], CODES_TFhirRequestIntentEnum[value]);
end;

procedure TFhirRequestGroup.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirRequestGroup.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirRequestGroup.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirRequestGroup.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirRequestGroup.SetSubject(value : TFhirReference);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirRequestGroup.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirRequestGroup.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirRequestGroup.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirRequestGroup.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirRequestGroup.SetAuthor(value : TFhirReference);
begin
  FAuthor.free;
  FAuthor := value;
end;

function TFhirRequestGroup.GetReasonCodeList : TFhirCodeableConceptList;
begin
  if FReasonCodeList = nil then
    FReasonCodeList := TFhirCodeableConceptList.Create;
  result := FReasonCodeList;
end;

function TFhirRequestGroup.GetHasReasonCodeList : boolean;
begin
  result := (FReasonCodeList <> nil) and (FReasonCodeList.count > 0);
end;

function TFhirRequestGroup.GetReasonReferenceList : TFhirReferenceList;
begin
  if FReasonReferenceList = nil then
    FReasonReferenceList := TFhirReferenceList.Create;
  result := FReasonReferenceList;
end;

function TFhirRequestGroup.GetHasReasonReferenceList : boolean;
begin
  result := (FReasonReferenceList <> nil) and (FReasonReferenceList.count > 0);
end;

function TFhirRequestGroup.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirRequestGroup.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirRequestGroup.GetActionList : TFhirRequestGroupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirRequestGroupActionList.Create;
  result := FActionList;
end;

function TFhirRequestGroup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirRequestGroupListEnumerator }

constructor TFhirRequestGroupListEnumerator.Create(list : TFhirRequestGroupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirRequestGroupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirRequestGroupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirRequestGroupListEnumerator.GetCurrent : TFhirRequestGroup;
begin
  Result := FList[FIndex];
end;

function TFhirRequestGroupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirRequestGroupList }

function TFhirRequestGroupList.AddItem(value: TFhirRequestGroup): TFhirRequestGroup;
begin
  assert(value.ClassName = 'TFhirRequestGroup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirRequestGroup');
  add(value);
  result := value;
end;

function TFhirRequestGroupList.Append: TFhirRequestGroup;
begin
  result := TFhirRequestGroup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupList.ClearItems;
begin
  Clear;
end;

function TFhirRequestGroupList.GetEnumerator : TFhirRequestGroupListEnumerator;
begin
  result := TFhirRequestGroupListEnumerator.Create(self.link);
end;

function TFhirRequestGroupList.Clone: TFhirRequestGroupList;
begin
  result := TFhirRequestGroupList(inherited Clone);
end;

function TFhirRequestGroupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirRequestGroupList.GetItemN(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup(ObjectByIndex[index]);
end;

function TFhirRequestGroupList.ItemClass: TFslObjectClass;
begin
  result := TFhirRequestGroup;
end;
function TFhirRequestGroupList.IndexOf(value: TFhirRequestGroup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirRequestGroupList.Insert(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirRequestGroupList.InsertItem(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  Inherited Insert(index, value);
end;

function TFhirRequestGroupList.Item(index: Integer): TFhirRequestGroup;
begin
  result := TFhirRequestGroup(ObjectByIndex[index]);
end;

function TFhirRequestGroupList.Link: TFhirRequestGroupList;
begin
  result := TFhirRequestGroupList(inherited Link);
end;

procedure TFhirRequestGroupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirRequestGroupList.SetItemByIndex(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  FhirRequestGroups[index] := value;
end;

procedure TFhirRequestGroupList.SetItemN(index: Integer; value: TFhirRequestGroup);
begin
  assert(value is TFhirRequestGroup);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_REQUESTGROUP}
{$IFDEF FHIR_RESEARCHDEFINITION}
{ TFhirResearchDefinition }

constructor TFhirResearchDefinition.Create;
begin
  inherited;
end;

destructor TFhirResearchDefinition.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FShortTitle.free;
  FSubtitle.free;
  FStatus.free;
  FExperimental.free;
  FSubject.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FCommentList.Free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FUsage.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FPopulation.free;
  FExposure.free;
  FExposureAlternative.free;
  FOutcome.free;
  inherited;
end;

procedure TFhirResearchDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirResearchDefinition(oSource).urlElement.Clone;
  if (TFhirResearchDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirResearchDefinition(oSource).versionElement.Clone;
  nameElement := TFhirResearchDefinition(oSource).nameElement.Clone;
  titleElement := TFhirResearchDefinition(oSource).titleElement.Clone;
  shortTitleElement := TFhirResearchDefinition(oSource).shortTitleElement.Clone;
  subtitleElement := TFhirResearchDefinition(oSource).subtitleElement.Clone;
  statusElement := TFhirResearchDefinition(oSource).statusElement.Clone;
  experimentalElement := TFhirResearchDefinition(oSource).experimentalElement.Clone;
  subject := TFhirResearchDefinition(oSource).subject.Clone;
  dateElement := TFhirResearchDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirResearchDefinition(oSource).publisherElement.Clone;
  if (TFhirResearchDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirResearchDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirResearchDefinition(oSource).descriptionElement.Clone;
  if (TFhirResearchDefinition(oSource).FCommentList = nil) then
  begin
    FCommentList.free;
    FCommentList := nil;
  end
  else
  begin
    if FCommentList = nil then
      FCommentList := TFhirStringList.Create;
    FCommentList.Assign(TFhirResearchDefinition(oSource).FCommentList);
  end;
  if (TFhirResearchDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirResearchDefinition(oSource).FUseContextList);
  end;
  if (TFhirResearchDefinition(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirResearchDefinition(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirResearchDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirResearchDefinition(oSource).usageElement.Clone;
  copyrightElement := TFhirResearchDefinition(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirResearchDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirResearchDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirResearchDefinition(oSource).effectivePeriod.Clone;
  if (TFhirResearchDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirResearchDefinition(oSource).FTopicList);
  end;
  if (TFhirResearchDefinition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirResearchDefinition(oSource).FAuthorList);
  end;
  if (TFhirResearchDefinition(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirResearchDefinition(oSource).FEditorList);
  end;
  if (TFhirResearchDefinition(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirResearchDefinition(oSource).FReviewerList);
  end;
  if (TFhirResearchDefinition(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirResearchDefinition(oSource).FEndorserList);
  end;
  if (TFhirResearchDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirResearchDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirResearchDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirCanonicalList.Create;
    FLibrary_List.Assign(TFhirResearchDefinition(oSource).FLibrary_List);
  end;
  population := TFhirResearchDefinition(oSource).population.Clone;
  exposure := TFhirResearchDefinition(oSource).exposure.Clone;
  exposureAlternative := TFhirResearchDefinition(oSource).exposureAlternative.Clone;
  outcome := TFhirResearchDefinition(oSource).outcome.Clone;
end;

function TFhirResearchDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtResearchDefinition;
end;

procedure TFhirResearchDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'shortTitle') Then
     list.add(self.link, 'shortTitle', FShortTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'comment') Then
    list.addAll(self, 'comment', FCommentList);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'population') Then
     list.add(self.link, 'population', FPopulation.Link);
  if (child_name = 'exposure') Then
     list.add(self.link, 'exposure', FExposure.Link);
  if (child_name = 'exposureAlternative') Then
     list.add(self.link, 'exposureAlternative', FExposureAlternative.Link);
  if (child_name = 'outcome') Then
     list.add(self.link, 'outcome', FOutcome.Link);
end;

procedure TFhirResearchDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'shortTitle', 'string', false, TFhirString, FShortTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', true, TFhirString, FCommentList.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'library', 'canonical', true, TFhirCanonical, FLibrary_List.Link));
  oList.add(TFHIRProperty.create(self, 'population', 'Reference', false, TFhirReference, FPopulation.Link));
  oList.add(TFHIRProperty.create(self, 'exposure', 'Reference', false, TFhirReference, FExposure.Link));
  oList.add(TFHIRProperty.create(self, 'exposureAlternative', 'Reference', false, TFhirReference, FExposureAlternative.Link));
  oList.add(TFHIRProperty.create(self, 'outcome', 'Reference', false, TFhirReference, FOutcome.Link));
end;

function TFhirResearchDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'shortTitle') then
  begin
    ShortTitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'population') then
  begin
    Population := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'exposure') then
  begin
    Exposure := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'exposureAlternative') then
  begin
    ExposureAlternative := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'outcome') then
  begin
    Outcome := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'comment') then CommentList.insertItem(index, asString(propValue))
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'library') then Library_List.insertItem(index, asCanonical(propValue))
  else inherited;
end;

function TFhirResearchDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'shortTitle') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'comment') then result := CommentList.new()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'topic') then result := TopicList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'library') then result := Library_List.new()
  else if (propName = 'population') then result := TFhirReference.create()
  else if (propName = 'exposure') then result := TFhirReference.create()
  else if (propName = 'exposureAlternative') then result := TFhirReference.create()
  else if (propName = 'outcome') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'shortTitle') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'canonical'
  else if (propName = 'population') then result := 'Reference'
  else if (propName = 'exposure') then result := 'Reference'
  else if (propName = 'exposureAlternative') then result := 'Reference'
  else if (propName = 'outcome') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'shortTitle') then ShortTitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'comment') then deletePropertyValue('comment', CommentList, value)
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value)
  else if (propName = 'population') then PopulationElement := nil
  else if (propName = 'exposure') then ExposureElement := nil
  else if (propName = 'exposureAlternative') then ExposureAlternativeElement := nil
  else if (propName = 'outcome') then OutcomeElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'shortTitle') then ShortTitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'comment') then replacePropertyValue('comment', CommentList, existing, new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new)
  else if (propName = 'population') then PopulationElement := new as TFhirReference
  else if (propName = 'exposure') then ExposureElement := new as TFhirReference
  else if (propName = 'exposureAlternative') then ExposureAlternativeElement := new as TFhirReference
  else if (propName = 'outcome') then OutcomeElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'comment') then CommentList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'topic') then TopicList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'library') then Library_List.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchDefinition.fhirType : string;
begin
  result := 'ResearchDefinition';
end;

function TFhirResearchDefinition.Link : TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition(inherited Link);
end;

function TFhirResearchDefinition.Clone : TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition(inherited Clone);
end;

function TFhirResearchDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirResearchDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchDefinition)) then
    result := false
  else
  begin
    o := TFhirResearchDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(shortTitleElement, o.shortTitleElement, true) and 
      compareDeep(subtitleElement, o.subtitleElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(commentList, o.commentList, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(usageElement, o.usageElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and 
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(topicList, o.topicList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(library_List, o.library_List, true) and 
      compareDeep(populationElement, o.populationElement, true) and compareDeep(exposureElement, o.exposureElement, true) and 
      compareDeep(exposureAlternativeElement, o.exposureAlternativeElement, true) and 
      compareDeep(outcomeElement, o.outcomeElement, true);
  end;
end;

function TFhirResearchDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FShortTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FcommentList) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FPopulation) and isEmptyProp(FExposure) and isEmptyProp(FExposureAlternative)
       and isEmptyProp(FOutcome);
end;

procedure TFhirResearchDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('shortTitle');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('comment');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('population');
  fields.add('exposure');
  fields.add('exposureAlternative');
  fields.add('outcome');
end;

function TFhirResearchDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FCommentList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FTopicList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FLibrary_List.sizeInBytes(magic));
end;

procedure TFhirResearchDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirResearchDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirResearchDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirResearchDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirResearchDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirResearchDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirResearchDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirResearchDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirResearchDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirResearchDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirResearchDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirResearchDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirResearchDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirResearchDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirResearchDefinition.SetShortTitle(value : TFhirString);
begin
  FShortTitle.free;
  FShortTitle := value;
end;

function TFhirResearchDefinition.GetShortTitleST : String;
begin
  if FShortTitle = nil then
    result := ''
  else
    result := FShortTitle.value;
end;

procedure TFhirResearchDefinition.SetShortTitleST(value : String);
begin
  if value <> '' then
  begin
    if FShortTitle = nil then
      FShortTitle := TFhirString.create;
    FShortTitle.value := value
  end
  else if FShortTitle <> nil then
    FShortTitle.value := '';
end;

procedure TFhirResearchDefinition.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirResearchDefinition.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirResearchDefinition.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirResearchDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirResearchDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirResearchDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirResearchDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirResearchDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirResearchDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirResearchDefinition.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirResearchDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirResearchDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirResearchDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirResearchDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirResearchDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirResearchDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirResearchDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirResearchDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirResearchDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirResearchDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirResearchDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirResearchDefinition.GetCommentList : TFhirStringList;
begin
  if FCommentList = nil then
    FCommentList := TFhirStringList.Create;
  result := FCommentList;
end;

function TFhirResearchDefinition.GetHasCommentList : boolean;
begin
  result := (FCommentList <> nil) and (FCommentList.count > 0);
end;

function TFhirResearchDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirResearchDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirResearchDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirResearchDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirResearchDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirResearchDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirResearchDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirResearchDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirResearchDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirResearchDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

procedure TFhirResearchDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirResearchDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirResearchDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirResearchDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirResearchDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirResearchDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirResearchDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirResearchDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirResearchDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirResearchDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirResearchDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

function TFhirResearchDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

function TFhirResearchDefinition.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirResearchDefinition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirResearchDefinition.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirResearchDefinition.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirResearchDefinition.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirResearchDefinition.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirResearchDefinition.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirResearchDefinition.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirResearchDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirResearchDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirResearchDefinition.GetLibrary_List : TFhirCanonicalList;
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirCanonicalList.Create;
  result := FLibrary_List;
end;

function TFhirResearchDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

procedure TFhirResearchDefinition.SetPopulation(value : TFhirReference);
begin
  FPopulation.free;
  FPopulation := value;
end;

procedure TFhirResearchDefinition.SetExposure(value : TFhirReference);
begin
  FExposure.free;
  FExposure := value;
end;

procedure TFhirResearchDefinition.SetExposureAlternative(value : TFhirReference);
begin
  FExposureAlternative.free;
  FExposureAlternative := value;
end;

procedure TFhirResearchDefinition.SetOutcome(value : TFhirReference);
begin
  FOutcome.free;
  FOutcome := value;
end;

{ TFhirResearchDefinitionListEnumerator }

constructor TFhirResearchDefinitionListEnumerator.Create(list : TFhirResearchDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchDefinitionListEnumerator.GetCurrent : TFhirResearchDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirResearchDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchDefinitionList }

function TFhirResearchDefinitionList.AddItem(value: TFhirResearchDefinition): TFhirResearchDefinition;
begin
  assert(value.ClassName = 'TFhirResearchDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchDefinition');
  add(value);
  result := value;
end;

function TFhirResearchDefinitionList.Append: TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirResearchDefinitionList.GetEnumerator : TFhirResearchDefinitionListEnumerator;
begin
  result := TFhirResearchDefinitionListEnumerator.Create(self.link);
end;

function TFhirResearchDefinitionList.Clone: TFhirResearchDefinitionList;
begin
  result := TFhirResearchDefinitionList(inherited Clone);
end;

function TFhirResearchDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchDefinitionList.GetItemN(index: Integer): TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition(ObjectByIndex[index]);
end;

function TFhirResearchDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchDefinition;
end;
function TFhirResearchDefinitionList.IndexOf(value: TFhirResearchDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchDefinitionList.Insert(index: Integer): TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchDefinitionList.InsertItem(index: Integer; value: TFhirResearchDefinition);
begin
  assert(value is TFhirResearchDefinition);
  Inherited Insert(index, value);
end;

function TFhirResearchDefinitionList.Item(index: Integer): TFhirResearchDefinition;
begin
  result := TFhirResearchDefinition(ObjectByIndex[index]);
end;

function TFhirResearchDefinitionList.Link: TFhirResearchDefinitionList;
begin
  result := TFhirResearchDefinitionList(inherited Link);
end;

procedure TFhirResearchDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchDefinitionList.SetItemByIndex(index: Integer; value: TFhirResearchDefinition);
begin
  assert(value is TFhirResearchDefinition);
  FhirResearchDefinitions[index] := value;
end;

procedure TFhirResearchDefinitionList.SetItemN(index: Integer; value: TFhirResearchDefinition);
begin
  assert(value is TFhirResearchDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHDEFINITION}
{$IFDEF FHIR_RESEARCHELEMENTDEFINITION}
{ TFhirResearchElementDefinitionCharacteristic }

constructor TFhirResearchElementDefinitionCharacteristic.Create;
begin
  inherited;
end;

destructor TFhirResearchElementDefinitionCharacteristic.Destroy;
begin
  FDefinition.free;
  FUsageContextList.Free;
  FExclude.free;
  FUnitOfMeasure.free;
  FStudyEffectiveDescription.free;
  FStudyEffective.free;
  FStudyEffectiveTimeFromStart.free;
  FStudyEffectiveGroupMeasure.free;
  FParticipantEffectiveDescription.free;
  FParticipantEffective.free;
  FParticipantEffectiveTimeFromStart.free;
  FParticipantEffectiveGroupMeasure.free;
  inherited;
end;

procedure TFhirResearchElementDefinitionCharacteristic.Assign(oSource : TFslObject);
begin
  inherited;
  definition := TFhirResearchElementDefinitionCharacteristic(oSource).definition.Clone;
  if (TFhirResearchElementDefinitionCharacteristic(oSource).FUsageContextList = nil) then
  begin
    FUsageContextList.free;
    FUsageContextList := nil;
  end
  else
  begin
    if FUsageContextList = nil then
      FUsageContextList := TFhirUsageContextList.Create;
    FUsageContextList.Assign(TFhirResearchElementDefinitionCharacteristic(oSource).FUsageContextList);
  end;
  excludeElement := TFhirResearchElementDefinitionCharacteristic(oSource).excludeElement.Clone;
  unitOfMeasure := TFhirResearchElementDefinitionCharacteristic(oSource).unitOfMeasure.Clone;
  studyEffectiveDescriptionElement := TFhirResearchElementDefinitionCharacteristic(oSource).studyEffectiveDescriptionElement.Clone;
  studyEffective := TFhirResearchElementDefinitionCharacteristic(oSource).studyEffective.Clone;
  studyEffectiveTimeFromStart := TFhirResearchElementDefinitionCharacteristic(oSource).studyEffectiveTimeFromStart.Clone;
  studyEffectiveGroupMeasureElement := TFhirResearchElementDefinitionCharacteristic(oSource).studyEffectiveGroupMeasureElement.Clone;
  participantEffectiveDescriptionElement := TFhirResearchElementDefinitionCharacteristic(oSource).participantEffectiveDescriptionElement.Clone;
  participantEffective := TFhirResearchElementDefinitionCharacteristic(oSource).participantEffective.Clone;
  participantEffectiveTimeFromStart := TFhirResearchElementDefinitionCharacteristic(oSource).participantEffectiveTimeFromStart.Clone;
  participantEffectiveGroupMeasureElement := TFhirResearchElementDefinitionCharacteristic(oSource).participantEffectiveGroupMeasureElement.Clone;
end;

procedure TFhirResearchElementDefinitionCharacteristic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'definition[x]') or (child_name = 'definition') Then
     list.add(self.link, 'definition[x]', FDefinition.Link);
  if (child_name = 'usageContext') Then
    list.addAll(self, 'usageContext', FUsageContextList);
  if (child_name = 'exclude') Then
     list.add(self.link, 'exclude', FExclude.Link);
  if (child_name = 'unitOfMeasure') Then
     list.add(self.link, 'unitOfMeasure', FUnitOfMeasure.Link);
  if (child_name = 'studyEffectiveDescription') Then
     list.add(self.link, 'studyEffectiveDescription', FStudyEffectiveDescription.Link);
  if (child_name = 'studyEffective[x]') or (child_name = 'studyEffective') Then
     list.add(self.link, 'studyEffective[x]', FStudyEffective.Link);
  if (child_name = 'studyEffectiveTimeFromStart') Then
     list.add(self.link, 'studyEffectiveTimeFromStart', FStudyEffectiveTimeFromStart.Link);
  if (child_name = 'studyEffectiveGroupMeasure') Then
     list.add(self.link, 'studyEffectiveGroupMeasure', FStudyEffectiveGroupMeasure.Link);
  if (child_name = 'participantEffectiveDescription') Then
     list.add(self.link, 'participantEffectiveDescription', FParticipantEffectiveDescription.Link);
  if (child_name = 'participantEffective[x]') or (child_name = 'participantEffective') Then
     list.add(self.link, 'participantEffective[x]', FParticipantEffective.Link);
  if (child_name = 'participantEffectiveTimeFromStart') Then
     list.add(self.link, 'participantEffectiveTimeFromStart', FParticipantEffectiveTimeFromStart.Link);
  if (child_name = 'participantEffectiveGroupMeasure') Then
     list.add(self.link, 'participantEffectiveGroupMeasure', FParticipantEffectiveGroupMeasure.Link);
end;

procedure TFhirResearchElementDefinitionCharacteristic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'definition[x]', 'CodeableConcept|canonical|Expression|DataRequirement', false, TFhirDataType, FDefinition.Link));
  oList.add(TFHIRProperty.create(self, 'usageContext', 'UsageContext', true, TFhirUsageContext, FUsageContextList.Link));
  oList.add(TFHIRProperty.create(self, 'exclude', 'boolean', false, TFhirBoolean, FExclude.Link));
  oList.add(TFHIRProperty.create(self, 'unitOfMeasure', 'CodeableConcept', false, TFhirCodeableConcept, FUnitOfMeasure.Link));
  oList.add(TFHIRProperty.create(self, 'studyEffectiveDescription', 'string', false, TFhirString, FStudyEffectiveDescription.Link));
  oList.add(TFHIRProperty.create(self, 'studyEffective[x]', 'dateTime|Period|Duration|Timing', false, TFhirDataType, FStudyEffective.Link));
  oList.add(TFHIRProperty.create(self, 'studyEffectiveTimeFromStart', 'Duration', false, TFhirDuration, FStudyEffectiveTimeFromStart.Link));
  oList.add(TFHIRProperty.create(self, 'studyEffectiveGroupMeasure', 'code', false, TFhirEnum, FStudyEffectiveGroupMeasure.Link));
  oList.add(TFHIRProperty.create(self, 'participantEffectiveDescription', 'string', false, TFhirString, FParticipantEffectiveDescription.Link));
  oList.add(TFHIRProperty.create(self, 'participantEffective[x]', 'dateTime|Period|Duration|Timing', false, TFhirDataType, FParticipantEffective.Link));
  oList.add(TFHIRProperty.create(self, 'participantEffectiveTimeFromStart', 'Duration', false, TFhirDuration, FParticipantEffectiveTimeFromStart.Link));
  oList.add(TFHIRProperty.create(self, 'participantEffectiveGroupMeasure', 'code', false, TFhirEnum, FParticipantEffectiveGroupMeasure.Link));
end;

function TFhirResearchElementDefinitionCharacteristic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (isMatchingName(propName, 'definition', ['CodeableConcept', 'Canonical', 'Expression', 'DataRequirement'])) then
  begin
    Definition := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'usageContext') then
  begin
    UsageContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'exclude') then
  begin
    ExcludeElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'unitOfMeasure') then
  begin
    UnitOfMeasure := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'studyEffectiveDescription') then
  begin
    StudyEffectiveDescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'studyEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then
  begin
    StudyEffective := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'studyEffectiveTimeFromStart') then
  begin
    StudyEffectiveTimeFromStart := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'studyEffectiveGroupMeasure') then
  begin
    StudyEffectiveGroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, propValue);
    result := propValue;
  end
  else if (propName = 'participantEffectiveDescription') then
  begin
    ParticipantEffectiveDescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then
  begin
    ParticipantEffective := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'participantEffectiveTimeFromStart') then
  begin
    ParticipantEffectiveTimeFromStart := propValue as TFhirDuration;
    result := propValue;
  end
  else if (propName = 'participantEffectiveGroupMeasure') then
  begin
    ParticipantEffectiveGroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchElementDefinitionCharacteristic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'usageContext') then UsageContextList.insertItem(index, propValue as TFhirUsageContext)
  else inherited;
end;

function TFhirResearchElementDefinitionCharacteristic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (isMatchingName(propName, 'definition', ['CodeableConcept', 'Canonical', 'Expression', 'DataRequirement'])) then raise EFHIRException.create('Cannot make property Definition')
  else if (propName = 'usageContext') then result := UsageContextList.new()
  else if (propName = 'exclude') then result := TFhirBoolean.create()
  else if (propName = 'unitOfMeasure') then result := TFhirCodeableConcept.create()
  else if (propName = 'studyEffectiveDescription') then result := TFhirString.create()
  else if (isMatchingName(propName, 'studyEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then raise EFHIRException.create('Cannot make property StudyEffective')
  else if (propName = 'studyEffectiveTimeFromStart') then result := TFhirDuration.create()
  else if (propName = 'studyEffectiveGroupMeasure') then result := TFhirEnum.create(SYSTEMS_TFhirGroupMeasureEnum[GroupMeasureNull], CODES_TFhirGroupMeasureEnum[GroupMeasureNull]) 
  else if (propName = 'participantEffectiveDescription') then result := TFhirString.create()
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then raise EFHIRException.create('Cannot make property ParticipantEffective')
  else if (propName = 'participantEffectiveTimeFromStart') then result := TFhirDuration.create()
  else if (propName = 'participantEffectiveGroupMeasure') then result := TFhirEnum.create(SYSTEMS_TFhirGroupMeasureEnum[GroupMeasureNull], CODES_TFhirGroupMeasureEnum[GroupMeasureNull]) 
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchElementDefinitionCharacteristic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'definition[x]') then result := 'CodeableConcept|canonical|Expression|DataRequirement'
  else if (propName = 'usageContext') then result := 'UsageContext'
  else if (propName = 'exclude') then result := 'boolean'
  else if (propName = 'unitOfMeasure') then result := 'CodeableConcept'
  else if (propName = 'studyEffectiveDescription') then result := 'string'
  else if (propName = 'studyEffective[x]') then result := 'dateTime|Period|Duration|Timing'
  else if (propName = 'studyEffectiveTimeFromStart') then result := 'Duration'
  else if (propName = 'studyEffectiveGroupMeasure') then result := 'code'
  else if (propName = 'participantEffectiveDescription') then result := 'string'
  else if (propName = 'participantEffective[x]') then result := 'dateTime|Period|Duration|Timing'
  else if (propName = 'participantEffectiveTimeFromStart') then result := 'Duration'
  else if (propName = 'participantEffectiveGroupMeasure') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchElementDefinitionCharacteristic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (isMatchingName(propName, 'definition', ['CodeableConcept', 'Canonical', 'Expression', 'DataRequirement'])) then DefinitionElement := nil
  else if (propName = 'usageContext') then deletePropertyValue('usageContext', UsageContextList, value)
  else if (propName = 'exclude') then ExcludeElement := nil
  else if (propName = 'unitOfMeasure') then UnitOfMeasureElement := nil
  else if (propName = 'studyEffectiveDescription') then StudyEffectiveDescriptionElement := nil
  else if (isMatchingName(propName, 'studyEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then StudyEffectiveElement := nil
  else if (propName = 'studyEffectiveTimeFromStart') then StudyEffectiveTimeFromStartElement := nil
  else if (propName = 'studyEffectiveGroupMeasure') then StudyEffectiveGroupMeasureElement := nil
  else if (propName = 'participantEffectiveDescription') then ParticipantEffectiveDescriptionElement := nil
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then ParticipantEffectiveElement := nil
  else if (propName = 'participantEffectiveTimeFromStart') then ParticipantEffectiveTimeFromStartElement := nil
  else if (propName = 'participantEffectiveGroupMeasure') then ParticipantEffectiveGroupMeasureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchElementDefinitionCharacteristic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (isMatchingName(propName, 'definition', ['CodeableConcept', 'Canonical', 'Expression', 'DataRequirement'])) then DefinitionElement := new as TFhirDataType
  else if (propName = 'usageContext') then replacePropertyValue('usageContext', UsageContextList, existing, new)
  else if (propName = 'exclude') then ExcludeElement := asBoolean(new)
  else if (propName = 'unitOfMeasure') then UnitOfMeasureElement := new as TFhirCodeableConcept
  else if (propName = 'studyEffectiveDescription') then StudyEffectiveDescriptionElement := asString(new)
  else if (isMatchingName(propName, 'studyEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then StudyEffectiveElement := new as TFhirDataType
  else if (propName = 'studyEffectiveTimeFromStart') then StudyEffectiveTimeFromStartElement := new as TFhirDuration
  else if (propName = 'studyEffectiveGroupMeasure') then StudyEffectiveGroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, new)
  else if (propName = 'participantEffectiveDescription') then ParticipantEffectiveDescriptionElement := asString(new)
  else if (isMatchingName(propName, 'participantEffective', ['DateTime', 'Period', 'Duration', 'Timing'])) then ParticipantEffectiveElement := new as TFhirDataType
  else if (propName = 'participantEffectiveTimeFromStart') then ParticipantEffectiveTimeFromStartElement := new as TFhirDuration
  else if (propName = 'participantEffectiveGroupMeasure') then ParticipantEffectiveGroupMeasureElement := asEnum(SYSTEMS_TFhirGroupMeasureEnum, CODES_TFhirGroupMeasureEnum, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchElementDefinitionCharacteristic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'usageContext') then UsageContextList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchElementDefinitionCharacteristic.fhirType : string;
begin
  result := 'ResearchElementDefinition.characteristic';
end;

function TFhirResearchElementDefinitionCharacteristic.Link : TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic(inherited Link);
end;

function TFhirResearchElementDefinitionCharacteristic.Clone : TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic(inherited Clone);
end;

function TFhirResearchElementDefinitionCharacteristic.equals(other : TObject) : boolean; 
var
  o : TFhirResearchElementDefinitionCharacteristic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchElementDefinitionCharacteristic)) then
    result := false
  else
  begin
    o := TFhirResearchElementDefinitionCharacteristic(other);
    result := compareDeep(definitionElement, o.definitionElement, true) and compareDeep(usageContextList, o.usageContextList, true) and 
      compareDeep(excludeElement, o.excludeElement, true) and compareDeep(unitOfMeasureElement, o.unitOfMeasureElement, true) and 
      compareDeep(studyEffectiveDescriptionElement, o.studyEffectiveDescriptionElement, true) and 
      compareDeep(studyEffectiveElement, o.studyEffectiveElement, true) and compareDeep(studyEffectiveTimeFromStartElement, o.studyEffectiveTimeFromStartElement, true) and 
      compareDeep(studyEffectiveGroupMeasureElement, o.studyEffectiveGroupMeasureElement, true) and 
      compareDeep(participantEffectiveDescriptionElement, o.participantEffectiveDescriptionElement, true) and 
      compareDeep(participantEffectiveElement, o.participantEffectiveElement, true) and 
      compareDeep(participantEffectiveTimeFromStartElement, o.participantEffectiveTimeFromStartElement, true) and 
      compareDeep(participantEffectiveGroupMeasureElement, o.participantEffectiveGroupMeasureElement, true);
  end;
end;

function TFhirResearchElementDefinitionCharacteristic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDefinition) and isEmptyProp(FusageContextList) and isEmptyProp(FExclude) and isEmptyProp(FUnitOfMeasure) and isEmptyProp(FStudyEffectiveDescription) and isEmptyProp(FStudyEffective) and isEmptyProp(FStudyEffectiveTimeFromStart) and isEmptyProp(FStudyEffectiveGroupMeasure) and isEmptyProp(FParticipantEffectiveDescription) and isEmptyProp(FParticipantEffective) and isEmptyProp(FParticipantEffectiveTimeFromStart) and isEmptyProp(FParticipantEffectiveGroupMeasure);
end;

procedure TFhirResearchElementDefinitionCharacteristic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('definition[x]');
  fields.add('usageContext');
  fields.add('exclude');
  fields.add('unitOfMeasure');
  fields.add('studyEffectiveDescription');
  fields.add('studyEffective[x]');
  fields.add('studyEffectiveTimeFromStart');
  fields.add('studyEffectiveGroupMeasure');
  fields.add('participantEffectiveDescription');
  fields.add('participantEffective[x]');
  fields.add('participantEffectiveTimeFromStart');
  fields.add('participantEffectiveGroupMeasure');
end;

function TFhirResearchElementDefinitionCharacteristic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FUsageContextList.sizeInBytes(magic));
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetDefinition(value : TFhirDataType);
begin
  FDefinition.free;
  FDefinition := value;
end;

function TFhirResearchElementDefinitionCharacteristic.GetUsageContextList : TFhirUsageContextList;
begin
  if FUsageContextList = nil then
    FUsageContextList := TFhirUsageContextList.Create;
  result := FUsageContextList;
end;

function TFhirResearchElementDefinitionCharacteristic.GetHasUsageContextList : boolean;
begin
  result := (FUsageContextList <> nil) and (FUsageContextList.count > 0);
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetExclude(value : TFhirBoolean);
begin
  FExclude.free;
  FExclude := value;
end;

function TFhirResearchElementDefinitionCharacteristic.GetExcludeST : Boolean;
begin
  if FExclude = nil then
    result := false
  else
    result := FExclude.value;
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetExcludeST(value : Boolean);
begin
  if FExclude = nil then
    FExclude := TFhirBoolean.create;
  FExclude.value := value
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetUnitOfMeasure(value : TFhirCodeableConcept);
begin
  FUnitOfMeasure.free;
  FUnitOfMeasure := value;
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveDescription(value : TFhirString);
begin
  FStudyEffectiveDescription.free;
  FStudyEffectiveDescription := value;
end;

function TFhirResearchElementDefinitionCharacteristic.GetStudyEffectiveDescriptionST : String;
begin
  if FStudyEffectiveDescription = nil then
    result := ''
  else
    result := FStudyEffectiveDescription.value;
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FStudyEffectiveDescription = nil then
      FStudyEffectiveDescription := TFhirString.create;
    FStudyEffectiveDescription.value := value
  end
  else if FStudyEffectiveDescription <> nil then
    FStudyEffectiveDescription.value := '';
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffective(value : TFhirDataType);
begin
  FStudyEffective.free;
  FStudyEffective := value;
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveTimeFromStart(value : TFhirDuration);
begin
  FStudyEffectiveTimeFromStart.free;
  FStudyEffectiveTimeFromStart := value;
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveGroupMeasure(value : TFhirEnum);
begin
  FStudyEffectiveGroupMeasure.free;
  FStudyEffectiveGroupMeasure := value;
end;

function TFhirResearchElementDefinitionCharacteristic.GetStudyEffectiveGroupMeasureST : TFhirGroupMeasureEnum;
begin
  if FStudyEffectiveGroupMeasure = nil then
    result := TFhirGroupMeasureEnum(0)
  else
    result := TFhirGroupMeasureEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupMeasureEnum, FStudyEffectiveGroupMeasure.value));
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetStudyEffectiveGroupMeasureST(value : TFhirGroupMeasureEnum);
begin
  if ord(value) = 0 then
    StudyEffectiveGroupMeasureElement := nil
  else
    StudyEffectiveGroupMeasureElement := TFhirEnum.create(SYSTEMS_TFhirGroupMeasureEnum[value], CODES_TFhirGroupMeasureEnum[value]);
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveDescription(value : TFhirString);
begin
  FParticipantEffectiveDescription.free;
  FParticipantEffectiveDescription := value;
end;

function TFhirResearchElementDefinitionCharacteristic.GetParticipantEffectiveDescriptionST : String;
begin
  if FParticipantEffectiveDescription = nil then
    result := ''
  else
    result := FParticipantEffectiveDescription.value;
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FParticipantEffectiveDescription = nil then
      FParticipantEffectiveDescription := TFhirString.create;
    FParticipantEffectiveDescription.value := value
  end
  else if FParticipantEffectiveDescription <> nil then
    FParticipantEffectiveDescription.value := '';
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffective(value : TFhirDataType);
begin
  FParticipantEffective.free;
  FParticipantEffective := value;
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveTimeFromStart(value : TFhirDuration);
begin
  FParticipantEffectiveTimeFromStart.free;
  FParticipantEffectiveTimeFromStart := value;
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveGroupMeasure(value : TFhirEnum);
begin
  FParticipantEffectiveGroupMeasure.free;
  FParticipantEffectiveGroupMeasure := value;
end;

function TFhirResearchElementDefinitionCharacteristic.GetParticipantEffectiveGroupMeasureST : TFhirGroupMeasureEnum;
begin
  if FParticipantEffectiveGroupMeasure = nil then
    result := TFhirGroupMeasureEnum(0)
  else
    result := TFhirGroupMeasureEnum(StringArrayIndexOfSensitive(CODES_TFhirGroupMeasureEnum, FParticipantEffectiveGroupMeasure.value));
end;

procedure TFhirResearchElementDefinitionCharacteristic.SetParticipantEffectiveGroupMeasureST(value : TFhirGroupMeasureEnum);
begin
  if ord(value) = 0 then
    ParticipantEffectiveGroupMeasureElement := nil
  else
    ParticipantEffectiveGroupMeasureElement := TFhirEnum.create(SYSTEMS_TFhirGroupMeasureEnum[value], CODES_TFhirGroupMeasureEnum[value]);
end;

{ TFhirResearchElementDefinitionCharacteristicListEnumerator }

constructor TFhirResearchElementDefinitionCharacteristicListEnumerator.Create(list : TFhirResearchElementDefinitionCharacteristicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchElementDefinitionCharacteristicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchElementDefinitionCharacteristicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchElementDefinitionCharacteristicListEnumerator.GetCurrent : TFhirResearchElementDefinitionCharacteristic;
begin
  Result := FList[FIndex];
end;

function TFhirResearchElementDefinitionCharacteristicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchElementDefinitionCharacteristicList }

function TFhirResearchElementDefinitionCharacteristicList.AddItem(value: TFhirResearchElementDefinitionCharacteristic): TFhirResearchElementDefinitionCharacteristic;
begin
  assert(value.ClassName = 'TFhirResearchElementDefinitionCharacteristic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchElementDefinitionCharacteristic');
  add(value);
  result := value;
end;

function TFhirResearchElementDefinitionCharacteristicList.Append: TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchElementDefinitionCharacteristicList.ClearItems;
begin
  Clear;
end;

function TFhirResearchElementDefinitionCharacteristicList.GetEnumerator : TFhirResearchElementDefinitionCharacteristicListEnumerator;
begin
  result := TFhirResearchElementDefinitionCharacteristicListEnumerator.Create(self.link);
end;

function TFhirResearchElementDefinitionCharacteristicList.Clone: TFhirResearchElementDefinitionCharacteristicList;
begin
  result := TFhirResearchElementDefinitionCharacteristicList(inherited Clone);
end;

function TFhirResearchElementDefinitionCharacteristicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchElementDefinitionCharacteristicList.GetItemN(index: Integer): TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic(ObjectByIndex[index]);
end;

function TFhirResearchElementDefinitionCharacteristicList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchElementDefinitionCharacteristic;
end;
function TFhirResearchElementDefinitionCharacteristicList.IndexOf(value: TFhirResearchElementDefinitionCharacteristic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchElementDefinitionCharacteristicList.Insert(index: Integer): TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchElementDefinitionCharacteristicList.InsertItem(index: Integer; value: TFhirResearchElementDefinitionCharacteristic);
begin
  assert(value is TFhirResearchElementDefinitionCharacteristic);
  Inherited Insert(index, value);
end;

function TFhirResearchElementDefinitionCharacteristicList.Item(index: Integer): TFhirResearchElementDefinitionCharacteristic;
begin
  result := TFhirResearchElementDefinitionCharacteristic(ObjectByIndex[index]);
end;

function TFhirResearchElementDefinitionCharacteristicList.Link: TFhirResearchElementDefinitionCharacteristicList;
begin
  result := TFhirResearchElementDefinitionCharacteristicList(inherited Link);
end;

procedure TFhirResearchElementDefinitionCharacteristicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchElementDefinitionCharacteristicList.SetItemByIndex(index: Integer; value: TFhirResearchElementDefinitionCharacteristic);
begin
  assert(value is TFhirResearchElementDefinitionCharacteristic);
  FhirResearchElementDefinitionCharacteristics[index] := value;
end;

procedure TFhirResearchElementDefinitionCharacteristicList.SetItemN(index: Integer; value: TFhirResearchElementDefinitionCharacteristic);
begin
  assert(value is TFhirResearchElementDefinitionCharacteristic);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchElementDefinition }

constructor TFhirResearchElementDefinition.Create;
begin
  inherited;
end;

destructor TFhirResearchElementDefinition.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FName.free;
  FTitle.free;
  FShortTitle.free;
  FSubtitle.free;
  FStatus.free;
  FExperimental.free;
  FSubject.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FCommentList.Free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FUsage.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FTopicList.Free;
  FAuthorList.Free;
  FEditorList.Free;
  FReviewerList.Free;
  FEndorserList.Free;
  FRelatedArtifactList.Free;
  FLibrary_List.Free;
  FType_.free;
  FVariableType.free;
  FCharacteristicList.Free;
  inherited;
end;

procedure TFhirResearchElementDefinition.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirResearchElementDefinition(oSource).urlElement.Clone;
  if (TFhirResearchElementDefinition(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchElementDefinition(oSource).FIdentifierList);
  end;
  versionElement := TFhirResearchElementDefinition(oSource).versionElement.Clone;
  nameElement := TFhirResearchElementDefinition(oSource).nameElement.Clone;
  titleElement := TFhirResearchElementDefinition(oSource).titleElement.Clone;
  shortTitleElement := TFhirResearchElementDefinition(oSource).shortTitleElement.Clone;
  subtitleElement := TFhirResearchElementDefinition(oSource).subtitleElement.Clone;
  statusElement := TFhirResearchElementDefinition(oSource).statusElement.Clone;
  experimentalElement := TFhirResearchElementDefinition(oSource).experimentalElement.Clone;
  subject := TFhirResearchElementDefinition(oSource).subject.Clone;
  dateElement := TFhirResearchElementDefinition(oSource).dateElement.Clone;
  publisherElement := TFhirResearchElementDefinition(oSource).publisherElement.Clone;
  if (TFhirResearchElementDefinition(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirResearchElementDefinition(oSource).FContactList);
  end;
  descriptionElement := TFhirResearchElementDefinition(oSource).descriptionElement.Clone;
  if (TFhirResearchElementDefinition(oSource).FCommentList = nil) then
  begin
    FCommentList.free;
    FCommentList := nil;
  end
  else
  begin
    if FCommentList = nil then
      FCommentList := TFhirStringList.Create;
    FCommentList.Assign(TFhirResearchElementDefinition(oSource).FCommentList);
  end;
  if (TFhirResearchElementDefinition(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirResearchElementDefinition(oSource).FUseContextList);
  end;
  if (TFhirResearchElementDefinition(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirResearchElementDefinition(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirResearchElementDefinition(oSource).purposeElement.Clone;
  usageElement := TFhirResearchElementDefinition(oSource).usageElement.Clone;
  copyrightElement := TFhirResearchElementDefinition(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirResearchElementDefinition(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirResearchElementDefinition(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirResearchElementDefinition(oSource).effectivePeriod.Clone;
  if (TFhirResearchElementDefinition(oSource).FTopicList = nil) then
  begin
    FTopicList.free;
    FTopicList := nil;
  end
  else
  begin
    if FTopicList = nil then
      FTopicList := TFhirCodeableConceptList.Create;
    FTopicList.Assign(TFhirResearchElementDefinition(oSource).FTopicList);
  end;
  if (TFhirResearchElementDefinition(oSource).FAuthorList = nil) then
  begin
    FAuthorList.free;
    FAuthorList := nil;
  end
  else
  begin
    if FAuthorList = nil then
      FAuthorList := TFhirContactDetailList.Create;
    FAuthorList.Assign(TFhirResearchElementDefinition(oSource).FAuthorList);
  end;
  if (TFhirResearchElementDefinition(oSource).FEditorList = nil) then
  begin
    FEditorList.free;
    FEditorList := nil;
  end
  else
  begin
    if FEditorList = nil then
      FEditorList := TFhirContactDetailList.Create;
    FEditorList.Assign(TFhirResearchElementDefinition(oSource).FEditorList);
  end;
  if (TFhirResearchElementDefinition(oSource).FReviewerList = nil) then
  begin
    FReviewerList.free;
    FReviewerList := nil;
  end
  else
  begin
    if FReviewerList = nil then
      FReviewerList := TFhirContactDetailList.Create;
    FReviewerList.Assign(TFhirResearchElementDefinition(oSource).FReviewerList);
  end;
  if (TFhirResearchElementDefinition(oSource).FEndorserList = nil) then
  begin
    FEndorserList.free;
    FEndorserList := nil;
  end
  else
  begin
    if FEndorserList = nil then
      FEndorserList := TFhirContactDetailList.Create;
    FEndorserList.Assign(TFhirResearchElementDefinition(oSource).FEndorserList);
  end;
  if (TFhirResearchElementDefinition(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirResearchElementDefinition(oSource).FRelatedArtifactList);
  end;
  if (TFhirResearchElementDefinition(oSource).FLibrary_List = nil) then
  begin
    FLibrary_List.free;
    FLibrary_List := nil;
  end
  else
  begin
    if FLibrary_List = nil then
      FLibrary_List := TFhirCanonicalList.Create;
    FLibrary_List.Assign(TFhirResearchElementDefinition(oSource).FLibrary_List);
  end;
  type_Element := TFhirResearchElementDefinition(oSource).type_Element.Clone;
  variableTypeElement := TFhirResearchElementDefinition(oSource).variableTypeElement.Clone;
  if (TFhirResearchElementDefinition(oSource).FCharacteristicList = nil) then
  begin
    FCharacteristicList.free;
    FCharacteristicList := nil;
  end
  else
  begin
    if FCharacteristicList = nil then
      FCharacteristicList := TFhirResearchElementDefinitionCharacteristicList.Create;
    FCharacteristicList.Assign(TFhirResearchElementDefinition(oSource).FCharacteristicList);
  end;
end;

function TFhirResearchElementDefinition.GetResourceType : TFhirResourceType;
begin
  result := frtResearchElementDefinition;
end;

procedure TFhirResearchElementDefinition.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'shortTitle') Then
     list.add(self.link, 'shortTitle', FShortTitle.Link);
  if (child_name = 'subtitle') Then
     list.add(self.link, 'subtitle', FSubtitle.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'subject[x]') or (child_name = 'subject') Then
     list.add(self.link, 'subject[x]', FSubject.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'comment') Then
    list.addAll(self, 'comment', FCommentList);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'usage') Then
     list.add(self.link, 'usage', FUsage.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'topic') Then
    list.addAll(self, 'topic', FTopicList);
  if (child_name = 'author') Then
    list.addAll(self, 'author', FAuthorList);
  if (child_name = 'editor') Then
    list.addAll(self, 'editor', FEditorList);
  if (child_name = 'reviewer') Then
    list.addAll(self, 'reviewer', FReviewerList);
  if (child_name = 'endorser') Then
    list.addAll(self, 'endorser', FEndorserList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'library') Then
    list.addAll(self, 'library', FLibrary_List);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'variableType') Then
     list.add(self.link, 'variableType', FVariableType.Link);
  if (child_name = 'characteristic') Then
    list.addAll(self, 'characteristic', FCharacteristicList);
end;

procedure TFhirResearchElementDefinition.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'shortTitle', 'string', false, TFhirString, FShortTitle.Link));
  oList.add(TFHIRProperty.create(self, 'subtitle', 'string', false, TFhirString, FSubtitle.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'subject[x]', 'CodeableConcept|Reference', false, TFhirDataType, FSubject.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'comment', 'string', true, TFhirString, FCommentList.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'usage', 'string', false, TFhirString, FUsage.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'CodeableConcept', true, TFhirCodeableConcept, FTopicList.Link));
  oList.add(TFHIRProperty.create(self, 'author', 'ContactDetail', true, TFhirContactDetail, FAuthorList.Link));
  oList.add(TFHIRProperty.create(self, 'editor', 'ContactDetail', true, TFhirContactDetail, FEditorList.Link));
  oList.add(TFHIRProperty.create(self, 'reviewer', 'ContactDetail', true, TFhirContactDetail, FReviewerList.Link));
  oList.add(TFHIRProperty.create(self, 'endorser', 'ContactDetail', true, TFhirContactDetail, FEndorserList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'library', 'canonical', true, TFhirCanonical, FLibrary_List.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'variableType', 'code', false, TFhirEnum, FVariableType.Link));
  oList.add(TFHIRProperty.create(self, 'characteristic', 'BackboneElement', true, TFhirResearchElementDefinitionCharacteristic, FCharacteristicList.Link));
end;

function TFhirResearchElementDefinition.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'shortTitle') then
  begin
    ShortTitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'subtitle') then
  begin
    SubtitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then
  begin
    Subject := propValue as TFhirDataType;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'comment') then
  begin
    CommentList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'usage') then
  begin
    UsageElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'author') then
  begin
    AuthorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'editor') then
  begin
    EditorList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'reviewer') then
  begin
    ReviewerList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'endorser') then
  begin
    EndorserList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'library') then
  begin
    Library_List.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirResearchElementTypeEnum, CODES_TFhirResearchElementTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'variableType') then
  begin
    VariableTypeElement := asEnum(SYSTEMS_TFhirVariableTypeEnum, CODES_TFhirVariableTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'characteristic') then
  begin
    CharacteristicList.add(propValue as TFhirResearchElementDefinitionCharacteristic);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchElementDefinition.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'comment') then CommentList.insertItem(index, asString(propValue))
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'topic') then TopicList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'author') then AuthorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'editor') then EditorList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'reviewer') then ReviewerList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'endorser') then EndorserList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'library') then Library_List.insertItem(index, asCanonical(propValue))
  else if (propName = 'characteristic') then CharacteristicList.insertItem(index, propValue as TFhirResearchElementDefinitionCharacteristic)
  else inherited;
end;

function TFhirResearchElementDefinition.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'shortTitle') then result := TFhirString.create()
  else if (propName = 'subtitle') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then raise EFHIRException.create('Cannot make property Subject')
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'comment') then result := CommentList.new()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'usage') then result := TFhirString.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'topic') then result := TopicList.new()
  else if (propName = 'author') then result := AuthorList.new()
  else if (propName = 'editor') then result := EditorList.new()
  else if (propName = 'reviewer') then result := ReviewerList.new()
  else if (propName = 'endorser') then result := EndorserList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'library') then result := Library_List.new()
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirResearchElementTypeEnum[ResearchElementTypeNull], CODES_TFhirResearchElementTypeEnum[ResearchElementTypeNull]) 
  else if (propName = 'variableType') then result := TFhirEnum.create(SYSTEMS_TFhirVariableTypeEnum[VariableTypeNull], CODES_TFhirVariableTypeEnum[VariableTypeNull]) 
  else if (propName = 'characteristic') then result := CharacteristicList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchElementDefinition.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'shortTitle') then result := 'string'
  else if (propName = 'subtitle') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'subject[x]') then result := 'CodeableConcept|Reference'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'comment') then result := 'string'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'usage') then result := 'string'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'topic') then result := 'CodeableConcept'
  else if (propName = 'author') then result := 'ContactDetail'
  else if (propName = 'editor') then result := 'ContactDetail'
  else if (propName = 'reviewer') then result := 'ContactDetail'
  else if (propName = 'endorser') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'library') then result := 'canonical'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'variableType') then result := 'code'
  else if (propName = 'characteristic') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchElementDefinition.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'shortTitle') then ShortTitleElement := nil
  else if (propName = 'subtitle') then SubtitleElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'comment') then deletePropertyValue('comment', CommentList, value)
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'usage') then UsageElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'topic') then deletePropertyValue('topic', TopicList, value)
  else if (propName = 'author') then deletePropertyValue('author', AuthorList, value)
  else if (propName = 'editor') then deletePropertyValue('editor', EditorList, value)
  else if (propName = 'reviewer') then deletePropertyValue('reviewer', ReviewerList, value)
  else if (propName = 'endorser') then deletePropertyValue('endorser', EndorserList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'library') then deletePropertyValue('library', Library_List, value)
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'variableType') then VariableTypeElement := nil
  else if (propName = 'characteristic') then deletePropertyValue('characteristic', CharacteristicList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchElementDefinition.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'shortTitle') then ShortTitleElement := asString(new)
  else if (propName = 'subtitle') then SubtitleElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (isMatchingName(propName, 'subject', ['CodeableConcept', 'Reference'])) then SubjectElement := new as TFhirDataType
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'comment') then replacePropertyValue('comment', CommentList, existing, new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'usage') then UsageElement := asString(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'topic') then replacePropertyValue('topic', TopicList, existing, new)
  else if (propName = 'author') then replacePropertyValue('author', AuthorList, existing, new)
  else if (propName = 'editor') then replacePropertyValue('editor', EditorList, existing, new)
  else if (propName = 'reviewer') then replacePropertyValue('reviewer', ReviewerList, existing, new)
  else if (propName = 'endorser') then replacePropertyValue('endorser', EndorserList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'library') then replacePropertyValue('library', Library_List, existing, new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirResearchElementTypeEnum, CODES_TFhirResearchElementTypeEnum, new)
  else if (propName = 'variableType') then VariableTypeElement := asEnum(SYSTEMS_TFhirVariableTypeEnum, CODES_TFhirVariableTypeEnum, new)
  else if (propName = 'characteristic') then replacePropertyValue('characteristic', CharacteristicList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchElementDefinition.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'comment') then CommentList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'topic') then TopicList.move(source, destination)
  else if (propName = 'author') then AuthorList.move(source, destination)
  else if (propName = 'editor') then EditorList.move(source, destination)
  else if (propName = 'reviewer') then ReviewerList.move(source, destination)
  else if (propName = 'endorser') then EndorserList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'library') then Library_List.move(source, destination)
  else if (propName = 'characteristic') then CharacteristicList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchElementDefinition.fhirType : string;
begin
  result := 'ResearchElementDefinition';
end;

function TFhirResearchElementDefinition.Link : TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition(inherited Link);
end;

function TFhirResearchElementDefinition.Clone : TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition(inherited Clone);
end;

function TFhirResearchElementDefinition.equals(other : TObject) : boolean; 
var
  o : TFhirResearchElementDefinition;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchElementDefinition)) then
    result := false
  else
  begin
    o := TFhirResearchElementDefinition(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(titleElement, o.titleElement, true) and compareDeep(shortTitleElement, o.shortTitleElement, true) and 
      compareDeep(subtitleElement, o.subtitleElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(subjectElement, o.subjectElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(publisherElement, o.publisherElement, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(commentList, o.commentList, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(usageElement, o.usageElement, true) and compareDeep(copyrightElement, o.copyrightElement, true) and 
      compareDeep(approvalDateElement, o.approvalDateElement, true) and compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and 
      compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and compareDeep(topicList, o.topicList, true) and 
      compareDeep(authorList, o.authorList, true) and compareDeep(editorList, o.editorList, true) and 
      compareDeep(reviewerList, o.reviewerList, true) and compareDeep(endorserList, o.endorserList, true) and 
      compareDeep(relatedArtifactList, o.relatedArtifactList, true) and compareDeep(library_List, o.library_List, true) and 
      compareDeep(type_Element, o.type_Element, true) and compareDeep(variableTypeElement, o.variableTypeElement, true) and 
      compareDeep(characteristicList, o.characteristicList, true);
  end;
end;

function TFhirResearchElementDefinition.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FName) and isEmptyProp(FTitle) and isEmptyProp(FShortTitle) and isEmptyProp(FSubtitle) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FSubject) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FcommentList) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FUsage) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FtopicList) and isEmptyProp(FauthorList) and isEmptyProp(FeditorList) and isEmptyProp(FreviewerList) and isEmptyProp(FendorserList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(Flibrary_List) and isEmptyProp(FType_) and isEmptyProp(FVariableType) and isEmptyProp(FcharacteristicList);
end;

procedure TFhirResearchElementDefinition.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('name');
  fields.add('title');
  fields.add('shortTitle');
  fields.add('subtitle');
  fields.add('status');
  fields.add('experimental');
  fields.add('subject[x]');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('comment');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('usage');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('topic');
  fields.add('author');
  fields.add('editor');
  fields.add('reviewer');
  fields.add('endorser');
  fields.add('relatedArtifact');
  fields.add('library');
  fields.add('type');
  fields.add('variableType');
  fields.add('characteristic');
end;

function TFhirResearchElementDefinition.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FCommentList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FTopicList.sizeInBytes(magic));
  inc(result, FAuthorList.sizeInBytes(magic));
  inc(result, FEditorList.sizeInBytes(magic));
  inc(result, FReviewerList.sizeInBytes(magic));
  inc(result, FEndorserList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FLibrary_List.sizeInBytes(magic));
  inc(result, FCharacteristicList.sizeInBytes(magic));
end;

procedure TFhirResearchElementDefinition.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirResearchElementDefinition.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirResearchElementDefinition.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirResearchElementDefinition.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirResearchElementDefinition.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirResearchElementDefinition.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirResearchElementDefinition.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirResearchElementDefinition.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirResearchElementDefinition.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirResearchElementDefinition.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirResearchElementDefinition.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirResearchElementDefinition.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirResearchElementDefinition.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirResearchElementDefinition.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

procedure TFhirResearchElementDefinition.SetShortTitle(value : TFhirString);
begin
  FShortTitle.free;
  FShortTitle := value;
end;

function TFhirResearchElementDefinition.GetShortTitleST : String;
begin
  if FShortTitle = nil then
    result := ''
  else
    result := FShortTitle.value;
end;

procedure TFhirResearchElementDefinition.SetShortTitleST(value : String);
begin
  if value <> '' then
  begin
    if FShortTitle = nil then
      FShortTitle := TFhirString.create;
    FShortTitle.value := value
  end
  else if FShortTitle <> nil then
    FShortTitle.value := '';
end;

procedure TFhirResearchElementDefinition.SetSubtitle(value : TFhirString);
begin
  FSubtitle.free;
  FSubtitle := value;
end;

function TFhirResearchElementDefinition.GetSubtitleST : String;
begin
  if FSubtitle = nil then
    result := ''
  else
    result := FSubtitle.value;
end;

procedure TFhirResearchElementDefinition.SetSubtitleST(value : String);
begin
  if value <> '' then
  begin
    if FSubtitle = nil then
      FSubtitle := TFhirString.create;
    FSubtitle.value := value
  end
  else if FSubtitle <> nil then
    FSubtitle.value := '';
end;

procedure TFhirResearchElementDefinition.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirResearchElementDefinition.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirResearchElementDefinition.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirResearchElementDefinition.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirResearchElementDefinition.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirResearchElementDefinition.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirResearchElementDefinition.SetSubject(value : TFhirDataType);
begin
  FSubject.free;
  FSubject := value;
end;

procedure TFhirResearchElementDefinition.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirResearchElementDefinition.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirResearchElementDefinition.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirResearchElementDefinition.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirResearchElementDefinition.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirResearchElementDefinition.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirResearchElementDefinition.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirResearchElementDefinition.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirResearchElementDefinition.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirResearchElementDefinition.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirResearchElementDefinition.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirResearchElementDefinition.GetCommentList : TFhirStringList;
begin
  if FCommentList = nil then
    FCommentList := TFhirStringList.Create;
  result := FCommentList;
end;

function TFhirResearchElementDefinition.GetHasCommentList : boolean;
begin
  result := (FCommentList <> nil) and (FCommentList.count > 0);
end;

function TFhirResearchElementDefinition.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirResearchElementDefinition.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirResearchElementDefinition.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirResearchElementDefinition.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirResearchElementDefinition.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirResearchElementDefinition.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirResearchElementDefinition.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirResearchElementDefinition.SetUsage(value : TFhirString);
begin
  FUsage.free;
  FUsage := value;
end;

function TFhirResearchElementDefinition.GetUsageST : String;
begin
  if FUsage = nil then
    result := ''
  else
    result := FUsage.value;
end;

procedure TFhirResearchElementDefinition.SetUsageST(value : String);
begin
  if value <> '' then
  begin
    if FUsage = nil then
      FUsage := TFhirString.create;
    FUsage.value := value
  end
  else if FUsage <> nil then
    FUsage.value := '';
end;

procedure TFhirResearchElementDefinition.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirResearchElementDefinition.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirResearchElementDefinition.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirResearchElementDefinition.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirResearchElementDefinition.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirResearchElementDefinition.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirResearchElementDefinition.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirResearchElementDefinition.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirResearchElementDefinition.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirResearchElementDefinition.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirResearchElementDefinition.GetTopicList : TFhirCodeableConceptList;
begin
  if FTopicList = nil then
    FTopicList := TFhirCodeableConceptList.Create;
  result := FTopicList;
end;

function TFhirResearchElementDefinition.GetHasTopicList : boolean;
begin
  result := (FTopicList <> nil) and (FTopicList.count > 0);
end;

function TFhirResearchElementDefinition.GetAuthorList : TFhirContactDetailList;
begin
  if FAuthorList = nil then
    FAuthorList := TFhirContactDetailList.Create;
  result := FAuthorList;
end;

function TFhirResearchElementDefinition.GetHasAuthorList : boolean;
begin
  result := (FAuthorList <> nil) and (FAuthorList.count > 0);
end;

function TFhirResearchElementDefinition.GetEditorList : TFhirContactDetailList;
begin
  if FEditorList = nil then
    FEditorList := TFhirContactDetailList.Create;
  result := FEditorList;
end;

function TFhirResearchElementDefinition.GetHasEditorList : boolean;
begin
  result := (FEditorList <> nil) and (FEditorList.count > 0);
end;

function TFhirResearchElementDefinition.GetReviewerList : TFhirContactDetailList;
begin
  if FReviewerList = nil then
    FReviewerList := TFhirContactDetailList.Create;
  result := FReviewerList;
end;

function TFhirResearchElementDefinition.GetHasReviewerList : boolean;
begin
  result := (FReviewerList <> nil) and (FReviewerList.count > 0);
end;

function TFhirResearchElementDefinition.GetEndorserList : TFhirContactDetailList;
begin
  if FEndorserList = nil then
    FEndorserList := TFhirContactDetailList.Create;
  result := FEndorserList;
end;

function TFhirResearchElementDefinition.GetHasEndorserList : boolean;
begin
  result := (FEndorserList <> nil) and (FEndorserList.count > 0);
end;

function TFhirResearchElementDefinition.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirResearchElementDefinition.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirResearchElementDefinition.GetLibrary_List : TFhirCanonicalList;
begin
  if FLibrary_List = nil then
    FLibrary_List := TFhirCanonicalList.Create;
  result := FLibrary_List;
end;

function TFhirResearchElementDefinition.GetHasLibrary_List : boolean;
begin
  result := (FLibrary_List <> nil) and (FLibrary_List.count > 0);
end;

procedure TFhirResearchElementDefinition.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirResearchElementDefinition.GetType_ST : TFhirResearchElementTypeEnum;
begin
  if FType_ = nil then
    result := TFhirResearchElementTypeEnum(0)
  else
    result := TFhirResearchElementTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirResearchElementTypeEnum, FType_.value));
end;

procedure TFhirResearchElementDefinition.SetType_ST(value : TFhirResearchElementTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirResearchElementTypeEnum[value], CODES_TFhirResearchElementTypeEnum[value]);
end;

procedure TFhirResearchElementDefinition.SetVariableType(value : TFhirEnum);
begin
  FVariableType.free;
  FVariableType := value;
end;

function TFhirResearchElementDefinition.GetVariableTypeST : TFhirVariableTypeEnum;
begin
  if FVariableType = nil then
    result := TFhirVariableTypeEnum(0)
  else
    result := TFhirVariableTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirVariableTypeEnum, FVariableType.value));
end;

procedure TFhirResearchElementDefinition.SetVariableTypeST(value : TFhirVariableTypeEnum);
begin
  if ord(value) = 0 then
    VariableTypeElement := nil
  else
    VariableTypeElement := TFhirEnum.create(SYSTEMS_TFhirVariableTypeEnum[value], CODES_TFhirVariableTypeEnum[value]);
end;

function TFhirResearchElementDefinition.GetCharacteristicList : TFhirResearchElementDefinitionCharacteristicList;
begin
  if FCharacteristicList = nil then
    FCharacteristicList := TFhirResearchElementDefinitionCharacteristicList.Create;
  result := FCharacteristicList;
end;

function TFhirResearchElementDefinition.GetHasCharacteristicList : boolean;
begin
  result := (FCharacteristicList <> nil) and (FCharacteristicList.count > 0);
end;

{ TFhirResearchElementDefinitionListEnumerator }

constructor TFhirResearchElementDefinitionListEnumerator.Create(list : TFhirResearchElementDefinitionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchElementDefinitionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchElementDefinitionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchElementDefinitionListEnumerator.GetCurrent : TFhirResearchElementDefinition;
begin
  Result := FList[FIndex];
end;

function TFhirResearchElementDefinitionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchElementDefinitionList }

function TFhirResearchElementDefinitionList.AddItem(value: TFhirResearchElementDefinition): TFhirResearchElementDefinition;
begin
  assert(value.ClassName = 'TFhirResearchElementDefinition', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchElementDefinition');
  add(value);
  result := value;
end;

function TFhirResearchElementDefinitionList.Append: TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchElementDefinitionList.ClearItems;
begin
  Clear;
end;

function TFhirResearchElementDefinitionList.GetEnumerator : TFhirResearchElementDefinitionListEnumerator;
begin
  result := TFhirResearchElementDefinitionListEnumerator.Create(self.link);
end;

function TFhirResearchElementDefinitionList.Clone: TFhirResearchElementDefinitionList;
begin
  result := TFhirResearchElementDefinitionList(inherited Clone);
end;

function TFhirResearchElementDefinitionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchElementDefinitionList.GetItemN(index: Integer): TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition(ObjectByIndex[index]);
end;

function TFhirResearchElementDefinitionList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchElementDefinition;
end;
function TFhirResearchElementDefinitionList.IndexOf(value: TFhirResearchElementDefinition): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchElementDefinitionList.Insert(index: Integer): TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchElementDefinitionList.InsertItem(index: Integer; value: TFhirResearchElementDefinition);
begin
  assert(value is TFhirResearchElementDefinition);
  Inherited Insert(index, value);
end;

function TFhirResearchElementDefinitionList.Item(index: Integer): TFhirResearchElementDefinition;
begin
  result := TFhirResearchElementDefinition(ObjectByIndex[index]);
end;

function TFhirResearchElementDefinitionList.Link: TFhirResearchElementDefinitionList;
begin
  result := TFhirResearchElementDefinitionList(inherited Link);
end;

procedure TFhirResearchElementDefinitionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchElementDefinitionList.SetItemByIndex(index: Integer; value: TFhirResearchElementDefinition);
begin
  assert(value is TFhirResearchElementDefinition);
  FhirResearchElementDefinitions[index] := value;
end;

procedure TFhirResearchElementDefinitionList.SetItemN(index: Integer; value: TFhirResearchElementDefinition);
begin
  assert(value is TFhirResearchElementDefinition);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHELEMENTDEFINITION}
{$IFDEF FHIR_RESEARCHSTUDY}
{ TFhirResearchStudyArm }

constructor TFhirResearchStudyArm.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyArm.Destroy;
begin
  FName.free;
  FType_.free;
  FDescription.free;
  inherited;
end;

procedure TFhirResearchStudyArm.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirResearchStudyArm(oSource).nameElement.Clone;
  type_ := TFhirResearchStudyArm(oSource).type_.Clone;
  descriptionElement := TFhirResearchStudyArm(oSource).descriptionElement.Clone;
end;

procedure TFhirResearchStudyArm.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
end;

procedure TFhirResearchStudyArm.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
end;

function TFhirResearchStudyArm.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyArm.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyArm.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyArm.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyArm.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'description') then DescriptionElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyArm.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyArm.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyArm.fhirType : string;
begin
  result := 'ResearchStudy.arm';
end;

function TFhirResearchStudyArm.Link : TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(inherited Link);
end;

function TFhirResearchStudyArm.Clone : TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(inherited Clone);
end;

function TFhirResearchStudyArm.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyArm;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyArm)) then
    result := false
  else
  begin
    o := TFhirResearchStudyArm(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true);
  end;
end;

function TFhirResearchStudyArm.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_) and isEmptyProp(FDescription);
end;

procedure TFhirResearchStudyArm.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
  fields.add('description');
end;

function TFhirResearchStudyArm.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirResearchStudyArm.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirResearchStudyArm.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirResearchStudyArm.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirResearchStudyArm.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirResearchStudyArm.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirResearchStudyArm.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirResearchStudyArm.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

{ TFhirResearchStudyArmListEnumerator }

constructor TFhirResearchStudyArmListEnumerator.Create(list : TFhirResearchStudyArmList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyArmListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyArmListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyArmListEnumerator.GetCurrent : TFhirResearchStudyArm;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyArmListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyArmList }

function TFhirResearchStudyArmList.AddItem(value: TFhirResearchStudyArm): TFhirResearchStudyArm;
begin
  assert(value.ClassName = 'TFhirResearchStudyArm', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyArm');
  add(value);
  result := value;
end;

function TFhirResearchStudyArmList.Append: TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyArmList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyArmList.GetEnumerator : TFhirResearchStudyArmListEnumerator;
begin
  result := TFhirResearchStudyArmListEnumerator.Create(self.link);
end;

function TFhirResearchStudyArmList.Clone: TFhirResearchStudyArmList;
begin
  result := TFhirResearchStudyArmList(inherited Clone);
end;

function TFhirResearchStudyArmList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyArmList.GetItemN(index: Integer): TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(ObjectByIndex[index]);
end;

function TFhirResearchStudyArmList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyArm;
end;
function TFhirResearchStudyArmList.IndexOf(value: TFhirResearchStudyArm): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyArmList.Insert(index: Integer): TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyArmList.InsertItem(index: Integer; value: TFhirResearchStudyArm);
begin
  assert(value is TFhirResearchStudyArm);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyArmList.Item(index: Integer): TFhirResearchStudyArm;
begin
  result := TFhirResearchStudyArm(ObjectByIndex[index]);
end;

function TFhirResearchStudyArmList.Link: TFhirResearchStudyArmList;
begin
  result := TFhirResearchStudyArmList(inherited Link);
end;

procedure TFhirResearchStudyArmList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyArmList.SetItemByIndex(index: Integer; value: TFhirResearchStudyArm);
begin
  assert(value is TFhirResearchStudyArm);
  FhirResearchStudyArms[index] := value;
end;

procedure TFhirResearchStudyArmList.SetItemN(index: Integer; value: TFhirResearchStudyArm);
begin
  assert(value is TFhirResearchStudyArm);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudyObjective }

constructor TFhirResearchStudyObjective.Create;
begin
  inherited;
end;

destructor TFhirResearchStudyObjective.Destroy;
begin
  FName.free;
  FType_.free;
  inherited;
end;

procedure TFhirResearchStudyObjective.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirResearchStudyObjective(oSource).nameElement.Clone;
  type_ := TFhirResearchStudyObjective(oSource).type_.Clone;
end;

procedure TFhirResearchStudyObjective.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
end;

procedure TFhirResearchStudyObjective.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
end;

function TFhirResearchStudyObjective.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudyObjective.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirResearchStudyObjective.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'type') then result := TFhirCodeableConcept.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudyObjective.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'type') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudyObjective.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'type') then Type_Element := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudyObjective.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudyObjective.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudyObjective.fhirType : string;
begin
  result := 'ResearchStudy.objective';
end;

function TFhirResearchStudyObjective.Link : TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(inherited Link);
end;

function TFhirResearchStudyObjective.Clone : TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(inherited Clone);
end;

function TFhirResearchStudyObjective.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudyObjective;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudyObjective)) then
    result := false
  else
  begin
    o := TFhirResearchStudyObjective(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(type_Element, o.type_Element, true);
  end;
end;

function TFhirResearchStudyObjective.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FType_);
end;

procedure TFhirResearchStudyObjective.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('type');
end;

function TFhirResearchStudyObjective.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirResearchStudyObjective.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirResearchStudyObjective.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirResearchStudyObjective.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirResearchStudyObjective.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

{ TFhirResearchStudyObjectiveListEnumerator }

constructor TFhirResearchStudyObjectiveListEnumerator.Create(list : TFhirResearchStudyObjectiveList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyObjectiveListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyObjectiveListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyObjectiveListEnumerator.GetCurrent : TFhirResearchStudyObjective;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyObjectiveListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyObjectiveList }

function TFhirResearchStudyObjectiveList.AddItem(value: TFhirResearchStudyObjective): TFhirResearchStudyObjective;
begin
  assert(value.ClassName = 'TFhirResearchStudyObjective', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudyObjective');
  add(value);
  result := value;
end;

function TFhirResearchStudyObjectiveList.Append: TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyObjectiveList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyObjectiveList.GetEnumerator : TFhirResearchStudyObjectiveListEnumerator;
begin
  result := TFhirResearchStudyObjectiveListEnumerator.Create(self.link);
end;

function TFhirResearchStudyObjectiveList.Clone: TFhirResearchStudyObjectiveList;
begin
  result := TFhirResearchStudyObjectiveList(inherited Clone);
end;

function TFhirResearchStudyObjectiveList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyObjectiveList.GetItemN(index: Integer): TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(ObjectByIndex[index]);
end;

function TFhirResearchStudyObjectiveList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudyObjective;
end;
function TFhirResearchStudyObjectiveList.IndexOf(value: TFhirResearchStudyObjective): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyObjectiveList.Insert(index: Integer): TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyObjectiveList.InsertItem(index: Integer; value: TFhirResearchStudyObjective);
begin
  assert(value is TFhirResearchStudyObjective);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyObjectiveList.Item(index: Integer): TFhirResearchStudyObjective;
begin
  result := TFhirResearchStudyObjective(ObjectByIndex[index]);
end;

function TFhirResearchStudyObjectiveList.Link: TFhirResearchStudyObjectiveList;
begin
  result := TFhirResearchStudyObjectiveList(inherited Link);
end;

procedure TFhirResearchStudyObjectiveList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyObjectiveList.SetItemByIndex(index: Integer; value: TFhirResearchStudyObjective);
begin
  assert(value is TFhirResearchStudyObjective);
  FhirResearchStudyObjectives[index] := value;
end;

procedure TFhirResearchStudyObjectiveList.SetItemN(index: Integer; value: TFhirResearchStudyObjective);
begin
  assert(value is TFhirResearchStudyObjective);
  ObjectByIndex[index] := value;
end;

{ TFhirResearchStudy }

constructor TFhirResearchStudy.Create;
begin
  inherited;
end;

destructor TFhirResearchStudy.Destroy;
begin
  FIdentifierList.Free;
  FTitle.free;
  FProtocolList.Free;
  FPartOfList.Free;
  FStatus.free;
  FPrimaryPurposeType.free;
  FPhase.free;
  FCategoryList.Free;
  FFocusList.Free;
  FConditionList.Free;
  FContactList.Free;
  FRelatedArtifactList.Free;
  FKeywordList.Free;
  FLocationList.Free;
  FDescription.free;
  FEnrollmentList.Free;
  FPeriod.free;
  FSponsor.free;
  FPrincipalInvestigator.free;
  FSiteList.Free;
  FReasonStopped.free;
  FNoteList.Free;
  FArmList.Free;
  FObjectiveList.Free;
  inherited;
end;

procedure TFhirResearchStudy.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirResearchStudy(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchStudy(oSource).FIdentifierList);
  end;
  titleElement := TFhirResearchStudy(oSource).titleElement.Clone;
  if (TFhirResearchStudy(oSource).FProtocolList = nil) then
  begin
    FProtocolList.free;
    FProtocolList := nil;
  end
  else
  begin
    if FProtocolList = nil then
      FProtocolList := TFhirReferenceList.Create;
    FProtocolList.Assign(TFhirResearchStudy(oSource).FProtocolList);
  end;
  if (TFhirResearchStudy(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirResearchStudy(oSource).FPartOfList);
  end;
  statusElement := TFhirResearchStudy(oSource).statusElement.Clone;
  primaryPurposeType := TFhirResearchStudy(oSource).primaryPurposeType.Clone;
  phase := TFhirResearchStudy(oSource).phase.Clone;
  if (TFhirResearchStudy(oSource).FCategoryList = nil) then
  begin
    FCategoryList.free;
    FCategoryList := nil;
  end
  else
  begin
    if FCategoryList = nil then
      FCategoryList := TFhirCodeableConceptList.Create;
    FCategoryList.Assign(TFhirResearchStudy(oSource).FCategoryList);
  end;
  if (TFhirResearchStudy(oSource).FFocusList = nil) then
  begin
    FFocusList.free;
    FFocusList := nil;
  end
  else
  begin
    if FFocusList = nil then
      FFocusList := TFhirCodeableConceptList.Create;
    FFocusList.Assign(TFhirResearchStudy(oSource).FFocusList);
  end;
  if (TFhirResearchStudy(oSource).FConditionList = nil) then
  begin
    FConditionList.free;
    FConditionList := nil;
  end
  else
  begin
    if FConditionList = nil then
      FConditionList := TFhirCodeableConceptList.Create;
    FConditionList.Assign(TFhirResearchStudy(oSource).FConditionList);
  end;
  if (TFhirResearchStudy(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirResearchStudy(oSource).FContactList);
  end;
  if (TFhirResearchStudy(oSource).FRelatedArtifactList = nil) then
  begin
    FRelatedArtifactList.free;
    FRelatedArtifactList := nil;
  end
  else
  begin
    if FRelatedArtifactList = nil then
      FRelatedArtifactList := TFhirRelatedArtifactList.Create;
    FRelatedArtifactList.Assign(TFhirResearchStudy(oSource).FRelatedArtifactList);
  end;
  if (TFhirResearchStudy(oSource).FKeywordList = nil) then
  begin
    FKeywordList.free;
    FKeywordList := nil;
  end
  else
  begin
    if FKeywordList = nil then
      FKeywordList := TFhirCodeableConceptList.Create;
    FKeywordList.Assign(TFhirResearchStudy(oSource).FKeywordList);
  end;
  if (TFhirResearchStudy(oSource).FLocationList = nil) then
  begin
    FLocationList.free;
    FLocationList := nil;
  end
  else
  begin
    if FLocationList = nil then
      FLocationList := TFhirCodeableConceptList.Create;
    FLocationList.Assign(TFhirResearchStudy(oSource).FLocationList);
  end;
  descriptionElement := TFhirResearchStudy(oSource).descriptionElement.Clone;
  if (TFhirResearchStudy(oSource).FEnrollmentList = nil) then
  begin
    FEnrollmentList.free;
    FEnrollmentList := nil;
  end
  else
  begin
    if FEnrollmentList = nil then
      FEnrollmentList := TFhirReferenceList.Create;
    FEnrollmentList.Assign(TFhirResearchStudy(oSource).FEnrollmentList);
  end;
  period := TFhirResearchStudy(oSource).period.Clone;
  sponsor := TFhirResearchStudy(oSource).sponsor.Clone;
  principalInvestigator := TFhirResearchStudy(oSource).principalInvestigator.Clone;
  if (TFhirResearchStudy(oSource).FSiteList = nil) then
  begin
    FSiteList.free;
    FSiteList := nil;
  end
  else
  begin
    if FSiteList = nil then
      FSiteList := TFhirReferenceList.Create;
    FSiteList.Assign(TFhirResearchStudy(oSource).FSiteList);
  end;
  reasonStopped := TFhirResearchStudy(oSource).reasonStopped.Clone;
  if (TFhirResearchStudy(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirResearchStudy(oSource).FNoteList);
  end;
  if (TFhirResearchStudy(oSource).FArmList = nil) then
  begin
    FArmList.free;
    FArmList := nil;
  end
  else
  begin
    if FArmList = nil then
      FArmList := TFhirResearchStudyArmList.Create;
    FArmList.Assign(TFhirResearchStudy(oSource).FArmList);
  end;
  if (TFhirResearchStudy(oSource).FObjectiveList = nil) then
  begin
    FObjectiveList.free;
    FObjectiveList := nil;
  end
  else
  begin
    if FObjectiveList = nil then
      FObjectiveList := TFhirResearchStudyObjectiveList.Create;
    FObjectiveList.Assign(TFhirResearchStudy(oSource).FObjectiveList);
  end;
end;

function TFhirResearchStudy.GetResourceType : TFhirResourceType;
begin
  result := frtResearchStudy;
end;

procedure TFhirResearchStudy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'protocol') Then
    list.addAll(self, 'protocol', FProtocolList);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'primaryPurposeType') Then
     list.add(self.link, 'primaryPurposeType', FPrimaryPurposeType.Link);
  if (child_name = 'phase') Then
     list.add(self.link, 'phase', FPhase.Link);
  if (child_name = 'category') Then
    list.addAll(self, 'category', FCategoryList);
  if (child_name = 'focus') Then
    list.addAll(self, 'focus', FFocusList);
  if (child_name = 'condition') Then
    list.addAll(self, 'condition', FConditionList);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'relatedArtifact') Then
    list.addAll(self, 'relatedArtifact', FRelatedArtifactList);
  if (child_name = 'keyword') Then
    list.addAll(self, 'keyword', FKeywordList);
  if (child_name = 'location') Then
    list.addAll(self, 'location', FLocationList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'enrollment') Then
    list.addAll(self, 'enrollment', FEnrollmentList);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'sponsor') Then
     list.add(self.link, 'sponsor', FSponsor.Link);
  if (child_name = 'principalInvestigator') Then
     list.add(self.link, 'principalInvestigator', FPrincipalInvestigator.Link);
  if (child_name = 'site') Then
    list.addAll(self, 'site', FSiteList);
  if (child_name = 'reasonStopped') Then
     list.add(self.link, 'reasonStopped', FReasonStopped.Link);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'arm') Then
    list.addAll(self, 'arm', FArmList);
  if (child_name = 'objective') Then
    list.addAll(self, 'objective', FObjectiveList);
end;

procedure TFhirResearchStudy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'protocol', 'Reference', true, TFhirReference, FProtocolList.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'primaryPurposeType', 'CodeableConcept', false, TFhirCodeableConcept, FPrimaryPurposeType.Link));
  oList.add(TFHIRProperty.create(self, 'phase', 'CodeableConcept', false, TFhirCodeableConcept, FPhase.Link));
  oList.add(TFHIRProperty.create(self, 'category', 'CodeableConcept', true, TFhirCodeableConcept, FCategoryList.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'CodeableConcept', true, TFhirCodeableConcept, FFocusList.Link));
  oList.add(TFHIRProperty.create(self, 'condition', 'CodeableConcept', true, TFhirCodeableConcept, FConditionList.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'relatedArtifact', 'RelatedArtifact', true, TFhirRelatedArtifact, FRelatedArtifactList.Link));
  oList.add(TFHIRProperty.create(self, 'keyword', 'CodeableConcept', true, TFhirCodeableConcept, FKeywordList.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'CodeableConcept', true, TFhirCodeableConcept, FLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'enrollment', 'Reference', true, TFhirReference, FEnrollmentList.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'sponsor', 'Reference', false, TFhirReference, FSponsor.Link));
  oList.add(TFHIRProperty.create(self, 'principalInvestigator', 'Reference', false, TFhirReference, FPrincipalInvestigator.Link));
  oList.add(TFHIRProperty.create(self, 'site', 'Reference', true, TFhirReference, FSiteList.Link));
  oList.add(TFHIRProperty.create(self, 'reasonStopped', 'CodeableConcept', false, TFhirCodeableConcept, FReasonStopped.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'arm', 'BackboneElement', true, TFhirResearchStudyArm, FArmList.Link));
  oList.add(TFHIRProperty.create(self, 'objective', 'BackboneElement', true, TFhirResearchStudyObjective, FObjectiveList.Link));
end;

function TFhirResearchStudy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'protocol') then
  begin
    ProtocolList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirResearchStudyStatusEnum, CODES_TFhirResearchStudyStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'primaryPurposeType') then
  begin
    PrimaryPurposeType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'phase') then
  begin
    Phase := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'category') then
  begin
    CategoryList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    FocusList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'condition') then
  begin
    ConditionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'relatedArtifact') then
  begin
    RelatedArtifactList.add(propValue as TFhirRelatedArtifact);
    result := propValue;
  end
  else if (propName = 'keyword') then
  begin
    KeywordList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    LocationList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'enrollment') then
  begin
    EnrollmentList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'sponsor') then
  begin
    Sponsor := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'principalInvestigator') then
  begin
    PrincipalInvestigator := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'site') then
  begin
    SiteList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'reasonStopped') then
  begin
    ReasonStopped := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'arm') then
  begin
    ArmList.add(propValue as TFhirResearchStudyArm);
    result := propValue;
  end
  else if (propName = 'objective') then
  begin
    ObjectiveList.add(propValue as TFhirResearchStudyObjective);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchStudy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'protocol') then ProtocolList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'category') then CategoryList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'focus') then FocusList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'condition') then ConditionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.insertItem(index, propValue as TFhirRelatedArtifact)
  else if (propName = 'keyword') then KeywordList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'location') then LocationList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'enrollment') then EnrollmentList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'site') then SiteList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'arm') then ArmList.insertItem(index, propValue as TFhirResearchStudyArm)
  else if (propName = 'objective') then ObjectiveList.insertItem(index, propValue as TFhirResearchStudyObjective)
  else inherited;
end;

function TFhirResearchStudy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'protocol') then result := ProtocolList.new()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirResearchStudyStatusEnum[ResearchStudyStatusNull], CODES_TFhirResearchStudyStatusEnum[ResearchStudyStatusNull]) 
  else if (propName = 'primaryPurposeType') then result := TFhirCodeableConcept.create()
  else if (propName = 'phase') then result := TFhirCodeableConcept.create()
  else if (propName = 'category') then result := CategoryList.new()
  else if (propName = 'focus') then result := FocusList.new()
  else if (propName = 'condition') then result := ConditionList.new()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'relatedArtifact') then result := RelatedArtifactList.new()
  else if (propName = 'keyword') then result := KeywordList.new()
  else if (propName = 'location') then result := LocationList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'enrollment') then result := EnrollmentList.new()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'sponsor') then result := TFhirReference.create()
  else if (propName = 'principalInvestigator') then result := TFhirReference.create()
  else if (propName = 'site') then result := SiteList.new()
  else if (propName = 'reasonStopped') then result := TFhirCodeableConcept.create()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'arm') then result := ArmList.new()
  else if (propName = 'objective') then result := ObjectiveList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchStudy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'protocol') then result := 'Reference'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'primaryPurposeType') then result := 'CodeableConcept'
  else if (propName = 'phase') then result := 'CodeableConcept'
  else if (propName = 'category') then result := 'CodeableConcept'
  else if (propName = 'focus') then result := 'CodeableConcept'
  else if (propName = 'condition') then result := 'CodeableConcept'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'relatedArtifact') then result := 'RelatedArtifact'
  else if (propName = 'keyword') then result := 'CodeableConcept'
  else if (propName = 'location') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'enrollment') then result := 'Reference'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'sponsor') then result := 'Reference'
  else if (propName = 'principalInvestigator') then result := 'Reference'
  else if (propName = 'site') then result := 'Reference'
  else if (propName = 'reasonStopped') then result := 'CodeableConcept'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'arm') then result := 'BackboneElement'
  else if (propName = 'objective') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchStudy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'protocol') then deletePropertyValue('protocol', ProtocolList, value)
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'primaryPurposeType') then PrimaryPurposeTypeElement := nil
  else if (propName = 'phase') then PhaseElement := nil
  else if (propName = 'category') then deletePropertyValue('category', CategoryList, value)
  else if (propName = 'focus') then deletePropertyValue('focus', FocusList, value)
  else if (propName = 'condition') then deletePropertyValue('condition', ConditionList, value)
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'relatedArtifact') then deletePropertyValue('relatedArtifact', RelatedArtifactList, value)
  else if (propName = 'keyword') then deletePropertyValue('keyword', KeywordList, value)
  else if (propName = 'location') then deletePropertyValue('location', LocationList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'enrollment') then deletePropertyValue('enrollment', EnrollmentList, value)
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'sponsor') then SponsorElement := nil
  else if (propName = 'principalInvestigator') then PrincipalInvestigatorElement := nil
  else if (propName = 'site') then deletePropertyValue('site', SiteList, value)
  else if (propName = 'reasonStopped') then ReasonStoppedElement := nil
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'arm') then deletePropertyValue('arm', ArmList, value)
  else if (propName = 'objective') then deletePropertyValue('objective', ObjectiveList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchStudy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'protocol') then replacePropertyValue('protocol', ProtocolList, existing, new)
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirResearchStudyStatusEnum, CODES_TFhirResearchStudyStatusEnum, new)
  else if (propName = 'primaryPurposeType') then PrimaryPurposeTypeElement := new as TFhirCodeableConcept
  else if (propName = 'phase') then PhaseElement := new as TFhirCodeableConcept
  else if (propName = 'category') then replacePropertyValue('category', CategoryList, existing, new)
  else if (propName = 'focus') then replacePropertyValue('focus', FocusList, existing, new)
  else if (propName = 'condition') then replacePropertyValue('condition', ConditionList, existing, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'relatedArtifact') then replacePropertyValue('relatedArtifact', RelatedArtifactList, existing, new)
  else if (propName = 'keyword') then replacePropertyValue('keyword', KeywordList, existing, new)
  else if (propName = 'location') then replacePropertyValue('location', LocationList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'enrollment') then replacePropertyValue('enrollment', EnrollmentList, existing, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'sponsor') then SponsorElement := new as TFhirReference
  else if (propName = 'principalInvestigator') then PrincipalInvestigatorElement := new as TFhirReference
  else if (propName = 'site') then replacePropertyValue('site', SiteList, existing, new)
  else if (propName = 'reasonStopped') then ReasonStoppedElement := new as TFhirCodeableConcept
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'arm') then replacePropertyValue('arm', ArmList, existing, new)
  else if (propName = 'objective') then replacePropertyValue('objective', ObjectiveList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchStudy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'protocol') then ProtocolList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'category') then CategoryList.move(source, destination)
  else if (propName = 'focus') then FocusList.move(source, destination)
  else if (propName = 'condition') then ConditionList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'relatedArtifact') then RelatedArtifactList.move(source, destination)
  else if (propName = 'keyword') then KeywordList.move(source, destination)
  else if (propName = 'location') then LocationList.move(source, destination)
  else if (propName = 'enrollment') then EnrollmentList.move(source, destination)
  else if (propName = 'site') then SiteList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'arm') then ArmList.move(source, destination)
  else if (propName = 'objective') then ObjectiveList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchStudy.fhirType : string;
begin
  result := 'ResearchStudy';
end;

function TFhirResearchStudy.Link : TFhirResearchStudy;
begin
  result := TFhirResearchStudy(inherited Link);
end;

function TFhirResearchStudy.Clone : TFhirResearchStudy;
begin
  result := TFhirResearchStudy(inherited Clone);
end;

function TFhirResearchStudy.equals(other : TObject) : boolean; 
var
  o : TFhirResearchStudy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchStudy)) then
    result := false
  else
  begin
    o := TFhirResearchStudy(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(protocolList, o.protocolList, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(primaryPurposeTypeElement, o.primaryPurposeTypeElement, true) and 
      compareDeep(phaseElement, o.phaseElement, true) and compareDeep(categoryList, o.categoryList, true) and 
      compareDeep(focusList, o.focusList, true) and compareDeep(conditionList, o.conditionList, true) and 
      compareDeep(contactList, o.contactList, true) and compareDeep(relatedArtifactList, o.relatedArtifactList, true) and 
      compareDeep(keywordList, o.keywordList, true) and compareDeep(locationList, o.locationList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(enrollmentList, o.enrollmentList, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(sponsorElement, o.sponsorElement, true) and 
      compareDeep(principalInvestigatorElement, o.principalInvestigatorElement, true) and 
      compareDeep(siteList, o.siteList, true) and compareDeep(reasonStoppedElement, o.reasonStoppedElement, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(armList, o.armList, true) and 
      compareDeep(objectiveList, o.objectiveList, true);
  end;
end;

function TFhirResearchStudy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FTitle) and isEmptyProp(FprotocolList) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FPrimaryPurposeType) and isEmptyProp(FPhase) and isEmptyProp(FcategoryList) and isEmptyProp(FfocusList) and isEmptyProp(FconditionList) and isEmptyProp(FcontactList) and isEmptyProp(FrelatedArtifactList) and isEmptyProp(FkeywordList) and isEmptyProp(FlocationList) and isEmptyProp(FDescription) and isEmptyProp(FenrollmentList) and isEmptyProp(FPeriod) and isEmptyProp(FSponsor) and isEmptyProp(FPrincipalInvestigator) and isEmptyProp(FsiteList) and isEmptyProp(FReasonStopped) and isEmptyProp(FnoteList) and isEmptyProp(FarmList) and isEmptyProp(FobjectiveList);
end;

procedure TFhirResearchStudy.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('title');
  fields.add('protocol');
  fields.add('partOf');
  fields.add('status');
  fields.add('primaryPurposeType');
  fields.add('phase');
  fields.add('category');
  fields.add('focus');
  fields.add('condition');
  fields.add('contact');
  fields.add('relatedArtifact');
  fields.add('keyword');
  fields.add('location');
  fields.add('description');
  fields.add('enrollment');
  fields.add('period');
  fields.add('sponsor');
  fields.add('principalInvestigator');
  fields.add('site');
  fields.add('reasonStopped');
  fields.add('note');
  fields.add('arm');
  fields.add('objective');
end;

function TFhirResearchStudy.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FProtocolList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FCategoryList.sizeInBytes(magic));
  inc(result, FFocusList.sizeInBytes(magic));
  inc(result, FConditionList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FRelatedArtifactList.sizeInBytes(magic));
  inc(result, FKeywordList.sizeInBytes(magic));
  inc(result, FLocationList.sizeInBytes(magic));
  inc(result, FEnrollmentList.sizeInBytes(magic));
  inc(result, FSiteList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FArmList.sizeInBytes(magic));
  inc(result, FObjectiveList.sizeInBytes(magic));
end;

function TFhirResearchStudy.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirResearchStudy.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirResearchStudy.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirResearchStudy.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirResearchStudy.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirResearchStudy.GetProtocolList : TFhirReferenceList;
begin
  if FProtocolList = nil then
    FProtocolList := TFhirReferenceList.Create;
  result := FProtocolList;
end;

function TFhirResearchStudy.GetHasProtocolList : boolean;
begin
  result := (FProtocolList <> nil) and (FProtocolList.count > 0);
end;

function TFhirResearchStudy.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirResearchStudy.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirResearchStudy.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirResearchStudy.GetStatusST : TFhirResearchStudyStatusEnum;
begin
  if FStatus = nil then
    result := TFhirResearchStudyStatusEnum(0)
  else
    result := TFhirResearchStudyStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirResearchStudyStatusEnum, FStatus.value));
end;

procedure TFhirResearchStudy.SetStatusST(value : TFhirResearchStudyStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirResearchStudyStatusEnum[value], CODES_TFhirResearchStudyStatusEnum[value]);
end;

procedure TFhirResearchStudy.SetPrimaryPurposeType(value : TFhirCodeableConcept);
begin
  FPrimaryPurposeType.free;
  FPrimaryPurposeType := value;
end;

procedure TFhirResearchStudy.SetPhase(value : TFhirCodeableConcept);
begin
  FPhase.free;
  FPhase := value;
end;

function TFhirResearchStudy.GetCategoryList : TFhirCodeableConceptList;
begin
  if FCategoryList = nil then
    FCategoryList := TFhirCodeableConceptList.Create;
  result := FCategoryList;
end;

function TFhirResearchStudy.GetHasCategoryList : boolean;
begin
  result := (FCategoryList <> nil) and (FCategoryList.count > 0);
end;

function TFhirResearchStudy.GetFocusList : TFhirCodeableConceptList;
begin
  if FFocusList = nil then
    FFocusList := TFhirCodeableConceptList.Create;
  result := FFocusList;
end;

function TFhirResearchStudy.GetHasFocusList : boolean;
begin
  result := (FFocusList <> nil) and (FFocusList.count > 0);
end;

function TFhirResearchStudy.GetConditionList : TFhirCodeableConceptList;
begin
  if FConditionList = nil then
    FConditionList := TFhirCodeableConceptList.Create;
  result := FConditionList;
end;

function TFhirResearchStudy.GetHasConditionList : boolean;
begin
  result := (FConditionList <> nil) and (FConditionList.count > 0);
end;

function TFhirResearchStudy.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirResearchStudy.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

function TFhirResearchStudy.GetRelatedArtifactList : TFhirRelatedArtifactList;
begin
  if FRelatedArtifactList = nil then
    FRelatedArtifactList := TFhirRelatedArtifactList.Create;
  result := FRelatedArtifactList;
end;

function TFhirResearchStudy.GetHasRelatedArtifactList : boolean;
begin
  result := (FRelatedArtifactList <> nil) and (FRelatedArtifactList.count > 0);
end;

function TFhirResearchStudy.GetKeywordList : TFhirCodeableConceptList;
begin
  if FKeywordList = nil then
    FKeywordList := TFhirCodeableConceptList.Create;
  result := FKeywordList;
end;

function TFhirResearchStudy.GetHasKeywordList : boolean;
begin
  result := (FKeywordList <> nil) and (FKeywordList.count > 0);
end;

function TFhirResearchStudy.GetLocationList : TFhirCodeableConceptList;
begin
  if FLocationList = nil then
    FLocationList := TFhirCodeableConceptList.Create;
  result := FLocationList;
end;

function TFhirResearchStudy.GetHasLocationList : boolean;
begin
  result := (FLocationList <> nil) and (FLocationList.count > 0);
end;

procedure TFhirResearchStudy.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirResearchStudy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirResearchStudy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirResearchStudy.GetEnrollmentList : TFhirReferenceList;
begin
  if FEnrollmentList = nil then
    FEnrollmentList := TFhirReferenceList.Create;
  result := FEnrollmentList;
end;

function TFhirResearchStudy.GetHasEnrollmentList : boolean;
begin
  result := (FEnrollmentList <> nil) and (FEnrollmentList.count > 0);
end;

procedure TFhirResearchStudy.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirResearchStudy.SetSponsor(value : TFhirReference);
begin
  FSponsor.free;
  FSponsor := value;
end;

procedure TFhirResearchStudy.SetPrincipalInvestigator(value : TFhirReference);
begin
  FPrincipalInvestigator.free;
  FPrincipalInvestigator := value;
end;

function TFhirResearchStudy.GetSiteList : TFhirReferenceList;
begin
  if FSiteList = nil then
    FSiteList := TFhirReferenceList.Create;
  result := FSiteList;
end;

function TFhirResearchStudy.GetHasSiteList : boolean;
begin
  result := (FSiteList <> nil) and (FSiteList.count > 0);
end;

procedure TFhirResearchStudy.SetReasonStopped(value : TFhirCodeableConcept);
begin
  FReasonStopped.free;
  FReasonStopped := value;
end;

function TFhirResearchStudy.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirResearchStudy.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirResearchStudy.GetArmList : TFhirResearchStudyArmList;
begin
  if FArmList = nil then
    FArmList := TFhirResearchStudyArmList.Create;
  result := FArmList;
end;

function TFhirResearchStudy.GetHasArmList : boolean;
begin
  result := (FArmList <> nil) and (FArmList.count > 0);
end;

function TFhirResearchStudy.GetObjectiveList : TFhirResearchStudyObjectiveList;
begin
  if FObjectiveList = nil then
    FObjectiveList := TFhirResearchStudyObjectiveList.Create;
  result := FObjectiveList;
end;

function TFhirResearchStudy.GetHasObjectiveList : boolean;
begin
  result := (FObjectiveList <> nil) and (FObjectiveList.count > 0);
end;

{ TFhirResearchStudyListEnumerator }

constructor TFhirResearchStudyListEnumerator.Create(list : TFhirResearchStudyList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchStudyListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchStudyListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchStudyListEnumerator.GetCurrent : TFhirResearchStudy;
begin
  Result := FList[FIndex];
end;

function TFhirResearchStudyListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchStudyList }

function TFhirResearchStudyList.AddItem(value: TFhirResearchStudy): TFhirResearchStudy;
begin
  assert(value.ClassName = 'TFhirResearchStudy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchStudy');
  add(value);
  result := value;
end;

function TFhirResearchStudyList.Append: TFhirResearchStudy;
begin
  result := TFhirResearchStudy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyList.ClearItems;
begin
  Clear;
end;

function TFhirResearchStudyList.GetEnumerator : TFhirResearchStudyListEnumerator;
begin
  result := TFhirResearchStudyListEnumerator.Create(self.link);
end;

function TFhirResearchStudyList.Clone: TFhirResearchStudyList;
begin
  result := TFhirResearchStudyList(inherited Clone);
end;

function TFhirResearchStudyList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchStudyList.GetItemN(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy(ObjectByIndex[index]);
end;

function TFhirResearchStudyList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchStudy;
end;
function TFhirResearchStudyList.IndexOf(value: TFhirResearchStudy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchStudyList.Insert(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchStudyList.InsertItem(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  Inherited Insert(index, value);
end;

function TFhirResearchStudyList.Item(index: Integer): TFhirResearchStudy;
begin
  result := TFhirResearchStudy(ObjectByIndex[index]);
end;

function TFhirResearchStudyList.Link: TFhirResearchStudyList;
begin
  result := TFhirResearchStudyList(inherited Link);
end;

procedure TFhirResearchStudyList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchStudyList.SetItemByIndex(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  FhirResearchStudies[index] := value;
end;

procedure TFhirResearchStudyList.SetItemN(index: Integer; value: TFhirResearchStudy);
begin
  assert(value is TFhirResearchStudy);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHSTUDY}
{$IFDEF FHIR_RESEARCHSUBJECT}
{ TFhirResearchSubject }

constructor TFhirResearchSubject.Create;
begin
  inherited;
end;

destructor TFhirResearchSubject.Destroy;
begin
  FIdentifierList.Free;
  FStatus.free;
  FPeriod.free;
  FStudy.free;
  FIndividual.free;
  FAssignedArm.free;
  FActualArm.free;
  FConsent.free;
  inherited;
end;

procedure TFhirResearchSubject.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirResearchSubject(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirResearchSubject(oSource).FIdentifierList);
  end;
  statusElement := TFhirResearchSubject(oSource).statusElement.Clone;
  period := TFhirResearchSubject(oSource).period.Clone;
  study := TFhirResearchSubject(oSource).study.Clone;
  individual := TFhirResearchSubject(oSource).individual.Clone;
  assignedArmElement := TFhirResearchSubject(oSource).assignedArmElement.Clone;
  actualArmElement := TFhirResearchSubject(oSource).actualArmElement.Clone;
  consent := TFhirResearchSubject(oSource).consent.Clone;
end;

function TFhirResearchSubject.GetResourceType : TFhirResourceType;
begin
  result := frtResearchSubject;
end;

procedure TFhirResearchSubject.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'study') Then
     list.add(self.link, 'study', FStudy.Link);
  if (child_name = 'individual') Then
     list.add(self.link, 'individual', FIndividual.Link);
  if (child_name = 'assignedArm') Then
     list.add(self.link, 'assignedArm', FAssignedArm.Link);
  if (child_name = 'actualArm') Then
     list.add(self.link, 'actualArm', FActualArm.Link);
  if (child_name = 'consent') Then
     list.add(self.link, 'consent', FConsent.Link);
end;

procedure TFhirResearchSubject.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'study', 'Reference', false, TFhirReference, FStudy.Link));
  oList.add(TFHIRProperty.create(self, 'individual', 'Reference', false, TFhirReference, FIndividual.Link));
  oList.add(TFHIRProperty.create(self, 'assignedArm', 'string', false, TFhirString, FAssignedArm.Link));
  oList.add(TFHIRProperty.create(self, 'actualArm', 'string', false, TFhirString, FActualArm.Link));
  oList.add(TFHIRProperty.create(self, 'consent', 'Reference', false, TFhirReference, FConsent.Link));
end;

function TFhirResearchSubject.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirResearchSubjectStatusEnum, CODES_TFhirResearchSubjectStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'study') then
  begin
    Study := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'individual') then
  begin
    Individual := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'assignedArm') then
  begin
    AssignedArmElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'actualArm') then
  begin
    ActualArmElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'consent') then
  begin
    Consent := propValue as TFhirReference;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirResearchSubject.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else inherited;
end;

function TFhirResearchSubject.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirResearchSubjectStatusEnum[ResearchSubjectStatusNull], CODES_TFhirResearchSubjectStatusEnum[ResearchSubjectStatusNull]) 
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'study') then result := TFhirReference.create()
  else if (propName = 'individual') then result := TFhirReference.create()
  else if (propName = 'assignedArm') then result := TFhirString.create()
  else if (propName = 'actualArm') then result := TFhirString.create()
  else if (propName = 'consent') then result := TFhirReference.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirResearchSubject.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'study') then result := 'Reference'
  else if (propName = 'individual') then result := 'Reference'
  else if (propName = 'assignedArm') then result := 'string'
  else if (propName = 'actualArm') then result := 'string'
  else if (propName = 'consent') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirResearchSubject.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'study') then StudyElement := nil
  else if (propName = 'individual') then IndividualElement := nil
  else if (propName = 'assignedArm') then AssignedArmElement := nil
  else if (propName = 'actualArm') then ActualArmElement := nil
  else if (propName = 'consent') then ConsentElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirResearchSubject.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirResearchSubjectStatusEnum, CODES_TFhirResearchSubjectStatusEnum, new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'study') then StudyElement := new as TFhirReference
  else if (propName = 'individual') then IndividualElement := new as TFhirReference
  else if (propName = 'assignedArm') then AssignedArmElement := asString(new)
  else if (propName = 'actualArm') then ActualArmElement := asString(new)
  else if (propName = 'consent') then ConsentElement := new as TFhirReference
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirResearchSubject.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirResearchSubject.fhirType : string;
begin
  result := 'ResearchSubject';
end;

function TFhirResearchSubject.Link : TFhirResearchSubject;
begin
  result := TFhirResearchSubject(inherited Link);
end;

function TFhirResearchSubject.Clone : TFhirResearchSubject;
begin
  result := TFhirResearchSubject(inherited Clone);
end;

function TFhirResearchSubject.equals(other : TObject) : boolean; 
var
  o : TFhirResearchSubject;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirResearchSubject)) then
    result := false
  else
  begin
    o := TFhirResearchSubject(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(periodElement, o.periodElement, true) and compareDeep(studyElement, o.studyElement, true) and 
      compareDeep(individualElement, o.individualElement, true) and compareDeep(assignedArmElement, o.assignedArmElement, true) and 
      compareDeep(actualArmElement, o.actualArmElement, true) and compareDeep(consentElement, o.consentElement, true);
  end;
end;

function TFhirResearchSubject.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FStatus) and isEmptyProp(FPeriod) and isEmptyProp(FStudy) and isEmptyProp(FIndividual) and isEmptyProp(FAssignedArm) and isEmptyProp(FActualArm) and isEmptyProp(FConsent);
end;

procedure TFhirResearchSubject.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('status');
  fields.add('period');
  fields.add('study');
  fields.add('individual');
  fields.add('assignedArm');
  fields.add('actualArm');
  fields.add('consent');
end;

function TFhirResearchSubject.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
end;

function TFhirResearchSubject.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirResearchSubject.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirResearchSubject.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirResearchSubject.GetStatusST : TFhirResearchSubjectStatusEnum;
begin
  if FStatus = nil then
    result := TFhirResearchSubjectStatusEnum(0)
  else
    result := TFhirResearchSubjectStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirResearchSubjectStatusEnum, FStatus.value));
end;

procedure TFhirResearchSubject.SetStatusST(value : TFhirResearchSubjectStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirResearchSubjectStatusEnum[value], CODES_TFhirResearchSubjectStatusEnum[value]);
end;

procedure TFhirResearchSubject.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

procedure TFhirResearchSubject.SetStudy(value : TFhirReference);
begin
  FStudy.free;
  FStudy := value;
end;

procedure TFhirResearchSubject.SetIndividual(value : TFhirReference);
begin
  FIndividual.free;
  FIndividual := value;
end;

procedure TFhirResearchSubject.SetAssignedArm(value : TFhirString);
begin
  FAssignedArm.free;
  FAssignedArm := value;
end;

function TFhirResearchSubject.GetAssignedArmST : String;
begin
  if FAssignedArm = nil then
    result := ''
  else
    result := FAssignedArm.value;
end;

procedure TFhirResearchSubject.SetAssignedArmST(value : String);
begin
  if value <> '' then
  begin
    if FAssignedArm = nil then
      FAssignedArm := TFhirString.create;
    FAssignedArm.value := value
  end
  else if FAssignedArm <> nil then
    FAssignedArm.value := '';
end;

procedure TFhirResearchSubject.SetActualArm(value : TFhirString);
begin
  FActualArm.free;
  FActualArm := value;
end;

function TFhirResearchSubject.GetActualArmST : String;
begin
  if FActualArm = nil then
    result := ''
  else
    result := FActualArm.value;
end;

procedure TFhirResearchSubject.SetActualArmST(value : String);
begin
  if value <> '' then
  begin
    if FActualArm = nil then
      FActualArm := TFhirString.create;
    FActualArm.value := value
  end
  else if FActualArm <> nil then
    FActualArm.value := '';
end;

procedure TFhirResearchSubject.SetConsent(value : TFhirReference);
begin
  FConsent.free;
  FConsent := value;
end;

{ TFhirResearchSubjectListEnumerator }

constructor TFhirResearchSubjectListEnumerator.Create(list : TFhirResearchSubjectList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirResearchSubjectListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirResearchSubjectListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirResearchSubjectListEnumerator.GetCurrent : TFhirResearchSubject;
begin
  Result := FList[FIndex];
end;

function TFhirResearchSubjectListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirResearchSubjectList }

function TFhirResearchSubjectList.AddItem(value: TFhirResearchSubject): TFhirResearchSubject;
begin
  assert(value.ClassName = 'TFhirResearchSubject', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirResearchSubject');
  add(value);
  result := value;
end;

function TFhirResearchSubjectList.Append: TFhirResearchSubject;
begin
  result := TFhirResearchSubject.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectList.ClearItems;
begin
  Clear;
end;

function TFhirResearchSubjectList.GetEnumerator : TFhirResearchSubjectListEnumerator;
begin
  result := TFhirResearchSubjectListEnumerator.Create(self.link);
end;

function TFhirResearchSubjectList.Clone: TFhirResearchSubjectList;
begin
  result := TFhirResearchSubjectList(inherited Clone);
end;

function TFhirResearchSubjectList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirResearchSubjectList.GetItemN(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject(ObjectByIndex[index]);
end;

function TFhirResearchSubjectList.ItemClass: TFslObjectClass;
begin
  result := TFhirResearchSubject;
end;
function TFhirResearchSubjectList.IndexOf(value: TFhirResearchSubject): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirResearchSubjectList.Insert(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirResearchSubjectList.InsertItem(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  Inherited Insert(index, value);
end;

function TFhirResearchSubjectList.Item(index: Integer): TFhirResearchSubject;
begin
  result := TFhirResearchSubject(ObjectByIndex[index]);
end;

function TFhirResearchSubjectList.Link: TFhirResearchSubjectList;
begin
  result := TFhirResearchSubjectList(inherited Link);
end;

procedure TFhirResearchSubjectList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirResearchSubjectList.SetItemByIndex(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  FhirResearchSubjects[index] := value;
end;

procedure TFhirResearchSubjectList.SetItemN(index: Integer; value: TFhirResearchSubject);
begin
  assert(value is TFhirResearchSubject);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_RESEARCHSUBJECT}
{$IFDEF FHIR_SUBSCRIPTION}
{ TFhirSubscriptionChannel }

constructor TFhirSubscriptionChannel.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionChannel.Destroy;
begin
  FType_.free;
  FEndpoint.free;
  FPayload.free;
  FHeaderList.Free;
  inherited;
end;

procedure TFhirSubscriptionChannel.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirSubscriptionChannel(oSource).type_Element.Clone;
  endpointElement := TFhirSubscriptionChannel(oSource).endpointElement.Clone;
  payloadElement := TFhirSubscriptionChannel(oSource).payloadElement.Clone;
  if (TFhirSubscriptionChannel(oSource).FHeaderList = nil) then
  begin
    FHeaderList.free;
    FHeaderList := nil;
  end
  else
  begin
    if FHeaderList = nil then
      FHeaderList := TFhirStringList.Create;
    FHeaderList.Assign(TFhirSubscriptionChannel(oSource).FHeaderList);
  end;
end;

procedure TFhirSubscriptionChannel.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'endpoint') Then
     list.add(self.link, 'endpoint', FEndpoint.Link);
  if (child_name = 'payload') Then
     list.add(self.link, 'payload', FPayload.Link);
  if (child_name = 'header') Then
    list.addAll(self, 'header', FHeaderList);
end;

procedure TFhirSubscriptionChannel.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'endpoint', 'url', false, TFhirUrl, FEndpoint.Link));
  oList.add(TFHIRProperty.create(self, 'payload', 'code', false, TFhirCode, FPayload.Link));
  oList.add(TFHIRProperty.create(self, 'header', 'string', true, TFhirString, FHeaderList.Link));
end;

function TFhirSubscriptionChannel.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSubscriptionChannelTypeEnum, CODES_TFhirSubscriptionChannelTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'endpoint') then
  begin
    EndpointElement := asUrl(propValue);
    result := propValue;
  end
  else if (propName = 'payload') then
  begin
    PayloadElement := asCode(propValue);
    result := propValue;
  end
  else if (propName = 'header') then
  begin
    HeaderList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionChannel.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'header') then HeaderList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirSubscriptionChannel.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirSubscriptionChannelTypeEnum[SubscriptionChannelTypeNull], CODES_TFhirSubscriptionChannelTypeEnum[SubscriptionChannelTypeNull]) 
  else if (propName = 'endpoint') then result := TFhirUrl.create()
  else if (propName = 'payload') then result := TFhirCode.create()
  else if (propName = 'header') then result := HeaderList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionChannel.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'endpoint') then result := 'url'
  else if (propName = 'payload') then result := 'code'
  else if (propName = 'header') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionChannel.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'endpoint') then EndpointElement := nil
  else if (propName = 'payload') then PayloadElement := nil
  else if (propName = 'header') then deletePropertyValue('header', HeaderList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionChannel.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSubscriptionChannelTypeEnum, CODES_TFhirSubscriptionChannelTypeEnum, new)
  else if (propName = 'endpoint') then EndpointElement := asUrl(new)
  else if (propName = 'payload') then PayloadElement := asCode(new)
  else if (propName = 'header') then replacePropertyValue('header', HeaderList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionChannel.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'header') then HeaderList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionChannel.fhirType : string;
begin
  result := 'Subscription.channel';
end;

function TFhirSubscriptionChannel.Link : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(inherited Link);
end;

function TFhirSubscriptionChannel.Clone : TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(inherited Clone);
end;

function TFhirSubscriptionChannel.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionChannel;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionChannel)) then
    result := false
  else
  begin
    o := TFhirSubscriptionChannel(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(endpointElement, o.endpointElement, true) and 
      compareDeep(payloadElement, o.payloadElement, true) and compareDeep(headerList, o.headerList, true);
  end;
end;

function TFhirSubscriptionChannel.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FEndpoint) and isEmptyProp(FPayload) and isEmptyProp(FheaderList);
end;

procedure TFhirSubscriptionChannel.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('endpoint');
  fields.add('payload');
  fields.add('header');
end;

function TFhirSubscriptionChannel.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FHeaderList.sizeInBytes(magic));
end;

procedure TFhirSubscriptionChannel.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirSubscriptionChannel.GetType_ST : TFhirSubscriptionChannelTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSubscriptionChannelTypeEnum(0)
  else
    result := TFhirSubscriptionChannelTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionChannelTypeEnum, FType_.value));
end;

procedure TFhirSubscriptionChannel.SetType_ST(value : TFhirSubscriptionChannelTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSubscriptionChannelTypeEnum[value], CODES_TFhirSubscriptionChannelTypeEnum[value]);
end;

procedure TFhirSubscriptionChannel.SetEndpoint(value : TFhirUrl);
begin
  FEndpoint.free;
  FEndpoint := value;
end;

function TFhirSubscriptionChannel.GetEndpointST : String;
begin
  if FEndpoint = nil then
    result := ''
  else
    result := FEndpoint.value;
end;

procedure TFhirSubscriptionChannel.SetEndpointST(value : String);
begin
  if value <> '' then
  begin
    if FEndpoint = nil then
      FEndpoint := TFhirUrl.create;
    FEndpoint.value := value
  end
  else if FEndpoint <> nil then
    FEndpoint.value := '';
end;

procedure TFhirSubscriptionChannel.SetPayload(value : TFhirCode);
begin
  FPayload.free;
  FPayload := value;
end;

function TFhirSubscriptionChannel.GetPayloadST : String;
begin
  if FPayload = nil then
    result := ''
  else
    result := FPayload.value;
end;

procedure TFhirSubscriptionChannel.SetPayloadST(value : String);
begin
  if value <> '' then
  begin
    if FPayload = nil then
      FPayload := TFhirCode.create;
    FPayload.value := value
  end
  else if FPayload <> nil then
    FPayload.value := '';
end;

function TFhirSubscriptionChannel.GetHeaderList : TFhirStringList;
begin
  if FHeaderList = nil then
    FHeaderList := TFhirStringList.Create;
  result := FHeaderList;
end;

function TFhirSubscriptionChannel.GetHasHeaderList : boolean;
begin
  result := (FHeaderList <> nil) and (FHeaderList.count > 0);
end;

{ TFhirSubscriptionChannelListEnumerator }

constructor TFhirSubscriptionChannelListEnumerator.Create(list : TFhirSubscriptionChannelList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionChannelListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionChannelListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionChannelListEnumerator.GetCurrent : TFhirSubscriptionChannel;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionChannelListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionChannelList }

function TFhirSubscriptionChannelList.AddItem(value: TFhirSubscriptionChannel): TFhirSubscriptionChannel;
begin
  assert(value.ClassName = 'TFhirSubscriptionChannel', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionChannel');
  add(value);
  result := value;
end;

function TFhirSubscriptionChannelList.Append: TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionChannelList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionChannelList.GetEnumerator : TFhirSubscriptionChannelListEnumerator;
begin
  result := TFhirSubscriptionChannelListEnumerator.Create(self.link);
end;

function TFhirSubscriptionChannelList.Clone: TFhirSubscriptionChannelList;
begin
  result := TFhirSubscriptionChannelList(inherited Clone);
end;

function TFhirSubscriptionChannelList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionChannelList.GetItemN(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(ObjectByIndex[index]);
end;

function TFhirSubscriptionChannelList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionChannel;
end;
function TFhirSubscriptionChannelList.IndexOf(value: TFhirSubscriptionChannel): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionChannelList.Insert(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionChannelList.InsertItem(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionChannelList.Item(index: Integer): TFhirSubscriptionChannel;
begin
  result := TFhirSubscriptionChannel(ObjectByIndex[index]);
end;

function TFhirSubscriptionChannelList.Link: TFhirSubscriptionChannelList;
begin
  result := TFhirSubscriptionChannelList(inherited Link);
end;

procedure TFhirSubscriptionChannelList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionChannelList.SetItemByIndex(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  FhirSubscriptionChannels[index] := value;
end;

procedure TFhirSubscriptionChannelList.SetItemN(index: Integer; value: TFhirSubscriptionChannel);
begin
  assert(value is TFhirSubscriptionChannel);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscription }

constructor TFhirSubscription.Create;
begin
  inherited;
end;

destructor TFhirSubscription.Destroy;
begin
  FStatus.free;
  FContactList.Free;
  FEnd_.free;
  FReason.free;
  FCriteria.free;
  FError.free;
  FChannel.free;
  inherited;
end;

procedure TFhirSubscription.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirSubscription(oSource).statusElement.Clone;
  if (TFhirSubscription(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactPointList.Create;
    FContactList.Assign(TFhirSubscription(oSource).FContactList);
  end;
  end_Element := TFhirSubscription(oSource).end_Element.Clone;
  reasonElement := TFhirSubscription(oSource).reasonElement.Clone;
  criteriaElement := TFhirSubscription(oSource).criteriaElement.Clone;
  errorElement := TFhirSubscription(oSource).errorElement.Clone;
  channel := TFhirSubscription(oSource).channel.Clone;
end;

function TFhirSubscription.GetResourceType : TFhirResourceType;
begin
  result := frtSubscription;
end;

procedure TFhirSubscription.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'end') Then
     list.add(self.link, 'end', FEnd_.Link);
  if (child_name = 'reason') Then
     list.add(self.link, 'reason', FReason.Link);
  if (child_name = 'criteria') Then
     list.add(self.link, 'criteria', FCriteria.Link);
  if (child_name = 'error') Then
     list.add(self.link, 'error', FError.Link);
  if (child_name = 'channel') Then
     list.add(self.link, 'channel', FChannel.Link);
end;

procedure TFhirSubscription.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactPoint', true, TFhirContactPoint, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'end', 'instant', false, TFhirInstant, FEnd_.Link));
  oList.add(TFHIRProperty.create(self, 'reason', 'string', false, TFhirString, FReason.Link));
  oList.add(TFHIRProperty.create(self, 'criteria', 'string', false, TFhirString, FCriteria.Link));
  oList.add(TFHIRProperty.create(self, 'error', 'string', false, TFhirString, FError.Link));
  oList.add(TFHIRProperty.create(self, 'channel', 'BackboneElement', false, TFhirSubscriptionChannel, FChannel.Link));
end;

function TFhirSubscription.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactPoint);
    result := propValue;
  end
  else if (propName = 'end') then
  begin
    End_Element := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'reason') then
  begin
    ReasonElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'criteria') then
  begin
    CriteriaElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'channel') then
  begin
    Channel := propValue as TFhirSubscriptionChannel;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscription.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactPoint)
  else inherited;
end;

function TFhirSubscription.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusEnum[SubscriptionStatusNull], CODES_TFhirSubscriptionStatusEnum[SubscriptionStatusNull]) 
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'end') then result := TFhirInstant.create()
  else if (propName = 'reason') then result := TFhirString.create()
  else if (propName = 'criteria') then result := TFhirString.create()
  else if (propName = 'error') then result := TFhirString.create()
  else if (propName = 'channel') then result := TFhirSubscriptionChannel.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscription.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'contact') then result := 'ContactPoint'
  else if (propName = 'end') then result := 'instant'
  else if (propName = 'reason') then result := 'string'
  else if (propName = 'criteria') then result := 'string'
  else if (propName = 'error') then result := 'string'
  else if (propName = 'channel') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscription.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'end') then End_Element := nil
  else if (propName = 'reason') then ReasonElement := nil
  else if (propName = 'criteria') then CriteriaElement := nil
  else if (propName = 'error') then ErrorElement := nil
  else if (propName = 'channel') then ChannelElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscription.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'end') then End_Element := asInstant(new)
  else if (propName = 'reason') then ReasonElement := asString(new)
  else if (propName = 'criteria') then CriteriaElement := asString(new)
  else if (propName = 'error') then ErrorElement := asString(new)
  else if (propName = 'channel') then ChannelElement := new as TFhirSubscriptionChannel
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscription.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'contact') then ContactList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscription.fhirType : string;
begin
  result := 'Subscription';
end;

function TFhirSubscription.Link : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Link);
end;

function TFhirSubscription.Clone : TFhirSubscription;
begin
  result := TFhirSubscription(inherited Clone);
end;

function TFhirSubscription.equals(other : TObject) : boolean; 
var
  o : TFhirSubscription;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscription)) then
    result := false
  else
  begin
    o := TFhirSubscription(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(end_Element, o.end_Element, true) and compareDeep(reasonElement, o.reasonElement, true) and 
      compareDeep(criteriaElement, o.criteriaElement, true) and compareDeep(errorElement, o.errorElement, true) and 
      compareDeep(channelElement, o.channelElement, true);
  end;
end;

function TFhirSubscription.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FcontactList) and isEmptyProp(FEnd_) and isEmptyProp(FReason) and isEmptyProp(FCriteria) and isEmptyProp(FError) and isEmptyProp(FChannel);
end;

procedure TFhirSubscription.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('contact');
  fields.add('end');
  fields.add('reason');
  fields.add('criteria');
  fields.add('error');
  fields.add('channel');
end;

function TFhirSubscription.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FContactList.sizeInBytes(magic));
end;

procedure TFhirSubscription.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubscription.GetStatusST : TFhirSubscriptionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSubscriptionStatusEnum(0)
  else
    result := TFhirSubscriptionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionStatusEnum, FStatus.value));
end;

procedure TFhirSubscription.SetStatusST(value : TFhirSubscriptionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusEnum[value], CODES_TFhirSubscriptionStatusEnum[value]);
end;

function TFhirSubscription.GetContactList : TFhirContactPointList;
begin
  if FContactList = nil then
    FContactList := TFhirContactPointList.Create;
  result := FContactList;
end;

function TFhirSubscription.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirSubscription.SetEnd_(value : TFhirInstant);
begin
  FEnd_.free;
  FEnd_ := value;
end;

function TFhirSubscription.GetEnd_ST : TFslDateTime;
begin
  if FEnd_ = nil then
    result := TFslDateTime.makeNull
  else
    result := FEnd_.value;
end;

procedure TFhirSubscription.SetEnd_ST(value : TFslDateTime);
begin
  if FEnd_ = nil then
    FEnd_ := TFhirInstant.create;
  FEnd_.value := value
end;

procedure TFhirSubscription.SetReason(value : TFhirString);
begin
  FReason.free;
  FReason := value;
end;

function TFhirSubscription.GetReasonST : String;
begin
  if FReason = nil then
    result := ''
  else
    result := FReason.value;
end;

procedure TFhirSubscription.SetReasonST(value : String);
begin
  if value <> '' then
  begin
    if FReason = nil then
      FReason := TFhirString.create;
    FReason.value := value
  end
  else if FReason <> nil then
    FReason.value := '';
end;

procedure TFhirSubscription.SetCriteria(value : TFhirString);
begin
  FCriteria.free;
  FCriteria := value;
end;

function TFhirSubscription.GetCriteriaST : String;
begin
  if FCriteria = nil then
    result := ''
  else
    result := FCriteria.value;
end;

procedure TFhirSubscription.SetCriteriaST(value : String);
begin
  if value <> '' then
  begin
    if FCriteria = nil then
      FCriteria := TFhirString.create;
    FCriteria.value := value
  end
  else if FCriteria <> nil then
    FCriteria.value := '';
end;

procedure TFhirSubscription.SetError(value : TFhirString);
begin
  FError.free;
  FError := value;
end;

function TFhirSubscription.GetErrorST : String;
begin
  if FError = nil then
    result := ''
  else
    result := FError.value;
end;

procedure TFhirSubscription.SetErrorST(value : String);
begin
  if value <> '' then
  begin
    if FError = nil then
      FError := TFhirString.create;
    FError.value := value
  end
  else if FError <> nil then
    FError.value := '';
end;

procedure TFhirSubscription.SetChannel(value : TFhirSubscriptionChannel);
begin
  FChannel.free;
  FChannel := value;
end;

{ TFhirSubscriptionListEnumerator }

constructor TFhirSubscriptionListEnumerator.Create(list : TFhirSubscriptionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionListEnumerator.GetCurrent : TFhirSubscription;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionList }

function TFhirSubscriptionList.AddItem(value: TFhirSubscription): TFhirSubscription;
begin
  assert(value.ClassName = 'TFhirSubscription', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscription');
  add(value);
  result := value;
end;

function TFhirSubscriptionList.Append: TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionList.GetEnumerator : TFhirSubscriptionListEnumerator;
begin
  result := TFhirSubscriptionListEnumerator.Create(self.link);
end;

function TFhirSubscriptionList.Clone: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Clone);
end;

function TFhirSubscriptionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionList.GetItemN(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscription;
end;
function TFhirSubscriptionList.IndexOf(value: TFhirSubscription): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionList.Insert(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionList.InsertItem(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionList.Item(index: Integer): TFhirSubscription;
begin
  result := TFhirSubscription(ObjectByIndex[index]);
end;

function TFhirSubscriptionList.Link: TFhirSubscriptionList;
begin
  result := TFhirSubscriptionList(inherited Link);
end;

procedure TFhirSubscriptionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionList.SetItemByIndex(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  FhirSubscriptions[index] := value;
end;

procedure TFhirSubscriptionList.SetItemN(index: Integer; value: TFhirSubscription);
begin
  assert(value is TFhirSubscription);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSCRIPTION}
{$IFDEF FHIR_SUBSCRIPTIONSTATUS}
{ TFhirSubscriptionStatusNotificationEvent }

constructor TFhirSubscriptionStatusNotificationEvent.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionStatusNotificationEvent.Destroy;
begin
  FEventNumber.free;
  FTimestamp.free;
  FFocus.free;
  FAdditionalContextList.Free;
  inherited;
end;

procedure TFhirSubscriptionStatusNotificationEvent.Assign(oSource : TFslObject);
begin
  inherited;
  eventNumberElement := TFhirSubscriptionStatusNotificationEvent(oSource).eventNumberElement.Clone;
  timestampElement := TFhirSubscriptionStatusNotificationEvent(oSource).timestampElement.Clone;
  focus := TFhirSubscriptionStatusNotificationEvent(oSource).focus.Clone;
  if (TFhirSubscriptionStatusNotificationEvent(oSource).FAdditionalContextList = nil) then
  begin
    FAdditionalContextList.free;
    FAdditionalContextList := nil;
  end
  else
  begin
    if FAdditionalContextList = nil then
      FAdditionalContextList := TFhirReferenceList.Create;
    FAdditionalContextList.Assign(TFhirSubscriptionStatusNotificationEvent(oSource).FAdditionalContextList);
  end;
end;

procedure TFhirSubscriptionStatusNotificationEvent.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'eventNumber') Then
     list.add(self.link, 'eventNumber', FEventNumber.Link);
  if (child_name = 'timestamp') Then
     list.add(self.link, 'timestamp', FTimestamp.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'additionalContext') Then
    list.addAll(self, 'additionalContext', FAdditionalContextList);
end;

procedure TFhirSubscriptionStatusNotificationEvent.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'eventNumber', 'string', false, TFhirString, FEventNumber.Link));
  oList.add(TFHIRProperty.create(self, 'timestamp', 'instant', false, TFhirInstant, FTimestamp.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', false, TFhirReference, FFocus.Link));
  oList.add(TFHIRProperty.create(self, 'additionalContext', 'Reference', true, TFhirReference, FAdditionalContextList.Link));
end;

function TFhirSubscriptionStatusNotificationEvent.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'eventNumber') then
  begin
    EventNumberElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'timestamp') then
  begin
    TimestampElement := asInstant(propValue);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'additionalContext') then
  begin
    AdditionalContextList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionStatusNotificationEvent.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'additionalContext') then AdditionalContextList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirSubscriptionStatusNotificationEvent.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'eventNumber') then result := TFhirString.create()
  else if (propName = 'timestamp') then result := TFhirInstant.create()
  else if (propName = 'focus') then result := TFhirReference.create()
  else if (propName = 'additionalContext') then result := AdditionalContextList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionStatusNotificationEvent.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'eventNumber') then result := 'string'
  else if (propName = 'timestamp') then result := 'instant'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'additionalContext') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionStatusNotificationEvent.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'eventNumber') then EventNumberElement := nil
  else if (propName = 'timestamp') then TimestampElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'additionalContext') then deletePropertyValue('additionalContext', AdditionalContextList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionStatusNotificationEvent.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'eventNumber') then EventNumberElement := asString(new)
  else if (propName = 'timestamp') then TimestampElement := asInstant(new)
  else if (propName = 'focus') then FocusElement := new as TFhirReference
  else if (propName = 'additionalContext') then replacePropertyValue('additionalContext', AdditionalContextList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionStatusNotificationEvent.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'additionalContext') then AdditionalContextList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionStatusNotificationEvent.fhirType : string;
begin
  result := 'SubscriptionStatus.notificationEvent';
end;

function TFhirSubscriptionStatusNotificationEvent.Link : TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent(inherited Link);
end;

function TFhirSubscriptionStatusNotificationEvent.Clone : TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent(inherited Clone);
end;

function TFhirSubscriptionStatusNotificationEvent.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionStatusNotificationEvent;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionStatusNotificationEvent)) then
    result := false
  else
  begin
    o := TFhirSubscriptionStatusNotificationEvent(other);
    result := compareDeep(eventNumberElement, o.eventNumberElement, true) and compareDeep(timestampElement, o.timestampElement, true) and 
      compareDeep(focusElement, o.focusElement, true) and compareDeep(additionalContextList, o.additionalContextList, true);
  end;
end;

function TFhirSubscriptionStatusNotificationEvent.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FEventNumber) and isEmptyProp(FTimestamp) and isEmptyProp(FFocus) and isEmptyProp(FadditionalContextList);
end;

procedure TFhirSubscriptionStatusNotificationEvent.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('eventNumber');
  fields.add('timestamp');
  fields.add('focus');
  fields.add('additionalContext');
end;

function TFhirSubscriptionStatusNotificationEvent.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FAdditionalContextList.sizeInBytes(magic));
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetEventNumber(value : TFhirString);
begin
  FEventNumber.free;
  FEventNumber := value;
end;

function TFhirSubscriptionStatusNotificationEvent.GetEventNumberST : String;
begin
  if FEventNumber = nil then
    result := ''
  else
    result := FEventNumber.value;
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetEventNumberST(value : String);
begin
  if value <> '' then
  begin
    if FEventNumber = nil then
      FEventNumber := TFhirString.create;
    FEventNumber.value := value
  end
  else if FEventNumber <> nil then
    FEventNumber.value := '';
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetTimestamp(value : TFhirInstant);
begin
  FTimestamp.free;
  FTimestamp := value;
end;

function TFhirSubscriptionStatusNotificationEvent.GetTimestampST : TFslDateTime;
begin
  if FTimestamp = nil then
    result := TFslDateTime.makeNull
  else
    result := FTimestamp.value;
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetTimestampST(value : TFslDateTime);
begin
  if FTimestamp = nil then
    FTimestamp := TFhirInstant.create;
  FTimestamp.value := value
end;

procedure TFhirSubscriptionStatusNotificationEvent.SetFocus(value : TFhirReference);
begin
  FFocus.free;
  FFocus := value;
end;

function TFhirSubscriptionStatusNotificationEvent.GetAdditionalContextList : TFhirReferenceList;
begin
  if FAdditionalContextList = nil then
    FAdditionalContextList := TFhirReferenceList.Create;
  result := FAdditionalContextList;
end;

function TFhirSubscriptionStatusNotificationEvent.GetHasAdditionalContextList : boolean;
begin
  result := (FAdditionalContextList <> nil) and (FAdditionalContextList.count > 0);
end;

{ TFhirSubscriptionStatusNotificationEventListEnumerator }

constructor TFhirSubscriptionStatusNotificationEventListEnumerator.Create(list : TFhirSubscriptionStatusNotificationEventList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionStatusNotificationEventListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionStatusNotificationEventListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionStatusNotificationEventListEnumerator.GetCurrent : TFhirSubscriptionStatusNotificationEvent;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionStatusNotificationEventListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionStatusNotificationEventList }

function TFhirSubscriptionStatusNotificationEventList.AddItem(value: TFhirSubscriptionStatusNotificationEvent): TFhirSubscriptionStatusNotificationEvent;
begin
  assert(value.ClassName = 'TFhirSubscriptionStatusNotificationEvent', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionStatusNotificationEvent');
  add(value);
  result := value;
end;

function TFhirSubscriptionStatusNotificationEventList.Append: TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionStatusNotificationEventList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionStatusNotificationEventList.GetEnumerator : TFhirSubscriptionStatusNotificationEventListEnumerator;
begin
  result := TFhirSubscriptionStatusNotificationEventListEnumerator.Create(self.link);
end;

function TFhirSubscriptionStatusNotificationEventList.Clone: TFhirSubscriptionStatusNotificationEventList;
begin
  result := TFhirSubscriptionStatusNotificationEventList(inherited Clone);
end;

function TFhirSubscriptionStatusNotificationEventList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionStatusNotificationEventList.GetItemN(index: Integer): TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent(ObjectByIndex[index]);
end;

function TFhirSubscriptionStatusNotificationEventList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionStatusNotificationEvent;
end;
function TFhirSubscriptionStatusNotificationEventList.IndexOf(value: TFhirSubscriptionStatusNotificationEvent): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionStatusNotificationEventList.Insert(index: Integer): TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionStatusNotificationEventList.InsertItem(index: Integer; value: TFhirSubscriptionStatusNotificationEvent);
begin
  assert(value is TFhirSubscriptionStatusNotificationEvent);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionStatusNotificationEventList.Item(index: Integer): TFhirSubscriptionStatusNotificationEvent;
begin
  result := TFhirSubscriptionStatusNotificationEvent(ObjectByIndex[index]);
end;

function TFhirSubscriptionStatusNotificationEventList.Link: TFhirSubscriptionStatusNotificationEventList;
begin
  result := TFhirSubscriptionStatusNotificationEventList(inherited Link);
end;

procedure TFhirSubscriptionStatusNotificationEventList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionStatusNotificationEventList.SetItemByIndex(index: Integer; value: TFhirSubscriptionStatusNotificationEvent);
begin
  assert(value is TFhirSubscriptionStatusNotificationEvent);
  FhirSubscriptionStatusNotificationEvents[index] := value;
end;

procedure TFhirSubscriptionStatusNotificationEventList.SetItemN(index: Integer; value: TFhirSubscriptionStatusNotificationEvent);
begin
  assert(value is TFhirSubscriptionStatusNotificationEvent);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionStatus }

constructor TFhirSubscriptionStatus.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionStatus.Destroy;
begin
  FStatus.free;
  FType_.free;
  FEventsSinceSubscriptionStart.free;
  FEventsInNotification.free;
  FNotificationEventList.Free;
  FSubscription.free;
  FTopic.free;
  FErrorList.Free;
  inherited;
end;

procedure TFhirSubscriptionStatus.Assign(oSource : TFslObject);
begin
  inherited;
  statusElement := TFhirSubscriptionStatus(oSource).statusElement.Clone;
  type_Element := TFhirSubscriptionStatus(oSource).type_Element.Clone;
  eventsSinceSubscriptionStartElement := TFhirSubscriptionStatus(oSource).eventsSinceSubscriptionStartElement.Clone;
  eventsInNotificationElement := TFhirSubscriptionStatus(oSource).eventsInNotificationElement.Clone;
  if (TFhirSubscriptionStatus(oSource).FNotificationEventList = nil) then
  begin
    FNotificationEventList.free;
    FNotificationEventList := nil;
  end
  else
  begin
    if FNotificationEventList = nil then
      FNotificationEventList := TFhirSubscriptionStatusNotificationEventList.Create;
    FNotificationEventList.Assign(TFhirSubscriptionStatus(oSource).FNotificationEventList);
  end;
  subscription := TFhirSubscriptionStatus(oSource).subscription.Clone;
  topicElement := TFhirSubscriptionStatus(oSource).topicElement.Clone;
  if (TFhirSubscriptionStatus(oSource).FErrorList = nil) then
  begin
    FErrorList.free;
    FErrorList := nil;
  end
  else
  begin
    if FErrorList = nil then
      FErrorList := TFhirCodeableConceptList.Create;
    FErrorList.Assign(TFhirSubscriptionStatus(oSource).FErrorList);
  end;
end;

function TFhirSubscriptionStatus.GetResourceType : TFhirResourceType;
begin
  result := frtSubscriptionStatus;
end;

procedure TFhirSubscriptionStatus.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'eventsSinceSubscriptionStart') Then
     list.add(self.link, 'eventsSinceSubscriptionStart', FEventsSinceSubscriptionStart.Link);
  if (child_name = 'eventsInNotification') Then
     list.add(self.link, 'eventsInNotification', FEventsInNotification.Link);
  if (child_name = 'notificationEvent') Then
    list.addAll(self, 'notificationEvent', FNotificationEventList);
  if (child_name = 'subscription') Then
     list.add(self.link, 'subscription', FSubscription.Link);
  if (child_name = 'topic') Then
     list.add(self.link, 'topic', FTopic.Link);
  if (child_name = 'error') Then
    list.addAll(self, 'error', FErrorList);
end;

procedure TFhirSubscriptionStatus.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'eventsSinceSubscriptionStart', 'string', false, TFhirString, FEventsSinceSubscriptionStart.Link));
  oList.add(TFHIRProperty.create(self, 'eventsInNotification', 'integer', false, TFhirInteger, FEventsInNotification.Link));
  oList.add(TFHIRProperty.create(self, 'notificationEvent', 'BackboneElement', true, TFhirSubscriptionStatusNotificationEvent, FNotificationEventList.Link));
  oList.add(TFHIRProperty.create(self, 'subscription', 'Reference', false, TFhirReference, FSubscription.Link));
  oList.add(TFHIRProperty.create(self, 'topic', 'canonical', false, TFhirCanonical, FTopic.Link));
  oList.add(TFHIRProperty.create(self, 'error', 'CodeableConcept', true, TFhirCodeableConcept, FErrorList.Link));
end;

function TFhirSubscriptionStatus.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirSubscriptionNotificationTypeEnum, CODES_TFhirSubscriptionNotificationTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'eventsSinceSubscriptionStart') then
  begin
    EventsSinceSubscriptionStartElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'eventsInNotification') then
  begin
    EventsInNotificationElement := asInteger(propValue);
    result := propValue;
  end
  else if (propName = 'notificationEvent') then
  begin
    NotificationEventList.add(propValue as TFhirSubscriptionStatusNotificationEvent);
    result := propValue;
  end
  else if (propName = 'subscription') then
  begin
    Subscription := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'topic') then
  begin
    TopicElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'error') then
  begin
    ErrorList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionStatus.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'notificationEvent') then NotificationEventList.insertItem(index, propValue as TFhirSubscriptionStatusNotificationEvent)
  else if (propName = 'error') then ErrorList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirSubscriptionStatus.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusEnum[SubscriptionStatusNull], CODES_TFhirSubscriptionStatusEnum[SubscriptionStatusNull]) 
  else if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirSubscriptionNotificationTypeEnum[SubscriptionNotificationTypeNull], CODES_TFhirSubscriptionNotificationTypeEnum[SubscriptionNotificationTypeNull]) 
  else if (propName = 'eventsSinceSubscriptionStart') then result := TFhirString.create()
  else if (propName = 'eventsInNotification') then result := TFhirInteger.create()
  else if (propName = 'notificationEvent') then result := NotificationEventList.new()
  else if (propName = 'subscription') then result := TFhirReference.create()
  else if (propName = 'topic') then result := TFhirCanonical.create()
  else if (propName = 'error') then result := ErrorList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionStatus.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'status') then result := 'code'
  else if (propName = 'type') then result := 'code'
  else if (propName = 'eventsSinceSubscriptionStart') then result := 'string'
  else if (propName = 'eventsInNotification') then result := 'integer'
  else if (propName = 'notificationEvent') then result := 'BackboneElement'
  else if (propName = 'subscription') then result := 'Reference'
  else if (propName = 'topic') then result := 'canonical'
  else if (propName = 'error') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionStatus.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := nil
  else if (propName = 'type') then Type_Element := nil
  else if (propName = 'eventsSinceSubscriptionStart') then EventsSinceSubscriptionStartElement := nil
  else if (propName = 'eventsInNotification') then EventsInNotificationElement := nil
  else if (propName = 'notificationEvent') then deletePropertyValue('notificationEvent', NotificationEventList, value)
  else if (propName = 'subscription') then SubscriptionElement := nil
  else if (propName = 'topic') then TopicElement := nil
  else if (propName = 'error') then deletePropertyValue('error', ErrorList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionStatus.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirSubscriptionStatusEnum, CODES_TFhirSubscriptionStatusEnum, new)
  else if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirSubscriptionNotificationTypeEnum, CODES_TFhirSubscriptionNotificationTypeEnum, new)
  else if (propName = 'eventsSinceSubscriptionStart') then EventsSinceSubscriptionStartElement := asString(new)
  else if (propName = 'eventsInNotification') then EventsInNotificationElement := asInteger(new)
  else if (propName = 'notificationEvent') then replacePropertyValue('notificationEvent', NotificationEventList, existing, new)
  else if (propName = 'subscription') then SubscriptionElement := new as TFhirReference
  else if (propName = 'topic') then TopicElement := asCanonical(new)
  else if (propName = 'error') then replacePropertyValue('error', ErrorList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionStatus.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'notificationEvent') then NotificationEventList.move(source, destination)
  else if (propName = 'error') then ErrorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionStatus.fhirType : string;
begin
  result := 'SubscriptionStatus';
end;

function TFhirSubscriptionStatus.Link : TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus(inherited Link);
end;

function TFhirSubscriptionStatus.Clone : TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus(inherited Clone);
end;

function TFhirSubscriptionStatus.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionStatus;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionStatus)) then
    result := false
  else
  begin
    o := TFhirSubscriptionStatus(other);
    result := compareDeep(statusElement, o.statusElement, true) and compareDeep(type_Element, o.type_Element, true) and 
      compareDeep(eventsSinceSubscriptionStartElement, o.eventsSinceSubscriptionStartElement, true) and 
      compareDeep(eventsInNotificationElement, o.eventsInNotificationElement, true) and 
      compareDeep(notificationEventList, o.notificationEventList, true) and compareDeep(subscriptionElement, o.subscriptionElement, true) and 
      compareDeep(topicElement, o.topicElement, true) and compareDeep(errorList, o.errorList, true);
  end;
end;

function TFhirSubscriptionStatus.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FStatus) and isEmptyProp(FType_) and isEmptyProp(FEventsSinceSubscriptionStart) and isEmptyProp(FEventsInNotification) and isEmptyProp(FnotificationEventList) and isEmptyProp(FSubscription) and isEmptyProp(FTopic) and isEmptyProp(FerrorList);
end;

procedure TFhirSubscriptionStatus.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('status');
  fields.add('type');
  fields.add('eventsSinceSubscriptionStart');
  fields.add('eventsInNotification');
  fields.add('notificationEvent');
  fields.add('subscription');
  fields.add('topic');
  fields.add('error');
end;

function TFhirSubscriptionStatus.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FNotificationEventList.sizeInBytes(magic));
  inc(result, FErrorList.sizeInBytes(magic));
end;

procedure TFhirSubscriptionStatus.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubscriptionStatus.GetStatusST : TFhirSubscriptionStatusEnum;
begin
  if FStatus = nil then
    result := TFhirSubscriptionStatusEnum(0)
  else
    result := TFhirSubscriptionStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionStatusEnum, FStatus.value));
end;

procedure TFhirSubscriptionStatus.SetStatusST(value : TFhirSubscriptionStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirSubscriptionStatusEnum[value], CODES_TFhirSubscriptionStatusEnum[value]);
end;

procedure TFhirSubscriptionStatus.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirSubscriptionStatus.GetType_ST : TFhirSubscriptionNotificationTypeEnum;
begin
  if FType_ = nil then
    result := TFhirSubscriptionNotificationTypeEnum(0)
  else
    result := TFhirSubscriptionNotificationTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionNotificationTypeEnum, FType_.value));
end;

procedure TFhirSubscriptionStatus.SetType_ST(value : TFhirSubscriptionNotificationTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirSubscriptionNotificationTypeEnum[value], CODES_TFhirSubscriptionNotificationTypeEnum[value]);
end;

procedure TFhirSubscriptionStatus.SetEventsSinceSubscriptionStart(value : TFhirString);
begin
  FEventsSinceSubscriptionStart.free;
  FEventsSinceSubscriptionStart := value;
end;

function TFhirSubscriptionStatus.GetEventsSinceSubscriptionStartST : String;
begin
  if FEventsSinceSubscriptionStart = nil then
    result := ''
  else
    result := FEventsSinceSubscriptionStart.value;
end;

procedure TFhirSubscriptionStatus.SetEventsSinceSubscriptionStartST(value : String);
begin
  if value <> '' then
  begin
    if FEventsSinceSubscriptionStart = nil then
      FEventsSinceSubscriptionStart := TFhirString.create;
    FEventsSinceSubscriptionStart.value := value
  end
  else if FEventsSinceSubscriptionStart <> nil then
    FEventsSinceSubscriptionStart.value := '';
end;

procedure TFhirSubscriptionStatus.SetEventsInNotification(value : TFhirInteger);
begin
  FEventsInNotification.free;
  FEventsInNotification := value;
end;

function TFhirSubscriptionStatus.GetEventsInNotificationST : String;
begin
  if FEventsInNotification = nil then
    result := ''
  else
    result := FEventsInNotification.value;
end;

procedure TFhirSubscriptionStatus.SetEventsInNotificationST(value : String);
begin
  if value <> '' then
  begin
    if FEventsInNotification = nil then
      FEventsInNotification := TFhirInteger.create;
    FEventsInNotification.value := value
  end
  else if FEventsInNotification <> nil then
    FEventsInNotification.value := '';
end;

function TFhirSubscriptionStatus.GetNotificationEventList : TFhirSubscriptionStatusNotificationEventList;
begin
  if FNotificationEventList = nil then
    FNotificationEventList := TFhirSubscriptionStatusNotificationEventList.Create;
  result := FNotificationEventList;
end;

function TFhirSubscriptionStatus.GetHasNotificationEventList : boolean;
begin
  result := (FNotificationEventList <> nil) and (FNotificationEventList.count > 0);
end;

procedure TFhirSubscriptionStatus.SetSubscription(value : TFhirReference);
begin
  FSubscription.free;
  FSubscription := value;
end;

procedure TFhirSubscriptionStatus.SetTopic(value : TFhirCanonical);
begin
  FTopic.free;
  FTopic := value;
end;

function TFhirSubscriptionStatus.GetTopicST : String;
begin
  if FTopic = nil then
    result := ''
  else
    result := FTopic.value;
end;

procedure TFhirSubscriptionStatus.SetTopicST(value : String);
begin
  if value <> '' then
  begin
    if FTopic = nil then
      FTopic := TFhirCanonical.create;
    FTopic.value := value
  end
  else if FTopic <> nil then
    FTopic.value := '';
end;

function TFhirSubscriptionStatus.GetErrorList : TFhirCodeableConceptList;
begin
  if FErrorList = nil then
    FErrorList := TFhirCodeableConceptList.Create;
  result := FErrorList;
end;

function TFhirSubscriptionStatus.GetHasErrorList : boolean;
begin
  result := (FErrorList <> nil) and (FErrorList.count > 0);
end;

{ TFhirSubscriptionStatusListEnumerator }

constructor TFhirSubscriptionStatusListEnumerator.Create(list : TFhirSubscriptionStatusList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionStatusListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionStatusListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionStatusListEnumerator.GetCurrent : TFhirSubscriptionStatus;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionStatusListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionStatusList }

function TFhirSubscriptionStatusList.AddItem(value: TFhirSubscriptionStatus): TFhirSubscriptionStatus;
begin
  assert(value.ClassName = 'TFhirSubscriptionStatus', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionStatus');
  add(value);
  result := value;
end;

function TFhirSubscriptionStatusList.Append: TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionStatusList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionStatusList.GetEnumerator : TFhirSubscriptionStatusListEnumerator;
begin
  result := TFhirSubscriptionStatusListEnumerator.Create(self.link);
end;

function TFhirSubscriptionStatusList.Clone: TFhirSubscriptionStatusList;
begin
  result := TFhirSubscriptionStatusList(inherited Clone);
end;

function TFhirSubscriptionStatusList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionStatusList.GetItemN(index: Integer): TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus(ObjectByIndex[index]);
end;

function TFhirSubscriptionStatusList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionStatus;
end;
function TFhirSubscriptionStatusList.IndexOf(value: TFhirSubscriptionStatus): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionStatusList.Insert(index: Integer): TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionStatusList.InsertItem(index: Integer; value: TFhirSubscriptionStatus);
begin
  assert(value is TFhirSubscriptionStatus);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionStatusList.Item(index: Integer): TFhirSubscriptionStatus;
begin
  result := TFhirSubscriptionStatus(ObjectByIndex[index]);
end;

function TFhirSubscriptionStatusList.Link: TFhirSubscriptionStatusList;
begin
  result := TFhirSubscriptionStatusList(inherited Link);
end;

procedure TFhirSubscriptionStatusList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionStatusList.SetItemByIndex(index: Integer; value: TFhirSubscriptionStatus);
begin
  assert(value is TFhirSubscriptionStatus);
  FhirSubscriptionStatuses[index] := value;
end;

procedure TFhirSubscriptionStatusList.SetItemN(index: Integer; value: TFhirSubscriptionStatus);
begin
  assert(value is TFhirSubscriptionStatus);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSCRIPTIONSTATUS}
{$IFDEF FHIR_SUBSCRIPTIONTOPIC}
{ TFhirSubscriptionTopicResourceTrigger }

constructor TFhirSubscriptionTopicResourceTrigger.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicResourceTrigger.Destroy;
begin
  FDescription.free;
  FResource.free;
  FSupportedInteraction.Free;
  FQueryCriteria.free;
  FFhirPathCriteria.free;
  inherited;
end;

procedure TFhirSubscriptionTopicResourceTrigger.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSubscriptionTopicResourceTrigger(oSource).descriptionElement.Clone;
  resourceElement := TFhirSubscriptionTopicResourceTrigger(oSource).resourceElement.Clone;
  if (TFhirSubscriptionTopicResourceTrigger(oSource).FSupportedInteraction = nil) then
  begin
    FSupportedInteraction.free;
    FSupportedInteraction := nil;
  end
  else
  begin
    FSupportedInteraction := TFhirEnumList.Create(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum);
    FSupportedInteraction.Assign(TFhirSubscriptionTopicResourceTrigger(oSource).FSupportedInteraction);
  end;
  queryCriteria := TFhirSubscriptionTopicResourceTrigger(oSource).queryCriteria.Clone;
  fhirPathCriteriaElement := TFhirSubscriptionTopicResourceTrigger(oSource).fhirPathCriteriaElement.Clone;
end;

procedure TFhirSubscriptionTopicResourceTrigger.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'supportedInteraction') Then
     list.addAll(self, 'supportedInteraction', FSupportedInteraction);
  if (child_name = 'queryCriteria') Then
     list.add(self.link, 'queryCriteria', FQueryCriteria.Link);
  if (child_name = 'fhirPathCriteria') Then
     list.add(self.link, 'fhirPathCriteria', FFhirPathCriteria.Link);
end;

procedure TFhirSubscriptionTopicResourceTrigger.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'uri', false, TFhirUri, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'supportedInteraction', 'code', true, TFhirEnum, FSupportedInteraction.Link));
  oList.add(TFHIRProperty.create(self, 'queryCriteria', 'BackboneElement', false, TFhirSubscriptionTopicResourceTriggerQueryCriteria, FQueryCriteria.Link));
  oList.add(TFHIRProperty.create(self, 'fhirPathCriteria', 'string', false, TFhirString, FFhirPathCriteria.Link));
end;

function TFhirSubscriptionTopicResourceTrigger.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'supportedInteraction') then
  begin
    SupportedInteractionList.add(asEnum(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum, propValue));
    result := propValue;
  end
  else if (propName = 'queryCriteria') then
  begin
    QueryCriteria := propValue as TFhirSubscriptionTopicResourceTriggerQueryCriteria;
    result := propValue;
  end
  else if (propName = 'fhirPathCriteria') then
  begin
    FhirPathCriteriaElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicResourceTrigger.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'supportedInteraction') then FSupportedInteraction.insertItem(index, asEnum(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum, propValue))
  else inherited;
end;

function TFhirSubscriptionTopicResourceTrigger.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'resource') then result := TFhirUri.create()
  else if (propName = 'queryCriteria') then result := TFhirSubscriptionTopicResourceTriggerQueryCriteria.create()
  else if (propName = 'fhirPathCriteria') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicResourceTrigger.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'resource') then result := 'uri'
  else if (propName = 'supportedInteraction') then result := 'code'
  else if (propName = 'queryCriteria') then result := 'BackboneElement'
  else if (propName = 'fhirPathCriteria') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicResourceTrigger.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'queryCriteria') then QueryCriteriaElement := nil
  else if (propName = 'fhirPathCriteria') then FhirPathCriteriaElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicResourceTrigger.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'resource') then ResourceElement := asUri(new)
  else if (propName = 'queryCriteria') then QueryCriteriaElement := new as TFhirSubscriptionTopicResourceTriggerQueryCriteria
  else if (propName = 'fhirPathCriteria') then FhirPathCriteriaElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicResourceTrigger.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'supportedInteraction') then FSupportedInteraction.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicResourceTrigger.fhirType : string;
begin
  result := 'SubscriptionTopic.resourceTrigger';
end;

function TFhirSubscriptionTopicResourceTrigger.Link : TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger(inherited Link);
end;

function TFhirSubscriptionTopicResourceTrigger.Clone : TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger(inherited Clone);
end;

function TFhirSubscriptionTopicResourceTrigger.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicResourceTrigger;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicResourceTrigger)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicResourceTrigger(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(resourceElement, o.resourceElement, true) and 
      compareDeep(supportedInteractionList, o.supportedInteractionList, true) and compareDeep(queryCriteriaElement, o.queryCriteriaElement, true) and 
      compareDeep(fhirPathCriteriaElement, o.fhirPathCriteriaElement, true);
  end;
end;

function TFhirSubscriptionTopicResourceTrigger.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FResource) and isEmptyProp(FSupportedInteraction) and isEmptyProp(FQueryCriteria) and isEmptyProp(FFhirPathCriteria);
end;

procedure TFhirSubscriptionTopicResourceTrigger.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('resource');
  fields.add('supportedInteraction');
  fields.add('queryCriteria');
  fields.add('fhirPathCriteria');
end;

function TFhirSubscriptionTopicResourceTrigger.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FSupportedInteraction.sizeInBytes(magic));
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubscriptionTopicResourceTrigger.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetResource(value : TFhirUri);
begin
  FResource.free;
  FResource := value;
end;

function TFhirSubscriptionTopicResourceTrigger.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirUri.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

function TFhirSubscriptionTopicResourceTrigger.GetSupportedInteraction : TFhirEnumList;
begin
  if FSupportedInteraction = nil then
    FSupportedInteraction := TFhirEnumList.Create(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum);
  result := FSupportedInteraction;
end;

function TFhirSubscriptionTopicResourceTrigger.GetHasSupportedInteraction : boolean;
begin
  result := (FSupportedInteraction <> nil) and (FSupportedInteraction.count > 0);
end;

function TFhirSubscriptionTopicResourceTrigger.GetSupportedInteractionST : TFhirInteractionTriggerEnumList;
  var i : integer;
begin
  result := [];
  if FsupportedInteraction <> nil then
    for i := 0 to FsupportedInteraction.count - 1 do
      result := result + [TFhirInteractionTriggerEnum(StringArrayIndexOfSensitive(CODES_TFhirInteractionTriggerEnum, FsupportedInteraction[i].value))];
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetSupportedInteractionST(value : TFhirInteractionTriggerEnumList);
var a : TFhirInteractionTriggerEnum;
begin
  if FsupportedInteraction = nil then
    FsupportedInteraction := TFhirEnumList.create(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum);
  FsupportedInteraction.clear;
  for a := low(TFhirInteractionTriggerEnum) to high(TFhirInteractionTriggerEnum) do
    if a in value then
      begin
         if FsupportedInteraction = nil then
           FsupportedInteraction := TFhirEnumList.create(SYSTEMS_TFhirInteractionTriggerEnum, CODES_TFhirInteractionTriggerEnum);
         FsupportedInteraction.add(TFhirEnum.create(SYSTEMS_TFhirInteractionTriggerEnum[a], CODES_TFhirInteractionTriggerEnum[a]));
      end;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetQueryCriteria(value : TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  FQueryCriteria.free;
  FQueryCriteria := value;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetFhirPathCriteria(value : TFhirString);
begin
  FFhirPathCriteria.free;
  FFhirPathCriteria := value;
end;

function TFhirSubscriptionTopicResourceTrigger.GetFhirPathCriteriaST : String;
begin
  if FFhirPathCriteria = nil then
    result := ''
  else
    result := FFhirPathCriteria.value;
end;

procedure TFhirSubscriptionTopicResourceTrigger.SetFhirPathCriteriaST(value : String);
begin
  if value <> '' then
  begin
    if FFhirPathCriteria = nil then
      FFhirPathCriteria := TFhirString.create;
    FFhirPathCriteria.value := value
  end
  else if FFhirPathCriteria <> nil then
    FFhirPathCriteria.value := '';
end;

{ TFhirSubscriptionTopicResourceTriggerListEnumerator }

constructor TFhirSubscriptionTopicResourceTriggerListEnumerator.Create(list : TFhirSubscriptionTopicResourceTriggerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicResourceTriggerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicResourceTriggerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicResourceTriggerListEnumerator.GetCurrent : TFhirSubscriptionTopicResourceTrigger;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicResourceTriggerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicResourceTriggerList }

function TFhirSubscriptionTopicResourceTriggerList.AddItem(value: TFhirSubscriptionTopicResourceTrigger): TFhirSubscriptionTopicResourceTrigger;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicResourceTrigger', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicResourceTrigger');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicResourceTriggerList.Append: TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicResourceTriggerList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicResourceTriggerList.GetEnumerator : TFhirSubscriptionTopicResourceTriggerListEnumerator;
begin
  result := TFhirSubscriptionTopicResourceTriggerListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicResourceTriggerList.Clone: TFhirSubscriptionTopicResourceTriggerList;
begin
  result := TFhirSubscriptionTopicResourceTriggerList(inherited Clone);
end;

function TFhirSubscriptionTopicResourceTriggerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicResourceTriggerList.GetItemN(index: Integer): TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicResourceTriggerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicResourceTrigger;
end;
function TFhirSubscriptionTopicResourceTriggerList.IndexOf(value: TFhirSubscriptionTopicResourceTrigger): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicResourceTriggerList.Insert(index: Integer): TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicResourceTriggerList.InsertItem(index: Integer; value: TFhirSubscriptionTopicResourceTrigger);
begin
  assert(value is TFhirSubscriptionTopicResourceTrigger);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicResourceTriggerList.Item(index: Integer): TFhirSubscriptionTopicResourceTrigger;
begin
  result := TFhirSubscriptionTopicResourceTrigger(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicResourceTriggerList.Link: TFhirSubscriptionTopicResourceTriggerList;
begin
  result := TFhirSubscriptionTopicResourceTriggerList(inherited Link);
end;

procedure TFhirSubscriptionTopicResourceTriggerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicResourceTriggerList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicResourceTrigger);
begin
  assert(value is TFhirSubscriptionTopicResourceTrigger);
  FhirSubscriptionTopicResourceTriggers[index] := value;
end;

procedure TFhirSubscriptionTopicResourceTriggerList.SetItemN(index: Integer; value: TFhirSubscriptionTopicResourceTrigger);
begin
  assert(value is TFhirSubscriptionTopicResourceTrigger);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopicResourceTriggerQueryCriteria }

constructor TFhirSubscriptionTopicResourceTriggerQueryCriteria.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicResourceTriggerQueryCriteria.Destroy;
begin
  FPrevious.free;
  FResultForCreate.free;
  FCurrent.free;
  FResultForDelete.free;
  FRequireBoth.free;
  inherited;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.Assign(oSource : TFslObject);
begin
  inherited;
  previousElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).previousElement.Clone;
  resultForCreateElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).resultForCreateElement.Clone;
  currentElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).currentElement.Clone;
  resultForDeleteElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).resultForDeleteElement.Clone;
  requireBothElement := TFhirSubscriptionTopicResourceTriggerQueryCriteria(oSource).requireBothElement.Clone;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'previous') Then
     list.add(self.link, 'previous', FPrevious.Link);
  if (child_name = 'resultForCreate') Then
     list.add(self.link, 'resultForCreate', FResultForCreate.Link);
  if (child_name = 'current') Then
     list.add(self.link, 'current', FCurrent.Link);
  if (child_name = 'resultForDelete') Then
     list.add(self.link, 'resultForDelete', FResultForDelete.Link);
  if (child_name = 'requireBoth') Then
     list.add(self.link, 'requireBoth', FRequireBoth.Link);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'previous', 'string', false, TFhirString, FPrevious.Link));
  oList.add(TFHIRProperty.create(self, 'resultForCreate', 'code', false, TFhirEnum, FResultForCreate.Link));
  oList.add(TFHIRProperty.create(self, 'current', 'string', false, TFhirString, FCurrent.Link));
  oList.add(TFHIRProperty.create(self, 'resultForDelete', 'code', false, TFhirEnum, FResultForDelete.Link));
  oList.add(TFHIRProperty.create(self, 'requireBoth', 'boolean', false, TFhirBoolean, FRequireBoth.Link));
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'previous') then
  begin
    PreviousElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'resultForCreate') then
  begin
    ResultForCreateElement := asEnum(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, CODES_TFhirCriteriaNotExistsBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'current') then
  begin
    CurrentElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'resultForDelete') then
  begin
    ResultForDeleteElement := asEnum(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, CODES_TFhirCriteriaNotExistsBehaviorEnum, propValue);
    result := propValue;
  end
  else if (propName = 'requireBoth') then
  begin
    RequireBothElement := asBoolean(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'previous') then result := TFhirString.create()
  else if (propName = 'resultForCreate') then result := TFhirEnum.create(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum[CriteriaNotExistsBehaviorNull], CODES_TFhirCriteriaNotExistsBehaviorEnum[CriteriaNotExistsBehaviorNull]) 
  else if (propName = 'current') then result := TFhirString.create()
  else if (propName = 'resultForDelete') then result := TFhirEnum.create(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum[CriteriaNotExistsBehaviorNull], CODES_TFhirCriteriaNotExistsBehaviorEnum[CriteriaNotExistsBehaviorNull]) 
  else if (propName = 'requireBoth') then result := TFhirBoolean.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'previous') then result := 'string'
  else if (propName = 'resultForCreate') then result := 'code'
  else if (propName = 'current') then result := 'string'
  else if (propName = 'resultForDelete') then result := 'code'
  else if (propName = 'requireBoth') then result := 'boolean'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'previous') then PreviousElement := nil
  else if (propName = 'resultForCreate') then ResultForCreateElement := nil
  else if (propName = 'current') then CurrentElement := nil
  else if (propName = 'resultForDelete') then ResultForDeleteElement := nil
  else if (propName = 'requireBoth') then RequireBothElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'previous') then PreviousElement := asString(new)
  else if (propName = 'resultForCreate') then ResultForCreateElement := asEnum(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, CODES_TFhirCriteriaNotExistsBehaviorEnum, new)
  else if (propName = 'current') then CurrentElement := asString(new)
  else if (propName = 'resultForDelete') then ResultForDeleteElement := asEnum(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum, CODES_TFhirCriteriaNotExistsBehaviorEnum, new)
  else if (propName = 'requireBoth') then RequireBothElement := asBoolean(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.fhirType : string;
begin
  result := 'SubscriptionTopic.resourceTrigger.queryCriteria';
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.Link : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria(inherited Link);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.Clone : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria(inherited Clone);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicResourceTriggerQueryCriteria)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicResourceTriggerQueryCriteria(other);
    result := compareDeep(previousElement, o.previousElement, true) and compareDeep(resultForCreateElement, o.resultForCreateElement, true) and 
      compareDeep(currentElement, o.currentElement, true) and compareDeep(resultForDeleteElement, o.resultForDeleteElement, true) and 
      compareDeep(requireBothElement, o.requireBothElement, true);
  end;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FPrevious) and isEmptyProp(FResultForCreate) and isEmptyProp(FCurrent) and isEmptyProp(FResultForDelete) and isEmptyProp(FRequireBoth);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('previous');
  fields.add('resultForCreate');
  fields.add('current');
  fields.add('resultForDelete');
  fields.add('requireBoth');
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetPrevious(value : TFhirString);
begin
  FPrevious.free;
  FPrevious := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetPreviousST : String;
begin
  if FPrevious = nil then
    result := ''
  else
    result := FPrevious.value;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetPreviousST(value : String);
begin
  if value <> '' then
  begin
    if FPrevious = nil then
      FPrevious := TFhirString.create;
    FPrevious.value := value
  end
  else if FPrevious <> nil then
    FPrevious.value := '';
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetResultForCreate(value : TFhirEnum);
begin
  FResultForCreate.free;
  FResultForCreate := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetResultForCreateST : TFhirCriteriaNotExistsBehaviorEnum;
begin
  if FResultForCreate = nil then
    result := TFhirCriteriaNotExistsBehaviorEnum(0)
  else
    result := TFhirCriteriaNotExistsBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirCriteriaNotExistsBehaviorEnum, FResultForCreate.value));
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetResultForCreateST(value : TFhirCriteriaNotExistsBehaviorEnum);
begin
  if ord(value) = 0 then
    ResultForCreateElement := nil
  else
    ResultForCreateElement := TFhirEnum.create(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum[value], CODES_TFhirCriteriaNotExistsBehaviorEnum[value]);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetCurrent(value : TFhirString);
begin
  FCurrent.free;
  FCurrent := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetCurrentST : String;
begin
  if FCurrent = nil then
    result := ''
  else
    result := FCurrent.value;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetCurrentST(value : String);
begin
  if value <> '' then
  begin
    if FCurrent = nil then
      FCurrent := TFhirString.create;
    FCurrent.value := value
  end
  else if FCurrent <> nil then
    FCurrent.value := '';
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetResultForDelete(value : TFhirEnum);
begin
  FResultForDelete.free;
  FResultForDelete := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetResultForDeleteST : TFhirCriteriaNotExistsBehaviorEnum;
begin
  if FResultForDelete = nil then
    result := TFhirCriteriaNotExistsBehaviorEnum(0)
  else
    result := TFhirCriteriaNotExistsBehaviorEnum(StringArrayIndexOfSensitive(CODES_TFhirCriteriaNotExistsBehaviorEnum, FResultForDelete.value));
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetResultForDeleteST(value : TFhirCriteriaNotExistsBehaviorEnum);
begin
  if ord(value) = 0 then
    ResultForDeleteElement := nil
  else
    ResultForDeleteElement := TFhirEnum.create(SYSTEMS_TFhirCriteriaNotExistsBehaviorEnum[value], CODES_TFhirCriteriaNotExistsBehaviorEnum[value]);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetRequireBoth(value : TFhirBoolean);
begin
  FRequireBoth.free;
  FRequireBoth := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteria.GetRequireBothST : Boolean;
begin
  if FRequireBoth = nil then
    result := false
  else
    result := FRequireBoth.value;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteria.SetRequireBothST(value : Boolean);
begin
  if FRequireBoth = nil then
    FRequireBoth := TFhirBoolean.create;
  FRequireBoth.value := value
end;

{ TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator }

constructor TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.Create(list : TFhirSubscriptionTopicResourceTriggerQueryCriteriaList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.GetCurrent : TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicResourceTriggerQueryCriteriaList }

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.AddItem(value: TFhirSubscriptionTopicResourceTriggerQueryCriteria): TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicResourceTriggerQueryCriteria', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicResourceTriggerQueryCriteria');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Append: TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.GetEnumerator : TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteriaListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Clone: TFhirSubscriptionTopicResourceTriggerQueryCriteriaList;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteriaList(inherited Clone);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.GetItemN(index: Integer): TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria;
end;
function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.IndexOf(value: TFhirSubscriptionTopicResourceTriggerQueryCriteria): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Insert(index: Integer): TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.InsertItem(index: Integer; value: TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  assert(value is TFhirSubscriptionTopicResourceTriggerQueryCriteria);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Item(index: Integer): TFhirSubscriptionTopicResourceTriggerQueryCriteria;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteria(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Link: TFhirSubscriptionTopicResourceTriggerQueryCriteriaList;
begin
  result := TFhirSubscriptionTopicResourceTriggerQueryCriteriaList(inherited Link);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  assert(value is TFhirSubscriptionTopicResourceTriggerQueryCriteria);
  FhirSubscriptionTopicResourceTriggerQueryCriteria[index] := value;
end;

procedure TFhirSubscriptionTopicResourceTriggerQueryCriteriaList.SetItemN(index: Integer; value: TFhirSubscriptionTopicResourceTriggerQueryCriteria);
begin
  assert(value is TFhirSubscriptionTopicResourceTriggerQueryCriteria);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopicEventTrigger }

constructor TFhirSubscriptionTopicEventTrigger.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicEventTrigger.Destroy;
begin
  FDescription.free;
  FEvent.free;
  FResource.free;
  inherited;
end;

procedure TFhirSubscriptionTopicEventTrigger.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSubscriptionTopicEventTrigger(oSource).descriptionElement.Clone;
  event := TFhirSubscriptionTopicEventTrigger(oSource).event.Clone;
  resourceElement := TFhirSubscriptionTopicEventTrigger(oSource).resourceElement.Clone;
end;

procedure TFhirSubscriptionTopicEventTrigger.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'event') Then
     list.add(self.link, 'event', FEvent.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
end;

procedure TFhirSubscriptionTopicEventTrigger.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'event', 'CodeableConcept', false, TFhirCodeableConcept, FEvent.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'uri', false, TFhirUri, FResource.Link));
end;

function TFhirSubscriptionTopicEventTrigger.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'event') then
  begin
    Event := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicEventTrigger.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirSubscriptionTopicEventTrigger.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'event') then result := TFhirCodeableConcept.create()
  else if (propName = 'resource') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicEventTrigger.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'event') then result := 'CodeableConcept'
  else if (propName = 'resource') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicEventTrigger.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'event') then EventElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicEventTrigger.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'event') then EventElement := new as TFhirCodeableConcept
  else if (propName = 'resource') then ResourceElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicEventTrigger.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicEventTrigger.fhirType : string;
begin
  result := 'SubscriptionTopic.eventTrigger';
end;

function TFhirSubscriptionTopicEventTrigger.Link : TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger(inherited Link);
end;

function TFhirSubscriptionTopicEventTrigger.Clone : TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger(inherited Clone);
end;

function TFhirSubscriptionTopicEventTrigger.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicEventTrigger;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicEventTrigger)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicEventTrigger(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(eventElement, o.eventElement, true) and 
      compareDeep(resourceElement, o.resourceElement, true);
  end;
end;

function TFhirSubscriptionTopicEventTrigger.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FEvent) and isEmptyProp(FResource);
end;

procedure TFhirSubscriptionTopicEventTrigger.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('event');
  fields.add('resource');
end;

function TFhirSubscriptionTopicEventTrigger.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirSubscriptionTopicEventTrigger.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubscriptionTopicEventTrigger.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubscriptionTopicEventTrigger.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSubscriptionTopicEventTrigger.SetEvent(value : TFhirCodeableConcept);
begin
  FEvent.free;
  FEvent := value;
end;

procedure TFhirSubscriptionTopicEventTrigger.SetResource(value : TFhirUri);
begin
  FResource.free;
  FResource := value;
end;

function TFhirSubscriptionTopicEventTrigger.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

procedure TFhirSubscriptionTopicEventTrigger.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirUri.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

{ TFhirSubscriptionTopicEventTriggerListEnumerator }

constructor TFhirSubscriptionTopicEventTriggerListEnumerator.Create(list : TFhirSubscriptionTopicEventTriggerList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicEventTriggerListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicEventTriggerListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicEventTriggerListEnumerator.GetCurrent : TFhirSubscriptionTopicEventTrigger;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicEventTriggerListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicEventTriggerList }

function TFhirSubscriptionTopicEventTriggerList.AddItem(value: TFhirSubscriptionTopicEventTrigger): TFhirSubscriptionTopicEventTrigger;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicEventTrigger', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicEventTrigger');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicEventTriggerList.Append: TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicEventTriggerList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicEventTriggerList.GetEnumerator : TFhirSubscriptionTopicEventTriggerListEnumerator;
begin
  result := TFhirSubscriptionTopicEventTriggerListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicEventTriggerList.Clone: TFhirSubscriptionTopicEventTriggerList;
begin
  result := TFhirSubscriptionTopicEventTriggerList(inherited Clone);
end;

function TFhirSubscriptionTopicEventTriggerList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicEventTriggerList.GetItemN(index: Integer): TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicEventTriggerList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicEventTrigger;
end;
function TFhirSubscriptionTopicEventTriggerList.IndexOf(value: TFhirSubscriptionTopicEventTrigger): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicEventTriggerList.Insert(index: Integer): TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicEventTriggerList.InsertItem(index: Integer; value: TFhirSubscriptionTopicEventTrigger);
begin
  assert(value is TFhirSubscriptionTopicEventTrigger);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicEventTriggerList.Item(index: Integer): TFhirSubscriptionTopicEventTrigger;
begin
  result := TFhirSubscriptionTopicEventTrigger(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicEventTriggerList.Link: TFhirSubscriptionTopicEventTriggerList;
begin
  result := TFhirSubscriptionTopicEventTriggerList(inherited Link);
end;

procedure TFhirSubscriptionTopicEventTriggerList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicEventTriggerList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicEventTrigger);
begin
  assert(value is TFhirSubscriptionTopicEventTrigger);
  FhirSubscriptionTopicEventTriggers[index] := value;
end;

procedure TFhirSubscriptionTopicEventTriggerList.SetItemN(index: Integer; value: TFhirSubscriptionTopicEventTrigger);
begin
  assert(value is TFhirSubscriptionTopicEventTrigger);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopicCanFilterBy }

constructor TFhirSubscriptionTopicCanFilterBy.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicCanFilterBy.Destroy;
begin
  FDescription.free;
  FResource.free;
  FFilterParameter.free;
  FModifier.Free;
  inherited;
end;

procedure TFhirSubscriptionTopicCanFilterBy.Assign(oSource : TFslObject);
begin
  inherited;
  descriptionElement := TFhirSubscriptionTopicCanFilterBy(oSource).descriptionElement.Clone;
  resourceElement := TFhirSubscriptionTopicCanFilterBy(oSource).resourceElement.Clone;
  filterParameterElement := TFhirSubscriptionTopicCanFilterBy(oSource).filterParameterElement.Clone;
  if (TFhirSubscriptionTopicCanFilterBy(oSource).FModifier = nil) then
  begin
    FModifier.free;
    FModifier := nil;
  end
  else
  begin
    FModifier := TFhirEnumList.Create(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum);
    FModifier.Assign(TFhirSubscriptionTopicCanFilterBy(oSource).FModifier);
  end;
end;

procedure TFhirSubscriptionTopicCanFilterBy.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'filterParameter') Then
     list.add(self.link, 'filterParameter', FFilterParameter.Link);
  if (child_name = 'modifier') Then
     list.addAll(self, 'modifier', FModifier);
end;

procedure TFhirSubscriptionTopicCanFilterBy.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'resource', 'uri', false, TFhirUri, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'filterParameter', 'string', false, TFhirString, FFilterParameter.Link));
  oList.add(TFHIRProperty.create(self, 'modifier', 'code', true, TFhirEnum, FModifier.Link));
end;

function TFhirSubscriptionTopicCanFilterBy.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'resource') then
  begin
    ResourceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'filterParameter') then
  begin
    FilterParameterElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'modifier') then
  begin
    ModifierList.add(asEnum(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum, propValue));
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicCanFilterBy.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'modifier') then FModifier.insertItem(index, asEnum(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum, propValue))
  else inherited;
end;

function TFhirSubscriptionTopicCanFilterBy.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'resource') then result := TFhirUri.create()
  else if (propName = 'filterParameter') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicCanFilterBy.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'description') then result := 'markdown'
  else if (propName = 'resource') then result := 'uri'
  else if (propName = 'filterParameter') then result := 'string'
  else if (propName = 'modifier') then result := 'code'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicCanFilterBy.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'filterParameter') then FilterParameterElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicCanFilterBy.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'resource') then ResourceElement := asUri(new)
  else if (propName = 'filterParameter') then FilterParameterElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicCanFilterBy.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'modifier') then FModifier.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicCanFilterBy.fhirType : string;
begin
  result := 'SubscriptionTopic.canFilterBy';
end;

function TFhirSubscriptionTopicCanFilterBy.Link : TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy(inherited Link);
end;

function TFhirSubscriptionTopicCanFilterBy.Clone : TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy(inherited Clone);
end;

function TFhirSubscriptionTopicCanFilterBy.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicCanFilterBy;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicCanFilterBy)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicCanFilterBy(other);
    result := compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(resourceElement, o.resourceElement, true) and 
      compareDeep(filterParameterElement, o.filterParameterElement, true) and compareDeep(modifierList, o.modifierList, true);
  end;
end;

function TFhirSubscriptionTopicCanFilterBy.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FDescription) and isEmptyProp(FResource) and isEmptyProp(FFilterParameter) and isEmptyProp(FModifier);
end;

procedure TFhirSubscriptionTopicCanFilterBy.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('description');
  fields.add('resource');
  fields.add('filterParameter');
  fields.add('modifier');
end;

function TFhirSubscriptionTopicCanFilterBy.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FModifier.sizeInBytes(magic));
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubscriptionTopicCanFilterBy.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetResource(value : TFhirUri);
begin
  FResource.free;
  FResource := value;
end;

function TFhirSubscriptionTopicCanFilterBy.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirUri.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetFilterParameter(value : TFhirString);
begin
  FFilterParameter.free;
  FFilterParameter := value;
end;

function TFhirSubscriptionTopicCanFilterBy.GetFilterParameterST : String;
begin
  if FFilterParameter = nil then
    result := ''
  else
    result := FFilterParameter.value;
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetFilterParameterST(value : String);
begin
  if value <> '' then
  begin
    if FFilterParameter = nil then
      FFilterParameter := TFhirString.create;
    FFilterParameter.value := value
  end
  else if FFilterParameter <> nil then
    FFilterParameter.value := '';
end;

function TFhirSubscriptionTopicCanFilterBy.GetModifier : TFhirEnumList;
begin
  if FModifier = nil then
    FModifier := TFhirEnumList.Create(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum);
  result := FModifier;
end;

function TFhirSubscriptionTopicCanFilterBy.GetHasModifier : boolean;
begin
  result := (FModifier <> nil) and (FModifier.count > 0);
end;

function TFhirSubscriptionTopicCanFilterBy.GetModifierST : TFhirSubscriptionSearchModifierEnumList;
  var i : integer;
begin
  result := [];
  if Fmodifier <> nil then
    for i := 0 to Fmodifier.count - 1 do
      result := result + [TFhirSubscriptionSearchModifierEnum(StringArrayIndexOfSensitive(CODES_TFhirSubscriptionSearchModifierEnum, Fmodifier[i].value))];
end;

procedure TFhirSubscriptionTopicCanFilterBy.SetModifierST(value : TFhirSubscriptionSearchModifierEnumList);
var a : TFhirSubscriptionSearchModifierEnum;
begin
  if Fmodifier = nil then
    Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum);
  Fmodifier.clear;
  for a := low(TFhirSubscriptionSearchModifierEnum) to high(TFhirSubscriptionSearchModifierEnum) do
    if a in value then
      begin
         if Fmodifier = nil then
           Fmodifier := TFhirEnumList.create(SYSTEMS_TFhirSubscriptionSearchModifierEnum, CODES_TFhirSubscriptionSearchModifierEnum);
         Fmodifier.add(TFhirEnum.create(SYSTEMS_TFhirSubscriptionSearchModifierEnum[a], CODES_TFhirSubscriptionSearchModifierEnum[a]));
      end;
end;

{ TFhirSubscriptionTopicCanFilterByListEnumerator }

constructor TFhirSubscriptionTopicCanFilterByListEnumerator.Create(list : TFhirSubscriptionTopicCanFilterByList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicCanFilterByListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicCanFilterByListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicCanFilterByListEnumerator.GetCurrent : TFhirSubscriptionTopicCanFilterBy;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicCanFilterByListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicCanFilterByList }

function TFhirSubscriptionTopicCanFilterByList.AddItem(value: TFhirSubscriptionTopicCanFilterBy): TFhirSubscriptionTopicCanFilterBy;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicCanFilterBy', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicCanFilterBy');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicCanFilterByList.Append: TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicCanFilterByList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicCanFilterByList.GetEnumerator : TFhirSubscriptionTopicCanFilterByListEnumerator;
begin
  result := TFhirSubscriptionTopicCanFilterByListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicCanFilterByList.Clone: TFhirSubscriptionTopicCanFilterByList;
begin
  result := TFhirSubscriptionTopicCanFilterByList(inherited Clone);
end;

function TFhirSubscriptionTopicCanFilterByList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicCanFilterByList.GetItemN(index: Integer): TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicCanFilterByList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicCanFilterBy;
end;
function TFhirSubscriptionTopicCanFilterByList.IndexOf(value: TFhirSubscriptionTopicCanFilterBy): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicCanFilterByList.Insert(index: Integer): TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicCanFilterByList.InsertItem(index: Integer; value: TFhirSubscriptionTopicCanFilterBy);
begin
  assert(value is TFhirSubscriptionTopicCanFilterBy);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicCanFilterByList.Item(index: Integer): TFhirSubscriptionTopicCanFilterBy;
begin
  result := TFhirSubscriptionTopicCanFilterBy(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicCanFilterByList.Link: TFhirSubscriptionTopicCanFilterByList;
begin
  result := TFhirSubscriptionTopicCanFilterByList(inherited Link);
end;

procedure TFhirSubscriptionTopicCanFilterByList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicCanFilterByList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicCanFilterBy);
begin
  assert(value is TFhirSubscriptionTopicCanFilterBy);
  FhirSubscriptionTopicCanFilterBies[index] := value;
end;

procedure TFhirSubscriptionTopicCanFilterByList.SetItemN(index: Integer; value: TFhirSubscriptionTopicCanFilterBy);
begin
  assert(value is TFhirSubscriptionTopicCanFilterBy);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopicNotificationShape }

constructor TFhirSubscriptionTopicNotificationShape.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopicNotificationShape.Destroy;
begin
  FResource.free;
  FIncludeList.Free;
  FRevIncludeList.Free;
  inherited;
end;

procedure TFhirSubscriptionTopicNotificationShape.Assign(oSource : TFslObject);
begin
  inherited;
  resourceElement := TFhirSubscriptionTopicNotificationShape(oSource).resourceElement.Clone;
  if (TFhirSubscriptionTopicNotificationShape(oSource).FIncludeList = nil) then
  begin
    FIncludeList.free;
    FIncludeList := nil;
  end
  else
  begin
    if FIncludeList = nil then
      FIncludeList := TFhirStringList.Create;
    FIncludeList.Assign(TFhirSubscriptionTopicNotificationShape(oSource).FIncludeList);
  end;
  if (TFhirSubscriptionTopicNotificationShape(oSource).FRevIncludeList = nil) then
  begin
    FRevIncludeList.free;
    FRevIncludeList := nil;
  end
  else
  begin
    if FRevIncludeList = nil then
      FRevIncludeList := TFhirStringList.Create;
    FRevIncludeList.Assign(TFhirSubscriptionTopicNotificationShape(oSource).FRevIncludeList);
  end;
end;

procedure TFhirSubscriptionTopicNotificationShape.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'resource') Then
     list.add(self.link, 'resource', FResource.Link);
  if (child_name = 'include') Then
    list.addAll(self, 'include', FIncludeList);
  if (child_name = 'revInclude') Then
    list.addAll(self, 'revInclude', FRevIncludeList);
end;

procedure TFhirSubscriptionTopicNotificationShape.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'resource', 'uri', false, TFhirUri, FResource.Link));
  oList.add(TFHIRProperty.create(self, 'include', 'string', true, TFhirString, FIncludeList.Link));
  oList.add(TFHIRProperty.create(self, 'revInclude', 'string', true, TFhirString, FRevIncludeList.Link));
end;

function TFhirSubscriptionTopicNotificationShape.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'resource') then
  begin
    ResourceElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'include') then
  begin
    IncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'revInclude') then
  begin
    RevIncludeList.add(asString(propValue)){2};     result := propValue;

  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopicNotificationShape.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'include') then IncludeList.insertItem(index, asString(propValue))
  else if (propName = 'revInclude') then RevIncludeList.insertItem(index, asString(propValue))
  else inherited;
end;

function TFhirSubscriptionTopicNotificationShape.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'resource') then result := TFhirUri.create()
  else if (propName = 'include') then result := IncludeList.new()
  else if (propName = 'revInclude') then result := RevIncludeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopicNotificationShape.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'resource') then result := 'uri'
  else if (propName = 'include') then result := 'string'
  else if (propName = 'revInclude') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopicNotificationShape.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'resource') then ResourceElement := nil
  else if (propName = 'include') then deletePropertyValue('include', IncludeList, value)
  else if (propName = 'revInclude') then deletePropertyValue('revInclude', RevIncludeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopicNotificationShape.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'resource') then ResourceElement := asUri(new)
  else if (propName = 'include') then replacePropertyValue('include', IncludeList, existing, new)
  else if (propName = 'revInclude') then replacePropertyValue('revInclude', RevIncludeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopicNotificationShape.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'include') then IncludeList.move(source, destination)
  else if (propName = 'revInclude') then RevIncludeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopicNotificationShape.fhirType : string;
begin
  result := 'SubscriptionTopic.notificationShape';
end;

function TFhirSubscriptionTopicNotificationShape.Link : TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape(inherited Link);
end;

function TFhirSubscriptionTopicNotificationShape.Clone : TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape(inherited Clone);
end;

function TFhirSubscriptionTopicNotificationShape.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopicNotificationShape;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopicNotificationShape)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopicNotificationShape(other);
    result := compareDeep(resourceElement, o.resourceElement, true) and compareDeep(includeList, o.includeList, true) and 
      compareDeep(revIncludeList, o.revIncludeList, true);
  end;
end;

function TFhirSubscriptionTopicNotificationShape.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResource) and isEmptyProp(FincludeList) and isEmptyProp(FrevIncludeList);
end;

procedure TFhirSubscriptionTopicNotificationShape.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('resource');
  fields.add('include');
  fields.add('revInclude');
end;

function TFhirSubscriptionTopicNotificationShape.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIncludeList.sizeInBytes(magic));
  inc(result, FRevIncludeList.sizeInBytes(magic));
end;

procedure TFhirSubscriptionTopicNotificationShape.SetResource(value : TFhirUri);
begin
  FResource.free;
  FResource := value;
end;

function TFhirSubscriptionTopicNotificationShape.GetResourceST : String;
begin
  if FResource = nil then
    result := ''
  else
    result := FResource.value;
end;

procedure TFhirSubscriptionTopicNotificationShape.SetResourceST(value : String);
begin
  if value <> '' then
  begin
    if FResource = nil then
      FResource := TFhirUri.create;
    FResource.value := value
  end
  else if FResource <> nil then
    FResource.value := '';
end;

function TFhirSubscriptionTopicNotificationShape.GetIncludeList : TFhirStringList;
begin
  if FIncludeList = nil then
    FIncludeList := TFhirStringList.Create;
  result := FIncludeList;
end;

function TFhirSubscriptionTopicNotificationShape.GetHasIncludeList : boolean;
begin
  result := (FIncludeList <> nil) and (FIncludeList.count > 0);
end;

function TFhirSubscriptionTopicNotificationShape.GetRevIncludeList : TFhirStringList;
begin
  if FRevIncludeList = nil then
    FRevIncludeList := TFhirStringList.Create;
  result := FRevIncludeList;
end;

function TFhirSubscriptionTopicNotificationShape.GetHasRevIncludeList : boolean;
begin
  result := (FRevIncludeList <> nil) and (FRevIncludeList.count > 0);
end;

{ TFhirSubscriptionTopicNotificationShapeListEnumerator }

constructor TFhirSubscriptionTopicNotificationShapeListEnumerator.Create(list : TFhirSubscriptionTopicNotificationShapeList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicNotificationShapeListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicNotificationShapeListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicNotificationShapeListEnumerator.GetCurrent : TFhirSubscriptionTopicNotificationShape;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicNotificationShapeListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicNotificationShapeList }

function TFhirSubscriptionTopicNotificationShapeList.AddItem(value: TFhirSubscriptionTopicNotificationShape): TFhirSubscriptionTopicNotificationShape;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopicNotificationShape', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopicNotificationShape');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicNotificationShapeList.Append: TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicNotificationShapeList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicNotificationShapeList.GetEnumerator : TFhirSubscriptionTopicNotificationShapeListEnumerator;
begin
  result := TFhirSubscriptionTopicNotificationShapeListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicNotificationShapeList.Clone: TFhirSubscriptionTopicNotificationShapeList;
begin
  result := TFhirSubscriptionTopicNotificationShapeList(inherited Clone);
end;

function TFhirSubscriptionTopicNotificationShapeList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicNotificationShapeList.GetItemN(index: Integer): TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicNotificationShapeList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopicNotificationShape;
end;
function TFhirSubscriptionTopicNotificationShapeList.IndexOf(value: TFhirSubscriptionTopicNotificationShape): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicNotificationShapeList.Insert(index: Integer): TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicNotificationShapeList.InsertItem(index: Integer; value: TFhirSubscriptionTopicNotificationShape);
begin
  assert(value is TFhirSubscriptionTopicNotificationShape);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicNotificationShapeList.Item(index: Integer): TFhirSubscriptionTopicNotificationShape;
begin
  result := TFhirSubscriptionTopicNotificationShape(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicNotificationShapeList.Link: TFhirSubscriptionTopicNotificationShapeList;
begin
  result := TFhirSubscriptionTopicNotificationShapeList(inherited Link);
end;

procedure TFhirSubscriptionTopicNotificationShapeList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicNotificationShapeList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopicNotificationShape);
begin
  assert(value is TFhirSubscriptionTopicNotificationShape);
  FhirSubscriptionTopicNotificationShapes[index] := value;
end;

procedure TFhirSubscriptionTopicNotificationShapeList.SetItemN(index: Integer; value: TFhirSubscriptionTopicNotificationShape);
begin
  assert(value is TFhirSubscriptionTopicNotificationShape);
  ObjectByIndex[index] := value;
end;

{ TFhirSubscriptionTopic }

constructor TFhirSubscriptionTopic.Create;
begin
  inherited;
end;

destructor TFhirSubscriptionTopic.Destroy;
begin
  FUrl.free;
  FIdentifierList.Free;
  FVersion.free;
  FTitle.free;
  FDerivedFromList.Free;
  FStatus.free;
  FExperimental.free;
  FDate.free;
  FPublisher.free;
  FContactList.Free;
  FDescription.free;
  FUseContextList.Free;
  FJurisdictionList.Free;
  FPurpose.free;
  FCopyright.free;
  FApprovalDate.free;
  FLastReviewDate.free;
  FEffectivePeriod.free;
  FResourceTriggerList.Free;
  FEventTriggerList.Free;
  FCanFilterByList.Free;
  FNotificationShapeList.Free;
  inherited;
end;

procedure TFhirSubscriptionTopic.Assign(oSource : TFslObject);
begin
  inherited;
  urlElement := TFhirSubscriptionTopic(oSource).urlElement.Clone;
  if (TFhirSubscriptionTopic(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirSubscriptionTopic(oSource).FIdentifierList);
  end;
  versionElement := TFhirSubscriptionTopic(oSource).versionElement.Clone;
  titleElement := TFhirSubscriptionTopic(oSource).titleElement.Clone;
  if (TFhirSubscriptionTopic(oSource).FDerivedFromList = nil) then
  begin
    FDerivedFromList.free;
    FDerivedFromList := nil;
  end
  else
  begin
    if FDerivedFromList = nil then
      FDerivedFromList := TFhirCanonicalList.Create;
    FDerivedFromList.Assign(TFhirSubscriptionTopic(oSource).FDerivedFromList);
  end;
  statusElement := TFhirSubscriptionTopic(oSource).statusElement.Clone;
  experimentalElement := TFhirSubscriptionTopic(oSource).experimentalElement.Clone;
  dateElement := TFhirSubscriptionTopic(oSource).dateElement.Clone;
  publisherElement := TFhirSubscriptionTopic(oSource).publisherElement.Clone;
  if (TFhirSubscriptionTopic(oSource).FContactList = nil) then
  begin
    FContactList.free;
    FContactList := nil;
  end
  else
  begin
    if FContactList = nil then
      FContactList := TFhirContactDetailList.Create;
    FContactList.Assign(TFhirSubscriptionTopic(oSource).FContactList);
  end;
  descriptionElement := TFhirSubscriptionTopic(oSource).descriptionElement.Clone;
  if (TFhirSubscriptionTopic(oSource).FUseContextList = nil) then
  begin
    FUseContextList.free;
    FUseContextList := nil;
  end
  else
  begin
    if FUseContextList = nil then
      FUseContextList := TFhirUsageContextList.Create;
    FUseContextList.Assign(TFhirSubscriptionTopic(oSource).FUseContextList);
  end;
  if (TFhirSubscriptionTopic(oSource).FJurisdictionList = nil) then
  begin
    FJurisdictionList.free;
    FJurisdictionList := nil;
  end
  else
  begin
    if FJurisdictionList = nil then
      FJurisdictionList := TFhirCodeableConceptList.Create;
    FJurisdictionList.Assign(TFhirSubscriptionTopic(oSource).FJurisdictionList);
  end;
  purposeElement := TFhirSubscriptionTopic(oSource).purposeElement.Clone;
  copyrightElement := TFhirSubscriptionTopic(oSource).copyrightElement.Clone;
  approvalDateElement := TFhirSubscriptionTopic(oSource).approvalDateElement.Clone;
  lastReviewDateElement := TFhirSubscriptionTopic(oSource).lastReviewDateElement.Clone;
  effectivePeriod := TFhirSubscriptionTopic(oSource).effectivePeriod.Clone;
  if (TFhirSubscriptionTopic(oSource).FResourceTriggerList = nil) then
  begin
    FResourceTriggerList.free;
    FResourceTriggerList := nil;
  end
  else
  begin
    if FResourceTriggerList = nil then
      FResourceTriggerList := TFhirSubscriptionTopicResourceTriggerList.Create;
    FResourceTriggerList.Assign(TFhirSubscriptionTopic(oSource).FResourceTriggerList);
  end;
  if (TFhirSubscriptionTopic(oSource).FEventTriggerList = nil) then
  begin
    FEventTriggerList.free;
    FEventTriggerList := nil;
  end
  else
  begin
    if FEventTriggerList = nil then
      FEventTriggerList := TFhirSubscriptionTopicEventTriggerList.Create;
    FEventTriggerList.Assign(TFhirSubscriptionTopic(oSource).FEventTriggerList);
  end;
  if (TFhirSubscriptionTopic(oSource).FCanFilterByList = nil) then
  begin
    FCanFilterByList.free;
    FCanFilterByList := nil;
  end
  else
  begin
    if FCanFilterByList = nil then
      FCanFilterByList := TFhirSubscriptionTopicCanFilterByList.Create;
    FCanFilterByList.Assign(TFhirSubscriptionTopic(oSource).FCanFilterByList);
  end;
  if (TFhirSubscriptionTopic(oSource).FNotificationShapeList = nil) then
  begin
    FNotificationShapeList.free;
    FNotificationShapeList := nil;
  end
  else
  begin
    if FNotificationShapeList = nil then
      FNotificationShapeList := TFhirSubscriptionTopicNotificationShapeList.Create;
    FNotificationShapeList.Assign(TFhirSubscriptionTopic(oSource).FNotificationShapeList);
  end;
end;

function TFhirSubscriptionTopic.GetResourceType : TFhirResourceType;
begin
  result := frtSubscriptionTopic;
end;

procedure TFhirSubscriptionTopic.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'url') Then
     list.add(self.link, 'url', FUrl.Link);
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'version') Then
     list.add(self.link, 'version', FVersion.Link);
  if (child_name = 'title') Then
     list.add(self.link, 'title', FTitle.Link);
  if (child_name = 'derivedFrom') Then
    list.addAll(self, 'derivedFrom', FDerivedFromList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'experimental') Then
     list.add(self.link, 'experimental', FExperimental.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'publisher') Then
     list.add(self.link, 'publisher', FPublisher.Link);
  if (child_name = 'contact') Then
    list.addAll(self, 'contact', FContactList);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'useContext') Then
    list.addAll(self, 'useContext', FUseContextList);
  if (child_name = 'jurisdiction') Then
    list.addAll(self, 'jurisdiction', FJurisdictionList);
  if (child_name = 'purpose') Then
     list.add(self.link, 'purpose', FPurpose.Link);
  if (child_name = 'copyright') Then
     list.add(self.link, 'copyright', FCopyright.Link);
  if (child_name = 'approvalDate') Then
     list.add(self.link, 'approvalDate', FApprovalDate.Link);
  if (child_name = 'lastReviewDate') Then
     list.add(self.link, 'lastReviewDate', FLastReviewDate.Link);
  if (child_name = 'effectivePeriod') Then
     list.add(self.link, 'effectivePeriod', FEffectivePeriod.Link);
  if (child_name = 'resourceTrigger') Then
    list.addAll(self, 'resourceTrigger', FResourceTriggerList);
  if (child_name = 'eventTrigger') Then
    list.addAll(self, 'eventTrigger', FEventTriggerList);
  if (child_name = 'canFilterBy') Then
    list.addAll(self, 'canFilterBy', FCanFilterByList);
  if (child_name = 'notificationShape') Then
    list.addAll(self, 'notificationShape', FNotificationShapeList);
end;

procedure TFhirSubscriptionTopic.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'url', 'uri', false, TFhirUri, FUrl.Link));
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'version', 'string', false, TFhirString, FVersion.Link));
  oList.add(TFHIRProperty.create(self, 'title', 'string', false, TFhirString, FTitle.Link));
  oList.add(TFHIRProperty.create(self, 'derivedFrom', 'canonical', true, TFhirCanonical, FDerivedFromList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'experimental', 'boolean', false, TFhirBoolean, FExperimental.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'dateTime', false, TFhirDateTime, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'publisher', 'string', false, TFhirString, FPublisher.Link));
  oList.add(TFHIRProperty.create(self, 'contact', 'ContactDetail', true, TFhirContactDetail, FContactList.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'markdown', false, TFhirMarkdown, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'useContext', 'UsageContext', true, TFhirUsageContext, FUseContextList.Link));
  oList.add(TFHIRProperty.create(self, 'jurisdiction', 'CodeableConcept', true, TFhirCodeableConcept, FJurisdictionList.Link));
  oList.add(TFHIRProperty.create(self, 'purpose', 'markdown', false, TFhirMarkdown, FPurpose.Link));
  oList.add(TFHIRProperty.create(self, 'copyright', 'markdown', false, TFhirMarkdown, FCopyright.Link));
  oList.add(TFHIRProperty.create(self, 'approvalDate', 'date', false, TFhirDate, FApprovalDate.Link));
  oList.add(TFHIRProperty.create(self, 'lastReviewDate', 'date', false, TFhirDate, FLastReviewDate.Link));
  oList.add(TFHIRProperty.create(self, 'effectivePeriod', 'Period', false, TFhirPeriod, FEffectivePeriod.Link));
  oList.add(TFHIRProperty.create(self, 'resourceTrigger', 'BackboneElement', true, TFhirSubscriptionTopicResourceTrigger, FResourceTriggerList.Link));
  oList.add(TFHIRProperty.create(self, 'eventTrigger', 'BackboneElement', true, TFhirSubscriptionTopicEventTrigger, FEventTriggerList.Link));
  oList.add(TFHIRProperty.create(self, 'canFilterBy', 'BackboneElement', true, TFhirSubscriptionTopicCanFilterBy, FCanFilterByList.Link));
  oList.add(TFHIRProperty.create(self, 'notificationShape', 'BackboneElement', true, TFhirSubscriptionTopicNotificationShape, FNotificationShapeList.Link));
end;

function TFhirSubscriptionTopic.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'url') then
  begin
    UrlElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'version') then
  begin
    VersionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'title') then
  begin
    TitleElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'derivedFrom') then
  begin
    DerivedFromList.add(asCanonical(propValue)){2};     result := propValue;

  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'experimental') then
  begin
    ExperimentalElement := asBoolean(propValue);
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'publisher') then
  begin
    PublisherElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'contact') then
  begin
    ContactList.add(propValue as TFhirContactDetail);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'useContext') then
  begin
    UseContextList.add(propValue as TFhirUsageContext);
    result := propValue;
  end
  else if (propName = 'jurisdiction') then
  begin
    JurisdictionList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'purpose') then
  begin
    PurposeElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'copyright') then
  begin
    CopyrightElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'approvalDate') then
  begin
    ApprovalDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'lastReviewDate') then
  begin
    LastReviewDateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'effectivePeriod') then
  begin
    EffectivePeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'resourceTrigger') then
  begin
    ResourceTriggerList.add(propValue as TFhirSubscriptionTopicResourceTrigger);
    result := propValue;
  end
  else if (propName = 'eventTrigger') then
  begin
    EventTriggerList.add(propValue as TFhirSubscriptionTopicEventTrigger);
    result := propValue;
  end
  else if (propName = 'canFilterBy') then
  begin
    CanFilterByList.add(propValue as TFhirSubscriptionTopicCanFilterBy);
    result := propValue;
  end
  else if (propName = 'notificationShape') then
  begin
    NotificationShapeList.add(propValue as TFhirSubscriptionTopicNotificationShape);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirSubscriptionTopic.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'derivedFrom') then DerivedFromList.insertItem(index, asCanonical(propValue))
  else if (propName = 'contact') then ContactList.insertItem(index, propValue as TFhirContactDetail)
  else if (propName = 'useContext') then UseContextList.insertItem(index, propValue as TFhirUsageContext)
  else if (propName = 'jurisdiction') then JurisdictionList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'resourceTrigger') then ResourceTriggerList.insertItem(index, propValue as TFhirSubscriptionTopicResourceTrigger)
  else if (propName = 'eventTrigger') then EventTriggerList.insertItem(index, propValue as TFhirSubscriptionTopicEventTrigger)
  else if (propName = 'canFilterBy') then CanFilterByList.insertItem(index, propValue as TFhirSubscriptionTopicCanFilterBy)
  else if (propName = 'notificationShape') then NotificationShapeList.insertItem(index, propValue as TFhirSubscriptionTopicNotificationShape)
  else inherited;
end;

function TFhirSubscriptionTopic.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'url') then result := TFhirUri.create()
  else if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'version') then result := TFhirString.create()
  else if (propName = 'title') then result := TFhirString.create()
  else if (propName = 'derivedFrom') then result := DerivedFromList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[PublicationStatusNull], CODES_TFhirPublicationStatusEnum[PublicationStatusNull]) 
  else if (propName = 'experimental') then result := TFhirBoolean.create()
  else if (propName = 'date') then result := TFhirDateTime.create()
  else if (propName = 'publisher') then result := TFhirString.create()
  else if (propName = 'contact') then result := ContactList.new()
  else if (propName = 'description') then result := TFhirMarkdown.create()
  else if (propName = 'useContext') then result := UseContextList.new()
  else if (propName = 'jurisdiction') then result := JurisdictionList.new()
  else if (propName = 'purpose') then result := TFhirMarkdown.create()
  else if (propName = 'copyright') then result := TFhirMarkdown.create()
  else if (propName = 'approvalDate') then result := TFhirDate.create()
  else if (propName = 'lastReviewDate') then result := TFhirDate.create()
  else if (propName = 'effectivePeriod') then result := TFhirPeriod.create()
  else if (propName = 'resourceTrigger') then result := ResourceTriggerList.new()
  else if (propName = 'eventTrigger') then result := EventTriggerList.new()
  else if (propName = 'canFilterBy') then result := CanFilterByList.new()
  else if (propName = 'notificationShape') then result := NotificationShapeList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirSubscriptionTopic.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'url') then result := 'uri'
  else if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'version') then result := 'string'
  else if (propName = 'title') then result := 'string'
  else if (propName = 'derivedFrom') then result := 'canonical'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'experimental') then result := 'boolean'
  else if (propName = 'date') then result := 'dateTime'
  else if (propName = 'publisher') then result := 'string'
  else if (propName = 'contact') then result := 'ContactDetail'
  else if (propName = 'description') then result := 'markdown'
  else if (propName = 'useContext') then result := 'UsageContext'
  else if (propName = 'jurisdiction') then result := 'CodeableConcept'
  else if (propName = 'purpose') then result := 'markdown'
  else if (propName = 'copyright') then result := 'markdown'
  else if (propName = 'approvalDate') then result := 'date'
  else if (propName = 'lastReviewDate') then result := 'date'
  else if (propName = 'effectivePeriod') then result := 'Period'
  else if (propName = 'resourceTrigger') then result := 'BackboneElement'
  else if (propName = 'eventTrigger') then result := 'BackboneElement'
  else if (propName = 'canFilterBy') then result := 'BackboneElement'
  else if (propName = 'notificationShape') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirSubscriptionTopic.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := nil
  else if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'version') then VersionElement := nil
  else if (propName = 'title') then TitleElement := nil
  else if (propName = 'derivedFrom') then deletePropertyValue('derivedFrom', DerivedFromList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'experimental') then ExperimentalElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'publisher') then PublisherElement := nil
  else if (propName = 'contact') then deletePropertyValue('contact', ContactList, value)
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'useContext') then deletePropertyValue('useContext', UseContextList, value)
  else if (propName = 'jurisdiction') then deletePropertyValue('jurisdiction', JurisdictionList, value)
  else if (propName = 'purpose') then PurposeElement := nil
  else if (propName = 'copyright') then CopyrightElement := nil
  else if (propName = 'approvalDate') then ApprovalDateElement := nil
  else if (propName = 'lastReviewDate') then LastReviewDateElement := nil
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := nil
  else if (propName = 'resourceTrigger') then deletePropertyValue('resourceTrigger', ResourceTriggerList, value)
  else if (propName = 'eventTrigger') then deletePropertyValue('eventTrigger', EventTriggerList, value)
  else if (propName = 'canFilterBy') then deletePropertyValue('canFilterBy', CanFilterByList, value)
  else if (propName = 'notificationShape') then deletePropertyValue('notificationShape', NotificationShapeList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirSubscriptionTopic.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'url') then UrlElement := asUri(new)
  else if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'version') then VersionElement := asString(new)
  else if (propName = 'title') then TitleElement := asString(new)
  else if (propName = 'derivedFrom') then replacePropertyValue('derivedFrom', DerivedFromList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirPublicationStatusEnum, CODES_TFhirPublicationStatusEnum, new)
  else if (propName = 'experimental') then ExperimentalElement := asBoolean(new)
  else if (propName = 'date') then DateElement := asDateTime(new)
  else if (propName = 'publisher') then PublisherElement := asString(new)
  else if (propName = 'contact') then replacePropertyValue('contact', ContactList, existing, new)
  else if (propName = 'description') then DescriptionElement := asMarkdown(new)
  else if (propName = 'useContext') then replacePropertyValue('useContext', UseContextList, existing, new)
  else if (propName = 'jurisdiction') then replacePropertyValue('jurisdiction', JurisdictionList, existing, new)
  else if (propName = 'purpose') then PurposeElement := asMarkdown(new)
  else if (propName = 'copyright') then CopyrightElement := asMarkdown(new)
  else if (propName = 'approvalDate') then ApprovalDateElement := asDate(new)
  else if (propName = 'lastReviewDate') then LastReviewDateElement := asDate(new)
  else if (propName = 'effectivePeriod') then EffectivePeriodElement := new as TFhirPeriod
  else if (propName = 'resourceTrigger') then replacePropertyValue('resourceTrigger', ResourceTriggerList, existing, new)
  else if (propName = 'eventTrigger') then replacePropertyValue('eventTrigger', EventTriggerList, existing, new)
  else if (propName = 'canFilterBy') then replacePropertyValue('canFilterBy', CanFilterByList, existing, new)
  else if (propName = 'notificationShape') then replacePropertyValue('notificationShape', NotificationShapeList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirSubscriptionTopic.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'derivedFrom') then DerivedFromList.move(source, destination)
  else if (propName = 'contact') then ContactList.move(source, destination)
  else if (propName = 'useContext') then UseContextList.move(source, destination)
  else if (propName = 'jurisdiction') then JurisdictionList.move(source, destination)
  else if (propName = 'resourceTrigger') then ResourceTriggerList.move(source, destination)
  else if (propName = 'eventTrigger') then EventTriggerList.move(source, destination)
  else if (propName = 'canFilterBy') then CanFilterByList.move(source, destination)
  else if (propName = 'notificationShape') then NotificationShapeList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirSubscriptionTopic.fhirType : string;
begin
  result := 'SubscriptionTopic';
end;

function TFhirSubscriptionTopic.Link : TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic(inherited Link);
end;

function TFhirSubscriptionTopic.Clone : TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic(inherited Clone);
end;

function TFhirSubscriptionTopic.equals(other : TObject) : boolean; 
var
  o : TFhirSubscriptionTopic;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirSubscriptionTopic)) then
    result := false
  else
  begin
    o := TFhirSubscriptionTopic(other);
    result := compareDeep(urlElement, o.urlElement, true) and compareDeep(identifierList, o.identifierList, true) and 
      compareDeep(versionElement, o.versionElement, true) and compareDeep(titleElement, o.titleElement, true) and 
      compareDeep(derivedFromList, o.derivedFromList, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(experimentalElement, o.experimentalElement, true) and compareDeep(dateElement, o.dateElement, true) and 
      compareDeep(publisherElement, o.publisherElement, true) and compareDeep(contactList, o.contactList, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(useContextList, o.useContextList, true) and 
      compareDeep(jurisdictionList, o.jurisdictionList, true) and compareDeep(purposeElement, o.purposeElement, true) and 
      compareDeep(copyrightElement, o.copyrightElement, true) and compareDeep(approvalDateElement, o.approvalDateElement, true) and 
      compareDeep(lastReviewDateElement, o.lastReviewDateElement, true) and compareDeep(effectivePeriodElement, o.effectivePeriodElement, true) and 
      compareDeep(resourceTriggerList, o.resourceTriggerList, true) and compareDeep(eventTriggerList, o.eventTriggerList, true) and 
      compareDeep(canFilterByList, o.canFilterByList, true) and compareDeep(notificationShapeList, o.notificationShapeList, true);
  end;
end;

function TFhirSubscriptionTopic.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FUrl) and isEmptyProp(FidentifierList) and isEmptyProp(FVersion) and isEmptyProp(FTitle) and isEmptyProp(FderivedFromList) and isEmptyProp(FStatus) and isEmptyProp(FExperimental) and isEmptyProp(FDate) and isEmptyProp(FPublisher) and isEmptyProp(FcontactList) and isEmptyProp(FDescription) and isEmptyProp(FuseContextList) and isEmptyProp(FjurisdictionList) and isEmptyProp(FPurpose) and isEmptyProp(FCopyright) and isEmptyProp(FApprovalDate) and isEmptyProp(FLastReviewDate) and isEmptyProp(FEffectivePeriod) and isEmptyProp(FresourceTriggerList) and isEmptyProp(FeventTriggerList) and isEmptyProp(FcanFilterByList) and isEmptyProp(FnotificationShapeList);
end;

procedure TFhirSubscriptionTopic.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('url');
  fields.add('identifier');
  fields.add('version');
  fields.add('title');
  fields.add('derivedFrom');
  fields.add('status');
  fields.add('experimental');
  fields.add('date');
  fields.add('publisher');
  fields.add('contact');
  fields.add('description');
  fields.add('useContext');
  fields.add('jurisdiction');
  fields.add('purpose');
  fields.add('copyright');
  fields.add('approvalDate');
  fields.add('lastReviewDate');
  fields.add('effectivePeriod');
  fields.add('resourceTrigger');
  fields.add('eventTrigger');
  fields.add('canFilterBy');
  fields.add('notificationShape');
end;

function TFhirSubscriptionTopic.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FDerivedFromList.sizeInBytes(magic));
  inc(result, FContactList.sizeInBytes(magic));
  inc(result, FUseContextList.sizeInBytes(magic));
  inc(result, FJurisdictionList.sizeInBytes(magic));
  inc(result, FResourceTriggerList.sizeInBytes(magic));
  inc(result, FEventTriggerList.sizeInBytes(magic));
  inc(result, FCanFilterByList.sizeInBytes(magic));
  inc(result, FNotificationShapeList.sizeInBytes(magic));
end;

procedure TFhirSubscriptionTopic.SetUrl(value : TFhirUri);
begin
  FUrl.free;
  FUrl := value;
end;

function TFhirSubscriptionTopic.GetUrlST : String;
begin
  if FUrl = nil then
    result := ''
  else
    result := FUrl.value;
end;

procedure TFhirSubscriptionTopic.SetUrlST(value : String);
begin
  if value <> '' then
  begin
    if FUrl = nil then
      FUrl := TFhirUri.create;
    FUrl.value := value
  end
  else if FUrl <> nil then
    FUrl.value := '';
end;

function TFhirSubscriptionTopic.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirSubscriptionTopic.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirSubscriptionTopic.SetVersion(value : TFhirString);
begin
  FVersion.free;
  FVersion := value;
end;

function TFhirSubscriptionTopic.GetVersionST : String;
begin
  if FVersion = nil then
    result := ''
  else
    result := FVersion.value;
end;

procedure TFhirSubscriptionTopic.SetVersionST(value : String);
begin
  if value <> '' then
  begin
    if FVersion = nil then
      FVersion := TFhirString.create;
    FVersion.value := value
  end
  else if FVersion <> nil then
    FVersion.value := '';
end;

procedure TFhirSubscriptionTopic.SetTitle(value : TFhirString);
begin
  FTitle.free;
  FTitle := value;
end;

function TFhirSubscriptionTopic.GetTitleST : String;
begin
  if FTitle = nil then
    result := ''
  else
    result := FTitle.value;
end;

procedure TFhirSubscriptionTopic.SetTitleST(value : String);
begin
  if value <> '' then
  begin
    if FTitle = nil then
      FTitle := TFhirString.create;
    FTitle.value := value
  end
  else if FTitle <> nil then
    FTitle.value := '';
end;

function TFhirSubscriptionTopic.GetDerivedFromList : TFhirCanonicalList;
begin
  if FDerivedFromList = nil then
    FDerivedFromList := TFhirCanonicalList.Create;
  result := FDerivedFromList;
end;

function TFhirSubscriptionTopic.GetHasDerivedFromList : boolean;
begin
  result := (FDerivedFromList <> nil) and (FDerivedFromList.count > 0);
end;

procedure TFhirSubscriptionTopic.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirSubscriptionTopic.GetStatusST : TFhirPublicationStatusEnum;
begin
  if FStatus = nil then
    result := TFhirPublicationStatusEnum(0)
  else
    result := TFhirPublicationStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirPublicationStatusEnum, FStatus.value));
end;

procedure TFhirSubscriptionTopic.SetStatusST(value : TFhirPublicationStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirPublicationStatusEnum[value], CODES_TFhirPublicationStatusEnum[value]);
end;

procedure TFhirSubscriptionTopic.SetExperimental(value : TFhirBoolean);
begin
  FExperimental.free;
  FExperimental := value;
end;

function TFhirSubscriptionTopic.GetExperimentalST : Boolean;
begin
  if FExperimental = nil then
    result := false
  else
    result := FExperimental.value;
end;

procedure TFhirSubscriptionTopic.SetExperimentalST(value : Boolean);
begin
  if FExperimental = nil then
    FExperimental := TFhirBoolean.create;
  FExperimental.value := value
end;

procedure TFhirSubscriptionTopic.SetDate(value : TFhirDateTime);
begin
  FDate.free;
  FDate := value;
end;

function TFhirSubscriptionTopic.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirSubscriptionTopic.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDateTime.create;
  FDate.value := value
end;

procedure TFhirSubscriptionTopic.SetPublisher(value : TFhirString);
begin
  FPublisher.free;
  FPublisher := value;
end;

function TFhirSubscriptionTopic.GetPublisherST : String;
begin
  if FPublisher = nil then
    result := ''
  else
    result := FPublisher.value;
end;

procedure TFhirSubscriptionTopic.SetPublisherST(value : String);
begin
  if value <> '' then
  begin
    if FPublisher = nil then
      FPublisher := TFhirString.create;
    FPublisher.value := value
  end
  else if FPublisher <> nil then
    FPublisher.value := '';
end;

function TFhirSubscriptionTopic.GetContactList : TFhirContactDetailList;
begin
  if FContactList = nil then
    FContactList := TFhirContactDetailList.Create;
  result := FContactList;
end;

function TFhirSubscriptionTopic.GetHasContactList : boolean;
begin
  result := (FContactList <> nil) and (FContactList.count > 0);
end;

procedure TFhirSubscriptionTopic.SetDescription(value : TFhirMarkdown);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirSubscriptionTopic.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirSubscriptionTopic.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirMarkdown.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirSubscriptionTopic.GetUseContextList : TFhirUsageContextList;
begin
  if FUseContextList = nil then
    FUseContextList := TFhirUsageContextList.Create;
  result := FUseContextList;
end;

function TFhirSubscriptionTopic.GetHasUseContextList : boolean;
begin
  result := (FUseContextList <> nil) and (FUseContextList.count > 0);
end;

function TFhirSubscriptionTopic.GetJurisdictionList : TFhirCodeableConceptList;
begin
  if FJurisdictionList = nil then
    FJurisdictionList := TFhirCodeableConceptList.Create;
  result := FJurisdictionList;
end;

function TFhirSubscriptionTopic.GetHasJurisdictionList : boolean;
begin
  result := (FJurisdictionList <> nil) and (FJurisdictionList.count > 0);
end;

procedure TFhirSubscriptionTopic.SetPurpose(value : TFhirMarkdown);
begin
  FPurpose.free;
  FPurpose := value;
end;

function TFhirSubscriptionTopic.GetPurposeST : String;
begin
  if FPurpose = nil then
    result := ''
  else
    result := FPurpose.value;
end;

procedure TFhirSubscriptionTopic.SetPurposeST(value : String);
begin
  if value <> '' then
  begin
    if FPurpose = nil then
      FPurpose := TFhirMarkdown.create;
    FPurpose.value := value
  end
  else if FPurpose <> nil then
    FPurpose.value := '';
end;

procedure TFhirSubscriptionTopic.SetCopyright(value : TFhirMarkdown);
begin
  FCopyright.free;
  FCopyright := value;
end;

function TFhirSubscriptionTopic.GetCopyrightST : String;
begin
  if FCopyright = nil then
    result := ''
  else
    result := FCopyright.value;
end;

procedure TFhirSubscriptionTopic.SetCopyrightST(value : String);
begin
  if value <> '' then
  begin
    if FCopyright = nil then
      FCopyright := TFhirMarkdown.create;
    FCopyright.value := value
  end
  else if FCopyright <> nil then
    FCopyright.value := '';
end;

procedure TFhirSubscriptionTopic.SetApprovalDate(value : TFhirDate);
begin
  FApprovalDate.free;
  FApprovalDate := value;
end;

function TFhirSubscriptionTopic.GetApprovalDateST : TFslDateTime;
begin
  if FApprovalDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FApprovalDate.value;
end;

procedure TFhirSubscriptionTopic.SetApprovalDateST(value : TFslDateTime);
begin
  if FApprovalDate = nil then
    FApprovalDate := TFhirDate.create;
  FApprovalDate.value := value
end;

procedure TFhirSubscriptionTopic.SetLastReviewDate(value : TFhirDate);
begin
  FLastReviewDate.free;
  FLastReviewDate := value;
end;

function TFhirSubscriptionTopic.GetLastReviewDateST : TFslDateTime;
begin
  if FLastReviewDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastReviewDate.value;
end;

procedure TFhirSubscriptionTopic.SetLastReviewDateST(value : TFslDateTime);
begin
  if FLastReviewDate = nil then
    FLastReviewDate := TFhirDate.create;
  FLastReviewDate.value := value
end;

procedure TFhirSubscriptionTopic.SetEffectivePeriod(value : TFhirPeriod);
begin
  FEffectivePeriod.free;
  FEffectivePeriod := value;
end;

function TFhirSubscriptionTopic.GetResourceTriggerList : TFhirSubscriptionTopicResourceTriggerList;
begin
  if FResourceTriggerList = nil then
    FResourceTriggerList := TFhirSubscriptionTopicResourceTriggerList.Create;
  result := FResourceTriggerList;
end;

function TFhirSubscriptionTopic.GetHasResourceTriggerList : boolean;
begin
  result := (FResourceTriggerList <> nil) and (FResourceTriggerList.count > 0);
end;

function TFhirSubscriptionTopic.GetEventTriggerList : TFhirSubscriptionTopicEventTriggerList;
begin
  if FEventTriggerList = nil then
    FEventTriggerList := TFhirSubscriptionTopicEventTriggerList.Create;
  result := FEventTriggerList;
end;

function TFhirSubscriptionTopic.GetHasEventTriggerList : boolean;
begin
  result := (FEventTriggerList <> nil) and (FEventTriggerList.count > 0);
end;

function TFhirSubscriptionTopic.GetCanFilterByList : TFhirSubscriptionTopicCanFilterByList;
begin
  if FCanFilterByList = nil then
    FCanFilterByList := TFhirSubscriptionTopicCanFilterByList.Create;
  result := FCanFilterByList;
end;

function TFhirSubscriptionTopic.GetHasCanFilterByList : boolean;
begin
  result := (FCanFilterByList <> nil) and (FCanFilterByList.count > 0);
end;

function TFhirSubscriptionTopic.GetNotificationShapeList : TFhirSubscriptionTopicNotificationShapeList;
begin
  if FNotificationShapeList = nil then
    FNotificationShapeList := TFhirSubscriptionTopicNotificationShapeList.Create;
  result := FNotificationShapeList;
end;

function TFhirSubscriptionTopic.GetHasNotificationShapeList : boolean;
begin
  result := (FNotificationShapeList <> nil) and (FNotificationShapeList.count > 0);
end;

{ TFhirSubscriptionTopicListEnumerator }

constructor TFhirSubscriptionTopicListEnumerator.Create(list : TFhirSubscriptionTopicList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirSubscriptionTopicListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirSubscriptionTopicListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirSubscriptionTopicListEnumerator.GetCurrent : TFhirSubscriptionTopic;
begin
  Result := FList[FIndex];
end;

function TFhirSubscriptionTopicListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirSubscriptionTopicList }

function TFhirSubscriptionTopicList.AddItem(value: TFhirSubscriptionTopic): TFhirSubscriptionTopic;
begin
  assert(value.ClassName = 'TFhirSubscriptionTopic', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirSubscriptionTopic');
  add(value);
  result := value;
end;

function TFhirSubscriptionTopicList.Append: TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicList.ClearItems;
begin
  Clear;
end;

function TFhirSubscriptionTopicList.GetEnumerator : TFhirSubscriptionTopicListEnumerator;
begin
  result := TFhirSubscriptionTopicListEnumerator.Create(self.link);
end;

function TFhirSubscriptionTopicList.Clone: TFhirSubscriptionTopicList;
begin
  result := TFhirSubscriptionTopicList(inherited Clone);
end;

function TFhirSubscriptionTopicList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirSubscriptionTopicList.GetItemN(index: Integer): TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicList.ItemClass: TFslObjectClass;
begin
  result := TFhirSubscriptionTopic;
end;
function TFhirSubscriptionTopicList.IndexOf(value: TFhirSubscriptionTopic): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirSubscriptionTopicList.Insert(index: Integer): TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirSubscriptionTopicList.InsertItem(index: Integer; value: TFhirSubscriptionTopic);
begin
  assert(value is TFhirSubscriptionTopic);
  Inherited Insert(index, value);
end;

function TFhirSubscriptionTopicList.Item(index: Integer): TFhirSubscriptionTopic;
begin
  result := TFhirSubscriptionTopic(ObjectByIndex[index]);
end;

function TFhirSubscriptionTopicList.Link: TFhirSubscriptionTopicList;
begin
  result := TFhirSubscriptionTopicList(inherited Link);
end;

procedure TFhirSubscriptionTopicList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirSubscriptionTopicList.SetItemByIndex(index: Integer; value: TFhirSubscriptionTopic);
begin
  assert(value is TFhirSubscriptionTopic);
  FhirSubscriptionTopics[index] := value;
end;

procedure TFhirSubscriptionTopicList.SetItemN(index: Integer; value: TFhirSubscriptionTopic);
begin
  assert(value is TFhirSubscriptionTopic);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_SUBSCRIPTIONTOPIC}
{$IFDEF FHIR_TASK}
{ TFhirTaskRestriction }

constructor TFhirTaskRestriction.Create;
begin
  inherited;
end;

destructor TFhirTaskRestriction.Destroy;
begin
  FRepetitions.free;
  FPeriod.free;
  FRecipientList.Free;
  inherited;
end;

procedure TFhirTaskRestriction.Assign(oSource : TFslObject);
begin
  inherited;
  repetitionsElement := TFhirTaskRestriction(oSource).repetitionsElement.Clone;
  period := TFhirTaskRestriction(oSource).period.Clone;
  if (TFhirTaskRestriction(oSource).FRecipientList = nil) then
  begin
    FRecipientList.free;
    FRecipientList := nil;
  end
  else
  begin
    if FRecipientList = nil then
      FRecipientList := TFhirReferenceList.Create;
    FRecipientList.Assign(TFhirTaskRestriction(oSource).FRecipientList);
  end;
end;

procedure TFhirTaskRestriction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'repetitions') Then
     list.add(self.link, 'repetitions', FRepetitions.Link);
  if (child_name = 'period') Then
     list.add(self.link, 'period', FPeriod.Link);
  if (child_name = 'recipient') Then
    list.addAll(self, 'recipient', FRecipientList);
end;

procedure TFhirTaskRestriction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'repetitions', 'positiveInt', false, TFhirPositiveInt, FRepetitions.Link));
  oList.add(TFHIRProperty.create(self, 'period', 'Period', false, TFhirPeriod, FPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'recipient', 'Reference', true, TFhirReference, FRecipientList.Link));
end;

function TFhirTaskRestriction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'repetitions') then
  begin
    RepetitionsElement := asPositiveInt(propValue);
    result := propValue;
  end
  else if (propName = 'period') then
  begin
    Period := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'recipient') then
  begin
    RecipientList.add(propValue as TFhirReference);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskRestriction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'recipient') then RecipientList.insertItem(index, propValue as TFhirReference)
  else inherited;
end;

function TFhirTaskRestriction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'repetitions') then result := TFhirPositiveInt.create()
  else if (propName = 'period') then result := TFhirPeriod.create()
  else if (propName = 'recipient') then result := RecipientList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskRestriction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'repetitions') then result := 'positiveInt'
  else if (propName = 'period') then result := 'Period'
  else if (propName = 'recipient') then result := 'Reference'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskRestriction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'repetitions') then RepetitionsElement := nil
  else if (propName = 'period') then PeriodElement := nil
  else if (propName = 'recipient') then deletePropertyValue('recipient', RecipientList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskRestriction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'repetitions') then RepetitionsElement := asPositiveInt(new)
  else if (propName = 'period') then PeriodElement := new as TFhirPeriod
  else if (propName = 'recipient') then replacePropertyValue('recipient', RecipientList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskRestriction.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'recipient') then RecipientList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskRestriction.fhirType : string;
begin
  result := 'Task.restriction';
end;

function TFhirTaskRestriction.Link : TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(inherited Link);
end;

function TFhirTaskRestriction.Clone : TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(inherited Clone);
end;

function TFhirTaskRestriction.equals(other : TObject) : boolean; 
var
  o : TFhirTaskRestriction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskRestriction)) then
    result := false
  else
  begin
    o := TFhirTaskRestriction(other);
    result := compareDeep(repetitionsElement, o.repetitionsElement, true) and compareDeep(periodElement, o.periodElement, true) and 
      compareDeep(recipientList, o.recipientList, true);
  end;
end;

function TFhirTaskRestriction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FRepetitions) and isEmptyProp(FPeriod) and isEmptyProp(FrecipientList);
end;

procedure TFhirTaskRestriction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('repetitions');
  fields.add('period');
  fields.add('recipient');
end;

function TFhirTaskRestriction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FRecipientList.sizeInBytes(magic));
end;

procedure TFhirTaskRestriction.SetRepetitions(value : TFhirPositiveInt);
begin
  FRepetitions.free;
  FRepetitions := value;
end;

function TFhirTaskRestriction.GetRepetitionsST : String;
begin
  if FRepetitions = nil then
    result := ''
  else
    result := FRepetitions.value;
end;

procedure TFhirTaskRestriction.SetRepetitionsST(value : String);
begin
  if value <> '' then
  begin
    if FRepetitions = nil then
      FRepetitions := TFhirPositiveInt.create;
    FRepetitions.value := value
  end
  else if FRepetitions <> nil then
    FRepetitions.value := '';
end;

procedure TFhirTaskRestriction.SetPeriod(value : TFhirPeriod);
begin
  FPeriod.free;
  FPeriod := value;
end;

function TFhirTaskRestriction.GetRecipientList : TFhirReferenceList;
begin
  if FRecipientList = nil then
    FRecipientList := TFhirReferenceList.Create;
  result := FRecipientList;
end;

function TFhirTaskRestriction.GetHasRecipientList : boolean;
begin
  result := (FRecipientList <> nil) and (FRecipientList.count > 0);
end;

{ TFhirTaskRestrictionListEnumerator }

constructor TFhirTaskRestrictionListEnumerator.Create(list : TFhirTaskRestrictionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskRestrictionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskRestrictionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskRestrictionListEnumerator.GetCurrent : TFhirTaskRestriction;
begin
  Result := FList[FIndex];
end;

function TFhirTaskRestrictionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTaskRestrictionList }

function TFhirTaskRestrictionList.AddItem(value: TFhirTaskRestriction): TFhirTaskRestriction;
begin
  assert(value.ClassName = 'TFhirTaskRestriction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskRestriction');
  add(value);
  result := value;
end;

function TFhirTaskRestrictionList.Append: TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRestrictionList.ClearItems;
begin
  Clear;
end;

function TFhirTaskRestrictionList.GetEnumerator : TFhirTaskRestrictionListEnumerator;
begin
  result := TFhirTaskRestrictionListEnumerator.Create(self.link);
end;

function TFhirTaskRestrictionList.Clone: TFhirTaskRestrictionList;
begin
  result := TFhirTaskRestrictionList(inherited Clone);
end;

function TFhirTaskRestrictionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskRestrictionList.GetItemN(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(ObjectByIndex[index]);
end;

function TFhirTaskRestrictionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskRestriction;
end;
function TFhirTaskRestrictionList.IndexOf(value: TFhirTaskRestriction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskRestrictionList.Insert(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskRestrictionList.InsertItem(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  Inherited Insert(index, value);
end;

function TFhirTaskRestrictionList.Item(index: Integer): TFhirTaskRestriction;
begin
  result := TFhirTaskRestriction(ObjectByIndex[index]);
end;

function TFhirTaskRestrictionList.Link: TFhirTaskRestrictionList;
begin
  result := TFhirTaskRestrictionList(inherited Link);
end;

procedure TFhirTaskRestrictionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskRestrictionList.SetItemByIndex(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  FhirTaskRestrictions[index] := value;
end;

procedure TFhirTaskRestrictionList.SetItemN(index: Integer; value: TFhirTaskRestriction);
begin
  assert(value is TFhirTaskRestriction);
  ObjectByIndex[index] := value;
end;

{ TFhirTaskInput }

constructor TFhirTaskInput.Create;
begin
  inherited;
end;

destructor TFhirTaskInput.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirTaskInput.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTaskInput(oSource).type_.Clone;
  value := TFhirTaskInput(oSource).value.Clone;
end;

procedure TFhirTaskInput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirTaskInput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage|Meta', false, TFhirDataType, FValue.Link));
end;

function TFhirTaskInput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskInput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTaskInput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskInput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage|Meta'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskInput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskInput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskInput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskInput.fhirType : string;
begin
  result := 'Task.input';
end;

function TFhirTaskInput.Link : TFhirTaskInput;
begin
  result := TFhirTaskInput(inherited Link);
end;

function TFhirTaskInput.Clone : TFhirTaskInput;
begin
  result := TFhirTaskInput(inherited Clone);
end;

function TFhirTaskInput.equals(other : TObject) : boolean; 
var
  o : TFhirTaskInput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskInput)) then
    result := false
  else
  begin
    o := TFhirTaskInput(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTaskInput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirTaskInput.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirTaskInput.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTaskInput.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirTaskInput.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirTaskInputListEnumerator }

constructor TFhirTaskInputListEnumerator.Create(list : TFhirTaskInputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskInputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskInputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskInputListEnumerator.GetCurrent : TFhirTaskInput;
begin
  Result := FList[FIndex];
end;

function TFhirTaskInputListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTaskInputList }

function TFhirTaskInputList.AddItem(value: TFhirTaskInput): TFhirTaskInput;
begin
  assert(value.ClassName = 'TFhirTaskInput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskInput');
  add(value);
  result := value;
end;

function TFhirTaskInputList.Append: TFhirTaskInput;
begin
  result := TFhirTaskInput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskInputList.ClearItems;
begin
  Clear;
end;

function TFhirTaskInputList.GetEnumerator : TFhirTaskInputListEnumerator;
begin
  result := TFhirTaskInputListEnumerator.Create(self.link);
end;

function TFhirTaskInputList.Clone: TFhirTaskInputList;
begin
  result := TFhirTaskInputList(inherited Clone);
end;

function TFhirTaskInputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskInputList.GetItemN(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput(ObjectByIndex[index]);
end;

function TFhirTaskInputList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskInput;
end;
function TFhirTaskInputList.IndexOf(value: TFhirTaskInput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskInputList.Insert(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskInputList.InsertItem(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  Inherited Insert(index, value);
end;

function TFhirTaskInputList.Item(index: Integer): TFhirTaskInput;
begin
  result := TFhirTaskInput(ObjectByIndex[index]);
end;

function TFhirTaskInputList.Link: TFhirTaskInputList;
begin
  result := TFhirTaskInputList(inherited Link);
end;

procedure TFhirTaskInputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskInputList.SetItemByIndex(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  FhirTaskInputs[index] := value;
end;

procedure TFhirTaskInputList.SetItemN(index: Integer; value: TFhirTaskInput);
begin
  assert(value is TFhirTaskInput);
  ObjectByIndex[index] := value;
end;

{ TFhirTaskOutput }

constructor TFhirTaskOutput.Create;
begin
  inherited;
end;

destructor TFhirTaskOutput.Destroy;
begin
  FType_.free;
  FValue.free;
  inherited;
end;

procedure TFhirTaskOutput.Assign(oSource : TFslObject);
begin
  inherited;
  type_ := TFhirTaskOutput(oSource).type_.Clone;
  value := TFhirTaskOutput(oSource).value.Clone;
end;

procedure TFhirTaskOutput.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'value[x]') or (child_name = 'value') Then
     list.add(self.link, 'value[x]', FValue.Link);
end;

procedure TFhirTaskOutput.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', false, TFhirCodeableConcept, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'value[x]', 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage|Meta', false, TFhirDataType, FValue.Link));
end;

function TFhirTaskOutput.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_ := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then
  begin
    Value := propValue as TFhirDataType;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTaskOutput.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTaskOutput.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirCodeableConcept.create()
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then raise EFHIRException.create('Cannot make property Value')
  else result := inherited createPropertyValue(propName);
end;

function TFhirTaskOutput.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'value[x]') then result := 'base64Binary|boolean|canonical|code|date|dateTime|decimal|id|instant|integer|markdown|oid|positiveInt|string|time|unsignedInt|uri|url|uuid|Address|Age|Annotation|Attachment|CodeableConcept|Coding|ContactPoint|Count|Distance|Duration|HumanName|Identif'+'ier|Money|Period|Quantity|Range|Ratio|Reference|SampledData|Signature|Timing|ContactDetail|Contributor|DataRequirement|Expression|ParameterDefinition|RelatedArtifact|TriggerDefinition|UsageContext|Dosage|Meta'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTaskOutput.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then ValueElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTaskOutput.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := new as TFhirCodeableConcept
  else if (isMatchingName(propName, 'value', ['Base64Binary', 'Boolean', 'Canonical', 'Code', 'Date', 'DateTime', 'Decimal', 'Id', 'Instant', 'Integer', 'Markdown', 'Oid', 'PositiveInt', 'String', 'Time', 'UnsignedInt', 'Uri', 'Url', 'Uuid', 'Address', 'Age', 'Annotation', 'Attachment', 'CodeableConcept', 'Coding', 'ContactPoint', 'Count', 'Distance', 'Duration', 'HumanName', 'Identifier', 'Money', 'Period', 'Quantity', 'Range', 'Ratio', 'Reference', 'SampledData', 'Signature', 'Timing', 'ContactDetail', 'Contributor', 'DataRequirement', 'Expression', 'ParameterDefinition', 'RelatedArtifact', 'TriggerDefinition', 'UsageContext', 'Dosage', 'Meta'])) then ValueElement := new as TFhirDataType
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTaskOutput.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTaskOutput.fhirType : string;
begin
  result := 'Task.output';
end;

function TFhirTaskOutput.Link : TFhirTaskOutput;
begin
  result := TFhirTaskOutput(inherited Link);
end;

function TFhirTaskOutput.Clone : TFhirTaskOutput;
begin
  result := TFhirTaskOutput(inherited Clone);
end;

function TFhirTaskOutput.equals(other : TObject) : boolean; 
var
  o : TFhirTaskOutput;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTaskOutput)) then
    result := false
  else
  begin
    o := TFhirTaskOutput(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(valueElement, o.valueElement, true);
  end;
end;

function TFhirTaskOutput.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FValue);
end;

procedure TFhirTaskOutput.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('value[x]');
end;

function TFhirTaskOutput.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTaskOutput.SetType_(value : TFhirCodeableConcept);
begin
  FType_.free;
  FType_ := value;
end;

procedure TFhirTaskOutput.SetValue(value : TFhirDataType);
begin
  FValue.free;
  FValue := value;
end;

{ TFhirTaskOutputListEnumerator }

constructor TFhirTaskOutputListEnumerator.Create(list : TFhirTaskOutputList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskOutputListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskOutputListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskOutputListEnumerator.GetCurrent : TFhirTaskOutput;
begin
  Result := FList[FIndex];
end;

function TFhirTaskOutputListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTaskOutputList }

function TFhirTaskOutputList.AddItem(value: TFhirTaskOutput): TFhirTaskOutput;
begin
  assert(value.ClassName = 'TFhirTaskOutput', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTaskOutput');
  add(value);
  result := value;
end;

function TFhirTaskOutputList.Append: TFhirTaskOutput;
begin
  result := TFhirTaskOutput.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskOutputList.ClearItems;
begin
  Clear;
end;

function TFhirTaskOutputList.GetEnumerator : TFhirTaskOutputListEnumerator;
begin
  result := TFhirTaskOutputListEnumerator.Create(self.link);
end;

function TFhirTaskOutputList.Clone: TFhirTaskOutputList;
begin
  result := TFhirTaskOutputList(inherited Clone);
end;

function TFhirTaskOutputList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskOutputList.GetItemN(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput(ObjectByIndex[index]);
end;

function TFhirTaskOutputList.ItemClass: TFslObjectClass;
begin
  result := TFhirTaskOutput;
end;
function TFhirTaskOutputList.IndexOf(value: TFhirTaskOutput): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskOutputList.Insert(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskOutputList.InsertItem(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  Inherited Insert(index, value);
end;

function TFhirTaskOutputList.Item(index: Integer): TFhirTaskOutput;
begin
  result := TFhirTaskOutput(ObjectByIndex[index]);
end;

function TFhirTaskOutputList.Link: TFhirTaskOutputList;
begin
  result := TFhirTaskOutputList(inherited Link);
end;

procedure TFhirTaskOutputList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskOutputList.SetItemByIndex(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  FhirTaskOutputs[index] := value;
end;

procedure TFhirTaskOutputList.SetItemN(index: Integer; value: TFhirTaskOutput);
begin
  assert(value is TFhirTaskOutput);
  ObjectByIndex[index] := value;
end;

{ TFhirTask }

constructor TFhirTask.Create;
begin
  inherited;
end;

destructor TFhirTask.Destroy;
begin
  FIdentifierList.Free;
  FInstantiatesCanonical.free;
  FInstantiatesUri.free;
  FBasedOnList.Free;
  FGroupIdentifier.free;
  FPartOfList.Free;
  FStatus.free;
  FStatusReason.free;
  FBusinessStatus.free;
  FIntent.free;
  FPriority.free;
  FCode.free;
  FDescription.free;
  FFocus.free;
  FFor_.free;
  FEncounter.free;
  FExecutionPeriod.free;
  FAuthoredOn.free;
  FLastModified.free;
  FRequester.free;
  FPerformerTypeList.Free;
  FOwner.free;
  FLocation.free;
  FReasonCode.free;
  FReasonReference.free;
  FInsuranceList.Free;
  FNoteList.Free;
  FRelevantHistoryList.Free;
  FRestriction.free;
  FInputList.Free;
  FOutputList.Free;
  inherited;
end;

procedure TFhirTask.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTask(oSource).FIdentifierList = nil) then
  begin
    FIdentifierList.free;
    FIdentifierList := nil;
  end
  else
  begin
    if FIdentifierList = nil then
      FIdentifierList := TFhirIdentifierList.Create;
    FIdentifierList.Assign(TFhirTask(oSource).FIdentifierList);
  end;
  instantiatesCanonicalElement := TFhirTask(oSource).instantiatesCanonicalElement.Clone;
  instantiatesUriElement := TFhirTask(oSource).instantiatesUriElement.Clone;
  if (TFhirTask(oSource).FBasedOnList = nil) then
  begin
    FBasedOnList.free;
    FBasedOnList := nil;
  end
  else
  begin
    if FBasedOnList = nil then
      FBasedOnList := TFhirReferenceList.Create;
    FBasedOnList.Assign(TFhirTask(oSource).FBasedOnList);
  end;
  groupIdentifier := TFhirTask(oSource).groupIdentifier.Clone;
  if (TFhirTask(oSource).FPartOfList = nil) then
  begin
    FPartOfList.free;
    FPartOfList := nil;
  end
  else
  begin
    if FPartOfList = nil then
      FPartOfList := TFhirReferenceList.Create;
    FPartOfList.Assign(TFhirTask(oSource).FPartOfList);
  end;
  statusElement := TFhirTask(oSource).statusElement.Clone;
  statusReason := TFhirTask(oSource).statusReason.Clone;
  businessStatus := TFhirTask(oSource).businessStatus.Clone;
  intentElement := TFhirTask(oSource).intentElement.Clone;
  priorityElement := TFhirTask(oSource).priorityElement.Clone;
  code := TFhirTask(oSource).code.Clone;
  descriptionElement := TFhirTask(oSource).descriptionElement.Clone;
  focus := TFhirTask(oSource).focus.Clone;
  for_ := TFhirTask(oSource).for_.Clone;
  encounter := TFhirTask(oSource).encounter.Clone;
  executionPeriod := TFhirTask(oSource).executionPeriod.Clone;
  authoredOnElement := TFhirTask(oSource).authoredOnElement.Clone;
  lastModifiedElement := TFhirTask(oSource).lastModifiedElement.Clone;
  requester := TFhirTask(oSource).requester.Clone;
  if (TFhirTask(oSource).FPerformerTypeList = nil) then
  begin
    FPerformerTypeList.free;
    FPerformerTypeList := nil;
  end
  else
  begin
    if FPerformerTypeList = nil then
      FPerformerTypeList := TFhirCodeableConceptList.Create;
    FPerformerTypeList.Assign(TFhirTask(oSource).FPerformerTypeList);
  end;
  owner := TFhirTask(oSource).owner.Clone;
  location := TFhirTask(oSource).location.Clone;
  reasonCode := TFhirTask(oSource).reasonCode.Clone;
  reasonReference := TFhirTask(oSource).reasonReference.Clone;
  if (TFhirTask(oSource).FInsuranceList = nil) then
  begin
    FInsuranceList.free;
    FInsuranceList := nil;
  end
  else
  begin
    if FInsuranceList = nil then
      FInsuranceList := TFhirReferenceList.Create;
    FInsuranceList.Assign(TFhirTask(oSource).FInsuranceList);
  end;
  if (TFhirTask(oSource).FNoteList = nil) then
  begin
    FNoteList.free;
    FNoteList := nil;
  end
  else
  begin
    if FNoteList = nil then
      FNoteList := TFhirAnnotationList.Create;
    FNoteList.Assign(TFhirTask(oSource).FNoteList);
  end;
  if (TFhirTask(oSource).FRelevantHistoryList = nil) then
  begin
    FRelevantHistoryList.free;
    FRelevantHistoryList := nil;
  end
  else
  begin
    if FRelevantHistoryList = nil then
      FRelevantHistoryList := TFhirReferenceList.Create;
    FRelevantHistoryList.Assign(TFhirTask(oSource).FRelevantHistoryList);
  end;
  restriction := TFhirTask(oSource).restriction.Clone;
  if (TFhirTask(oSource).FInputList = nil) then
  begin
    FInputList.free;
    FInputList := nil;
  end
  else
  begin
    if FInputList = nil then
      FInputList := TFhirTaskInputList.Create;
    FInputList.Assign(TFhirTask(oSource).FInputList);
  end;
  if (TFhirTask(oSource).FOutputList = nil) then
  begin
    FOutputList.free;
    FOutputList := nil;
  end
  else
  begin
    if FOutputList = nil then
      FOutputList := TFhirTaskOutputList.Create;
    FOutputList.Assign(TFhirTask(oSource).FOutputList);
  end;
end;

function TFhirTask.GetResourceType : TFhirResourceType;
begin
  result := frtTask;
end;

procedure TFhirTask.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
    list.addAll(self, 'identifier', FIdentifierList);
  if (child_name = 'instantiatesCanonical') Then
     list.add(self.link, 'instantiatesCanonical', FInstantiatesCanonical.Link);
  if (child_name = 'instantiatesUri') Then
     list.add(self.link, 'instantiatesUri', FInstantiatesUri.Link);
  if (child_name = 'basedOn') Then
    list.addAll(self, 'basedOn', FBasedOnList);
  if (child_name = 'groupIdentifier') Then
     list.add(self.link, 'groupIdentifier', FGroupIdentifier.Link);
  if (child_name = 'partOf') Then
    list.addAll(self, 'partOf', FPartOfList);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusReason') Then
     list.add(self.link, 'statusReason', FStatusReason.Link);
  if (child_name = 'businessStatus') Then
     list.add(self.link, 'businessStatus', FBusinessStatus.Link);
  if (child_name = 'intent') Then
     list.add(self.link, 'intent', FIntent.Link);
  if (child_name = 'priority') Then
     list.add(self.link, 'priority', FPriority.Link);
  if (child_name = 'code') Then
     list.add(self.link, 'code', FCode.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'focus') Then
     list.add(self.link, 'focus', FFocus.Link);
  if (child_name = 'for') Then
     list.add(self.link, 'for', FFor_.Link);
  if (child_name = 'encounter') Then
     list.add(self.link, 'encounter', FEncounter.Link);
  if (child_name = 'executionPeriod') Then
     list.add(self.link, 'executionPeriod', FExecutionPeriod.Link);
  if (child_name = 'authoredOn') Then
     list.add(self.link, 'authoredOn', FAuthoredOn.Link);
  if (child_name = 'lastModified') Then
     list.add(self.link, 'lastModified', FLastModified.Link);
  if (child_name = 'requester') Then
     list.add(self.link, 'requester', FRequester.Link);
  if (child_name = 'performerType') Then
    list.addAll(self, 'performerType', FPerformerTypeList);
  if (child_name = 'owner') Then
     list.add(self.link, 'owner', FOwner.Link);
  if (child_name = 'location') Then
     list.add(self.link, 'location', FLocation.Link);
  if (child_name = 'reasonCode') Then
     list.add(self.link, 'reasonCode', FReasonCode.Link);
  if (child_name = 'reasonReference') Then
     list.add(self.link, 'reasonReference', FReasonReference.Link);
  if (child_name = 'insurance') Then
    list.addAll(self, 'insurance', FInsuranceList);
  if (child_name = 'note') Then
    list.addAll(self, 'note', FNoteList);
  if (child_name = 'relevantHistory') Then
    list.addAll(self, 'relevantHistory', FRelevantHistoryList);
  if (child_name = 'restriction') Then
     list.add(self.link, 'restriction', FRestriction.Link);
  if (child_name = 'input') Then
    list.addAll(self, 'input', FInputList);
  if (child_name = 'output') Then
    list.addAll(self, 'output', FOutputList);
end;

procedure TFhirTask.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', true, TFhirIdentifier, FIdentifierList.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesCanonical', 'canonical', false, TFhirCanonical, FInstantiatesCanonical.Link));
  oList.add(TFHIRProperty.create(self, 'instantiatesUri', 'uri', false, TFhirUri, FInstantiatesUri.Link));
  oList.add(TFHIRProperty.create(self, 'basedOn', 'Reference', true, TFhirReference, FBasedOnList.Link));
  oList.add(TFHIRProperty.create(self, 'groupIdentifier', 'Identifier', false, TFhirIdentifier, FGroupIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'partOf', 'Reference', true, TFhirReference, FPartOfList.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusReason', 'CodeableConcept', false, TFhirCodeableConcept, FStatusReason.Link));
  oList.add(TFHIRProperty.create(self, 'businessStatus', 'CodeableConcept', false, TFhirCodeableConcept, FBusinessStatus.Link));
  oList.add(TFHIRProperty.create(self, 'intent', 'code', false, TFhirEnum, FIntent.Link));
  oList.add(TFHIRProperty.create(self, 'priority', 'code', false, TFhirEnum, FPriority.Link));
  oList.add(TFHIRProperty.create(self, 'code', 'CodeableConcept', false, TFhirCodeableConcept, FCode.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'focus', 'Reference', false, TFhirReference, FFocus.Link));
  oList.add(TFHIRProperty.create(self, 'for', 'Reference', false, TFhirReference, FFor_.Link));
  oList.add(TFHIRProperty.create(self, 'encounter', 'Reference', false, TFhirReference, FEncounter.Link));
  oList.add(TFHIRProperty.create(self, 'executionPeriod', 'Period', false, TFhirPeriod, FExecutionPeriod.Link));
  oList.add(TFHIRProperty.create(self, 'authoredOn', 'dateTime', false, TFhirDateTime, FAuthoredOn.Link));
  oList.add(TFHIRProperty.create(self, 'lastModified', 'dateTime', false, TFhirDateTime, FLastModified.Link));
  oList.add(TFHIRProperty.create(self, 'requester', 'Reference', false, TFhirReference, FRequester.Link));
  oList.add(TFHIRProperty.create(self, 'performerType', 'CodeableConcept', true, TFhirCodeableConcept, FPerformerTypeList.Link));
  oList.add(TFHIRProperty.create(self, 'owner', 'Reference', false, TFhirReference, FOwner.Link));
  oList.add(TFHIRProperty.create(self, 'location', 'Reference', false, TFhirReference, FLocation.Link));
  oList.add(TFHIRProperty.create(self, 'reasonCode', 'CodeableConcept', false, TFhirCodeableConcept, FReasonCode.Link));
  oList.add(TFHIRProperty.create(self, 'reasonReference', 'Reference', false, TFhirReference, FReasonReference.Link));
  oList.add(TFHIRProperty.create(self, 'insurance', 'Reference', true, TFhirReference, FInsuranceList.Link));
  oList.add(TFHIRProperty.create(self, 'note', 'Annotation', true, TFhirAnnotation, FNoteList.Link));
  oList.add(TFHIRProperty.create(self, 'relevantHistory', 'Reference', true, TFhirReference, FRelevantHistoryList.Link));
  oList.add(TFHIRProperty.create(self, 'restriction', 'BackboneElement', false, TFhirTaskRestriction, FRestriction.Link));
  oList.add(TFHIRProperty.create(self, 'input', 'BackboneElement', true, TFhirTaskInput, FInputList.Link));
  oList.add(TFHIRProperty.create(self, 'output', 'BackboneElement', true, TFhirTaskOutput, FOutputList.Link));
end;

function TFhirTask.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    IdentifierList.add(propValue as TFhirIdentifier);
    result := propValue;
  end
  else if (propName = 'instantiatesCanonical') then
  begin
    InstantiatesCanonicalElement := asCanonical(propValue);
    result := propValue;
  end
  else if (propName = 'instantiatesUri') then
  begin
    InstantiatesUriElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'basedOn') then
  begin
    BasedOnList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'groupIdentifier') then
  begin
    GroupIdentifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'partOf') then
  begin
    PartOfList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirTaskStatusEnum, CODES_TFhirTaskStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusReason') then
  begin
    StatusReason := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'businessStatus') then
  begin
    BusinessStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'intent') then
  begin
    IntentElement := asEnum(SYSTEMS_TFhirTaskIntentEnum, CODES_TFhirTaskIntentEnum, propValue);
    result := propValue;
  end
  else if (propName = 'priority') then
  begin
    PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, propValue);
    result := propValue;
  end
  else if (propName = 'code') then
  begin
    Code := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'focus') then
  begin
    Focus := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'for') then
  begin
    For_ := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'encounter') then
  begin
    Encounter := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'executionPeriod') then
  begin
    ExecutionPeriod := propValue as TFhirPeriod;
    result := propValue;
  end
  else if (propName = 'authoredOn') then
  begin
    AuthoredOnElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'lastModified') then
  begin
    LastModifiedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'requester') then
  begin
    Requester := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'performerType') then
  begin
    PerformerTypeList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'owner') then
  begin
    Owner := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'location') then
  begin
    Location := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'reasonCode') then
  begin
    ReasonCode := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'reasonReference') then
  begin
    ReasonReference := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'insurance') then
  begin
    InsuranceList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'note') then
  begin
    NoteList.add(propValue as TFhirAnnotation);
    result := propValue;
  end
  else if (propName = 'relevantHistory') then
  begin
    RelevantHistoryList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'restriction') then
  begin
    Restriction := propValue as TFhirTaskRestriction;
    result := propValue;
  end
  else if (propName = 'input') then
  begin
    InputList.add(propValue as TFhirTaskInput);
    result := propValue;
  end
  else if (propName = 'output') then
  begin
    OutputList.add(propValue as TFhirTaskOutput);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTask.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'identifier') then IdentifierList.insertItem(index, propValue as TFhirIdentifier)
  else if (propName = 'basedOn') then BasedOnList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'partOf') then PartOfList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'performerType') then PerformerTypeList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'insurance') then InsuranceList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'note') then NoteList.insertItem(index, propValue as TFhirAnnotation)
  else if (propName = 'relevantHistory') then RelevantHistoryList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'input') then InputList.insertItem(index, propValue as TFhirTaskInput)
  else if (propName = 'output') then OutputList.insertItem(index, propValue as TFhirTaskOutput)
  else inherited;
end;

function TFhirTask.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := IdentifierList.new()
  else if (propName = 'instantiatesCanonical') then result := TFhirCanonical.create()
  else if (propName = 'instantiatesUri') then result := TFhirUri.create()
  else if (propName = 'basedOn') then result := BasedOnList.new()
  else if (propName = 'groupIdentifier') then result := TFhirIdentifier.create()
  else if (propName = 'partOf') then result := PartOfList.new()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirTaskStatusEnum[TaskStatusNull], CODES_TFhirTaskStatusEnum[TaskStatusNull]) 
  else if (propName = 'statusReason') then result := TFhirCodeableConcept.create()
  else if (propName = 'businessStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'intent') then result := TFhirEnum.create(SYSTEMS_TFhirTaskIntentEnum[TaskIntentNull], CODES_TFhirTaskIntentEnum[TaskIntentNull]) 
  else if (propName = 'priority') then result := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[RequestPriorityNull], CODES_TFhirRequestPriorityEnum[RequestPriorityNull]) 
  else if (propName = 'code') then result := TFhirCodeableConcept.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'focus') then result := TFhirReference.create()
  else if (propName = 'for') then result := TFhirReference.create()
  else if (propName = 'encounter') then result := TFhirReference.create()
  else if (propName = 'executionPeriod') then result := TFhirPeriod.create()
  else if (propName = 'authoredOn') then result := TFhirDateTime.create()
  else if (propName = 'lastModified') then result := TFhirDateTime.create()
  else if (propName = 'requester') then result := TFhirReference.create()
  else if (propName = 'performerType') then result := PerformerTypeList.new()
  else if (propName = 'owner') then result := TFhirReference.create()
  else if (propName = 'location') then result := TFhirReference.create()
  else if (propName = 'reasonCode') then result := TFhirCodeableConcept.create()
  else if (propName = 'reasonReference') then result := TFhirReference.create()
  else if (propName = 'insurance') then result := InsuranceList.new()
  else if (propName = 'note') then result := NoteList.new()
  else if (propName = 'relevantHistory') then result := RelevantHistoryList.new()
  else if (propName = 'restriction') then result := TFhirTaskRestriction.create()
  else if (propName = 'input') then result := InputList.new()
  else if (propName = 'output') then result := OutputList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTask.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'instantiatesCanonical') then result := 'canonical'
  else if (propName = 'instantiatesUri') then result := 'uri'
  else if (propName = 'basedOn') then result := 'Reference'
  else if (propName = 'groupIdentifier') then result := 'Identifier'
  else if (propName = 'partOf') then result := 'Reference'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusReason') then result := 'CodeableConcept'
  else if (propName = 'businessStatus') then result := 'CodeableConcept'
  else if (propName = 'intent') then result := 'code'
  else if (propName = 'priority') then result := 'code'
  else if (propName = 'code') then result := 'CodeableConcept'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'focus') then result := 'Reference'
  else if (propName = 'for') then result := 'Reference'
  else if (propName = 'encounter') then result := 'Reference'
  else if (propName = 'executionPeriod') then result := 'Period'
  else if (propName = 'authoredOn') then result := 'dateTime'
  else if (propName = 'lastModified') then result := 'dateTime'
  else if (propName = 'requester') then result := 'Reference'
  else if (propName = 'performerType') then result := 'CodeableConcept'
  else if (propName = 'owner') then result := 'Reference'
  else if (propName = 'location') then result := 'Reference'
  else if (propName = 'reasonCode') then result := 'CodeableConcept'
  else if (propName = 'reasonReference') then result := 'Reference'
  else if (propName = 'insurance') then result := 'Reference'
  else if (propName = 'note') then result := 'Annotation'
  else if (propName = 'relevantHistory') then result := 'Reference'
  else if (propName = 'restriction') then result := 'BackboneElement'
  else if (propName = 'input') then result := 'BackboneElement'
  else if (propName = 'output') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTask.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then deletePropertyValue('identifier', IdentifierList, value)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := nil
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := nil
  else if (propName = 'basedOn') then deletePropertyValue('basedOn', BasedOnList, value)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := nil
  else if (propName = 'partOf') then deletePropertyValue('partOf', PartOfList, value)
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusReason') then StatusReasonElement := nil
  else if (propName = 'businessStatus') then BusinessStatusElement := nil
  else if (propName = 'intent') then IntentElement := nil
  else if (propName = 'priority') then PriorityElement := nil
  else if (propName = 'code') then CodeElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'focus') then FocusElement := nil
  else if (propName = 'for') then For_Element := nil
  else if (propName = 'encounter') then EncounterElement := nil
  else if (propName = 'executionPeriod') then ExecutionPeriodElement := nil
  else if (propName = 'authoredOn') then AuthoredOnElement := nil
  else if (propName = 'lastModified') then LastModifiedElement := nil
  else if (propName = 'requester') then RequesterElement := nil
  else if (propName = 'performerType') then deletePropertyValue('performerType', PerformerTypeList, value)
  else if (propName = 'owner') then OwnerElement := nil
  else if (propName = 'location') then LocationElement := nil
  else if (propName = 'reasonCode') then ReasonCodeElement := nil
  else if (propName = 'reasonReference') then ReasonReferenceElement := nil
  else if (propName = 'insurance') then deletePropertyValue('insurance', InsuranceList, value)
  else if (propName = 'note') then deletePropertyValue('note', NoteList, value)
  else if (propName = 'relevantHistory') then deletePropertyValue('relevantHistory', RelevantHistoryList, value)
  else if (propName = 'restriction') then RestrictionElement := nil
  else if (propName = 'input') then deletePropertyValue('input', InputList, value)
  else if (propName = 'output') then deletePropertyValue('output', OutputList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTask.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then replacePropertyValue('identifier', IdentifierList, existing, new)
  else if (propName = 'instantiatesCanonical') then InstantiatesCanonicalElement := asCanonical(new)
  else if (propName = 'instantiatesUri') then InstantiatesUriElement := asUri(new)
  else if (propName = 'basedOn') then replacePropertyValue('basedOn', BasedOnList, existing, new)
  else if (propName = 'groupIdentifier') then GroupIdentifierElement := new as TFhirIdentifier
  else if (propName = 'partOf') then replacePropertyValue('partOf', PartOfList, existing, new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirTaskStatusEnum, CODES_TFhirTaskStatusEnum, new)
  else if (propName = 'statusReason') then StatusReasonElement := new as TFhirCodeableConcept
  else if (propName = 'businessStatus') then BusinessStatusElement := new as TFhirCodeableConcept
  else if (propName = 'intent') then IntentElement := asEnum(SYSTEMS_TFhirTaskIntentEnum, CODES_TFhirTaskIntentEnum, new)
  else if (propName = 'priority') then PriorityElement := asEnum(SYSTEMS_TFhirRequestPriorityEnum, CODES_TFhirRequestPriorityEnum, new)
  else if (propName = 'code') then CodeElement := new as TFhirCodeableConcept
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'focus') then FocusElement := new as TFhirReference
  else if (propName = 'for') then For_Element := new as TFhirReference
  else if (propName = 'encounter') then EncounterElement := new as TFhirReference
  else if (propName = 'executionPeriod') then ExecutionPeriodElement := new as TFhirPeriod
  else if (propName = 'authoredOn') then AuthoredOnElement := asDateTime(new)
  else if (propName = 'lastModified') then LastModifiedElement := asDateTime(new)
  else if (propName = 'requester') then RequesterElement := new as TFhirReference
  else if (propName = 'performerType') then replacePropertyValue('performerType', PerformerTypeList, existing, new)
  else if (propName = 'owner') then OwnerElement := new as TFhirReference
  else if (propName = 'location') then LocationElement := new as TFhirReference
  else if (propName = 'reasonCode') then ReasonCodeElement := new as TFhirCodeableConcept
  else if (propName = 'reasonReference') then ReasonReferenceElement := new as TFhirReference
  else if (propName = 'insurance') then replacePropertyValue('insurance', InsuranceList, existing, new)
  else if (propName = 'note') then replacePropertyValue('note', NoteList, existing, new)
  else if (propName = 'relevantHistory') then replacePropertyValue('relevantHistory', RelevantHistoryList, existing, new)
  else if (propName = 'restriction') then RestrictionElement := new as TFhirTaskRestriction
  else if (propName = 'input') then replacePropertyValue('input', InputList, existing, new)
  else if (propName = 'output') then replacePropertyValue('output', OutputList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTask.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'identifier') then IdentifierList.move(source, destination)
  else if (propName = 'basedOn') then BasedOnList.move(source, destination)
  else if (propName = 'partOf') then PartOfList.move(source, destination)
  else if (propName = 'performerType') then PerformerTypeList.move(source, destination)
  else if (propName = 'insurance') then InsuranceList.move(source, destination)
  else if (propName = 'note') then NoteList.move(source, destination)
  else if (propName = 'relevantHistory') then RelevantHistoryList.move(source, destination)
  else if (propName = 'input') then InputList.move(source, destination)
  else if (propName = 'output') then OutputList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTask.fhirType : string;
begin
  result := 'Task';
end;

function TFhirTask.Link : TFhirTask;
begin
  result := TFhirTask(inherited Link);
end;

function TFhirTask.Clone : TFhirTask;
begin
  result := TFhirTask(inherited Clone);
end;

function TFhirTask.equals(other : TObject) : boolean; 
var
  o : TFhirTask;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTask)) then
    result := false
  else
  begin
    o := TFhirTask(other);
    result := compareDeep(identifierList, o.identifierList, true) and compareDeep(instantiatesCanonicalElement, o.instantiatesCanonicalElement, true) and 
      compareDeep(instantiatesUriElement, o.instantiatesUriElement, true) and compareDeep(basedOnList, o.basedOnList, true) and 
      compareDeep(groupIdentifierElement, o.groupIdentifierElement, true) and compareDeep(partOfList, o.partOfList, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(statusReasonElement, o.statusReasonElement, true) and 
      compareDeep(businessStatusElement, o.businessStatusElement, true) and compareDeep(intentElement, o.intentElement, true) and 
      compareDeep(priorityElement, o.priorityElement, true) and compareDeep(codeElement, o.codeElement, true) and 
      compareDeep(descriptionElement, o.descriptionElement, true) and compareDeep(focusElement, o.focusElement, true) and 
      compareDeep(for_Element, o.for_Element, true) and compareDeep(encounterElement, o.encounterElement, true) and 
      compareDeep(executionPeriodElement, o.executionPeriodElement, true) and compareDeep(authoredOnElement, o.authoredOnElement, true) and 
      compareDeep(lastModifiedElement, o.lastModifiedElement, true) and compareDeep(requesterElement, o.requesterElement, true) and 
      compareDeep(performerTypeList, o.performerTypeList, true) and compareDeep(ownerElement, o.ownerElement, true) and 
      compareDeep(locationElement, o.locationElement, true) and compareDeep(reasonCodeElement, o.reasonCodeElement, true) and 
      compareDeep(reasonReferenceElement, o.reasonReferenceElement, true) and compareDeep(insuranceList, o.insuranceList, true) and 
      compareDeep(noteList, o.noteList, true) and compareDeep(relevantHistoryList, o.relevantHistoryList, true) and 
      compareDeep(restrictionElement, o.restrictionElement, true) and compareDeep(inputList, o.inputList, true) and 
      compareDeep(outputList, o.outputList, true);
  end;
end;

function TFhirTask.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FidentifierList) and isEmptyProp(FInstantiatesCanonical) and isEmptyProp(FInstantiatesUri) and isEmptyProp(FbasedOnList) and isEmptyProp(FGroupIdentifier) and isEmptyProp(FpartOfList) and isEmptyProp(FStatus) and isEmptyProp(FStatusReason) and isEmptyProp(FBusinessStatus) and isEmptyProp(FIntent) and isEmptyProp(FPriority) and isEmptyProp(FCode) and isEmptyProp(FDescription) and isEmptyProp(FFocus) and isEmptyProp(FFor_) and isEmptyProp(FEncounter) and isEmptyProp(FExecutionPeriod) and isEmptyProp(FAuthoredOn) and isEmptyProp(FLastModified) and isEmptyProp(FRequester) and isEmptyProp(FperformerTypeList) and isEmptyProp(FOwner) and isEmptyProp(FLocation) and isEmptyProp(FReasonCode) and isEmptyProp(FReasonReference) and isEmptyProp(FinsuranceList) and isEmptyProp(FnoteList) and isEmptyProp(FrelevantHistoryList) and isEmptyProp(FRestriction) and isEmptyProp(FinputList) and isEmptyProp(FoutputList);
end;

procedure TFhirTask.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('instantiatesCanonical');
  fields.add('instantiatesUri');
  fields.add('basedOn');
  fields.add('groupIdentifier');
  fields.add('partOf');
  fields.add('status');
  fields.add('statusReason');
  fields.add('businessStatus');
  fields.add('intent');
  fields.add('priority');
  fields.add('code');
  fields.add('description');
  fields.add('focus');
  fields.add('for');
  fields.add('encounter');
  fields.add('executionPeriod');
  fields.add('authoredOn');
  fields.add('lastModified');
  fields.add('requester');
  fields.add('performerType');
  fields.add('owner');
  fields.add('location');
  fields.add('reasonCode');
  fields.add('reasonReference');
  fields.add('insurance');
  fields.add('note');
  fields.add('relevantHistory');
  fields.add('restriction');
  fields.add('input');
  fields.add('output');
end;

function TFhirTask.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FIdentifierList.sizeInBytes(magic));
  inc(result, FBasedOnList.sizeInBytes(magic));
  inc(result, FPartOfList.sizeInBytes(magic));
  inc(result, FPerformerTypeList.sizeInBytes(magic));
  inc(result, FInsuranceList.sizeInBytes(magic));
  inc(result, FNoteList.sizeInBytes(magic));
  inc(result, FRelevantHistoryList.sizeInBytes(magic));
  inc(result, FInputList.sizeInBytes(magic));
  inc(result, FOutputList.sizeInBytes(magic));
end;

function TFhirTask.GetIdentifierList : TFhirIdentifierList;
begin
  if FIdentifierList = nil then
    FIdentifierList := TFhirIdentifierList.Create;
  result := FIdentifierList;
end;

function TFhirTask.GetHasIdentifierList : boolean;
begin
  result := (FIdentifierList <> nil) and (FIdentifierList.count > 0);
end;

procedure TFhirTask.SetInstantiatesCanonical(value : TFhirCanonical);
begin
  FInstantiatesCanonical.free;
  FInstantiatesCanonical := value;
end;

function TFhirTask.GetInstantiatesCanonicalST : String;
begin
  if FInstantiatesCanonical = nil then
    result := ''
  else
    result := FInstantiatesCanonical.value;
end;

procedure TFhirTask.SetInstantiatesCanonicalST(value : String);
begin
  if value <> '' then
  begin
    if FInstantiatesCanonical = nil then
      FInstantiatesCanonical := TFhirCanonical.create;
    FInstantiatesCanonical.value := value
  end
  else if FInstantiatesCanonical <> nil then
    FInstantiatesCanonical.value := '';
end;

procedure TFhirTask.SetInstantiatesUri(value : TFhirUri);
begin
  FInstantiatesUri.free;
  FInstantiatesUri := value;
end;

function TFhirTask.GetInstantiatesUriST : String;
begin
  if FInstantiatesUri = nil then
    result := ''
  else
    result := FInstantiatesUri.value;
end;

procedure TFhirTask.SetInstantiatesUriST(value : String);
begin
  if value <> '' then
  begin
    if FInstantiatesUri = nil then
      FInstantiatesUri := TFhirUri.create;
    FInstantiatesUri.value := value
  end
  else if FInstantiatesUri <> nil then
    FInstantiatesUri.value := '';
end;

function TFhirTask.GetBasedOnList : TFhirReferenceList;
begin
  if FBasedOnList = nil then
    FBasedOnList := TFhirReferenceList.Create;
  result := FBasedOnList;
end;

function TFhirTask.GetHasBasedOnList : boolean;
begin
  result := (FBasedOnList <> nil) and (FBasedOnList.count > 0);
end;

procedure TFhirTask.SetGroupIdentifier(value : TFhirIdentifier);
begin
  FGroupIdentifier.free;
  FGroupIdentifier := value;
end;

function TFhirTask.GetPartOfList : TFhirReferenceList;
begin
  if FPartOfList = nil then
    FPartOfList := TFhirReferenceList.Create;
  result := FPartOfList;
end;

function TFhirTask.GetHasPartOfList : boolean;
begin
  result := (FPartOfList <> nil) and (FPartOfList.count > 0);
end;

procedure TFhirTask.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirTask.GetStatusST : TFhirTaskStatusEnum;
begin
  if FStatus = nil then
    result := TFhirTaskStatusEnum(0)
  else
    result := TFhirTaskStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirTaskStatusEnum, FStatus.value));
end;

procedure TFhirTask.SetStatusST(value : TFhirTaskStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirTaskStatusEnum[value], CODES_TFhirTaskStatusEnum[value]);
end;

procedure TFhirTask.SetStatusReason(value : TFhirCodeableConcept);
begin
  FStatusReason.free;
  FStatusReason := value;
end;

procedure TFhirTask.SetBusinessStatus(value : TFhirCodeableConcept);
begin
  FBusinessStatus.free;
  FBusinessStatus := value;
end;

procedure TFhirTask.SetIntent(value : TFhirEnum);
begin
  FIntent.free;
  FIntent := value;
end;

function TFhirTask.GetIntentST : TFhirTaskIntentEnum;
begin
  if FIntent = nil then
    result := TFhirTaskIntentEnum(0)
  else
    result := TFhirTaskIntentEnum(StringArrayIndexOfSensitive(CODES_TFhirTaskIntentEnum, FIntent.value));
end;

procedure TFhirTask.SetIntentST(value : TFhirTaskIntentEnum);
begin
  if ord(value) = 0 then
    IntentElement := nil
  else
    IntentElement := TFhirEnum.create(SYSTEMS_TFhirTaskIntentEnum[value], CODES_TFhirTaskIntentEnum[value]);
end;

procedure TFhirTask.SetPriority(value : TFhirEnum);
begin
  FPriority.free;
  FPriority := value;
end;

function TFhirTask.GetPriorityST : TFhirRequestPriorityEnum;
begin
  if FPriority = nil then
    result := TFhirRequestPriorityEnum(0)
  else
    result := TFhirRequestPriorityEnum(StringArrayIndexOfSensitive(CODES_TFhirRequestPriorityEnum, FPriority.value));
end;

procedure TFhirTask.SetPriorityST(value : TFhirRequestPriorityEnum);
begin
  if ord(value) = 0 then
    PriorityElement := nil
  else
    PriorityElement := TFhirEnum.create(SYSTEMS_TFhirRequestPriorityEnum[value], CODES_TFhirRequestPriorityEnum[value]);
end;

procedure TFhirTask.SetCode(value : TFhirCodeableConcept);
begin
  FCode.free;
  FCode := value;
end;

procedure TFhirTask.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTask.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTask.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

procedure TFhirTask.SetFocus(value : TFhirReference);
begin
  FFocus.free;
  FFocus := value;
end;

procedure TFhirTask.SetFor_(value : TFhirReference);
begin
  FFor_.free;
  FFor_ := value;
end;

procedure TFhirTask.SetEncounter(value : TFhirReference);
begin
  FEncounter.free;
  FEncounter := value;
end;

procedure TFhirTask.SetExecutionPeriod(value : TFhirPeriod);
begin
  FExecutionPeriod.free;
  FExecutionPeriod := value;
end;

procedure TFhirTask.SetAuthoredOn(value : TFhirDateTime);
begin
  FAuthoredOn.free;
  FAuthoredOn := value;
end;

function TFhirTask.GetAuthoredOnST : TFslDateTime;
begin
  if FAuthoredOn = nil then
    result := TFslDateTime.makeNull
  else
    result := FAuthoredOn.value;
end;

procedure TFhirTask.SetAuthoredOnST(value : TFslDateTime);
begin
  if FAuthoredOn = nil then
    FAuthoredOn := TFhirDateTime.create;
  FAuthoredOn.value := value
end;

procedure TFhirTask.SetLastModified(value : TFhirDateTime);
begin
  FLastModified.free;
  FLastModified := value;
end;

function TFhirTask.GetLastModifiedST : TFslDateTime;
begin
  if FLastModified = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastModified.value;
end;

procedure TFhirTask.SetLastModifiedST(value : TFslDateTime);
begin
  if FLastModified = nil then
    FLastModified := TFhirDateTime.create;
  FLastModified.value := value
end;

procedure TFhirTask.SetRequester(value : TFhirReference);
begin
  FRequester.free;
  FRequester := value;
end;

function TFhirTask.GetPerformerTypeList : TFhirCodeableConceptList;
begin
  if FPerformerTypeList = nil then
    FPerformerTypeList := TFhirCodeableConceptList.Create;
  result := FPerformerTypeList;
end;

function TFhirTask.GetHasPerformerTypeList : boolean;
begin
  result := (FPerformerTypeList <> nil) and (FPerformerTypeList.count > 0);
end;

procedure TFhirTask.SetOwner(value : TFhirReference);
begin
  FOwner.free;
  FOwner := value;
end;

procedure TFhirTask.SetLocation(value : TFhirReference);
begin
  FLocation.free;
  FLocation := value;
end;

procedure TFhirTask.SetReasonCode(value : TFhirCodeableConcept);
begin
  FReasonCode.free;
  FReasonCode := value;
end;

procedure TFhirTask.SetReasonReference(value : TFhirReference);
begin
  FReasonReference.free;
  FReasonReference := value;
end;

function TFhirTask.GetInsuranceList : TFhirReferenceList;
begin
  if FInsuranceList = nil then
    FInsuranceList := TFhirReferenceList.Create;
  result := FInsuranceList;
end;

function TFhirTask.GetHasInsuranceList : boolean;
begin
  result := (FInsuranceList <> nil) and (FInsuranceList.count > 0);
end;

function TFhirTask.GetNoteList : TFhirAnnotationList;
begin
  if FNoteList = nil then
    FNoteList := TFhirAnnotationList.Create;
  result := FNoteList;
end;

function TFhirTask.GetHasNoteList : boolean;
begin
  result := (FNoteList <> nil) and (FNoteList.count > 0);
end;

function TFhirTask.GetRelevantHistoryList : TFhirReferenceList;
begin
  if FRelevantHistoryList = nil then
    FRelevantHistoryList := TFhirReferenceList.Create;
  result := FRelevantHistoryList;
end;

function TFhirTask.GetHasRelevantHistoryList : boolean;
begin
  result := (FRelevantHistoryList <> nil) and (FRelevantHistoryList.count > 0);
end;

procedure TFhirTask.SetRestriction(value : TFhirTaskRestriction);
begin
  FRestriction.free;
  FRestriction := value;
end;

function TFhirTask.GetInputList : TFhirTaskInputList;
begin
  if FInputList = nil then
    FInputList := TFhirTaskInputList.Create;
  result := FInputList;
end;

function TFhirTask.GetHasInputList : boolean;
begin
  result := (FInputList <> nil) and (FInputList.count > 0);
end;

function TFhirTask.GetOutputList : TFhirTaskOutputList;
begin
  if FOutputList = nil then
    FOutputList := TFhirTaskOutputList.Create;
  result := FOutputList;
end;

function TFhirTask.GetHasOutputList : boolean;
begin
  result := (FOutputList <> nil) and (FOutputList.count > 0);
end;

{ TFhirTaskListEnumerator }

constructor TFhirTaskListEnumerator.Create(list : TFhirTaskList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTaskListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTaskListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTaskListEnumerator.GetCurrent : TFhirTask;
begin
  Result := FList[FIndex];
end;

function TFhirTaskListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTaskList }

function TFhirTaskList.AddItem(value: TFhirTask): TFhirTask;
begin
  assert(value.ClassName = 'TFhirTask', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTask');
  add(value);
  result := value;
end;

function TFhirTaskList.Append: TFhirTask;
begin
  result := TFhirTask.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskList.ClearItems;
begin
  Clear;
end;

function TFhirTaskList.GetEnumerator : TFhirTaskListEnumerator;
begin
  result := TFhirTaskListEnumerator.Create(self.link);
end;

function TFhirTaskList.Clone: TFhirTaskList;
begin
  result := TFhirTaskList(inherited Clone);
end;

function TFhirTaskList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTaskList.GetItemN(index: Integer): TFhirTask;
begin
  result := TFhirTask(ObjectByIndex[index]);
end;

function TFhirTaskList.ItemClass: TFslObjectClass;
begin
  result := TFhirTask;
end;
function TFhirTaskList.IndexOf(value: TFhirTask): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTaskList.Insert(index: Integer): TFhirTask;
begin
  result := TFhirTask.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTaskList.InsertItem(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  Inherited Insert(index, value);
end;

function TFhirTaskList.Item(index: Integer): TFhirTask;
begin
  result := TFhirTask(ObjectByIndex[index]);
end;

function TFhirTaskList.Link: TFhirTaskList;
begin
  result := TFhirTaskList(inherited Link);
end;

procedure TFhirTaskList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTaskList.SetItemByIndex(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  FhirTasks[index] := value;
end;

procedure TFhirTaskList.SetItemN(index: Integer; value: TFhirTask);
begin
  assert(value is TFhirTask);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TASK}
{$IFDEF FHIR_TESTREPORT}
{ TFhirTestReportParticipant }

constructor TFhirTestReportParticipant.Create;
begin
  inherited;
end;

destructor TFhirTestReportParticipant.Destroy;
begin
  FType_.free;
  FUri.free;
  FDisplay.free;
  inherited;
end;

procedure TFhirTestReportParticipant.Assign(oSource : TFslObject);
begin
  inherited;
  type_Element := TFhirTestReportParticipant(oSource).type_Element.Clone;
  uriElement := TFhirTestReportParticipant(oSource).uriElement.Clone;
  displayElement := TFhirTestReportParticipant(oSource).displayElement.Clone;
end;

procedure TFhirTestReportParticipant.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'type') Then
     list.add(self.link, 'type', FType_.Link);
  if (child_name = 'uri') Then
     list.add(self.link, 'uri', FUri.Link);
  if (child_name = 'display') Then
     list.add(self.link, 'display', FDisplay.Link);
end;

procedure TFhirTestReportParticipant.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'type', 'code', false, TFhirEnum, FType_.Link));
  oList.add(TFHIRProperty.create(self, 'uri', 'uri', false, TFhirUri, FUri.Link));
  oList.add(TFHIRProperty.create(self, 'display', 'string', false, TFhirString, FDisplay.Link));
end;

function TFhirTestReportParticipant.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'type') then
  begin
    Type_Element := asEnum(SYSTEMS_TFhirTestReportParticipantTypeEnum, CODES_TFhirTestReportParticipantTypeEnum, propValue);
    result := propValue;
  end
  else if (propName = 'uri') then
  begin
    UriElement := asUri(propValue);
    result := propValue;
  end
  else if (propName = 'display') then
  begin
    DisplayElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportParticipant.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportParticipant.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'type') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportParticipantTypeEnum[TestReportParticipantTypeNull], CODES_TFhirTestReportParticipantTypeEnum[TestReportParticipantTypeNull]) 
  else if (propName = 'uri') then result := TFhirUri.create()
  else if (propName = 'display') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportParticipant.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'type') then result := 'code'
  else if (propName = 'uri') then result := 'uri'
  else if (propName = 'display') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportParticipant.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := nil
  else if (propName = 'uri') then UriElement := nil
  else if (propName = 'display') then DisplayElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportParticipant.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'type') then Type_Element := asEnum(SYSTEMS_TFhirTestReportParticipantTypeEnum, CODES_TFhirTestReportParticipantTypeEnum, new)
  else if (propName = 'uri') then UriElement := asUri(new)
  else if (propName = 'display') then DisplayElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportParticipant.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportParticipant.fhirType : string;
begin
  result := 'TestReport.participant';
end;

function TFhirTestReportParticipant.Link : TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(inherited Link);
end;

function TFhirTestReportParticipant.Clone : TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(inherited Clone);
end;

function TFhirTestReportParticipant.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportParticipant;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportParticipant)) then
    result := false
  else
  begin
    o := TFhirTestReportParticipant(other);
    result := compareDeep(type_Element, o.type_Element, true) and compareDeep(uriElement, o.uriElement, true) and 
      compareDeep(displayElement, o.displayElement, true);
  end;
end;

function TFhirTestReportParticipant.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FType_) and isEmptyProp(FUri) and isEmptyProp(FDisplay);
end;

procedure TFhirTestReportParticipant.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('type');
  fields.add('uri');
  fields.add('display');
end;

function TFhirTestReportParticipant.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportParticipant.SetType_(value : TFhirEnum);
begin
  FType_.free;
  FType_ := value;
end;

function TFhirTestReportParticipant.GetType_ST : TFhirTestReportParticipantTypeEnum;
begin
  if FType_ = nil then
    result := TFhirTestReportParticipantTypeEnum(0)
  else
    result := TFhirTestReportParticipantTypeEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportParticipantTypeEnum, FType_.value));
end;

procedure TFhirTestReportParticipant.SetType_ST(value : TFhirTestReportParticipantTypeEnum);
begin
  if ord(value) = 0 then
    Type_Element := nil
  else
    Type_Element := TFhirEnum.create(SYSTEMS_TFhirTestReportParticipantTypeEnum[value], CODES_TFhirTestReportParticipantTypeEnum[value]);
end;

procedure TFhirTestReportParticipant.SetUri(value : TFhirUri);
begin
  FUri.free;
  FUri := value;
end;

function TFhirTestReportParticipant.GetUriST : String;
begin
  if FUri = nil then
    result := ''
  else
    result := FUri.value;
end;

procedure TFhirTestReportParticipant.SetUriST(value : String);
begin
  if value <> '' then
  begin
    if FUri = nil then
      FUri := TFhirUri.create;
    FUri.value := value
  end
  else if FUri <> nil then
    FUri.value := '';
end;

procedure TFhirTestReportParticipant.SetDisplay(value : TFhirString);
begin
  FDisplay.free;
  FDisplay := value;
end;

function TFhirTestReportParticipant.GetDisplayST : String;
begin
  if FDisplay = nil then
    result := ''
  else
    result := FDisplay.value;
end;

procedure TFhirTestReportParticipant.SetDisplayST(value : String);
begin
  if value <> '' then
  begin
    if FDisplay = nil then
      FDisplay := TFhirString.create;
    FDisplay.value := value
  end
  else if FDisplay <> nil then
    FDisplay.value := '';
end;

{ TFhirTestReportParticipantListEnumerator }

constructor TFhirTestReportParticipantListEnumerator.Create(list : TFhirTestReportParticipantList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportParticipantListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportParticipantListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportParticipantListEnumerator.GetCurrent : TFhirTestReportParticipant;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportParticipantListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportParticipantList }

function TFhirTestReportParticipantList.AddItem(value: TFhirTestReportParticipant): TFhirTestReportParticipant;
begin
  assert(value.ClassName = 'TFhirTestReportParticipant', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportParticipant');
  add(value);
  result := value;
end;

function TFhirTestReportParticipantList.Append: TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportParticipantList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportParticipantList.GetEnumerator : TFhirTestReportParticipantListEnumerator;
begin
  result := TFhirTestReportParticipantListEnumerator.Create(self.link);
end;

function TFhirTestReportParticipantList.Clone: TFhirTestReportParticipantList;
begin
  result := TFhirTestReportParticipantList(inherited Clone);
end;

function TFhirTestReportParticipantList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportParticipantList.GetItemN(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(ObjectByIndex[index]);
end;

function TFhirTestReportParticipantList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportParticipant;
end;
function TFhirTestReportParticipantList.IndexOf(value: TFhirTestReportParticipant): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportParticipantList.Insert(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportParticipantList.InsertItem(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  Inherited Insert(index, value);
end;

function TFhirTestReportParticipantList.Item(index: Integer): TFhirTestReportParticipant;
begin
  result := TFhirTestReportParticipant(ObjectByIndex[index]);
end;

function TFhirTestReportParticipantList.Link: TFhirTestReportParticipantList;
begin
  result := TFhirTestReportParticipantList(inherited Link);
end;

procedure TFhirTestReportParticipantList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportParticipantList.SetItemByIndex(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  FhirTestReportParticipants[index] := value;
end;

procedure TFhirTestReportParticipantList.SetItemN(index: Integer; value: TFhirTestReportParticipant);
begin
  assert(value is TFhirTestReportParticipant);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetup }

constructor TFhirTestReportSetup.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetup.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportSetup.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestReportSetup(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportSetupActionList.Create;
    FActionList.Assign(TFhirTestReportSetup(oSource).FActionList);
  end;
end;

procedure TFhirTestReportSetup.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportSetup.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirTestReportSetupAction, FActionList.Link));
end;

function TFhirTestReportSetup.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportSetupAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetup.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportSetupAction)
  else inherited;
end;

function TFhirTestReportSetup.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetup.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetup.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetup.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetup.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetup.fhirType : string;
begin
  result := 'TestReport.setup';
end;

function TFhirTestReportSetup.Link : TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(inherited Link);
end;

function TFhirTestReportSetup.Clone : TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(inherited Clone);
end;

function TFhirTestReportSetup.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetup;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetup)) then
    result := false
  else
  begin
    o := TFhirTestReportSetup(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportSetup.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestReportSetup.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('action');
end;

function TFhirTestReportSetup.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActionList.sizeInBytes(magic));
end;

function TFhirTestReportSetup.GetActionList : TFhirTestReportSetupActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportSetupActionList.Create;
  result := FActionList;
end;

function TFhirTestReportSetup.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirTestReportSetupListEnumerator }

constructor TFhirTestReportSetupListEnumerator.Create(list : TFhirTestReportSetupList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupListEnumerator.GetCurrent : TFhirTestReportSetup;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportSetupList }

function TFhirTestReportSetupList.AddItem(value: TFhirTestReportSetup): TFhirTestReportSetup;
begin
  assert(value.ClassName = 'TFhirTestReportSetup', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetup');
  add(value);
  result := value;
end;

function TFhirTestReportSetupList.Append: TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupList.GetEnumerator : TFhirTestReportSetupListEnumerator;
begin
  result := TFhirTestReportSetupListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupList.Clone: TFhirTestReportSetupList;
begin
  result := TFhirTestReportSetupList(inherited Clone);
end;

function TFhirTestReportSetupList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupList.GetItemN(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(ObjectByIndex[index]);
end;

function TFhirTestReportSetupList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetup;
end;
function TFhirTestReportSetupList.IndexOf(value: TFhirTestReportSetup): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupList.Insert(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupList.InsertItem(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupList.Item(index: Integer): TFhirTestReportSetup;
begin
  result := TFhirTestReportSetup(ObjectByIndex[index]);
end;

function TFhirTestReportSetupList.Link: TFhirTestReportSetupList;
begin
  result := TFhirTestReportSetupList(inherited Link);
end;

procedure TFhirTestReportSetupList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupList.SetItemByIndex(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  FhirTestReportSetups[index] := value;
end;

procedure TFhirTestReportSetupList.SetItemN(index: Integer; value: TFhirTestReportSetup);
begin
  assert(value is TFhirTestReportSetup);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupAction }

constructor TFhirTestReportSetupAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestReportSetupAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportSetupAction(oSource).operation.Clone;
  assert := TFhirTestReportSetupAction(oSource).assert.Clone;
end;

procedure TFhirTestReportSetupAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestReportSetupAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', 'BackboneElement', false, TFhirTestReportSetupActionOperation, FOperation.Link));
  oList.add(TFHIRProperty.create(self, 'assert', 'BackboneElement', false, TFhirTestReportSetupActionAssert, FAssert.Link));
end;

function TFhirTestReportSetupAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation;
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestReportSetupActionAssert;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create()
  else if (propName = 'assert') then result := TFhirTestReportSetupActionAssert.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := 'BackboneElement'
  else if (propName = 'assert') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation
  else if (propName = 'assert') then AssertElement := new as TFhirTestReportSetupActionAssert
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupAction.fhirType : string;
begin
  result := 'TestReport.setup.action';
end;

function TFhirTestReportSetupAction.Link : TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(inherited Link);
end;

function TFhirTestReportSetupAction.Clone : TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(inherited Clone);
end;

function TFhirTestReportSetupAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetupAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupAction)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestReportSetupAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestReportSetupAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

function TFhirTestReportSetupAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportSetupAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

procedure TFhirTestReportSetupAction.SetAssert(value : TFhirTestReportSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

{ TFhirTestReportSetupActionListEnumerator }

constructor TFhirTestReportSetupActionListEnumerator.Create(list : TFhirTestReportSetupActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionListEnumerator.GetCurrent : TFhirTestReportSetupAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportSetupActionList }

function TFhirTestReportSetupActionList.AddItem(value: TFhirTestReportSetupAction): TFhirTestReportSetupAction;
begin
  assert(value.ClassName = 'TFhirTestReportSetupAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupAction');
  add(value);
  result := value;
end;

function TFhirTestReportSetupActionList.Append: TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionList.GetEnumerator : TFhirTestReportSetupActionListEnumerator;
begin
  result := TFhirTestReportSetupActionListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionList.Clone: TFhirTestReportSetupActionList;
begin
  result := TFhirTestReportSetupActionList(inherited Clone);
end;

function TFhirTestReportSetupActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionList.GetItemN(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupAction;
end;
function TFhirTestReportSetupActionList.IndexOf(value: TFhirTestReportSetupAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionList.Insert(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionList.InsertItem(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionList.Item(index: Integer): TFhirTestReportSetupAction;
begin
  result := TFhirTestReportSetupAction(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionList.Link: TFhirTestReportSetupActionList;
begin
  result := TFhirTestReportSetupActionList(inherited Link);
end;

procedure TFhirTestReportSetupActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  FhirTestReportSetupActions[index] := value;
end;

procedure TFhirTestReportSetupActionList.SetItemN(index: Integer; value: TFhirTestReportSetupAction);
begin
  assert(value is TFhirTestReportSetupAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupActionOperation }

constructor TFhirTestReportSetupActionOperation.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupActionOperation.Destroy;
begin
  FResult.free;
  FMessage.free;
  FDetail.free;
  inherited;
end;

procedure TFhirTestReportSetupActionOperation.Assign(oSource : TFslObject);
begin
  inherited;
  resultElement := TFhirTestReportSetupActionOperation(oSource).resultElement.Clone;
  messageElement := TFhirTestReportSetupActionOperation(oSource).messageElement.Clone;
  detailElement := TFhirTestReportSetupActionOperation(oSource).detailElement.Clone;
end;

procedure TFhirTestReportSetupActionOperation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirTestReportSetupActionOperation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFhirEnum, FResult.Link));
  oList.add(TFHIRProperty.create(self, 'message', 'markdown', false, TFhirMarkdown, FMessage.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'uri', false, TFhirUri, FDetail.Link));
end;

function TFhirTestReportSetupActionOperation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirTestReportActionResultEnum, CODES_TFhirTestReportActionResultEnum, propValue);
    result := propValue;
  end
  else if (propName = 'message') then
  begin
    MessageElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asUri(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupActionOperation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupActionOperation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'result') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportActionResultEnum[TestReportActionResultNull], CODES_TFhirTestReportActionResultEnum[TestReportActionResultNull]) 
  else if (propName = 'message') then result := TFhirMarkdown.create()
  else if (propName = 'detail') then result := TFhirUri.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupActionOperation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'result') then result := 'code'
  else if (propName = 'message') then result := 'markdown'
  else if (propName = 'detail') then result := 'uri'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupActionOperation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := nil
  else if (propName = 'message') then MessageElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupActionOperation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirTestReportActionResultEnum, CODES_TFhirTestReportActionResultEnum, new)
  else if (propName = 'message') then MessageElement := asMarkdown(new)
  else if (propName = 'detail') then DetailElement := asUri(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupActionOperation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupActionOperation.fhirType : string;
begin
  result := 'TestReport.setup.action.operation';
end;

function TFhirTestReportSetupActionOperation.Link : TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(inherited Link);
end;

function TFhirTestReportSetupActionOperation.Clone : TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(inherited Clone);
end;

function TFhirTestReportSetupActionOperation.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetupActionOperation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupActionOperation)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupActionOperation(other);
    result := compareDeep(resultElement, o.resultElement, true) and compareDeep(messageElement, o.messageElement, true) and 
      compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirTestReportSetupActionOperation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResult) and isEmptyProp(FMessage) and isEmptyProp(FDetail);
end;

procedure TFhirTestReportSetupActionOperation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('result');
  fields.add('message');
  fields.add('detail');
end;

function TFhirTestReportSetupActionOperation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportSetupActionOperation.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

function TFhirTestReportSetupActionOperation.GetResultST : TFhirTestReportActionResultEnum;
begin
  if FResult = nil then
    result := TFhirTestReportActionResultEnum(0)
  else
    result := TFhirTestReportActionResultEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportActionResultEnum, FResult.value));
end;

procedure TFhirTestReportSetupActionOperation.SetResultST(value : TFhirTestReportActionResultEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirTestReportActionResultEnum[value], CODES_TFhirTestReportActionResultEnum[value]);
end;

procedure TFhirTestReportSetupActionOperation.SetMessage(value : TFhirMarkdown);
begin
  FMessage.free;
  FMessage := value;
end;

function TFhirTestReportSetupActionOperation.GetMessageST : String;
begin
  if FMessage = nil then
    result := ''
  else
    result := FMessage.value;
end;

procedure TFhirTestReportSetupActionOperation.SetMessageST(value : String);
begin
  if value <> '' then
  begin
    if FMessage = nil then
      FMessage := TFhirMarkdown.create;
    FMessage.value := value
  end
  else if FMessage <> nil then
    FMessage.value := '';
end;

procedure TFhirTestReportSetupActionOperation.SetDetail(value : TFhirUri);
begin
  FDetail.free;
  FDetail := value;
end;

function TFhirTestReportSetupActionOperation.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

procedure TFhirTestReportSetupActionOperation.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirUri.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

{ TFhirTestReportSetupActionOperationListEnumerator }

constructor TFhirTestReportSetupActionOperationListEnumerator.Create(list : TFhirTestReportSetupActionOperationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionOperationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionOperationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionOperationListEnumerator.GetCurrent : TFhirTestReportSetupActionOperation;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionOperationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportSetupActionOperationList }

function TFhirTestReportSetupActionOperationList.AddItem(value: TFhirTestReportSetupActionOperation): TFhirTestReportSetupActionOperation;
begin
  assert(value.ClassName = 'TFhirTestReportSetupActionOperation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupActionOperation');
  add(value);
  result := value;
end;

function TFhirTestReportSetupActionOperationList.Append: TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionOperationList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionOperationList.GetEnumerator : TFhirTestReportSetupActionOperationListEnumerator;
begin
  result := TFhirTestReportSetupActionOperationListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionOperationList.Clone: TFhirTestReportSetupActionOperationList;
begin
  result := TFhirTestReportSetupActionOperationList(inherited Clone);
end;

function TFhirTestReportSetupActionOperationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionOperationList.GetItemN(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionOperationList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupActionOperation;
end;
function TFhirTestReportSetupActionOperationList.IndexOf(value: TFhirTestReportSetupActionOperation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionOperationList.Insert(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionOperationList.InsertItem(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionOperationList.Item(index: Integer): TFhirTestReportSetupActionOperation;
begin
  result := TFhirTestReportSetupActionOperation(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionOperationList.Link: TFhirTestReportSetupActionOperationList;
begin
  result := TFhirTestReportSetupActionOperationList(inherited Link);
end;

procedure TFhirTestReportSetupActionOperationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionOperationList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  FhirTestReportSetupActionOperations[index] := value;
end;

procedure TFhirTestReportSetupActionOperationList.SetItemN(index: Integer; value: TFhirTestReportSetupActionOperation);
begin
  assert(value is TFhirTestReportSetupActionOperation);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportSetupActionAssert }

constructor TFhirTestReportSetupActionAssert.Create;
begin
  inherited;
end;

destructor TFhirTestReportSetupActionAssert.Destroy;
begin
  FResult.free;
  FMessage.free;
  FDetail.free;
  inherited;
end;

procedure TFhirTestReportSetupActionAssert.Assign(oSource : TFslObject);
begin
  inherited;
  resultElement := TFhirTestReportSetupActionAssert(oSource).resultElement.Clone;
  messageElement := TFhirTestReportSetupActionAssert(oSource).messageElement.Clone;
  detailElement := TFhirTestReportSetupActionAssert(oSource).detailElement.Clone;
end;

procedure TFhirTestReportSetupActionAssert.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'message') Then
     list.add(self.link, 'message', FMessage.Link);
  if (child_name = 'detail') Then
     list.add(self.link, 'detail', FDetail.Link);
end;

procedure TFhirTestReportSetupActionAssert.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFhirEnum, FResult.Link));
  oList.add(TFHIRProperty.create(self, 'message', 'markdown', false, TFhirMarkdown, FMessage.Link));
  oList.add(TFHIRProperty.create(self, 'detail', 'string', false, TFhirString, FDetail.Link));
end;

function TFhirTestReportSetupActionAssert.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirTestReportActionResultEnum, CODES_TFhirTestReportActionResultEnum, propValue);
    result := propValue;
  end
  else if (propName = 'message') then
  begin
    MessageElement := asMarkdown(propValue);
    result := propValue;
  end
  else if (propName = 'detail') then
  begin
    DetailElement := asString(propValue);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportSetupActionAssert.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportSetupActionAssert.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'result') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportActionResultEnum[TestReportActionResultNull], CODES_TFhirTestReportActionResultEnum[TestReportActionResultNull]) 
  else if (propName = 'message') then result := TFhirMarkdown.create()
  else if (propName = 'detail') then result := TFhirString.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportSetupActionAssert.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'result') then result := 'code'
  else if (propName = 'message') then result := 'markdown'
  else if (propName = 'detail') then result := 'string'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportSetupActionAssert.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := nil
  else if (propName = 'message') then MessageElement := nil
  else if (propName = 'detail') then DetailElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportSetupActionAssert.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirTestReportActionResultEnum, CODES_TFhirTestReportActionResultEnum, new)
  else if (propName = 'message') then MessageElement := asMarkdown(new)
  else if (propName = 'detail') then DetailElement := asString(new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportSetupActionAssert.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportSetupActionAssert.fhirType : string;
begin
  result := 'TestReport.setup.action.assert';
end;

function TFhirTestReportSetupActionAssert.Link : TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(inherited Link);
end;

function TFhirTestReportSetupActionAssert.Clone : TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(inherited Clone);
end;

function TFhirTestReportSetupActionAssert.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportSetupActionAssert;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportSetupActionAssert)) then
    result := false
  else
  begin
    o := TFhirTestReportSetupActionAssert(other);
    result := compareDeep(resultElement, o.resultElement, true) and compareDeep(messageElement, o.messageElement, true) and 
      compareDeep(detailElement, o.detailElement, true);
  end;
end;

function TFhirTestReportSetupActionAssert.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FResult) and isEmptyProp(FMessage) and isEmptyProp(FDetail);
end;

procedure TFhirTestReportSetupActionAssert.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('result');
  fields.add('message');
  fields.add('detail');
end;

function TFhirTestReportSetupActionAssert.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportSetupActionAssert.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

function TFhirTestReportSetupActionAssert.GetResultST : TFhirTestReportActionResultEnum;
begin
  if FResult = nil then
    result := TFhirTestReportActionResultEnum(0)
  else
    result := TFhirTestReportActionResultEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportActionResultEnum, FResult.value));
end;

procedure TFhirTestReportSetupActionAssert.SetResultST(value : TFhirTestReportActionResultEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirTestReportActionResultEnum[value], CODES_TFhirTestReportActionResultEnum[value]);
end;

procedure TFhirTestReportSetupActionAssert.SetMessage(value : TFhirMarkdown);
begin
  FMessage.free;
  FMessage := value;
end;

function TFhirTestReportSetupActionAssert.GetMessageST : String;
begin
  if FMessage = nil then
    result := ''
  else
    result := FMessage.value;
end;

procedure TFhirTestReportSetupActionAssert.SetMessageST(value : String);
begin
  if value <> '' then
  begin
    if FMessage = nil then
      FMessage := TFhirMarkdown.create;
    FMessage.value := value
  end
  else if FMessage <> nil then
    FMessage.value := '';
end;

procedure TFhirTestReportSetupActionAssert.SetDetail(value : TFhirString);
begin
  FDetail.free;
  FDetail := value;
end;

function TFhirTestReportSetupActionAssert.GetDetailST : String;
begin
  if FDetail = nil then
    result := ''
  else
    result := FDetail.value;
end;

procedure TFhirTestReportSetupActionAssert.SetDetailST(value : String);
begin
  if value <> '' then
  begin
    if FDetail = nil then
      FDetail := TFhirString.create;
    FDetail.value := value
  end
  else if FDetail <> nil then
    FDetail.value := '';
end;

{ TFhirTestReportSetupActionAssertListEnumerator }

constructor TFhirTestReportSetupActionAssertListEnumerator.Create(list : TFhirTestReportSetupActionAssertList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportSetupActionAssertListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportSetupActionAssertListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportSetupActionAssertListEnumerator.GetCurrent : TFhirTestReportSetupActionAssert;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportSetupActionAssertListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportSetupActionAssertList }

function TFhirTestReportSetupActionAssertList.AddItem(value: TFhirTestReportSetupActionAssert): TFhirTestReportSetupActionAssert;
begin
  assert(value.ClassName = 'TFhirTestReportSetupActionAssert', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportSetupActionAssert');
  add(value);
  result := value;
end;

function TFhirTestReportSetupActionAssertList.Append: TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionAssertList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportSetupActionAssertList.GetEnumerator : TFhirTestReportSetupActionAssertListEnumerator;
begin
  result := TFhirTestReportSetupActionAssertListEnumerator.Create(self.link);
end;

function TFhirTestReportSetupActionAssertList.Clone: TFhirTestReportSetupActionAssertList;
begin
  result := TFhirTestReportSetupActionAssertList(inherited Clone);
end;

function TFhirTestReportSetupActionAssertList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportSetupActionAssertList.GetItemN(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionAssertList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportSetupActionAssert;
end;
function TFhirTestReportSetupActionAssertList.IndexOf(value: TFhirTestReportSetupActionAssert): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportSetupActionAssertList.Insert(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportSetupActionAssertList.InsertItem(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  Inherited Insert(index, value);
end;

function TFhirTestReportSetupActionAssertList.Item(index: Integer): TFhirTestReportSetupActionAssert;
begin
  result := TFhirTestReportSetupActionAssert(ObjectByIndex[index]);
end;

function TFhirTestReportSetupActionAssertList.Link: TFhirTestReportSetupActionAssertList;
begin
  result := TFhirTestReportSetupActionAssertList(inherited Link);
end;

procedure TFhirTestReportSetupActionAssertList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportSetupActionAssertList.SetItemByIndex(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  FhirTestReportSetupActionAsserts[index] := value;
end;

procedure TFhirTestReportSetupActionAssertList.SetItemN(index: Integer; value: TFhirTestReportSetupActionAssert);
begin
  assert(value is TFhirTestReportSetupActionAssert);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTest }

constructor TFhirTestReportTest.Create;
begin
  inherited;
end;

destructor TFhirTestReportTest.Destroy;
begin
  FName.free;
  FDescription.free;
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportTest.Assign(oSource : TFslObject);
begin
  inherited;
  nameElement := TFhirTestReportTest(oSource).nameElement.Clone;
  descriptionElement := TFhirTestReportTest(oSource).descriptionElement.Clone;
  if (TFhirTestReportTest(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportTestActionList.Create;
    FActionList.Assign(TFhirTestReportTest(oSource).FActionList);
  end;
end;

procedure TFhirTestReportTest.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'description') Then
     list.add(self.link, 'description', FDescription.Link);
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportTest.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'description', 'string', false, TFhirString, FDescription.Link));
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirTestReportTestAction, FActionList.Link));
end;

function TFhirTestReportTest.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'description') then
  begin
    DescriptionElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportTestAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTest.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportTestAction)
  else inherited;
end;

function TFhirTestReportTest.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'description') then result := TFhirString.create()
  else if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTest.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'name') then result := 'string'
  else if (propName = 'description') then result := 'string'
  else if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTest.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'name') then NameElement := nil
  else if (propName = 'description') then DescriptionElement := nil
  else if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTest.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'description') then DescriptionElement := asString(new)
  else if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTest.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTest.fhirType : string;
begin
  result := 'TestReport.test';
end;

function TFhirTestReportTest.Link : TFhirTestReportTest;
begin
  result := TFhirTestReportTest(inherited Link);
end;

function TFhirTestReportTest.Clone : TFhirTestReportTest;
begin
  result := TFhirTestReportTest(inherited Clone);
end;

function TFhirTestReportTest.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTest;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTest)) then
    result := false
  else
  begin
    o := TFhirTestReportTest(other);
    result := compareDeep(nameElement, o.nameElement, true) and compareDeep(descriptionElement, o.descriptionElement, true) and 
      compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportTest.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FName) and isEmptyProp(FDescription) and isEmptyProp(FactionList);
end;

procedure TFhirTestReportTest.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('name');
  fields.add('description');
  fields.add('action');
end;

function TFhirTestReportTest.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActionList.sizeInBytes(magic));
end;

procedure TFhirTestReportTest.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirTestReportTest.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTestReportTest.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTestReportTest.SetDescription(value : TFhirString);
begin
  FDescription.free;
  FDescription := value;
end;

function TFhirTestReportTest.GetDescriptionST : String;
begin
  if FDescription = nil then
    result := ''
  else
    result := FDescription.value;
end;

procedure TFhirTestReportTest.SetDescriptionST(value : String);
begin
  if value <> '' then
  begin
    if FDescription = nil then
      FDescription := TFhirString.create;
    FDescription.value := value
  end
  else if FDescription <> nil then
    FDescription.value := '';
end;

function TFhirTestReportTest.GetActionList : TFhirTestReportTestActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportTestActionList.Create;
  result := FActionList;
end;

function TFhirTestReportTest.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirTestReportTestListEnumerator }

constructor TFhirTestReportTestListEnumerator.Create(list : TFhirTestReportTestList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTestListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTestListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTestListEnumerator.GetCurrent : TFhirTestReportTest;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTestListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportTestList }

function TFhirTestReportTestList.AddItem(value: TFhirTestReportTest): TFhirTestReportTest;
begin
  assert(value.ClassName = 'TFhirTestReportTest', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTest');
  add(value);
  result := value;
end;

function TFhirTestReportTestList.Append: TFhirTestReportTest;
begin
  result := TFhirTestReportTest.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTestList.GetEnumerator : TFhirTestReportTestListEnumerator;
begin
  result := TFhirTestReportTestListEnumerator.Create(self.link);
end;

function TFhirTestReportTestList.Clone: TFhirTestReportTestList;
begin
  result := TFhirTestReportTestList(inherited Clone);
end;

function TFhirTestReportTestList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTestList.GetItemN(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest(ObjectByIndex[index]);
end;

function TFhirTestReportTestList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTest;
end;
function TFhirTestReportTestList.IndexOf(value: TFhirTestReportTest): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTestList.Insert(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestList.InsertItem(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  Inherited Insert(index, value);
end;

function TFhirTestReportTestList.Item(index: Integer): TFhirTestReportTest;
begin
  result := TFhirTestReportTest(ObjectByIndex[index]);
end;

function TFhirTestReportTestList.Link: TFhirTestReportTestList;
begin
  result := TFhirTestReportTestList(inherited Link);
end;

procedure TFhirTestReportTestList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTestList.SetItemByIndex(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  FhirTestReportTests[index] := value;
end;

procedure TFhirTestReportTestList.SetItemN(index: Integer; value: TFhirTestReportTest);
begin
  assert(value is TFhirTestReportTest);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTestAction }

constructor TFhirTestReportTestAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportTestAction.Destroy;
begin
  FOperation.free;
  FAssert.free;
  inherited;
end;

procedure TFhirTestReportTestAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportTestAction(oSource).operation.Clone;
  assert := TFhirTestReportTestAction(oSource).assert.Clone;
end;

procedure TFhirTestReportTestAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
  if (child_name = 'assert') Then
     list.add(self.link, 'assert', FAssert.Link);
end;

procedure TFhirTestReportTestAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestReportSetupActionOperation, FOperation.Link));
  oList.add(TFHIRProperty.create(self, 'assert', '', false, TFhirTestReportSetupActionAssert, FAssert.Link));
end;

function TFhirTestReportTestAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation;
    result := propValue;
  end
  else if (propName = 'assert') then
  begin
    Assert := propValue as TFhirTestReportSetupActionAssert;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTestAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportTestAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create()
  else if (propName = 'assert') then result := TFhirTestReportSetupActionAssert.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTestAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else if (propName = 'assert') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTestAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else if (propName = 'assert') then AssertElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTestAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation
  else if (propName = 'assert') then AssertElement := new as TFhirTestReportSetupActionAssert
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTestAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTestAction.fhirType : string;
begin
  result := 'TestReport.test.action';
end;

function TFhirTestReportTestAction.Link : TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(inherited Link);
end;

function TFhirTestReportTestAction.Clone : TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(inherited Clone);
end;

function TFhirTestReportTestAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTestAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTestAction)) then
    result := false
  else
  begin
    o := TFhirTestReportTestAction(other);
    result := compareDeep(operationElement, o.operationElement, true) and compareDeep(assertElement, o.assertElement, true);
  end;
end;

function TFhirTestReportTestAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation) and isEmptyProp(FAssert);
end;

procedure TFhirTestReportTestAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('operation');
  fields.add('assert');
end;

function TFhirTestReportTestAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportTestAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

procedure TFhirTestReportTestAction.SetAssert(value : TFhirTestReportSetupActionAssert);
begin
  FAssert.free;
  FAssert := value;
end;

{ TFhirTestReportTestActionListEnumerator }

constructor TFhirTestReportTestActionListEnumerator.Create(list : TFhirTestReportTestActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTestActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTestActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTestActionListEnumerator.GetCurrent : TFhirTestReportTestAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTestActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportTestActionList }

function TFhirTestReportTestActionList.AddItem(value: TFhirTestReportTestAction): TFhirTestReportTestAction;
begin
  assert(value.ClassName = 'TFhirTestReportTestAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTestAction');
  add(value);
  result := value;
end;

function TFhirTestReportTestActionList.Append: TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTestActionList.GetEnumerator : TFhirTestReportTestActionListEnumerator;
begin
  result := TFhirTestReportTestActionListEnumerator.Create(self.link);
end;

function TFhirTestReportTestActionList.Clone: TFhirTestReportTestActionList;
begin
  result := TFhirTestReportTestActionList(inherited Clone);
end;

function TFhirTestReportTestActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTestActionList.GetItemN(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(ObjectByIndex[index]);
end;

function TFhirTestReportTestActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTestAction;
end;
function TFhirTestReportTestActionList.IndexOf(value: TFhirTestReportTestAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTestActionList.Insert(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTestActionList.InsertItem(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportTestActionList.Item(index: Integer): TFhirTestReportTestAction;
begin
  result := TFhirTestReportTestAction(ObjectByIndex[index]);
end;

function TFhirTestReportTestActionList.Link: TFhirTestReportTestActionList;
begin
  result := TFhirTestReportTestActionList(inherited Link);
end;

procedure TFhirTestReportTestActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTestActionList.SetItemByIndex(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  FhirTestReportTestActions[index] := value;
end;

procedure TFhirTestReportTestActionList.SetItemN(index: Integer; value: TFhirTestReportTestAction);
begin
  assert(value is TFhirTestReportTestAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTeardown }

constructor TFhirTestReportTeardown.Create;
begin
  inherited;
end;

destructor TFhirTestReportTeardown.Destroy;
begin
  FActionList.Free;
  inherited;
end;

procedure TFhirTestReportTeardown.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirTestReportTeardown(oSource).FActionList = nil) then
  begin
    FActionList.free;
    FActionList := nil;
  end
  else
  begin
    if FActionList = nil then
      FActionList := TFhirTestReportTeardownActionList.Create;
    FActionList.Assign(TFhirTestReportTeardown(oSource).FActionList);
  end;
end;

procedure TFhirTestReportTeardown.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'action') Then
    list.addAll(self, 'action', FActionList);
end;

procedure TFhirTestReportTeardown.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'action', 'BackboneElement', true, TFhirTestReportTeardownAction, FActionList.Link));
end;

function TFhirTestReportTeardown.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'action') then
  begin
    ActionList.add(propValue as TFhirTestReportTeardownAction);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTeardown.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'action') then ActionList.insertItem(index, propValue as TFhirTestReportTeardownAction)
  else inherited;
end;

function TFhirTestReportTeardown.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'action') then result := ActionList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTeardown.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'action') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTeardown.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'action') then deletePropertyValue('action', ActionList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTeardown.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'action') then replacePropertyValue('action', ActionList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTeardown.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'action') then ActionList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTeardown.fhirType : string;
begin
  result := 'TestReport.teardown';
end;

function TFhirTestReportTeardown.Link : TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(inherited Link);
end;

function TFhirTestReportTeardown.Clone : TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(inherited Clone);
end;

function TFhirTestReportTeardown.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTeardown;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTeardown)) then
    result := false
  else
  begin
    o := TFhirTestReportTeardown(other);
    result := compareDeep(actionList, o.actionList, true);
  end;
end;

function TFhirTestReportTeardown.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FactionList);
end;

procedure TFhirTestReportTeardown.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('action');
end;

function TFhirTestReportTeardown.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FActionList.sizeInBytes(magic));
end;

function TFhirTestReportTeardown.GetActionList : TFhirTestReportTeardownActionList;
begin
  if FActionList = nil then
    FActionList := TFhirTestReportTeardownActionList.Create;
  result := FActionList;
end;

function TFhirTestReportTeardown.GetHasActionList : boolean;
begin
  result := (FActionList <> nil) and (FActionList.count > 0);
end;

{ TFhirTestReportTeardownListEnumerator }

constructor TFhirTestReportTeardownListEnumerator.Create(list : TFhirTestReportTeardownList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTeardownListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTeardownListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTeardownListEnumerator.GetCurrent : TFhirTestReportTeardown;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTeardownListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportTeardownList }

function TFhirTestReportTeardownList.AddItem(value: TFhirTestReportTeardown): TFhirTestReportTeardown;
begin
  assert(value.ClassName = 'TFhirTestReportTeardown', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTeardown');
  add(value);
  result := value;
end;

function TFhirTestReportTeardownList.Append: TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTeardownList.GetEnumerator : TFhirTestReportTeardownListEnumerator;
begin
  result := TFhirTestReportTeardownListEnumerator.Create(self.link);
end;

function TFhirTestReportTeardownList.Clone: TFhirTestReportTeardownList;
begin
  result := TFhirTestReportTeardownList(inherited Clone);
end;

function TFhirTestReportTeardownList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTeardownList.GetItemN(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTeardown;
end;
function TFhirTestReportTeardownList.IndexOf(value: TFhirTestReportTeardown): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTeardownList.Insert(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownList.InsertItem(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  Inherited Insert(index, value);
end;

function TFhirTestReportTeardownList.Item(index: Integer): TFhirTestReportTeardown;
begin
  result := TFhirTestReportTeardown(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownList.Link: TFhirTestReportTeardownList;
begin
  result := TFhirTestReportTeardownList(inherited Link);
end;

procedure TFhirTestReportTeardownList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTeardownList.SetItemByIndex(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  FhirTestReportTeardowns[index] := value;
end;

procedure TFhirTestReportTeardownList.SetItemN(index: Integer; value: TFhirTestReportTeardown);
begin
  assert(value is TFhirTestReportTeardown);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReportTeardownAction }

constructor TFhirTestReportTeardownAction.Create;
begin
  inherited;
end;

destructor TFhirTestReportTeardownAction.Destroy;
begin
  FOperation.free;
  inherited;
end;

procedure TFhirTestReportTeardownAction.Assign(oSource : TFslObject);
begin
  inherited;
  operation := TFhirTestReportTeardownAction(oSource).operation.Clone;
end;

procedure TFhirTestReportTeardownAction.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'operation') Then
     list.add(self.link, 'operation', FOperation.Link);
end;

procedure TFhirTestReportTeardownAction.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'operation', '', false, TFhirTestReportSetupActionOperation, FOperation.Link));
end;

function TFhirTestReportTeardownAction.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'operation') then
  begin
    Operation := propValue as TFhirTestReportSetupActionOperation;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReportTeardownAction.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirTestReportTeardownAction.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'operation') then result := TFhirTestReportSetupActionOperation.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReportTeardownAction.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'operation') then result := ''
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReportTeardownAction.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReportTeardownAction.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'operation') then OperationElement := new as TFhirTestReportSetupActionOperation
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReportTeardownAction.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReportTeardownAction.fhirType : string;
begin
  result := 'TestReport.teardown.action';
end;

function TFhirTestReportTeardownAction.Link : TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(inherited Link);
end;

function TFhirTestReportTeardownAction.Clone : TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(inherited Clone);
end;

function TFhirTestReportTeardownAction.equals(other : TObject) : boolean; 
var
  o : TFhirTestReportTeardownAction;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReportTeardownAction)) then
    result := false
  else
  begin
    o := TFhirTestReportTeardownAction(other);
    result := compareDeep(operationElement, o.operationElement, true);
  end;
end;

function TFhirTestReportTeardownAction.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOperation);
end;

procedure TFhirTestReportTeardownAction.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('operation');
end;

function TFhirTestReportTeardownAction.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirTestReportTeardownAction.SetOperation(value : TFhirTestReportSetupActionOperation);
begin
  FOperation.free;
  FOperation := value;
end;

{ TFhirTestReportTeardownActionListEnumerator }

constructor TFhirTestReportTeardownActionListEnumerator.Create(list : TFhirTestReportTeardownActionList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportTeardownActionListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportTeardownActionListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportTeardownActionListEnumerator.GetCurrent : TFhirTestReportTeardownAction;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportTeardownActionListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportTeardownActionList }

function TFhirTestReportTeardownActionList.AddItem(value: TFhirTestReportTeardownAction): TFhirTestReportTeardownAction;
begin
  assert(value.ClassName = 'TFhirTestReportTeardownAction', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReportTeardownAction');
  add(value);
  result := value;
end;

function TFhirTestReportTeardownActionList.Append: TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownActionList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportTeardownActionList.GetEnumerator : TFhirTestReportTeardownActionListEnumerator;
begin
  result := TFhirTestReportTeardownActionListEnumerator.Create(self.link);
end;

function TFhirTestReportTeardownActionList.Clone: TFhirTestReportTeardownActionList;
begin
  result := TFhirTestReportTeardownActionList(inherited Clone);
end;

function TFhirTestReportTeardownActionList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportTeardownActionList.GetItemN(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownActionList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReportTeardownAction;
end;
function TFhirTestReportTeardownActionList.IndexOf(value: TFhirTestReportTeardownAction): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportTeardownActionList.Insert(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportTeardownActionList.InsertItem(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  Inherited Insert(index, value);
end;

function TFhirTestReportTeardownActionList.Item(index: Integer): TFhirTestReportTeardownAction;
begin
  result := TFhirTestReportTeardownAction(ObjectByIndex[index]);
end;

function TFhirTestReportTeardownActionList.Link: TFhirTestReportTeardownActionList;
begin
  result := TFhirTestReportTeardownActionList(inherited Link);
end;

procedure TFhirTestReportTeardownActionList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportTeardownActionList.SetItemByIndex(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  FhirTestReportTeardownActions[index] := value;
end;

procedure TFhirTestReportTeardownActionList.SetItemN(index: Integer; value: TFhirTestReportTeardownAction);
begin
  assert(value is TFhirTestReportTeardownAction);
  ObjectByIndex[index] := value;
end;

{ TFhirTestReport }

constructor TFhirTestReport.Create;
begin
  inherited;
end;

destructor TFhirTestReport.Destroy;
begin
  FIdentifier.free;
  FName.free;
  FStatus.free;
  FTestScript.free;
  FResult.free;
  FScore.free;
  FTester.free;
  FIssued.free;
  FParticipantList.Free;
  FSetup.free;
  FTestList.Free;
  FTeardown.free;
  inherited;
end;

procedure TFhirTestReport.Assign(oSource : TFslObject);
begin
  inherited;
  identifier := TFhirTestReport(oSource).identifier.Clone;
  nameElement := TFhirTestReport(oSource).nameElement.Clone;
  statusElement := TFhirTestReport(oSource).statusElement.Clone;
  testScript := TFhirTestReport(oSource).testScript.Clone;
  resultElement := TFhirTestReport(oSource).resultElement.Clone;
  scoreElement := TFhirTestReport(oSource).scoreElement.Clone;
  testerElement := TFhirTestReport(oSource).testerElement.Clone;
  issuedElement := TFhirTestReport(oSource).issuedElement.Clone;
  if (TFhirTestReport(oSource).FParticipantList = nil) then
  begin
    FParticipantList.free;
    FParticipantList := nil;
  end
  else
  begin
    if FParticipantList = nil then
      FParticipantList := TFhirTestReportParticipantList.Create;
    FParticipantList.Assign(TFhirTestReport(oSource).FParticipantList);
  end;
  setup := TFhirTestReport(oSource).setup.Clone;
  if (TFhirTestReport(oSource).FTestList = nil) then
  begin
    FTestList.free;
    FTestList := nil;
  end
  else
  begin
    if FTestList = nil then
      FTestList := TFhirTestReportTestList.Create;
    FTestList.Assign(TFhirTestReport(oSource).FTestList);
  end;
  teardown := TFhirTestReport(oSource).teardown.Clone;
end;

function TFhirTestReport.GetResourceType : TFhirResourceType;
begin
  result := frtTestReport;
end;

procedure TFhirTestReport.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'identifier') Then
     list.add(self.link, 'identifier', FIdentifier.Link);
  if (child_name = 'name') Then
     list.add(self.link, 'name', FName.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'testScript') Then
     list.add(self.link, 'testScript', FTestScript.Link);
  if (child_name = 'result') Then
     list.add(self.link, 'result', FResult.Link);
  if (child_name = 'score') Then
     list.add(self.link, 'score', FScore.Link);
  if (child_name = 'tester') Then
     list.add(self.link, 'tester', FTester.Link);
  if (child_name = 'issued') Then
     list.add(self.link, 'issued', FIssued.Link);
  if (child_name = 'participant') Then
    list.addAll(self, 'participant', FParticipantList);
  if (child_name = 'setup') Then
     list.add(self.link, 'setup', FSetup.Link);
  if (child_name = 'test') Then
    list.addAll(self, 'test', FTestList);
  if (child_name = 'teardown') Then
     list.add(self.link, 'teardown', FTeardown.Link);
end;

procedure TFhirTestReport.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'identifier', 'Identifier', false, TFhirIdentifier, FIdentifier.Link));
  oList.add(TFHIRProperty.create(self, 'name', 'string', false, TFhirString, FName.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'testScript', 'Reference', false, TFhirReference, FTestScript.Link));
  oList.add(TFHIRProperty.create(self, 'result', 'code', false, TFhirEnum, FResult.Link));
  oList.add(TFHIRProperty.create(self, 'score', 'decimal', false, TFhirDecimal, FScore.Link));
  oList.add(TFHIRProperty.create(self, 'tester', 'string', false, TFhirString, FTester.Link));
  oList.add(TFHIRProperty.create(self, 'issued', 'dateTime', false, TFhirDateTime, FIssued.Link));
  oList.add(TFHIRProperty.create(self, 'participant', 'BackboneElement', true, TFhirTestReportParticipant, FParticipantList.Link));
  oList.add(TFHIRProperty.create(self, 'setup', 'BackboneElement', false, TFhirTestReportSetup, FSetup.Link));
  oList.add(TFHIRProperty.create(self, 'test', 'BackboneElement', true, TFhirTestReportTest, FTestList.Link));
  oList.add(TFHIRProperty.create(self, 'teardown', 'BackboneElement', false, TFhirTestReportTeardown, FTeardown.Link));
end;

function TFhirTestReport.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'identifier') then
  begin
    Identifier := propValue as TFhirIdentifier;
    result := propValue;
  end
  else if (propName = 'name') then
  begin
    NameElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirTestReportStatusEnum, CODES_TFhirTestReportStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'testScript') then
  begin
    TestScript := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'result') then
  begin
    ResultElement := asEnum(SYSTEMS_TFhirTestReportResultEnum, CODES_TFhirTestReportResultEnum, propValue);
    result := propValue;
  end
  else if (propName = 'score') then
  begin
    ScoreElement := asDecimal(propValue);
    result := propValue;
  end
  else if (propName = 'tester') then
  begin
    TesterElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'issued') then
  begin
    IssuedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'participant') then
  begin
    ParticipantList.add(propValue as TFhirTestReportParticipant);
    result := propValue;
  end
  else if (propName = 'setup') then
  begin
    Setup := propValue as TFhirTestReportSetup;
    result := propValue;
  end
  else if (propName = 'test') then
  begin
    TestList.add(propValue as TFhirTestReportTest);
    result := propValue;
  end
  else if (propName = 'teardown') then
  begin
    Teardown := propValue as TFhirTestReportTeardown;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirTestReport.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'participant') then ParticipantList.insertItem(index, propValue as TFhirTestReportParticipant)
  else if (propName = 'test') then TestList.insertItem(index, propValue as TFhirTestReportTest)
  else inherited;
end;

function TFhirTestReport.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'identifier') then result := TFhirIdentifier.create()
  else if (propName = 'name') then result := TFhirString.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportStatusEnum[TestReportStatusNull], CODES_TFhirTestReportStatusEnum[TestReportStatusNull]) 
  else if (propName = 'testScript') then result := TFhirReference.create()
  else if (propName = 'result') then result := TFhirEnum.create(SYSTEMS_TFhirTestReportResultEnum[TestReportResultNull], CODES_TFhirTestReportResultEnum[TestReportResultNull]) 
  else if (propName = 'score') then result := TFhirDecimal.create()
  else if (propName = 'tester') then result := TFhirString.create()
  else if (propName = 'issued') then result := TFhirDateTime.create()
  else if (propName = 'participant') then result := ParticipantList.new()
  else if (propName = 'setup') then result := TFhirTestReportSetup.create()
  else if (propName = 'test') then result := TestList.new()
  else if (propName = 'teardown') then result := TFhirTestReportTeardown.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirTestReport.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'identifier') then result := 'Identifier'
  else if (propName = 'name') then result := 'string'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'testScript') then result := 'Reference'
  else if (propName = 'result') then result := 'code'
  else if (propName = 'score') then result := 'decimal'
  else if (propName = 'tester') then result := 'string'
  else if (propName = 'issued') then result := 'dateTime'
  else if (propName = 'participant') then result := 'BackboneElement'
  else if (propName = 'setup') then result := 'BackboneElement'
  else if (propName = 'test') then result := 'BackboneElement'
  else if (propName = 'teardown') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirTestReport.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := nil
  else if (propName = 'name') then NameElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'testScript') then TestScriptElement := nil
  else if (propName = 'result') then ResultElement := nil
  else if (propName = 'score') then ScoreElement := nil
  else if (propName = 'tester') then TesterElement := nil
  else if (propName = 'issued') then IssuedElement := nil
  else if (propName = 'participant') then deletePropertyValue('participant', ParticipantList, value)
  else if (propName = 'setup') then SetupElement := nil
  else if (propName = 'test') then deletePropertyValue('test', TestList, value)
  else if (propName = 'teardown') then TeardownElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirTestReport.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'identifier') then IdentifierElement := new as TFhirIdentifier
  else if (propName = 'name') then NameElement := asString(new)
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirTestReportStatusEnum, CODES_TFhirTestReportStatusEnum, new)
  else if (propName = 'testScript') then TestScriptElement := new as TFhirReference
  else if (propName = 'result') then ResultElement := asEnum(SYSTEMS_TFhirTestReportResultEnum, CODES_TFhirTestReportResultEnum, new)
  else if (propName = 'score') then ScoreElement := asDecimal(new)
  else if (propName = 'tester') then TesterElement := asString(new)
  else if (propName = 'issued') then IssuedElement := asDateTime(new)
  else if (propName = 'participant') then replacePropertyValue('participant', ParticipantList, existing, new)
  else if (propName = 'setup') then SetupElement := new as TFhirTestReportSetup
  else if (propName = 'test') then replacePropertyValue('test', TestList, existing, new)
  else if (propName = 'teardown') then TeardownElement := new as TFhirTestReportTeardown
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirTestReport.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'participant') then ParticipantList.move(source, destination)
  else if (propName = 'test') then TestList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirTestReport.fhirType : string;
begin
  result := 'TestReport';
end;

function TFhirTestReport.Link : TFhirTestReport;
begin
  result := TFhirTestReport(inherited Link);
end;

function TFhirTestReport.Clone : TFhirTestReport;
begin
  result := TFhirTestReport(inherited Clone);
end;

function TFhirTestReport.equals(other : TObject) : boolean; 
var
  o : TFhirTestReport;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirTestReport)) then
    result := false
  else
  begin
    o := TFhirTestReport(other);
    result := compareDeep(identifierElement, o.identifierElement, true) and compareDeep(nameElement, o.nameElement, true) and 
      compareDeep(statusElement, o.statusElement, true) and compareDeep(testScriptElement, o.testScriptElement, true) and 
      compareDeep(resultElement, o.resultElement, true) and compareDeep(scoreElement, o.scoreElement, true) and 
      compareDeep(testerElement, o.testerElement, true) and compareDeep(issuedElement, o.issuedElement, true) and 
      compareDeep(participantList, o.participantList, true) and compareDeep(setupElement, o.setupElement, true) and 
      compareDeep(testList, o.testList, true) and compareDeep(teardownElement, o.teardownElement, true);
  end;
end;

function TFhirTestReport.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FIdentifier) and isEmptyProp(FName) and isEmptyProp(FStatus) and isEmptyProp(FTestScript) and isEmptyProp(FResult) and isEmptyProp(FScore) and isEmptyProp(FTester) and isEmptyProp(FIssued) and isEmptyProp(FparticipantList) and isEmptyProp(FSetup) and isEmptyProp(FtestList) and isEmptyProp(FTeardown);
end;

procedure TFhirTestReport.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('identifier');
  fields.add('name');
  fields.add('status');
  fields.add('testScript');
  fields.add('result');
  fields.add('score');
  fields.add('tester');
  fields.add('issued');
  fields.add('participant');
  fields.add('setup');
  fields.add('test');
  fields.add('teardown');
end;

function TFhirTestReport.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FParticipantList.sizeInBytes(magic));
  inc(result, FTestList.sizeInBytes(magic));
end;

procedure TFhirTestReport.SetIdentifier(value : TFhirIdentifier);
begin
  FIdentifier.free;
  FIdentifier := value;
end;

procedure TFhirTestReport.SetName(value : TFhirString);
begin
  FName.free;
  FName := value;
end;

function TFhirTestReport.GetNameST : String;
begin
  if FName = nil then
    result := ''
  else
    result := FName.value;
end;

procedure TFhirTestReport.SetNameST(value : String);
begin
  if value <> '' then
  begin
    if FName = nil then
      FName := TFhirString.create;
    FName.value := value
  end
  else if FName <> nil then
    FName.value := '';
end;

procedure TFhirTestReport.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirTestReport.GetStatusST : TFhirTestReportStatusEnum;
begin
  if FStatus = nil then
    result := TFhirTestReportStatusEnum(0)
  else
    result := TFhirTestReportStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportStatusEnum, FStatus.value));
end;

procedure TFhirTestReport.SetStatusST(value : TFhirTestReportStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirTestReportStatusEnum[value], CODES_TFhirTestReportStatusEnum[value]);
end;

procedure TFhirTestReport.SetTestScript(value : TFhirReference);
begin
  FTestScript.free;
  FTestScript := value;
end;

procedure TFhirTestReport.SetResult(value : TFhirEnum);
begin
  FResult.free;
  FResult := value;
end;

function TFhirTestReport.GetResultST : TFhirTestReportResultEnum;
begin
  if FResult = nil then
    result := TFhirTestReportResultEnum(0)
  else
    result := TFhirTestReportResultEnum(StringArrayIndexOfSensitive(CODES_TFhirTestReportResultEnum, FResult.value));
end;

procedure TFhirTestReport.SetResultST(value : TFhirTestReportResultEnum);
begin
  if ord(value) = 0 then
    ResultElement := nil
  else
    ResultElement := TFhirEnum.create(SYSTEMS_TFhirTestReportResultEnum[value], CODES_TFhirTestReportResultEnum[value]);
end;

procedure TFhirTestReport.SetScore(value : TFhirDecimal);
begin
  FScore.free;
  FScore := value;
end;

function TFhirTestReport.GetScoreST : String;
begin
  if FScore = nil then
    result := ''
  else
    result := FScore.value;
end;

procedure TFhirTestReport.SetScoreST(value : String);
begin
  if value <> '' then
  begin
    if FScore = nil then
      FScore := TFhirDecimal.create;
    FScore.value := value
  end
  else if FScore <> nil then
    FScore.value := '';
end;

procedure TFhirTestReport.SetTester(value : TFhirString);
begin
  FTester.free;
  FTester := value;
end;

function TFhirTestReport.GetTesterST : String;
begin
  if FTester = nil then
    result := ''
  else
    result := FTester.value;
end;

procedure TFhirTestReport.SetTesterST(value : String);
begin
  if value <> '' then
  begin
    if FTester = nil then
      FTester := TFhirString.create;
    FTester.value := value
  end
  else if FTester <> nil then
    FTester.value := '';
end;

procedure TFhirTestReport.SetIssued(value : TFhirDateTime);
begin
  FIssued.free;
  FIssued := value;
end;

function TFhirTestReport.GetIssuedST : TFslDateTime;
begin
  if FIssued = nil then
    result := TFslDateTime.makeNull
  else
    result := FIssued.value;
end;

procedure TFhirTestReport.SetIssuedST(value : TFslDateTime);
begin
  if FIssued = nil then
    FIssued := TFhirDateTime.create;
  FIssued.value := value
end;

function TFhirTestReport.GetParticipantList : TFhirTestReportParticipantList;
begin
  if FParticipantList = nil then
    FParticipantList := TFhirTestReportParticipantList.Create;
  result := FParticipantList;
end;

function TFhirTestReport.GetHasParticipantList : boolean;
begin
  result := (FParticipantList <> nil) and (FParticipantList.count > 0);
end;

procedure TFhirTestReport.SetSetup(value : TFhirTestReportSetup);
begin
  FSetup.free;
  FSetup := value;
end;

function TFhirTestReport.GetTestList : TFhirTestReportTestList;
begin
  if FTestList = nil then
    FTestList := TFhirTestReportTestList.Create;
  result := FTestList;
end;

function TFhirTestReport.GetHasTestList : boolean;
begin
  result := (FTestList <> nil) and (FTestList.count > 0);
end;

procedure TFhirTestReport.SetTeardown(value : TFhirTestReportTeardown);
begin
  FTeardown.free;
  FTeardown := value;
end;

{ TFhirTestReportListEnumerator }

constructor TFhirTestReportListEnumerator.Create(list : TFhirTestReportList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirTestReportListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirTestReportListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirTestReportListEnumerator.GetCurrent : TFhirTestReport;
begin
  Result := FList[FIndex];
end;

function TFhirTestReportListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirTestReportList }

function TFhirTestReportList.AddItem(value: TFhirTestReport): TFhirTestReport;
begin
  assert(value.ClassName = 'TFhirTestReport', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirTestReport');
  add(value);
  result := value;
end;

function TFhirTestReportList.Append: TFhirTestReport;
begin
  result := TFhirTestReport.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportList.ClearItems;
begin
  Clear;
end;

function TFhirTestReportList.GetEnumerator : TFhirTestReportListEnumerator;
begin
  result := TFhirTestReportListEnumerator.Create(self.link);
end;

function TFhirTestReportList.Clone: TFhirTestReportList;
begin
  result := TFhirTestReportList(inherited Clone);
end;

function TFhirTestReportList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirTestReportList.GetItemN(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport(ObjectByIndex[index]);
end;

function TFhirTestReportList.ItemClass: TFslObjectClass;
begin
  result := TFhirTestReport;
end;
function TFhirTestReportList.IndexOf(value: TFhirTestReport): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirTestReportList.Insert(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirTestReportList.InsertItem(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  Inherited Insert(index, value);
end;

function TFhirTestReportList.Item(index: Integer): TFhirTestReport;
begin
  result := TFhirTestReport(ObjectByIndex[index]);
end;

function TFhirTestReportList.Link: TFhirTestReportList;
begin
  result := TFhirTestReportList(inherited Link);
end;

procedure TFhirTestReportList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirTestReportList.SetItemByIndex(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  FhirTestReports[index] := value;
end;

procedure TFhirTestReportList.SetItemN(index: Integer; value: TFhirTestReport);
begin
  assert(value is TFhirTestReport);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_TESTREPORT}
{$IFDEF FHIR_VERIFICATIONRESULT}
{ TFhirVerificationResultPrimarySource }

constructor TFhirVerificationResultPrimarySource.Create;
begin
  inherited;
end;

destructor TFhirVerificationResultPrimarySource.Destroy;
begin
  FWho.free;
  FType_List.Free;
  FCommunicationMethodList.Free;
  FValidationStatus.free;
  FValidationDate.free;
  FCanPushUpdates.free;
  FPushTypeAvailableList.Free;
  inherited;
end;

procedure TFhirVerificationResultPrimarySource.Assign(oSource : TFslObject);
begin
  inherited;
  who := TFhirVerificationResultPrimarySource(oSource).who.Clone;
  if (TFhirVerificationResultPrimarySource(oSource).FType_List = nil) then
  begin
    FType_List.free;
    FType_List := nil;
  end
  else
  begin
    if FType_List = nil then
      FType_List := TFhirCodeableConceptList.Create;
    FType_List.Assign(TFhirVerificationResultPrimarySource(oSource).FType_List);
  end;
  if (TFhirVerificationResultPrimarySource(oSource).FCommunicationMethodList = nil) then
  begin
    FCommunicationMethodList.free;
    FCommunicationMethodList := nil;
  end
  else
  begin
    if FCommunicationMethodList = nil then
      FCommunicationMethodList := TFhirCodeableConceptList.Create;
    FCommunicationMethodList.Assign(TFhirVerificationResultPrimarySource(oSource).FCommunicationMethodList);
  end;
  validationStatus := TFhirVerificationResultPrimarySource(oSource).validationStatus.Clone;
  validationDateElement := TFhirVerificationResultPrimarySource(oSource).validationDateElement.Clone;
  canPushUpdates := TFhirVerificationResultPrimarySource(oSource).canPushUpdates.Clone;
  if (TFhirVerificationResultPrimarySource(oSource).FPushTypeAvailableList = nil) then
  begin
    FPushTypeAvailableList.free;
    FPushTypeAvailableList := nil;
  end
  else
  begin
    if FPushTypeAvailableList = nil then
      FPushTypeAvailableList := TFhirCodeableConceptList.Create;
    FPushTypeAvailableList.Assign(TFhirVerificationResultPrimarySource(oSource).FPushTypeAvailableList);
  end;
end;

procedure TFhirVerificationResultPrimarySource.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'type') Then
    list.addAll(self, 'type', FType_List);
  if (child_name = 'communicationMethod') Then
    list.addAll(self, 'communicationMethod', FCommunicationMethodList);
  if (child_name = 'validationStatus') Then
     list.add(self.link, 'validationStatus', FValidationStatus.Link);
  if (child_name = 'validationDate') Then
     list.add(self.link, 'validationDate', FValidationDate.Link);
  if (child_name = 'canPushUpdates') Then
     list.add(self.link, 'canPushUpdates', FCanPushUpdates.Link);
  if (child_name = 'pushTypeAvailable') Then
    list.addAll(self, 'pushTypeAvailable', FPushTypeAvailableList);
end;

procedure TFhirVerificationResultPrimarySource.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'who', 'Reference', false, TFhirReference, FWho.Link));
  oList.add(TFHIRProperty.create(self, 'type', 'CodeableConcept', true, TFhirCodeableConcept, FType_List.Link));
  oList.add(TFHIRProperty.create(self, 'communicationMethod', 'CodeableConcept', true, TFhirCodeableConcept, FCommunicationMethodList.Link));
  oList.add(TFHIRProperty.create(self, 'validationStatus', 'CodeableConcept', false, TFhirCodeableConcept, FValidationStatus.Link));
  oList.add(TFHIRProperty.create(self, 'validationDate', 'dateTime', false, TFhirDateTime, FValidationDate.Link));
  oList.add(TFHIRProperty.create(self, 'canPushUpdates', 'CodeableConcept', false, TFhirCodeableConcept, FCanPushUpdates.Link));
  oList.add(TFHIRProperty.create(self, 'pushTypeAvailable', 'CodeableConcept', true, TFhirCodeableConcept, FPushTypeAvailableList.Link));
end;

function TFhirVerificationResultPrimarySource.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'who') then
  begin
    Who := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'type') then
  begin
    Type_List.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'communicationMethod') then
  begin
    CommunicationMethodList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'validationStatus') then
  begin
    ValidationStatus := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'validationDate') then
  begin
    ValidationDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'canPushUpdates') then
  begin
    CanPushUpdates := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'pushTypeAvailable') then
  begin
    PushTypeAvailableList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResultPrimarySource.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'type') then Type_List.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'communicationMethod') then CommunicationMethodList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'pushTypeAvailable') then PushTypeAvailableList.insertItem(index, propValue as TFhirCodeableConcept)
  else inherited;
end;

function TFhirVerificationResultPrimarySource.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'who') then result := TFhirReference.create()
  else if (propName = 'type') then result := Type_List.new()
  else if (propName = 'communicationMethod') then result := CommunicationMethodList.new()
  else if (propName = 'validationStatus') then result := TFhirCodeableConcept.create()
  else if (propName = 'validationDate') then result := TFhirDateTime.create()
  else if (propName = 'canPushUpdates') then result := TFhirCodeableConcept.create()
  else if (propName = 'pushTypeAvailable') then result := PushTypeAvailableList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResultPrimarySource.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'who') then result := 'Reference'
  else if (propName = 'type') then result := 'CodeableConcept'
  else if (propName = 'communicationMethod') then result := 'CodeableConcept'
  else if (propName = 'validationStatus') then result := 'CodeableConcept'
  else if (propName = 'validationDate') then result := 'dateTime'
  else if (propName = 'canPushUpdates') then result := 'CodeableConcept'
  else if (propName = 'pushTypeAvailable') then result := 'CodeableConcept'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResultPrimarySource.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := nil
  else if (propName = 'type') then deletePropertyValue('type', Type_List, value)
  else if (propName = 'communicationMethod') then deletePropertyValue('communicationMethod', CommunicationMethodList, value)
  else if (propName = 'validationStatus') then ValidationStatusElement := nil
  else if (propName = 'validationDate') then ValidationDateElement := nil
  else if (propName = 'canPushUpdates') then CanPushUpdatesElement := nil
  else if (propName = 'pushTypeAvailable') then deletePropertyValue('pushTypeAvailable', PushTypeAvailableList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResultPrimarySource.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := new as TFhirReference
  else if (propName = 'type') then replacePropertyValue('type', Type_List, existing, new)
  else if (propName = 'communicationMethod') then replacePropertyValue('communicationMethod', CommunicationMethodList, existing, new)
  else if (propName = 'validationStatus') then ValidationStatusElement := new as TFhirCodeableConcept
  else if (propName = 'validationDate') then ValidationDateElement := asDateTime(new)
  else if (propName = 'canPushUpdates') then CanPushUpdatesElement := new as TFhirCodeableConcept
  else if (propName = 'pushTypeAvailable') then replacePropertyValue('pushTypeAvailable', PushTypeAvailableList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResultPrimarySource.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'type') then Type_List.move(source, destination)
  else if (propName = 'communicationMethod') then CommunicationMethodList.move(source, destination)
  else if (propName = 'pushTypeAvailable') then PushTypeAvailableList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResultPrimarySource.fhirType : string;
begin
  result := 'VerificationResult.primarySource';
end;

function TFhirVerificationResultPrimarySource.Link : TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(inherited Link);
end;

function TFhirVerificationResultPrimarySource.Clone : TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(inherited Clone);
end;

function TFhirVerificationResultPrimarySource.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResultPrimarySource;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResultPrimarySource)) then
    result := false
  else
  begin
    o := TFhirVerificationResultPrimarySource(other);
    result := compareDeep(whoElement, o.whoElement, true) and compareDeep(type_List, o.type_List, true) and 
      compareDeep(communicationMethodList, o.communicationMethodList, true) and compareDeep(validationStatusElement, o.validationStatusElement, true) and 
      compareDeep(validationDateElement, o.validationDateElement, true) and compareDeep(canPushUpdatesElement, o.canPushUpdatesElement, true) and 
      compareDeep(pushTypeAvailableList, o.pushTypeAvailableList, true);
  end;
end;

function TFhirVerificationResultPrimarySource.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWho) and isEmptyProp(Ftype_List) and isEmptyProp(FcommunicationMethodList) and isEmptyProp(FValidationStatus) and isEmptyProp(FValidationDate) and isEmptyProp(FCanPushUpdates) and isEmptyProp(FpushTypeAvailableList);
end;

procedure TFhirVerificationResultPrimarySource.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('who');
  fields.add('type');
  fields.add('communicationMethod');
  fields.add('validationStatus');
  fields.add('validationDate');
  fields.add('canPushUpdates');
  fields.add('pushTypeAvailable');
end;

function TFhirVerificationResultPrimarySource.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FType_List.sizeInBytes(magic));
  inc(result, FCommunicationMethodList.sizeInBytes(magic));
  inc(result, FPushTypeAvailableList.sizeInBytes(magic));
end;

procedure TFhirVerificationResultPrimarySource.SetWho(value : TFhirReference);
begin
  FWho.free;
  FWho := value;
end;

function TFhirVerificationResultPrimarySource.GetType_List : TFhirCodeableConceptList;
begin
  if FType_List = nil then
    FType_List := TFhirCodeableConceptList.Create;
  result := FType_List;
end;

function TFhirVerificationResultPrimarySource.GetHasType_List : boolean;
begin
  result := (FType_List <> nil) and (FType_List.count > 0);
end;

function TFhirVerificationResultPrimarySource.GetCommunicationMethodList : TFhirCodeableConceptList;
begin
  if FCommunicationMethodList = nil then
    FCommunicationMethodList := TFhirCodeableConceptList.Create;
  result := FCommunicationMethodList;
end;

function TFhirVerificationResultPrimarySource.GetHasCommunicationMethodList : boolean;
begin
  result := (FCommunicationMethodList <> nil) and (FCommunicationMethodList.count > 0);
end;

procedure TFhirVerificationResultPrimarySource.SetValidationStatus(value : TFhirCodeableConcept);
begin
  FValidationStatus.free;
  FValidationStatus := value;
end;

procedure TFhirVerificationResultPrimarySource.SetValidationDate(value : TFhirDateTime);
begin
  FValidationDate.free;
  FValidationDate := value;
end;

function TFhirVerificationResultPrimarySource.GetValidationDateST : TFslDateTime;
begin
  if FValidationDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FValidationDate.value;
end;

procedure TFhirVerificationResultPrimarySource.SetValidationDateST(value : TFslDateTime);
begin
  if FValidationDate = nil then
    FValidationDate := TFhirDateTime.create;
  FValidationDate.value := value
end;

procedure TFhirVerificationResultPrimarySource.SetCanPushUpdates(value : TFhirCodeableConcept);
begin
  FCanPushUpdates.free;
  FCanPushUpdates := value;
end;

function TFhirVerificationResultPrimarySource.GetPushTypeAvailableList : TFhirCodeableConceptList;
begin
  if FPushTypeAvailableList = nil then
    FPushTypeAvailableList := TFhirCodeableConceptList.Create;
  result := FPushTypeAvailableList;
end;

function TFhirVerificationResultPrimarySource.GetHasPushTypeAvailableList : boolean;
begin
  result := (FPushTypeAvailableList <> nil) and (FPushTypeAvailableList.count > 0);
end;

{ TFhirVerificationResultPrimarySourceListEnumerator }

constructor TFhirVerificationResultPrimarySourceListEnumerator.Create(list : TFhirVerificationResultPrimarySourceList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultPrimarySourceListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultPrimarySourceListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultPrimarySourceListEnumerator.GetCurrent : TFhirVerificationResultPrimarySource;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultPrimarySourceListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVerificationResultPrimarySourceList }

function TFhirVerificationResultPrimarySourceList.AddItem(value: TFhirVerificationResultPrimarySource): TFhirVerificationResultPrimarySource;
begin
  assert(value.ClassName = 'TFhirVerificationResultPrimarySource', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResultPrimarySource');
  add(value);
  result := value;
end;

function TFhirVerificationResultPrimarySourceList.Append: TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultPrimarySourceList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultPrimarySourceList.GetEnumerator : TFhirVerificationResultPrimarySourceListEnumerator;
begin
  result := TFhirVerificationResultPrimarySourceListEnumerator.Create(self.link);
end;

function TFhirVerificationResultPrimarySourceList.Clone: TFhirVerificationResultPrimarySourceList;
begin
  result := TFhirVerificationResultPrimarySourceList(inherited Clone);
end;

function TFhirVerificationResultPrimarySourceList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultPrimarySourceList.GetItemN(index: Integer): TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(ObjectByIndex[index]);
end;

function TFhirVerificationResultPrimarySourceList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResultPrimarySource;
end;
function TFhirVerificationResultPrimarySourceList.IndexOf(value: TFhirVerificationResultPrimarySource): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultPrimarySourceList.Insert(index: Integer): TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultPrimarySourceList.InsertItem(index: Integer; value: TFhirVerificationResultPrimarySource);
begin
  assert(value is TFhirVerificationResultPrimarySource);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultPrimarySourceList.Item(index: Integer): TFhirVerificationResultPrimarySource;
begin
  result := TFhirVerificationResultPrimarySource(ObjectByIndex[index]);
end;

function TFhirVerificationResultPrimarySourceList.Link: TFhirVerificationResultPrimarySourceList;
begin
  result := TFhirVerificationResultPrimarySourceList(inherited Link);
end;

procedure TFhirVerificationResultPrimarySourceList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultPrimarySourceList.SetItemByIndex(index: Integer; value: TFhirVerificationResultPrimarySource);
begin
  assert(value is TFhirVerificationResultPrimarySource);
  FhirVerificationResultPrimarySources[index] := value;
end;

procedure TFhirVerificationResultPrimarySourceList.SetItemN(index: Integer; value: TFhirVerificationResultPrimarySource);
begin
  assert(value is TFhirVerificationResultPrimarySource);
  ObjectByIndex[index] := value;
end;

{ TFhirVerificationResultAttestation }

constructor TFhirVerificationResultAttestation.Create;
begin
  inherited;
end;

destructor TFhirVerificationResultAttestation.Destroy;
begin
  FWho.free;
  FOnBehalfOf.free;
  FCommunicationMethod.free;
  FDate.free;
  FSourceIdentityCertificate.free;
  FProxyIdentityCertificate.free;
  FProxySignature.free;
  FSourceSignature.free;
  inherited;
end;

procedure TFhirVerificationResultAttestation.Assign(oSource : TFslObject);
begin
  inherited;
  who := TFhirVerificationResultAttestation(oSource).who.Clone;
  onBehalfOf := TFhirVerificationResultAttestation(oSource).onBehalfOf.Clone;
  communicationMethod := TFhirVerificationResultAttestation(oSource).communicationMethod.Clone;
  dateElement := TFhirVerificationResultAttestation(oSource).dateElement.Clone;
  sourceIdentityCertificateElement := TFhirVerificationResultAttestation(oSource).sourceIdentityCertificateElement.Clone;
  proxyIdentityCertificateElement := TFhirVerificationResultAttestation(oSource).proxyIdentityCertificateElement.Clone;
  proxySignature := TFhirVerificationResultAttestation(oSource).proxySignature.Clone;
  sourceSignature := TFhirVerificationResultAttestation(oSource).sourceSignature.Clone;
end;

procedure TFhirVerificationResultAttestation.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'who') Then
     list.add(self.link, 'who', FWho.Link);
  if (child_name = 'onBehalfOf') Then
     list.add(self.link, 'onBehalfOf', FOnBehalfOf.Link);
  if (child_name = 'communicationMethod') Then
     list.add(self.link, 'communicationMethod', FCommunicationMethod.Link);
  if (child_name = 'date') Then
     list.add(self.link, 'date', FDate.Link);
  if (child_name = 'sourceIdentityCertificate') Then
     list.add(self.link, 'sourceIdentityCertificate', FSourceIdentityCertificate.Link);
  if (child_name = 'proxyIdentityCertificate') Then
     list.add(self.link, 'proxyIdentityCertificate', FProxyIdentityCertificate.Link);
  if (child_name = 'proxySignature') Then
     list.add(self.link, 'proxySignature', FProxySignature.Link);
  if (child_name = 'sourceSignature') Then
     list.add(self.link, 'sourceSignature', FSourceSignature.Link);
end;

procedure TFhirVerificationResultAttestation.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'who', 'Reference', false, TFhirReference, FWho.Link));
  oList.add(TFHIRProperty.create(self, 'onBehalfOf', 'Reference', false, TFhirReference, FOnBehalfOf.Link));
  oList.add(TFHIRProperty.create(self, 'communicationMethod', 'CodeableConcept', false, TFhirCodeableConcept, FCommunicationMethod.Link));
  oList.add(TFHIRProperty.create(self, 'date', 'date', false, TFhirDate, FDate.Link));
  oList.add(TFHIRProperty.create(self, 'sourceIdentityCertificate', 'string', false, TFhirString, FSourceIdentityCertificate.Link));
  oList.add(TFHIRProperty.create(self, 'proxyIdentityCertificate', 'string', false, TFhirString, FProxyIdentityCertificate.Link));
  oList.add(TFHIRProperty.create(self, 'proxySignature', 'Signature', false, TFhirSignature, FProxySignature.Link));
  oList.add(TFHIRProperty.create(self, 'sourceSignature', 'Signature', false, TFhirSignature, FSourceSignature.Link));
end;

function TFhirVerificationResultAttestation.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'who') then
  begin
    Who := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'onBehalfOf') then
  begin
    OnBehalfOf := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'communicationMethod') then
  begin
    CommunicationMethod := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'date') then
  begin
    DateElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'sourceIdentityCertificate') then
  begin
    SourceIdentityCertificateElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'proxyIdentityCertificate') then
  begin
    ProxyIdentityCertificateElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'proxySignature') then
  begin
    ProxySignature := propValue as TFhirSignature;
    result := propValue;
  end
  else if (propName = 'sourceSignature') then
  begin
    SourceSignature := propValue as TFhirSignature;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResultAttestation.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirVerificationResultAttestation.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'who') then result := TFhirReference.create()
  else if (propName = 'onBehalfOf') then result := TFhirReference.create()
  else if (propName = 'communicationMethod') then result := TFhirCodeableConcept.create()
  else if (propName = 'date') then result := TFhirDate.create()
  else if (propName = 'sourceIdentityCertificate') then result := TFhirString.create()
  else if (propName = 'proxyIdentityCertificate') then result := TFhirString.create()
  else if (propName = 'proxySignature') then result := TFhirSignature.create()
  else if (propName = 'sourceSignature') then result := TFhirSignature.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResultAttestation.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'who') then result := 'Reference'
  else if (propName = 'onBehalfOf') then result := 'Reference'
  else if (propName = 'communicationMethod') then result := 'CodeableConcept'
  else if (propName = 'date') then result := 'date'
  else if (propName = 'sourceIdentityCertificate') then result := 'string'
  else if (propName = 'proxyIdentityCertificate') then result := 'string'
  else if (propName = 'proxySignature') then result := 'Signature'
  else if (propName = 'sourceSignature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResultAttestation.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := nil
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := nil
  else if (propName = 'communicationMethod') then CommunicationMethodElement := nil
  else if (propName = 'date') then DateElement := nil
  else if (propName = 'sourceIdentityCertificate') then SourceIdentityCertificateElement := nil
  else if (propName = 'proxyIdentityCertificate') then ProxyIdentityCertificateElement := nil
  else if (propName = 'proxySignature') then ProxySignatureElement := nil
  else if (propName = 'sourceSignature') then SourceSignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResultAttestation.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'who') then WhoElement := new as TFhirReference
  else if (propName = 'onBehalfOf') then OnBehalfOfElement := new as TFhirReference
  else if (propName = 'communicationMethod') then CommunicationMethodElement := new as TFhirCodeableConcept
  else if (propName = 'date') then DateElement := asDate(new)
  else if (propName = 'sourceIdentityCertificate') then SourceIdentityCertificateElement := asString(new)
  else if (propName = 'proxyIdentityCertificate') then ProxyIdentityCertificateElement := asString(new)
  else if (propName = 'proxySignature') then ProxySignatureElement := new as TFhirSignature
  else if (propName = 'sourceSignature') then SourceSignatureElement := new as TFhirSignature
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResultAttestation.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResultAttestation.fhirType : string;
begin
  result := 'VerificationResult.attestation';
end;

function TFhirVerificationResultAttestation.Link : TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(inherited Link);
end;

function TFhirVerificationResultAttestation.Clone : TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(inherited Clone);
end;

function TFhirVerificationResultAttestation.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResultAttestation;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResultAttestation)) then
    result := false
  else
  begin
    o := TFhirVerificationResultAttestation(other);
    result := compareDeep(whoElement, o.whoElement, true) and compareDeep(onBehalfOfElement, o.onBehalfOfElement, true) and 
      compareDeep(communicationMethodElement, o.communicationMethodElement, true) and 
      compareDeep(dateElement, o.dateElement, true) and compareDeep(sourceIdentityCertificateElement, o.sourceIdentityCertificateElement, true) and 
      compareDeep(proxyIdentityCertificateElement, o.proxyIdentityCertificateElement, true) and 
      compareDeep(proxySignatureElement, o.proxySignatureElement, true) and compareDeep(sourceSignatureElement, o.sourceSignatureElement, true);
  end;
end;

function TFhirVerificationResultAttestation.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FWho) and isEmptyProp(FOnBehalfOf) and isEmptyProp(FCommunicationMethod) and isEmptyProp(FDate) and isEmptyProp(FSourceIdentityCertificate) and isEmptyProp(FProxyIdentityCertificate) and isEmptyProp(FProxySignature) and isEmptyProp(FSourceSignature);
end;

procedure TFhirVerificationResultAttestation.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('who');
  fields.add('onBehalfOf');
  fields.add('communicationMethod');
  fields.add('date');
  fields.add('sourceIdentityCertificate');
  fields.add('proxyIdentityCertificate');
  fields.add('proxySignature');
  fields.add('sourceSignature');
end;

function TFhirVerificationResultAttestation.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirVerificationResultAttestation.SetWho(value : TFhirReference);
begin
  FWho.free;
  FWho := value;
end;

procedure TFhirVerificationResultAttestation.SetOnBehalfOf(value : TFhirReference);
begin
  FOnBehalfOf.free;
  FOnBehalfOf := value;
end;

procedure TFhirVerificationResultAttestation.SetCommunicationMethod(value : TFhirCodeableConcept);
begin
  FCommunicationMethod.free;
  FCommunicationMethod := value;
end;

procedure TFhirVerificationResultAttestation.SetDate(value : TFhirDate);
begin
  FDate.free;
  FDate := value;
end;

function TFhirVerificationResultAttestation.GetDateST : TFslDateTime;
begin
  if FDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FDate.value;
end;

procedure TFhirVerificationResultAttestation.SetDateST(value : TFslDateTime);
begin
  if FDate = nil then
    FDate := TFhirDate.create;
  FDate.value := value
end;

procedure TFhirVerificationResultAttestation.SetSourceIdentityCertificate(value : TFhirString);
begin
  FSourceIdentityCertificate.free;
  FSourceIdentityCertificate := value;
end;

function TFhirVerificationResultAttestation.GetSourceIdentityCertificateST : String;
begin
  if FSourceIdentityCertificate = nil then
    result := ''
  else
    result := FSourceIdentityCertificate.value;
end;

procedure TFhirVerificationResultAttestation.SetSourceIdentityCertificateST(value : String);
begin
  if value <> '' then
  begin
    if FSourceIdentityCertificate = nil then
      FSourceIdentityCertificate := TFhirString.create;
    FSourceIdentityCertificate.value := value
  end
  else if FSourceIdentityCertificate <> nil then
    FSourceIdentityCertificate.value := '';
end;

procedure TFhirVerificationResultAttestation.SetProxyIdentityCertificate(value : TFhirString);
begin
  FProxyIdentityCertificate.free;
  FProxyIdentityCertificate := value;
end;

function TFhirVerificationResultAttestation.GetProxyIdentityCertificateST : String;
begin
  if FProxyIdentityCertificate = nil then
    result := ''
  else
    result := FProxyIdentityCertificate.value;
end;

procedure TFhirVerificationResultAttestation.SetProxyIdentityCertificateST(value : String);
begin
  if value <> '' then
  begin
    if FProxyIdentityCertificate = nil then
      FProxyIdentityCertificate := TFhirString.create;
    FProxyIdentityCertificate.value := value
  end
  else if FProxyIdentityCertificate <> nil then
    FProxyIdentityCertificate.value := '';
end;

procedure TFhirVerificationResultAttestation.SetProxySignature(value : TFhirSignature);
begin
  FProxySignature.free;
  FProxySignature := value;
end;

procedure TFhirVerificationResultAttestation.SetSourceSignature(value : TFhirSignature);
begin
  FSourceSignature.free;
  FSourceSignature := value;
end;

{ TFhirVerificationResultAttestationListEnumerator }

constructor TFhirVerificationResultAttestationListEnumerator.Create(list : TFhirVerificationResultAttestationList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultAttestationListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultAttestationListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultAttestationListEnumerator.GetCurrent : TFhirVerificationResultAttestation;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultAttestationListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVerificationResultAttestationList }

function TFhirVerificationResultAttestationList.AddItem(value: TFhirVerificationResultAttestation): TFhirVerificationResultAttestation;
begin
  assert(value.ClassName = 'TFhirVerificationResultAttestation', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResultAttestation');
  add(value);
  result := value;
end;

function TFhirVerificationResultAttestationList.Append: TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultAttestationList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultAttestationList.GetEnumerator : TFhirVerificationResultAttestationListEnumerator;
begin
  result := TFhirVerificationResultAttestationListEnumerator.Create(self.link);
end;

function TFhirVerificationResultAttestationList.Clone: TFhirVerificationResultAttestationList;
begin
  result := TFhirVerificationResultAttestationList(inherited Clone);
end;

function TFhirVerificationResultAttestationList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultAttestationList.GetItemN(index: Integer): TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(ObjectByIndex[index]);
end;

function TFhirVerificationResultAttestationList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResultAttestation;
end;
function TFhirVerificationResultAttestationList.IndexOf(value: TFhirVerificationResultAttestation): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultAttestationList.Insert(index: Integer): TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultAttestationList.InsertItem(index: Integer; value: TFhirVerificationResultAttestation);
begin
  assert(value is TFhirVerificationResultAttestation);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultAttestationList.Item(index: Integer): TFhirVerificationResultAttestation;
begin
  result := TFhirVerificationResultAttestation(ObjectByIndex[index]);
end;

function TFhirVerificationResultAttestationList.Link: TFhirVerificationResultAttestationList;
begin
  result := TFhirVerificationResultAttestationList(inherited Link);
end;

procedure TFhirVerificationResultAttestationList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultAttestationList.SetItemByIndex(index: Integer; value: TFhirVerificationResultAttestation);
begin
  assert(value is TFhirVerificationResultAttestation);
  FhirVerificationResultAttestations[index] := value;
end;

procedure TFhirVerificationResultAttestationList.SetItemN(index: Integer; value: TFhirVerificationResultAttestation);
begin
  assert(value is TFhirVerificationResultAttestation);
  ObjectByIndex[index] := value;
end;

{ TFhirVerificationResultValidator }

constructor TFhirVerificationResultValidator.Create;
begin
  inherited;
end;

destructor TFhirVerificationResultValidator.Destroy;
begin
  FOrganization.free;
  FIdentityCertificate.free;
  FAttestationSignature.free;
  inherited;
end;

procedure TFhirVerificationResultValidator.Assign(oSource : TFslObject);
begin
  inherited;
  organization := TFhirVerificationResultValidator(oSource).organization.Clone;
  identityCertificateElement := TFhirVerificationResultValidator(oSource).identityCertificateElement.Clone;
  attestationSignature := TFhirVerificationResultValidator(oSource).attestationSignature.Clone;
end;

procedure TFhirVerificationResultValidator.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'organization') Then
     list.add(self.link, 'organization', FOrganization.Link);
  if (child_name = 'identityCertificate') Then
     list.add(self.link, 'identityCertificate', FIdentityCertificate.Link);
  if (child_name = 'attestationSignature') Then
     list.add(self.link, 'attestationSignature', FAttestationSignature.Link);
end;

procedure TFhirVerificationResultValidator.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'organization', 'Reference', false, TFhirReference, FOrganization.Link));
  oList.add(TFHIRProperty.create(self, 'identityCertificate', 'string', false, TFhirString, FIdentityCertificate.Link));
  oList.add(TFHIRProperty.create(self, 'attestationSignature', 'Signature', false, TFhirSignature, FAttestationSignature.Link));
end;

function TFhirVerificationResultValidator.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'organization') then
  begin
    Organization := propValue as TFhirReference;
    result := propValue;
  end
  else if (propName = 'identityCertificate') then
  begin
    IdentityCertificateElement := asString(propValue);
    result := propValue;
  end
  else if (propName = 'attestationSignature') then
  begin
    AttestationSignature := propValue as TFhirSignature;
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResultValidator.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  inherited;
end;

function TFhirVerificationResultValidator.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'organization') then result := TFhirReference.create()
  else if (propName = 'identityCertificate') then result := TFhirString.create()
  else if (propName = 'attestationSignature') then result := TFhirSignature.create()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResultValidator.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'organization') then result := 'Reference'
  else if (propName = 'identityCertificate') then result := 'string'
  else if (propName = 'attestationSignature') then result := 'Signature'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResultValidator.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'organization') then OrganizationElement := nil
  else if (propName = 'identityCertificate') then IdentityCertificateElement := nil
  else if (propName = 'attestationSignature') then AttestationSignatureElement := nil
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResultValidator.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'organization') then OrganizationElement := new as TFhirReference
  else if (propName = 'identityCertificate') then IdentityCertificateElement := asString(new)
  else if (propName = 'attestationSignature') then AttestationSignatureElement := new as TFhirSignature
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResultValidator.reorderProperty(propName : string; source, destination : integer);
begin
  inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResultValidator.fhirType : string;
begin
  result := 'VerificationResult.validator';
end;

function TFhirVerificationResultValidator.Link : TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(inherited Link);
end;

function TFhirVerificationResultValidator.Clone : TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(inherited Clone);
end;

function TFhirVerificationResultValidator.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResultValidator;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResultValidator)) then
    result := false
  else
  begin
    o := TFhirVerificationResultValidator(other);
    result := compareDeep(organizationElement, o.organizationElement, true) and 
      compareDeep(identityCertificateElement, o.identityCertificateElement, true) and 
      compareDeep(attestationSignatureElement, o.attestationSignatureElement, true);
  end;
end;

function TFhirVerificationResultValidator.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FOrganization) and isEmptyProp(FIdentityCertificate) and isEmptyProp(FAttestationSignature);
end;

procedure TFhirVerificationResultValidator.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('organization');
  fields.add('identityCertificate');
  fields.add('attestationSignature');
end;

function TFhirVerificationResultValidator.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
end;

procedure TFhirVerificationResultValidator.SetOrganization(value : TFhirReference);
begin
  FOrganization.free;
  FOrganization := value;
end;

procedure TFhirVerificationResultValidator.SetIdentityCertificate(value : TFhirString);
begin
  FIdentityCertificate.free;
  FIdentityCertificate := value;
end;

function TFhirVerificationResultValidator.GetIdentityCertificateST : String;
begin
  if FIdentityCertificate = nil then
    result := ''
  else
    result := FIdentityCertificate.value;
end;

procedure TFhirVerificationResultValidator.SetIdentityCertificateST(value : String);
begin
  if value <> '' then
  begin
    if FIdentityCertificate = nil then
      FIdentityCertificate := TFhirString.create;
    FIdentityCertificate.value := value
  end
  else if FIdentityCertificate <> nil then
    FIdentityCertificate.value := '';
end;

procedure TFhirVerificationResultValidator.SetAttestationSignature(value : TFhirSignature);
begin
  FAttestationSignature.free;
  FAttestationSignature := value;
end;

{ TFhirVerificationResultValidatorListEnumerator }

constructor TFhirVerificationResultValidatorListEnumerator.Create(list : TFhirVerificationResultValidatorList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultValidatorListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultValidatorListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultValidatorListEnumerator.GetCurrent : TFhirVerificationResultValidator;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultValidatorListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVerificationResultValidatorList }

function TFhirVerificationResultValidatorList.AddItem(value: TFhirVerificationResultValidator): TFhirVerificationResultValidator;
begin
  assert(value.ClassName = 'TFhirVerificationResultValidator', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResultValidator');
  add(value);
  result := value;
end;

function TFhirVerificationResultValidatorList.Append: TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultValidatorList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultValidatorList.GetEnumerator : TFhirVerificationResultValidatorListEnumerator;
begin
  result := TFhirVerificationResultValidatorListEnumerator.Create(self.link);
end;

function TFhirVerificationResultValidatorList.Clone: TFhirVerificationResultValidatorList;
begin
  result := TFhirVerificationResultValidatorList(inherited Clone);
end;

function TFhirVerificationResultValidatorList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultValidatorList.GetItemN(index: Integer): TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(ObjectByIndex[index]);
end;

function TFhirVerificationResultValidatorList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResultValidator;
end;
function TFhirVerificationResultValidatorList.IndexOf(value: TFhirVerificationResultValidator): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultValidatorList.Insert(index: Integer): TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultValidatorList.InsertItem(index: Integer; value: TFhirVerificationResultValidator);
begin
  assert(value is TFhirVerificationResultValidator);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultValidatorList.Item(index: Integer): TFhirVerificationResultValidator;
begin
  result := TFhirVerificationResultValidator(ObjectByIndex[index]);
end;

function TFhirVerificationResultValidatorList.Link: TFhirVerificationResultValidatorList;
begin
  result := TFhirVerificationResultValidatorList(inherited Link);
end;

procedure TFhirVerificationResultValidatorList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultValidatorList.SetItemByIndex(index: Integer; value: TFhirVerificationResultValidator);
begin
  assert(value is TFhirVerificationResultValidator);
  FhirVerificationResultValidators[index] := value;
end;

procedure TFhirVerificationResultValidatorList.SetItemN(index: Integer; value: TFhirVerificationResultValidator);
begin
  assert(value is TFhirVerificationResultValidator);
  ObjectByIndex[index] := value;
end;

{ TFhirVerificationResult }

constructor TFhirVerificationResult.Create;
begin
  inherited;
end;

destructor TFhirVerificationResult.Destroy;
begin
  FTargetList.Free;
  FTargetLocationList.Free;
  FNeed.free;
  FStatus.free;
  FStatusDate.free;
  FValidationType.free;
  FValidationProcessList.Free;
  FFrequency.free;
  FLastPerformed.free;
  FNextScheduled.free;
  FFailureAction.free;
  FPrimarySourceList.Free;
  FAttestation.free;
  FValidatorList.Free;
  inherited;
end;

procedure TFhirVerificationResult.Assign(oSource : TFslObject);
begin
  inherited;
  if (TFhirVerificationResult(oSource).FTargetList = nil) then
  begin
    FTargetList.free;
    FTargetList := nil;
  end
  else
  begin
    if FTargetList = nil then
      FTargetList := TFhirReferenceList.Create;
    FTargetList.Assign(TFhirVerificationResult(oSource).FTargetList);
  end;
  if (TFhirVerificationResult(oSource).FTargetLocationList = nil) then
  begin
    FTargetLocationList.free;
    FTargetLocationList := nil;
  end
  else
  begin
    if FTargetLocationList = nil then
      FTargetLocationList := TFhirStringList.Create;
    FTargetLocationList.Assign(TFhirVerificationResult(oSource).FTargetLocationList);
  end;
  need := TFhirVerificationResult(oSource).need.Clone;
  statusElement := TFhirVerificationResult(oSource).statusElement.Clone;
  statusDateElement := TFhirVerificationResult(oSource).statusDateElement.Clone;
  validationType := TFhirVerificationResult(oSource).validationType.Clone;
  if (TFhirVerificationResult(oSource).FValidationProcessList = nil) then
  begin
    FValidationProcessList.free;
    FValidationProcessList := nil;
  end
  else
  begin
    if FValidationProcessList = nil then
      FValidationProcessList := TFhirCodeableConceptList.Create;
    FValidationProcessList.Assign(TFhirVerificationResult(oSource).FValidationProcessList);
  end;
  frequency := TFhirVerificationResult(oSource).frequency.Clone;
  lastPerformedElement := TFhirVerificationResult(oSource).lastPerformedElement.Clone;
  nextScheduledElement := TFhirVerificationResult(oSource).nextScheduledElement.Clone;
  failureAction := TFhirVerificationResult(oSource).failureAction.Clone;
  if (TFhirVerificationResult(oSource).FPrimarySourceList = nil) then
  begin
    FPrimarySourceList.free;
    FPrimarySourceList := nil;
  end
  else
  begin
    if FPrimarySourceList = nil then
      FPrimarySourceList := TFhirVerificationResultPrimarySourceList.Create;
    FPrimarySourceList.Assign(TFhirVerificationResult(oSource).FPrimarySourceList);
  end;
  attestation := TFhirVerificationResult(oSource).attestation.Clone;
  if (TFhirVerificationResult(oSource).FValidatorList = nil) then
  begin
    FValidatorList.free;
    FValidatorList := nil;
  end
  else
  begin
    if FValidatorList = nil then
      FValidatorList := TFhirVerificationResultValidatorList.Create;
    FValidatorList.Assign(TFhirVerificationResult(oSource).FValidatorList);
  end;
end;

function TFhirVerificationResult.GetResourceType : TFhirResourceType;
begin
  result := frtVerificationResult;
end;

procedure TFhirVerificationResult.GetChildrenByName(child_name : string; list : TFHIRSelectionList);
begin
  inherited;
  if (child_name = 'target') Then
    list.addAll(self, 'target', FTargetList);
  if (child_name = 'targetLocation') Then
    list.addAll(self, 'targetLocation', FTargetLocationList);
  if (child_name = 'need') Then
     list.add(self.link, 'need', FNeed.Link);
  if (child_name = 'status') Then
     list.add(self.link, 'status', FStatus.Link);
  if (child_name = 'statusDate') Then
     list.add(self.link, 'statusDate', FStatusDate.Link);
  if (child_name = 'validationType') Then
     list.add(self.link, 'validationType', FValidationType.Link);
  if (child_name = 'validationProcess') Then
    list.addAll(self, 'validationProcess', FValidationProcessList);
  if (child_name = 'frequency') Then
     list.add(self.link, 'frequency', FFrequency.Link);
  if (child_name = 'lastPerformed') Then
     list.add(self.link, 'lastPerformed', FLastPerformed.Link);
  if (child_name = 'nextScheduled') Then
     list.add(self.link, 'nextScheduled', FNextScheduled.Link);
  if (child_name = 'failureAction') Then
     list.add(self.link, 'failureAction', FFailureAction.Link);
  if (child_name = 'primarySource') Then
    list.addAll(self, 'primarySource', FPrimarySourceList);
  if (child_name = 'attestation') Then
     list.add(self.link, 'attestation', FAttestation.Link);
  if (child_name = 'validator') Then
    list.addAll(self, 'validator', FValidatorList);
end;

procedure TFhirVerificationResult.ListProperties(oList: TFHIRPropertyList; bInheritedProperties, bPrimitiveValues: Boolean);
begin
  inherited;
  oList.add(TFHIRProperty.create(self, 'target', 'Reference', true, TFhirReference, FTargetList.Link));
  oList.add(TFHIRProperty.create(self, 'targetLocation', 'string', true, TFhirString, FTargetLocationList.Link));
  oList.add(TFHIRProperty.create(self, 'need', 'CodeableConcept', false, TFhirCodeableConcept, FNeed.Link));
  oList.add(TFHIRProperty.create(self, 'status', 'code', false, TFhirEnum, FStatus.Link));
  oList.add(TFHIRProperty.create(self, 'statusDate', 'dateTime', false, TFhirDateTime, FStatusDate.Link));
  oList.add(TFHIRProperty.create(self, 'validationType', 'CodeableConcept', false, TFhirCodeableConcept, FValidationType.Link));
  oList.add(TFHIRProperty.create(self, 'validationProcess', 'CodeableConcept', true, TFhirCodeableConcept, FValidationProcessList.Link));
  oList.add(TFHIRProperty.create(self, 'frequency', 'Timing', false, TFhirTiming, FFrequency.Link));
  oList.add(TFHIRProperty.create(self, 'lastPerformed', 'dateTime', false, TFhirDateTime, FLastPerformed.Link));
  oList.add(TFHIRProperty.create(self, 'nextScheduled', 'date', false, TFhirDate, FNextScheduled.Link));
  oList.add(TFHIRProperty.create(self, 'failureAction', 'CodeableConcept', false, TFhirCodeableConcept, FFailureAction.Link));
  oList.add(TFHIRProperty.create(self, 'primarySource', 'BackboneElement', true, TFhirVerificationResultPrimarySource, FPrimarySourceList.Link));
  oList.add(TFHIRProperty.create(self, 'attestation', 'BackboneElement', false, TFhirVerificationResultAttestation, FAttestation.Link));
  oList.add(TFHIRProperty.create(self, 'validator', 'BackboneElement', true, TFhirVerificationResultValidator, FValidatorList.Link));
end;

function TFhirVerificationResult.setProperty(propName : string; propValue: TFHIRObject) : TFHIRObject;
begin
  if (propName = 'target') then
  begin
    TargetList.add(propValue as TFhirReference);
    result := propValue;
  end
  else if (propName = 'targetLocation') then
  begin
    TargetLocationList.add(asString(propValue)){2};     result := propValue;

  end
  else if (propName = 'need') then
  begin
    Need := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'status') then
  begin
    StatusElement := asEnum(SYSTEMS_TFhirStatusEnum, CODES_TFhirStatusEnum, propValue);
    result := propValue;
  end
  else if (propName = 'statusDate') then
  begin
    StatusDateElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'validationType') then
  begin
    ValidationType := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'validationProcess') then
  begin
    ValidationProcessList.add(propValue as TFhirCodeableConcept);
    result := propValue;
  end
  else if (propName = 'frequency') then
  begin
    Frequency := propValue as TFhirTiming;
    result := propValue;
  end
  else if (propName = 'lastPerformed') then
  begin
    LastPerformedElement := asDateTime(propValue);
    result := propValue;
  end
  else if (propName = 'nextScheduled') then
  begin
    NextScheduledElement := asDate(propValue);
    result := propValue;
  end
  else if (propName = 'failureAction') then
  begin
    FailureAction := propValue as TFhirCodeableConcept;
    result := propValue;
  end
  else if (propName = 'primarySource') then
  begin
    PrimarySourceList.add(propValue as TFhirVerificationResultPrimarySource);
    result := propValue;
  end
  else if (propName = 'attestation') then
  begin
    Attestation := propValue as TFhirVerificationResultAttestation;
    result := propValue;
  end
  else if (propName = 'validator') then
  begin
    ValidatorList.add(propValue as TFhirVerificationResultValidator);
    result := propValue;
  end
  else result := inherited setProperty(propName, propValue);
end;

procedure TFhirVerificationResult.insertProperty(propName: string; propValue: TFHIRObject; index : integer);
begin
  if (propName = 'target') then TargetList.insertItem(index, propValue as TFhirReference)
  else if (propName = 'targetLocation') then TargetLocationList.insertItem(index, asString(propValue))
  else if (propName = 'validationProcess') then ValidationProcessList.insertItem(index, propValue as TFhirCodeableConcept)
  else if (propName = 'primarySource') then PrimarySourceList.insertItem(index, propValue as TFhirVerificationResultPrimarySource)
  else if (propName = 'validator') then ValidatorList.insertItem(index, propValue as TFhirVerificationResultValidator)
  else inherited;
end;

function TFhirVerificationResult.createPropertyValue(propName : string) : TFHIRObject;
begin
  if (propName = 'target') then result := TargetList.new()
  else if (propName = 'targetLocation') then result := TargetLocationList.new()
  else if (propName = 'need') then result := TFhirCodeableConcept.create()
  else if (propName = 'status') then result := TFhirEnum.create(SYSTEMS_TFhirStatusEnum[StatusNull], CODES_TFhirStatusEnum[StatusNull]) 
  else if (propName = 'statusDate') then result := TFhirDateTime.create()
  else if (propName = 'validationType') then result := TFhirCodeableConcept.create()
  else if (propName = 'validationProcess') then result := ValidationProcessList.new()
  else if (propName = 'frequency') then result := TFhirTiming.create()
  else if (propName = 'lastPerformed') then result := TFhirDateTime.create()
  else if (propName = 'nextScheduled') then result := TFhirDate.create()
  else if (propName = 'failureAction') then result := TFhirCodeableConcept.create()
  else if (propName = 'primarySource') then result := PrimarySourceList.new()
  else if (propName = 'attestation') then result := TFhirVerificationResultAttestation.create()
  else if (propName = 'validator') then result := ValidatorList.new()
  else result := inherited createPropertyValue(propName);
end;

function TFhirVerificationResult.getTypesForProperty(propName: string) : String;
begin
  if (propName = 'target') then result := 'Reference'
  else if (propName = 'targetLocation') then result := 'string'
  else if (propName = 'need') then result := 'CodeableConcept'
  else if (propName = 'status') then result := 'code'
  else if (propName = 'statusDate') then result := 'dateTime'
  else if (propName = 'validationType') then result := 'CodeableConcept'
  else if (propName = 'validationProcess') then result := 'CodeableConcept'
  else if (propName = 'frequency') then result := 'Timing'
  else if (propName = 'lastPerformed') then result := 'dateTime'
  else if (propName = 'nextScheduled') then result := 'date'
  else if (propName = 'failureAction') then result := 'CodeableConcept'
  else if (propName = 'primarySource') then result := 'BackboneElement'
  else if (propName = 'attestation') then result := 'BackboneElement'
  else if (propName = 'validator') then result := 'BackboneElement'
  else result := inherited getTypesForProperty(propName);
end;

procedure TFhirVerificationResult.deleteProperty(propName: string; value : TFHIRObject);
begin
  if (propName = 'target') then deletePropertyValue('target', TargetList, value)
  else if (propName = 'targetLocation') then deletePropertyValue('targetLocation', TargetLocationList, value)
  else if (propName = 'need') then NeedElement := nil
  else if (propName = 'status') then StatusElement := nil
  else if (propName = 'statusDate') then StatusDateElement := nil
  else if (propName = 'validationType') then ValidationTypeElement := nil
  else if (propName = 'validationProcess') then deletePropertyValue('validationProcess', ValidationProcessList, value)
  else if (propName = 'frequency') then FrequencyElement := nil
  else if (propName = 'lastPerformed') then LastPerformedElement := nil
  else if (propName = 'nextScheduled') then NextScheduledElement := nil
  else if (propName = 'failureAction') then FailureActionElement := nil
  else if (propName = 'primarySource') then deletePropertyValue('primarySource', PrimarySourceList, value)
  else if (propName = 'attestation') then AttestationElement := nil
  else if (propName = 'validator') then deletePropertyValue('validator', ValidatorList, value)
  else
    inherited deleteProperty(propName, value);
end;

procedure TFhirVerificationResult.replaceProperty(propName : string; existing, new : TFHIRObject);
begin
  if (propName = 'target') then replacePropertyValue('target', TargetList, existing, new)
  else if (propName = 'targetLocation') then replacePropertyValue('targetLocation', TargetLocationList, existing, new)
  else if (propName = 'need') then NeedElement := new as TFhirCodeableConcept
  else if (propName = 'status') then StatusElement := asEnum(SYSTEMS_TFhirStatusEnum, CODES_TFhirStatusEnum, new)
  else if (propName = 'statusDate') then StatusDateElement := asDateTime(new)
  else if (propName = 'validationType') then ValidationTypeElement := new as TFhirCodeableConcept
  else if (propName = 'validationProcess') then replacePropertyValue('validationProcess', ValidationProcessList, existing, new)
  else if (propName = 'frequency') then FrequencyElement := new as TFhirTiming
  else if (propName = 'lastPerformed') then LastPerformedElement := asDateTime(new)
  else if (propName = 'nextScheduled') then NextScheduledElement := asDate(new)
  else if (propName = 'failureAction') then FailureActionElement := new as TFhirCodeableConcept
  else if (propName = 'primarySource') then replacePropertyValue('primarySource', PrimarySourceList, existing, new)
  else if (propName = 'attestation') then AttestationElement := new as TFhirVerificationResultAttestation
  else if (propName = 'validator') then replacePropertyValue('validator', ValidatorList, existing, new)
  else
    inherited replaceProperty(propName, existing, new);
end;

procedure TFhirVerificationResult.reorderProperty(propName : string; source, destination : integer);
begin
  if (propName = 'target') then TargetList.move(source, destination)
  else if (propName = 'targetLocation') then TargetLocationList.move(source, destination)
  else if (propName = 'validationProcess') then ValidationProcessList.move(source, destination)
  else if (propName = 'primarySource') then PrimarySourceList.move(source, destination)
  else if (propName = 'validator') then ValidatorList.move(source, destination)
  else
    inherited reorderProperty(propName, source, destination);
end;

function TFhirVerificationResult.fhirType : string;
begin
  result := 'VerificationResult';
end;

function TFhirVerificationResult.Link : TFhirVerificationResult;
begin
  result := TFhirVerificationResult(inherited Link);
end;

function TFhirVerificationResult.Clone : TFhirVerificationResult;
begin
  result := TFhirVerificationResult(inherited Clone);
end;

function TFhirVerificationResult.equals(other : TObject) : boolean; 
var
  o : TFhirVerificationResult;
begin
  if (not inherited equals(other)) then
    result := false
  else if (not (other is TFhirVerificationResult)) then
    result := false
  else
  begin
    o := TFhirVerificationResult(other);
    result := compareDeep(targetList, o.targetList, true) and compareDeep(targetLocationList, o.targetLocationList, true) and 
      compareDeep(needElement, o.needElement, true) and compareDeep(statusElement, o.statusElement, true) and 
      compareDeep(statusDateElement, o.statusDateElement, true) and compareDeep(validationTypeElement, o.validationTypeElement, true) and 
      compareDeep(validationProcessList, o.validationProcessList, true) and compareDeep(frequencyElement, o.frequencyElement, true) and 
      compareDeep(lastPerformedElement, o.lastPerformedElement, true) and compareDeep(nextScheduledElement, o.nextScheduledElement, true) and 
      compareDeep(failureActionElement, o.failureActionElement, true) and compareDeep(primarySourceList, o.primarySourceList, true) and 
      compareDeep(attestationElement, o.attestationElement, true) and compareDeep(validatorList, o.validatorList, true);
  end;
end;

function TFhirVerificationResult.isEmpty : boolean;
begin
  result := inherited isEmpty  and isEmptyProp(FtargetList) and isEmptyProp(FtargetLocationList) and isEmptyProp(FNeed) and isEmptyProp(FStatus) and isEmptyProp(FStatusDate) and isEmptyProp(FValidationType) and isEmptyProp(FvalidationProcessList) and isEmptyProp(FFrequency) and isEmptyProp(FLastPerformed) and isEmptyProp(FNextScheduled) and isEmptyProp(FFailureAction) and isEmptyProp(FprimarySourceList) and isEmptyProp(FAttestation) and isEmptyProp(FvalidatorList);
end;

procedure TFhirVerificationResult.listFieldsInOrder(fields : TStringList);
begin;
  inherited listFieldsInOrder(fields);
  fields.add('target');
  fields.add('targetLocation');
  fields.add('need');
  fields.add('status');
  fields.add('statusDate');
  fields.add('validationType');
  fields.add('validationProcess');
  fields.add('frequency');
  fields.add('lastPerformed');
  fields.add('nextScheduled');
  fields.add('failureAction');
  fields.add('primarySource');
  fields.add('attestation');
  fields.add('validator');
end;

function TFhirVerificationResult.sizeInBytesV(magic : integer) : cardinal;
begin;
  result := inherited sizeInBytesV(magic);
  inc(result, FTargetList.sizeInBytes(magic));
  inc(result, FTargetLocationList.sizeInBytes(magic));
  inc(result, FValidationProcessList.sizeInBytes(magic));
  inc(result, FPrimarySourceList.sizeInBytes(magic));
  inc(result, FValidatorList.sizeInBytes(magic));
end;

function TFhirVerificationResult.GetTargetList : TFhirReferenceList;
begin
  if FTargetList = nil then
    FTargetList := TFhirReferenceList.Create;
  result := FTargetList;
end;

function TFhirVerificationResult.GetHasTargetList : boolean;
begin
  result := (FTargetList <> nil) and (FTargetList.count > 0);
end;

function TFhirVerificationResult.GetTargetLocationList : TFhirStringList;
begin
  if FTargetLocationList = nil then
    FTargetLocationList := TFhirStringList.Create;
  result := FTargetLocationList;
end;

function TFhirVerificationResult.GetHasTargetLocationList : boolean;
begin
  result := (FTargetLocationList <> nil) and (FTargetLocationList.count > 0);
end;

procedure TFhirVerificationResult.SetNeed(value : TFhirCodeableConcept);
begin
  FNeed.free;
  FNeed := value;
end;

procedure TFhirVerificationResult.SetStatus(value : TFhirEnum);
begin
  FStatus.free;
  FStatus := value;
end;

function TFhirVerificationResult.GetStatusST : TFhirStatusEnum;
begin
  if FStatus = nil then
    result := TFhirStatusEnum(0)
  else
    result := TFhirStatusEnum(StringArrayIndexOfSensitive(CODES_TFhirStatusEnum, FStatus.value));
end;

procedure TFhirVerificationResult.SetStatusST(value : TFhirStatusEnum);
begin
  if ord(value) = 0 then
    StatusElement := nil
  else
    StatusElement := TFhirEnum.create(SYSTEMS_TFhirStatusEnum[value], CODES_TFhirStatusEnum[value]);
end;

procedure TFhirVerificationResult.SetStatusDate(value : TFhirDateTime);
begin
  FStatusDate.free;
  FStatusDate := value;
end;

function TFhirVerificationResult.GetStatusDateST : TFslDateTime;
begin
  if FStatusDate = nil then
    result := TFslDateTime.makeNull
  else
    result := FStatusDate.value;
end;

procedure TFhirVerificationResult.SetStatusDateST(value : TFslDateTime);
begin
  if FStatusDate = nil then
    FStatusDate := TFhirDateTime.create;
  FStatusDate.value := value
end;

procedure TFhirVerificationResult.SetValidationType(value : TFhirCodeableConcept);
begin
  FValidationType.free;
  FValidationType := value;
end;

function TFhirVerificationResult.GetValidationProcessList : TFhirCodeableConceptList;
begin
  if FValidationProcessList = nil then
    FValidationProcessList := TFhirCodeableConceptList.Create;
  result := FValidationProcessList;
end;

function TFhirVerificationResult.GetHasValidationProcessList : boolean;
begin
  result := (FValidationProcessList <> nil) and (FValidationProcessList.count > 0);
end;

procedure TFhirVerificationResult.SetFrequency(value : TFhirTiming);
begin
  FFrequency.free;
  FFrequency := value;
end;

procedure TFhirVerificationResult.SetLastPerformed(value : TFhirDateTime);
begin
  FLastPerformed.free;
  FLastPerformed := value;
end;

function TFhirVerificationResult.GetLastPerformedST : TFslDateTime;
begin
  if FLastPerformed = nil then
    result := TFslDateTime.makeNull
  else
    result := FLastPerformed.value;
end;

procedure TFhirVerificationResult.SetLastPerformedST(value : TFslDateTime);
begin
  if FLastPerformed = nil then
    FLastPerformed := TFhirDateTime.create;
  FLastPerformed.value := value
end;

procedure TFhirVerificationResult.SetNextScheduled(value : TFhirDate);
begin
  FNextScheduled.free;
  FNextScheduled := value;
end;

function TFhirVerificationResult.GetNextScheduledST : TFslDateTime;
begin
  if FNextScheduled = nil then
    result := TFslDateTime.makeNull
  else
    result := FNextScheduled.value;
end;

procedure TFhirVerificationResult.SetNextScheduledST(value : TFslDateTime);
begin
  if FNextScheduled = nil then
    FNextScheduled := TFhirDate.create;
  FNextScheduled.value := value
end;

procedure TFhirVerificationResult.SetFailureAction(value : TFhirCodeableConcept);
begin
  FFailureAction.free;
  FFailureAction := value;
end;

function TFhirVerificationResult.GetPrimarySourceList : TFhirVerificationResultPrimarySourceList;
begin
  if FPrimarySourceList = nil then
    FPrimarySourceList := TFhirVerificationResultPrimarySourceList.Create;
  result := FPrimarySourceList;
end;

function TFhirVerificationResult.GetHasPrimarySourceList : boolean;
begin
  result := (FPrimarySourceList <> nil) and (FPrimarySourceList.count > 0);
end;

procedure TFhirVerificationResult.SetAttestation(value : TFhirVerificationResultAttestation);
begin
  FAttestation.free;
  FAttestation := value;
end;

function TFhirVerificationResult.GetValidatorList : TFhirVerificationResultValidatorList;
begin
  if FValidatorList = nil then
    FValidatorList := TFhirVerificationResultValidatorList.Create;
  result := FValidatorList;
end;

function TFhirVerificationResult.GetHasValidatorList : boolean;
begin
  result := (FValidatorList <> nil) and (FValidatorList.count > 0);
end;

{ TFhirVerificationResultListEnumerator }

constructor TFhirVerificationResultListEnumerator.Create(list : TFhirVerificationResultList);
begin
  inherited Create;
  FIndex := -1;
  FList := list;
end;

destructor TFhirVerificationResultListEnumerator.Destroy;
begin
  FList.Free;
  inherited;
end;

function TFhirVerificationResultListEnumerator.MoveNext : boolean;
begin
  inc(FIndex);
  Result := FIndex < FList.count;
end;

function TFhirVerificationResultListEnumerator.GetCurrent : TFhirVerificationResult;
begin
  Result := FList[FIndex];
end;

function TFhirVerificationResultListEnumerator.sizeInBytesV(magic : integer) : cardinal;
begin
  result := inherited sizeInBytesV(magic);
  inc(result, FList.sizeInBytes(magic));
end;

{ TFhirVerificationResultList }

function TFhirVerificationResultList.AddItem(value: TFhirVerificationResult): TFhirVerificationResult;
begin
  assert(value.ClassName = 'TFhirVerificationResult', 'Attempt to add an item of type '+value.ClassName+' to a List of TFhirVerificationResult');
  add(value);
  result := value;
end;

function TFhirVerificationResultList.Append: TFhirVerificationResult;
begin
  result := TFhirVerificationResult.create;
  try
    add(result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultList.ClearItems;
begin
  Clear;
end;

function TFhirVerificationResultList.GetEnumerator : TFhirVerificationResultListEnumerator;
begin
  result := TFhirVerificationResultListEnumerator.Create(self.link);
end;

function TFhirVerificationResultList.Clone: TFhirVerificationResultList;
begin
  result := TFhirVerificationResultList(inherited Clone);
end;

function TFhirVerificationResultList.Count: Integer;
begin
  result := Inherited Count;
end;

function TFhirVerificationResultList.GetItemN(index: Integer): TFhirVerificationResult;
begin
  result := TFhirVerificationResult(ObjectByIndex[index]);
end;

function TFhirVerificationResultList.ItemClass: TFslObjectClass;
begin
  result := TFhirVerificationResult;
end;
function TFhirVerificationResultList.IndexOf(value: TFhirVerificationResult): Integer;
begin
  result := IndexByReference(value);
end;

function TFhirVerificationResultList.Insert(index: Integer): TFhirVerificationResult;
begin
  result := TFhirVerificationResult.create;
  try
    inherited insert(index, result.Link);
  finally
    result.free;
  end;
end;

procedure TFhirVerificationResultList.InsertItem(index: Integer; value: TFhirVerificationResult);
begin
  assert(value is TFhirVerificationResult);
  Inherited Insert(index, value);
end;

function TFhirVerificationResultList.Item(index: Integer): TFhirVerificationResult;
begin
  result := TFhirVerificationResult(ObjectByIndex[index]);
end;

function TFhirVerificationResultList.Link: TFhirVerificationResultList;
begin
  result := TFhirVerificationResultList(inherited Link);
end;

procedure TFhirVerificationResultList.Remove(index: Integer);
begin
  DeleteByIndex(index);
end;

procedure TFhirVerificationResultList.SetItemByIndex(index: Integer; value: TFhirVerificationResult);
begin
  assert(value is TFhirVerificationResult);
  FhirVerificationResults[index] := value;
end;

procedure TFhirVerificationResultList.SetItemN(index: Integer; value: TFhirVerificationResult);
begin
  assert(value is TFhirVerificationResult);
  ObjectByIndex[index] := value;
end;

{$ENDIF FHIR_VERIFICATIONRESULT}


end.

